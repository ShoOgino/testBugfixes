{"path":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointBoxQuery#createWeight(IndexSearcher,boolean).mjava","commits":[{"id":"a61b5b0e4cf8ab04d7674f9ae117ddc60be22005","date":1461676641,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointBoxQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // We don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\".\n    // This is an inverted structure and should be used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n\n      private DocIdSetIterator buildMatchingIterator(LeafReader reader, PointValues values) throws IOException {\n        MatchingPoints result = new MatchingPoints(reader, field);\n\n        values.intersect(field,\n            new IntersectVisitor() {\n\n              @Override\n              public void visit(int docID) {\n                result.add(docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, lowerPoint, offset) < 0) {\n                    // Doc's value is too low, in this dimension\n                    return;\n                  }\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, upperPoint, offset) > 0) {\n                    // Doc's value is too high, in this dimension\n                    return;\n                  }\n                }\n\n                // Doc is in-bounds\n                result.add(docID);\n              }\n\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n                boolean crosses = false;\n\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n\n                  if (StringHelper.compare(bytesPerDim, minPackedValue, offset, upperPoint, offset) > 0 ||\n                      StringHelper.compare(bytesPerDim, maxPackedValue, offset, lowerPoint, offset) < 0) {\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  }\n\n                  crosses |= StringHelper.compare(bytesPerDim, minPackedValue, offset, lowerPoint, offset) < 0 ||\n                    StringHelper.compare(bytesPerDim, maxPackedValue, offset, upperPoint, offset) > 0;\n                }\n\n                if (crosses) {\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        return result.iterator();\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment indexed any points\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        if (fieldInfo.getPointDimensionCount() != numDims) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with numDims=\" + fieldInfo.getPointDimensionCount() + \" but this query has numDims=\" + numDims);\n        }\n        if (bytesPerDim != fieldInfo.getPointNumBytes()) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with bytesPerDim=\" + fieldInfo.getPointNumBytes() + \" but this query has bytesPerDim=\" + bytesPerDim);\n        }\n\n        boolean allDocsMatch;\n        if (values.getDocCount(field) == reader.maxDoc()) {\n          final byte[] fieldPackedLower = values.getMinPackedValue(field);\n          final byte[] fieldPackedUpper = values.getMaxPackedValue(field);\n          allDocsMatch = true;\n          for (int i = 0; i < numDims; ++i) {\n            int offset = i * bytesPerDim;\n            if (StringHelper.compare(bytesPerDim, lowerPoint, offset, fieldPackedLower, offset) > 0\n                || StringHelper.compare(bytesPerDim, upperPoint, offset, fieldPackedUpper, offset) < 0) {\n              allDocsMatch = false;\n              break;\n            }\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        DocIdSetIterator iterator;\n        if (allDocsMatch) {\n          // all docs have a value and all points are within bounds, so everything matches\n          iterator = DocIdSetIterator.all(reader.maxDoc());\n        } else {\n          iterator = buildMatchingIterator(reader, values);\n        }\n\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["f976862431a9be6f9f76f958b5a9a04aa2342747"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f7f901826e47f75f810d7aae24b0455d21ea1fe2","date":1461678892,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointBoxQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // We don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\".\n    // This is an inverted structure and should be used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n\n      private DocIdSetIterator buildMatchingIterator(LeafReader reader, PointValues values) throws IOException {\n        MatchingPoints result = new MatchingPoints(reader, field);\n\n        values.intersect(field,\n            new IntersectVisitor() {\n\n              @Override\n              public void visit(int docID) {\n                result.add(docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, lowerPoint, offset) < 0) {\n                    // Doc's value is too low, in this dimension\n                    return;\n                  }\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, upperPoint, offset) > 0) {\n                    // Doc's value is too high, in this dimension\n                    return;\n                  }\n                }\n\n                // Doc is in-bounds\n                result.add(docID);\n              }\n\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n                boolean crosses = false;\n\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n\n                  if (StringHelper.compare(bytesPerDim, minPackedValue, offset, upperPoint, offset) > 0 ||\n                      StringHelper.compare(bytesPerDim, maxPackedValue, offset, lowerPoint, offset) < 0) {\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  }\n\n                  crosses |= StringHelper.compare(bytesPerDim, minPackedValue, offset, lowerPoint, offset) < 0 ||\n                    StringHelper.compare(bytesPerDim, maxPackedValue, offset, upperPoint, offset) > 0;\n                }\n\n                if (crosses) {\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        return result.iterator();\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment indexed any points\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        if (fieldInfo.getPointDimensionCount() != numDims) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with numDims=\" + fieldInfo.getPointDimensionCount() + \" but this query has numDims=\" + numDims);\n        }\n        if (bytesPerDim != fieldInfo.getPointNumBytes()) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with bytesPerDim=\" + fieldInfo.getPointNumBytes() + \" but this query has bytesPerDim=\" + bytesPerDim);\n        }\n\n        boolean allDocsMatch;\n        if (values.getDocCount(field) == reader.maxDoc()) {\n          final byte[] fieldPackedLower = values.getMinPackedValue(field);\n          final byte[] fieldPackedUpper = values.getMaxPackedValue(field);\n          allDocsMatch = true;\n          for (int i = 0; i < numDims; ++i) {\n            int offset = i * bytesPerDim;\n            if (StringHelper.compare(bytesPerDim, lowerPoint, offset, fieldPackedLower, offset) > 0\n                || StringHelper.compare(bytesPerDim, upperPoint, offset, fieldPackedUpper, offset) < 0) {\n              allDocsMatch = false;\n              break;\n            }\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        DocIdSetIterator iterator;\n        if (allDocsMatch) {\n          // all docs have a value and all points are within bounds, so everything matches\n          iterator = DocIdSetIterator.all(reader.maxDoc());\n        } else {\n          iterator = buildMatchingIterator(reader, values);\n        }\n\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d81603e93cecbbd110c13a7e3b8ee478d6a73d6a","date":1461772947,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointBoxQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointBoxQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // We don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\".\n    // This is an inverted structure and should be used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n\n      private DocIdSetIterator buildMatchingIterator(LeafReader reader, PointValues values) throws IOException {\n        MatchingPoints result = new MatchingPoints(reader, field);\n\n        values.intersect(field,\n            new IntersectVisitor() {\n\n              @Override\n              public void grow(int count) {\n                result.grow(count);\n              }\n\n              @Override\n              public void visit(int docID) {\n                result.add(docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, lowerPoint, offset) < 0) {\n                    // Doc's value is too low, in this dimension\n                    return;\n                  }\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, upperPoint, offset) > 0) {\n                    // Doc's value is too high, in this dimension\n                    return;\n                  }\n                }\n\n                // Doc is in-bounds\n                result.add(docID);\n              }\n\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n                boolean crosses = false;\n\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n\n                  if (StringHelper.compare(bytesPerDim, minPackedValue, offset, upperPoint, offset) > 0 ||\n                      StringHelper.compare(bytesPerDim, maxPackedValue, offset, lowerPoint, offset) < 0) {\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  }\n\n                  crosses |= StringHelper.compare(bytesPerDim, minPackedValue, offset, lowerPoint, offset) < 0 ||\n                    StringHelper.compare(bytesPerDim, maxPackedValue, offset, upperPoint, offset) > 0;\n                }\n\n                if (crosses) {\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        return result.iterator();\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment indexed any points\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        if (fieldInfo.getPointDimensionCount() != numDims) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with numDims=\" + fieldInfo.getPointDimensionCount() + \" but this query has numDims=\" + numDims);\n        }\n        if (bytesPerDim != fieldInfo.getPointNumBytes()) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with bytesPerDim=\" + fieldInfo.getPointNumBytes() + \" but this query has bytesPerDim=\" + bytesPerDim);\n        }\n\n        boolean allDocsMatch;\n        if (values.getDocCount(field) == reader.maxDoc()) {\n          final byte[] fieldPackedLower = values.getMinPackedValue(field);\n          final byte[] fieldPackedUpper = values.getMaxPackedValue(field);\n          allDocsMatch = true;\n          for (int i = 0; i < numDims; ++i) {\n            int offset = i * bytesPerDim;\n            if (StringHelper.compare(bytesPerDim, lowerPoint, offset, fieldPackedLower, offset) > 0\n                || StringHelper.compare(bytesPerDim, upperPoint, offset, fieldPackedUpper, offset) < 0) {\n              allDocsMatch = false;\n              break;\n            }\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        DocIdSetIterator iterator;\n        if (allDocsMatch) {\n          // all docs have a value and all points are within bounds, so everything matches\n          iterator = DocIdSetIterator.all(reader.maxDoc());\n        } else {\n          iterator = buildMatchingIterator(reader, values);\n        }\n\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // We don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\".\n    // This is an inverted structure and should be used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n\n      private DocIdSetIterator buildMatchingIterator(LeafReader reader, PointValues values) throws IOException {\n        MatchingPoints result = new MatchingPoints(reader, field);\n\n        values.intersect(field,\n            new IntersectVisitor() {\n\n              @Override\n              public void visit(int docID) {\n                result.add(docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, lowerPoint, offset) < 0) {\n                    // Doc's value is too low, in this dimension\n                    return;\n                  }\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, upperPoint, offset) > 0) {\n                    // Doc's value is too high, in this dimension\n                    return;\n                  }\n                }\n\n                // Doc is in-bounds\n                result.add(docID);\n              }\n\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n                boolean crosses = false;\n\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n\n                  if (StringHelper.compare(bytesPerDim, minPackedValue, offset, upperPoint, offset) > 0 ||\n                      StringHelper.compare(bytesPerDim, maxPackedValue, offset, lowerPoint, offset) < 0) {\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  }\n\n                  crosses |= StringHelper.compare(bytesPerDim, minPackedValue, offset, lowerPoint, offset) < 0 ||\n                    StringHelper.compare(bytesPerDim, maxPackedValue, offset, upperPoint, offset) > 0;\n                }\n\n                if (crosses) {\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        return result.iterator();\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment indexed any points\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        if (fieldInfo.getPointDimensionCount() != numDims) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with numDims=\" + fieldInfo.getPointDimensionCount() + \" but this query has numDims=\" + numDims);\n        }\n        if (bytesPerDim != fieldInfo.getPointNumBytes()) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with bytesPerDim=\" + fieldInfo.getPointNumBytes() + \" but this query has bytesPerDim=\" + bytesPerDim);\n        }\n\n        boolean allDocsMatch;\n        if (values.getDocCount(field) == reader.maxDoc()) {\n          final byte[] fieldPackedLower = values.getMinPackedValue(field);\n          final byte[] fieldPackedUpper = values.getMaxPackedValue(field);\n          allDocsMatch = true;\n          for (int i = 0; i < numDims; ++i) {\n            int offset = i * bytesPerDim;\n            if (StringHelper.compare(bytesPerDim, lowerPoint, offset, fieldPackedLower, offset) > 0\n                || StringHelper.compare(bytesPerDim, upperPoint, offset, fieldPackedUpper, offset) < 0) {\n              allDocsMatch = false;\n              break;\n            }\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        DocIdSetIterator iterator;\n        if (allDocsMatch) {\n          // all docs have a value and all points are within bounds, so everything matches\n          iterator = DocIdSetIterator.all(reader.maxDoc());\n        } else {\n          iterator = buildMatchingIterator(reader, values);\n        }\n\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":["f976862431a9be6f9f76f958b5a9a04aa2342747"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f976862431a9be6f9f76f958b5a9a04aa2342747","date":1464099811,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointBoxQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointBoxQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // We don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\".\n    // This is an inverted structure and should be used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n\n      private DocIdSetIterator buildMatchingIterator(LeafReader reader, PointValues values) throws IOException {\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n\n        values.intersect(field,\n            new IntersectVisitor() {\n\n              DocIdSetBuilder.BulkAdder adder;\n\n              @Override\n              public void grow(int count) {\n                adder = result.grow(count);\n              }\n\n              @Override\n              public void visit(int docID) {\n                adder.add(docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, lowerPoint, offset) < 0) {\n                    // Doc's value is too low, in this dimension\n                    return;\n                  }\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, upperPoint, offset) > 0) {\n                    // Doc's value is too high, in this dimension\n                    return;\n                  }\n                }\n\n                // Doc is in-bounds\n                adder.add(docID);\n              }\n\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n                boolean crosses = false;\n\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n\n                  if (StringHelper.compare(bytesPerDim, minPackedValue, offset, upperPoint, offset) > 0 ||\n                      StringHelper.compare(bytesPerDim, maxPackedValue, offset, lowerPoint, offset) < 0) {\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  }\n\n                  crosses |= StringHelper.compare(bytesPerDim, minPackedValue, offset, lowerPoint, offset) < 0 ||\n                    StringHelper.compare(bytesPerDim, maxPackedValue, offset, upperPoint, offset) > 0;\n                }\n\n                if (crosses) {\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        return result.build().iterator();\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment indexed any points\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        if (fieldInfo.getPointDimensionCount() != numDims) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with numDims=\" + fieldInfo.getPointDimensionCount() + \" but this query has numDims=\" + numDims);\n        }\n        if (bytesPerDim != fieldInfo.getPointNumBytes()) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with bytesPerDim=\" + fieldInfo.getPointNumBytes() + \" but this query has bytesPerDim=\" + bytesPerDim);\n        }\n\n        boolean allDocsMatch;\n        if (values.getDocCount(field) == reader.maxDoc()) {\n          final byte[] fieldPackedLower = values.getMinPackedValue(field);\n          final byte[] fieldPackedUpper = values.getMaxPackedValue(field);\n          allDocsMatch = true;\n          for (int i = 0; i < numDims; ++i) {\n            int offset = i * bytesPerDim;\n            if (StringHelper.compare(bytesPerDim, lowerPoint, offset, fieldPackedLower, offset) > 0\n                || StringHelper.compare(bytesPerDim, upperPoint, offset, fieldPackedUpper, offset) < 0) {\n              allDocsMatch = false;\n              break;\n            }\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        DocIdSetIterator iterator;\n        if (allDocsMatch) {\n          // all docs have a value and all points are within bounds, so everything matches\n          iterator = DocIdSetIterator.all(reader.maxDoc());\n        } else {\n          iterator = buildMatchingIterator(reader, values);\n        }\n\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // We don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\".\n    // This is an inverted structure and should be used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n\n      private DocIdSetIterator buildMatchingIterator(LeafReader reader, PointValues values) throws IOException {\n        MatchingPoints result = new MatchingPoints(reader, field);\n\n        values.intersect(field,\n            new IntersectVisitor() {\n\n              @Override\n              public void grow(int count) {\n                result.grow(count);\n              }\n\n              @Override\n              public void visit(int docID) {\n                result.add(docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, lowerPoint, offset) < 0) {\n                    // Doc's value is too low, in this dimension\n                    return;\n                  }\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, upperPoint, offset) > 0) {\n                    // Doc's value is too high, in this dimension\n                    return;\n                  }\n                }\n\n                // Doc is in-bounds\n                result.add(docID);\n              }\n\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n                boolean crosses = false;\n\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n\n                  if (StringHelper.compare(bytesPerDim, minPackedValue, offset, upperPoint, offset) > 0 ||\n                      StringHelper.compare(bytesPerDim, maxPackedValue, offset, lowerPoint, offset) < 0) {\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  }\n\n                  crosses |= StringHelper.compare(bytesPerDim, minPackedValue, offset, lowerPoint, offset) < 0 ||\n                    StringHelper.compare(bytesPerDim, maxPackedValue, offset, upperPoint, offset) > 0;\n                }\n\n                if (crosses) {\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        return result.iterator();\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment indexed any points\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        if (fieldInfo.getPointDimensionCount() != numDims) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with numDims=\" + fieldInfo.getPointDimensionCount() + \" but this query has numDims=\" + numDims);\n        }\n        if (bytesPerDim != fieldInfo.getPointNumBytes()) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with bytesPerDim=\" + fieldInfo.getPointNumBytes() + \" but this query has bytesPerDim=\" + bytesPerDim);\n        }\n\n        boolean allDocsMatch;\n        if (values.getDocCount(field) == reader.maxDoc()) {\n          final byte[] fieldPackedLower = values.getMinPackedValue(field);\n          final byte[] fieldPackedUpper = values.getMaxPackedValue(field);\n          allDocsMatch = true;\n          for (int i = 0; i < numDims; ++i) {\n            int offset = i * bytesPerDim;\n            if (StringHelper.compare(bytesPerDim, lowerPoint, offset, fieldPackedLower, offset) > 0\n                || StringHelper.compare(bytesPerDim, upperPoint, offset, fieldPackedUpper, offset) < 0) {\n              allDocsMatch = false;\n              break;\n            }\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        DocIdSetIterator iterator;\n        if (allDocsMatch) {\n          // all docs have a value and all points are within bounds, so everything matches\n          iterator = DocIdSetIterator.all(reader.maxDoc());\n        } else {\n          iterator = buildMatchingIterator(reader, values);\n        }\n\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","bugFix":["a61b5b0e4cf8ab04d7674f9ae117ddc60be22005","d81603e93cecbbd110c13a7e3b8ee478d6a73d6a"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0e121d43b5a10f2df530f406f935102656e9c4e8","date":1464198131,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointBoxQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointBoxQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // We don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\".\n    // This is an inverted structure and should be used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n\n      private DocIdSetIterator buildMatchingIterator(LeafReader reader, PointValues values) throws IOException {\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n\n        values.intersect(field,\n            new IntersectVisitor() {\n\n              DocIdSetBuilder.BulkAdder adder;\n\n              @Override\n              public void grow(int count) {\n                adder = result.grow(count);\n              }\n\n              @Override\n              public void visit(int docID) {\n                adder.add(docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, lowerPoint, offset) < 0) {\n                    // Doc's value is too low, in this dimension\n                    return;\n                  }\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, upperPoint, offset) > 0) {\n                    // Doc's value is too high, in this dimension\n                    return;\n                  }\n                }\n\n                // Doc is in-bounds\n                adder.add(docID);\n              }\n\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n                boolean crosses = false;\n\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n\n                  if (StringHelper.compare(bytesPerDim, minPackedValue, offset, upperPoint, offset) > 0 ||\n                      StringHelper.compare(bytesPerDim, maxPackedValue, offset, lowerPoint, offset) < 0) {\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  }\n\n                  crosses |= StringHelper.compare(bytesPerDim, minPackedValue, offset, lowerPoint, offset) < 0 ||\n                    StringHelper.compare(bytesPerDim, maxPackedValue, offset, upperPoint, offset) > 0;\n                }\n\n                if (crosses) {\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        return result.build().iterator();\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment indexed any points\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        if (fieldInfo.getPointDimensionCount() != numDims) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with numDims=\" + fieldInfo.getPointDimensionCount() + \" but this query has numDims=\" + numDims);\n        }\n        if (bytesPerDim != fieldInfo.getPointNumBytes()) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with bytesPerDim=\" + fieldInfo.getPointNumBytes() + \" but this query has bytesPerDim=\" + bytesPerDim);\n        }\n\n        boolean allDocsMatch;\n        if (values.getDocCount(field) == reader.maxDoc()) {\n          final byte[] fieldPackedLower = values.getMinPackedValue(field);\n          final byte[] fieldPackedUpper = values.getMaxPackedValue(field);\n          allDocsMatch = true;\n          for (int i = 0; i < numDims; ++i) {\n            int offset = i * bytesPerDim;\n            if (StringHelper.compare(bytesPerDim, lowerPoint, offset, fieldPackedLower, offset) > 0\n                || StringHelper.compare(bytesPerDim, upperPoint, offset, fieldPackedUpper, offset) < 0) {\n              allDocsMatch = false;\n              break;\n            }\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        DocIdSetIterator iterator;\n        if (allDocsMatch) {\n          // all docs have a value and all points are within bounds, so everything matches\n          iterator = DocIdSetIterator.all(reader.maxDoc());\n        } else {\n          iterator = buildMatchingIterator(reader, values);\n        }\n\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // We don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\".\n    // This is an inverted structure and should be used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n\n      private DocIdSetIterator buildMatchingIterator(LeafReader reader, PointValues values) throws IOException {\n        MatchingPoints result = new MatchingPoints(reader, field);\n\n        values.intersect(field,\n            new IntersectVisitor() {\n\n              @Override\n              public void grow(int count) {\n                result.grow(count);\n              }\n\n              @Override\n              public void visit(int docID) {\n                result.add(docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, lowerPoint, offset) < 0) {\n                    // Doc's value is too low, in this dimension\n                    return;\n                  }\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, upperPoint, offset) > 0) {\n                    // Doc's value is too high, in this dimension\n                    return;\n                  }\n                }\n\n                // Doc is in-bounds\n                result.add(docID);\n              }\n\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n                boolean crosses = false;\n\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n\n                  if (StringHelper.compare(bytesPerDim, minPackedValue, offset, upperPoint, offset) > 0 ||\n                      StringHelper.compare(bytesPerDim, maxPackedValue, offset, lowerPoint, offset) < 0) {\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  }\n\n                  crosses |= StringHelper.compare(bytesPerDim, minPackedValue, offset, lowerPoint, offset) < 0 ||\n                    StringHelper.compare(bytesPerDim, maxPackedValue, offset, upperPoint, offset) > 0;\n                }\n\n                if (crosses) {\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        return result.iterator();\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment indexed any points\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        if (fieldInfo.getPointDimensionCount() != numDims) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with numDims=\" + fieldInfo.getPointDimensionCount() + \" but this query has numDims=\" + numDims);\n        }\n        if (bytesPerDim != fieldInfo.getPointNumBytes()) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with bytesPerDim=\" + fieldInfo.getPointNumBytes() + \" but this query has bytesPerDim=\" + bytesPerDim);\n        }\n\n        boolean allDocsMatch;\n        if (values.getDocCount(field) == reader.maxDoc()) {\n          final byte[] fieldPackedLower = values.getMinPackedValue(field);\n          final byte[] fieldPackedUpper = values.getMaxPackedValue(field);\n          allDocsMatch = true;\n          for (int i = 0; i < numDims; ++i) {\n            int offset = i * bytesPerDim;\n            if (StringHelper.compare(bytesPerDim, lowerPoint, offset, fieldPackedLower, offset) > 0\n                || StringHelper.compare(bytesPerDim, upperPoint, offset, fieldPackedUpper, offset) < 0) {\n              allDocsMatch = false;\n              break;\n            }\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        DocIdSetIterator iterator;\n        if (allDocsMatch) {\n          // all docs have a value and all points are within bounds, so everything matches\n          iterator = DocIdSetIterator.all(reader.maxDoc());\n        } else {\n          iterator = buildMatchingIterator(reader, values);\n        }\n\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"83870855d82aba6819217abeff5a40779dbb28b4","date":1464291012,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointBoxQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointBoxQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // We don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\".\n    // This is an inverted structure and should be used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n\n      private DocIdSetIterator buildMatchingIterator(LeafReader reader, PointValues values) throws IOException {\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n\n        values.intersect(field,\n            new IntersectVisitor() {\n\n              DocIdSetBuilder.BulkAdder adder;\n\n              @Override\n              public void grow(int count) {\n                adder = result.grow(count);\n              }\n\n              @Override\n              public void visit(int docID) {\n                adder.add(docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, lowerPoint, offset) < 0) {\n                    // Doc's value is too low, in this dimension\n                    return;\n                  }\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, upperPoint, offset) > 0) {\n                    // Doc's value is too high, in this dimension\n                    return;\n                  }\n                }\n\n                // Doc is in-bounds\n                adder.add(docID);\n              }\n\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n                boolean crosses = false;\n\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n\n                  if (StringHelper.compare(bytesPerDim, minPackedValue, offset, upperPoint, offset) > 0 ||\n                      StringHelper.compare(bytesPerDim, maxPackedValue, offset, lowerPoint, offset) < 0) {\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  }\n\n                  crosses |= StringHelper.compare(bytesPerDim, minPackedValue, offset, lowerPoint, offset) < 0 ||\n                    StringHelper.compare(bytesPerDim, maxPackedValue, offset, upperPoint, offset) > 0;\n                }\n\n                if (crosses) {\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        return result.build().iterator();\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment indexed any points\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        if (fieldInfo.getPointDimensionCount() != numDims) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with numDims=\" + fieldInfo.getPointDimensionCount() + \" but this query has numDims=\" + numDims);\n        }\n        if (bytesPerDim != fieldInfo.getPointNumBytes()) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with bytesPerDim=\" + fieldInfo.getPointNumBytes() + \" but this query has bytesPerDim=\" + bytesPerDim);\n        }\n\n        boolean allDocsMatch;\n        if (values.getDocCount(field) == reader.maxDoc()) {\n          final byte[] fieldPackedLower = values.getMinPackedValue(field);\n          final byte[] fieldPackedUpper = values.getMaxPackedValue(field);\n          allDocsMatch = true;\n          for (int i = 0; i < numDims; ++i) {\n            int offset = i * bytesPerDim;\n            if (StringHelper.compare(bytesPerDim, lowerPoint, offset, fieldPackedLower, offset) > 0\n                || StringHelper.compare(bytesPerDim, upperPoint, offset, fieldPackedUpper, offset) < 0) {\n              allDocsMatch = false;\n              break;\n            }\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        DocIdSetIterator iterator;\n        if (allDocsMatch) {\n          // all docs have a value and all points are within bounds, so everything matches\n          iterator = DocIdSetIterator.all(reader.maxDoc());\n        } else {\n          iterator = buildMatchingIterator(reader, values);\n        }\n\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // We don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\".\n    // This is an inverted structure and should be used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n\n      private DocIdSetIterator buildMatchingIterator(LeafReader reader, PointValues values) throws IOException {\n        MatchingPoints result = new MatchingPoints(reader, field);\n\n        values.intersect(field,\n            new IntersectVisitor() {\n\n              @Override\n              public void grow(int count) {\n                result.grow(count);\n              }\n\n              @Override\n              public void visit(int docID) {\n                result.add(docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, lowerPoint, offset) < 0) {\n                    // Doc's value is too low, in this dimension\n                    return;\n                  }\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, upperPoint, offset) > 0) {\n                    // Doc's value is too high, in this dimension\n                    return;\n                  }\n                }\n\n                // Doc is in-bounds\n                result.add(docID);\n              }\n\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n                boolean crosses = false;\n\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n\n                  if (StringHelper.compare(bytesPerDim, minPackedValue, offset, upperPoint, offset) > 0 ||\n                      StringHelper.compare(bytesPerDim, maxPackedValue, offset, lowerPoint, offset) < 0) {\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  }\n\n                  crosses |= StringHelper.compare(bytesPerDim, minPackedValue, offset, lowerPoint, offset) < 0 ||\n                    StringHelper.compare(bytesPerDim, maxPackedValue, offset, upperPoint, offset) > 0;\n                }\n\n                if (crosses) {\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        return result.iterator();\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment indexed any points\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        if (fieldInfo.getPointDimensionCount() != numDims) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with numDims=\" + fieldInfo.getPointDimensionCount() + \" but this query has numDims=\" + numDims);\n        }\n        if (bytesPerDim != fieldInfo.getPointNumBytes()) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with bytesPerDim=\" + fieldInfo.getPointNumBytes() + \" but this query has bytesPerDim=\" + bytesPerDim);\n        }\n\n        boolean allDocsMatch;\n        if (values.getDocCount(field) == reader.maxDoc()) {\n          final byte[] fieldPackedLower = values.getMinPackedValue(field);\n          final byte[] fieldPackedUpper = values.getMaxPackedValue(field);\n          allDocsMatch = true;\n          for (int i = 0; i < numDims; ++i) {\n            int offset = i * bytesPerDim;\n            if (StringHelper.compare(bytesPerDim, lowerPoint, offset, fieldPackedLower, offset) > 0\n                || StringHelper.compare(bytesPerDim, upperPoint, offset, fieldPackedUpper, offset) < 0) {\n              allDocsMatch = false;\n              break;\n            }\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        DocIdSetIterator iterator;\n        if (allDocsMatch) {\n          // all docs have a value and all points are within bounds, so everything matches\n          iterator = DocIdSetIterator.all(reader.maxDoc());\n        } else {\n          iterator = buildMatchingIterator(reader, values);\n        }\n\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"50ff3ac7f4f69138711952170497ecb401ce2396","date":1465514544,"type":4,"author":"Mike McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointBoxQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":null,"sourceOld":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // We don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\".\n    // This is an inverted structure and should be used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n\n      private DocIdSetIterator buildMatchingIterator(LeafReader reader, PointValues values) throws IOException {\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n\n        values.intersect(field,\n            new IntersectVisitor() {\n\n              DocIdSetBuilder.BulkAdder adder;\n\n              @Override\n              public void grow(int count) {\n                adder = result.grow(count);\n              }\n\n              @Override\n              public void visit(int docID) {\n                adder.add(docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, lowerPoint, offset) < 0) {\n                    // Doc's value is too low, in this dimension\n                    return;\n                  }\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, upperPoint, offset) > 0) {\n                    // Doc's value is too high, in this dimension\n                    return;\n                  }\n                }\n\n                // Doc is in-bounds\n                adder.add(docID);\n              }\n\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n                boolean crosses = false;\n\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n\n                  if (StringHelper.compare(bytesPerDim, minPackedValue, offset, upperPoint, offset) > 0 ||\n                      StringHelper.compare(bytesPerDim, maxPackedValue, offset, lowerPoint, offset) < 0) {\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  }\n\n                  crosses |= StringHelper.compare(bytesPerDim, minPackedValue, offset, lowerPoint, offset) < 0 ||\n                    StringHelper.compare(bytesPerDim, maxPackedValue, offset, upperPoint, offset) > 0;\n                }\n\n                if (crosses) {\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        return result.build().iterator();\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment indexed any points\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        if (fieldInfo.getPointDimensionCount() != numDims) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with numDims=\" + fieldInfo.getPointDimensionCount() + \" but this query has numDims=\" + numDims);\n        }\n        if (bytesPerDim != fieldInfo.getPointNumBytes()) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with bytesPerDim=\" + fieldInfo.getPointNumBytes() + \" but this query has bytesPerDim=\" + bytesPerDim);\n        }\n\n        boolean allDocsMatch;\n        if (values.getDocCount(field) == reader.maxDoc()) {\n          final byte[] fieldPackedLower = values.getMinPackedValue(field);\n          final byte[] fieldPackedUpper = values.getMaxPackedValue(field);\n          allDocsMatch = true;\n          for (int i = 0; i < numDims; ++i) {\n            int offset = i * bytesPerDim;\n            if (StringHelper.compare(bytesPerDim, lowerPoint, offset, fieldPackedLower, offset) > 0\n                || StringHelper.compare(bytesPerDim, upperPoint, offset, fieldPackedUpper, offset) < 0) {\n              allDocsMatch = false;\n              break;\n            }\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        DocIdSetIterator iterator;\n        if (allDocsMatch) {\n          // all docs have a value and all points are within bounds, so everything matches\n          iterator = DocIdSetIterator.all(reader.maxDoc());\n        } else {\n          iterator = buildMatchingIterator(reader, values);\n        }\n\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":4,"author":"Kevin Risden","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointBoxQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":null,"sourceOld":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // We don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\".\n    // This is an inverted structure and should be used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n\n      private DocIdSetIterator buildMatchingIterator(LeafReader reader, PointValues values) throws IOException {\n        MatchingPoints result = new MatchingPoints(reader, field);\n\n        values.intersect(field,\n            new IntersectVisitor() {\n\n              @Override\n              public void grow(int count) {\n                result.grow(count);\n              }\n\n              @Override\n              public void visit(int docID) {\n                result.add(docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, lowerPoint, offset) < 0) {\n                    // Doc's value is too low, in this dimension\n                    return;\n                  }\n                  if (StringHelper.compare(bytesPerDim, packedValue, offset, upperPoint, offset) > 0) {\n                    // Doc's value is too high, in this dimension\n                    return;\n                  }\n                }\n\n                // Doc is in-bounds\n                result.add(docID);\n              }\n\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n                boolean crosses = false;\n\n                for(int dim=0;dim<numDims;dim++) {\n                  int offset = dim*bytesPerDim;\n\n                  if (StringHelper.compare(bytesPerDim, minPackedValue, offset, upperPoint, offset) > 0 ||\n                      StringHelper.compare(bytesPerDim, maxPackedValue, offset, lowerPoint, offset) < 0) {\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  }\n\n                  crosses |= StringHelper.compare(bytesPerDim, minPackedValue, offset, lowerPoint, offset) < 0 ||\n                    StringHelper.compare(bytesPerDim, maxPackedValue, offset, upperPoint, offset) > 0;\n                }\n\n                if (crosses) {\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        return result.iterator();\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment indexed any points\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        if (fieldInfo.getPointDimensionCount() != numDims) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with numDims=\" + fieldInfo.getPointDimensionCount() + \" but this query has numDims=\" + numDims);\n        }\n        if (bytesPerDim != fieldInfo.getPointNumBytes()) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with bytesPerDim=\" + fieldInfo.getPointNumBytes() + \" but this query has bytesPerDim=\" + bytesPerDim);\n        }\n\n        boolean allDocsMatch;\n        if (values.getDocCount(field) == reader.maxDoc()) {\n          final byte[] fieldPackedLower = values.getMinPackedValue(field);\n          final byte[] fieldPackedUpper = values.getMaxPackedValue(field);\n          allDocsMatch = true;\n          for (int i = 0; i < numDims; ++i) {\n            int offset = i * bytesPerDim;\n            if (StringHelper.compare(bytesPerDim, lowerPoint, offset, fieldPackedLower, offset) > 0\n                || StringHelper.compare(bytesPerDim, upperPoint, offset, fieldPackedUpper, offset) < 0) {\n              allDocsMatch = false;\n              break;\n            }\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        DocIdSetIterator iterator;\n        if (allDocsMatch) {\n          // all docs have a value and all points are within bounds, so everything matches\n          iterator = DocIdSetIterator.all(reader.maxDoc());\n        } else {\n          iterator = buildMatchingIterator(reader, values);\n        }\n\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0e121d43b5a10f2df530f406f935102656e9c4e8":["d81603e93cecbbd110c13a7e3b8ee478d6a73d6a","f976862431a9be6f9f76f958b5a9a04aa2342747"],"50ff3ac7f4f69138711952170497ecb401ce2396":["0e121d43b5a10f2df530f406f935102656e9c4e8"],"a61b5b0e4cf8ab04d7674f9ae117ddc60be22005":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f7f901826e47f75f810d7aae24b0455d21ea1fe2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","a61b5b0e4cf8ab04d7674f9ae117ddc60be22005"],"83870855d82aba6819217abeff5a40779dbb28b4":["d81603e93cecbbd110c13a7e3b8ee478d6a73d6a","0e121d43b5a10f2df530f406f935102656e9c4e8"],"f976862431a9be6f9f76f958b5a9a04aa2342747":["d81603e93cecbbd110c13a7e3b8ee478d6a73d6a"],"d81603e93cecbbd110c13a7e3b8ee478d6a73d6a":["f7f901826e47f75f810d7aae24b0455d21ea1fe2"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["d81603e93cecbbd110c13a7e3b8ee478d6a73d6a","50ff3ac7f4f69138711952170497ecb401ce2396"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["50ff3ac7f4f69138711952170497ecb401ce2396"]},"commit2Childs":{"0e121d43b5a10f2df530f406f935102656e9c4e8":["50ff3ac7f4f69138711952170497ecb401ce2396","83870855d82aba6819217abeff5a40779dbb28b4"],"50ff3ac7f4f69138711952170497ecb401ce2396":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a61b5b0e4cf8ab04d7674f9ae117ddc60be22005":["f7f901826e47f75f810d7aae24b0455d21ea1fe2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a61b5b0e4cf8ab04d7674f9ae117ddc60be22005","f7f901826e47f75f810d7aae24b0455d21ea1fe2"],"f7f901826e47f75f810d7aae24b0455d21ea1fe2":["d81603e93cecbbd110c13a7e3b8ee478d6a73d6a"],"83870855d82aba6819217abeff5a40779dbb28b4":[],"f976862431a9be6f9f76f958b5a9a04aa2342747":["0e121d43b5a10f2df530f406f935102656e9c4e8"],"d81603e93cecbbd110c13a7e3b8ee478d6a73d6a":["0e121d43b5a10f2df530f406f935102656e9c4e8","83870855d82aba6819217abeff5a40779dbb28b4","f976862431a9be6f9f76f958b5a9a04aa2342747","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["83870855d82aba6819217abeff5a40779dbb28b4","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}