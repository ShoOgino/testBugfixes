{"path":"solr/src/java/org/apache/solr/handler/component/SpellCheckComponent#toNamedList(boolean,SpellingResult,String,boolean,boolean).mjava","commits":[{"id":"d6aab5206b894bf0ea232b059a45cf2de460726f","date":1284150281,"type":1,"author":"Grant Ingersoll","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/SpellCheckComponent#toNamedList(boolean,SpellingResult,String,boolean,boolean).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/SpellCheckComponent#toNamedList(SpellingResult,String,boolean,boolean).mjava","sourceNew":"  protected NamedList toNamedList(boolean shardRequest, SpellingResult spellingResult, String origQuery, boolean extendedResults, boolean collate) {\n    NamedList result = new NamedList();\n    Map<Token, LinkedHashMap<String, Integer>> suggestions = spellingResult.getSuggestions();\n    boolean hasFreqInfo = spellingResult.hasTokenFrequencyInfo();\n    boolean isCorrectlySpelled = false;\n    Map<Token, String> best = null;\n    if (collate == true){\n      best = new LinkedHashMap<Token, String>(suggestions.size());\n    }\n    \n    int numSuggestions = 0;\n    for(LinkedHashMap<String, Integer> theSuggestion : suggestions.values())\n    {\n    \tif(theSuggestion.size()>0)\n    \t{\n    \t\tnumSuggestions++;\n    \t}\n    }    \n    // will be flipped to false if any of the suggestions are not in the index and hasFreqInfo is true\n    if(numSuggestions > 0) {\n      isCorrectlySpelled = true;\n    }\n    \n    for (Map.Entry<Token, LinkedHashMap<String, Integer>> entry : suggestions.entrySet()) {\n      Token inputToken = entry.getKey();\n      Map<String, Integer> theSuggestions = entry.getValue();\n      if (theSuggestions != null && (theSuggestions.size()>0 || shardRequest)) {\n        SimpleOrderedMap suggestionList = new SimpleOrderedMap();\n        suggestionList.add(\"numFound\", theSuggestions.size());\n        suggestionList.add(\"startOffset\", inputToken.startOffset());\n        suggestionList.add(\"endOffset\", inputToken.endOffset());\n\n        // Logical structure of normal (non-extended) results:\n        // \"suggestion\":[\"alt1\",\"alt2\"]\n        //\n        // Logical structure of the extended results:\n        // \"suggestion\":[\n        //     {\"word\":\"alt1\",\"freq\":7},\n        //     {\"word\":\"alt2\",\"freq\":4}\n        // ]\n        if (extendedResults && hasFreqInfo) {\n          suggestionList.add(\"origFreq\", spellingResult.getTokenFrequency(inputToken));\n\n          ArrayList<SimpleOrderedMap> sugs = new ArrayList<SimpleOrderedMap>();\n          suggestionList.add(\"suggestion\", sugs);\n          for (Map.Entry<String, Integer> suggEntry : theSuggestions.entrySet()) {\n            SimpleOrderedMap sugEntry = new SimpleOrderedMap();\n            sugEntry.add(\"word\",suggEntry.getKey());\n            sugEntry.add(\"freq\",suggEntry.getValue());\n            sugs.add(sugEntry);\n          }\n        } else {\n          suggestionList.add(\"suggestion\", theSuggestions.keySet());\n        }\n\n        if (collate == true && theSuggestions.size()>0){//set aside the best suggestion for this token\n          best.put(inputToken, theSuggestions.keySet().iterator().next());\n        }\n        if (hasFreqInfo) {\n          isCorrectlySpelled = isCorrectlySpelled && spellingResult.getTokenFrequency(inputToken) > 0;\n        }\n        result.add(new String(inputToken.buffer(), 0, inputToken.length()), suggestionList);\n      }\n    }\n    if (hasFreqInfo) {\n      result.add(\"correctlySpelled\", isCorrectlySpelled);\n    } else if(extendedResults && suggestions.size() == 0) { // if the word is misspelled, its added to suggestions with freqinfo\n      result.add(\"correctlySpelled\", true);\n    }\n    if (collate == true){\n      StringBuilder collation = new StringBuilder(origQuery);\n      int offset = 0;\n      for (Iterator<Map.Entry<Token, String>> bestIter = best.entrySet().iterator(); bestIter.hasNext();) {\n        Map.Entry<Token, String> entry = bestIter.next();\n        Token tok = entry.getKey();\n        // we are replacing the query in order, but injected terms might cause illegal offsets due to previous replacements.\n        if (tok.getPositionIncrement() == 0) continue;\n        collation.replace(tok.startOffset() + offset, \n          tok.endOffset() + offset, entry.getValue());\n        offset += entry.getValue().length() - (tok.endOffset() - tok.startOffset());\n      }\n      String collVal = collation.toString();\n      if (collVal.equals(origQuery) == false) {\n        LOG.debug(\"Collation:\" + collation);\n        result.add(\"collation\", collVal);\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  protected NamedList toNamedList(SpellingResult spellingResult, String origQuery, boolean extendedResults, boolean collate) {\n    NamedList result = new NamedList();\n    Map<Token, LinkedHashMap<String, Integer>> suggestions = spellingResult.getSuggestions();\n    boolean hasFreqInfo = spellingResult.hasTokenFrequencyInfo();\n    boolean isCorrectlySpelled = false;\n    Map<Token, String> best = null;\n    if (collate == true){\n      best = new LinkedHashMap<Token, String>(suggestions.size());\n    }\n    \n    // will be flipped to false if any of the suggestions are not in the index and hasFreqInfo is true\n    if(suggestions.size() > 0) {\n      isCorrectlySpelled = true;\n    }\n    \n    for (Map.Entry<Token, LinkedHashMap<String, Integer>> entry : suggestions.entrySet()) {\n      Token inputToken = entry.getKey();\n      Map<String, Integer> theSuggestions = entry.getValue();\n      if (theSuggestions != null && theSuggestions.size() > 0) {\n        SimpleOrderedMap suggestionList = new SimpleOrderedMap();\n        suggestionList.add(\"numFound\", theSuggestions.size());\n        suggestionList.add(\"startOffset\", inputToken.startOffset());\n        suggestionList.add(\"endOffset\", inputToken.endOffset());\n\n        // Logical structure of normal (non-extended) results:\n        // \"suggestion\":[\"alt1\",\"alt2\"]\n        //\n        // Logical structure of the extended results:\n        // \"suggestion\":[\n        //     {\"word\":\"alt1\",\"freq\":7},\n        //     {\"word\":\"alt2\",\"freq\":4}\n        // ]\n        if (extendedResults && hasFreqInfo) {\n          suggestionList.add(\"origFreq\", spellingResult.getTokenFrequency(inputToken));\n\n          ArrayList<SimpleOrderedMap> sugs = new ArrayList<SimpleOrderedMap>();\n          suggestionList.add(\"suggestion\", sugs);\n          for (Map.Entry<String, Integer> suggEntry : theSuggestions.entrySet()) {\n            SimpleOrderedMap sugEntry = new SimpleOrderedMap();\n            sugEntry.add(\"word\",suggEntry.getKey());\n            sugEntry.add(\"freq\",suggEntry.getValue());\n            sugs.add(sugEntry);\n          }\n        } else {\n          suggestionList.add(\"suggestion\", theSuggestions.keySet());\n        }\n\n        if (collate == true ){//set aside the best suggestion for this token\n          best.put(inputToken, theSuggestions.keySet().iterator().next());\n        }\n        if (hasFreqInfo) {\n          isCorrectlySpelled = isCorrectlySpelled && spellingResult.getTokenFrequency(inputToken) > 0;\n        }\n        result.add(new String(inputToken.buffer(), 0, inputToken.length()), suggestionList);\n      }\n    }\n    if (hasFreqInfo) {\n      result.add(\"correctlySpelled\", isCorrectlySpelled);\n    } else if(extendedResults && suggestions.size() == 0) { // if the word is misspelled, its added to suggestions with freqinfo\n      result.add(\"correctlySpelled\", true);\n    }\n    if (collate == true){\n      StringBuilder collation = new StringBuilder(origQuery);\n      int offset = 0;\n      for (Iterator<Map.Entry<Token, String>> bestIter = best.entrySet().iterator(); bestIter.hasNext();) {\n        Map.Entry<Token, String> entry = bestIter.next();\n        Token tok = entry.getKey();\n        // we are replacing the query in order, but injected terms might cause illegal offsets due to previous replacements.\n        if (tok.getPositionIncrement() == 0) continue;\n        collation.replace(tok.startOffset() + offset, \n          tok.endOffset() + offset, entry.getValue());\n        offset += entry.getValue().length() - (tok.endOffset() - tok.startOffset());\n      }\n      String collVal = collation.toString();\n      if (collVal.equals(origQuery) == false) {\n        LOG.debug(\"Collation:\" + collation);\n        result.add(\"collation\", collVal);\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cdcf766020b9b159d0b3a6ecae90ff1998ded019","date":1286818331,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/SpellCheckComponent#toNamedList(boolean,SpellingResult,String,boolean,boolean).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/SpellCheckComponent#toNamedList(boolean,SpellingResult,String,boolean,boolean).mjava","sourceNew":"  protected NamedList toNamedList(boolean shardRequest, SpellingResult spellingResult, String origQuery, boolean extendedResults, boolean collate) {\n    NamedList result = new NamedList();\n    Map<Token, LinkedHashMap<String, Integer>> suggestions = spellingResult.getSuggestions();\n    boolean hasFreqInfo = spellingResult.hasTokenFrequencyInfo();\n    boolean isCorrectlySpelled = false;\n    \n    int numSuggestions = 0;\n    for(LinkedHashMap<String, Integer> theSuggestion : suggestions.values())\n    {\n    \tif(theSuggestion.size()>0)\n    \t{\n    \t\tnumSuggestions++;\n    \t}\n    } \n    \n    // will be flipped to false if any of the suggestions are not in the index and hasFreqInfo is true\n    if(numSuggestions > 0) {\n      isCorrectlySpelled = true;\n    }\n    \n    for (Map.Entry<Token, LinkedHashMap<String, Integer>> entry : suggestions.entrySet()) {\n      Token inputToken = entry.getKey();\n      Map<String, Integer> theSuggestions = entry.getValue();\n      if (theSuggestions != null && (theSuggestions.size()>0 || shardRequest)) {\n        SimpleOrderedMap suggestionList = new SimpleOrderedMap();\n        suggestionList.add(\"numFound\", theSuggestions.size());\n        suggestionList.add(\"startOffset\", inputToken.startOffset());\n        suggestionList.add(\"endOffset\", inputToken.endOffset());\n\n        // Logical structure of normal (non-extended) results:\n        // \"suggestion\":[\"alt1\",\"alt2\"]\n        //\n        // Logical structure of the extended results:\n        // \"suggestion\":[\n        //     {\"word\":\"alt1\",\"freq\":7},\n        //     {\"word\":\"alt2\",\"freq\":4}\n        // ]\n        if (extendedResults && hasFreqInfo) {\n          suggestionList.add(\"origFreq\", spellingResult.getTokenFrequency(inputToken));\n\n          ArrayList<SimpleOrderedMap> sugs = new ArrayList<SimpleOrderedMap>();\n          suggestionList.add(\"suggestion\", sugs);\n          for (Map.Entry<String, Integer> suggEntry : theSuggestions.entrySet()) {\n            SimpleOrderedMap sugEntry = new SimpleOrderedMap();\n            sugEntry.add(\"word\",suggEntry.getKey());\n            sugEntry.add(\"freq\",suggEntry.getValue());\n            sugs.add(sugEntry);\n          }\n        } else {\n          suggestionList.add(\"suggestion\", theSuggestions.keySet());\n        }\n\n        if (hasFreqInfo) {\n          isCorrectlySpelled = isCorrectlySpelled && spellingResult.getTokenFrequency(inputToken) > 0;\n        }\n        result.add(new String(inputToken.buffer(), 0, inputToken.length()), suggestionList);\n      }\n    }\n    if (hasFreqInfo) {\n      result.add(\"correctlySpelled\", isCorrectlySpelled);\n    } else if(extendedResults && suggestions.size() == 0) { // if the word is misspelled, its added to suggestions with freqinfo\n      result.add(\"correctlySpelled\", true);\n    }\n    return result;\n  }\n\n","sourceOld":"  protected NamedList toNamedList(boolean shardRequest, SpellingResult spellingResult, String origQuery, boolean extendedResults, boolean collate) {\n    NamedList result = new NamedList();\n    Map<Token, LinkedHashMap<String, Integer>> suggestions = spellingResult.getSuggestions();\n    boolean hasFreqInfo = spellingResult.hasTokenFrequencyInfo();\n    boolean isCorrectlySpelled = false;\n    Map<Token, String> best = null;\n    if (collate == true){\n      best = new LinkedHashMap<Token, String>(suggestions.size());\n    }\n    \n    int numSuggestions = 0;\n    for(LinkedHashMap<String, Integer> theSuggestion : suggestions.values())\n    {\n    \tif(theSuggestion.size()>0)\n    \t{\n    \t\tnumSuggestions++;\n    \t}\n    }    \n    // will be flipped to false if any of the suggestions are not in the index and hasFreqInfo is true\n    if(numSuggestions > 0) {\n      isCorrectlySpelled = true;\n    }\n    \n    for (Map.Entry<Token, LinkedHashMap<String, Integer>> entry : suggestions.entrySet()) {\n      Token inputToken = entry.getKey();\n      Map<String, Integer> theSuggestions = entry.getValue();\n      if (theSuggestions != null && (theSuggestions.size()>0 || shardRequest)) {\n        SimpleOrderedMap suggestionList = new SimpleOrderedMap();\n        suggestionList.add(\"numFound\", theSuggestions.size());\n        suggestionList.add(\"startOffset\", inputToken.startOffset());\n        suggestionList.add(\"endOffset\", inputToken.endOffset());\n\n        // Logical structure of normal (non-extended) results:\n        // \"suggestion\":[\"alt1\",\"alt2\"]\n        //\n        // Logical structure of the extended results:\n        // \"suggestion\":[\n        //     {\"word\":\"alt1\",\"freq\":7},\n        //     {\"word\":\"alt2\",\"freq\":4}\n        // ]\n        if (extendedResults && hasFreqInfo) {\n          suggestionList.add(\"origFreq\", spellingResult.getTokenFrequency(inputToken));\n\n          ArrayList<SimpleOrderedMap> sugs = new ArrayList<SimpleOrderedMap>();\n          suggestionList.add(\"suggestion\", sugs);\n          for (Map.Entry<String, Integer> suggEntry : theSuggestions.entrySet()) {\n            SimpleOrderedMap sugEntry = new SimpleOrderedMap();\n            sugEntry.add(\"word\",suggEntry.getKey());\n            sugEntry.add(\"freq\",suggEntry.getValue());\n            sugs.add(sugEntry);\n          }\n        } else {\n          suggestionList.add(\"suggestion\", theSuggestions.keySet());\n        }\n\n        if (collate == true && theSuggestions.size()>0){//set aside the best suggestion for this token\n          best.put(inputToken, theSuggestions.keySet().iterator().next());\n        }\n        if (hasFreqInfo) {\n          isCorrectlySpelled = isCorrectlySpelled && spellingResult.getTokenFrequency(inputToken) > 0;\n        }\n        result.add(new String(inputToken.buffer(), 0, inputToken.length()), suggestionList);\n      }\n    }\n    if (hasFreqInfo) {\n      result.add(\"correctlySpelled\", isCorrectlySpelled);\n    } else if(extendedResults && suggestions.size() == 0) { // if the word is misspelled, its added to suggestions with freqinfo\n      result.add(\"correctlySpelled\", true);\n    }\n    if (collate == true){\n      StringBuilder collation = new StringBuilder(origQuery);\n      int offset = 0;\n      for (Iterator<Map.Entry<Token, String>> bestIter = best.entrySet().iterator(); bestIter.hasNext();) {\n        Map.Entry<Token, String> entry = bestIter.next();\n        Token tok = entry.getKey();\n        // we are replacing the query in order, but injected terms might cause illegal offsets due to previous replacements.\n        if (tok.getPositionIncrement() == 0) continue;\n        collation.replace(tok.startOffset() + offset, \n          tok.endOffset() + offset, entry.getValue());\n        offset += entry.getValue().length() - (tok.endOffset() - tok.startOffset());\n      }\n      String collVal = collation.toString();\n      if (collVal.equals(origQuery) == false) {\n        LOG.debug(\"Collation:\" + collation);\n        result.add(\"collation\", collVal);\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":0,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/component/SpellCheckComponent#toNamedList(boolean,SpellingResult,String,boolean,boolean).mjava","pathOld":"/dev/null","sourceNew":"  protected NamedList toNamedList(boolean shardRequest, SpellingResult spellingResult, String origQuery, boolean extendedResults, boolean collate) {\n    NamedList result = new NamedList();\n    Map<Token, LinkedHashMap<String, Integer>> suggestions = spellingResult.getSuggestions();\n    boolean hasFreqInfo = spellingResult.hasTokenFrequencyInfo();\n    boolean isCorrectlySpelled = false;\n    \n    int numSuggestions = 0;\n    for(LinkedHashMap<String, Integer> theSuggestion : suggestions.values())\n    {\n    \tif(theSuggestion.size()>0)\n    \t{\n    \t\tnumSuggestions++;\n    \t}\n    } \n    \n    // will be flipped to false if any of the suggestions are not in the index and hasFreqInfo is true\n    if(numSuggestions > 0) {\n      isCorrectlySpelled = true;\n    }\n    \n    for (Map.Entry<Token, LinkedHashMap<String, Integer>> entry : suggestions.entrySet()) {\n      Token inputToken = entry.getKey();\n      Map<String, Integer> theSuggestions = entry.getValue();\n      if (theSuggestions != null && (theSuggestions.size()>0 || shardRequest)) {\n        SimpleOrderedMap suggestionList = new SimpleOrderedMap();\n        suggestionList.add(\"numFound\", theSuggestions.size());\n        suggestionList.add(\"startOffset\", inputToken.startOffset());\n        suggestionList.add(\"endOffset\", inputToken.endOffset());\n\n        // Logical structure of normal (non-extended) results:\n        // \"suggestion\":[\"alt1\",\"alt2\"]\n        //\n        // Logical structure of the extended results:\n        // \"suggestion\":[\n        //     {\"word\":\"alt1\",\"freq\":7},\n        //     {\"word\":\"alt2\",\"freq\":4}\n        // ]\n        if (extendedResults && hasFreqInfo) {\n          suggestionList.add(\"origFreq\", spellingResult.getTokenFrequency(inputToken));\n\n          ArrayList<SimpleOrderedMap> sugs = new ArrayList<SimpleOrderedMap>();\n          suggestionList.add(\"suggestion\", sugs);\n          for (Map.Entry<String, Integer> suggEntry : theSuggestions.entrySet()) {\n            SimpleOrderedMap sugEntry = new SimpleOrderedMap();\n            sugEntry.add(\"word\",suggEntry.getKey());\n            sugEntry.add(\"freq\",suggEntry.getValue());\n            sugs.add(sugEntry);\n          }\n        } else {\n          suggestionList.add(\"suggestion\", theSuggestions.keySet());\n        }\n\n        if (hasFreqInfo) {\n          isCorrectlySpelled = isCorrectlySpelled && spellingResult.getTokenFrequency(inputToken) > 0;\n        }\n        result.add(new String(inputToken.buffer(), 0, inputToken.length()), suggestionList);\n      }\n    }\n    if (hasFreqInfo) {\n      result.add(\"correctlySpelled\", isCorrectlySpelled);\n    } else if(extendedResults && suggestions.size() == 0) { // if the word is misspelled, its added to suggestions with freqinfo\n      result.add(\"correctlySpelled\", true);\n    }\n    return result;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#toNamedList(boolean,SpellingResult,String,boolean,boolean).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/SpellCheckComponent#toNamedList(boolean,SpellingResult,String,boolean,boolean).mjava","sourceNew":"  protected NamedList toNamedList(boolean shardRequest, SpellingResult spellingResult, String origQuery, boolean extendedResults, boolean collate) {\n    NamedList result = new NamedList();\n    Map<Token, LinkedHashMap<String, Integer>> suggestions = spellingResult.getSuggestions();\n    boolean hasFreqInfo = spellingResult.hasTokenFrequencyInfo();\n    boolean isCorrectlySpelled = false;\n    \n    int numSuggestions = 0;\n    for(LinkedHashMap<String, Integer> theSuggestion : suggestions.values())\n    {\n    \tif(theSuggestion.size()>0)\n    \t{\n    \t\tnumSuggestions++;\n    \t}\n    } \n    \n    // will be flipped to false if any of the suggestions are not in the index and hasFreqInfo is true\n    if(numSuggestions > 0) {\n      isCorrectlySpelled = true;\n    }\n    \n    for (Map.Entry<Token, LinkedHashMap<String, Integer>> entry : suggestions.entrySet()) {\n      Token inputToken = entry.getKey();\n      Map<String, Integer> theSuggestions = entry.getValue();\n      if (theSuggestions != null && (theSuggestions.size()>0 || shardRequest)) {\n        SimpleOrderedMap suggestionList = new SimpleOrderedMap();\n        suggestionList.add(\"numFound\", theSuggestions.size());\n        suggestionList.add(\"startOffset\", inputToken.startOffset());\n        suggestionList.add(\"endOffset\", inputToken.endOffset());\n\n        // Logical structure of normal (non-extended) results:\n        // \"suggestion\":[\"alt1\",\"alt2\"]\n        //\n        // Logical structure of the extended results:\n        // \"suggestion\":[\n        //     {\"word\":\"alt1\",\"freq\":7},\n        //     {\"word\":\"alt2\",\"freq\":4}\n        // ]\n        if (extendedResults && hasFreqInfo) {\n          suggestionList.add(\"origFreq\", spellingResult.getTokenFrequency(inputToken));\n\n          ArrayList<SimpleOrderedMap> sugs = new ArrayList<SimpleOrderedMap>();\n          suggestionList.add(\"suggestion\", sugs);\n          for (Map.Entry<String, Integer> suggEntry : theSuggestions.entrySet()) {\n            SimpleOrderedMap sugEntry = new SimpleOrderedMap();\n            sugEntry.add(\"word\",suggEntry.getKey());\n            sugEntry.add(\"freq\",suggEntry.getValue());\n            sugs.add(sugEntry);\n          }\n        } else {\n          suggestionList.add(\"suggestion\", theSuggestions.keySet());\n        }\n\n        if (hasFreqInfo) {\n          isCorrectlySpelled = isCorrectlySpelled && spellingResult.getTokenFrequency(inputToken) > 0;\n        }\n        result.add(new String(inputToken.buffer(), 0, inputToken.length()), suggestionList);\n      }\n    }\n    if (hasFreqInfo) {\n      result.add(\"correctlySpelled\", isCorrectlySpelled);\n    } else if(extendedResults && suggestions.size() == 0) { // if the word is misspelled, its added to suggestions with freqinfo\n      result.add(\"correctlySpelled\", true);\n    }\n    return result;\n  }\n\n","sourceOld":"  protected NamedList toNamedList(boolean shardRequest, SpellingResult spellingResult, String origQuery, boolean extendedResults, boolean collate) {\n    NamedList result = new NamedList();\n    Map<Token, LinkedHashMap<String, Integer>> suggestions = spellingResult.getSuggestions();\n    boolean hasFreqInfo = spellingResult.hasTokenFrequencyInfo();\n    boolean isCorrectlySpelled = false;\n    \n    int numSuggestions = 0;\n    for(LinkedHashMap<String, Integer> theSuggestion : suggestions.values())\n    {\n    \tif(theSuggestion.size()>0)\n    \t{\n    \t\tnumSuggestions++;\n    \t}\n    } \n    \n    // will be flipped to false if any of the suggestions are not in the index and hasFreqInfo is true\n    if(numSuggestions > 0) {\n      isCorrectlySpelled = true;\n    }\n    \n    for (Map.Entry<Token, LinkedHashMap<String, Integer>> entry : suggestions.entrySet()) {\n      Token inputToken = entry.getKey();\n      Map<String, Integer> theSuggestions = entry.getValue();\n      if (theSuggestions != null && (theSuggestions.size()>0 || shardRequest)) {\n        SimpleOrderedMap suggestionList = new SimpleOrderedMap();\n        suggestionList.add(\"numFound\", theSuggestions.size());\n        suggestionList.add(\"startOffset\", inputToken.startOffset());\n        suggestionList.add(\"endOffset\", inputToken.endOffset());\n\n        // Logical structure of normal (non-extended) results:\n        // \"suggestion\":[\"alt1\",\"alt2\"]\n        //\n        // Logical structure of the extended results:\n        // \"suggestion\":[\n        //     {\"word\":\"alt1\",\"freq\":7},\n        //     {\"word\":\"alt2\",\"freq\":4}\n        // ]\n        if (extendedResults && hasFreqInfo) {\n          suggestionList.add(\"origFreq\", spellingResult.getTokenFrequency(inputToken));\n\n          ArrayList<SimpleOrderedMap> sugs = new ArrayList<SimpleOrderedMap>();\n          suggestionList.add(\"suggestion\", sugs);\n          for (Map.Entry<String, Integer> suggEntry : theSuggestions.entrySet()) {\n            SimpleOrderedMap sugEntry = new SimpleOrderedMap();\n            sugEntry.add(\"word\",suggEntry.getKey());\n            sugEntry.add(\"freq\",suggEntry.getValue());\n            sugs.add(sugEntry);\n          }\n        } else {\n          suggestionList.add(\"suggestion\", theSuggestions.keySet());\n        }\n\n        if (hasFreqInfo) {\n          isCorrectlySpelled = isCorrectlySpelled && spellingResult.getTokenFrequency(inputToken) > 0;\n        }\n        result.add(new String(inputToken.buffer(), 0, inputToken.length()), suggestionList);\n      }\n    }\n    if (hasFreqInfo) {\n      result.add(\"correctlySpelled\", isCorrectlySpelled);\n    } else if(extendedResults && suggestions.size() == 0) { // if the word is misspelled, its added to suggestions with freqinfo\n      result.add(\"correctlySpelled\", true);\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#toNamedList(boolean,SpellingResult,String,boolean,boolean).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/SpellCheckComponent#toNamedList(boolean,SpellingResult,String,boolean,boolean).mjava","sourceNew":"  protected NamedList toNamedList(boolean shardRequest, SpellingResult spellingResult, String origQuery, boolean extendedResults, boolean collate) {\n    NamedList result = new NamedList();\n    Map<Token, LinkedHashMap<String, Integer>> suggestions = spellingResult.getSuggestions();\n    boolean hasFreqInfo = spellingResult.hasTokenFrequencyInfo();\n    boolean isCorrectlySpelled = false;\n    \n    int numSuggestions = 0;\n    for(LinkedHashMap<String, Integer> theSuggestion : suggestions.values())\n    {\n    \tif(theSuggestion.size()>0)\n    \t{\n    \t\tnumSuggestions++;\n    \t}\n    } \n    \n    // will be flipped to false if any of the suggestions are not in the index and hasFreqInfo is true\n    if(numSuggestions > 0) {\n      isCorrectlySpelled = true;\n    }\n    \n    for (Map.Entry<Token, LinkedHashMap<String, Integer>> entry : suggestions.entrySet()) {\n      Token inputToken = entry.getKey();\n      Map<String, Integer> theSuggestions = entry.getValue();\n      if (theSuggestions != null && (theSuggestions.size()>0 || shardRequest)) {\n        SimpleOrderedMap suggestionList = new SimpleOrderedMap();\n        suggestionList.add(\"numFound\", theSuggestions.size());\n        suggestionList.add(\"startOffset\", inputToken.startOffset());\n        suggestionList.add(\"endOffset\", inputToken.endOffset());\n\n        // Logical structure of normal (non-extended) results:\n        // \"suggestion\":[\"alt1\",\"alt2\"]\n        //\n        // Logical structure of the extended results:\n        // \"suggestion\":[\n        //     {\"word\":\"alt1\",\"freq\":7},\n        //     {\"word\":\"alt2\",\"freq\":4}\n        // ]\n        if (extendedResults && hasFreqInfo) {\n          suggestionList.add(\"origFreq\", spellingResult.getTokenFrequency(inputToken));\n\n          ArrayList<SimpleOrderedMap> sugs = new ArrayList<SimpleOrderedMap>();\n          suggestionList.add(\"suggestion\", sugs);\n          for (Map.Entry<String, Integer> suggEntry : theSuggestions.entrySet()) {\n            SimpleOrderedMap sugEntry = new SimpleOrderedMap();\n            sugEntry.add(\"word\",suggEntry.getKey());\n            sugEntry.add(\"freq\",suggEntry.getValue());\n            sugs.add(sugEntry);\n          }\n        } else {\n          suggestionList.add(\"suggestion\", theSuggestions.keySet());\n        }\n\n        if (hasFreqInfo) {\n          isCorrectlySpelled = isCorrectlySpelled && spellingResult.getTokenFrequency(inputToken) > 0;\n        }\n        result.add(new String(inputToken.buffer(), 0, inputToken.length()), suggestionList);\n      }\n    }\n    if (hasFreqInfo) {\n      result.add(\"correctlySpelled\", isCorrectlySpelled);\n    } else if(extendedResults && suggestions.size() == 0) { // if the word is misspelled, its added to suggestions with freqinfo\n      result.add(\"correctlySpelled\", true);\n    }\n    return result;\n  }\n\n","sourceOld":"  protected NamedList toNamedList(boolean shardRequest, SpellingResult spellingResult, String origQuery, boolean extendedResults, boolean collate) {\n    NamedList result = new NamedList();\n    Map<Token, LinkedHashMap<String, Integer>> suggestions = spellingResult.getSuggestions();\n    boolean hasFreqInfo = spellingResult.hasTokenFrequencyInfo();\n    boolean isCorrectlySpelled = false;\n    \n    int numSuggestions = 0;\n    for(LinkedHashMap<String, Integer> theSuggestion : suggestions.values())\n    {\n    \tif(theSuggestion.size()>0)\n    \t{\n    \t\tnumSuggestions++;\n    \t}\n    } \n    \n    // will be flipped to false if any of the suggestions are not in the index and hasFreqInfo is true\n    if(numSuggestions > 0) {\n      isCorrectlySpelled = true;\n    }\n    \n    for (Map.Entry<Token, LinkedHashMap<String, Integer>> entry : suggestions.entrySet()) {\n      Token inputToken = entry.getKey();\n      Map<String, Integer> theSuggestions = entry.getValue();\n      if (theSuggestions != null && (theSuggestions.size()>0 || shardRequest)) {\n        SimpleOrderedMap suggestionList = new SimpleOrderedMap();\n        suggestionList.add(\"numFound\", theSuggestions.size());\n        suggestionList.add(\"startOffset\", inputToken.startOffset());\n        suggestionList.add(\"endOffset\", inputToken.endOffset());\n\n        // Logical structure of normal (non-extended) results:\n        // \"suggestion\":[\"alt1\",\"alt2\"]\n        //\n        // Logical structure of the extended results:\n        // \"suggestion\":[\n        //     {\"word\":\"alt1\",\"freq\":7},\n        //     {\"word\":\"alt2\",\"freq\":4}\n        // ]\n        if (extendedResults && hasFreqInfo) {\n          suggestionList.add(\"origFreq\", spellingResult.getTokenFrequency(inputToken));\n\n          ArrayList<SimpleOrderedMap> sugs = new ArrayList<SimpleOrderedMap>();\n          suggestionList.add(\"suggestion\", sugs);\n          for (Map.Entry<String, Integer> suggEntry : theSuggestions.entrySet()) {\n            SimpleOrderedMap sugEntry = new SimpleOrderedMap();\n            sugEntry.add(\"word\",suggEntry.getKey());\n            sugEntry.add(\"freq\",suggEntry.getValue());\n            sugs.add(sugEntry);\n          }\n        } else {\n          suggestionList.add(\"suggestion\", theSuggestions.keySet());\n        }\n\n        if (hasFreqInfo) {\n          isCorrectlySpelled = isCorrectlySpelled && spellingResult.getTokenFrequency(inputToken) > 0;\n        }\n        result.add(new String(inputToken.buffer(), 0, inputToken.length()), suggestionList);\n      }\n    }\n    if (hasFreqInfo) {\n      result.add(\"correctlySpelled\", isCorrectlySpelled);\n    } else if(extendedResults && suggestions.size() == 0) { // if the word is misspelled, its added to suggestions with freqinfo\n      result.add(\"correctlySpelled\", true);\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#toNamedList(boolean,SpellingResult,String,boolean,boolean).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/SpellCheckComponent#toNamedList(boolean,SpellingResult,String,boolean,boolean).mjava","sourceNew":"  protected NamedList toNamedList(boolean shardRequest, SpellingResult spellingResult, String origQuery, boolean extendedResults, boolean collate) {\n    NamedList result = new NamedList();\n    Map<Token, LinkedHashMap<String, Integer>> suggestions = spellingResult.getSuggestions();\n    boolean hasFreqInfo = spellingResult.hasTokenFrequencyInfo();\n    boolean isCorrectlySpelled = false;\n    \n    int numSuggestions = 0;\n    for(LinkedHashMap<String, Integer> theSuggestion : suggestions.values())\n    {\n    \tif(theSuggestion.size()>0)\n    \t{\n    \t\tnumSuggestions++;\n    \t}\n    } \n    \n    // will be flipped to false if any of the suggestions are not in the index and hasFreqInfo is true\n    if(numSuggestions > 0) {\n      isCorrectlySpelled = true;\n    }\n    \n    for (Map.Entry<Token, LinkedHashMap<String, Integer>> entry : suggestions.entrySet()) {\n      Token inputToken = entry.getKey();\n      Map<String, Integer> theSuggestions = entry.getValue();\n      if (theSuggestions != null && (theSuggestions.size()>0 || shardRequest)) {\n        SimpleOrderedMap suggestionList = new SimpleOrderedMap();\n        suggestionList.add(\"numFound\", theSuggestions.size());\n        suggestionList.add(\"startOffset\", inputToken.startOffset());\n        suggestionList.add(\"endOffset\", inputToken.endOffset());\n\n        // Logical structure of normal (non-extended) results:\n        // \"suggestion\":[\"alt1\",\"alt2\"]\n        //\n        // Logical structure of the extended results:\n        // \"suggestion\":[\n        //     {\"word\":\"alt1\",\"freq\":7},\n        //     {\"word\":\"alt2\",\"freq\":4}\n        // ]\n        if (extendedResults && hasFreqInfo) {\n          suggestionList.add(\"origFreq\", spellingResult.getTokenFrequency(inputToken));\n\n          ArrayList<SimpleOrderedMap> sugs = new ArrayList<SimpleOrderedMap>();\n          suggestionList.add(\"suggestion\", sugs);\n          for (Map.Entry<String, Integer> suggEntry : theSuggestions.entrySet()) {\n            SimpleOrderedMap sugEntry = new SimpleOrderedMap();\n            sugEntry.add(\"word\",suggEntry.getKey());\n            sugEntry.add(\"freq\",suggEntry.getValue());\n            sugs.add(sugEntry);\n          }\n        } else {\n          suggestionList.add(\"suggestion\", theSuggestions.keySet());\n        }\n\n        if (hasFreqInfo) {\n          isCorrectlySpelled = isCorrectlySpelled && spellingResult.getTokenFrequency(inputToken) > 0;\n        }\n        result.add(new String(inputToken.buffer(), 0, inputToken.length()), suggestionList);\n      }\n    }\n    if (hasFreqInfo) {\n      result.add(\"correctlySpelled\", isCorrectlySpelled);\n    } else if(extendedResults && suggestions.size() == 0) { // if the word is misspelled, its added to suggestions with freqinfo\n      result.add(\"correctlySpelled\", true);\n    }\n    return result;\n  }\n\n","sourceOld":"  protected NamedList toNamedList(boolean shardRequest, SpellingResult spellingResult, String origQuery, boolean extendedResults, boolean collate) {\n    NamedList result = new NamedList();\n    Map<Token, LinkedHashMap<String, Integer>> suggestions = spellingResult.getSuggestions();\n    boolean hasFreqInfo = spellingResult.hasTokenFrequencyInfo();\n    boolean isCorrectlySpelled = false;\n    \n    int numSuggestions = 0;\n    for(LinkedHashMap<String, Integer> theSuggestion : suggestions.values())\n    {\n    \tif(theSuggestion.size()>0)\n    \t{\n    \t\tnumSuggestions++;\n    \t}\n    } \n    \n    // will be flipped to false if any of the suggestions are not in the index and hasFreqInfo is true\n    if(numSuggestions > 0) {\n      isCorrectlySpelled = true;\n    }\n    \n    for (Map.Entry<Token, LinkedHashMap<String, Integer>> entry : suggestions.entrySet()) {\n      Token inputToken = entry.getKey();\n      Map<String, Integer> theSuggestions = entry.getValue();\n      if (theSuggestions != null && (theSuggestions.size()>0 || shardRequest)) {\n        SimpleOrderedMap suggestionList = new SimpleOrderedMap();\n        suggestionList.add(\"numFound\", theSuggestions.size());\n        suggestionList.add(\"startOffset\", inputToken.startOffset());\n        suggestionList.add(\"endOffset\", inputToken.endOffset());\n\n        // Logical structure of normal (non-extended) results:\n        // \"suggestion\":[\"alt1\",\"alt2\"]\n        //\n        // Logical structure of the extended results:\n        // \"suggestion\":[\n        //     {\"word\":\"alt1\",\"freq\":7},\n        //     {\"word\":\"alt2\",\"freq\":4}\n        // ]\n        if (extendedResults && hasFreqInfo) {\n          suggestionList.add(\"origFreq\", spellingResult.getTokenFrequency(inputToken));\n\n          ArrayList<SimpleOrderedMap> sugs = new ArrayList<SimpleOrderedMap>();\n          suggestionList.add(\"suggestion\", sugs);\n          for (Map.Entry<String, Integer> suggEntry : theSuggestions.entrySet()) {\n            SimpleOrderedMap sugEntry = new SimpleOrderedMap();\n            sugEntry.add(\"word\",suggEntry.getKey());\n            sugEntry.add(\"freq\",suggEntry.getValue());\n            sugs.add(sugEntry);\n          }\n        } else {\n          suggestionList.add(\"suggestion\", theSuggestions.keySet());\n        }\n\n        if (hasFreqInfo) {\n          isCorrectlySpelled = isCorrectlySpelled && spellingResult.getTokenFrequency(inputToken) > 0;\n        }\n        result.add(new String(inputToken.buffer(), 0, inputToken.length()), suggestionList);\n      }\n    }\n    if (hasFreqInfo) {\n      result.add(\"correctlySpelled\", isCorrectlySpelled);\n    } else if(extendedResults && suggestions.size() == 0) { // if the word is misspelled, its added to suggestions with freqinfo\n      result.add(\"correctlySpelled\", true);\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d6aab5206b894bf0ea232b059a45cf2de460726f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["cdcf766020b9b159d0b3a6ecae90ff1998ded019"],"cdcf766020b9b159d0b3a6ecae90ff1998ded019":["d6aab5206b894bf0ea232b059a45cf2de460726f"],"c26f00b574427b55127e869b935845554afde1fa":["cdcf766020b9b159d0b3a6ecae90ff1998ded019","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a258fbb26824fd104ed795e5d9033d2d040049ee":["cdcf766020b9b159d0b3a6ecae90ff1998ded019"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","cdcf766020b9b159d0b3a6ecae90ff1998ded019"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c26f00b574427b55127e869b935845554afde1fa"]},"commit2Childs":{"d6aab5206b894bf0ea232b059a45cf2de460726f":["cdcf766020b9b159d0b3a6ecae90ff1998ded019"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"cdcf766020b9b159d0b3a6ecae90ff1998ded019":["c903c3d15906a3da96b8c0c2fb704491005fdbdb","c26f00b574427b55127e869b935845554afde1fa","a258fbb26824fd104ed795e5d9033d2d040049ee","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"c26f00b574427b55127e869b935845554afde1fa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d6aab5206b894bf0ea232b059a45cf2de460726f","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a258fbb26824fd104ed795e5d9033d2d040049ee","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}