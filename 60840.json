{"path":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T],int).mjava","commits":[{"id":"651a27b35167c2ea81f87f4749722e52b7d5b750","date":1359669118,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T],int).mjava","pathOld":"/dev/null","sourceNew":"  /** Load a previously saved FST; maxBlockBits allows you to\n   *  control the size of the byte[] pages used to hold the FST bytes. */\n  public FST(DataInput in, Outputs<T> outputs, int maxBlockBits) throws IOException {\n    this.outputs = outputs;\n\n    if (maxBlockBits < 1 || maxBlockBits > 30) {\n      throw new IllegalArgumentException(\"maxBlockBits should be 1 .. 30; got \" + maxBlockBits);\n    }\n\n    // NOTE: only reads most recent format; we don't have\n    // back-compat promise for FSTs (they are experimental):\n    version = CodecUtil.checkHeader(in, FILE_FORMAT_NAME, VERSION_PACKED, VERSION_VINT_TARGET);\n    packed = in.readByte() == 1;\n    if (in.readByte() == 1) {\n      // accepts empty string\n      // 1 KB blocks:\n      BytesStore emptyBytes = new BytesStore(10);\n      int numBytes = in.readVInt();\n      emptyBytes.copyBytes(in, numBytes);\n\n      // De-serialize empty-string output:\n      BytesReader reader;\n      if (packed) {\n        reader = emptyBytes.getForwardReader();\n      } else {\n        reader = emptyBytes.getReverseReader();\n        // NoOutputs uses 0 bytes when writing its output,\n        // so we have to check here else BytesStore gets\n        // angry:\n        if (numBytes > 0) {\n          reader.setPosition(numBytes-1);\n        }\n      }\n      emptyOutput = outputs.readFinalOutput(reader);\n    } else {\n      emptyOutput = null;\n    }\n    final byte t = in.readByte();\n    switch(t) {\n      case 0:\n        inputType = INPUT_TYPE.BYTE1;\n        break;\n      case 1:\n        inputType = INPUT_TYPE.BYTE2;\n        break;\n      case 2:\n        inputType = INPUT_TYPE.BYTE4;\n        break;\n    default:\n      throw new IllegalStateException(\"invalid input type \" + t);\n    }\n    if (packed) {\n      nodeRefToAddress = PackedInts.getReader(in);\n    } else {\n      nodeRefToAddress = null;\n    }\n    startNode = in.readVLong();\n    nodeCount = in.readVLong();\n    arcCount = in.readVLong();\n    arcWithOutputCount = in.readVLong();\n\n    long numBytes = in.readVLong();\n    bytes = new BytesStore(in, numBytes, 1<<maxBlockBits);\n    \n    NO_OUTPUT = outputs.getNoOutput();\n\n    cacheRootArcs();\n\n    // NOTE: bogus because this is only used during\n    // building; we need to break out mutable FST from\n    // immutable\n    allowArrayArcs = false;\n\n    /*\n    if (bytes.length == 665) {\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n      Util.toDot(this, w, false, false);\n      w.close();\n      System.out.println(\"Wrote FST to out.dot\");\n    }\n    */\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0bf1d4eb51af6e03fffcbf80f0b5d69923c9f86","date":1359670147,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T],int).mjava","pathOld":"/dev/null","sourceNew":"  /** Load a previously saved FST; maxBlockBits allows you to\n   *  control the size of the byte[] pages used to hold the FST bytes. */\n  public FST(DataInput in, Outputs<T> outputs, int maxBlockBits) throws IOException {\n    this.outputs = outputs;\n\n    if (maxBlockBits < 1 || maxBlockBits > 30) {\n      throw new IllegalArgumentException(\"maxBlockBits should be 1 .. 30; got \" + maxBlockBits);\n    }\n\n    // NOTE: only reads most recent format; we don't have\n    // back-compat promise for FSTs (they are experimental):\n    version = CodecUtil.checkHeader(in, FILE_FORMAT_NAME, VERSION_PACKED, VERSION_VINT_TARGET);\n    packed = in.readByte() == 1;\n    if (in.readByte() == 1) {\n      // accepts empty string\n      // 1 KB blocks:\n      BytesStore emptyBytes = new BytesStore(10);\n      int numBytes = in.readVInt();\n      emptyBytes.copyBytes(in, numBytes);\n\n      // De-serialize empty-string output:\n      BytesReader reader;\n      if (packed) {\n        reader = emptyBytes.getForwardReader();\n      } else {\n        reader = emptyBytes.getReverseReader();\n        // NoOutputs uses 0 bytes when writing its output,\n        // so we have to check here else BytesStore gets\n        // angry:\n        if (numBytes > 0) {\n          reader.setPosition(numBytes-1);\n        }\n      }\n      emptyOutput = outputs.readFinalOutput(reader);\n    } else {\n      emptyOutput = null;\n    }\n    final byte t = in.readByte();\n    switch(t) {\n      case 0:\n        inputType = INPUT_TYPE.BYTE1;\n        break;\n      case 1:\n        inputType = INPUT_TYPE.BYTE2;\n        break;\n      case 2:\n        inputType = INPUT_TYPE.BYTE4;\n        break;\n    default:\n      throw new IllegalStateException(\"invalid input type \" + t);\n    }\n    if (packed) {\n      nodeRefToAddress = PackedInts.getReader(in);\n    } else {\n      nodeRefToAddress = null;\n    }\n    startNode = in.readVLong();\n    nodeCount = in.readVLong();\n    arcCount = in.readVLong();\n    arcWithOutputCount = in.readVLong();\n\n    long numBytes = in.readVLong();\n    bytes = new BytesStore(in, numBytes, 1<<maxBlockBits);\n    \n    NO_OUTPUT = outputs.getNoOutput();\n\n    cacheRootArcs();\n\n    // NOTE: bogus because this is only used during\n    // building; we need to break out mutable FST from\n    // immutable\n    allowArrayArcs = false;\n\n    /*\n    if (bytes.length == 665) {\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n      Util.toDot(this, w, false, false);\n      w.close();\n      System.out.println(\"Wrote FST to out.dot\");\n    }\n    */\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7d89d7e4e5101347833eea558851bf4209218619","date":1396265641,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T],int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T],int).mjava","sourceNew":"  /** Load a previously saved FST; maxBlockBits allows you to\n   *  control the size of the byte[] pages used to hold the FST bytes. */\n  public FST(DataInput in, Outputs<T> outputs, int maxBlockBits) throws IOException {\n    this.outputs = outputs;\n\n    if (maxBlockBits < 1 || maxBlockBits > 30) {\n      throw new IllegalArgumentException(\"maxBlockBits should be 1 .. 30; got \" + maxBlockBits);\n    }\n\n    // NOTE: only reads most recent format; we don't have\n    // back-compat promise for FSTs (they are experimental):\n    version = CodecUtil.checkHeader(in, FILE_FORMAT_NAME, VERSION_PACKED, VERSION_VINT_TARGET);\n    packed = in.readByte() == 1;\n    if (in.readByte() == 1) {\n      // accepts empty string\n      // 1 KB blocks:\n      BytesStore emptyBytes = new BytesStore(10);\n      int numBytes = in.readVInt();\n      emptyBytes.copyBytes(in, numBytes);\n\n      // De-serialize empty-string output:\n      BytesReader reader;\n      if (packed) {\n        reader = emptyBytes.getForwardReader();\n      } else {\n        reader = emptyBytes.getReverseReader();\n        // NoOutputs uses 0 bytes when writing its output,\n        // so we have to check here else BytesStore gets\n        // angry:\n        if (numBytes > 0) {\n          reader.setPosition(numBytes-1);\n        }\n      }\n      emptyOutput = outputs.readFinalOutput(reader);\n    } else {\n      emptyOutput = null;\n    }\n    final byte t = in.readByte();\n    switch(t) {\n      case 0:\n        inputType = INPUT_TYPE.BYTE1;\n        break;\n      case 1:\n        inputType = INPUT_TYPE.BYTE2;\n        break;\n      case 2:\n        inputType = INPUT_TYPE.BYTE4;\n        break;\n    default:\n      throw new IllegalStateException(\"invalid input type \" + t);\n    }\n    if (packed) {\n      nodeRefToAddress = PackedInts.getReader(in);\n    } else {\n      nodeRefToAddress = null;\n    }\n    startNode = in.readVLong();\n    nodeCount = in.readVLong();\n    arcCount = in.readVLong();\n    arcWithOutputCount = in.readVLong();\n\n    long numBytes = in.readVLong();\n    bytes = new BytesStore(in, numBytes, 1<<maxBlockBits);\n    \n    NO_OUTPUT = outputs.getNoOutput();\n\n    cacheRootArcs();\n\n    // NOTE: bogus because this is only used during\n    // building; we need to break out mutable FST from\n    // immutable\n    allowArrayArcs = false;\n\n    /*\n    if (bytes.length == 665) {\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), StandardCharsets.UTF_8);\n      Util.toDot(this, w, false, false);\n      w.close();\n      System.out.println(\"Wrote FST to out.dot\");\n    }\n    */\n  }\n\n","sourceOld":"  /** Load a previously saved FST; maxBlockBits allows you to\n   *  control the size of the byte[] pages used to hold the FST bytes. */\n  public FST(DataInput in, Outputs<T> outputs, int maxBlockBits) throws IOException {\n    this.outputs = outputs;\n\n    if (maxBlockBits < 1 || maxBlockBits > 30) {\n      throw new IllegalArgumentException(\"maxBlockBits should be 1 .. 30; got \" + maxBlockBits);\n    }\n\n    // NOTE: only reads most recent format; we don't have\n    // back-compat promise for FSTs (they are experimental):\n    version = CodecUtil.checkHeader(in, FILE_FORMAT_NAME, VERSION_PACKED, VERSION_VINT_TARGET);\n    packed = in.readByte() == 1;\n    if (in.readByte() == 1) {\n      // accepts empty string\n      // 1 KB blocks:\n      BytesStore emptyBytes = new BytesStore(10);\n      int numBytes = in.readVInt();\n      emptyBytes.copyBytes(in, numBytes);\n\n      // De-serialize empty-string output:\n      BytesReader reader;\n      if (packed) {\n        reader = emptyBytes.getForwardReader();\n      } else {\n        reader = emptyBytes.getReverseReader();\n        // NoOutputs uses 0 bytes when writing its output,\n        // so we have to check here else BytesStore gets\n        // angry:\n        if (numBytes > 0) {\n          reader.setPosition(numBytes-1);\n        }\n      }\n      emptyOutput = outputs.readFinalOutput(reader);\n    } else {\n      emptyOutput = null;\n    }\n    final byte t = in.readByte();\n    switch(t) {\n      case 0:\n        inputType = INPUT_TYPE.BYTE1;\n        break;\n      case 1:\n        inputType = INPUT_TYPE.BYTE2;\n        break;\n      case 2:\n        inputType = INPUT_TYPE.BYTE4;\n        break;\n    default:\n      throw new IllegalStateException(\"invalid input type \" + t);\n    }\n    if (packed) {\n      nodeRefToAddress = PackedInts.getReader(in);\n    } else {\n      nodeRefToAddress = null;\n    }\n    startNode = in.readVLong();\n    nodeCount = in.readVLong();\n    arcCount = in.readVLong();\n    arcWithOutputCount = in.readVLong();\n\n    long numBytes = in.readVLong();\n    bytes = new BytesStore(in, numBytes, 1<<maxBlockBits);\n    \n    NO_OUTPUT = outputs.getNoOutput();\n\n    cacheRootArcs();\n\n    // NOTE: bogus because this is only used during\n    // building; we need to break out mutable FST from\n    // immutable\n    allowArrayArcs = false;\n\n    /*\n    if (bytes.length == 665) {\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n      Util.toDot(this, w, false, false);\n      w.close();\n      System.out.println(\"Wrote FST to out.dot\");\n    }\n    */\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5eb2511ababf862ea11e10761c70ee560cd84510","date":1396607225,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T],int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T],int).mjava","sourceNew":"  /** Load a previously saved FST; maxBlockBits allows you to\n   *  control the size of the byte[] pages used to hold the FST bytes. */\n  public FST(DataInput in, Outputs<T> outputs, int maxBlockBits) throws IOException {\n    this.outputs = outputs;\n\n    if (maxBlockBits < 1 || maxBlockBits > 30) {\n      throw new IllegalArgumentException(\"maxBlockBits should be 1 .. 30; got \" + maxBlockBits);\n    }\n\n    // NOTE: only reads most recent format; we don't have\n    // back-compat promise for FSTs (they are experimental):\n    version = CodecUtil.checkHeader(in, FILE_FORMAT_NAME, VERSION_PACKED, VERSION_VINT_TARGET);\n    packed = in.readByte() == 1;\n    if (in.readByte() == 1) {\n      // accepts empty string\n      // 1 KB blocks:\n      BytesStore emptyBytes = new BytesStore(10);\n      int numBytes = in.readVInt();\n      emptyBytes.copyBytes(in, numBytes);\n\n      // De-serialize empty-string output:\n      BytesReader reader;\n      if (packed) {\n        reader = emptyBytes.getForwardReader();\n      } else {\n        reader = emptyBytes.getReverseReader();\n        // NoOutputs uses 0 bytes when writing its output,\n        // so we have to check here else BytesStore gets\n        // angry:\n        if (numBytes > 0) {\n          reader.setPosition(numBytes-1);\n        }\n      }\n      emptyOutput = outputs.readFinalOutput(reader);\n    } else {\n      emptyOutput = null;\n    }\n    final byte t = in.readByte();\n    switch(t) {\n      case 0:\n        inputType = INPUT_TYPE.BYTE1;\n        break;\n      case 1:\n        inputType = INPUT_TYPE.BYTE2;\n        break;\n      case 2:\n        inputType = INPUT_TYPE.BYTE4;\n        break;\n    default:\n      throw new IllegalStateException(\"invalid input type \" + t);\n    }\n    if (packed) {\n      nodeRefToAddress = PackedInts.getReader(in);\n    } else {\n      nodeRefToAddress = null;\n    }\n    startNode = in.readVLong();\n    nodeCount = in.readVLong();\n    arcCount = in.readVLong();\n    arcWithOutputCount = in.readVLong();\n\n    long numBytes = in.readVLong();\n    bytes = new BytesStore(in, numBytes, 1<<maxBlockBits);\n    \n    NO_OUTPUT = outputs.getNoOutput();\n\n    cacheRootArcs();\n\n    // NOTE: bogus because this is only used during\n    // building; we need to break out mutable FST from\n    // immutable\n    allowArrayArcs = false;\n\n    /*\n    if (bytes.length == 665) {\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), StandardCharsets.UTF_8);\n      Util.toDot(this, w, false, false);\n      w.close();\n      System.out.println(\"Wrote FST to out.dot\");\n    }\n    */\n  }\n\n","sourceOld":"  /** Load a previously saved FST; maxBlockBits allows you to\n   *  control the size of the byte[] pages used to hold the FST bytes. */\n  public FST(DataInput in, Outputs<T> outputs, int maxBlockBits) throws IOException {\n    this.outputs = outputs;\n\n    if (maxBlockBits < 1 || maxBlockBits > 30) {\n      throw new IllegalArgumentException(\"maxBlockBits should be 1 .. 30; got \" + maxBlockBits);\n    }\n\n    // NOTE: only reads most recent format; we don't have\n    // back-compat promise for FSTs (they are experimental):\n    version = CodecUtil.checkHeader(in, FILE_FORMAT_NAME, VERSION_PACKED, VERSION_VINT_TARGET);\n    packed = in.readByte() == 1;\n    if (in.readByte() == 1) {\n      // accepts empty string\n      // 1 KB blocks:\n      BytesStore emptyBytes = new BytesStore(10);\n      int numBytes = in.readVInt();\n      emptyBytes.copyBytes(in, numBytes);\n\n      // De-serialize empty-string output:\n      BytesReader reader;\n      if (packed) {\n        reader = emptyBytes.getForwardReader();\n      } else {\n        reader = emptyBytes.getReverseReader();\n        // NoOutputs uses 0 bytes when writing its output,\n        // so we have to check here else BytesStore gets\n        // angry:\n        if (numBytes > 0) {\n          reader.setPosition(numBytes-1);\n        }\n      }\n      emptyOutput = outputs.readFinalOutput(reader);\n    } else {\n      emptyOutput = null;\n    }\n    final byte t = in.readByte();\n    switch(t) {\n      case 0:\n        inputType = INPUT_TYPE.BYTE1;\n        break;\n      case 1:\n        inputType = INPUT_TYPE.BYTE2;\n        break;\n      case 2:\n        inputType = INPUT_TYPE.BYTE4;\n        break;\n    default:\n      throw new IllegalStateException(\"invalid input type \" + t);\n    }\n    if (packed) {\n      nodeRefToAddress = PackedInts.getReader(in);\n    } else {\n      nodeRefToAddress = null;\n    }\n    startNode = in.readVLong();\n    nodeCount = in.readVLong();\n    arcCount = in.readVLong();\n    arcWithOutputCount = in.readVLong();\n\n    long numBytes = in.readVLong();\n    bytes = new BytesStore(in, numBytes, 1<<maxBlockBits);\n    \n    NO_OUTPUT = outputs.getNoOutput();\n\n    cacheRootArcs();\n\n    // NOTE: bogus because this is only used during\n    // building; we need to break out mutable FST from\n    // immutable\n    allowArrayArcs = false;\n\n    /*\n    if (bytes.length == 665) {\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), \"UTF-8\");\n      Util.toDot(this, w, false, false);\n      w.close();\n      System.out.println(\"Wrote FST to out.dot\");\n    }\n    */\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1abb939fb41b2fe4f89fd518f3da288c0213341d","date":1435657417,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T],int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T],int).mjava","sourceNew":"  /** Load a previously saved FST; maxBlockBits allows you to\n   *  control the size of the byte[] pages used to hold the FST bytes. */\n  public FST(DataInput in, Outputs<T> outputs, int maxBlockBits) throws IOException {\n    this.outputs = outputs;\n\n    if (maxBlockBits < 1 || maxBlockBits > 30) {\n      throw new IllegalArgumentException(\"maxBlockBits should be 1 .. 30; got \" + maxBlockBits);\n    }\n\n    // NOTE: only reads most recent format; we don't have\n    // back-compat promise for FSTs (they are experimental):\n    version = CodecUtil.checkHeader(in, FILE_FORMAT_NAME, VERSION_PACKED, VERSION_NO_NODE_ARC_COUNTS);\n    packed = in.readByte() == 1;\n    if (in.readByte() == 1) {\n      // accepts empty string\n      // 1 KB blocks:\n      BytesStore emptyBytes = new BytesStore(10);\n      int numBytes = in.readVInt();\n      emptyBytes.copyBytes(in, numBytes);\n\n      // De-serialize empty-string output:\n      BytesReader reader;\n      if (packed) {\n        reader = emptyBytes.getForwardReader();\n      } else {\n        reader = emptyBytes.getReverseReader();\n        // NoOutputs uses 0 bytes when writing its output,\n        // so we have to check here else BytesStore gets\n        // angry:\n        if (numBytes > 0) {\n          reader.setPosition(numBytes-1);\n        }\n      }\n      emptyOutput = outputs.readFinalOutput(reader);\n    } else {\n      emptyOutput = null;\n    }\n    final byte t = in.readByte();\n    switch(t) {\n      case 0:\n        inputType = INPUT_TYPE.BYTE1;\n        break;\n      case 1:\n        inputType = INPUT_TYPE.BYTE2;\n        break;\n      case 2:\n        inputType = INPUT_TYPE.BYTE4;\n        break;\n    default:\n      throw new IllegalStateException(\"invalid input type \" + t);\n    }\n    if (packed) {\n      nodeRefToAddress = PackedInts.getReader(in);\n    } else {\n      nodeRefToAddress = null;\n    }\n    startNode = in.readVLong();\n    if (version < VERSION_NO_NODE_ARC_COUNTS) {\n      in.readVLong();\n      in.readVLong();\n      in.readVLong();\n    }\n\n    long numBytes = in.readVLong();\n    if (numBytes > 1 << maxBlockBits) {\n      // FST is big: we need multiple pages\n      bytes = new BytesStore(in, numBytes, 1<<maxBlockBits);\n      bytesArray = null;\n    } else {\n      // FST fits into a single block: use ByteArrayBytesStoreReader for less overhead\n      bytes = null;\n      bytesArray = new byte[(int) numBytes];\n      in.readBytes(bytesArray, 0, bytesArray.length);\n    }\n    \n    cacheRootArcs();\n  }\n\n","sourceOld":"  /** Load a previously saved FST; maxBlockBits allows you to\n   *  control the size of the byte[] pages used to hold the FST bytes. */\n  public FST(DataInput in, Outputs<T> outputs, int maxBlockBits) throws IOException {\n    this.outputs = outputs;\n\n    if (maxBlockBits < 1 || maxBlockBits > 30) {\n      throw new IllegalArgumentException(\"maxBlockBits should be 1 .. 30; got \" + maxBlockBits);\n    }\n\n    // NOTE: only reads most recent format; we don't have\n    // back-compat promise for FSTs (they are experimental):\n    version = CodecUtil.checkHeader(in, FILE_FORMAT_NAME, VERSION_PACKED, VERSION_VINT_TARGET);\n    packed = in.readByte() == 1;\n    if (in.readByte() == 1) {\n      // accepts empty string\n      // 1 KB blocks:\n      BytesStore emptyBytes = new BytesStore(10);\n      int numBytes = in.readVInt();\n      emptyBytes.copyBytes(in, numBytes);\n\n      // De-serialize empty-string output:\n      BytesReader reader;\n      if (packed) {\n        reader = emptyBytes.getForwardReader();\n      } else {\n        reader = emptyBytes.getReverseReader();\n        // NoOutputs uses 0 bytes when writing its output,\n        // so we have to check here else BytesStore gets\n        // angry:\n        if (numBytes > 0) {\n          reader.setPosition(numBytes-1);\n        }\n      }\n      emptyOutput = outputs.readFinalOutput(reader);\n    } else {\n      emptyOutput = null;\n    }\n    final byte t = in.readByte();\n    switch(t) {\n      case 0:\n        inputType = INPUT_TYPE.BYTE1;\n        break;\n      case 1:\n        inputType = INPUT_TYPE.BYTE2;\n        break;\n      case 2:\n        inputType = INPUT_TYPE.BYTE4;\n        break;\n    default:\n      throw new IllegalStateException(\"invalid input type \" + t);\n    }\n    if (packed) {\n      nodeRefToAddress = PackedInts.getReader(in);\n    } else {\n      nodeRefToAddress = null;\n    }\n    startNode = in.readVLong();\n    nodeCount = in.readVLong();\n    arcCount = in.readVLong();\n    arcWithOutputCount = in.readVLong();\n\n    long numBytes = in.readVLong();\n    bytes = new BytesStore(in, numBytes, 1<<maxBlockBits);\n    \n    NO_OUTPUT = outputs.getNoOutput();\n\n    cacheRootArcs();\n\n    // NOTE: bogus because this is only used during\n    // building; we need to break out mutable FST from\n    // immutable\n    allowArrayArcs = false;\n\n    /*\n    if (bytes.length == 665) {\n      Writer w = new OutputStreamWriter(new FileOutputStream(\"out.dot\"), StandardCharsets.UTF_8);\n      Util.toDot(this, w, false, false);\n      w.close();\n      System.out.println(\"Wrote FST to out.dot\");\n    }\n    */\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6244579a467d5f2673ac98265d74bddbea1a8114","date":1478786509,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T],int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T],int).mjava","sourceNew":"  /** Load a previously saved FST; maxBlockBits allows you to\n   *  control the size of the byte[] pages used to hold the FST bytes. */\n  public FST(DataInput in, Outputs<T> outputs, int maxBlockBits) throws IOException {\n    this.outputs = outputs;\n\n    if (maxBlockBits < 1 || maxBlockBits > 30) {\n      throw new IllegalArgumentException(\"maxBlockBits should be 1 .. 30; got \" + maxBlockBits);\n    }\n\n    // NOTE: only reads most recent format; we don't have\n    // back-compat promise for FSTs (they are experimental):\n    version = CodecUtil.checkHeader(in, FILE_FORMAT_NAME, VERSION_PACKED, VERSION_CURRENT);\n    if (version < VERSION_PACKED_REMOVED) {\n      if (in.readByte() == 1) {\n        throw new CorruptIndexException(\"Cannot read packed FSTs anymore\", in);\n      }\n    }\n    if (in.readByte() == 1) {\n      // accepts empty string\n      // 1 KB blocks:\n      BytesStore emptyBytes = new BytesStore(10);\n      int numBytes = in.readVInt();\n      emptyBytes.copyBytes(in, numBytes);\n\n      // De-serialize empty-string output:\n      BytesReader reader = emptyBytes.getReverseReader();\n      // NoOutputs uses 0 bytes when writing its output,\n      // so we have to check here else BytesStore gets\n      // angry:\n      if (numBytes > 0) {\n        reader.setPosition(numBytes-1);\n      }\n      emptyOutput = outputs.readFinalOutput(reader);\n    } else {\n      emptyOutput = null;\n    }\n    final byte t = in.readByte();\n    switch(t) {\n      case 0:\n        inputType = INPUT_TYPE.BYTE1;\n        break;\n      case 1:\n        inputType = INPUT_TYPE.BYTE2;\n        break;\n      case 2:\n        inputType = INPUT_TYPE.BYTE4;\n        break;\n    default:\n      throw new IllegalStateException(\"invalid input type \" + t);\n    }\n    startNode = in.readVLong();\n    if (version < VERSION_NO_NODE_ARC_COUNTS) {\n      in.readVLong();\n      in.readVLong();\n      in.readVLong();\n    }\n\n    long numBytes = in.readVLong();\n    if (numBytes > 1 << maxBlockBits) {\n      // FST is big: we need multiple pages\n      bytes = new BytesStore(in, numBytes, 1<<maxBlockBits);\n      bytesArray = null;\n    } else {\n      // FST fits into a single block: use ByteArrayBytesStoreReader for less overhead\n      bytes = null;\n      bytesArray = new byte[(int) numBytes];\n      in.readBytes(bytesArray, 0, bytesArray.length);\n    }\n    \n    cacheRootArcs();\n  }\n\n","sourceOld":"  /** Load a previously saved FST; maxBlockBits allows you to\n   *  control the size of the byte[] pages used to hold the FST bytes. */\n  public FST(DataInput in, Outputs<T> outputs, int maxBlockBits) throws IOException {\n    this.outputs = outputs;\n\n    if (maxBlockBits < 1 || maxBlockBits > 30) {\n      throw new IllegalArgumentException(\"maxBlockBits should be 1 .. 30; got \" + maxBlockBits);\n    }\n\n    // NOTE: only reads most recent format; we don't have\n    // back-compat promise for FSTs (they are experimental):\n    version = CodecUtil.checkHeader(in, FILE_FORMAT_NAME, VERSION_PACKED, VERSION_NO_NODE_ARC_COUNTS);\n    packed = in.readByte() == 1;\n    if (in.readByte() == 1) {\n      // accepts empty string\n      // 1 KB blocks:\n      BytesStore emptyBytes = new BytesStore(10);\n      int numBytes = in.readVInt();\n      emptyBytes.copyBytes(in, numBytes);\n\n      // De-serialize empty-string output:\n      BytesReader reader;\n      if (packed) {\n        reader = emptyBytes.getForwardReader();\n      } else {\n        reader = emptyBytes.getReverseReader();\n        // NoOutputs uses 0 bytes when writing its output,\n        // so we have to check here else BytesStore gets\n        // angry:\n        if (numBytes > 0) {\n          reader.setPosition(numBytes-1);\n        }\n      }\n      emptyOutput = outputs.readFinalOutput(reader);\n    } else {\n      emptyOutput = null;\n    }\n    final byte t = in.readByte();\n    switch(t) {\n      case 0:\n        inputType = INPUT_TYPE.BYTE1;\n        break;\n      case 1:\n        inputType = INPUT_TYPE.BYTE2;\n        break;\n      case 2:\n        inputType = INPUT_TYPE.BYTE4;\n        break;\n    default:\n      throw new IllegalStateException(\"invalid input type \" + t);\n    }\n    if (packed) {\n      nodeRefToAddress = PackedInts.getReader(in);\n    } else {\n      nodeRefToAddress = null;\n    }\n    startNode = in.readVLong();\n    if (version < VERSION_NO_NODE_ARC_COUNTS) {\n      in.readVLong();\n      in.readVLong();\n      in.readVLong();\n    }\n\n    long numBytes = in.readVLong();\n    if (numBytes > 1 << maxBlockBits) {\n      // FST is big: we need multiple pages\n      bytes = new BytesStore(in, numBytes, 1<<maxBlockBits);\n      bytesArray = null;\n    } else {\n      // FST fits into a single block: use ByteArrayBytesStoreReader for less overhead\n      bytes = null;\n      bytesArray = new byte[(int) numBytes];\n      in.readBytes(bytesArray, 0, bytesArray.length);\n    }\n    \n    cacheRootArcs();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"199dfa410f1fdbfd3294106b04096cce5ed34b21","date":1478812506,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T],int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T],int).mjava","sourceNew":"  /** Load a previously saved FST; maxBlockBits allows you to\n   *  control the size of the byte[] pages used to hold the FST bytes. */\n  public FST(DataInput in, Outputs<T> outputs, int maxBlockBits) throws IOException {\n    this.outputs = outputs;\n\n    if (maxBlockBits < 1 || maxBlockBits > 30) {\n      throw new IllegalArgumentException(\"maxBlockBits should be 1 .. 30; got \" + maxBlockBits);\n    }\n\n    // NOTE: only reads most recent format; we don't have\n    // back-compat promise for FSTs (they are experimental):\n    version = CodecUtil.checkHeader(in, FILE_FORMAT_NAME, VERSION_PACKED, VERSION_CURRENT);\n    if (version < VERSION_PACKED_REMOVED) {\n      if (in.readByte() == 1) {\n        throw new CorruptIndexException(\"Cannot read packed FSTs anymore\", in);\n      }\n    }\n    if (in.readByte() == 1) {\n      // accepts empty string\n      // 1 KB blocks:\n      BytesStore emptyBytes = new BytesStore(10);\n      int numBytes = in.readVInt();\n      emptyBytes.copyBytes(in, numBytes);\n\n      // De-serialize empty-string output:\n      BytesReader reader = emptyBytes.getReverseReader();\n      // NoOutputs uses 0 bytes when writing its output,\n      // so we have to check here else BytesStore gets\n      // angry:\n      if (numBytes > 0) {\n        reader.setPosition(numBytes-1);\n      }\n      emptyOutput = outputs.readFinalOutput(reader);\n    } else {\n      emptyOutput = null;\n    }\n    final byte t = in.readByte();\n    switch(t) {\n      case 0:\n        inputType = INPUT_TYPE.BYTE1;\n        break;\n      case 1:\n        inputType = INPUT_TYPE.BYTE2;\n        break;\n      case 2:\n        inputType = INPUT_TYPE.BYTE4;\n        break;\n    default:\n      throw new IllegalStateException(\"invalid input type \" + t);\n    }\n    startNode = in.readVLong();\n    if (version < VERSION_NO_NODE_ARC_COUNTS) {\n      in.readVLong();\n      in.readVLong();\n      in.readVLong();\n    }\n\n    long numBytes = in.readVLong();\n    if (numBytes > 1 << maxBlockBits) {\n      // FST is big: we need multiple pages\n      bytes = new BytesStore(in, numBytes, 1<<maxBlockBits);\n      bytesArray = null;\n    } else {\n      // FST fits into a single block: use ByteArrayBytesStoreReader for less overhead\n      bytes = null;\n      bytesArray = new byte[(int) numBytes];\n      in.readBytes(bytesArray, 0, bytesArray.length);\n    }\n    \n    cacheRootArcs();\n  }\n\n","sourceOld":"  /** Load a previously saved FST; maxBlockBits allows you to\n   *  control the size of the byte[] pages used to hold the FST bytes. */\n  public FST(DataInput in, Outputs<T> outputs, int maxBlockBits) throws IOException {\n    this.outputs = outputs;\n\n    if (maxBlockBits < 1 || maxBlockBits > 30) {\n      throw new IllegalArgumentException(\"maxBlockBits should be 1 .. 30; got \" + maxBlockBits);\n    }\n\n    // NOTE: only reads most recent format; we don't have\n    // back-compat promise for FSTs (they are experimental):\n    version = CodecUtil.checkHeader(in, FILE_FORMAT_NAME, VERSION_PACKED, VERSION_NO_NODE_ARC_COUNTS);\n    packed = in.readByte() == 1;\n    if (in.readByte() == 1) {\n      // accepts empty string\n      // 1 KB blocks:\n      BytesStore emptyBytes = new BytesStore(10);\n      int numBytes = in.readVInt();\n      emptyBytes.copyBytes(in, numBytes);\n\n      // De-serialize empty-string output:\n      BytesReader reader;\n      if (packed) {\n        reader = emptyBytes.getForwardReader();\n      } else {\n        reader = emptyBytes.getReverseReader();\n        // NoOutputs uses 0 bytes when writing its output,\n        // so we have to check here else BytesStore gets\n        // angry:\n        if (numBytes > 0) {\n          reader.setPosition(numBytes-1);\n        }\n      }\n      emptyOutput = outputs.readFinalOutput(reader);\n    } else {\n      emptyOutput = null;\n    }\n    final byte t = in.readByte();\n    switch(t) {\n      case 0:\n        inputType = INPUT_TYPE.BYTE1;\n        break;\n      case 1:\n        inputType = INPUT_TYPE.BYTE2;\n        break;\n      case 2:\n        inputType = INPUT_TYPE.BYTE4;\n        break;\n    default:\n      throw new IllegalStateException(\"invalid input type \" + t);\n    }\n    if (packed) {\n      nodeRefToAddress = PackedInts.getReader(in);\n    } else {\n      nodeRefToAddress = null;\n    }\n    startNode = in.readVLong();\n    if (version < VERSION_NO_NODE_ARC_COUNTS) {\n      in.readVLong();\n      in.readVLong();\n      in.readVLong();\n    }\n\n    long numBytes = in.readVLong();\n    if (numBytes > 1 << maxBlockBits) {\n      // FST is big: we need multiple pages\n      bytes = new BytesStore(in, numBytes, 1<<maxBlockBits);\n      bytesArray = null;\n    } else {\n      // FST fits into a single block: use ByteArrayBytesStoreReader for less overhead\n      bytes = null;\n      bytesArray = new byte[(int) numBytes];\n      in.readBytes(bytesArray, 0, bytesArray.length);\n    }\n    \n    cacheRootArcs();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c0e7448656541edc407546460641f47950451b16","date":1519150500,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T],int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T],int).mjava","sourceNew":"  /** Load a previously saved FST; maxBlockBits allows you to\n   *  control the size of the byte[] pages used to hold the FST bytes. */\n  public FST(DataInput in, Outputs<T> outputs, int maxBlockBits) throws IOException {\n    this.outputs = outputs;\n\n    if (maxBlockBits < 1 || maxBlockBits > 30) {\n      throw new IllegalArgumentException(\"maxBlockBits should be 1 .. 30; got \" + maxBlockBits);\n    }\n\n    // NOTE: only reads most recent format; we don't have\n    // back-compat promise for FSTs (they are experimental):\n    version = CodecUtil.checkHeader(in, FILE_FORMAT_NAME, VERSION_START, VERSION_CURRENT);\n    if (in.readByte() == 1) {\n      // accepts empty string\n      // 1 KB blocks:\n      BytesStore emptyBytes = new BytesStore(10);\n      int numBytes = in.readVInt();\n      emptyBytes.copyBytes(in, numBytes);\n\n      // De-serialize empty-string output:\n      BytesReader reader = emptyBytes.getReverseReader();\n      // NoOutputs uses 0 bytes when writing its output,\n      // so we have to check here else BytesStore gets\n      // angry:\n      if (numBytes > 0) {\n        reader.setPosition(numBytes-1);\n      }\n      emptyOutput = outputs.readFinalOutput(reader);\n    } else {\n      emptyOutput = null;\n    }\n    final byte t = in.readByte();\n    switch(t) {\n      case 0:\n        inputType = INPUT_TYPE.BYTE1;\n        break;\n      case 1:\n        inputType = INPUT_TYPE.BYTE2;\n        break;\n      case 2:\n        inputType = INPUT_TYPE.BYTE4;\n        break;\n    default:\n      throw new IllegalStateException(\"invalid input type \" + t);\n    }\n    startNode = in.readVLong();\n\n    long numBytes = in.readVLong();\n    if (numBytes > 1 << maxBlockBits) {\n      // FST is big: we need multiple pages\n      bytes = new BytesStore(in, numBytes, 1<<maxBlockBits);\n      bytesArray = null;\n    } else {\n      // FST fits into a single block: use ByteArrayBytesStoreReader for less overhead\n      bytes = null;\n      bytesArray = new byte[(int) numBytes];\n      in.readBytes(bytesArray, 0, bytesArray.length);\n    }\n    \n    cacheRootArcs();\n  }\n\n","sourceOld":"  /** Load a previously saved FST; maxBlockBits allows you to\n   *  control the size of the byte[] pages used to hold the FST bytes. */\n  public FST(DataInput in, Outputs<T> outputs, int maxBlockBits) throws IOException {\n    this.outputs = outputs;\n\n    if (maxBlockBits < 1 || maxBlockBits > 30) {\n      throw new IllegalArgumentException(\"maxBlockBits should be 1 .. 30; got \" + maxBlockBits);\n    }\n\n    // NOTE: only reads most recent format; we don't have\n    // back-compat promise for FSTs (they are experimental):\n    version = CodecUtil.checkHeader(in, FILE_FORMAT_NAME, VERSION_PACKED, VERSION_CURRENT);\n    if (version < VERSION_PACKED_REMOVED) {\n      if (in.readByte() == 1) {\n        throw new CorruptIndexException(\"Cannot read packed FSTs anymore\", in);\n      }\n    }\n    if (in.readByte() == 1) {\n      // accepts empty string\n      // 1 KB blocks:\n      BytesStore emptyBytes = new BytesStore(10);\n      int numBytes = in.readVInt();\n      emptyBytes.copyBytes(in, numBytes);\n\n      // De-serialize empty-string output:\n      BytesReader reader = emptyBytes.getReverseReader();\n      // NoOutputs uses 0 bytes when writing its output,\n      // so we have to check here else BytesStore gets\n      // angry:\n      if (numBytes > 0) {\n        reader.setPosition(numBytes-1);\n      }\n      emptyOutput = outputs.readFinalOutput(reader);\n    } else {\n      emptyOutput = null;\n    }\n    final byte t = in.readByte();\n    switch(t) {\n      case 0:\n        inputType = INPUT_TYPE.BYTE1;\n        break;\n      case 1:\n        inputType = INPUT_TYPE.BYTE2;\n        break;\n      case 2:\n        inputType = INPUT_TYPE.BYTE4;\n        break;\n    default:\n      throw new IllegalStateException(\"invalid input type \" + t);\n    }\n    startNode = in.readVLong();\n    if (version < VERSION_NO_NODE_ARC_COUNTS) {\n      in.readVLong();\n      in.readVLong();\n      in.readVLong();\n    }\n\n    long numBytes = in.readVLong();\n    if (numBytes > 1 << maxBlockBits) {\n      // FST is big: we need multiple pages\n      bytes = new BytesStore(in, numBytes, 1<<maxBlockBits);\n      bytesArray = null;\n    } else {\n      // FST fits into a single block: use ByteArrayBytesStoreReader for less overhead\n      bytes = null;\n      bytesArray = new byte[(int) numBytes];\n      in.readBytes(bytesArray, 0, bytesArray.length);\n    }\n    \n    cacheRootArcs();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dcc12263939c1d6c4b4a2015f67d1b6d97f375a4","date":1550598742,"type":5,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T],FSTStore).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#FST(DataInput,Outputs[T],int).mjava","sourceNew":"  /** Load a previously saved FST; maxBlockBits allows you to\n   *  control the size of the byte[] pages used to hold the FST bytes. */\n  public FST(DataInput in, Outputs<T> outputs, FSTStore fstStore) throws IOException {\n    bytes = null;\n    this.fstStore = fstStore;\n    this.outputs = outputs;\n\n    // NOTE: only reads most recent format; we don't have\n    // back-compat promise for FSTs (they are experimental):\n    version = CodecUtil.checkHeader(in, FILE_FORMAT_NAME, VERSION_START, VERSION_CURRENT);\n    if (in.readByte() == 1) {\n      // accepts empty string\n      // 1 KB blocks:\n      BytesStore emptyBytes = new BytesStore(10);\n      int numBytes = in.readVInt();\n      emptyBytes.copyBytes(in, numBytes);\n\n      // De-serialize empty-string output:\n      BytesReader reader = emptyBytes.getReverseReader();\n      // NoOutputs uses 0 bytes when writing its output,\n      // so we have to check here else BytesStore gets\n      // angry:\n      if (numBytes > 0) {\n        reader.setPosition(numBytes-1);\n      }\n      emptyOutput = outputs.readFinalOutput(reader);\n    } else {\n      emptyOutput = null;\n    }\n    final byte t = in.readByte();\n    switch(t) {\n      case 0:\n        inputType = INPUT_TYPE.BYTE1;\n        break;\n      case 1:\n        inputType = INPUT_TYPE.BYTE2;\n        break;\n      case 2:\n        inputType = INPUT_TYPE.BYTE4;\n        break;\n    default:\n      throw new IllegalStateException(\"invalid input type \" + t);\n    }\n    startNode = in.readVLong();\n\n    long numBytes = in.readVLong();\n    this.fstStore.init(in, numBytes);\n    cacheRootArcs();\n  }\n\n","sourceOld":"  /** Load a previously saved FST; maxBlockBits allows you to\n   *  control the size of the byte[] pages used to hold the FST bytes. */\n  public FST(DataInput in, Outputs<T> outputs, int maxBlockBits) throws IOException {\n    this.outputs = outputs;\n\n    if (maxBlockBits < 1 || maxBlockBits > 30) {\n      throw new IllegalArgumentException(\"maxBlockBits should be 1 .. 30; got \" + maxBlockBits);\n    }\n\n    // NOTE: only reads most recent format; we don't have\n    // back-compat promise for FSTs (they are experimental):\n    version = CodecUtil.checkHeader(in, FILE_FORMAT_NAME, VERSION_START, VERSION_CURRENT);\n    if (in.readByte() == 1) {\n      // accepts empty string\n      // 1 KB blocks:\n      BytesStore emptyBytes = new BytesStore(10);\n      int numBytes = in.readVInt();\n      emptyBytes.copyBytes(in, numBytes);\n\n      // De-serialize empty-string output:\n      BytesReader reader = emptyBytes.getReverseReader();\n      // NoOutputs uses 0 bytes when writing its output,\n      // so we have to check here else BytesStore gets\n      // angry:\n      if (numBytes > 0) {\n        reader.setPosition(numBytes-1);\n      }\n      emptyOutput = outputs.readFinalOutput(reader);\n    } else {\n      emptyOutput = null;\n    }\n    final byte t = in.readByte();\n    switch(t) {\n      case 0:\n        inputType = INPUT_TYPE.BYTE1;\n        break;\n      case 1:\n        inputType = INPUT_TYPE.BYTE2;\n        break;\n      case 2:\n        inputType = INPUT_TYPE.BYTE4;\n        break;\n    default:\n      throw new IllegalStateException(\"invalid input type \" + t);\n    }\n    startNode = in.readVLong();\n\n    long numBytes = in.readVLong();\n    if (numBytes > 1 << maxBlockBits) {\n      // FST is big: we need multiple pages\n      bytes = new BytesStore(in, numBytes, 1<<maxBlockBits);\n      bytesArray = null;\n    } else {\n      // FST fits into a single block: use ByteArrayBytesStoreReader for less overhead\n      bytes = null;\n      bytesArray = new byte[(int) numBytes];\n      in.readBytes(bytesArray, 0, bytesArray.length);\n    }\n    \n    cacheRootArcs();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c0e7448656541edc407546460641f47950451b16":["6244579a467d5f2673ac98265d74bddbea1a8114"],"1abb939fb41b2fe4f89fd518f3da288c0213341d":["7d89d7e4e5101347833eea558851bf4209218619"],"5eb2511ababf862ea11e10761c70ee560cd84510":["651a27b35167c2ea81f87f4749722e52b7d5b750","7d89d7e4e5101347833eea558851bf4209218619"],"b0bf1d4eb51af6e03fffcbf80f0b5d69923c9f86":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","651a27b35167c2ea81f87f4749722e52b7d5b750"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6244579a467d5f2673ac98265d74bddbea1a8114":["1abb939fb41b2fe4f89fd518f3da288c0213341d"],"199dfa410f1fdbfd3294106b04096cce5ed34b21":["1abb939fb41b2fe4f89fd518f3da288c0213341d","6244579a467d5f2673ac98265d74bddbea1a8114"],"7d89d7e4e5101347833eea558851bf4209218619":["651a27b35167c2ea81f87f4749722e52b7d5b750"],"651a27b35167c2ea81f87f4749722e52b7d5b750":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["dcc12263939c1d6c4b4a2015f67d1b6d97f375a4"],"dcc12263939c1d6c4b4a2015f67d1b6d97f375a4":["c0e7448656541edc407546460641f47950451b16"]},"commit2Childs":{"c0e7448656541edc407546460641f47950451b16":["dcc12263939c1d6c4b4a2015f67d1b6d97f375a4"],"1abb939fb41b2fe4f89fd518f3da288c0213341d":["6244579a467d5f2673ac98265d74bddbea1a8114","199dfa410f1fdbfd3294106b04096cce5ed34b21"],"5eb2511ababf862ea11e10761c70ee560cd84510":[],"b0bf1d4eb51af6e03fffcbf80f0b5d69923c9f86":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b0bf1d4eb51af6e03fffcbf80f0b5d69923c9f86","651a27b35167c2ea81f87f4749722e52b7d5b750"],"6244579a467d5f2673ac98265d74bddbea1a8114":["c0e7448656541edc407546460641f47950451b16","199dfa410f1fdbfd3294106b04096cce5ed34b21"],"199dfa410f1fdbfd3294106b04096cce5ed34b21":[],"7d89d7e4e5101347833eea558851bf4209218619":["1abb939fb41b2fe4f89fd518f3da288c0213341d","5eb2511ababf862ea11e10761c70ee560cd84510"],"651a27b35167c2ea81f87f4749722e52b7d5b750":["5eb2511ababf862ea11e10761c70ee560cd84510","b0bf1d4eb51af6e03fffcbf80f0b5d69923c9f86","7d89d7e4e5101347833eea558851bf4209218619"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"dcc12263939c1d6c4b4a2015f67d1b6d97f375a4":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["5eb2511ababf862ea11e10761c70ee560cd84510","b0bf1d4eb51af6e03fffcbf80f0b5d69923c9f86","199dfa410f1fdbfd3294106b04096cce5ed34b21","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}