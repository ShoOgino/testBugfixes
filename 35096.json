{"path":"solr/core/src/java/org/apache/solr/cloud/OverseerConfigSetMessageHandler#deleteConfigSet(String,boolean).mjava","commits":[{"id":"2209af2c265d2258ec4b29c8cc78622d36994a15","date":1440641916,"type":0,"author":"Gregory Chanan","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerConfigSetMessageHandler#deleteConfigSet(String,boolean).mjava","pathOld":"/dev/null","sourceNew":"  private void deleteConfigSet(String configSetName, boolean force) throws IOException {\n    ZkConfigManager configManager = new ZkConfigManager(zkStateReader.getZkClient());\n    if (!configManager.configExists(configSetName)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"ConfigSet does not exist to delete: \" + configSetName);\n    }\n\n    String propertyPath = ConfigSetProperties.DEFAULT_FILENAME;\n    NamedList properties = getConfigSetProperties(getPropertyPath(configSetName, propertyPath));\n    if (properties != null) {\n      Object immutable = properties.get(ConfigSetProperties.IMMUTABLE_CONFIGSET_ARG);\n      boolean isImmutableConfigSet = immutable  != null ? Boolean.parseBoolean(immutable.toString()) : false;\n      if (!force && isImmutableConfigSet) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Requested delete of immutable ConfigSet: \" + configSetName);\n      }\n    }\n    configManager.deleteConfigDir(configSetName);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"124b6ffc5800c27aedfa52108f1556d75a865cbd","date":1448387785,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerConfigSetMessageHandler#deleteConfigSet(String,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerConfigSetMessageHandler#deleteConfigSet(String,boolean).mjava","sourceNew":"  private void deleteConfigSet(String configSetName, boolean force) throws IOException {\n    ZkConfigManager configManager = new ZkConfigManager(zkStateReader.getZkClient());\n    if (!configManager.configExists(configSetName)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"ConfigSet does not exist to delete: \" + configSetName);\n    }\n\n    for (String s : zkStateReader.getClusterState().getCollections()) {\n      if (configSetName.equals(zkStateReader.readConfigName(s)))\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Can not delete ConfigSet as it is currently being used by collection [\" + s + \"]\");\n    }\n\n    String propertyPath = ConfigSetProperties.DEFAULT_FILENAME;\n    NamedList properties = getConfigSetProperties(getPropertyPath(configSetName, propertyPath));\n    if (properties != null) {\n      Object immutable = properties.get(ConfigSetProperties.IMMUTABLE_CONFIGSET_ARG);\n      boolean isImmutableConfigSet = immutable  != null ? Boolean.parseBoolean(immutable.toString()) : false;\n      if (!force && isImmutableConfigSet) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Requested delete of immutable ConfigSet: \" + configSetName);\n      }\n    }\n    configManager.deleteConfigDir(configSetName);\n  }\n\n","sourceOld":"  private void deleteConfigSet(String configSetName, boolean force) throws IOException {\n    ZkConfigManager configManager = new ZkConfigManager(zkStateReader.getZkClient());\n    if (!configManager.configExists(configSetName)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"ConfigSet does not exist to delete: \" + configSetName);\n    }\n\n    String propertyPath = ConfigSetProperties.DEFAULT_FILENAME;\n    NamedList properties = getConfigSetProperties(getPropertyPath(configSetName, propertyPath));\n    if (properties != null) {\n      Object immutable = properties.get(ConfigSetProperties.IMMUTABLE_CONFIGSET_ARG);\n      boolean isImmutableConfigSet = immutable  != null ? Boolean.parseBoolean(immutable.toString()) : false;\n      if (!force && isImmutableConfigSet) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Requested delete of immutable ConfigSet: \" + configSetName);\n      }\n    }\n    configManager.deleteConfigDir(configSetName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9974f61802aea1d15849a1053f88f5e89fc32b4","date":1462405923,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerConfigSetMessageHandler#deleteConfigSet(String,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerConfigSetMessageHandler#deleteConfigSet(String,boolean).mjava","sourceNew":"  private void deleteConfigSet(String configSetName, boolean force) throws IOException {\n    ZkConfigManager configManager = new ZkConfigManager(zkStateReader.getZkClient());\n    if (!configManager.configExists(configSetName)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"ConfigSet does not exist to delete: \" + configSetName);\n    }\n\n    for (Map.Entry<String, DocCollection> entry : zkStateReader.getClusterState().getCollectionsMap().entrySet()) {\n      if (configSetName.equals(zkStateReader.readConfigName(entry.getKey())))\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Can not delete ConfigSet as it is currently being used by collection [\" + entry.getKey() + \"]\");\n    }\n\n    String propertyPath = ConfigSetProperties.DEFAULT_FILENAME;\n    NamedList properties = getConfigSetProperties(getPropertyPath(configSetName, propertyPath));\n    if (properties != null) {\n      Object immutable = properties.get(ConfigSetProperties.IMMUTABLE_CONFIGSET_ARG);\n      boolean isImmutableConfigSet = immutable  != null ? Boolean.parseBoolean(immutable.toString()) : false;\n      if (!force && isImmutableConfigSet) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Requested delete of immutable ConfigSet: \" + configSetName);\n      }\n    }\n    configManager.deleteConfigDir(configSetName);\n  }\n\n","sourceOld":"  private void deleteConfigSet(String configSetName, boolean force) throws IOException {\n    ZkConfigManager configManager = new ZkConfigManager(zkStateReader.getZkClient());\n    if (!configManager.configExists(configSetName)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"ConfigSet does not exist to delete: \" + configSetName);\n    }\n\n    for (String s : zkStateReader.getClusterState().getCollections()) {\n      if (configSetName.equals(zkStateReader.readConfigName(s)))\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Can not delete ConfigSet as it is currently being used by collection [\" + s + \"]\");\n    }\n\n    String propertyPath = ConfigSetProperties.DEFAULT_FILENAME;\n    NamedList properties = getConfigSetProperties(getPropertyPath(configSetName, propertyPath));\n    if (properties != null) {\n      Object immutable = properties.get(ConfigSetProperties.IMMUTABLE_CONFIGSET_ARG);\n      boolean isImmutableConfigSet = immutable  != null ? Boolean.parseBoolean(immutable.toString()) : false;\n      if (!force && isImmutableConfigSet) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Requested delete of immutable ConfigSet: \" + configSetName);\n      }\n    }\n    configManager.deleteConfigDir(configSetName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"73450c0955930295d34703e7ddbfc6973b7a121a","date":1462431925,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerConfigSetMessageHandler#deleteConfigSet(String,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerConfigSetMessageHandler#deleteConfigSet(String,boolean).mjava","sourceNew":"  private void deleteConfigSet(String configSetName, boolean force) throws IOException {\n    ZkConfigManager configManager = new ZkConfigManager(zkStateReader.getZkClient());\n    if (!configManager.configExists(configSetName)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"ConfigSet does not exist to delete: \" + configSetName);\n    }\n\n    for (Map.Entry<String, DocCollection> entry : zkStateReader.getClusterState().getCollectionsMap().entrySet()) {\n      if (configSetName.equals(zkStateReader.readConfigName(entry.getKey())))\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Can not delete ConfigSet as it is currently being used by collection [\" + entry.getKey() + \"]\");\n    }\n\n    String propertyPath = ConfigSetProperties.DEFAULT_FILENAME;\n    NamedList properties = getConfigSetProperties(getPropertyPath(configSetName, propertyPath));\n    if (properties != null) {\n      Object immutable = properties.get(ConfigSetProperties.IMMUTABLE_CONFIGSET_ARG);\n      boolean isImmutableConfigSet = immutable  != null ? Boolean.parseBoolean(immutable.toString()) : false;\n      if (!force && isImmutableConfigSet) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Requested delete of immutable ConfigSet: \" + configSetName);\n      }\n    }\n    configManager.deleteConfigDir(configSetName);\n  }\n\n","sourceOld":"  private void deleteConfigSet(String configSetName, boolean force) throws IOException {\n    ZkConfigManager configManager = new ZkConfigManager(zkStateReader.getZkClient());\n    if (!configManager.configExists(configSetName)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"ConfigSet does not exist to delete: \" + configSetName);\n    }\n\n    for (String s : zkStateReader.getClusterState().getCollections()) {\n      if (configSetName.equals(zkStateReader.readConfigName(s)))\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Can not delete ConfigSet as it is currently being used by collection [\" + s + \"]\");\n    }\n\n    String propertyPath = ConfigSetProperties.DEFAULT_FILENAME;\n    NamedList properties = getConfigSetProperties(getPropertyPath(configSetName, propertyPath));\n    if (properties != null) {\n      Object immutable = properties.get(ConfigSetProperties.IMMUTABLE_CONFIGSET_ARG);\n      boolean isImmutableConfigSet = immutable  != null ? Boolean.parseBoolean(immutable.toString()) : false;\n      if (!force && isImmutableConfigSet) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Requested delete of immutable ConfigSet: \" + configSetName);\n      }\n    }\n    configManager.deleteConfigDir(configSetName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7dc08f02757dd10637b16a5c65eaaef839a91a9a","date":1462455462,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerConfigSetMessageHandler#deleteConfigSet(String,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerConfigSetMessageHandler#deleteConfigSet(String,boolean).mjava","sourceNew":"  private void deleteConfigSet(String configSetName, boolean force) throws IOException {\n    ZkConfigManager configManager = new ZkConfigManager(zkStateReader.getZkClient());\n    if (!configManager.configExists(configSetName)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"ConfigSet does not exist to delete: \" + configSetName);\n    }\n\n    for (Map.Entry<String, DocCollection> entry : zkStateReader.getClusterState().getCollectionsMap().entrySet()) {\n      if (configSetName.equals(zkStateReader.readConfigName(entry.getKey())))\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Can not delete ConfigSet as it is currently being used by collection [\" + entry.getKey() + \"]\");\n    }\n\n    String propertyPath = ConfigSetProperties.DEFAULT_FILENAME;\n    NamedList properties = getConfigSetProperties(getPropertyPath(configSetName, propertyPath));\n    if (properties != null) {\n      Object immutable = properties.get(ConfigSetProperties.IMMUTABLE_CONFIGSET_ARG);\n      boolean isImmutableConfigSet = immutable  != null ? Boolean.parseBoolean(immutable.toString()) : false;\n      if (!force && isImmutableConfigSet) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Requested delete of immutable ConfigSet: \" + configSetName);\n      }\n    }\n    configManager.deleteConfigDir(configSetName);\n  }\n\n","sourceOld":"  private void deleteConfigSet(String configSetName, boolean force) throws IOException {\n    ZkConfigManager configManager = new ZkConfigManager(zkStateReader.getZkClient());\n    if (!configManager.configExists(configSetName)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"ConfigSet does not exist to delete: \" + configSetName);\n    }\n\n    for (String s : zkStateReader.getClusterState().getCollections()) {\n      if (configSetName.equals(zkStateReader.readConfigName(s)))\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Can not delete ConfigSet as it is currently being used by collection [\" + s + \"]\");\n    }\n\n    String propertyPath = ConfigSetProperties.DEFAULT_FILENAME;\n    NamedList properties = getConfigSetProperties(getPropertyPath(configSetName, propertyPath));\n    if (properties != null) {\n      Object immutable = properties.get(ConfigSetProperties.IMMUTABLE_CONFIGSET_ARG);\n      boolean isImmutableConfigSet = immutable  != null ? Boolean.parseBoolean(immutable.toString()) : false;\n      if (!force && isImmutableConfigSet) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Requested delete of immutable ConfigSet: \" + configSetName);\n      }\n    }\n    configManager.deleteConfigDir(configSetName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","date":1462576651,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerConfigSetMessageHandler#deleteConfigSet(String,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerConfigSetMessageHandler#deleteConfigSet(String,boolean).mjava","sourceNew":"  private void deleteConfigSet(String configSetName, boolean force) throws IOException {\n    ZkConfigManager configManager = new ZkConfigManager(zkStateReader.getZkClient());\n    if (!configManager.configExists(configSetName)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"ConfigSet does not exist to delete: \" + configSetName);\n    }\n\n    for (Map.Entry<String, DocCollection> entry : zkStateReader.getClusterState().getCollectionsMap().entrySet()) {\n      if (configSetName.equals(zkStateReader.readConfigName(entry.getKey())))\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Can not delete ConfigSet as it is currently being used by collection [\" + entry.getKey() + \"]\");\n    }\n\n    String propertyPath = ConfigSetProperties.DEFAULT_FILENAME;\n    NamedList properties = getConfigSetProperties(getPropertyPath(configSetName, propertyPath));\n    if (properties != null) {\n      Object immutable = properties.get(ConfigSetProperties.IMMUTABLE_CONFIGSET_ARG);\n      boolean isImmutableConfigSet = immutable  != null ? Boolean.parseBoolean(immutable.toString()) : false;\n      if (!force && isImmutableConfigSet) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Requested delete of immutable ConfigSet: \" + configSetName);\n      }\n    }\n    configManager.deleteConfigDir(configSetName);\n  }\n\n","sourceOld":"  private void deleteConfigSet(String configSetName, boolean force) throws IOException {\n    ZkConfigManager configManager = new ZkConfigManager(zkStateReader.getZkClient());\n    if (!configManager.configExists(configSetName)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"ConfigSet does not exist to delete: \" + configSetName);\n    }\n\n    for (String s : zkStateReader.getClusterState().getCollections()) {\n      if (configSetName.equals(zkStateReader.readConfigName(s)))\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Can not delete ConfigSet as it is currently being used by collection [\" + s + \"]\");\n    }\n\n    String propertyPath = ConfigSetProperties.DEFAULT_FILENAME;\n    NamedList properties = getConfigSetProperties(getPropertyPath(configSetName, propertyPath));\n    if (properties != null) {\n      Object immutable = properties.get(ConfigSetProperties.IMMUTABLE_CONFIGSET_ARG);\n      boolean isImmutableConfigSet = immutable  != null ? Boolean.parseBoolean(immutable.toString()) : false;\n      if (!force && isImmutableConfigSet) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Requested delete of immutable ConfigSet: \" + configSetName);\n      }\n    }\n    configManager.deleteConfigDir(configSetName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e29778bfb04e9115636606cb8f74e23ecba15c7b","date":1536084166,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerConfigSetMessageHandler#deleteConfigSet(String,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerConfigSetMessageHandler#deleteConfigSet(String,boolean).mjava","sourceNew":"  private void deleteConfigSet(String configSetName, boolean force) throws IOException {\n    ZkConfigManager configManager = new ZkConfigManager(zkStateReader.getZkClient());\n    if (!configManager.configExists(configSetName)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"ConfigSet does not exist to delete: \" + configSetName);\n    }\n\n    for (Map.Entry<String, DocCollection> entry : zkStateReader.getClusterState().getCollectionsMap().entrySet()) {\n      if (configSetName.equals(zkStateReader.readConfigName(entry.getKey())))\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Can not delete ConfigSet as it is currently being used by collection [\" + entry.getKey() + \"]\");\n    }\n\n    String propertyPath = ConfigSetProperties.DEFAULT_FILENAME;\n    NamedList properties = getConfigSetProperties(getPropertyPath(configSetName, propertyPath));\n    if (properties != null) {\n      Object immutable = properties.get(ConfigSetProperties.IMMUTABLE_CONFIGSET_ARG);\n      boolean isImmutableConfigSet = immutable != null ? Boolean.parseBoolean(immutable.toString()) : false;\n      if (!force && isImmutableConfigSet) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Requested delete of immutable ConfigSet: \" + configSetName);\n      }\n    }\n    configManager.deleteConfigDir(configSetName);\n  }\n\n","sourceOld":"  private void deleteConfigSet(String configSetName, boolean force) throws IOException {\n    ZkConfigManager configManager = new ZkConfigManager(zkStateReader.getZkClient());\n    if (!configManager.configExists(configSetName)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"ConfigSet does not exist to delete: \" + configSetName);\n    }\n\n    for (Map.Entry<String, DocCollection> entry : zkStateReader.getClusterState().getCollectionsMap().entrySet()) {\n      if (configSetName.equals(zkStateReader.readConfigName(entry.getKey())))\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Can not delete ConfigSet as it is currently being used by collection [\" + entry.getKey() + \"]\");\n    }\n\n    String propertyPath = ConfigSetProperties.DEFAULT_FILENAME;\n    NamedList properties = getConfigSetProperties(getPropertyPath(configSetName, propertyPath));\n    if (properties != null) {\n      Object immutable = properties.get(ConfigSetProperties.IMMUTABLE_CONFIGSET_ARG);\n      boolean isImmutableConfigSet = immutable  != null ? Boolean.parseBoolean(immutable.toString()) : false;\n      if (!force && isImmutableConfigSet) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Requested delete of immutable ConfigSet: \" + configSetName);\n      }\n    }\n    configManager.deleteConfigDir(configSetName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4949836c6e83246ddba8997472e3333f40986c8c","date":1560293762,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerConfigSetMessageHandler#deleteConfigSet(String,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerConfigSetMessageHandler#deleteConfigSet(String,boolean).mjava","sourceNew":"  private void deleteConfigSet(String configSetName, boolean force) throws IOException {\n    ZkConfigManager configManager = new ZkConfigManager(zkStateReader.getZkClient());\n    if (!configManager.configExists(configSetName)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"ConfigSet does not exist to delete: \" + configSetName);\n    }\n\n    for (Map.Entry<String, DocCollection> entry : zkStateReader.getClusterState().getCollectionsMap().entrySet()) {\n      String configName = null;\n      try {\n        configName = zkStateReader.readConfigName(entry.getKey());\n      } catch (KeeperException ex) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Can not delete ConfigSet as it is currently being used by collection [\" + entry.getKey() + \"]\");\n      }\n      if (configSetName.equals(configName))\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Can not delete ConfigSet as it is currently being used by collection [\" + entry.getKey() + \"]\");\n    }\n\n    String propertyPath = ConfigSetProperties.DEFAULT_FILENAME;\n    NamedList properties = getConfigSetProperties(getPropertyPath(configSetName, propertyPath));\n    if (properties != null) {\n      Object immutable = properties.get(ConfigSetProperties.IMMUTABLE_CONFIGSET_ARG);\n      boolean isImmutableConfigSet = immutable != null ? Boolean.parseBoolean(immutable.toString()) : false;\n      if (!force && isImmutableConfigSet) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Requested delete of immutable ConfigSet: \" + configSetName);\n      }\n    }\n    configManager.deleteConfigDir(configSetName);\n  }\n\n","sourceOld":"  private void deleteConfigSet(String configSetName, boolean force) throws IOException {\n    ZkConfigManager configManager = new ZkConfigManager(zkStateReader.getZkClient());\n    if (!configManager.configExists(configSetName)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"ConfigSet does not exist to delete: \" + configSetName);\n    }\n\n    for (Map.Entry<String, DocCollection> entry : zkStateReader.getClusterState().getCollectionsMap().entrySet()) {\n      if (configSetName.equals(zkStateReader.readConfigName(entry.getKey())))\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Can not delete ConfigSet as it is currently being used by collection [\" + entry.getKey() + \"]\");\n    }\n\n    String propertyPath = ConfigSetProperties.DEFAULT_FILENAME;\n    NamedList properties = getConfigSetProperties(getPropertyPath(configSetName, propertyPath));\n    if (properties != null) {\n      Object immutable = properties.get(ConfigSetProperties.IMMUTABLE_CONFIGSET_ARG);\n      boolean isImmutableConfigSet = immutable != null ? Boolean.parseBoolean(immutable.toString()) : false;\n      if (!force && isImmutableConfigSet) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Requested delete of immutable ConfigSet: \" + configSetName);\n      }\n    }\n    configManager.deleteConfigDir(configSetName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"06a8891f085f71282bb3ece1b1732b68f07813a3","date":1591912889,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerConfigSetMessageHandler#deleteConfigSet(String,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerConfigSetMessageHandler#deleteConfigSet(String,boolean).mjava","sourceNew":"  private void deleteConfigSet(String configSetName, boolean force) throws IOException {\n    ZkConfigManager configManager = new ZkConfigManager(zkStateReader.getZkClient());\n    if (!configManager.configExists(configSetName)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"ConfigSet does not exist to delete: \" + configSetName);\n    }\n\n    for (Map.Entry<String, DocCollection> entry : zkStateReader.getClusterState().getCollectionsMap().entrySet()) {\n      String configName = null;\n      try {\n        configName = zkStateReader.readConfigName(entry.getKey());\n      } catch (KeeperException ex) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Can not delete ConfigSet as it is currently being used by collection [\" + entry.getKey() + \"]\");\n      }\n      if (configSetName.equals(configName))\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Can not delete ConfigSet as it is currently being used by collection [\" + entry.getKey() + \"]\");\n    }\n\n    String propertyPath = ConfigSetProperties.DEFAULT_FILENAME;\n    @SuppressWarnings({\"rawtypes\"})\n    NamedList properties = getConfigSetProperties(getPropertyPath(configSetName, propertyPath));\n    if (properties != null) {\n      Object immutable = properties.get(ConfigSetProperties.IMMUTABLE_CONFIGSET_ARG);\n      boolean isImmutableConfigSet = immutable != null ? Boolean.parseBoolean(immutable.toString()) : false;\n      if (!force && isImmutableConfigSet) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Requested delete of immutable ConfigSet: \" + configSetName);\n      }\n    }\n    configManager.deleteConfigDir(configSetName);\n  }\n\n","sourceOld":"  private void deleteConfigSet(String configSetName, boolean force) throws IOException {\n    ZkConfigManager configManager = new ZkConfigManager(zkStateReader.getZkClient());\n    if (!configManager.configExists(configSetName)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"ConfigSet does not exist to delete: \" + configSetName);\n    }\n\n    for (Map.Entry<String, DocCollection> entry : zkStateReader.getClusterState().getCollectionsMap().entrySet()) {\n      String configName = null;\n      try {\n        configName = zkStateReader.readConfigName(entry.getKey());\n      } catch (KeeperException ex) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Can not delete ConfigSet as it is currently being used by collection [\" + entry.getKey() + \"]\");\n      }\n      if (configSetName.equals(configName))\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Can not delete ConfigSet as it is currently being used by collection [\" + entry.getKey() + \"]\");\n    }\n\n    String propertyPath = ConfigSetProperties.DEFAULT_FILENAME;\n    NamedList properties = getConfigSetProperties(getPropertyPath(configSetName, propertyPath));\n    if (properties != null) {\n      Object immutable = properties.get(ConfigSetProperties.IMMUTABLE_CONFIGSET_ARG);\n      boolean isImmutableConfigSet = immutable != null ? Boolean.parseBoolean(immutable.toString()) : false;\n      if (!force && isImmutableConfigSet) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"Requested delete of immutable ConfigSet: \" + configSetName);\n      }\n    }\n    configManager.deleteConfigDir(configSetName);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"124b6ffc5800c27aedfa52108f1556d75a865cbd":["2209af2c265d2258ec4b29c8cc78622d36994a15"],"2209af2c265d2258ec4b29c8cc78622d36994a15":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e29778bfb04e9115636606cb8f74e23ecba15c7b":["73450c0955930295d34703e7ddbfc6973b7a121a"],"73450c0955930295d34703e7ddbfc6973b7a121a":["124b6ffc5800c27aedfa52108f1556d75a865cbd","e9974f61802aea1d15849a1053f88f5e89fc32b4"],"7dc08f02757dd10637b16a5c65eaaef839a91a9a":["124b6ffc5800c27aedfa52108f1556d75a865cbd","73450c0955930295d34703e7ddbfc6973b7a121a"],"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904":["124b6ffc5800c27aedfa52108f1556d75a865cbd","73450c0955930295d34703e7ddbfc6973b7a121a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"06a8891f085f71282bb3ece1b1732b68f07813a3":["4949836c6e83246ddba8997472e3333f40986c8c"],"4949836c6e83246ddba8997472e3333f40986c8c":["e29778bfb04e9115636606cb8f74e23ecba15c7b"],"e9974f61802aea1d15849a1053f88f5e89fc32b4":["124b6ffc5800c27aedfa52108f1556d75a865cbd"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["06a8891f085f71282bb3ece1b1732b68f07813a3"]},"commit2Childs":{"124b6ffc5800c27aedfa52108f1556d75a865cbd":["73450c0955930295d34703e7ddbfc6973b7a121a","7dc08f02757dd10637b16a5c65eaaef839a91a9a","a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","e9974f61802aea1d15849a1053f88f5e89fc32b4"],"2209af2c265d2258ec4b29c8cc78622d36994a15":["124b6ffc5800c27aedfa52108f1556d75a865cbd"],"e29778bfb04e9115636606cb8f74e23ecba15c7b":["4949836c6e83246ddba8997472e3333f40986c8c"],"73450c0955930295d34703e7ddbfc6973b7a121a":["e29778bfb04e9115636606cb8f74e23ecba15c7b","7dc08f02757dd10637b16a5c65eaaef839a91a9a","a8ed5da4b0191db6bc7f77f9feb35da6bd76f904"],"7dc08f02757dd10637b16a5c65eaaef839a91a9a":[],"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["2209af2c265d2258ec4b29c8cc78622d36994a15"],"06a8891f085f71282bb3ece1b1732b68f07813a3":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4949836c6e83246ddba8997472e3333f40986c8c":["06a8891f085f71282bb3ece1b1732b68f07813a3"],"e9974f61802aea1d15849a1053f88f5e89fc32b4":["73450c0955930295d34703e7ddbfc6973b7a121a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["7dc08f02757dd10637b16a5c65eaaef839a91a9a","a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}