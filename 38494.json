{"path":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.IntFieldValueCollector#IntFieldValueCollector(int,int,int,int,int,String,GroupHeadSelector,SortSpec,boolean,boolean,FieldType,IntIntHashMap,FunctionQuery,IndexSearcher).mjava","commits":[{"id":"446ec69a32a7e8cb8bf6eb8be693e96ab5f5a0d3","date":1556831715,"type":1,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.IntFieldValueCollector#IntFieldValueCollector(int,int,int,int,int,String,GroupHeadSelector,SortSpec,boolean,boolean,FieldType,IntIntHashMap,FunctionQuery,IndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.IntFieldValueCollector#IntFieldValueCollector(int,int,int,int,int,String,GroupHeadSelector,SortSpec,boolean,FieldType,IntIntHashMap,FunctionQuery,IndexSearcher).mjava","sourceNew":"    public IntFieldValueCollector(int maxDoc,\n                                  int size,\n                                  int segments,\n                                  int nullValue,\n                                  int nullPolicy,\n                                  String collapseField,\n                                  GroupHeadSelector groupHeadSelector,\n                                  SortSpec sortSpec,\n                                  boolean needsScores4Collapsing,\n                                  boolean needsScores,\n                                  FieldType fieldType,\n                                  IntIntHashMap boostDocsMap,\n                                  FunctionQuery funcQuery,\n                                  IndexSearcher searcher) throws IOException{\n\n      assert ! GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type);\n      \n      this.maxDoc = maxDoc;\n      this.contexts = new LeafReaderContext[segments];\n      this.collapseField = collapseField;\n      this.nullValue = nullValue;\n      this.nullPolicy = nullPolicy;\n      this.needsScores4Collapsing = needsScores4Collapsing;\n      this.needsScores = needsScores;\n      if (null != sortSpec) {\n        this.collapseStrategy = new IntSortSpecStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores4Collapsing, this.needsScores, boostDocsMap, sortSpec, searcher);\n      } else if (funcQuery != null) {\n        this.collapseStrategy =  new IntValueSourceStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores4Collapsing, this.needsScores, boostDocsMap, funcQuery, searcher);\n      } else {\n        NumberType numType = fieldType.getNumberType();\n        assert null != numType; // shouldn't make it here for non-numeric types\n        switch (numType) {\n          case INTEGER: {\n            this.collapseStrategy = new IntIntStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap);\n            break;\n          }\n          case FLOAT: {\n            this.collapseStrategy = new IntFloatStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap);\n            break;\n          }\n          default: {\n            throw new IOException(\"min/max must be Int or Float field types when collapsing on numeric fields\");\n          }\n        }\n      }\n    }\n\n","sourceOld":"    public IntFieldValueCollector(int maxDoc,\n                                  int size,\n                                  int segments,\n                                  int nullValue,\n                                  int nullPolicy,\n                                  String collapseField,\n                                  GroupHeadSelector groupHeadSelector,\n                                  SortSpec sortSpec,\n                                  boolean needsScores,\n                                  FieldType fieldType,\n                                  IntIntHashMap boostDocsMap,\n                                  FunctionQuery funcQuery,\n                                  IndexSearcher searcher) throws IOException{\n\n      assert ! GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type);\n      \n      this.maxDoc = maxDoc;\n      this.contexts = new LeafReaderContext[segments];\n      this.collapseField = collapseField;\n      this.nullValue = nullValue;\n      this.nullPolicy = nullPolicy;\n      this.needsScores = needsScores;\n      if (null != sortSpec) {\n        this.collapseStrategy = new IntSortSpecStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap, sortSpec, searcher);\n      } else if (funcQuery != null) {\n        this.collapseStrategy =  new IntValueSourceStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap, funcQuery, searcher);\n      } else {\n        NumberType numType = fieldType.getNumberType();\n        assert null != numType; // shouldn't make it here for non-numeric types\n        switch (numType) {\n          case INTEGER: {\n            this.collapseStrategy = new IntIntStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap);\n            break;\n          }\n          case FLOAT: {\n            this.collapseStrategy = new IntFloatStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap);\n            break;\n          }\n          default: {\n            throw new IOException(\"min/max must be Int or Float field types when collapsing on numeric fields\");\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"432fdfa612cbca5b4cf9125a2c6aa055cd53cadb","date":1561824429,"type":3,"author":"Munendra S N","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.IntFieldValueCollector#IntFieldValueCollector(int,int,int,int,int,String,GroupHeadSelector,SortSpec,boolean,boolean,FieldType,IntIntHashMap,FunctionQuery,IndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.IntFieldValueCollector#IntFieldValueCollector(int,int,int,int,int,String,GroupHeadSelector,SortSpec,boolean,boolean,FieldType,IntIntHashMap,FunctionQuery,IndexSearcher).mjava","sourceNew":"    public IntFieldValueCollector(int maxDoc,\n                                  int size,\n                                  int segments,\n                                  int nullValue,\n                                  int nullPolicy,\n                                  String collapseField,\n                                  GroupHeadSelector groupHeadSelector,\n                                  SortSpec sortSpec,\n                                  boolean needsScores4Collapsing,\n                                  boolean needsScores,\n                                  FieldType fieldType,\n                                  IntIntHashMap boostDocsMap,\n                                  FunctionQuery funcQuery,\n                                  IndexSearcher searcher) throws IOException{\n\n      assert ! GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type);\n      \n      this.maxDoc = maxDoc;\n      this.contexts = new LeafReaderContext[segments];\n      this.collapseField = collapseField;\n      this.nullValue = nullValue;\n      this.nullPolicy = nullPolicy;\n      this.needsScores4Collapsing = needsScores4Collapsing;\n      this.needsScores = needsScores;\n      if (null != sortSpec) {\n        this.collapseStrategy = new IntSortSpecStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores4Collapsing, this.needsScores, boostDocsMap, sortSpec, searcher);\n      } else if (funcQuery != null) {\n        this.collapseStrategy =  new IntValueSourceStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores4Collapsing, this.needsScores, boostDocsMap, funcQuery, searcher);\n      } else {\n        NumberType numType = fieldType.getNumberType();\n        assert null != numType; // shouldn't make it here for non-numeric types\n        switch (numType) {\n          case INTEGER: {\n            this.collapseStrategy = new IntIntStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap);\n            break;\n          }\n          case FLOAT: {\n            this.collapseStrategy = new IntFloatStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap);\n            break;\n          }\n          default: {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"min/max must be Int or Float field types when collapsing on numeric fields\");\n          }\n        }\n      }\n    }\n\n","sourceOld":"    public IntFieldValueCollector(int maxDoc,\n                                  int size,\n                                  int segments,\n                                  int nullValue,\n                                  int nullPolicy,\n                                  String collapseField,\n                                  GroupHeadSelector groupHeadSelector,\n                                  SortSpec sortSpec,\n                                  boolean needsScores4Collapsing,\n                                  boolean needsScores,\n                                  FieldType fieldType,\n                                  IntIntHashMap boostDocsMap,\n                                  FunctionQuery funcQuery,\n                                  IndexSearcher searcher) throws IOException{\n\n      assert ! GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type);\n      \n      this.maxDoc = maxDoc;\n      this.contexts = new LeafReaderContext[segments];\n      this.collapseField = collapseField;\n      this.nullValue = nullValue;\n      this.nullPolicy = nullPolicy;\n      this.needsScores4Collapsing = needsScores4Collapsing;\n      this.needsScores = needsScores;\n      if (null != sortSpec) {\n        this.collapseStrategy = new IntSortSpecStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores4Collapsing, this.needsScores, boostDocsMap, sortSpec, searcher);\n      } else if (funcQuery != null) {\n        this.collapseStrategy =  new IntValueSourceStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores4Collapsing, this.needsScores, boostDocsMap, funcQuery, searcher);\n      } else {\n        NumberType numType = fieldType.getNumberType();\n        assert null != numType; // shouldn't make it here for non-numeric types\n        switch (numType) {\n          case INTEGER: {\n            this.collapseStrategy = new IntIntStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap);\n            break;\n          }\n          case FLOAT: {\n            this.collapseStrategy = new IntFloatStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap);\n            break;\n          }\n          default: {\n            throw new IOException(\"min/max must be Int or Float field types when collapsing on numeric fields\");\n          }\n        }\n      }\n    }\n\n","bugFix":["4d048016075a0b8589fcfc77fdf8e2a29fc80964"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ece7e3f03c890461bce71fb45142b75807c28a4e","date":1583713564,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.IntFieldValueCollector#IntFieldValueCollector(int,int,int,int,int,String,GroupHeadSelector,SortSpec,boolean,boolean,FieldType,IntIntHashMap,FunctionQuery,IndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.IntFieldValueCollector#IntFieldValueCollector(int,int,int,int,int,String,GroupHeadSelector,SortSpec,boolean,boolean,FieldType,IntIntHashMap,FunctionQuery,IndexSearcher).mjava","sourceNew":"    public IntFieldValueCollector(int maxDoc,\n                                  int size,\n                                  int segments,\n                                  int nullValue,\n                                  int nullPolicy,\n                                  String collapseField,\n                                  GroupHeadSelector groupHeadSelector,\n                                  SortSpec sortSpec,\n                                  boolean needsScores4Collapsing,\n                                  boolean needsScores,\n                                  FieldType fieldType,\n                                  IntIntHashMap boostDocsMap,\n                                  FunctionQuery funcQuery,\n                                  IndexSearcher searcher) throws IOException{\n\n      assert ! GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type);\n      \n      this.maxDoc = maxDoc;\n      this.contexts = new LeafReaderContext[segments];\n      List<LeafReaderContext> con = searcher.getTopReaderContext().leaves();\n      for(int i=0; i<con.size(); i++) {\n        contexts[i] = con.get(i);\n      }\n      this.collapseField = collapseField;\n      this.nullValue = nullValue;\n      this.nullPolicy = nullPolicy;\n      this.needsScores4Collapsing = needsScores4Collapsing;\n      this.needsScores = needsScores;\n      if (null != sortSpec) {\n        this.collapseStrategy = new IntSortSpecStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores4Collapsing, this.needsScores, boostDocsMap, sortSpec, searcher);\n      } else if (funcQuery != null) {\n        this.collapseStrategy =  new IntValueSourceStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores4Collapsing, this.needsScores, boostDocsMap, funcQuery, searcher);\n      } else {\n        NumberType numType = fieldType.getNumberType();\n        assert null != numType; // shouldn't make it here for non-numeric types\n        switch (numType) {\n          case INTEGER: {\n            this.collapseStrategy = new IntIntStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap);\n            break;\n          }\n          case FLOAT: {\n            this.collapseStrategy = new IntFloatStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap);\n            break;\n          }\n          default: {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"min/max must be Int or Float field types when collapsing on numeric fields\");\n          }\n        }\n      }\n    }\n\n","sourceOld":"    public IntFieldValueCollector(int maxDoc,\n                                  int size,\n                                  int segments,\n                                  int nullValue,\n                                  int nullPolicy,\n                                  String collapseField,\n                                  GroupHeadSelector groupHeadSelector,\n                                  SortSpec sortSpec,\n                                  boolean needsScores4Collapsing,\n                                  boolean needsScores,\n                                  FieldType fieldType,\n                                  IntIntHashMap boostDocsMap,\n                                  FunctionQuery funcQuery,\n                                  IndexSearcher searcher) throws IOException{\n\n      assert ! GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type);\n      \n      this.maxDoc = maxDoc;\n      this.contexts = new LeafReaderContext[segments];\n      this.collapseField = collapseField;\n      this.nullValue = nullValue;\n      this.nullPolicy = nullPolicy;\n      this.needsScores4Collapsing = needsScores4Collapsing;\n      this.needsScores = needsScores;\n      if (null != sortSpec) {\n        this.collapseStrategy = new IntSortSpecStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores4Collapsing, this.needsScores, boostDocsMap, sortSpec, searcher);\n      } else if (funcQuery != null) {\n        this.collapseStrategy =  new IntValueSourceStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores4Collapsing, this.needsScores, boostDocsMap, funcQuery, searcher);\n      } else {\n        NumberType numType = fieldType.getNumberType();\n        assert null != numType; // shouldn't make it here for non-numeric types\n        switch (numType) {\n          case INTEGER: {\n            this.collapseStrategy = new IntIntStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap);\n            break;\n          }\n          case FLOAT: {\n            this.collapseStrategy = new IntFloatStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap);\n            break;\n          }\n          default: {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"min/max must be Int or Float field types when collapsing on numeric fields\");\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3575e61fd7df2bbcce8b977a23d3d67aa423ce62","date":1586507050,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.IntFieldValueCollector#IntFieldValueCollector(int,int,int,int,int,String,GroupHeadSelector,SortSpec,boolean,boolean,FieldType,IntIntHashMap,FunctionQuery,IndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.IntFieldValueCollector#IntFieldValueCollector(int,int,int,int,int,String,GroupHeadSelector,SortSpec,boolean,boolean,FieldType,IntIntHashMap,FunctionQuery,IndexSearcher).mjava","sourceNew":"    public IntFieldValueCollector(int maxDoc,\n                                  int size,\n                                  int segments,\n                                  int nullValue,\n                                  int nullPolicy,\n                                  String collapseField,\n                                  GroupHeadSelector groupHeadSelector,\n                                  SortSpec sortSpec,\n                                  boolean needsScores4Collapsing,\n                                  boolean needsScores,\n                                  FieldType fieldType,\n                                  IntIntHashMap boostDocsMap,\n                                  FunctionQuery funcQuery,\n                                  IndexSearcher searcher) throws IOException{\n\n      assert ! GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type);\n\n      this.maxDoc = maxDoc;\n      this.contexts = new LeafReaderContext[segments];\n      List<LeafReaderContext> con = searcher.getTopReaderContext().leaves();\n      for(int i=0; i<con.size(); i++) {\n        contexts[i] = con.get(i);\n      }\n      this.collapseField = collapseField;\n      this.nullValue = nullValue;\n      this.nullPolicy = nullPolicy;\n      this.needsScores4Collapsing = needsScores4Collapsing;\n      this.needsScores = needsScores;\n      if (null != sortSpec) {\n        this.collapseStrategy = new IntSortSpecStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores4Collapsing, this.needsScores, boostDocsMap, sortSpec, searcher);\n      } else if (funcQuery != null) {\n        this.collapseStrategy =  new IntValueSourceStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores4Collapsing, this.needsScores, boostDocsMap, funcQuery, searcher);\n      } else {\n        NumberType numType = fieldType.getNumberType();\n        assert null != numType; // shouldn't make it here for non-numeric types\n        switch (numType) {\n          case INTEGER: {\n            this.collapseStrategy = new IntIntStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap);\n            break;\n          }\n          case FLOAT: {\n            this.collapseStrategy = new IntFloatStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap);\n            break;\n          }\n          default: {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"min/max must be Int or Float field types when collapsing on numeric fields\");\n          }\n        }\n      }\n    }\n\n","sourceOld":"    public IntFieldValueCollector(int maxDoc,\n                                  int size,\n                                  int segments,\n                                  int nullValue,\n                                  int nullPolicy,\n                                  String collapseField,\n                                  GroupHeadSelector groupHeadSelector,\n                                  SortSpec sortSpec,\n                                  boolean needsScores4Collapsing,\n                                  boolean needsScores,\n                                  FieldType fieldType,\n                                  IntIntHashMap boostDocsMap,\n                                  FunctionQuery funcQuery,\n                                  IndexSearcher searcher) throws IOException{\n\n      assert ! GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type);\n      \n      this.maxDoc = maxDoc;\n      this.contexts = new LeafReaderContext[segments];\n      List<LeafReaderContext> con = searcher.getTopReaderContext().leaves();\n      for(int i=0; i<con.size(); i++) {\n        contexts[i] = con.get(i);\n      }\n      this.collapseField = collapseField;\n      this.nullValue = nullValue;\n      this.nullPolicy = nullPolicy;\n      this.needsScores4Collapsing = needsScores4Collapsing;\n      this.needsScores = needsScores;\n      if (null != sortSpec) {\n        this.collapseStrategy = new IntSortSpecStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores4Collapsing, this.needsScores, boostDocsMap, sortSpec, searcher);\n      } else if (funcQuery != null) {\n        this.collapseStrategy =  new IntValueSourceStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores4Collapsing, this.needsScores, boostDocsMap, funcQuery, searcher);\n      } else {\n        NumberType numType = fieldType.getNumberType();\n        assert null != numType; // shouldn't make it here for non-numeric types\n        switch (numType) {\n          case INTEGER: {\n            this.collapseStrategy = new IntIntStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap);\n            break;\n          }\n          case FLOAT: {\n            this.collapseStrategy = new IntFloatStrategy(maxDoc, size, collapseField, nullValue, nullPolicy, groupHeadSelector, this.needsScores, boostDocsMap);\n            break;\n          }\n          default: {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"min/max must be Int or Float field types when collapsing on numeric fields\");\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"432fdfa612cbca5b4cf9125a2c6aa055cd53cadb":["446ec69a32a7e8cb8bf6eb8be693e96ab5f5a0d3"],"3575e61fd7df2bbcce8b977a23d3d67aa423ce62":["ece7e3f03c890461bce71fb45142b75807c28a4e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"446ec69a32a7e8cb8bf6eb8be693e96ab5f5a0d3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ece7e3f03c890461bce71fb45142b75807c28a4e":["432fdfa612cbca5b4cf9125a2c6aa055cd53cadb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3575e61fd7df2bbcce8b977a23d3d67aa423ce62"]},"commit2Childs":{"432fdfa612cbca5b4cf9125a2c6aa055cd53cadb":["ece7e3f03c890461bce71fb45142b75807c28a4e"],"3575e61fd7df2bbcce8b977a23d3d67aa423ce62":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["446ec69a32a7e8cb8bf6eb8be693e96ab5f5a0d3"],"446ec69a32a7e8cb8bf6eb8be693e96ab5f5a0d3":["432fdfa612cbca5b4cf9125a2c6aa055cd53cadb"],"ece7e3f03c890461bce71fb45142b75807c28a4e":["3575e61fd7df2bbcce8b977a23d3d67aa423ce62"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}