{"path":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#fetchFullUpdateFromLeader(AddUpdateCommand,long).mjava","commits":[{"id":"415bbbe7da8065dd3c477bdc3c703c6425622998","date":1485393793,"type":0,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#fetchFullUpdateFromLeader(AddUpdateCommand,long).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * This method is used when an update on which a particular in-place update has been lost for some reason. This method\n   * sends a request to the shard leader to fetch the latest full document as seen on the leader.\n   * @return AddUpdateCommand containing latest full doc at shard leader for the given id, or null if not found.\n   */\n  private UpdateCommand fetchFullUpdateFromLeader(AddUpdateCommand inplaceAdd, long versionOnUpdate) throws IOException {\n    String id = inplaceAdd.getPrintableId();\n    UpdateShardHandler updateShardHandler = inplaceAdd.getReq().getCore().getCoreDescriptor().getCoreContainer().getUpdateShardHandler();\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"distrib\", false);\n    params.set(\"getInputDocument\", id);\n    params.set(\"onlyIfActive\", true);\n    SolrRequest<SimpleSolrResponse> ur = new GenericSolrRequest(METHOD.GET, \"/get\", params);\n\n    String leaderUrl = req.getParams().get(DISTRIB_FROM);\n    \n    if (leaderUrl == null) {\n      // An update we're dependent upon didn't arrive! This is unexpected. Perhaps likely our leader is\n      // down or partitioned from us for some reason. Lets force refresh cluster state, and request the\n      // leader for the update.\n      if (zkController == null) { // we should be in cloud mode, but wtf? could be a unit test\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Can't find document with id=\" + id + \", but fetching from leader \"\n            + \"failed since we're not in cloud mode.\");\n      }\n      Replica leader;\n      try {\n        leader = zkController.getZkStateReader().getLeaderRetry(cloudDesc.getCollectionName(), cloudDesc.getShardId());\n      } catch (InterruptedException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Exception during fetching from leader.\", e);\n      }\n      leaderUrl = leader.getCoreUrl();\n    }\n    \n    HttpSolrClient hsc = new HttpSolrClient.Builder(leaderUrl).\n        withHttpClient(updateShardHandler.getHttpClient()).build();\n    NamedList rsp = null;\n    try {\n      rsp = hsc.request(ur);\n    } catch (SolrServerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during fetching [\" + id +\n          \"] from leader (\" + leaderUrl + \"): \", e);\n    } finally {\n      hsc.close();\n    }\n    Object inputDocObj = rsp.get(\"inputDocument\");\n    Long version = (Long)rsp.get(\"version\");\n    SolrInputDocument leaderDoc = (SolrInputDocument) inputDocObj;\n\n    if (leaderDoc == null) {\n      // this doc was not found (deleted) on the leader. Lets delete it here as well.\n      DeleteUpdateCommand del = new DeleteUpdateCommand(inplaceAdd.getReq());\n      del.setIndexedId(inplaceAdd.getIndexedId());\n      del.setId(inplaceAdd.getIndexedId().utf8ToString());\n      del.setVersion((version == null || version == 0)? -versionOnUpdate: version);\n      return del;\n    }\n\n    AddUpdateCommand cmd = new AddUpdateCommand(req);\n    cmd.solrDoc = leaderDoc;\n    cmd.setVersion((long)leaderDoc.getFieldValue(VERSION_FIELD));\n    return cmd;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"598b5d23aa7c9732bf473c21a9cd309c44599394","date":1485530378,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#fetchFullUpdateFromLeader(AddUpdateCommand,long).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * This method is used when an update on which a particular in-place update has been lost for some reason. This method\n   * sends a request to the shard leader to fetch the latest full document as seen on the leader.\n   * @return AddUpdateCommand containing latest full doc at shard leader for the given id, or null if not found.\n   */\n  private UpdateCommand fetchFullUpdateFromLeader(AddUpdateCommand inplaceAdd, long versionOnUpdate) throws IOException {\n    String id = inplaceAdd.getPrintableId();\n    UpdateShardHandler updateShardHandler = inplaceAdd.getReq().getCore().getCoreDescriptor().getCoreContainer().getUpdateShardHandler();\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"distrib\", false);\n    params.set(\"getInputDocument\", id);\n    params.set(\"onlyIfActive\", true);\n    SolrRequest<SimpleSolrResponse> ur = new GenericSolrRequest(METHOD.GET, \"/get\", params);\n\n    String leaderUrl = req.getParams().get(DISTRIB_FROM);\n    \n    if (leaderUrl == null) {\n      // An update we're dependent upon didn't arrive! This is unexpected. Perhaps likely our leader is\n      // down or partitioned from us for some reason. Lets force refresh cluster state, and request the\n      // leader for the update.\n      if (zkController == null) { // we should be in cloud mode, but wtf? could be a unit test\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Can't find document with id=\" + id + \", but fetching from leader \"\n            + \"failed since we're not in cloud mode.\");\n      }\n      Replica leader;\n      try {\n        leader = zkController.getZkStateReader().getLeaderRetry(cloudDesc.getCollectionName(), cloudDesc.getShardId());\n      } catch (InterruptedException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Exception during fetching from leader.\", e);\n      }\n      leaderUrl = leader.getCoreUrl();\n    }\n    \n    HttpSolrClient hsc = new HttpSolrClient.Builder(leaderUrl).\n        withHttpClient(updateShardHandler.getHttpClient()).build();\n    NamedList rsp = null;\n    try {\n      rsp = hsc.request(ur);\n    } catch (SolrServerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during fetching [\" + id +\n          \"] from leader (\" + leaderUrl + \"): \", e);\n    } finally {\n      hsc.close();\n    }\n    Object inputDocObj = rsp.get(\"inputDocument\");\n    Long version = (Long)rsp.get(\"version\");\n    SolrInputDocument leaderDoc = (SolrInputDocument) inputDocObj;\n\n    if (leaderDoc == null) {\n      // this doc was not found (deleted) on the leader. Lets delete it here as well.\n      DeleteUpdateCommand del = new DeleteUpdateCommand(inplaceAdd.getReq());\n      del.setIndexedId(inplaceAdd.getIndexedId());\n      del.setId(inplaceAdd.getIndexedId().utf8ToString());\n      del.setVersion((version == null || version == 0)? -versionOnUpdate: version);\n      return del;\n    }\n\n    AddUpdateCommand cmd = new AddUpdateCommand(req);\n    cmd.solrDoc = leaderDoc;\n    cmd.setVersion((long)leaderDoc.getFieldValue(VERSION_FIELD));\n    return cmd;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6d2dadc1f5ca8703d8659f4964961f9967935d75","date":1490231750,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#fetchFullUpdateFromLeader(AddUpdateCommand,long).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#fetchFullUpdateFromLeader(AddUpdateCommand,long).mjava","sourceNew":"  /**\n   * This method is used when an update on which a particular in-place update has been lost for some reason. This method\n   * sends a request to the shard leader to fetch the latest full document as seen on the leader.\n   * @return AddUpdateCommand containing latest full doc at shard leader for the given id, or null if not found.\n   */\n  private UpdateCommand fetchFullUpdateFromLeader(AddUpdateCommand inplaceAdd, long versionOnUpdate) throws IOException {\n    String id = inplaceAdd.getPrintableId();\n    UpdateShardHandler updateShardHandler = inplaceAdd.getReq().getCore().getCoreDescriptor().getCoreContainer().getUpdateShardHandler();\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"distrib\", false);\n    params.set(\"getInputDocument\", id);\n    params.set(\"onlyIfActive\", true);\n    SolrRequest<SimpleSolrResponse> ur = new GenericSolrRequest(METHOD.GET, \"/get\", params);\n\n    String leaderUrl = req.getParams().get(DISTRIB_FROM);\n    \n    if (leaderUrl == null) {\n      // An update we're dependent upon didn't arrive! This is unexpected. Perhaps likely our leader is\n      // down or partitioned from us for some reason. Lets force refresh cluster state, and request the\n      // leader for the update.\n      if (zkController == null) { // we should be in cloud mode, but wtf? could be a unit test\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Can't find document with id=\" + id + \", but fetching from leader \"\n            + \"failed since we're not in cloud mode.\");\n      }\n      Replica leader;\n      try {\n        leader = zkController.getZkStateReader().getLeaderRetry(cloudDesc.getCollectionName(), cloudDesc.getShardId());\n      } catch (InterruptedException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Exception during fetching from leader.\", e);\n      }\n      leaderUrl = leader.getCoreUrl();\n    }\n    \n    HttpSolrClient hsc = new HttpSolrClient.Builder(leaderUrl).\n        withHttpClient(updateShardHandler.getHttpClient()).build();\n    NamedList rsp = null;\n    try {\n      rsp = hsc.request(ur);\n    } catch (SolrServerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during fetching [\" + id +\n          \"] from leader (\" + leaderUrl + \"): \", e);\n    } finally {\n      hsc.close();\n    }\n    Object inputDocObj = rsp.get(\"inputDocument\");\n    Long version = (Long)rsp.get(\"version\");\n    SolrInputDocument leaderDoc = (SolrInputDocument) inputDocObj;\n\n    if (leaderDoc == null) {\n      // this doc was not found (deleted) on the leader. Lets delete it here as well.\n      DeleteUpdateCommand del = new DeleteUpdateCommand(inplaceAdd.getReq());\n      del.setIndexedId(inplaceAdd.getIndexedId());\n      del.setId(inplaceAdd.getIndexedId().utf8ToString());\n      del.setVersion((version == null || version == 0)? -versionOnUpdate: version);\n      return del;\n    }\n\n    AddUpdateCommand cmd = new AddUpdateCommand(req);\n    cmd.solrDoc = leaderDoc;\n    cmd.setVersion((long)leaderDoc.getFieldValue(CommonParams.VERSION_FIELD));\n    return cmd;\n  }\n\n","sourceOld":"  /**\n   * This method is used when an update on which a particular in-place update has been lost for some reason. This method\n   * sends a request to the shard leader to fetch the latest full document as seen on the leader.\n   * @return AddUpdateCommand containing latest full doc at shard leader for the given id, or null if not found.\n   */\n  private UpdateCommand fetchFullUpdateFromLeader(AddUpdateCommand inplaceAdd, long versionOnUpdate) throws IOException {\n    String id = inplaceAdd.getPrintableId();\n    UpdateShardHandler updateShardHandler = inplaceAdd.getReq().getCore().getCoreDescriptor().getCoreContainer().getUpdateShardHandler();\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"distrib\", false);\n    params.set(\"getInputDocument\", id);\n    params.set(\"onlyIfActive\", true);\n    SolrRequest<SimpleSolrResponse> ur = new GenericSolrRequest(METHOD.GET, \"/get\", params);\n\n    String leaderUrl = req.getParams().get(DISTRIB_FROM);\n    \n    if (leaderUrl == null) {\n      // An update we're dependent upon didn't arrive! This is unexpected. Perhaps likely our leader is\n      // down or partitioned from us for some reason. Lets force refresh cluster state, and request the\n      // leader for the update.\n      if (zkController == null) { // we should be in cloud mode, but wtf? could be a unit test\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Can't find document with id=\" + id + \", but fetching from leader \"\n            + \"failed since we're not in cloud mode.\");\n      }\n      Replica leader;\n      try {\n        leader = zkController.getZkStateReader().getLeaderRetry(cloudDesc.getCollectionName(), cloudDesc.getShardId());\n      } catch (InterruptedException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Exception during fetching from leader.\", e);\n      }\n      leaderUrl = leader.getCoreUrl();\n    }\n    \n    HttpSolrClient hsc = new HttpSolrClient.Builder(leaderUrl).\n        withHttpClient(updateShardHandler.getHttpClient()).build();\n    NamedList rsp = null;\n    try {\n      rsp = hsc.request(ur);\n    } catch (SolrServerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during fetching [\" + id +\n          \"] from leader (\" + leaderUrl + \"): \", e);\n    } finally {\n      hsc.close();\n    }\n    Object inputDocObj = rsp.get(\"inputDocument\");\n    Long version = (Long)rsp.get(\"version\");\n    SolrInputDocument leaderDoc = (SolrInputDocument) inputDocObj;\n\n    if (leaderDoc == null) {\n      // this doc was not found (deleted) on the leader. Lets delete it here as well.\n      DeleteUpdateCommand del = new DeleteUpdateCommand(inplaceAdd.getReq());\n      del.setIndexedId(inplaceAdd.getIndexedId());\n      del.setId(inplaceAdd.getIndexedId().utf8ToString());\n      del.setVersion((version == null || version == 0)? -versionOnUpdate: version);\n      return del;\n    }\n\n    AddUpdateCommand cmd = new AddUpdateCommand(req);\n    cmd.solrDoc = leaderDoc;\n    cmd.setVersion((long)leaderDoc.getFieldValue(VERSION_FIELD));\n    return cmd;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"01624b85de12fb02335810bdf325124e59040772","date":1490254940,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#fetchFullUpdateFromLeader(AddUpdateCommand,long).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#fetchFullUpdateFromLeader(AddUpdateCommand,long).mjava","sourceNew":"  /**\n   * This method is used when an update on which a particular in-place update has been lost for some reason. This method\n   * sends a request to the shard leader to fetch the latest full document as seen on the leader.\n   * @return AddUpdateCommand containing latest full doc at shard leader for the given id, or null if not found.\n   */\n  private UpdateCommand fetchFullUpdateFromLeader(AddUpdateCommand inplaceAdd, long versionOnUpdate) throws IOException {\n    String id = inplaceAdd.getPrintableId();\n    UpdateShardHandler updateShardHandler = inplaceAdd.getReq().getCore().getCoreDescriptor().getCoreContainer().getUpdateShardHandler();\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(DISTRIB, false);\n    params.set(\"getInputDocument\", id);\n    params.set(\"onlyIfActive\", true);\n    SolrRequest<SimpleSolrResponse> ur = new GenericSolrRequest(METHOD.GET, \"/get\", params);\n\n    String leaderUrl = req.getParams().get(DISTRIB_FROM);\n    \n    if (leaderUrl == null) {\n      // An update we're dependent upon didn't arrive! This is unexpected. Perhaps likely our leader is\n      // down or partitioned from us for some reason. Lets force refresh cluster state, and request the\n      // leader for the update.\n      if (zkController == null) { // we should be in cloud mode, but wtf? could be a unit test\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Can't find document with id=\" + id + \", but fetching from leader \"\n            + \"failed since we're not in cloud mode.\");\n      }\n      Replica leader;\n      try {\n        leader = zkController.getZkStateReader().getLeaderRetry(cloudDesc.getCollectionName(), cloudDesc.getShardId());\n      } catch (InterruptedException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Exception during fetching from leader.\", e);\n      }\n      leaderUrl = leader.getCoreUrl();\n    }\n    \n    HttpSolrClient hsc = new HttpSolrClient.Builder(leaderUrl).\n        withHttpClient(updateShardHandler.getHttpClient()).build();\n    NamedList rsp = null;\n    try {\n      rsp = hsc.request(ur);\n    } catch (SolrServerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during fetching [\" + id +\n          \"] from leader (\" + leaderUrl + \"): \", e);\n    } finally {\n      hsc.close();\n    }\n    Object inputDocObj = rsp.get(\"inputDocument\");\n    Long version = (Long)rsp.get(\"version\");\n    SolrInputDocument leaderDoc = (SolrInputDocument) inputDocObj;\n\n    if (leaderDoc == null) {\n      // this doc was not found (deleted) on the leader. Lets delete it here as well.\n      DeleteUpdateCommand del = new DeleteUpdateCommand(inplaceAdd.getReq());\n      del.setIndexedId(inplaceAdd.getIndexedId());\n      del.setId(inplaceAdd.getIndexedId().utf8ToString());\n      del.setVersion((version == null || version == 0)? -versionOnUpdate: version);\n      return del;\n    }\n\n    AddUpdateCommand cmd = new AddUpdateCommand(req);\n    cmd.solrDoc = leaderDoc;\n    cmd.setVersion((long)leaderDoc.getFieldValue(CommonParams.VERSION_FIELD));\n    return cmd;\n  }\n\n","sourceOld":"  /**\n   * This method is used when an update on which a particular in-place update has been lost for some reason. This method\n   * sends a request to the shard leader to fetch the latest full document as seen on the leader.\n   * @return AddUpdateCommand containing latest full doc at shard leader for the given id, or null if not found.\n   */\n  private UpdateCommand fetchFullUpdateFromLeader(AddUpdateCommand inplaceAdd, long versionOnUpdate) throws IOException {\n    String id = inplaceAdd.getPrintableId();\n    UpdateShardHandler updateShardHandler = inplaceAdd.getReq().getCore().getCoreDescriptor().getCoreContainer().getUpdateShardHandler();\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"distrib\", false);\n    params.set(\"getInputDocument\", id);\n    params.set(\"onlyIfActive\", true);\n    SolrRequest<SimpleSolrResponse> ur = new GenericSolrRequest(METHOD.GET, \"/get\", params);\n\n    String leaderUrl = req.getParams().get(DISTRIB_FROM);\n    \n    if (leaderUrl == null) {\n      // An update we're dependent upon didn't arrive! This is unexpected. Perhaps likely our leader is\n      // down or partitioned from us for some reason. Lets force refresh cluster state, and request the\n      // leader for the update.\n      if (zkController == null) { // we should be in cloud mode, but wtf? could be a unit test\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Can't find document with id=\" + id + \", but fetching from leader \"\n            + \"failed since we're not in cloud mode.\");\n      }\n      Replica leader;\n      try {\n        leader = zkController.getZkStateReader().getLeaderRetry(cloudDesc.getCollectionName(), cloudDesc.getShardId());\n      } catch (InterruptedException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Exception during fetching from leader.\", e);\n      }\n      leaderUrl = leader.getCoreUrl();\n    }\n    \n    HttpSolrClient hsc = new HttpSolrClient.Builder(leaderUrl).\n        withHttpClient(updateShardHandler.getHttpClient()).build();\n    NamedList rsp = null;\n    try {\n      rsp = hsc.request(ur);\n    } catch (SolrServerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during fetching [\" + id +\n          \"] from leader (\" + leaderUrl + \"): \", e);\n    } finally {\n      hsc.close();\n    }\n    Object inputDocObj = rsp.get(\"inputDocument\");\n    Long version = (Long)rsp.get(\"version\");\n    SolrInputDocument leaderDoc = (SolrInputDocument) inputDocObj;\n\n    if (leaderDoc == null) {\n      // this doc was not found (deleted) on the leader. Lets delete it here as well.\n      DeleteUpdateCommand del = new DeleteUpdateCommand(inplaceAdd.getReq());\n      del.setIndexedId(inplaceAdd.getIndexedId());\n      del.setId(inplaceAdd.getIndexedId().utf8ToString());\n      del.setVersion((version == null || version == 0)? -versionOnUpdate: version);\n      return del;\n    }\n\n    AddUpdateCommand cmd = new AddUpdateCommand(req);\n    cmd.solrDoc = leaderDoc;\n    cmd.setVersion((long)leaderDoc.getFieldValue(CommonParams.VERSION_FIELD));\n    return cmd;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e5fa6615014cd2288fe930f8c8bb726f9504961d","date":1490280013,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#fetchFullUpdateFromLeader(AddUpdateCommand,long).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#fetchFullUpdateFromLeader(AddUpdateCommand,long).mjava","sourceNew":"  /**\n   * This method is used when an update on which a particular in-place update has been lost for some reason. This method\n   * sends a request to the shard leader to fetch the latest full document as seen on the leader.\n   * @return AddUpdateCommand containing latest full doc at shard leader for the given id, or null if not found.\n   */\n  private UpdateCommand fetchFullUpdateFromLeader(AddUpdateCommand inplaceAdd, long versionOnUpdate) throws IOException {\n    String id = inplaceAdd.getPrintableId();\n    UpdateShardHandler updateShardHandler = inplaceAdd.getReq().getCore().getCoreDescriptor().getCoreContainer().getUpdateShardHandler();\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"distrib\", false);\n    params.set(\"getInputDocument\", id);\n    params.set(\"onlyIfActive\", true);\n    SolrRequest<SimpleSolrResponse> ur = new GenericSolrRequest(METHOD.GET, \"/get\", params);\n\n    String leaderUrl = req.getParams().get(DISTRIB_FROM);\n    \n    if (leaderUrl == null) {\n      // An update we're dependent upon didn't arrive! This is unexpected. Perhaps likely our leader is\n      // down or partitioned from us for some reason. Lets force refresh cluster state, and request the\n      // leader for the update.\n      if (zkController == null) { // we should be in cloud mode, but wtf? could be a unit test\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Can't find document with id=\" + id + \", but fetching from leader \"\n            + \"failed since we're not in cloud mode.\");\n      }\n      Replica leader;\n      try {\n        leader = zkController.getZkStateReader().getLeaderRetry(cloudDesc.getCollectionName(), cloudDesc.getShardId());\n      } catch (InterruptedException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Exception during fetching from leader.\", e);\n      }\n      leaderUrl = leader.getCoreUrl();\n    }\n    \n    HttpSolrClient hsc = new HttpSolrClient.Builder(leaderUrl).\n        withHttpClient(updateShardHandler.getHttpClient()).build();\n    NamedList rsp = null;\n    try {\n      rsp = hsc.request(ur);\n    } catch (SolrServerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during fetching [\" + id +\n          \"] from leader (\" + leaderUrl + \"): \", e);\n    } finally {\n      hsc.close();\n    }\n    Object inputDocObj = rsp.get(\"inputDocument\");\n    Long version = (Long)rsp.get(\"version\");\n    SolrInputDocument leaderDoc = (SolrInputDocument) inputDocObj;\n\n    if (leaderDoc == null) {\n      // this doc was not found (deleted) on the leader. Lets delete it here as well.\n      DeleteUpdateCommand del = new DeleteUpdateCommand(inplaceAdd.getReq());\n      del.setIndexedId(inplaceAdd.getIndexedId());\n      del.setId(inplaceAdd.getIndexedId().utf8ToString());\n      del.setVersion((version == null || version == 0)? -versionOnUpdate: version);\n      return del;\n    }\n\n    AddUpdateCommand cmd = new AddUpdateCommand(req);\n    cmd.solrDoc = leaderDoc;\n    cmd.setVersion((long)leaderDoc.getFieldValue(CommonParams.VERSION_FIELD));\n    return cmd;\n  }\n\n","sourceOld":"  /**\n   * This method is used when an update on which a particular in-place update has been lost for some reason. This method\n   * sends a request to the shard leader to fetch the latest full document as seen on the leader.\n   * @return AddUpdateCommand containing latest full doc at shard leader for the given id, or null if not found.\n   */\n  private UpdateCommand fetchFullUpdateFromLeader(AddUpdateCommand inplaceAdd, long versionOnUpdate) throws IOException {\n    String id = inplaceAdd.getPrintableId();\n    UpdateShardHandler updateShardHandler = inplaceAdd.getReq().getCore().getCoreDescriptor().getCoreContainer().getUpdateShardHandler();\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"distrib\", false);\n    params.set(\"getInputDocument\", id);\n    params.set(\"onlyIfActive\", true);\n    SolrRequest<SimpleSolrResponse> ur = new GenericSolrRequest(METHOD.GET, \"/get\", params);\n\n    String leaderUrl = req.getParams().get(DISTRIB_FROM);\n    \n    if (leaderUrl == null) {\n      // An update we're dependent upon didn't arrive! This is unexpected. Perhaps likely our leader is\n      // down or partitioned from us for some reason. Lets force refresh cluster state, and request the\n      // leader for the update.\n      if (zkController == null) { // we should be in cloud mode, but wtf? could be a unit test\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Can't find document with id=\" + id + \", but fetching from leader \"\n            + \"failed since we're not in cloud mode.\");\n      }\n      Replica leader;\n      try {\n        leader = zkController.getZkStateReader().getLeaderRetry(cloudDesc.getCollectionName(), cloudDesc.getShardId());\n      } catch (InterruptedException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Exception during fetching from leader.\", e);\n      }\n      leaderUrl = leader.getCoreUrl();\n    }\n    \n    HttpSolrClient hsc = new HttpSolrClient.Builder(leaderUrl).\n        withHttpClient(updateShardHandler.getHttpClient()).build();\n    NamedList rsp = null;\n    try {\n      rsp = hsc.request(ur);\n    } catch (SolrServerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during fetching [\" + id +\n          \"] from leader (\" + leaderUrl + \"): \", e);\n    } finally {\n      hsc.close();\n    }\n    Object inputDocObj = rsp.get(\"inputDocument\");\n    Long version = (Long)rsp.get(\"version\");\n    SolrInputDocument leaderDoc = (SolrInputDocument) inputDocObj;\n\n    if (leaderDoc == null) {\n      // this doc was not found (deleted) on the leader. Lets delete it here as well.\n      DeleteUpdateCommand del = new DeleteUpdateCommand(inplaceAdd.getReq());\n      del.setIndexedId(inplaceAdd.getIndexedId());\n      del.setId(inplaceAdd.getIndexedId().utf8ToString());\n      del.setVersion((version == null || version == 0)? -versionOnUpdate: version);\n      return del;\n    }\n\n    AddUpdateCommand cmd = new AddUpdateCommand(req);\n    cmd.solrDoc = leaderDoc;\n    cmd.setVersion((long)leaderDoc.getFieldValue(VERSION_FIELD));\n    return cmd;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6f4c5d3859373c3a74734e85efa122b17514e3e8","date":1490280013,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#fetchFullUpdateFromLeader(AddUpdateCommand,long).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#fetchFullUpdateFromLeader(AddUpdateCommand,long).mjava","sourceNew":"  /**\n   * This method is used when an update on which a particular in-place update has been lost for some reason. This method\n   * sends a request to the shard leader to fetch the latest full document as seen on the leader.\n   * @return AddUpdateCommand containing latest full doc at shard leader for the given id, or null if not found.\n   */\n  private UpdateCommand fetchFullUpdateFromLeader(AddUpdateCommand inplaceAdd, long versionOnUpdate) throws IOException {\n    String id = inplaceAdd.getPrintableId();\n    UpdateShardHandler updateShardHandler = inplaceAdd.getReq().getCore().getCoreDescriptor().getCoreContainer().getUpdateShardHandler();\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(DISTRIB, false);\n    params.set(\"getInputDocument\", id);\n    params.set(\"onlyIfActive\", true);\n    SolrRequest<SimpleSolrResponse> ur = new GenericSolrRequest(METHOD.GET, \"/get\", params);\n\n    String leaderUrl = req.getParams().get(DISTRIB_FROM);\n    \n    if (leaderUrl == null) {\n      // An update we're dependent upon didn't arrive! This is unexpected. Perhaps likely our leader is\n      // down or partitioned from us for some reason. Lets force refresh cluster state, and request the\n      // leader for the update.\n      if (zkController == null) { // we should be in cloud mode, but wtf? could be a unit test\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Can't find document with id=\" + id + \", but fetching from leader \"\n            + \"failed since we're not in cloud mode.\");\n      }\n      Replica leader;\n      try {\n        leader = zkController.getZkStateReader().getLeaderRetry(cloudDesc.getCollectionName(), cloudDesc.getShardId());\n      } catch (InterruptedException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Exception during fetching from leader.\", e);\n      }\n      leaderUrl = leader.getCoreUrl();\n    }\n    \n    HttpSolrClient hsc = new HttpSolrClient.Builder(leaderUrl).\n        withHttpClient(updateShardHandler.getHttpClient()).build();\n    NamedList rsp = null;\n    try {\n      rsp = hsc.request(ur);\n    } catch (SolrServerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during fetching [\" + id +\n          \"] from leader (\" + leaderUrl + \"): \", e);\n    } finally {\n      hsc.close();\n    }\n    Object inputDocObj = rsp.get(\"inputDocument\");\n    Long version = (Long)rsp.get(\"version\");\n    SolrInputDocument leaderDoc = (SolrInputDocument) inputDocObj;\n\n    if (leaderDoc == null) {\n      // this doc was not found (deleted) on the leader. Lets delete it here as well.\n      DeleteUpdateCommand del = new DeleteUpdateCommand(inplaceAdd.getReq());\n      del.setIndexedId(inplaceAdd.getIndexedId());\n      del.setId(inplaceAdd.getIndexedId().utf8ToString());\n      del.setVersion((version == null || version == 0)? -versionOnUpdate: version);\n      return del;\n    }\n\n    AddUpdateCommand cmd = new AddUpdateCommand(req);\n    cmd.solrDoc = leaderDoc;\n    cmd.setVersion((long)leaderDoc.getFieldValue(CommonParams.VERSION_FIELD));\n    return cmd;\n  }\n\n","sourceOld":"  /**\n   * This method is used when an update on which a particular in-place update has been lost for some reason. This method\n   * sends a request to the shard leader to fetch the latest full document as seen on the leader.\n   * @return AddUpdateCommand containing latest full doc at shard leader for the given id, or null if not found.\n   */\n  private UpdateCommand fetchFullUpdateFromLeader(AddUpdateCommand inplaceAdd, long versionOnUpdate) throws IOException {\n    String id = inplaceAdd.getPrintableId();\n    UpdateShardHandler updateShardHandler = inplaceAdd.getReq().getCore().getCoreDescriptor().getCoreContainer().getUpdateShardHandler();\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"distrib\", false);\n    params.set(\"getInputDocument\", id);\n    params.set(\"onlyIfActive\", true);\n    SolrRequest<SimpleSolrResponse> ur = new GenericSolrRequest(METHOD.GET, \"/get\", params);\n\n    String leaderUrl = req.getParams().get(DISTRIB_FROM);\n    \n    if (leaderUrl == null) {\n      // An update we're dependent upon didn't arrive! This is unexpected. Perhaps likely our leader is\n      // down or partitioned from us for some reason. Lets force refresh cluster state, and request the\n      // leader for the update.\n      if (zkController == null) { // we should be in cloud mode, but wtf? could be a unit test\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Can't find document with id=\" + id + \", but fetching from leader \"\n            + \"failed since we're not in cloud mode.\");\n      }\n      Replica leader;\n      try {\n        leader = zkController.getZkStateReader().getLeaderRetry(cloudDesc.getCollectionName(), cloudDesc.getShardId());\n      } catch (InterruptedException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Exception during fetching from leader.\", e);\n      }\n      leaderUrl = leader.getCoreUrl();\n    }\n    \n    HttpSolrClient hsc = new HttpSolrClient.Builder(leaderUrl).\n        withHttpClient(updateShardHandler.getHttpClient()).build();\n    NamedList rsp = null;\n    try {\n      rsp = hsc.request(ur);\n    } catch (SolrServerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during fetching [\" + id +\n          \"] from leader (\" + leaderUrl + \"): \", e);\n    } finally {\n      hsc.close();\n    }\n    Object inputDocObj = rsp.get(\"inputDocument\");\n    Long version = (Long)rsp.get(\"version\");\n    SolrInputDocument leaderDoc = (SolrInputDocument) inputDocObj;\n\n    if (leaderDoc == null) {\n      // this doc was not found (deleted) on the leader. Lets delete it here as well.\n      DeleteUpdateCommand del = new DeleteUpdateCommand(inplaceAdd.getReq());\n      del.setIndexedId(inplaceAdd.getIndexedId());\n      del.setId(inplaceAdd.getIndexedId().utf8ToString());\n      del.setVersion((version == null || version == 0)? -versionOnUpdate: version);\n      return del;\n    }\n\n    AddUpdateCommand cmd = new AddUpdateCommand(req);\n    cmd.solrDoc = leaderDoc;\n    cmd.setVersion((long)leaderDoc.getFieldValue(CommonParams.VERSION_FIELD));\n    return cmd;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"729cb470f975115d4c60517b2cb7c42e37a7a2e1","date":1492041760,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#fetchFullUpdateFromLeader(AddUpdateCommand,long).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#fetchFullUpdateFromLeader(AddUpdateCommand,long).mjava","sourceNew":"  /**\n   * This method is used when an update on which a particular in-place update has been lost for some reason. This method\n   * sends a request to the shard leader to fetch the latest full document as seen on the leader.\n   * @return AddUpdateCommand containing latest full doc at shard leader for the given id, or null if not found.\n   */\n  private UpdateCommand fetchFullUpdateFromLeader(AddUpdateCommand inplaceAdd, long versionOnUpdate) throws IOException {\n    String id = inplaceAdd.getPrintableId();\n    UpdateShardHandler updateShardHandler = inplaceAdd.getReq().getCore().getCoreContainer().getUpdateShardHandler();\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(DISTRIB, false);\n    params.set(\"getInputDocument\", id);\n    params.set(\"onlyIfActive\", true);\n    SolrRequest<SimpleSolrResponse> ur = new GenericSolrRequest(METHOD.GET, \"/get\", params);\n\n    String leaderUrl = req.getParams().get(DISTRIB_FROM);\n    \n    if (leaderUrl == null) {\n      // An update we're dependent upon didn't arrive! This is unexpected. Perhaps likely our leader is\n      // down or partitioned from us for some reason. Lets force refresh cluster state, and request the\n      // leader for the update.\n      if (zkController == null) { // we should be in cloud mode, but wtf? could be a unit test\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Can't find document with id=\" + id + \", but fetching from leader \"\n            + \"failed since we're not in cloud mode.\");\n      }\n      Replica leader;\n      try {\n        leader = zkController.getZkStateReader().getLeaderRetry(cloudDesc.getCollectionName(), cloudDesc.getShardId());\n      } catch (InterruptedException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Exception during fetching from leader.\", e);\n      }\n      leaderUrl = leader.getCoreUrl();\n    }\n    \n    HttpSolrClient hsc = new HttpSolrClient.Builder(leaderUrl).\n        withHttpClient(updateShardHandler.getHttpClient()).build();\n    NamedList rsp = null;\n    try {\n      rsp = hsc.request(ur);\n    } catch (SolrServerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during fetching [\" + id +\n          \"] from leader (\" + leaderUrl + \"): \", e);\n    } finally {\n      hsc.close();\n    }\n    Object inputDocObj = rsp.get(\"inputDocument\");\n    Long version = (Long)rsp.get(\"version\");\n    SolrInputDocument leaderDoc = (SolrInputDocument) inputDocObj;\n\n    if (leaderDoc == null) {\n      // this doc was not found (deleted) on the leader. Lets delete it here as well.\n      DeleteUpdateCommand del = new DeleteUpdateCommand(inplaceAdd.getReq());\n      del.setIndexedId(inplaceAdd.getIndexedId());\n      del.setId(inplaceAdd.getIndexedId().utf8ToString());\n      del.setVersion((version == null || version == 0)? -versionOnUpdate: version);\n      return del;\n    }\n\n    AddUpdateCommand cmd = new AddUpdateCommand(req);\n    cmd.solrDoc = leaderDoc;\n    cmd.setVersion((long)leaderDoc.getFieldValue(CommonParams.VERSION_FIELD));\n    return cmd;\n  }\n\n","sourceOld":"  /**\n   * This method is used when an update on which a particular in-place update has been lost for some reason. This method\n   * sends a request to the shard leader to fetch the latest full document as seen on the leader.\n   * @return AddUpdateCommand containing latest full doc at shard leader for the given id, or null if not found.\n   */\n  private UpdateCommand fetchFullUpdateFromLeader(AddUpdateCommand inplaceAdd, long versionOnUpdate) throws IOException {\n    String id = inplaceAdd.getPrintableId();\n    UpdateShardHandler updateShardHandler = inplaceAdd.getReq().getCore().getCoreDescriptor().getCoreContainer().getUpdateShardHandler();\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(DISTRIB, false);\n    params.set(\"getInputDocument\", id);\n    params.set(\"onlyIfActive\", true);\n    SolrRequest<SimpleSolrResponse> ur = new GenericSolrRequest(METHOD.GET, \"/get\", params);\n\n    String leaderUrl = req.getParams().get(DISTRIB_FROM);\n    \n    if (leaderUrl == null) {\n      // An update we're dependent upon didn't arrive! This is unexpected. Perhaps likely our leader is\n      // down or partitioned from us for some reason. Lets force refresh cluster state, and request the\n      // leader for the update.\n      if (zkController == null) { // we should be in cloud mode, but wtf? could be a unit test\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Can't find document with id=\" + id + \", but fetching from leader \"\n            + \"failed since we're not in cloud mode.\");\n      }\n      Replica leader;\n      try {\n        leader = zkController.getZkStateReader().getLeaderRetry(cloudDesc.getCollectionName(), cloudDesc.getShardId());\n      } catch (InterruptedException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Exception during fetching from leader.\", e);\n      }\n      leaderUrl = leader.getCoreUrl();\n    }\n    \n    HttpSolrClient hsc = new HttpSolrClient.Builder(leaderUrl).\n        withHttpClient(updateShardHandler.getHttpClient()).build();\n    NamedList rsp = null;\n    try {\n      rsp = hsc.request(ur);\n    } catch (SolrServerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during fetching [\" + id +\n          \"] from leader (\" + leaderUrl + \"): \", e);\n    } finally {\n      hsc.close();\n    }\n    Object inputDocObj = rsp.get(\"inputDocument\");\n    Long version = (Long)rsp.get(\"version\");\n    SolrInputDocument leaderDoc = (SolrInputDocument) inputDocObj;\n\n    if (leaderDoc == null) {\n      // this doc was not found (deleted) on the leader. Lets delete it here as well.\n      DeleteUpdateCommand del = new DeleteUpdateCommand(inplaceAdd.getReq());\n      del.setIndexedId(inplaceAdd.getIndexedId());\n      del.setId(inplaceAdd.getIndexedId().utf8ToString());\n      del.setVersion((version == null || version == 0)? -versionOnUpdate: version);\n      return del;\n    }\n\n    AddUpdateCommand cmd = new AddUpdateCommand(req);\n    cmd.solrDoc = leaderDoc;\n    cmd.setVersion((long)leaderDoc.getFieldValue(CommonParams.VERSION_FIELD));\n    return cmd;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#fetchFullUpdateFromLeader(AddUpdateCommand,long).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#fetchFullUpdateFromLeader(AddUpdateCommand,long).mjava","sourceNew":"  /**\n   * This method is used when an update on which a particular in-place update has been lost for some reason. This method\n   * sends a request to the shard leader to fetch the latest full document as seen on the leader.\n   * @return AddUpdateCommand containing latest full doc at shard leader for the given id, or null if not found.\n   */\n  private UpdateCommand fetchFullUpdateFromLeader(AddUpdateCommand inplaceAdd, long versionOnUpdate) throws IOException {\n    String id = inplaceAdd.getPrintableId();\n    UpdateShardHandler updateShardHandler = inplaceAdd.getReq().getCore().getCoreContainer().getUpdateShardHandler();\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(DISTRIB, false);\n    params.set(\"getInputDocument\", id);\n    params.set(\"onlyIfActive\", true);\n    SolrRequest<SimpleSolrResponse> ur = new GenericSolrRequest(METHOD.GET, \"/get\", params);\n\n    String leaderUrl = req.getParams().get(DISTRIB_FROM);\n    \n    if (leaderUrl == null) {\n      // An update we're dependent upon didn't arrive! This is unexpected. Perhaps likely our leader is\n      // down or partitioned from us for some reason. Lets force refresh cluster state, and request the\n      // leader for the update.\n      if (zkController == null) { // we should be in cloud mode, but wtf? could be a unit test\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Can't find document with id=\" + id + \", but fetching from leader \"\n            + \"failed since we're not in cloud mode.\");\n      }\n      Replica leader;\n      try {\n        leader = zkController.getZkStateReader().getLeaderRetry(cloudDesc.getCollectionName(), cloudDesc.getShardId());\n      } catch (InterruptedException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Exception during fetching from leader.\", e);\n      }\n      leaderUrl = leader.getCoreUrl();\n    }\n    \n    HttpSolrClient hsc = new HttpSolrClient.Builder(leaderUrl).\n        withHttpClient(updateShardHandler.getHttpClient()).build();\n    NamedList rsp = null;\n    try {\n      rsp = hsc.request(ur);\n    } catch (SolrServerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during fetching [\" + id +\n          \"] from leader (\" + leaderUrl + \"): \", e);\n    } finally {\n      hsc.close();\n    }\n    Object inputDocObj = rsp.get(\"inputDocument\");\n    Long version = (Long)rsp.get(\"version\");\n    SolrInputDocument leaderDoc = (SolrInputDocument) inputDocObj;\n\n    if (leaderDoc == null) {\n      // this doc was not found (deleted) on the leader. Lets delete it here as well.\n      DeleteUpdateCommand del = new DeleteUpdateCommand(inplaceAdd.getReq());\n      del.setIndexedId(inplaceAdd.getIndexedId());\n      del.setId(inplaceAdd.getIndexedId().utf8ToString());\n      del.setVersion((version == null || version == 0)? -versionOnUpdate: version);\n      return del;\n    }\n\n    AddUpdateCommand cmd = new AddUpdateCommand(req);\n    cmd.solrDoc = leaderDoc;\n    cmd.setVersion((long)leaderDoc.getFieldValue(CommonParams.VERSION_FIELD));\n    return cmd;\n  }\n\n","sourceOld":"  /**\n   * This method is used when an update on which a particular in-place update has been lost for some reason. This method\n   * sends a request to the shard leader to fetch the latest full document as seen on the leader.\n   * @return AddUpdateCommand containing latest full doc at shard leader for the given id, or null if not found.\n   */\n  private UpdateCommand fetchFullUpdateFromLeader(AddUpdateCommand inplaceAdd, long versionOnUpdate) throws IOException {\n    String id = inplaceAdd.getPrintableId();\n    UpdateShardHandler updateShardHandler = inplaceAdd.getReq().getCore().getCoreDescriptor().getCoreContainer().getUpdateShardHandler();\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(DISTRIB, false);\n    params.set(\"getInputDocument\", id);\n    params.set(\"onlyIfActive\", true);\n    SolrRequest<SimpleSolrResponse> ur = new GenericSolrRequest(METHOD.GET, \"/get\", params);\n\n    String leaderUrl = req.getParams().get(DISTRIB_FROM);\n    \n    if (leaderUrl == null) {\n      // An update we're dependent upon didn't arrive! This is unexpected. Perhaps likely our leader is\n      // down or partitioned from us for some reason. Lets force refresh cluster state, and request the\n      // leader for the update.\n      if (zkController == null) { // we should be in cloud mode, but wtf? could be a unit test\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Can't find document with id=\" + id + \", but fetching from leader \"\n            + \"failed since we're not in cloud mode.\");\n      }\n      Replica leader;\n      try {\n        leader = zkController.getZkStateReader().getLeaderRetry(cloudDesc.getCollectionName(), cloudDesc.getShardId());\n      } catch (InterruptedException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Exception during fetching from leader.\", e);\n      }\n      leaderUrl = leader.getCoreUrl();\n    }\n    \n    HttpSolrClient hsc = new HttpSolrClient.Builder(leaderUrl).\n        withHttpClient(updateShardHandler.getHttpClient()).build();\n    NamedList rsp = null;\n    try {\n      rsp = hsc.request(ur);\n    } catch (SolrServerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during fetching [\" + id +\n          \"] from leader (\" + leaderUrl + \"): \", e);\n    } finally {\n      hsc.close();\n    }\n    Object inputDocObj = rsp.get(\"inputDocument\");\n    Long version = (Long)rsp.get(\"version\");\n    SolrInputDocument leaderDoc = (SolrInputDocument) inputDocObj;\n\n    if (leaderDoc == null) {\n      // this doc was not found (deleted) on the leader. Lets delete it here as well.\n      DeleteUpdateCommand del = new DeleteUpdateCommand(inplaceAdd.getReq());\n      del.setIndexedId(inplaceAdd.getIndexedId());\n      del.setId(inplaceAdd.getIndexedId().utf8ToString());\n      del.setVersion((version == null || version == 0)? -versionOnUpdate: version);\n      return del;\n    }\n\n    AddUpdateCommand cmd = new AddUpdateCommand(req);\n    cmd.solrDoc = leaderDoc;\n    cmd.setVersion((long)leaderDoc.getFieldValue(CommonParams.VERSION_FIELD));\n    return cmd;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"601f914e4448cab7640fecfb5d15f8f2e2af0bf6","date":1508947828,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#fetchFullUpdateFromLeader(AddUpdateCommand,long).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#fetchFullUpdateFromLeader(AddUpdateCommand,long).mjava","sourceNew":"  /**\n   * This method is used when an update on which a particular in-place update has been lost for some reason. This method\n   * sends a request to the shard leader to fetch the latest full document as seen on the leader.\n   * @return AddUpdateCommand containing latest full doc at shard leader for the given id, or null if not found.\n   */\n  private UpdateCommand fetchFullUpdateFromLeader(AddUpdateCommand inplaceAdd, long versionOnUpdate) throws IOException {\n    String id = inplaceAdd.getPrintableId();\n    UpdateShardHandler updateShardHandler = inplaceAdd.getReq().getCore().getCoreContainer().getUpdateShardHandler();\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(DISTRIB, false);\n    params.set(\"getInputDocument\", id);\n    params.set(\"onlyIfActive\", true);\n    SolrRequest<SimpleSolrResponse> ur = new GenericSolrRequest(METHOD.GET, \"/get\", params);\n\n    String leaderUrl = req.getParams().get(DISTRIB_FROM);\n    \n    if (leaderUrl == null) {\n      // An update we're dependent upon didn't arrive! This is unexpected. Perhaps likely our leader is\n      // down or partitioned from us for some reason. Lets force refresh cluster state, and request the\n      // leader for the update.\n      if (zkController == null) { // we should be in cloud mode, but wtf? could be a unit test\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Can't find document with id=\" + id + \", but fetching from leader \"\n            + \"failed since we're not in cloud mode.\");\n      }\n      Replica leader;\n      try {\n        leader = zkController.getZkStateReader().getLeaderRetry(cloudDesc.getCollectionName(), cloudDesc.getShardId());\n      } catch (InterruptedException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Exception during fetching from leader.\", e);\n      }\n      leaderUrl = leader.getCoreUrl();\n    }\n\n    NamedList<Object> rsp = null;\n    try (HttpSolrClient hsc = new HttpSolrClient.Builder(leaderUrl).\n        withHttpClient(updateShardHandler.getHttpClient()).build()) {\n      rsp = hsc.request(ur);\n    } catch (SolrServerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during fetching [\" + id +\n          \"] from leader (\" + leaderUrl + \"): \", e);\n    }\n    Object inputDocObj = rsp.get(\"inputDocument\");\n    Long version = (Long)rsp.get(\"version\");\n    SolrInputDocument leaderDoc = (SolrInputDocument) inputDocObj;\n\n    if (leaderDoc == null) {\n      // this doc was not found (deleted) on the leader. Lets delete it here as well.\n      DeleteUpdateCommand del = new DeleteUpdateCommand(inplaceAdd.getReq());\n      del.setIndexedId(inplaceAdd.getIndexedId());\n      del.setId(inplaceAdd.getIndexedId().utf8ToString());\n      del.setVersion((version == null || version == 0)? -versionOnUpdate: version);\n      return del;\n    }\n\n    AddUpdateCommand cmd = new AddUpdateCommand(req);\n    cmd.solrDoc = leaderDoc;\n    cmd.setVersion((long)leaderDoc.getFieldValue(CommonParams.VERSION_FIELD));\n    return cmd;\n  }\n\n","sourceOld":"  /**\n   * This method is used when an update on which a particular in-place update has been lost for some reason. This method\n   * sends a request to the shard leader to fetch the latest full document as seen on the leader.\n   * @return AddUpdateCommand containing latest full doc at shard leader for the given id, or null if not found.\n   */\n  private UpdateCommand fetchFullUpdateFromLeader(AddUpdateCommand inplaceAdd, long versionOnUpdate) throws IOException {\n    String id = inplaceAdd.getPrintableId();\n    UpdateShardHandler updateShardHandler = inplaceAdd.getReq().getCore().getCoreContainer().getUpdateShardHandler();\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(DISTRIB, false);\n    params.set(\"getInputDocument\", id);\n    params.set(\"onlyIfActive\", true);\n    SolrRequest<SimpleSolrResponse> ur = new GenericSolrRequest(METHOD.GET, \"/get\", params);\n\n    String leaderUrl = req.getParams().get(DISTRIB_FROM);\n    \n    if (leaderUrl == null) {\n      // An update we're dependent upon didn't arrive! This is unexpected. Perhaps likely our leader is\n      // down or partitioned from us for some reason. Lets force refresh cluster state, and request the\n      // leader for the update.\n      if (zkController == null) { // we should be in cloud mode, but wtf? could be a unit test\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Can't find document with id=\" + id + \", but fetching from leader \"\n            + \"failed since we're not in cloud mode.\");\n      }\n      Replica leader;\n      try {\n        leader = zkController.getZkStateReader().getLeaderRetry(cloudDesc.getCollectionName(), cloudDesc.getShardId());\n      } catch (InterruptedException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Exception during fetching from leader.\", e);\n      }\n      leaderUrl = leader.getCoreUrl();\n    }\n    \n    HttpSolrClient hsc = new HttpSolrClient.Builder(leaderUrl).\n        withHttpClient(updateShardHandler.getHttpClient()).build();\n    NamedList rsp = null;\n    try {\n      rsp = hsc.request(ur);\n    } catch (SolrServerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during fetching [\" + id +\n          \"] from leader (\" + leaderUrl + \"): \", e);\n    } finally {\n      hsc.close();\n    }\n    Object inputDocObj = rsp.get(\"inputDocument\");\n    Long version = (Long)rsp.get(\"version\");\n    SolrInputDocument leaderDoc = (SolrInputDocument) inputDocObj;\n\n    if (leaderDoc == null) {\n      // this doc was not found (deleted) on the leader. Lets delete it here as well.\n      DeleteUpdateCommand del = new DeleteUpdateCommand(inplaceAdd.getReq());\n      del.setIndexedId(inplaceAdd.getIndexedId());\n      del.setId(inplaceAdd.getIndexedId().utf8ToString());\n      del.setVersion((version == null || version == 0)? -versionOnUpdate: version);\n      return del;\n    }\n\n    AddUpdateCommand cmd = new AddUpdateCommand(req);\n    cmd.solrDoc = leaderDoc;\n    cmd.setVersion((long)leaderDoc.getFieldValue(CommonParams.VERSION_FIELD));\n    return cmd;\n  }\n\n","bugFix":null,"bugIntro":["3646ead588297558973dbd1162e69791e822b944"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad55ff45b3a5483090d87a63019d0e6a8d4b5a65","date":1509551229,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#fetchFullUpdateFromLeader(AddUpdateCommand,long).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#fetchFullUpdateFromLeader(AddUpdateCommand,long).mjava","sourceNew":"  /**\n   * This method is used when an update on which a particular in-place update has been lost for some reason. This method\n   * sends a request to the shard leader to fetch the latest full document as seen on the leader.\n   * @return AddUpdateCommand containing latest full doc at shard leader for the given id, or null if not found.\n   */\n  private UpdateCommand fetchFullUpdateFromLeader(AddUpdateCommand inplaceAdd, long versionOnUpdate) throws IOException {\n    String id = inplaceAdd.getPrintableId();\n    UpdateShardHandler updateShardHandler = inplaceAdd.getReq().getCore().getCoreContainer().getUpdateShardHandler();\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(DISTRIB, false);\n    params.set(\"getInputDocument\", id);\n    params.set(\"onlyIfActive\", true);\n    SolrRequest<SimpleSolrResponse> ur = new GenericSolrRequest(METHOD.GET, \"/get\", params);\n\n    String leaderUrl = req.getParams().get(DISTRIB_FROM);\n    \n    if (leaderUrl == null) {\n      // An update we're dependent upon didn't arrive! This is unexpected. Perhaps likely our leader is\n      // down or partitioned from us for some reason. Lets force refresh cluster state, and request the\n      // leader for the update.\n      if (zkController == null) { // we should be in cloud mode, but wtf? could be a unit test\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Can't find document with id=\" + id + \", but fetching from leader \"\n            + \"failed since we're not in cloud mode.\");\n      }\n      Replica leader;\n      try {\n        leader = zkController.getZkStateReader().getLeaderRetry(collection, cloudDesc.getShardId());\n      } catch (InterruptedException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Exception during fetching from leader.\", e);\n      }\n      leaderUrl = leader.getCoreUrl();\n    }\n\n    NamedList<Object> rsp = null;\n    try (HttpSolrClient hsc = new HttpSolrClient.Builder(leaderUrl).\n        withHttpClient(updateShardHandler.getHttpClient()).build()) {\n      rsp = hsc.request(ur);\n    } catch (SolrServerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during fetching [\" + id +\n          \"] from leader (\" + leaderUrl + \"): \", e);\n    }\n    Object inputDocObj = rsp.get(\"inputDocument\");\n    Long version = (Long)rsp.get(\"version\");\n    SolrInputDocument leaderDoc = (SolrInputDocument) inputDocObj;\n\n    if (leaderDoc == null) {\n      // this doc was not found (deleted) on the leader. Lets delete it here as well.\n      DeleteUpdateCommand del = new DeleteUpdateCommand(inplaceAdd.getReq());\n      del.setIndexedId(inplaceAdd.getIndexedId());\n      del.setId(inplaceAdd.getIndexedId().utf8ToString());\n      del.setVersion((version == null || version == 0)? -versionOnUpdate: version);\n      return del;\n    }\n\n    AddUpdateCommand cmd = new AddUpdateCommand(req);\n    cmd.solrDoc = leaderDoc;\n    cmd.setVersion((long)leaderDoc.getFieldValue(CommonParams.VERSION_FIELD));\n    return cmd;\n  }\n\n","sourceOld":"  /**\n   * This method is used when an update on which a particular in-place update has been lost for some reason. This method\n   * sends a request to the shard leader to fetch the latest full document as seen on the leader.\n   * @return AddUpdateCommand containing latest full doc at shard leader for the given id, or null if not found.\n   */\n  private UpdateCommand fetchFullUpdateFromLeader(AddUpdateCommand inplaceAdd, long versionOnUpdate) throws IOException {\n    String id = inplaceAdd.getPrintableId();\n    UpdateShardHandler updateShardHandler = inplaceAdd.getReq().getCore().getCoreContainer().getUpdateShardHandler();\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(DISTRIB, false);\n    params.set(\"getInputDocument\", id);\n    params.set(\"onlyIfActive\", true);\n    SolrRequest<SimpleSolrResponse> ur = new GenericSolrRequest(METHOD.GET, \"/get\", params);\n\n    String leaderUrl = req.getParams().get(DISTRIB_FROM);\n    \n    if (leaderUrl == null) {\n      // An update we're dependent upon didn't arrive! This is unexpected. Perhaps likely our leader is\n      // down or partitioned from us for some reason. Lets force refresh cluster state, and request the\n      // leader for the update.\n      if (zkController == null) { // we should be in cloud mode, but wtf? could be a unit test\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Can't find document with id=\" + id + \", but fetching from leader \"\n            + \"failed since we're not in cloud mode.\");\n      }\n      Replica leader;\n      try {\n        leader = zkController.getZkStateReader().getLeaderRetry(cloudDesc.getCollectionName(), cloudDesc.getShardId());\n      } catch (InterruptedException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Exception during fetching from leader.\", e);\n      }\n      leaderUrl = leader.getCoreUrl();\n    }\n\n    NamedList<Object> rsp = null;\n    try (HttpSolrClient hsc = new HttpSolrClient.Builder(leaderUrl).\n        withHttpClient(updateShardHandler.getHttpClient()).build()) {\n      rsp = hsc.request(ur);\n    } catch (SolrServerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during fetching [\" + id +\n          \"] from leader (\" + leaderUrl + \"): \", e);\n    }\n    Object inputDocObj = rsp.get(\"inputDocument\");\n    Long version = (Long)rsp.get(\"version\");\n    SolrInputDocument leaderDoc = (SolrInputDocument) inputDocObj;\n\n    if (leaderDoc == null) {\n      // this doc was not found (deleted) on the leader. Lets delete it here as well.\n      DeleteUpdateCommand del = new DeleteUpdateCommand(inplaceAdd.getReq());\n      del.setIndexedId(inplaceAdd.getIndexedId());\n      del.setId(inplaceAdd.getIndexedId().utf8ToString());\n      del.setVersion((version == null || version == 0)? -versionOnUpdate: version);\n      return del;\n    }\n\n    AddUpdateCommand cmd = new AddUpdateCommand(req);\n    cmd.solrDoc = leaderDoc;\n    cmd.setVersion((long)leaderDoc.getFieldValue(CommonParams.VERSION_FIELD));\n    return cmd;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3646ead588297558973dbd1162e69791e822b944","date":1525482176,"type":3,"author":"Mark Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#fetchFullUpdateFromLeader(AddUpdateCommand,long).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#fetchFullUpdateFromLeader(AddUpdateCommand,long).mjava","sourceNew":"  /**\n   * This method is used when an update on which a particular in-place update has been lost for some reason. This method\n   * sends a request to the shard leader to fetch the latest full document as seen on the leader.\n   * @return AddUpdateCommand containing latest full doc at shard leader for the given id, or null if not found.\n   */\n  private UpdateCommand fetchFullUpdateFromLeader(AddUpdateCommand inplaceAdd, long versionOnUpdate) throws IOException {\n    String id = inplaceAdd.getPrintableId();\n    UpdateShardHandler updateShardHandler = inplaceAdd.getReq().getCore().getCoreContainer().getUpdateShardHandler();\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(DISTRIB, false);\n    params.set(\"getInputDocument\", id);\n    params.set(\"onlyIfActive\", true);\n    SolrRequest<SimpleSolrResponse> ur = new GenericSolrRequest(METHOD.GET, \"/get\", params);\n\n    String leaderUrl = req.getParams().get(DISTRIB_FROM);\n    \n    if (leaderUrl == null) {\n      // An update we're dependent upon didn't arrive! This is unexpected. Perhaps likely our leader is\n      // down or partitioned from us for some reason. Lets force refresh cluster state, and request the\n      // leader for the update.\n      if (zkController == null) { // we should be in cloud mode, but wtf? could be a unit test\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Can't find document with id=\" + id + \", but fetching from leader \"\n            + \"failed since we're not in cloud mode.\");\n      }\n      Replica leader;\n      try {\n        leader = zkController.getZkStateReader().getLeaderRetry(collection, cloudDesc.getShardId());\n      } catch (InterruptedException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Exception during fetching from leader.\", e);\n      }\n      leaderUrl = leader.getCoreUrl();\n    }\n\n    NamedList<Object> rsp = null;\n    try (HttpSolrClient hsc = new HttpSolrClient.Builder(leaderUrl).\n        withHttpClient(updateShardHandler.getUpdateOnlyHttpClient()).build()) {\n      rsp = hsc.request(ur);\n    } catch (SolrServerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during fetching [\" + id +\n          \"] from leader (\" + leaderUrl + \"): \", e);\n    }\n    Object inputDocObj = rsp.get(\"inputDocument\");\n    Long version = (Long)rsp.get(\"version\");\n    SolrInputDocument leaderDoc = (SolrInputDocument) inputDocObj;\n\n    if (leaderDoc == null) {\n      // this doc was not found (deleted) on the leader. Lets delete it here as well.\n      DeleteUpdateCommand del = new DeleteUpdateCommand(inplaceAdd.getReq());\n      del.setIndexedId(inplaceAdd.getIndexedId());\n      del.setId(inplaceAdd.getIndexedId().utf8ToString());\n      del.setVersion((version == null || version == 0)? -versionOnUpdate: version);\n      return del;\n    }\n\n    AddUpdateCommand cmd = new AddUpdateCommand(req);\n    cmd.solrDoc = leaderDoc;\n    cmd.setVersion((long)leaderDoc.getFieldValue(CommonParams.VERSION_FIELD));\n    return cmd;\n  }\n\n","sourceOld":"  /**\n   * This method is used when an update on which a particular in-place update has been lost for some reason. This method\n   * sends a request to the shard leader to fetch the latest full document as seen on the leader.\n   * @return AddUpdateCommand containing latest full doc at shard leader for the given id, or null if not found.\n   */\n  private UpdateCommand fetchFullUpdateFromLeader(AddUpdateCommand inplaceAdd, long versionOnUpdate) throws IOException {\n    String id = inplaceAdd.getPrintableId();\n    UpdateShardHandler updateShardHandler = inplaceAdd.getReq().getCore().getCoreContainer().getUpdateShardHandler();\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(DISTRIB, false);\n    params.set(\"getInputDocument\", id);\n    params.set(\"onlyIfActive\", true);\n    SolrRequest<SimpleSolrResponse> ur = new GenericSolrRequest(METHOD.GET, \"/get\", params);\n\n    String leaderUrl = req.getParams().get(DISTRIB_FROM);\n    \n    if (leaderUrl == null) {\n      // An update we're dependent upon didn't arrive! This is unexpected. Perhaps likely our leader is\n      // down or partitioned from us for some reason. Lets force refresh cluster state, and request the\n      // leader for the update.\n      if (zkController == null) { // we should be in cloud mode, but wtf? could be a unit test\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Can't find document with id=\" + id + \", but fetching from leader \"\n            + \"failed since we're not in cloud mode.\");\n      }\n      Replica leader;\n      try {\n        leader = zkController.getZkStateReader().getLeaderRetry(collection, cloudDesc.getShardId());\n      } catch (InterruptedException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Exception during fetching from leader.\", e);\n      }\n      leaderUrl = leader.getCoreUrl();\n    }\n\n    NamedList<Object> rsp = null;\n    try (HttpSolrClient hsc = new HttpSolrClient.Builder(leaderUrl).\n        withHttpClient(updateShardHandler.getHttpClient()).build()) {\n      rsp = hsc.request(ur);\n    } catch (SolrServerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during fetching [\" + id +\n          \"] from leader (\" + leaderUrl + \"): \", e);\n    }\n    Object inputDocObj = rsp.get(\"inputDocument\");\n    Long version = (Long)rsp.get(\"version\");\n    SolrInputDocument leaderDoc = (SolrInputDocument) inputDocObj;\n\n    if (leaderDoc == null) {\n      // this doc was not found (deleted) on the leader. Lets delete it here as well.\n      DeleteUpdateCommand del = new DeleteUpdateCommand(inplaceAdd.getReq());\n      del.setIndexedId(inplaceAdd.getIndexedId());\n      del.setId(inplaceAdd.getIndexedId().utf8ToString());\n      del.setVersion((version == null || version == 0)? -versionOnUpdate: version);\n      return del;\n    }\n\n    AddUpdateCommand cmd = new AddUpdateCommand(req);\n    cmd.solrDoc = leaderDoc;\n    cmd.setVersion((long)leaderDoc.getFieldValue(CommonParams.VERSION_FIELD));\n    return cmd;\n  }\n\n","bugFix":["601f914e4448cab7640fecfb5d15f8f2e2af0bf6"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1a77e5e21cbd575a8240b0e3926164f15295f4e8","date":1544979500,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#fetchFullUpdateFromLeader(AddUpdateCommand,long).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#fetchFullUpdateFromLeader(AddUpdateCommand,long).mjava","sourceNew":"  /**\n   * This method is used when an update on which a particular in-place update has been lost for some reason. This method\n   * sends a request to the shard leader to fetch the latest full document as seen on the leader.\n   * @return AddUpdateCommand containing latest full doc at shard leader for the given id, or null if not found.\n   */\n  private UpdateCommand fetchFullUpdateFromLeader(AddUpdateCommand inplaceAdd, long versionOnUpdate) throws IOException {\n    String id = inplaceAdd.getPrintableId();\n    UpdateShardHandler updateShardHandler = inplaceAdd.getReq().getCore().getCoreContainer().getUpdateShardHandler();\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(DISTRIB, false);\n    params.set(\"getInputDocument\", id);\n    params.set(\"onlyIfActive\", true);\n    SolrRequest<SimpleSolrResponse> ur = new GenericSolrRequest(METHOD.GET, \"/get\", params);\n\n    String leaderUrl = req.getParams().get(DISTRIB_FROM);\n    \n    if (leaderUrl == null) {\n      // An update we're dependent upon didn't arrive! This is unexpected. Perhaps likely our leader is\n      // down or partitioned from us for some reason. Lets force refresh cluster state, and request the\n      // leader for the update.\n      if (zkController == null) { // we should be in cloud mode, but wtf? could be a unit test\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Can't find document with id=\" + id + \", but fetching from leader \"\n            + \"failed since we're not in cloud mode.\");\n      }\n      Replica leader;\n      try {\n        leader = zkController.getZkStateReader().getLeaderRetry(collection, cloudDesc.getShardId());\n      } catch (InterruptedException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Exception during fetching from leader.\", e);\n      }\n      leaderUrl = leader.getCoreUrl();\n    }\n\n    NamedList<Object> rsp;\n    try {\n      ur.setBasePath(leaderUrl);\n      rsp = updateShardHandler.getUpdateOnlyHttpClient().request(ur);\n    } catch (SolrServerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during fetching [\" + id +\n          \"] from leader (\" + leaderUrl + \"): \", e);\n    }\n    Object inputDocObj = rsp.get(\"inputDocument\");\n    Long version = (Long)rsp.get(\"version\");\n    SolrInputDocument leaderDoc = (SolrInputDocument) inputDocObj;\n\n    if (leaderDoc == null) {\n      // this doc was not found (deleted) on the leader. Lets delete it here as well.\n      DeleteUpdateCommand del = new DeleteUpdateCommand(inplaceAdd.getReq());\n      del.setIndexedId(inplaceAdd.getIndexedId());\n      del.setId(inplaceAdd.getIndexedId().utf8ToString());\n      del.setVersion((version == null || version == 0)? -versionOnUpdate: version);\n      return del;\n    }\n\n    AddUpdateCommand cmd = new AddUpdateCommand(req);\n    cmd.solrDoc = leaderDoc;\n    cmd.setVersion((long)leaderDoc.getFieldValue(CommonParams.VERSION_FIELD));\n    return cmd;\n  }\n\n","sourceOld":"  /**\n   * This method is used when an update on which a particular in-place update has been lost for some reason. This method\n   * sends a request to the shard leader to fetch the latest full document as seen on the leader.\n   * @return AddUpdateCommand containing latest full doc at shard leader for the given id, or null if not found.\n   */\n  private UpdateCommand fetchFullUpdateFromLeader(AddUpdateCommand inplaceAdd, long versionOnUpdate) throws IOException {\n    String id = inplaceAdd.getPrintableId();\n    UpdateShardHandler updateShardHandler = inplaceAdd.getReq().getCore().getCoreContainer().getUpdateShardHandler();\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(DISTRIB, false);\n    params.set(\"getInputDocument\", id);\n    params.set(\"onlyIfActive\", true);\n    SolrRequest<SimpleSolrResponse> ur = new GenericSolrRequest(METHOD.GET, \"/get\", params);\n\n    String leaderUrl = req.getParams().get(DISTRIB_FROM);\n    \n    if (leaderUrl == null) {\n      // An update we're dependent upon didn't arrive! This is unexpected. Perhaps likely our leader is\n      // down or partitioned from us for some reason. Lets force refresh cluster state, and request the\n      // leader for the update.\n      if (zkController == null) { // we should be in cloud mode, but wtf? could be a unit test\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Can't find document with id=\" + id + \", but fetching from leader \"\n            + \"failed since we're not in cloud mode.\");\n      }\n      Replica leader;\n      try {\n        leader = zkController.getZkStateReader().getLeaderRetry(collection, cloudDesc.getShardId());\n      } catch (InterruptedException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Exception during fetching from leader.\", e);\n      }\n      leaderUrl = leader.getCoreUrl();\n    }\n\n    NamedList<Object> rsp = null;\n    try (HttpSolrClient hsc = new HttpSolrClient.Builder(leaderUrl).\n        withHttpClient(updateShardHandler.getUpdateOnlyHttpClient()).build()) {\n      rsp = hsc.request(ur);\n    } catch (SolrServerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during fetching [\" + id +\n          \"] from leader (\" + leaderUrl + \"): \", e);\n    }\n    Object inputDocObj = rsp.get(\"inputDocument\");\n    Long version = (Long)rsp.get(\"version\");\n    SolrInputDocument leaderDoc = (SolrInputDocument) inputDocObj;\n\n    if (leaderDoc == null) {\n      // this doc was not found (deleted) on the leader. Lets delete it here as well.\n      DeleteUpdateCommand del = new DeleteUpdateCommand(inplaceAdd.getReq());\n      del.setIndexedId(inplaceAdd.getIndexedId());\n      del.setId(inplaceAdd.getIndexedId().utf8ToString());\n      del.setVersion((version == null || version == 0)? -versionOnUpdate: version);\n      return del;\n    }\n\n    AddUpdateCommand cmd = new AddUpdateCommand(req);\n    cmd.solrDoc = leaderDoc;\n    cmd.setVersion((long)leaderDoc.getFieldValue(CommonParams.VERSION_FIELD));\n    return cmd;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9d70e774cb25c8a8d2c3e5e84200f235f9168d87","date":1553016391,"type":3,"author":"Bar Rotstein","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#fetchFullUpdateFromLeader(AddUpdateCommand,long).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#fetchFullUpdateFromLeader(AddUpdateCommand,long).mjava","sourceNew":"  /**\n   * This method is used when an update on which a particular in-place update has been lost for some reason. This method\n   * sends a request to the shard leader to fetch the latest full document as seen on the leader.\n   * @return AddUpdateCommand containing latest full doc at shard leader for the given id, or null if not found.\n   */\n  private UpdateCommand fetchFullUpdateFromLeader(AddUpdateCommand inplaceAdd, long versionOnUpdate) throws IOException {\n    String id = inplaceAdd.getPrintableId();\n    UpdateShardHandler updateShardHandler = inplaceAdd.getReq().getCore().getCoreContainer().getUpdateShardHandler();\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(DISTRIB, false);\n    params.set(\"getInputDocument\", id);\n    params.set(\"onlyIfActive\", true);\n    SolrRequest<SimpleSolrResponse> ur = new GenericSolrRequest(METHOD.GET, \"/get\", params);\n\n    String leaderUrl = getLeaderUrl(id);\n\n    if(leaderUrl == null) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Can't find document with id=\" + id);\n    }\n\n    NamedList<Object> rsp;\n    try {\n      ur.setBasePath(leaderUrl);\n      rsp = updateShardHandler.getUpdateOnlyHttpClient().request(ur);\n    } catch (SolrServerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during fetching [\" + id +\n          \"] from leader (\" + leaderUrl + \"): \", e);\n    }\n    Object inputDocObj = rsp.get(\"inputDocument\");\n    Long version = (Long)rsp.get(\"version\");\n    SolrInputDocument leaderDoc = (SolrInputDocument) inputDocObj;\n\n    if (leaderDoc == null) {\n      // this doc was not found (deleted) on the leader. Lets delete it here as well.\n      DeleteUpdateCommand del = new DeleteUpdateCommand(inplaceAdd.getReq());\n      del.setIndexedId(inplaceAdd.getIndexedId());\n      del.setId(inplaceAdd.getIndexedId().utf8ToString());\n      del.setVersion((version == null || version == 0)? -versionOnUpdate: version);\n      return del;\n    }\n\n    AddUpdateCommand cmd = new AddUpdateCommand(req);\n    cmd.solrDoc = leaderDoc;\n    cmd.setVersion((long)leaderDoc.getFieldValue(CommonParams.VERSION_FIELD));\n    return cmd;\n  }\n\n","sourceOld":"  /**\n   * This method is used when an update on which a particular in-place update has been lost for some reason. This method\n   * sends a request to the shard leader to fetch the latest full document as seen on the leader.\n   * @return AddUpdateCommand containing latest full doc at shard leader for the given id, or null if not found.\n   */\n  private UpdateCommand fetchFullUpdateFromLeader(AddUpdateCommand inplaceAdd, long versionOnUpdate) throws IOException {\n    String id = inplaceAdd.getPrintableId();\n    UpdateShardHandler updateShardHandler = inplaceAdd.getReq().getCore().getCoreContainer().getUpdateShardHandler();\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(DISTRIB, false);\n    params.set(\"getInputDocument\", id);\n    params.set(\"onlyIfActive\", true);\n    SolrRequest<SimpleSolrResponse> ur = new GenericSolrRequest(METHOD.GET, \"/get\", params);\n\n    String leaderUrl = req.getParams().get(DISTRIB_FROM);\n    \n    if (leaderUrl == null) {\n      // An update we're dependent upon didn't arrive! This is unexpected. Perhaps likely our leader is\n      // down or partitioned from us for some reason. Lets force refresh cluster state, and request the\n      // leader for the update.\n      if (zkController == null) { // we should be in cloud mode, but wtf? could be a unit test\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Can't find document with id=\" + id + \", but fetching from leader \"\n            + \"failed since we're not in cloud mode.\");\n      }\n      Replica leader;\n      try {\n        leader = zkController.getZkStateReader().getLeaderRetry(collection, cloudDesc.getShardId());\n      } catch (InterruptedException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Exception during fetching from leader.\", e);\n      }\n      leaderUrl = leader.getCoreUrl();\n    }\n\n    NamedList<Object> rsp;\n    try {\n      ur.setBasePath(leaderUrl);\n      rsp = updateShardHandler.getUpdateOnlyHttpClient().request(ur);\n    } catch (SolrServerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during fetching [\" + id +\n          \"] from leader (\" + leaderUrl + \"): \", e);\n    }\n    Object inputDocObj = rsp.get(\"inputDocument\");\n    Long version = (Long)rsp.get(\"version\");\n    SolrInputDocument leaderDoc = (SolrInputDocument) inputDocObj;\n\n    if (leaderDoc == null) {\n      // this doc was not found (deleted) on the leader. Lets delete it here as well.\n      DeleteUpdateCommand del = new DeleteUpdateCommand(inplaceAdd.getReq());\n      del.setIndexedId(inplaceAdd.getIndexedId());\n      del.setId(inplaceAdd.getIndexedId().utf8ToString());\n      del.setVersion((version == null || version == 0)? -versionOnUpdate: version);\n      return del;\n    }\n\n    AddUpdateCommand cmd = new AddUpdateCommand(req);\n    cmd.solrDoc = leaderDoc;\n    cmd.setVersion((long)leaderDoc.getFieldValue(CommonParams.VERSION_FIELD));\n    return cmd;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"415bbbe7da8065dd3c477bdc3c703c6425622998":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["6f4c5d3859373c3a74734e85efa122b17514e3e8"],"598b5d23aa7c9732bf473c21a9cd309c44599394":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","415bbbe7da8065dd3c477bdc3c703c6425622998"],"ad55ff45b3a5483090d87a63019d0e6a8d4b5a65":["601f914e4448cab7640fecfb5d15f8f2e2af0bf6"],"6d2dadc1f5ca8703d8659f4964961f9967935d75":["415bbbe7da8065dd3c477bdc3c703c6425622998"],"6f4c5d3859373c3a74734e85efa122b17514e3e8":["e5fa6615014cd2288fe930f8c8bb726f9504961d"],"729cb470f975115d4c60517b2cb7c42e37a7a2e1":["01624b85de12fb02335810bdf325124e59040772"],"01624b85de12fb02335810bdf325124e59040772":["6d2dadc1f5ca8703d8659f4964961f9967935d75"],"e5fa6615014cd2288fe930f8c8bb726f9504961d":["415bbbe7da8065dd3c477bdc3c703c6425622998"],"1a77e5e21cbd575a8240b0e3926164f15295f4e8":["3646ead588297558973dbd1162e69791e822b944"],"601f914e4448cab7640fecfb5d15f8f2e2af0bf6":["729cb470f975115d4c60517b2cb7c42e37a7a2e1"],"3646ead588297558973dbd1162e69791e822b944":["ad55ff45b3a5483090d87a63019d0e6a8d4b5a65"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9d70e774cb25c8a8d2c3e5e84200f235f9168d87":["1a77e5e21cbd575a8240b0e3926164f15295f4e8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9d70e774cb25c8a8d2c3e5e84200f235f9168d87"]},"commit2Childs":{"415bbbe7da8065dd3c477bdc3c703c6425622998":["598b5d23aa7c9732bf473c21a9cd309c44599394","6d2dadc1f5ca8703d8659f4964961f9967935d75","e5fa6615014cd2288fe930f8c8bb726f9504961d"],"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":[],"598b5d23aa7c9732bf473c21a9cd309c44599394":[],"ad55ff45b3a5483090d87a63019d0e6a8d4b5a65":["3646ead588297558973dbd1162e69791e822b944"],"6d2dadc1f5ca8703d8659f4964961f9967935d75":["01624b85de12fb02335810bdf325124e59040772"],"6f4c5d3859373c3a74734e85efa122b17514e3e8":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb"],"729cb470f975115d4c60517b2cb7c42e37a7a2e1":["601f914e4448cab7640fecfb5d15f8f2e2af0bf6"],"01624b85de12fb02335810bdf325124e59040772":["729cb470f975115d4c60517b2cb7c42e37a7a2e1"],"e5fa6615014cd2288fe930f8c8bb726f9504961d":["6f4c5d3859373c3a74734e85efa122b17514e3e8"],"1a77e5e21cbd575a8240b0e3926164f15295f4e8":["9d70e774cb25c8a8d2c3e5e84200f235f9168d87"],"601f914e4448cab7640fecfb5d15f8f2e2af0bf6":["ad55ff45b3a5483090d87a63019d0e6a8d4b5a65"],"3646ead588297558973dbd1162e69791e822b944":["1a77e5e21cbd575a8240b0e3926164f15295f4e8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["415bbbe7da8065dd3c477bdc3c703c6425622998","598b5d23aa7c9732bf473c21a9cd309c44599394"],"9d70e774cb25c8a8d2c3e5e84200f235f9168d87":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","598b5d23aa7c9732bf473c21a9cd309c44599394","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}