{"path":"lucene/contrib/misc/src/java/org/apache/lucene/search/SearcherManager#maybeReopen().mjava","commits":[{"id":"edcc2c2cbab6bf89ea584169ffb3ca83a31827f9","date":1316963893,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/contrib/misc/src/java/org/apache/lucene/search/SearcherManager#maybeReopen().mjava","pathOld":"/dev/null","sourceNew":"  /** You must call this, periodically, to perform a\n   *  reopen.  This calls {@link IndexReader#reopen} on the\n   *  underlying reader, and if that returns a new reader,\n   *  it's warmed (if you provided a {@link SearcherWarmer}\n   *  and then swapped into production.\n   *\n   *  <p><b>Threads</b>: it's fine for more than one thread to\n   *  call this at once.  Only the first thread will attempt\n   *  the reopen; subsequent threads will see that another\n   *  thread is already handling reopen and will return\n   *  immediately.  Note that this means if another thread\n   *  is already reopening then subsequent threads will\n   *  return right away without waiting for the reader\n   *  reopen to complete.</p>\n   *\n   *  <p>This method returns true if a new reader was in\n   *  fact opened.</p>\n   */\n  public boolean maybeReopen()\n    throws  IOException {\n\n    if (currentSearcher == null) {\n      throw new AlreadyClosedException(\"this SearcherManager is closed\");\n    }\n\n    // Ensure only 1 thread does reopen at once; other\n    // threads just return immediately:\n    if (!reopening.getAndSet(true)) {\n      try {\n        IndexReader newReader = currentSearcher.getIndexReader().reopen();\n        if (newReader != currentSearcher.getIndexReader()) {\n          IndexSearcher newSearcher = new IndexSearcher(newReader, es);\n          if (warmer != null) {\n            warmer.warm(newSearcher);\n          }\n          swapSearcher(newSearcher);\n          return true;\n        } else {\n          return false;\n        }\n      } finally {\n        reopening.set(false);\n      }\n    } else {\n      return false;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["76364fe9e16e51702b00a59a9ae3ed0646080deb","4df4116ba247711222d5e70863dd14459e41e27c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"576017a3864f5d8d12be8dc6b7b47dd9c41cc08d","date":1317143951,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/contrib/misc/src/java/org/apache/lucene/search/SearcherManager#maybeReopen().mjava","pathOld":"lucene/contrib/misc/src/java/org/apache/lucene/search/SearcherManager#maybeReopen().mjava","sourceNew":"  /** You must call this, periodically, to perform a\n   *  reopen.  This calls {@link IndexReader#reopen} on the\n   *  underlying reader, and if that returns a new reader,\n   *  it's warmed (if you provided a {@link SearcherWarmer}\n   *  and then swapped into production.\n   *\n   *  <p><b>Threads</b>: it's fine for more than one thread to\n   *  call this at once.  Only the first thread will attempt\n   *  the reopen; subsequent threads will see that another\n   *  thread is already handling reopen and will return\n   *  immediately.  Note that this means if another thread\n   *  is already reopening then subsequent threads will\n   *  return right away without waiting for the reader\n   *  reopen to complete.</p>\n   *\n   *  <p>This method returns true if a new reader was in\n   *  fact opened.</p>\n   */\n  public boolean maybeReopen()\n    throws  IOException {\n\n    if (currentSearcher == null) {\n      throw new AlreadyClosedException(\"this SearcherManager is closed\");\n    }\n\n    // Ensure only 1 thread does reopen at once; other\n    // threads just return immediately:\n    if (!reopening.getAndSet(true)) {\n      try {\n        IndexReader newReader = currentSearcher.getIndexReader().reopen();\n        if (newReader != currentSearcher.getIndexReader()) {\n          IndexSearcher newSearcher = new IndexSearcher(newReader, es);\n          if (warmer != null) {\n            boolean success = false;\n            try {\n              warmer.warm(newSearcher);\n              success = true;\n            } finally {\n              if (!success) {\n                newReader.decRef();\n              }\n            }\n          }\n          swapSearcher(newSearcher);\n          return true;\n        } else {\n          return false;\n        }\n      } finally {\n        reopening.set(false);\n      }\n    } else {\n      return false;\n    }\n  }\n\n","sourceOld":"  /** You must call this, periodically, to perform a\n   *  reopen.  This calls {@link IndexReader#reopen} on the\n   *  underlying reader, and if that returns a new reader,\n   *  it's warmed (if you provided a {@link SearcherWarmer}\n   *  and then swapped into production.\n   *\n   *  <p><b>Threads</b>: it's fine for more than one thread to\n   *  call this at once.  Only the first thread will attempt\n   *  the reopen; subsequent threads will see that another\n   *  thread is already handling reopen and will return\n   *  immediately.  Note that this means if another thread\n   *  is already reopening then subsequent threads will\n   *  return right away without waiting for the reader\n   *  reopen to complete.</p>\n   *\n   *  <p>This method returns true if a new reader was in\n   *  fact opened.</p>\n   */\n  public boolean maybeReopen()\n    throws  IOException {\n\n    if (currentSearcher == null) {\n      throw new AlreadyClosedException(\"this SearcherManager is closed\");\n    }\n\n    // Ensure only 1 thread does reopen at once; other\n    // threads just return immediately:\n    if (!reopening.getAndSet(true)) {\n      try {\n        IndexReader newReader = currentSearcher.getIndexReader().reopen();\n        if (newReader != currentSearcher.getIndexReader()) {\n          IndexSearcher newSearcher = new IndexSearcher(newReader, es);\n          if (warmer != null) {\n            warmer.warm(newSearcher);\n          }\n          swapSearcher(newSearcher);\n          return true;\n        } else {\n          return false;\n        }\n      } finally {\n        reopening.set(false);\n      }\n    } else {\n      return false;\n    }\n  }\n\n","bugFix":null,"bugIntro":["4df4116ba247711222d5e70863dd14459e41e27c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"abba29aa88f170f3d51899c885b760337dd1c47c","date":1317196921,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/contrib/misc/src/java/org/apache/lucene/search/SearcherManager#maybeReopen().mjava","pathOld":"lucene/contrib/misc/src/java/org/apache/lucene/search/SearcherManager#maybeReopen().mjava","sourceNew":"  /** You must call this, periodically, to perform a\n   *  reopen.  This calls {@link IndexReader#reopen} on the\n   *  underlying reader, and if that returns a new reader,\n   *  it's warmed (if you provided a {@link SearcherWarmer}\n   *  and then swapped into production.\n   *\n   *  <p><b>Threads</b>: it's fine for more than one thread to\n   *  call this at once.  Only the first thread will attempt\n   *  the reopen; subsequent threads will see that another\n   *  thread is already handling reopen and will return\n   *  immediately.  Note that this means if another thread\n   *  is already reopening then subsequent threads will\n   *  return right away without waiting for the reader\n   *  reopen to complete.</p>\n   *\n   *  <p>This method returns true if a new reader was in\n   *  fact opened.</p>\n   */\n  public boolean maybeReopen()\n    throws  IOException {\n\n    if (currentSearcher == null) {\n      throw new AlreadyClosedException(\"this SearcherManager is closed\");\n    }\n\n    // Ensure only 1 thread does reopen at once; other\n    // threads just return immediately:\n    if (reopening.tryAcquire()) {\n      try {\n        IndexReader newReader = currentSearcher.getIndexReader().reopen();\n        if (newReader != currentSearcher.getIndexReader()) {\n          IndexSearcher newSearcher = new IndexSearcher(newReader, es);\n          if (warmer != null) {\n            boolean success = false;\n            try {\n              warmer.warm(newSearcher);\n              success = true;\n            } finally {\n              if (!success) {\n                newReader.decRef();\n              }\n            }\n          }\n          swapSearcher(newSearcher);\n          return true;\n        } else {\n          return false;\n        }\n      } finally {\n        reopening.release();\n      }\n    } else {\n      return false;\n    }\n  }\n\n","sourceOld":"  /** You must call this, periodically, to perform a\n   *  reopen.  This calls {@link IndexReader#reopen} on the\n   *  underlying reader, and if that returns a new reader,\n   *  it's warmed (if you provided a {@link SearcherWarmer}\n   *  and then swapped into production.\n   *\n   *  <p><b>Threads</b>: it's fine for more than one thread to\n   *  call this at once.  Only the first thread will attempt\n   *  the reopen; subsequent threads will see that another\n   *  thread is already handling reopen and will return\n   *  immediately.  Note that this means if another thread\n   *  is already reopening then subsequent threads will\n   *  return right away without waiting for the reader\n   *  reopen to complete.</p>\n   *\n   *  <p>This method returns true if a new reader was in\n   *  fact opened.</p>\n   */\n  public boolean maybeReopen()\n    throws  IOException {\n\n    if (currentSearcher == null) {\n      throw new AlreadyClosedException(\"this SearcherManager is closed\");\n    }\n\n    // Ensure only 1 thread does reopen at once; other\n    // threads just return immediately:\n    if (!reopening.getAndSet(true)) {\n      try {\n        IndexReader newReader = currentSearcher.getIndexReader().reopen();\n        if (newReader != currentSearcher.getIndexReader()) {\n          IndexSearcher newSearcher = new IndexSearcher(newReader, es);\n          if (warmer != null) {\n            boolean success = false;\n            try {\n              warmer.warm(newSearcher);\n              success = true;\n            } finally {\n              if (!success) {\n                newReader.decRef();\n              }\n            }\n          }\n          swapSearcher(newSearcher);\n          return true;\n        } else {\n          return false;\n        }\n      } finally {\n        reopening.set(false);\n      }\n    } else {\n      return false;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"dfc6076b23c4069ed33fce21fd75a8ccfbf5019c","date":1317456621,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/contrib/misc/src/java/org/apache/lucene/search/SearcherManager#maybeReopen().mjava","pathOld":"lucene/contrib/misc/src/java/org/apache/lucene/search/SearcherManager#maybeReopen().mjava","sourceNew":"  /** You must call this, periodically, to perform a\n   *  reopen.  This calls {@link IndexReader#reopen} on the\n   *  underlying reader, and if that returns a new reader,\n   *  it's warmed (if you provided a {@link SearcherWarmer}\n   *  and then swapped into production.\n   *\n   *  <p><b>Threads</b>: it's fine for more than one thread to\n   *  call this at once.  Only the first thread will attempt\n   *  the reopen; subsequent threads will see that another\n   *  thread is already handling reopen and will return\n   *  immediately.  Note that this means if another thread\n   *  is already reopening then subsequent threads will\n   *  return right away without waiting for the reader\n   *  reopen to complete.</p>\n   *\n   *  <p>This method returns true if a new reader was in\n   *  fact opened.</p>\n   */\n  public boolean maybeReopen()\n    throws  IOException {\n\n    if (currentSearcher == null) {\n      throw new AlreadyClosedException(\"this SearcherManager is closed\");\n    }\n\n    // Ensure only 1 thread does reopen at once; other\n    // threads just return immediately:\n    if (reopening.tryAcquire()) {\n      try {\n        IndexReader newReader = currentSearcher.getIndexReader().reopen();\n        if (newReader != currentSearcher.getIndexReader()) {\n          IndexSearcher newSearcher = new IndexSearcher(newReader, es);\n          if (warmer != null) {\n            boolean success = false;\n            try {\n              warmer.warm(newSearcher);\n              success = true;\n            } finally {\n              if (!success) {\n                newReader.decRef();\n              }\n            }\n          }\n          boolean success = false;\n          try {\n            swapSearcher(newSearcher);\n            success = true;\n          } finally {\n            if (!success) {\n              release(newSearcher);\n            }\n          }\n          return true;\n        } else {\n          return false;\n        }\n      } finally {\n        reopening.release();\n      }\n    } else {\n      return false;\n    }\n  }\n\n","sourceOld":"  /** You must call this, periodically, to perform a\n   *  reopen.  This calls {@link IndexReader#reopen} on the\n   *  underlying reader, and if that returns a new reader,\n   *  it's warmed (if you provided a {@link SearcherWarmer}\n   *  and then swapped into production.\n   *\n   *  <p><b>Threads</b>: it's fine for more than one thread to\n   *  call this at once.  Only the first thread will attempt\n   *  the reopen; subsequent threads will see that another\n   *  thread is already handling reopen and will return\n   *  immediately.  Note that this means if another thread\n   *  is already reopening then subsequent threads will\n   *  return right away without waiting for the reader\n   *  reopen to complete.</p>\n   *\n   *  <p>This method returns true if a new reader was in\n   *  fact opened.</p>\n   */\n  public boolean maybeReopen()\n    throws  IOException {\n\n    if (currentSearcher == null) {\n      throw new AlreadyClosedException(\"this SearcherManager is closed\");\n    }\n\n    // Ensure only 1 thread does reopen at once; other\n    // threads just return immediately:\n    if (reopening.tryAcquire()) {\n      try {\n        IndexReader newReader = currentSearcher.getIndexReader().reopen();\n        if (newReader != currentSearcher.getIndexReader()) {\n          IndexSearcher newSearcher = new IndexSearcher(newReader, es);\n          if (warmer != null) {\n            boolean success = false;\n            try {\n              warmer.warm(newSearcher);\n              success = true;\n            } finally {\n              if (!success) {\n                newReader.decRef();\n              }\n            }\n          }\n          swapSearcher(newSearcher);\n          return true;\n        } else {\n          return false;\n        }\n      } finally {\n        reopening.release();\n      }\n    } else {\n      return false;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4df4116ba247711222d5e70863dd14459e41e27c","date":1317479977,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/contrib/misc/src/java/org/apache/lucene/search/SearcherManager#maybeReopen().mjava","pathOld":"lucene/contrib/misc/src/java/org/apache/lucene/search/SearcherManager#maybeReopen().mjava","sourceNew":"  /** You must call this, periodically, to perform a\n   *  reopen.  This calls {@link IndexReader#reopen} on the\n   *  underlying reader, and if that returns a new reader,\n   *  it's warmed (if you provided a {@link SearcherWarmer}\n   *  and then swapped into production.\n   *\n   *  <p><b>Threads</b>: it's fine for more than one thread to\n   *  call this at once.  Only the first thread will attempt\n   *  the reopen; subsequent threads will see that another\n   *  thread is already handling reopen and will return\n   *  immediately.  Note that this means if another thread\n   *  is already reopening then subsequent threads will\n   *  return right away without waiting for the reader\n   *  reopen to complete.</p>\n   *\n   *  <p>This method returns true if a new reader was in\n   *  fact opened.</p>\n   */\n  public boolean maybeReopen()\n    throws  IOException {\n\n    if (currentSearcher == null) {\n      throw new AlreadyClosedException(\"this SearcherManager is closed\");\n    }\n\n    // Ensure only 1 thread does reopen at once; other\n    // threads just return immediately:\n    if (reopening.tryAcquire()) {\n      try {\n        IndexReader newReader = currentSearcher.getIndexReader().reopen();\n        if (newReader != currentSearcher.getIndexReader()) {\n          IndexSearcher newSearcher = new IndexSearcher(newReader, es);\n          boolean success = false;\n          try {\n            if (warmer != null) {\n              warmer.warm(newSearcher);\n            }\n            swapSearcher(newSearcher);\n            success = true;\n          } finally {\n            if (!success) {\n              release(newSearcher);\n            }\n          }\n          return true;\n        } else {\n          return false;\n        }\n      } finally {\n        reopening.release();\n      }\n    } else {\n      return false;\n    }\n  }\n\n","sourceOld":"  /** You must call this, periodically, to perform a\n   *  reopen.  This calls {@link IndexReader#reopen} on the\n   *  underlying reader, and if that returns a new reader,\n   *  it's warmed (if you provided a {@link SearcherWarmer}\n   *  and then swapped into production.\n   *\n   *  <p><b>Threads</b>: it's fine for more than one thread to\n   *  call this at once.  Only the first thread will attempt\n   *  the reopen; subsequent threads will see that another\n   *  thread is already handling reopen and will return\n   *  immediately.  Note that this means if another thread\n   *  is already reopening then subsequent threads will\n   *  return right away without waiting for the reader\n   *  reopen to complete.</p>\n   *\n   *  <p>This method returns true if a new reader was in\n   *  fact opened.</p>\n   */\n  public boolean maybeReopen()\n    throws  IOException {\n\n    if (currentSearcher == null) {\n      throw new AlreadyClosedException(\"this SearcherManager is closed\");\n    }\n\n    // Ensure only 1 thread does reopen at once; other\n    // threads just return immediately:\n    if (reopening.tryAcquire()) {\n      try {\n        IndexReader newReader = currentSearcher.getIndexReader().reopen();\n        if (newReader != currentSearcher.getIndexReader()) {\n          IndexSearcher newSearcher = new IndexSearcher(newReader, es);\n          if (warmer != null) {\n            boolean success = false;\n            try {\n              warmer.warm(newSearcher);\n              success = true;\n            } finally {\n              if (!success) {\n                newReader.decRef();\n              }\n            }\n          }\n          boolean success = false;\n          try {\n            swapSearcher(newSearcher);\n            success = true;\n          } finally {\n            if (!success) {\n              release(newSearcher);\n            }\n          }\n          return true;\n        } else {\n          return false;\n        }\n      } finally {\n        reopening.release();\n      }\n    } else {\n      return false;\n    }\n  }\n\n","bugFix":["576017a3864f5d8d12be8dc6b7b47dd9c41cc08d","edcc2c2cbab6bf89ea584169ffb3ca83a31827f9"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8a8259c922a83abc544609227a60d48e5ee93e7e","date":1317679620,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/contrib/misc/src/java/org/apache/lucene/search/SearcherManager#maybeReopen().mjava","pathOld":"lucene/contrib/misc/src/java/org/apache/lucene/search/SearcherManager#maybeReopen().mjava","sourceNew":"  /** You must call this, periodically, to perform a\n   *  reopen.  This calls {@link IndexReader#openIfChanged} on the\n   *  underlying reader, and if that returns a new reader,\n   *  it's warmed (if you provided a {@link SearcherWarmer}\n   *  and then swapped into production.\n   *\n   *  <p><b>Threads</b>: it's fine for more than one thread to\n   *  call this at once.  Only the first thread will attempt\n   *  the reopen; subsequent threads will see that another\n   *  thread is already handling reopen and will return\n   *  immediately.  Note that this means if another thread\n   *  is already reopening then subsequent threads will\n   *  return right away without waiting for the reader\n   *  reopen to complete.</p>\n   *\n   *  <p>This method returns true if a new reader was in\n   *  fact opened.</p>\n   */\n  public boolean maybeReopen()\n    throws  IOException {\n\n    if (currentSearcher == null) {\n      throw new AlreadyClosedException(\"this SearcherManager is closed\");\n    }\n\n    // Ensure only 1 thread does reopen at once; other\n    // threads just return immediately:\n    if (reopening.tryAcquire()) {\n      try {\n        IndexReader newReader = IndexReader.openIfChanged(currentSearcher.getIndexReader());\n        if (newReader != null) {\n          IndexSearcher newSearcher = new IndexSearcher(newReader, es);\n          boolean success = false;\n          try {\n            if (warmer != null) {\n              warmer.warm(newSearcher);\n            }\n            swapSearcher(newSearcher);\n            success = true;\n          } finally {\n            if (!success) {\n              release(newSearcher);\n            }\n          }\n          return true;\n        } else {\n          return false;\n        }\n      } finally {\n        reopening.release();\n      }\n    } else {\n      return false;\n    }\n  }\n\n","sourceOld":"  /** You must call this, periodically, to perform a\n   *  reopen.  This calls {@link IndexReader#reopen} on the\n   *  underlying reader, and if that returns a new reader,\n   *  it's warmed (if you provided a {@link SearcherWarmer}\n   *  and then swapped into production.\n   *\n   *  <p><b>Threads</b>: it's fine for more than one thread to\n   *  call this at once.  Only the first thread will attempt\n   *  the reopen; subsequent threads will see that another\n   *  thread is already handling reopen and will return\n   *  immediately.  Note that this means if another thread\n   *  is already reopening then subsequent threads will\n   *  return right away without waiting for the reader\n   *  reopen to complete.</p>\n   *\n   *  <p>This method returns true if a new reader was in\n   *  fact opened.</p>\n   */\n  public boolean maybeReopen()\n    throws  IOException {\n\n    if (currentSearcher == null) {\n      throw new AlreadyClosedException(\"this SearcherManager is closed\");\n    }\n\n    // Ensure only 1 thread does reopen at once; other\n    // threads just return immediately:\n    if (reopening.tryAcquire()) {\n      try {\n        IndexReader newReader = currentSearcher.getIndexReader().reopen();\n        if (newReader != currentSearcher.getIndexReader()) {\n          IndexSearcher newSearcher = new IndexSearcher(newReader, es);\n          boolean success = false;\n          try {\n            if (warmer != null) {\n              warmer.warm(newSearcher);\n            }\n            swapSearcher(newSearcher);\n            success = true;\n          } finally {\n            if (!success) {\n              release(newSearcher);\n            }\n          }\n          return true;\n        } else {\n          return false;\n        }\n      } finally {\n        reopening.release();\n      }\n    } else {\n      return false;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"606baff722a317c76a92b111d183b54b6e6e5741","date":1317974711,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/contrib/misc/src/java/org/apache/lucene/search/SearcherManager#maybeReopen().mjava","pathOld":"lucene/contrib/misc/src/java/org/apache/lucene/search/SearcherManager#maybeReopen().mjava","sourceNew":"  /**\n   * You must call this, periodically, to perform a reopen. This calls\n   * {@link #openIfChanged(IndexReader)} with the underlying reader, and if that returns a\n   * new reader, it's warmed (if you provided a {@link SearcherWarmer} and then\n   * swapped into production.\n   * \n   * <p>\n   * <b>Threads</b>: it's fine for more than one thread to call this at once.\n   * Only the first thread will attempt the reopen; subsequent threads will see\n   * that another thread is already handling reopen and will return immediately.\n   * Note that this means if another thread is already reopening then subsequent\n   * threads will return right away without waiting for the reader reopen to\n   * complete.\n   * </p>\n   * \n   * <p>\n   * This method returns true if a new reader was in fact opened.\n   * </p>\n   */\n  public boolean maybeReopen() throws IOException {\n    ensureOpen();\n    // Ensure only 1 thread does reopen at once; other\n    // threads just return immediately:\n    if (reopenLock.tryAcquire()) {\n      try {\n        final IndexReader newReader = openIfChanged(currentSearcher.getIndexReader());\n        if (newReader != null) {\n          final IndexSearcher newSearcher = new IndexSearcher(newReader, es);\n          boolean success = false;\n          try {\n            if (warmer != null) {\n              warmer.warm(newSearcher);\n            }\n            swapSearcher(newSearcher);\n            success = true;\n          } finally {\n            if (!success) {\n              release(newSearcher);\n            }\n          }\n          return true;\n        } else {\n          return false;\n        }\n      } finally {\n        reopenLock.release();\n      }\n    } else {\n      return false;\n    }\n  }\n\n","sourceOld":"  /** You must call this, periodically, to perform a\n   *  reopen.  This calls {@link IndexReader#openIfChanged} on the\n   *  underlying reader, and if that returns a new reader,\n   *  it's warmed (if you provided a {@link SearcherWarmer}\n   *  and then swapped into production.\n   *\n   *  <p><b>Threads</b>: it's fine for more than one thread to\n   *  call this at once.  Only the first thread will attempt\n   *  the reopen; subsequent threads will see that another\n   *  thread is already handling reopen and will return\n   *  immediately.  Note that this means if another thread\n   *  is already reopening then subsequent threads will\n   *  return right away without waiting for the reader\n   *  reopen to complete.</p>\n   *\n   *  <p>This method returns true if a new reader was in\n   *  fact opened.</p>\n   */\n  public boolean maybeReopen()\n    throws  IOException {\n\n    if (currentSearcher == null) {\n      throw new AlreadyClosedException(\"this SearcherManager is closed\");\n    }\n\n    // Ensure only 1 thread does reopen at once; other\n    // threads just return immediately:\n    if (reopening.tryAcquire()) {\n      try {\n        IndexReader newReader = IndexReader.openIfChanged(currentSearcher.getIndexReader());\n        if (newReader != null) {\n          IndexSearcher newSearcher = new IndexSearcher(newReader, es);\n          boolean success = false;\n          try {\n            if (warmer != null) {\n              warmer.warm(newSearcher);\n            }\n            swapSearcher(newSearcher);\n            success = true;\n          } finally {\n            if (!success) {\n              release(newSearcher);\n            }\n          }\n          return true;\n        } else {\n          return false;\n        }\n      } finally {\n        reopening.release();\n      }\n    } else {\n      return false;\n    }\n  }\n\n","bugFix":null,"bugIntro":["76364fe9e16e51702b00a59a9ae3ed0646080deb"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"43369d257d14f61a881aa609962ef95e8a334d3a","date":1318786064,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/contrib/misc/src/java/org/apache/lucene/search/SearcherManager#maybeReopen().mjava","pathOld":"lucene/contrib/misc/src/java/org/apache/lucene/search/SearcherManager#maybeReopen().mjava","sourceNew":"  /**\n   * You must call this, periodically, to perform a reopen. This calls\n   * {@link IndexReader#openIfChanged(IndexReader)} with the underlying reader, and if that returns a\n   * new reader, it's warmed (if you provided a {@link SearcherWarmer} and then\n   * swapped into production.\n   * \n   * <p>\n   * <b>Threads</b>: it's fine for more than one thread to call this at once.\n   * Only the first thread will attempt the reopen; subsequent threads will see\n   * that another thread is already handling reopen and will return immediately.\n   * Note that this means if another thread is already reopening then subsequent\n   * threads will return right away without waiting for the reader reopen to\n   * complete.\n   * </p>\n   * \n   * <p>\n   * This method returns true if a new reader was in fact opened.\n   * </p>\n   */\n  public boolean maybeReopen() throws IOException {\n    ensureOpen();\n    // Ensure only 1 thread does reopen at once; other\n    // threads just return immediately:\n    if (reopenLock.tryAcquire()) {\n      try {\n        // IR.openIfChanged preserves NRT and applyDeletes\n        // in the newly returned reader:\n        final IndexReader newReader = IndexReader.openIfChanged(currentSearcher.getIndexReader());\n        if (newReader != null) {\n          final IndexSearcher newSearcher = new IndexSearcher(newReader, es);\n          boolean success = false;\n          try {\n            if (warmer != null) {\n              warmer.warm(newSearcher);\n            }\n            swapSearcher(newSearcher);\n            success = true;\n          } finally {\n            if (!success) {\n              release(newSearcher);\n            }\n          }\n          return true;\n        } else {\n          return false;\n        }\n      } finally {\n        reopenLock.release();\n      }\n    } else {\n      return false;\n    }\n  }\n\n","sourceOld":"  /**\n   * You must call this, periodically, to perform a reopen. This calls\n   * {@link #openIfChanged(IndexReader)} with the underlying reader, and if that returns a\n   * new reader, it's warmed (if you provided a {@link SearcherWarmer} and then\n   * swapped into production.\n   * \n   * <p>\n   * <b>Threads</b>: it's fine for more than one thread to call this at once.\n   * Only the first thread will attempt the reopen; subsequent threads will see\n   * that another thread is already handling reopen and will return immediately.\n   * Note that this means if another thread is already reopening then subsequent\n   * threads will return right away without waiting for the reader reopen to\n   * complete.\n   * </p>\n   * \n   * <p>\n   * This method returns true if a new reader was in fact opened.\n   * </p>\n   */\n  public boolean maybeReopen() throws IOException {\n    ensureOpen();\n    // Ensure only 1 thread does reopen at once; other\n    // threads just return immediately:\n    if (reopenLock.tryAcquire()) {\n      try {\n        final IndexReader newReader = openIfChanged(currentSearcher.getIndexReader());\n        if (newReader != null) {\n          final IndexSearcher newSearcher = new IndexSearcher(newReader, es);\n          boolean success = false;\n          try {\n            if (warmer != null) {\n              warmer.warm(newSearcher);\n            }\n            swapSearcher(newSearcher);\n            success = true;\n          } finally {\n            if (!success) {\n              release(newSearcher);\n            }\n          }\n          return true;\n        } else {\n          return false;\n        }\n      } finally {\n        reopenLock.release();\n      }\n    } else {\n      return false;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"76364fe9e16e51702b00a59a9ae3ed0646080deb","date":1320780791,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/contrib/misc/src/java/org/apache/lucene/search/SearcherManager#maybeReopen().mjava","pathOld":"lucene/contrib/misc/src/java/org/apache/lucene/search/SearcherManager#maybeReopen().mjava","sourceNew":"  /**\n   * You must call this, periodically, to perform a reopen. This calls\n   * {@link IndexReader#openIfChanged(IndexReader)} with the underlying reader, and if that returns a\n   * new reader, it's warmed (if you provided a {@link SearcherWarmer} and then\n   * swapped into production.\n   * \n   * <p>\n   * <b>Threads</b>: it's fine for more than one thread to call this at once.\n   * Only the first thread will attempt the reopen; subsequent threads will see\n   * that another thread is already handling reopen and will return immediately.\n   * Note that this means if another thread is already reopening then subsequent\n   * threads will return right away without waiting for the reader reopen to\n   * complete.\n   * </p>\n   * \n   * <p>\n   * This method returns true if a new reader was in fact opened or \n   * if the current searcher has no pending changes.\n   * </p>\n   */\n  public boolean maybeReopen() throws IOException {\n    ensureOpen();\n    // Ensure only 1 thread does reopen at once; other\n    // threads just return immediately:\n    if (reopenLock.tryAcquire()) {\n      try {\n        // IR.openIfChanged preserves NRT and applyDeletes\n        // in the newly returned reader:\n        final IndexReader newReader = IndexReader.openIfChanged(currentSearcher.getIndexReader());\n        if (newReader != null) {\n          final IndexSearcher newSearcher = new IndexSearcher(newReader, es);\n          boolean success = false;\n          try {\n            if (warmer != null) {\n              warmer.warm(newSearcher);\n            }\n            swapSearcher(newSearcher);\n            success = true;\n          } finally {\n            if (!success) {\n              release(newSearcher);\n            }\n          }\n        }\n        return true;\n      } finally {\n        reopenLock.release();\n      }\n    } else {\n      return false;\n    }\n  }\n\n","sourceOld":"  /**\n   * You must call this, periodically, to perform a reopen. This calls\n   * {@link IndexReader#openIfChanged(IndexReader)} with the underlying reader, and if that returns a\n   * new reader, it's warmed (if you provided a {@link SearcherWarmer} and then\n   * swapped into production.\n   * \n   * <p>\n   * <b>Threads</b>: it's fine for more than one thread to call this at once.\n   * Only the first thread will attempt the reopen; subsequent threads will see\n   * that another thread is already handling reopen and will return immediately.\n   * Note that this means if another thread is already reopening then subsequent\n   * threads will return right away without waiting for the reader reopen to\n   * complete.\n   * </p>\n   * \n   * <p>\n   * This method returns true if a new reader was in fact opened.\n   * </p>\n   */\n  public boolean maybeReopen() throws IOException {\n    ensureOpen();\n    // Ensure only 1 thread does reopen at once; other\n    // threads just return immediately:\n    if (reopenLock.tryAcquire()) {\n      try {\n        // IR.openIfChanged preserves NRT and applyDeletes\n        // in the newly returned reader:\n        final IndexReader newReader = IndexReader.openIfChanged(currentSearcher.getIndexReader());\n        if (newReader != null) {\n          final IndexSearcher newSearcher = new IndexSearcher(newReader, es);\n          boolean success = false;\n          try {\n            if (warmer != null) {\n              warmer.warm(newSearcher);\n            }\n            swapSearcher(newSearcher);\n            success = true;\n          } finally {\n            if (!success) {\n              release(newSearcher);\n            }\n          }\n          return true;\n        } else {\n          return false;\n        }\n      } finally {\n        reopenLock.release();\n      }\n    } else {\n      return false;\n    }\n  }\n\n","bugFix":["606baff722a317c76a92b111d183b54b6e6e5741","edcc2c2cbab6bf89ea584169ffb3ca83a31827f9"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"df16fc2e9b615e0138edac46655ae628f5d098ad","date":1320876869,"type":5,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/SearcherManager#maybeReopen().mjava","pathOld":"lucene/contrib/misc/src/java/org/apache/lucene/search/SearcherManager#maybeReopen().mjava","sourceNew":"  /**\n   * You must call this, periodically, to perform a reopen. This calls\n   * {@link IndexReader#openIfChanged(IndexReader)} with the underlying reader, and if that returns a\n   * new reader, it's warmed (if you provided a {@link SearcherWarmer} and then\n   * swapped into production.\n   * \n   * <p>\n   * <b>Threads</b>: it's fine for more than one thread to call this at once.\n   * Only the first thread will attempt the reopen; subsequent threads will see\n   * that another thread is already handling reopen and will return immediately.\n   * Note that this means if another thread is already reopening then subsequent\n   * threads will return right away without waiting for the reader reopen to\n   * complete.\n   * </p>\n   * \n   * <p>\n   * This method returns true if a new reader was in fact opened or \n   * if the current searcher has no pending changes.\n   * </p>\n   */\n  public boolean maybeReopen() throws IOException {\n    ensureOpen();\n    // Ensure only 1 thread does reopen at once; other\n    // threads just return immediately:\n    if (reopenLock.tryAcquire()) {\n      try {\n        // IR.openIfChanged preserves NRT and applyDeletes\n        // in the newly returned reader:\n        final IndexReader newReader = IndexReader.openIfChanged(currentSearcher.getIndexReader());\n        if (newReader != null) {\n          final IndexSearcher newSearcher = new IndexSearcher(newReader, es);\n          boolean success = false;\n          try {\n            if (warmer != null) {\n              warmer.warm(newSearcher);\n            }\n            swapSearcher(newSearcher);\n            success = true;\n          } finally {\n            if (!success) {\n              release(newSearcher);\n            }\n          }\n        }\n        return true;\n      } finally {\n        reopenLock.release();\n      }\n    } else {\n      return false;\n    }\n  }\n\n","sourceOld":"  /**\n   * You must call this, periodically, to perform a reopen. This calls\n   * {@link IndexReader#openIfChanged(IndexReader)} with the underlying reader, and if that returns a\n   * new reader, it's warmed (if you provided a {@link SearcherWarmer} and then\n   * swapped into production.\n   * \n   * <p>\n   * <b>Threads</b>: it's fine for more than one thread to call this at once.\n   * Only the first thread will attempt the reopen; subsequent threads will see\n   * that another thread is already handling reopen and will return immediately.\n   * Note that this means if another thread is already reopening then subsequent\n   * threads will return right away without waiting for the reader reopen to\n   * complete.\n   * </p>\n   * \n   * <p>\n   * This method returns true if a new reader was in fact opened or \n   * if the current searcher has no pending changes.\n   * </p>\n   */\n  public boolean maybeReopen() throws IOException {\n    ensureOpen();\n    // Ensure only 1 thread does reopen at once; other\n    // threads just return immediately:\n    if (reopenLock.tryAcquire()) {\n      try {\n        // IR.openIfChanged preserves NRT and applyDeletes\n        // in the newly returned reader:\n        final IndexReader newReader = IndexReader.openIfChanged(currentSearcher.getIndexReader());\n        if (newReader != null) {\n          final IndexSearcher newSearcher = new IndexSearcher(newReader, es);\n          boolean success = false;\n          try {\n            if (warmer != null) {\n              warmer.warm(newSearcher);\n            }\n            swapSearcher(newSearcher);\n            success = true;\n          } finally {\n            if (!success) {\n              release(newSearcher);\n            }\n          }\n        }\n        return true;\n      } finally {\n        reopenLock.release();\n      }\n    } else {\n      return false;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"8a8259c922a83abc544609227a60d48e5ee93e7e":["4df4116ba247711222d5e70863dd14459e41e27c"],"dfc6076b23c4069ed33fce21fd75a8ccfbf5019c":["abba29aa88f170f3d51899c885b760337dd1c47c"],"576017a3864f5d8d12be8dc6b7b47dd9c41cc08d":["edcc2c2cbab6bf89ea584169ffb3ca83a31827f9"],"df16fc2e9b615e0138edac46655ae628f5d098ad":["76364fe9e16e51702b00a59a9ae3ed0646080deb"],"76364fe9e16e51702b00a59a9ae3ed0646080deb":["43369d257d14f61a881aa609962ef95e8a334d3a"],"4df4116ba247711222d5e70863dd14459e41e27c":["dfc6076b23c4069ed33fce21fd75a8ccfbf5019c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"edcc2c2cbab6bf89ea584169ffb3ca83a31827f9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"43369d257d14f61a881aa609962ef95e8a334d3a":["606baff722a317c76a92b111d183b54b6e6e5741"],"606baff722a317c76a92b111d183b54b6e6e5741":["8a8259c922a83abc544609227a60d48e5ee93e7e"],"abba29aa88f170f3d51899c885b760337dd1c47c":["576017a3864f5d8d12be8dc6b7b47dd9c41cc08d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["df16fc2e9b615e0138edac46655ae628f5d098ad"]},"commit2Childs":{"8a8259c922a83abc544609227a60d48e5ee93e7e":["606baff722a317c76a92b111d183b54b6e6e5741"],"dfc6076b23c4069ed33fce21fd75a8ccfbf5019c":["4df4116ba247711222d5e70863dd14459e41e27c"],"576017a3864f5d8d12be8dc6b7b47dd9c41cc08d":["abba29aa88f170f3d51899c885b760337dd1c47c"],"df16fc2e9b615e0138edac46655ae628f5d098ad":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"76364fe9e16e51702b00a59a9ae3ed0646080deb":["df16fc2e9b615e0138edac46655ae628f5d098ad"],"4df4116ba247711222d5e70863dd14459e41e27c":["8a8259c922a83abc544609227a60d48e5ee93e7e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["edcc2c2cbab6bf89ea584169ffb3ca83a31827f9"],"edcc2c2cbab6bf89ea584169ffb3ca83a31827f9":["576017a3864f5d8d12be8dc6b7b47dd9c41cc08d"],"43369d257d14f61a881aa609962ef95e8a334d3a":["76364fe9e16e51702b00a59a9ae3ed0646080deb"],"606baff722a317c76a92b111d183b54b6e6e5741":["43369d257d14f61a881aa609962ef95e8a334d3a"],"abba29aa88f170f3d51899c885b760337dd1c47c":["dfc6076b23c4069ed33fce21fd75a8ccfbf5019c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}