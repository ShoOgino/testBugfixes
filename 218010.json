{"path":"lucene/src/test/org/apache/lucene/index/values/TestTypePromotion#assertValues(TestType,Directory,long[]).mjava","commits":[{"id":"ff266254aa2c0b84006f8f3088ee25337661554d","date":1318269918,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestTypePromotion#assertValues(TestType,Directory,long[]).mjava","pathOld":"/dev/null","sourceNew":"  private void assertValues(TestType type, Directory dir, long[] values)\n      throws CorruptIndexException, IOException {\n    IndexReader reader = IndexReader.open(dir);\n    assertTrue(reader.isOptimized());\n    ReaderContext topReaderContext = reader.getTopReaderContext();\n    ReaderContext[] children = topReaderContext.children();\n    IndexDocValues docValues = children[0].reader.docValues(\"promote\");\n    assertEquals(1, children.length);\n    Source directSource = docValues.getDirectSource();\n    for (int i = 0; i < values.length; i++) {\n      int id = Integer.parseInt(reader.document(i).get(\"id\"));\n      String msg = \"id: \" + id + \" doc: \" + i;\n      switch (type) {\n      case Byte:\n        BytesRef bytes = directSource.getBytes(i, new BytesRef());\n        long value = 0;\n        switch(bytes.length) {\n        case 1:\n          value = bytes.bytes[bytes.offset];\n          break;\n        case 2:\n          value = bytes.asShort();\n          break;\n        case 4:\n          value = bytes.asInt();\n          break;\n        case 8:\n          value = bytes.asLong();\n          break;\n          \n        default:\n          fail(msg + \" bytessize: \" + bytes.length);\n        }\n        \n        assertEquals(msg  + \" byteSize: \" + bytes.length, values[id], value);\n        break;\n      case Float:\n          assertEquals(msg, values[id], Double.doubleToRawLongBits(directSource.getFloat(i)));\n        break;\n      case Int:\n        assertEquals(msg, values[id], directSource.getInt(i));\n      default:\n        break;\n      }\n\n    }\n    docValues.close();\n    reader.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["cd659803551ebd8ca09b9e4ad7abd18d3d558f9d","4d3e8520fd031bab31fd0e4d480e55958bc45efe","1a65994c1e63cc607f3176b95dba35bb4e58b69f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"dd5f755cd0bd295d6cb9bdd4cc1772d5c8caca42","date":1318352817,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestTypePromotion#assertValues(TestType,Directory,long[]).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestTypePromotion#assertValues(TestType,Directory,long[]).mjava","sourceNew":"  private void assertValues(TestType type, Directory dir, long[] values)\n      throws CorruptIndexException, IOException {\n    IndexReader reader = IndexReader.open(dir);\n    assertTrue(reader.isOptimized());\n    ReaderContext topReaderContext = reader.getTopReaderContext();\n    ReaderContext[] children = topReaderContext.children();\n    IndexDocValues docValues = children[0].reader.docValues(\"promote\");\n    assertEquals(1, children.length);\n    Source directSource = docValues.getDirectSource();\n    for (int i = 0; i < values.length; i++) {\n      int id = Integer.parseInt(reader.document(i).get(\"id\"));\n      String msg = \"id: \" + id + \" doc: \" + i;\n      switch (type) {\n      case Byte:\n        BytesRef bytes = directSource.getBytes(i, new BytesRef());\n        long value = 0;\n        switch(bytes.length) {\n        case 1:\n          value = bytes.bytes[bytes.offset];\n          break;\n        case 2:\n          value = bytes.asShort();\n          break;\n        case 4:\n          value = bytes.asInt();\n          break;\n        case 8:\n          value = bytes.asLong();\n          break;\n          \n        default:\n          fail(msg + \" bytessize: \" + bytes.length);\n        }\n        \n        assertEquals(msg  + \" byteSize: \" + bytes.length, values[id], value);\n        break;\n      case Float:\n          assertEquals(msg, values[id], Double.doubleToRawLongBits(directSource.getFloat(i)));\n        break;\n      case Int:\n        assertEquals(msg, values[id], directSource.getInt(i));\n        break;\n      default:\n        break;\n      }\n\n    }\n    docValues.close();\n    reader.close();\n  }\n\n","sourceOld":"  private void assertValues(TestType type, Directory dir, long[] values)\n      throws CorruptIndexException, IOException {\n    IndexReader reader = IndexReader.open(dir);\n    assertTrue(reader.isOptimized());\n    ReaderContext topReaderContext = reader.getTopReaderContext();\n    ReaderContext[] children = topReaderContext.children();\n    IndexDocValues docValues = children[0].reader.docValues(\"promote\");\n    assertEquals(1, children.length);\n    Source directSource = docValues.getDirectSource();\n    for (int i = 0; i < values.length; i++) {\n      int id = Integer.parseInt(reader.document(i).get(\"id\"));\n      String msg = \"id: \" + id + \" doc: \" + i;\n      switch (type) {\n      case Byte:\n        BytesRef bytes = directSource.getBytes(i, new BytesRef());\n        long value = 0;\n        switch(bytes.length) {\n        case 1:\n          value = bytes.bytes[bytes.offset];\n          break;\n        case 2:\n          value = bytes.asShort();\n          break;\n        case 4:\n          value = bytes.asInt();\n          break;\n        case 8:\n          value = bytes.asLong();\n          break;\n          \n        default:\n          fail(msg + \" bytessize: \" + bytes.length);\n        }\n        \n        assertEquals(msg  + \" byteSize: \" + bytes.length, values[id], value);\n        break;\n      case Float:\n          assertEquals(msg, values[id], Double.doubleToRawLongBits(directSource.getFloat(i)));\n        break;\n      case Int:\n        assertEquals(msg, values[id], directSource.getInt(i));\n      default:\n        break;\n      }\n\n    }\n    docValues.close();\n    reader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d14e8d18c0e3970c20354dbeeb49da11bd587fbd","date":1321041051,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestTypePromotion#assertValues(TestType,Directory,long[]).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestTypePromotion#assertValues(TestType,Directory,long[]).mjava","sourceNew":"  private void assertValues(TestType type, Directory dir, long[] values)\n      throws CorruptIndexException, IOException {\n    IndexReader reader = IndexReader.open(dir);\n    assertEquals(1, reader.getSequentialSubReaders().length);\n    ReaderContext topReaderContext = reader.getTopReaderContext();\n    ReaderContext[] children = topReaderContext.children();\n    IndexDocValues docValues = children[0].reader.docValues(\"promote\");\n    assertEquals(1, children.length);\n    Source directSource = docValues.getDirectSource();\n    for (int i = 0; i < values.length; i++) {\n      int id = Integer.parseInt(reader.document(i).get(\"id\"));\n      String msg = \"id: \" + id + \" doc: \" + i;\n      switch (type) {\n      case Byte:\n        BytesRef bytes = directSource.getBytes(i, new BytesRef());\n        long value = 0;\n        switch(bytes.length) {\n        case 1:\n          value = bytes.bytes[bytes.offset];\n          break;\n        case 2:\n          value = bytes.asShort();\n          break;\n        case 4:\n          value = bytes.asInt();\n          break;\n        case 8:\n          value = bytes.asLong();\n          break;\n          \n        default:\n          fail(msg + \" bytessize: \" + bytes.length);\n        }\n        \n        assertEquals(msg  + \" byteSize: \" + bytes.length, values[id], value);\n        break;\n      case Float:\n          assertEquals(msg, values[id], Double.doubleToRawLongBits(directSource.getFloat(i)));\n        break;\n      case Int:\n        assertEquals(msg, values[id], directSource.getInt(i));\n        break;\n      default:\n        break;\n      }\n\n    }\n    docValues.close();\n    reader.close();\n  }\n\n","sourceOld":"  private void assertValues(TestType type, Directory dir, long[] values)\n      throws CorruptIndexException, IOException {\n    IndexReader reader = IndexReader.open(dir);\n    assertTrue(reader.isOptimized());\n    ReaderContext topReaderContext = reader.getTopReaderContext();\n    ReaderContext[] children = topReaderContext.children();\n    IndexDocValues docValues = children[0].reader.docValues(\"promote\");\n    assertEquals(1, children.length);\n    Source directSource = docValues.getDirectSource();\n    for (int i = 0; i < values.length; i++) {\n      int id = Integer.parseInt(reader.document(i).get(\"id\"));\n      String msg = \"id: \" + id + \" doc: \" + i;\n      switch (type) {\n      case Byte:\n        BytesRef bytes = directSource.getBytes(i, new BytesRef());\n        long value = 0;\n        switch(bytes.length) {\n        case 1:\n          value = bytes.bytes[bytes.offset];\n          break;\n        case 2:\n          value = bytes.asShort();\n          break;\n        case 4:\n          value = bytes.asInt();\n          break;\n        case 8:\n          value = bytes.asLong();\n          break;\n          \n        default:\n          fail(msg + \" bytessize: \" + bytes.length);\n        }\n        \n        assertEquals(msg  + \" byteSize: \" + bytes.length, values[id], value);\n        break;\n      case Float:\n          assertEquals(msg, values[id], Double.doubleToRawLongBits(directSource.getFloat(i)));\n        break;\n      case Int:\n        assertEquals(msg, values[id], directSource.getInt(i));\n        break;\n      default:\n        break;\n      }\n\n    }\n    docValues.close();\n    reader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1a65994c1e63cc607f3176b95dba35bb4e58b69f","date":1322143796,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestTypePromotion#assertValues(TestType,Directory,long[]).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestTypePromotion#assertValues(TestType,Directory,long[]).mjava","sourceNew":"  private void assertValues(TestType type, Directory dir, long[] values)\n      throws CorruptIndexException, IOException {\n    IndexReader reader = IndexReader.open(dir);\n    assertEquals(1, reader.getSequentialSubReaders().length);\n    ReaderContext topReaderContext = reader.getTopReaderContext();\n    ReaderContext[] children = topReaderContext.children();\n    IndexDocValues docValues = children[0].reader.docValues(\"promote\");\n    assertEquals(1, children.length);\n    Source directSource = docValues.getDirectSource();\n    for (int i = 0; i < values.length; i++) {\n      int id = Integer.parseInt(reader.document(i).get(\"id\"));\n      String msg = \"id: \" + id + \" doc: \" + i;\n      switch (type) {\n      case Byte:\n        BytesRef bytes = directSource.getBytes(i, new BytesRef());\n        long value = 0;\n        switch(bytes.length) {\n        case 1:\n          value = bytes.bytes[bytes.offset];\n          break;\n        case 2:\n          value = asShort(bytes);\n          break;\n        case 4:\n          value = asInt(bytes);\n          break;\n        case 8:\n          value = asLong(bytes);\n          break;\n          \n        default:\n          fail(msg + \" bytessize: \" + bytes.length);\n        }\n        \n        assertEquals(msg  + \" byteSize: \" + bytes.length, values[id], value);\n        break;\n      case Float:\n          assertEquals(msg, values[id], Double.doubleToRawLongBits(directSource.getFloat(i)));\n        break;\n      case Int:\n        assertEquals(msg, values[id], directSource.getInt(i));\n        break;\n      default:\n        break;\n      }\n\n    }\n    docValues.close();\n    reader.close();\n  }\n\n","sourceOld":"  private void assertValues(TestType type, Directory dir, long[] values)\n      throws CorruptIndexException, IOException {\n    IndexReader reader = IndexReader.open(dir);\n    assertEquals(1, reader.getSequentialSubReaders().length);\n    ReaderContext topReaderContext = reader.getTopReaderContext();\n    ReaderContext[] children = topReaderContext.children();\n    IndexDocValues docValues = children[0].reader.docValues(\"promote\");\n    assertEquals(1, children.length);\n    Source directSource = docValues.getDirectSource();\n    for (int i = 0; i < values.length; i++) {\n      int id = Integer.parseInt(reader.document(i).get(\"id\"));\n      String msg = \"id: \" + id + \" doc: \" + i;\n      switch (type) {\n      case Byte:\n        BytesRef bytes = directSource.getBytes(i, new BytesRef());\n        long value = 0;\n        switch(bytes.length) {\n        case 1:\n          value = bytes.bytes[bytes.offset];\n          break;\n        case 2:\n          value = bytes.asShort();\n          break;\n        case 4:\n          value = bytes.asInt();\n          break;\n        case 8:\n          value = bytes.asLong();\n          break;\n          \n        default:\n          fail(msg + \" bytessize: \" + bytes.length);\n        }\n        \n        assertEquals(msg  + \" byteSize: \" + bytes.length, values[id], value);\n        break;\n      case Float:\n          assertEquals(msg, values[id], Double.doubleToRawLongBits(directSource.getFloat(i)));\n        break;\n      case Int:\n        assertEquals(msg, values[id], directSource.getInt(i));\n        break;\n      default:\n        break;\n      }\n\n    }\n    docValues.close();\n    reader.close();\n  }\n\n","bugFix":["ff266254aa2c0b84006f8f3088ee25337661554d"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"94e8fdd836dbd4f01a00be6ffbe2c2df8d74898b","date":1322155235,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestTypePromotion#assertValues(TestType,Directory,long[]).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestTypePromotion#assertValues(TestType,Directory,long[]).mjava","sourceNew":"  private void assertValues(TestType type, Directory dir, long[] values)\n      throws CorruptIndexException, IOException {\n    IndexReader reader = IndexReader.open(dir);\n    assertEquals(1, reader.getSequentialSubReaders().length);\n    ReaderContext topReaderContext = reader.getTopReaderContext();\n    ReaderContext[] children = topReaderContext.children();\n    IndexDocValues docValues = children[0].reader.docValues(\"promote\");\n    assertEquals(1, children.length);\n    Source directSource = docValues.getDirectSource();\n    for (int i = 0; i < values.length; i++) {\n      int id = Integer.parseInt(reader.document(i).get(\"id\"));\n      String msg = \"id: \" + id + \" doc: \" + i;\n      switch (type) {\n      case Byte:\n        BytesRef bytes = directSource.getBytes(i, new BytesRef());\n        long value = 0;\n        switch(bytes.length) {\n        case 1:\n          value = bytes.bytes[bytes.offset];\n          break;\n        case 2:\n          value = BytesRefUtils.asShort(bytes);\n          break;\n        case 4:\n          value = BytesRefUtils.asInt(bytes);\n          break;\n        case 8:\n          value = BytesRefUtils.asLong(bytes);\n          break;\n          \n        default:\n          fail(msg + \" bytessize: \" + bytes.length);\n        }\n        \n        assertEquals(msg  + \" byteSize: \" + bytes.length, values[id], value);\n        break;\n      case Float:\n          assertEquals(msg, values[id], Double.doubleToRawLongBits(directSource.getFloat(i)));\n        break;\n      case Int:\n        assertEquals(msg, values[id], directSource.getInt(i));\n        break;\n      default:\n        break;\n      }\n\n    }\n    docValues.close();\n    reader.close();\n  }\n\n","sourceOld":"  private void assertValues(TestType type, Directory dir, long[] values)\n      throws CorruptIndexException, IOException {\n    IndexReader reader = IndexReader.open(dir);\n    assertEquals(1, reader.getSequentialSubReaders().length);\n    ReaderContext topReaderContext = reader.getTopReaderContext();\n    ReaderContext[] children = topReaderContext.children();\n    IndexDocValues docValues = children[0].reader.docValues(\"promote\");\n    assertEquals(1, children.length);\n    Source directSource = docValues.getDirectSource();\n    for (int i = 0; i < values.length; i++) {\n      int id = Integer.parseInt(reader.document(i).get(\"id\"));\n      String msg = \"id: \" + id + \" doc: \" + i;\n      switch (type) {\n      case Byte:\n        BytesRef bytes = directSource.getBytes(i, new BytesRef());\n        long value = 0;\n        switch(bytes.length) {\n        case 1:\n          value = bytes.bytes[bytes.offset];\n          break;\n        case 2:\n          value = asShort(bytes);\n          break;\n        case 4:\n          value = asInt(bytes);\n          break;\n        case 8:\n          value = asLong(bytes);\n          break;\n          \n        default:\n          fail(msg + \" bytessize: \" + bytes.length);\n        }\n        \n        assertEquals(msg  + \" byteSize: \" + bytes.length, values[id], value);\n        break;\n      case Float:\n          assertEquals(msg, values[id], Double.doubleToRawLongBits(directSource.getFloat(i)));\n        break;\n      case Int:\n        assertEquals(msg, values[id], directSource.getInt(i));\n        break;\n      default:\n        break;\n      }\n\n    }\n    docValues.close();\n    reader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1e59c344a45b9502f40ec44f5fe4e20ed2291dbe","date":1323449025,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestTypePromotion#assertValues(TestType,Directory,long[]).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestTypePromotion#assertValues(TestType,Directory,long[]).mjava","sourceNew":"  private void assertValues(TestType type, Directory dir, long[] values)\n      throws CorruptIndexException, IOException {\n    IndexReader reader = IndexReader.open(dir);\n    assertEquals(1, reader.getSequentialSubReaders().length);\n    ReaderContext topReaderContext = reader.getTopReaderContext();\n    ReaderContext[] children = topReaderContext.children();\n    DocValues docValues = children[0].reader.docValues(\"promote\");\n    assertEquals(1, children.length);\n    Source directSource = docValues.getDirectSource();\n    for (int i = 0; i < values.length; i++) {\n      int id = Integer.parseInt(reader.document(i).get(\"id\"));\n      String msg = \"id: \" + id + \" doc: \" + i;\n      switch (type) {\n      case Byte:\n        BytesRef bytes = directSource.getBytes(i, new BytesRef());\n        long value = 0;\n        switch(bytes.length) {\n        case 1:\n          value = bytes.bytes[bytes.offset];\n          break;\n        case 2:\n          value = BytesRefUtils.asShort(bytes);\n          break;\n        case 4:\n          value = BytesRefUtils.asInt(bytes);\n          break;\n        case 8:\n          value = BytesRefUtils.asLong(bytes);\n          break;\n          \n        default:\n          fail(msg + \" bytessize: \" + bytes.length);\n        }\n        \n        assertEquals(msg  + \" byteSize: \" + bytes.length, values[id], value);\n        break;\n      case Float:\n          assertEquals(msg, values[id], Double.doubleToRawLongBits(directSource.getFloat(i)));\n        break;\n      case Int:\n        assertEquals(msg, values[id], directSource.getInt(i));\n        break;\n      default:\n        break;\n      }\n\n    }\n    docValues.close();\n    reader.close();\n  }\n\n","sourceOld":"  private void assertValues(TestType type, Directory dir, long[] values)\n      throws CorruptIndexException, IOException {\n    IndexReader reader = IndexReader.open(dir);\n    assertEquals(1, reader.getSequentialSubReaders().length);\n    ReaderContext topReaderContext = reader.getTopReaderContext();\n    ReaderContext[] children = topReaderContext.children();\n    IndexDocValues docValues = children[0].reader.docValues(\"promote\");\n    assertEquals(1, children.length);\n    Source directSource = docValues.getDirectSource();\n    for (int i = 0; i < values.length; i++) {\n      int id = Integer.parseInt(reader.document(i).get(\"id\"));\n      String msg = \"id: \" + id + \" doc: \" + i;\n      switch (type) {\n      case Byte:\n        BytesRef bytes = directSource.getBytes(i, new BytesRef());\n        long value = 0;\n        switch(bytes.length) {\n        case 1:\n          value = bytes.bytes[bytes.offset];\n          break;\n        case 2:\n          value = BytesRefUtils.asShort(bytes);\n          break;\n        case 4:\n          value = BytesRefUtils.asInt(bytes);\n          break;\n        case 8:\n          value = BytesRefUtils.asLong(bytes);\n          break;\n          \n        default:\n          fail(msg + \" bytessize: \" + bytes.length);\n        }\n        \n        assertEquals(msg  + \" byteSize: \" + bytes.length, values[id], value);\n        break;\n      case Float:\n          assertEquals(msg, values[id], Double.doubleToRawLongBits(directSource.getFloat(i)));\n        break;\n      case Int:\n        assertEquals(msg, values[id], directSource.getInt(i));\n        break;\n      default:\n        break;\n      }\n\n    }\n    docValues.close();\n    reader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d638301ad1cfcae567b681b893bc8781f0ee48a5","date":1323801546,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestTypePromotion#assertValues(TestType,Directory,long[]).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestTypePromotion#assertValues(TestType,Directory,long[]).mjava","sourceNew":"  private void assertValues(TestType type, Directory dir, long[] values)\n      throws CorruptIndexException, IOException {\n    IndexReader reader = IndexReader.open(dir);\n    assertEquals(1, reader.getSequentialSubReaders().length);\n    ReaderContext topReaderContext = reader.getTopReaderContext();\n    ReaderContext[] children = topReaderContext.children();\n    DocValues docValues = children[0].reader.docValues(\"promote\");\n    assertEquals(1, children.length);\n    Source directSource = docValues.getDirectSource();\n    for (int i = 0; i < values.length; i++) {\n      int id = Integer.parseInt(reader.document(i).get(\"id\"));\n      String msg = \"id: \" + id + \" doc: \" + i;\n      switch (type) {\n      case Byte:\n        BytesRef bytes = directSource.getBytes(i, new BytesRef());\n        long value = 0;\n        switch(bytes.length) {\n        case 1:\n          value = bytes.bytes[bytes.offset];\n          break;\n        case 2:\n          value = BytesRefUtils.asShort(bytes);\n          break;\n        case 4:\n          value = BytesRefUtils.asInt(bytes);\n          break;\n        case 8:\n          value = BytesRefUtils.asLong(bytes);\n          break;\n          \n        default:\n          fail(msg + \" bytessize: \" + bytes.length);\n        }\n        \n        assertEquals(msg  + \" byteSize: \" + bytes.length, values[id], value);\n        break;\n      case Float:\n          assertEquals(msg, values[id], Double.doubleToRawLongBits(directSource.getFloat(i)));\n        break;\n      case Int:\n        assertEquals(msg, values[id], directSource.getInt(i));\n        break;\n      default:\n        break;\n      }\n\n    }\n    docValues.close();\n    reader.close();\n  }\n\n","sourceOld":"  private void assertValues(TestType type, Directory dir, long[] values)\n      throws CorruptIndexException, IOException {\n    IndexReader reader = IndexReader.open(dir);\n    assertEquals(1, reader.getSequentialSubReaders().length);\n    ReaderContext topReaderContext = reader.getTopReaderContext();\n    ReaderContext[] children = topReaderContext.children();\n    IndexDocValues docValues = children[0].reader.docValues(\"promote\");\n    assertEquals(1, children.length);\n    Source directSource = docValues.getDirectSource();\n    for (int i = 0; i < values.length; i++) {\n      int id = Integer.parseInt(reader.document(i).get(\"id\"));\n      String msg = \"id: \" + id + \" doc: \" + i;\n      switch (type) {\n      case Byte:\n        BytesRef bytes = directSource.getBytes(i, new BytesRef());\n        long value = 0;\n        switch(bytes.length) {\n        case 1:\n          value = bytes.bytes[bytes.offset];\n          break;\n        case 2:\n          value = BytesRefUtils.asShort(bytes);\n          break;\n        case 4:\n          value = BytesRefUtils.asInt(bytes);\n          break;\n        case 8:\n          value = BytesRefUtils.asLong(bytes);\n          break;\n          \n        default:\n          fail(msg + \" bytessize: \" + bytes.length);\n        }\n        \n        assertEquals(msg  + \" byteSize: \" + bytes.length, values[id], value);\n        break;\n      case Float:\n          assertEquals(msg, values[id], Double.doubleToRawLongBits(directSource.getFloat(i)));\n        break;\n      case Int:\n        assertEquals(msg, values[id], directSource.getInt(i));\n        break;\n      default:\n        break;\n      }\n\n    }\n    docValues.close();\n    reader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0ae5e3ed1232483b7b8a014f175a5fe43595982","date":1324062192,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestTypePromotion#assertValues(TestType,Directory,long[]).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestTypePromotion#assertValues(TestType,Directory,long[]).mjava","sourceNew":"  private void assertValues(TestType type, Directory dir, long[] values)\n      throws CorruptIndexException, IOException {\n    IndexReader reader = IndexReader.open(dir);\n    assertEquals(1, reader.getSequentialSubReaders().length);\n    ReaderContext topReaderContext = reader.getTopReaderContext();\n    ReaderContext[] children = topReaderContext.children();\n    DocValues docValues = children[0].reader.docValues(\"promote\");\n    assertEquals(1, children.length);\n    Source directSource = docValues.getDirectSource();\n    for (int i = 0; i < values.length; i++) {\n      int id = Integer.parseInt(reader.document(i).get(\"id\"));\n      String msg = \"id: \" + id + \" doc: \" + i;\n      switch (type) {\n      case Byte:\n        BytesRef bytes = directSource.getBytes(i, new BytesRef());\n        long value = 0;\n        switch(bytes.length) {\n        case 1:\n          value = bytes.bytes[bytes.offset];\n          break;\n        case 2:\n          value = BytesRefUtils.asShort(bytes);\n          break;\n        case 4:\n          value = BytesRefUtils.asInt(bytes);\n          break;\n        case 8:\n          value = BytesRefUtils.asLong(bytes);\n          break;\n          \n        default:\n          fail(msg + \" bytessize: \" + bytes.length);\n        }\n        \n        assertEquals(msg  + \" byteSize: \" + bytes.length, values[id], value);\n        break;\n      case Float:\n          assertEquals(msg, values[id], Double.doubleToRawLongBits(directSource.getFloat(i)));\n        break;\n      case Int:\n        assertEquals(msg, values[id], directSource.getInt(i));\n        break;\n      default:\n        break;\n      }\n\n    }\n    docValues.close();\n    reader.close();\n  }\n\n","sourceOld":"  private void assertValues(TestType type, Directory dir, long[] values)\n      throws CorruptIndexException, IOException {\n    IndexReader reader = IndexReader.open(dir);\n    assertEquals(1, reader.getSequentialSubReaders().length);\n    ReaderContext topReaderContext = reader.getTopReaderContext();\n    ReaderContext[] children = topReaderContext.children();\n    DocValues docValues = children[0].reader.docValues(\"promote\");\n    assertEquals(1, children.length);\n    Source directSource = docValues.getDirectSource();\n    for (int i = 0; i < values.length; i++) {\n      int id = Integer.parseInt(reader.document(i).get(\"id\"));\n      String msg = \"id: \" + id + \" doc: \" + i;\n      switch (type) {\n      case Byte:\n        BytesRef bytes = directSource.getBytes(i, new BytesRef());\n        long value = 0;\n        switch(bytes.length) {\n        case 1:\n          value = bytes.bytes[bytes.offset];\n          break;\n        case 2:\n          value = BytesRefUtils.asShort(bytes);\n          break;\n        case 4:\n          value = BytesRefUtils.asInt(bytes);\n          break;\n        case 8:\n          value = BytesRefUtils.asLong(bytes);\n          break;\n          \n        default:\n          fail(msg + \" bytessize: \" + bytes.length);\n        }\n        \n        assertEquals(msg  + \" byteSize: \" + bytes.length, values[id], value);\n        break;\n      case Float:\n          assertEquals(msg, values[id], Double.doubleToRawLongBits(directSource.getFloat(i)));\n        break;\n      case Int:\n        assertEquals(msg, values[id], directSource.getInt(i));\n        break;\n      default:\n        break;\n      }\n\n    }\n    docValues.close();\n    reader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"ff266254aa2c0b84006f8f3088ee25337661554d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1a65994c1e63cc607f3176b95dba35bb4e58b69f":["d14e8d18c0e3970c20354dbeeb49da11bd587fbd"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1e59c344a45b9502f40ec44f5fe4e20ed2291dbe":["94e8fdd836dbd4f01a00be6ffbe2c2df8d74898b"],"dd5f755cd0bd295d6cb9bdd4cc1772d5c8caca42":["ff266254aa2c0b84006f8f3088ee25337661554d"],"94e8fdd836dbd4f01a00be6ffbe2c2df8d74898b":["1a65994c1e63cc607f3176b95dba35bb4e58b69f"],"d14e8d18c0e3970c20354dbeeb49da11bd587fbd":["dd5f755cd0bd295d6cb9bdd4cc1772d5c8caca42"],"a0ae5e3ed1232483b7b8a014f175a5fe43595982":["d638301ad1cfcae567b681b893bc8781f0ee48a5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0ae5e3ed1232483b7b8a014f175a5fe43595982"],"d638301ad1cfcae567b681b893bc8781f0ee48a5":["94e8fdd836dbd4f01a00be6ffbe2c2df8d74898b","1e59c344a45b9502f40ec44f5fe4e20ed2291dbe"]},"commit2Childs":{"ff266254aa2c0b84006f8f3088ee25337661554d":["dd5f755cd0bd295d6cb9bdd4cc1772d5c8caca42"],"1a65994c1e63cc607f3176b95dba35bb4e58b69f":["94e8fdd836dbd4f01a00be6ffbe2c2df8d74898b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ff266254aa2c0b84006f8f3088ee25337661554d"],"1e59c344a45b9502f40ec44f5fe4e20ed2291dbe":["d638301ad1cfcae567b681b893bc8781f0ee48a5"],"dd5f755cd0bd295d6cb9bdd4cc1772d5c8caca42":["d14e8d18c0e3970c20354dbeeb49da11bd587fbd"],"d14e8d18c0e3970c20354dbeeb49da11bd587fbd":["1a65994c1e63cc607f3176b95dba35bb4e58b69f"],"94e8fdd836dbd4f01a00be6ffbe2c2df8d74898b":["1e59c344a45b9502f40ec44f5fe4e20ed2291dbe","d638301ad1cfcae567b681b893bc8781f0ee48a5"],"a0ae5e3ed1232483b7b8a014f175a5fe43595982":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d638301ad1cfcae567b681b893bc8781f0ee48a5":["a0ae5e3ed1232483b7b8a014f175a5fe43595982"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}