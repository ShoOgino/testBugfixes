{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#interpolate(PlanetModel,GeoPoint,GeoPoint,double[]).mjava","commits":[{"id":"ec544d8bab0522461529d7ba4fbe68c09cf4793f","date":1529389900,"type":1,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#interpolate(PlanetModel,GeoPoint,GeoPoint,double[]).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#interpolate(GeoPoint,GeoPoint,double[]).mjava","sourceNew":"  /**\n   * Find points on the boundary of the intersection of a plane and the unit sphere,\n   * given a starting point, and ending point, and a list of proportions of the arc (e.g. 0.25, 0.5, 0.75).\n   * The angle between the starting point and ending point is assumed to be less than pi.\n   * @param planetModel is the planet model.\n   * @param start is the start point.\n   * @param end is the end point.\n   * @param proportions is an array of fractional proportions measured between start and end.\n   * @return an array of points corresponding to the proportions passed in.\n   */\n  public GeoPoint[] interpolate(final PlanetModel planetModel, final GeoPoint start, final GeoPoint end, final double[] proportions) {\n    // Steps:\n    // (1) Translate (x0,y0,z0) of endpoints into origin-centered place:\n    // x1 = x0 + D*A\n    // y1 = y0 + D*B\n    // z1 = z0 + D*C\n    // (2) Rotate counterclockwise in x-y:\n    // ra = -atan2(B,A)\n    // x2 = x1 cos ra - y1 sin ra\n    // y2 = x1 sin ra + y1 cos ra\n    // z2 = z1\n    // Faster:\n    // cos ra = A/sqrt(A^2+B^2+C^2)\n    // sin ra = -B/sqrt(A^2+B^2+C^2)\n    // cos (-ra) = A/sqrt(A^2+B^2+C^2)\n    // sin (-ra) = B/sqrt(A^2+B^2+C^2)\n    // (3) Rotate clockwise in x-z:\n    // ha = pi/2 - asin(C/sqrt(A^2+B^2+C^2))\n    // x3 = x2 cos ha - z2 sin ha\n    // y3 = y2\n    // z3 = x2 sin ha + z2 cos ha\n    // At this point, z3 should be zero.\n    // Faster:\n    // sin(ha) = cos(asin(C/sqrt(A^2+B^2+C^2))) = sqrt(1 - C^2/(A^2+B^2+C^2)) = sqrt(A^2+B^2)/sqrt(A^2+B^2+C^2)\n    // cos(ha) = sin(asin(C/sqrt(A^2+B^2+C^2))) = C/sqrt(A^2+B^2+C^2)\n    // (4) Compute interpolations by getting longitudes of original points\n    // la = atan2(y3,x3)\n    // (5) Rotate new points (xN0, yN0, zN0) counter-clockwise in x-z:\n    // ha = -(pi - asin(C/sqrt(A^2+B^2+C^2)))\n    // xN1 = xN0 cos ha - zN0 sin ha\n    // yN1 = yN0\n    // zN1 = xN0 sin ha + zN0 cos ha\n    // (6) Rotate new points clockwise in x-y:\n    // ra = atan2(B,A)\n    // xN2 = xN1 cos ra - yN1 sin ra\n    // yN2 = xN1 sin ra + yN1 cos ra\n    // zN2 = zN1\n    // (7) Translate new points:\n    // xN3 = xN2 - D*A\n    // yN3 = yN2 - D*B\n    // zN3 = zN2 - D*C\n\n    // First, calculate the angles and their sin/cos values\n    double A = x;\n    double B = y;\n    double C = z;\n\n    // Translation amounts\n    final double transX = -D * A;\n    final double transY = -D * B;\n    final double transZ = -D * C;\n\n    double cosRA;\n    double sinRA;\n    double cosHA;\n    double sinHA;\n\n    double magnitude = magnitude();\n    if (magnitude >= MINIMUM_RESOLUTION) {\n      final double denom = 1.0 / magnitude;\n      A *= denom;\n      B *= denom;\n      C *= denom;\n\n      // cos ra = A/sqrt(A^2+B^2+C^2)\n      // sin ra = -B/sqrt(A^2+B^2+C^2)\n      // cos (-ra) = A/sqrt(A^2+B^2+C^2)\n      // sin (-ra) = B/sqrt(A^2+B^2+C^2)\n      final double xyMagnitude = Math.sqrt(A * A + B * B);\n      if (xyMagnitude >= MINIMUM_RESOLUTION) {\n        final double xyDenom = 1.0 / xyMagnitude;\n        cosRA = A * xyDenom;\n        sinRA = -B * xyDenom;\n      } else {\n        cosRA = 1.0;\n        sinRA = 0.0;\n      }\n\n      // sin(ha) = cos(asin(C/sqrt(A^2+B^2+C^2))) = sqrt(1 - C^2/(A^2+B^2+C^2)) = sqrt(A^2+B^2)/sqrt(A^2+B^2+C^2)\n      // cos(ha) = sin(asin(C/sqrt(A^2+B^2+C^2))) = C/sqrt(A^2+B^2+C^2)\n      sinHA = xyMagnitude;\n      cosHA = C;\n    } else {\n      cosRA = 1.0;\n      sinRA = 0.0;\n      cosHA = 1.0;\n      sinHA = 0.0;\n    }\n\n    // Forward-translate the start and end points\n    final Vector modifiedStart = modify(start, transX, transY, transZ, sinRA, cosRA, sinHA, cosHA);\n    final Vector modifiedEnd = modify(end, transX, transY, transZ, sinRA, cosRA, sinHA, cosHA);\n    if (Math.abs(modifiedStart.z) >= MINIMUM_RESOLUTION)\n      throw new IllegalArgumentException(\"Start point was not on plane: \" + modifiedStart.z);\n    if (Math.abs(modifiedEnd.z) >= MINIMUM_RESOLUTION)\n      throw new IllegalArgumentException(\"End point was not on plane: \" + modifiedEnd.z);\n\n    // Compute the angular distance between start and end point\n    final double startAngle = Math.atan2(modifiedStart.y, modifiedStart.x);\n    final double endAngle = Math.atan2(modifiedEnd.y, modifiedEnd.x);\n\n    final double startMagnitude = Math.sqrt(modifiedStart.x * modifiedStart.x + modifiedStart.y * modifiedStart.y);\n    double delta;\n\n    double newEndAngle = endAngle;\n    while (newEndAngle < startAngle) {\n      newEndAngle += Math.PI * 2.0;\n    }\n\n    if (newEndAngle - startAngle <= Math.PI) {\n      delta = newEndAngle - startAngle;\n    } else {\n      double newStartAngle = startAngle;\n      while (newStartAngle < endAngle) {\n        newStartAngle += Math.PI * 2.0;\n      }\n      delta = newStartAngle - endAngle;\n    }\n\n    final GeoPoint[] returnValues = new GeoPoint[proportions.length];\n    for (int i = 0; i < returnValues.length; i++) {\n      final double newAngle = startAngle + proportions[i] * delta;\n      final double sinNewAngle = Math.sin(newAngle);\n      final double cosNewAngle = Math.cos(newAngle);\n      final Vector newVector = new Vector(cosNewAngle * startMagnitude, sinNewAngle * startMagnitude, 0.0);\n      returnValues[i] = reverseModify(planetModel, newVector, transX, transY, transZ, sinRA, cosRA, sinHA, cosHA);\n    }\n\n    return returnValues;\n  }\n\n","sourceOld":"  /**\n   * Find points on the boundary of the intersection of a plane and the unit sphere,\n   * given a starting point, and ending point, and a list of proportions of the arc (e.g. 0.25, 0.5, 0.75).\n   * The angle between the starting point and ending point is assumed to be less than pi.\n   * @param start is the start point.\n   * @param end is the end point.\n   * @param proportions is an array of fractional proportions measured between start and end.\n   * @return an array of points corresponding to the proportions passed in.\n   */\n  public GeoPoint[] interpolate(final GeoPoint start, final GeoPoint end, final double[] proportions) {\n    // Steps:\n    // (1) Translate (x0,y0,z0) of endpoints into origin-centered place:\n    // x1 = x0 + D*A\n    // y1 = y0 + D*B\n    // z1 = z0 + D*C\n    // (2) Rotate counterclockwise in x-y:\n    // ra = -atan2(B,A)\n    // x2 = x1 cos ra - y1 sin ra\n    // y2 = x1 sin ra + y1 cos ra\n    // z2 = z1\n    // Faster:\n    // cos ra = A/sqrt(A^2+B^2+C^2)\n    // sin ra = -B/sqrt(A^2+B^2+C^2)\n    // cos (-ra) = A/sqrt(A^2+B^2+C^2)\n    // sin (-ra) = B/sqrt(A^2+B^2+C^2)\n    // (3) Rotate clockwise in x-z:\n    // ha = pi/2 - asin(C/sqrt(A^2+B^2+C^2))\n    // x3 = x2 cos ha - z2 sin ha\n    // y3 = y2\n    // z3 = x2 sin ha + z2 cos ha\n    // At this point, z3 should be zero.\n    // Faster:\n    // sin(ha) = cos(asin(C/sqrt(A^2+B^2+C^2))) = sqrt(1 - C^2/(A^2+B^2+C^2)) = sqrt(A^2+B^2)/sqrt(A^2+B^2+C^2)\n    // cos(ha) = sin(asin(C/sqrt(A^2+B^2+C^2))) = C/sqrt(A^2+B^2+C^2)\n    // (4) Compute interpolations by getting longitudes of original points\n    // la = atan2(y3,x3)\n    // (5) Rotate new points (xN0, yN0, zN0) counter-clockwise in x-z:\n    // ha = -(pi - asin(C/sqrt(A^2+B^2+C^2)))\n    // xN1 = xN0 cos ha - zN0 sin ha\n    // yN1 = yN0\n    // zN1 = xN0 sin ha + zN0 cos ha\n    // (6) Rotate new points clockwise in x-y:\n    // ra = atan2(B,A)\n    // xN2 = xN1 cos ra - yN1 sin ra\n    // yN2 = xN1 sin ra + yN1 cos ra\n    // zN2 = zN1\n    // (7) Translate new points:\n    // xN3 = xN2 - D*A\n    // yN3 = yN2 - D*B\n    // zN3 = zN2 - D*C\n\n    // First, calculate the angles and their sin/cos values\n    double A = x;\n    double B = y;\n    double C = z;\n\n    // Translation amounts\n    final double transX = -D * A;\n    final double transY = -D * B;\n    final double transZ = -D * C;\n\n    double cosRA;\n    double sinRA;\n    double cosHA;\n    double sinHA;\n\n    double magnitude = magnitude();\n    if (magnitude >= MINIMUM_RESOLUTION) {\n      final double denom = 1.0 / magnitude;\n      A *= denom;\n      B *= denom;\n      C *= denom;\n\n      // cos ra = A/sqrt(A^2+B^2+C^2)\n      // sin ra = -B/sqrt(A^2+B^2+C^2)\n      // cos (-ra) = A/sqrt(A^2+B^2+C^2)\n      // sin (-ra) = B/sqrt(A^2+B^2+C^2)\n      final double xyMagnitude = Math.sqrt(A * A + B * B);\n      if (xyMagnitude >= MINIMUM_RESOLUTION) {\n        final double xyDenom = 1.0 / xyMagnitude;\n        cosRA = A * xyDenom;\n        sinRA = -B * xyDenom;\n      } else {\n        cosRA = 1.0;\n        sinRA = 0.0;\n      }\n\n      // sin(ha) = cos(asin(C/sqrt(A^2+B^2+C^2))) = sqrt(1 - C^2/(A^2+B^2+C^2)) = sqrt(A^2+B^2)/sqrt(A^2+B^2+C^2)\n      // cos(ha) = sin(asin(C/sqrt(A^2+B^2+C^2))) = C/sqrt(A^2+B^2+C^2)\n      sinHA = xyMagnitude;\n      cosHA = C;\n    } else {\n      cosRA = 1.0;\n      sinRA = 0.0;\n      cosHA = 1.0;\n      sinHA = 0.0;\n    }\n\n    // Forward-translate the start and end points\n    final Vector modifiedStart = modify(start, transX, transY, transZ, sinRA, cosRA, sinHA, cosHA);\n    final Vector modifiedEnd = modify(end, transX, transY, transZ, sinRA, cosRA, sinHA, cosHA);\n    if (Math.abs(modifiedStart.z) >= MINIMUM_RESOLUTION)\n      throw new IllegalArgumentException(\"Start point was not on plane: \" + modifiedStart.z);\n    if (Math.abs(modifiedEnd.z) >= MINIMUM_RESOLUTION)\n      throw new IllegalArgumentException(\"End point was not on plane: \" + modifiedEnd.z);\n\n    // Compute the angular distance between start and end point\n    final double startAngle = Math.atan2(modifiedStart.y, modifiedStart.x);\n    final double endAngle = Math.atan2(modifiedEnd.y, modifiedEnd.x);\n\n    final double startMagnitude = Math.sqrt(modifiedStart.x * modifiedStart.x + modifiedStart.y * modifiedStart.y);\n    double delta;\n\n    double newEndAngle = endAngle;\n    while (newEndAngle < startAngle) {\n      newEndAngle += Math.PI * 2.0;\n    }\n\n    if (newEndAngle - startAngle <= Math.PI) {\n      delta = newEndAngle - startAngle;\n    } else {\n      double newStartAngle = startAngle;\n      while (newStartAngle < endAngle) {\n        newStartAngle += Math.PI * 2.0;\n      }\n      delta = newStartAngle - endAngle;\n    }\n\n    final GeoPoint[] returnValues = new GeoPoint[proportions.length];\n    for (int i = 0; i < returnValues.length; i++) {\n      final double newAngle = startAngle + proportions[i] * delta;\n      final double sinNewAngle = Math.sin(newAngle);\n      final double cosNewAngle = Math.cos(newAngle);\n      final Vector newVector = new Vector(cosNewAngle * startMagnitude, sinNewAngle * startMagnitude, 0.0);\n      returnValues[i] = reverseModify(newVector, transX, transY, transZ, sinRA, cosRA, sinHA, cosHA);\n    }\n\n    return returnValues;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":0,"author":"Michael Braun","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#interpolate(PlanetModel,GeoPoint,GeoPoint,double[]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Find points on the boundary of the intersection of a plane and the unit sphere,\n   * given a starting point, and ending point, and a list of proportions of the arc (e.g. 0.25, 0.5, 0.75).\n   * The angle between the starting point and ending point is assumed to be less than pi.\n   * @param planetModel is the planet model.\n   * @param start is the start point.\n   * @param end is the end point.\n   * @param proportions is an array of fractional proportions measured between start and end.\n   * @return an array of points corresponding to the proportions passed in.\n   */\n  public GeoPoint[] interpolate(final PlanetModel planetModel, final GeoPoint start, final GeoPoint end, final double[] proportions) {\n    // Steps:\n    // (1) Translate (x0,y0,z0) of endpoints into origin-centered place:\n    // x1 = x0 + D*A\n    // y1 = y0 + D*B\n    // z1 = z0 + D*C\n    // (2) Rotate counterclockwise in x-y:\n    // ra = -atan2(B,A)\n    // x2 = x1 cos ra - y1 sin ra\n    // y2 = x1 sin ra + y1 cos ra\n    // z2 = z1\n    // Faster:\n    // cos ra = A/sqrt(A^2+B^2+C^2)\n    // sin ra = -B/sqrt(A^2+B^2+C^2)\n    // cos (-ra) = A/sqrt(A^2+B^2+C^2)\n    // sin (-ra) = B/sqrt(A^2+B^2+C^2)\n    // (3) Rotate clockwise in x-z:\n    // ha = pi/2 - asin(C/sqrt(A^2+B^2+C^2))\n    // x3 = x2 cos ha - z2 sin ha\n    // y3 = y2\n    // z3 = x2 sin ha + z2 cos ha\n    // At this point, z3 should be zero.\n    // Faster:\n    // sin(ha) = cos(asin(C/sqrt(A^2+B^2+C^2))) = sqrt(1 - C^2/(A^2+B^2+C^2)) = sqrt(A^2+B^2)/sqrt(A^2+B^2+C^2)\n    // cos(ha) = sin(asin(C/sqrt(A^2+B^2+C^2))) = C/sqrt(A^2+B^2+C^2)\n    // (4) Compute interpolations by getting longitudes of original points\n    // la = atan2(y3,x3)\n    // (5) Rotate new points (xN0, yN0, zN0) counter-clockwise in x-z:\n    // ha = -(pi - asin(C/sqrt(A^2+B^2+C^2)))\n    // xN1 = xN0 cos ha - zN0 sin ha\n    // yN1 = yN0\n    // zN1 = xN0 sin ha + zN0 cos ha\n    // (6) Rotate new points clockwise in x-y:\n    // ra = atan2(B,A)\n    // xN2 = xN1 cos ra - yN1 sin ra\n    // yN2 = xN1 sin ra + yN1 cos ra\n    // zN2 = zN1\n    // (7) Translate new points:\n    // xN3 = xN2 - D*A\n    // yN3 = yN2 - D*B\n    // zN3 = zN2 - D*C\n\n    // First, calculate the angles and their sin/cos values\n    double A = x;\n    double B = y;\n    double C = z;\n\n    // Translation amounts\n    final double transX = -D * A;\n    final double transY = -D * B;\n    final double transZ = -D * C;\n\n    double cosRA;\n    double sinRA;\n    double cosHA;\n    double sinHA;\n\n    double magnitude = magnitude();\n    if (magnitude >= MINIMUM_RESOLUTION) {\n      final double denom = 1.0 / magnitude;\n      A *= denom;\n      B *= denom;\n      C *= denom;\n\n      // cos ra = A/sqrt(A^2+B^2+C^2)\n      // sin ra = -B/sqrt(A^2+B^2+C^2)\n      // cos (-ra) = A/sqrt(A^2+B^2+C^2)\n      // sin (-ra) = B/sqrt(A^2+B^2+C^2)\n      final double xyMagnitude = Math.sqrt(A * A + B * B);\n      if (xyMagnitude >= MINIMUM_RESOLUTION) {\n        final double xyDenom = 1.0 / xyMagnitude;\n        cosRA = A * xyDenom;\n        sinRA = -B * xyDenom;\n      } else {\n        cosRA = 1.0;\n        sinRA = 0.0;\n      }\n\n      // sin(ha) = cos(asin(C/sqrt(A^2+B^2+C^2))) = sqrt(1 - C^2/(A^2+B^2+C^2)) = sqrt(A^2+B^2)/sqrt(A^2+B^2+C^2)\n      // cos(ha) = sin(asin(C/sqrt(A^2+B^2+C^2))) = C/sqrt(A^2+B^2+C^2)\n      sinHA = xyMagnitude;\n      cosHA = C;\n    } else {\n      cosRA = 1.0;\n      sinRA = 0.0;\n      cosHA = 1.0;\n      sinHA = 0.0;\n    }\n\n    // Forward-translate the start and end points\n    final Vector modifiedStart = modify(start, transX, transY, transZ, sinRA, cosRA, sinHA, cosHA);\n    final Vector modifiedEnd = modify(end, transX, transY, transZ, sinRA, cosRA, sinHA, cosHA);\n    if (Math.abs(modifiedStart.z) >= MINIMUM_RESOLUTION)\n      throw new IllegalArgumentException(\"Start point was not on plane: \" + modifiedStart.z);\n    if (Math.abs(modifiedEnd.z) >= MINIMUM_RESOLUTION)\n      throw new IllegalArgumentException(\"End point was not on plane: \" + modifiedEnd.z);\n\n    // Compute the angular distance between start and end point\n    final double startAngle = Math.atan2(modifiedStart.y, modifiedStart.x);\n    final double endAngle = Math.atan2(modifiedEnd.y, modifiedEnd.x);\n\n    final double startMagnitude = Math.sqrt(modifiedStart.x * modifiedStart.x + modifiedStart.y * modifiedStart.y);\n    double delta;\n\n    double newEndAngle = endAngle;\n    while (newEndAngle < startAngle) {\n      newEndAngle += Math.PI * 2.0;\n    }\n\n    if (newEndAngle - startAngle <= Math.PI) {\n      delta = newEndAngle - startAngle;\n    } else {\n      double newStartAngle = startAngle;\n      while (newStartAngle < endAngle) {\n        newStartAngle += Math.PI * 2.0;\n      }\n      delta = newStartAngle - endAngle;\n    }\n\n    final GeoPoint[] returnValues = new GeoPoint[proportions.length];\n    for (int i = 0; i < returnValues.length; i++) {\n      final double newAngle = startAngle + proportions[i] * delta;\n      final double sinNewAngle = Math.sin(newAngle);\n      final double cosNewAngle = Math.cos(newAngle);\n      final Vector newVector = new Vector(cosNewAngle * startMagnitude, sinNewAngle * startMagnitude, 0.0);\n      returnValues[i] = reverseModify(planetModel, newVector, transX, transY, transZ, sinRA, cosRA, sinHA, cosHA);\n    }\n\n    return returnValues;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":0,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#interpolate(PlanetModel,GeoPoint,GeoPoint,double[]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Find points on the boundary of the intersection of a plane and the unit sphere,\n   * given a starting point, and ending point, and a list of proportions of the arc (e.g. 0.25, 0.5, 0.75).\n   * The angle between the starting point and ending point is assumed to be less than pi.\n   * @param planetModel is the planet model.\n   * @param start is the start point.\n   * @param end is the end point.\n   * @param proportions is an array of fractional proportions measured between start and end.\n   * @return an array of points corresponding to the proportions passed in.\n   */\n  public GeoPoint[] interpolate(final PlanetModel planetModel, final GeoPoint start, final GeoPoint end, final double[] proportions) {\n    // Steps:\n    // (1) Translate (x0,y0,z0) of endpoints into origin-centered place:\n    // x1 = x0 + D*A\n    // y1 = y0 + D*B\n    // z1 = z0 + D*C\n    // (2) Rotate counterclockwise in x-y:\n    // ra = -atan2(B,A)\n    // x2 = x1 cos ra - y1 sin ra\n    // y2 = x1 sin ra + y1 cos ra\n    // z2 = z1\n    // Faster:\n    // cos ra = A/sqrt(A^2+B^2+C^2)\n    // sin ra = -B/sqrt(A^2+B^2+C^2)\n    // cos (-ra) = A/sqrt(A^2+B^2+C^2)\n    // sin (-ra) = B/sqrt(A^2+B^2+C^2)\n    // (3) Rotate clockwise in x-z:\n    // ha = pi/2 - asin(C/sqrt(A^2+B^2+C^2))\n    // x3 = x2 cos ha - z2 sin ha\n    // y3 = y2\n    // z3 = x2 sin ha + z2 cos ha\n    // At this point, z3 should be zero.\n    // Faster:\n    // sin(ha) = cos(asin(C/sqrt(A^2+B^2+C^2))) = sqrt(1 - C^2/(A^2+B^2+C^2)) = sqrt(A^2+B^2)/sqrt(A^2+B^2+C^2)\n    // cos(ha) = sin(asin(C/sqrt(A^2+B^2+C^2))) = C/sqrt(A^2+B^2+C^2)\n    // (4) Compute interpolations by getting longitudes of original points\n    // la = atan2(y3,x3)\n    // (5) Rotate new points (xN0, yN0, zN0) counter-clockwise in x-z:\n    // ha = -(pi - asin(C/sqrt(A^2+B^2+C^2)))\n    // xN1 = xN0 cos ha - zN0 sin ha\n    // yN1 = yN0\n    // zN1 = xN0 sin ha + zN0 cos ha\n    // (6) Rotate new points clockwise in x-y:\n    // ra = atan2(B,A)\n    // xN2 = xN1 cos ra - yN1 sin ra\n    // yN2 = xN1 sin ra + yN1 cos ra\n    // zN2 = zN1\n    // (7) Translate new points:\n    // xN3 = xN2 - D*A\n    // yN3 = yN2 - D*B\n    // zN3 = zN2 - D*C\n\n    // First, calculate the angles and their sin/cos values\n    double A = x;\n    double B = y;\n    double C = z;\n\n    // Translation amounts\n    final double transX = -D * A;\n    final double transY = -D * B;\n    final double transZ = -D * C;\n\n    double cosRA;\n    double sinRA;\n    double cosHA;\n    double sinHA;\n\n    double magnitude = magnitude();\n    if (magnitude >= MINIMUM_RESOLUTION) {\n      final double denom = 1.0 / magnitude;\n      A *= denom;\n      B *= denom;\n      C *= denom;\n\n      // cos ra = A/sqrt(A^2+B^2+C^2)\n      // sin ra = -B/sqrt(A^2+B^2+C^2)\n      // cos (-ra) = A/sqrt(A^2+B^2+C^2)\n      // sin (-ra) = B/sqrt(A^2+B^2+C^2)\n      final double xyMagnitude = Math.sqrt(A * A + B * B);\n      if (xyMagnitude >= MINIMUM_RESOLUTION) {\n        final double xyDenom = 1.0 / xyMagnitude;\n        cosRA = A * xyDenom;\n        sinRA = -B * xyDenom;\n      } else {\n        cosRA = 1.0;\n        sinRA = 0.0;\n      }\n\n      // sin(ha) = cos(asin(C/sqrt(A^2+B^2+C^2))) = sqrt(1 - C^2/(A^2+B^2+C^2)) = sqrt(A^2+B^2)/sqrt(A^2+B^2+C^2)\n      // cos(ha) = sin(asin(C/sqrt(A^2+B^2+C^2))) = C/sqrt(A^2+B^2+C^2)\n      sinHA = xyMagnitude;\n      cosHA = C;\n    } else {\n      cosRA = 1.0;\n      sinRA = 0.0;\n      cosHA = 1.0;\n      sinHA = 0.0;\n    }\n\n    // Forward-translate the start and end points\n    final Vector modifiedStart = modify(start, transX, transY, transZ, sinRA, cosRA, sinHA, cosHA);\n    final Vector modifiedEnd = modify(end, transX, transY, transZ, sinRA, cosRA, sinHA, cosHA);\n    if (Math.abs(modifiedStart.z) >= MINIMUM_RESOLUTION)\n      throw new IllegalArgumentException(\"Start point was not on plane: \" + modifiedStart.z);\n    if (Math.abs(modifiedEnd.z) >= MINIMUM_RESOLUTION)\n      throw new IllegalArgumentException(\"End point was not on plane: \" + modifiedEnd.z);\n\n    // Compute the angular distance between start and end point\n    final double startAngle = Math.atan2(modifiedStart.y, modifiedStart.x);\n    final double endAngle = Math.atan2(modifiedEnd.y, modifiedEnd.x);\n\n    final double startMagnitude = Math.sqrt(modifiedStart.x * modifiedStart.x + modifiedStart.y * modifiedStart.y);\n    double delta;\n\n    double newEndAngle = endAngle;\n    while (newEndAngle < startAngle) {\n      newEndAngle += Math.PI * 2.0;\n    }\n\n    if (newEndAngle - startAngle <= Math.PI) {\n      delta = newEndAngle - startAngle;\n    } else {\n      double newStartAngle = startAngle;\n      while (newStartAngle < endAngle) {\n        newStartAngle += Math.PI * 2.0;\n      }\n      delta = newStartAngle - endAngle;\n    }\n\n    final GeoPoint[] returnValues = new GeoPoint[proportions.length];\n    for (int i = 0; i < returnValues.length; i++) {\n      final double newAngle = startAngle + proportions[i] * delta;\n      final double sinNewAngle = Math.sin(newAngle);\n      final double cosNewAngle = Math.cos(newAngle);\n      final Vector newVector = new Vector(cosNewAngle * startMagnitude, sinNewAngle * startMagnitude, 0.0);\n      returnValues[i] = reverseModify(planetModel, newVector, transX, transY, transZ, sinRA, cosRA, sinHA, cosHA);\n    }\n\n    return returnValues;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ec544d8bab0522461529d7ba4fbe68c09cf4793f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ec544d8bab0522461529d7ba4fbe68c09cf4793f"],"ec544d8bab0522461529d7ba4fbe68c09cf4793f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ec544d8bab0522461529d7ba4fbe68c09cf4793f"]},"commit2Childs":{"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","ec544d8bab0522461529d7ba4fbe68c09cf4793f","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"ec544d8bab0522461529d7ba4fbe68c09cf4793f":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}