{"path":"lucene/analysis/common/src/java/org/apache/lucene/analysis/synonym/FlattenGraphFilter#releaseBufferedToken().mjava","commits":[{"id":"24a98f5fdd23e04f85819dbc63b47a12f7c44311","date":1482439157,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/synonym/FlattenGraphFilter#releaseBufferedToken().mjava","pathOld":"/dev/null","sourceNew":"  private boolean releaseBufferedToken() {\n\n    // We only need the while loop (retry) if we have a hole (an output node that has no tokens leaving):\n    while (outputFrom < outputNodes.getMaxPos()) {\n      OutputNode output = outputNodes.get(outputFrom);\n      if (output.inputNodes.isEmpty()) {\n        // No tokens arrived to this node, which happens for the first node\n        // after a hole:\n        //System.out.println(\"    skip empty outputFrom=\" + outputFrom);\n        outputFrom++;\n        continue;\n      }\n\n      int maxToNode = -1;\n      for(int inputNodeID : output.inputNodes) {\n        InputNode inputNode = inputNodes.get(inputNodeID);\n        assert inputNode.outputNode == outputFrom;\n        maxToNode = Math.max(maxToNode, inputNode.maxToNode);\n      }\n      //System.out.println(\"  release maxToNode=\" + maxToNode + \" vs inputFrom=\" + inputFrom);\n\n      // TODO: we could shrink the frontier here somewhat if we\n      // always output posLen=1 as part of our \"sausagizing\":\n      if (maxToNode <= inputFrom || done) {\n        //System.out.println(\"  output node merged these inputs: \" + output.inputNodes);\n        // These tokens are now frozen\n        assert output.nextOut < output.inputNodes.size(): \"output.nextOut=\" + output.nextOut + \" vs output.inputNodes.size()=\" + output.inputNodes.size();\n        InputNode inputNode = inputNodes.get(output.inputNodes.get(output.nextOut));\n        if (done && inputNode.tokens.size() == 0 && outputFrom >= outputNodes.getMaxPos()) {\n          return false;\n        }\n        if (inputNode.tokens.size() == 0) {\n          assert inputNode.nextOut == 0;\n          assert output.nextOut == 0;\n          // Hole dest nodes should never be merged since 1) we always\n          // assign them to a new output position, and 2) since they never\n          // have arriving tokens they cannot be pushed:\n          assert output.inputNodes.size() == 1: output.inputNodes.size();\n          outputFrom++;\n          inputNodes.freeBefore(output.inputNodes.get(0));\n          outputNodes.freeBefore(outputFrom);\n          continue;\n        }\n\n        assert inputNode.nextOut < inputNode.tokens.size();\n\n        restoreState(inputNode.tokens.get(inputNode.nextOut));\n\n        // Correct posInc\n        assert outputFrom >= lastOutputFrom;\n        posIncAtt.setPositionIncrement(outputFrom - lastOutputFrom);\n        int toInputNodeID = inputNode.node + posLenAtt.getPositionLength();\n        InputNode toInputNode = inputNodes.get(toInputNodeID);\n\n        // Correct posLen\n        assert toInputNode.outputNode > outputFrom;\n        posLenAtt.setPositionLength(toInputNode.outputNode - outputFrom);\n        lastOutputFrom = outputFrom;\n        inputNode.nextOut++;\n        //System.out.println(\"  ret \" + this);\n\n        OutputNode outputEndNode = outputNodes.get(toInputNode.outputNode);\n\n        // Correct offsets\n\n        // This is a bit messy; we must do this so offset don't go backwards,\n        // which would otherwise happen if the replacement has more tokens\n        // than the input:\n        int startOffset = Math.max(lastStartOffset, output.startOffset);\n        offsetAtt.setOffset(startOffset, outputEndNode.endOffset);\n        lastStartOffset = startOffset;\n\n        if (inputNode.nextOut == inputNode.tokens.size()) {\n          output.nextOut++;\n          if (output.nextOut == output.inputNodes.size()) {\n            outputFrom++;\n            inputNodes.freeBefore(output.inputNodes.get(0));\n            outputNodes.freeBefore(outputFrom);\n          }\n        }\n\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    //System.out.println(\"    break false\");\n    return false;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"91ce9dc05b3127c8d17a5f8ff109f35e5f625c27","date":1483444067,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/synonym/FlattenGraphFilter#releaseBufferedToken().mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/synonym/FlattenGraphFilter#releaseBufferedToken().mjava","sourceNew":"  private boolean releaseBufferedToken() {\n\n    // We only need the while loop (retry) if we have a hole (an output node that has no tokens leaving):\n    while (outputFrom < outputNodes.getMaxPos()) {\n      OutputNode output = outputNodes.get(outputFrom);\n      if (output.inputNodes.isEmpty()) {\n        // No tokens arrived to this node, which happens for the first node\n        // after a hole:\n        //System.out.println(\"    skip empty outputFrom=\" + outputFrom);\n        outputFrom++;\n        continue;\n      }\n\n      int maxToNode = -1;\n      for(int inputNodeID : output.inputNodes) {\n        InputNode inputNode = inputNodes.get(inputNodeID);\n        assert inputNode.outputNode == outputFrom;\n        maxToNode = Math.max(maxToNode, inputNode.maxToNode);\n      }\n      //System.out.println(\"  release maxToNode=\" + maxToNode + \" vs inputFrom=\" + inputFrom);\n\n      // TODO: we could shrink the frontier here somewhat if we\n      // always output posLen=1 as part of our \"sausagizing\":\n      if (maxToNode <= inputFrom || done) {\n        //System.out.println(\"  output node merged these inputs: \" + output.inputNodes);\n        // These tokens are now frozen\n        assert output.nextOut < output.inputNodes.size(): \"output.nextOut=\" + output.nextOut + \" vs output.inputNodes.size()=\" + output.inputNodes.size();\n        InputNode inputNode = inputNodes.get(output.inputNodes.get(output.nextOut));\n        if (done && inputNode.tokens.size() == 0 && outputFrom >= outputNodes.getMaxPos()) {\n          return false;\n        }\n        if (inputNode.tokens.size() == 0) {\n          assert inputNode.nextOut == 0;\n          assert output.nextOut == 0;\n          // Hole dest nodes should never be merged since 1) we always\n          // assign them to a new output position, and 2) since they never\n          // have arriving tokens they cannot be pushed:\n          assert output.inputNodes.size() == 1: output.inputNodes.size();\n          outputFrom++;\n          inputNodes.freeBefore(output.inputNodes.get(0));\n          outputNodes.freeBefore(outputFrom);\n          continue;\n        }\n\n        assert inputNode.nextOut < inputNode.tokens.size();\n\n        restoreState(inputNode.tokens.get(inputNode.nextOut));\n\n        // Correct posInc\n        assert outputFrom >= lastOutputFrom;\n        posIncAtt.setPositionIncrement(outputFrom - lastOutputFrom);\n        int toInputNodeID = inputNode.node + posLenAtt.getPositionLength();\n        InputNode toInputNode = inputNodes.get(toInputNodeID);\n\n        // Correct posLen\n        assert toInputNode.outputNode > outputFrom;\n        posLenAtt.setPositionLength(toInputNode.outputNode - outputFrom);\n        lastOutputFrom = outputFrom;\n        inputNode.nextOut++;\n        //System.out.println(\"  ret \" + this);\n\n        OutputNode outputEndNode = outputNodes.get(toInputNode.outputNode);\n\n        // Correct offsets\n\n        // This is a bit messy; we must do this so offset don't go backwards,\n        // which would otherwise happen if the replacement has more tokens\n        // than the input:\n        int startOffset = Math.max(lastStartOffset, output.startOffset);\n\n        // We must do this in case the incoming tokens have broken offsets:\n        int endOffset = Math.max(startOffset, outputEndNode.endOffset);\n        \n        offsetAtt.setOffset(startOffset, endOffset);\n        lastStartOffset = startOffset;\n\n        if (inputNode.nextOut == inputNode.tokens.size()) {\n          output.nextOut++;\n          if (output.nextOut == output.inputNodes.size()) {\n            outputFrom++;\n            inputNodes.freeBefore(output.inputNodes.get(0));\n            outputNodes.freeBefore(outputFrom);\n          }\n        }\n\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    //System.out.println(\"    break false\");\n    return false;\n  }\n\n","sourceOld":"  private boolean releaseBufferedToken() {\n\n    // We only need the while loop (retry) if we have a hole (an output node that has no tokens leaving):\n    while (outputFrom < outputNodes.getMaxPos()) {\n      OutputNode output = outputNodes.get(outputFrom);\n      if (output.inputNodes.isEmpty()) {\n        // No tokens arrived to this node, which happens for the first node\n        // after a hole:\n        //System.out.println(\"    skip empty outputFrom=\" + outputFrom);\n        outputFrom++;\n        continue;\n      }\n\n      int maxToNode = -1;\n      for(int inputNodeID : output.inputNodes) {\n        InputNode inputNode = inputNodes.get(inputNodeID);\n        assert inputNode.outputNode == outputFrom;\n        maxToNode = Math.max(maxToNode, inputNode.maxToNode);\n      }\n      //System.out.println(\"  release maxToNode=\" + maxToNode + \" vs inputFrom=\" + inputFrom);\n\n      // TODO: we could shrink the frontier here somewhat if we\n      // always output posLen=1 as part of our \"sausagizing\":\n      if (maxToNode <= inputFrom || done) {\n        //System.out.println(\"  output node merged these inputs: \" + output.inputNodes);\n        // These tokens are now frozen\n        assert output.nextOut < output.inputNodes.size(): \"output.nextOut=\" + output.nextOut + \" vs output.inputNodes.size()=\" + output.inputNodes.size();\n        InputNode inputNode = inputNodes.get(output.inputNodes.get(output.nextOut));\n        if (done && inputNode.tokens.size() == 0 && outputFrom >= outputNodes.getMaxPos()) {\n          return false;\n        }\n        if (inputNode.tokens.size() == 0) {\n          assert inputNode.nextOut == 0;\n          assert output.nextOut == 0;\n          // Hole dest nodes should never be merged since 1) we always\n          // assign them to a new output position, and 2) since they never\n          // have arriving tokens they cannot be pushed:\n          assert output.inputNodes.size() == 1: output.inputNodes.size();\n          outputFrom++;\n          inputNodes.freeBefore(output.inputNodes.get(0));\n          outputNodes.freeBefore(outputFrom);\n          continue;\n        }\n\n        assert inputNode.nextOut < inputNode.tokens.size();\n\n        restoreState(inputNode.tokens.get(inputNode.nextOut));\n\n        // Correct posInc\n        assert outputFrom >= lastOutputFrom;\n        posIncAtt.setPositionIncrement(outputFrom - lastOutputFrom);\n        int toInputNodeID = inputNode.node + posLenAtt.getPositionLength();\n        InputNode toInputNode = inputNodes.get(toInputNodeID);\n\n        // Correct posLen\n        assert toInputNode.outputNode > outputFrom;\n        posLenAtt.setPositionLength(toInputNode.outputNode - outputFrom);\n        lastOutputFrom = outputFrom;\n        inputNode.nextOut++;\n        //System.out.println(\"  ret \" + this);\n\n        OutputNode outputEndNode = outputNodes.get(toInputNode.outputNode);\n\n        // Correct offsets\n\n        // This is a bit messy; we must do this so offset don't go backwards,\n        // which would otherwise happen if the replacement has more tokens\n        // than the input:\n        int startOffset = Math.max(lastStartOffset, output.startOffset);\n        offsetAtt.setOffset(startOffset, outputEndNode.endOffset);\n        lastStartOffset = startOffset;\n\n        if (inputNode.nextOut == inputNode.tokens.size()) {\n          output.nextOut++;\n          if (output.nextOut == output.inputNodes.size()) {\n            outputFrom++;\n            inputNodes.freeBefore(output.inputNodes.get(0));\n            outputNodes.freeBefore(outputFrom);\n          }\n        }\n\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    //System.out.println(\"    break false\");\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f03e4bed5023ec3ef93a771b8888cae991cf448d","date":1483469262,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/synonym/FlattenGraphFilter#releaseBufferedToken().mjava","pathOld":"/dev/null","sourceNew":"  private boolean releaseBufferedToken() {\n\n    // We only need the while loop (retry) if we have a hole (an output node that has no tokens leaving):\n    while (outputFrom < outputNodes.getMaxPos()) {\n      OutputNode output = outputNodes.get(outputFrom);\n      if (output.inputNodes.isEmpty()) {\n        // No tokens arrived to this node, which happens for the first node\n        // after a hole:\n        //System.out.println(\"    skip empty outputFrom=\" + outputFrom);\n        outputFrom++;\n        continue;\n      }\n\n      int maxToNode = -1;\n      for(int inputNodeID : output.inputNodes) {\n        InputNode inputNode = inputNodes.get(inputNodeID);\n        assert inputNode.outputNode == outputFrom;\n        maxToNode = Math.max(maxToNode, inputNode.maxToNode);\n      }\n      //System.out.println(\"  release maxToNode=\" + maxToNode + \" vs inputFrom=\" + inputFrom);\n\n      // TODO: we could shrink the frontier here somewhat if we\n      // always output posLen=1 as part of our \"sausagizing\":\n      if (maxToNode <= inputFrom || done) {\n        //System.out.println(\"  output node merged these inputs: \" + output.inputNodes);\n        // These tokens are now frozen\n        assert output.nextOut < output.inputNodes.size(): \"output.nextOut=\" + output.nextOut + \" vs output.inputNodes.size()=\" + output.inputNodes.size();\n        InputNode inputNode = inputNodes.get(output.inputNodes.get(output.nextOut));\n        if (done && inputNode.tokens.size() == 0 && outputFrom >= outputNodes.getMaxPos()) {\n          return false;\n        }\n        if (inputNode.tokens.size() == 0) {\n          assert inputNode.nextOut == 0;\n          assert output.nextOut == 0;\n          // Hole dest nodes should never be merged since 1) we always\n          // assign them to a new output position, and 2) since they never\n          // have arriving tokens they cannot be pushed:\n          assert output.inputNodes.size() == 1: output.inputNodes.size();\n          outputFrom++;\n          inputNodes.freeBefore(output.inputNodes.get(0));\n          outputNodes.freeBefore(outputFrom);\n          continue;\n        }\n\n        assert inputNode.nextOut < inputNode.tokens.size();\n\n        restoreState(inputNode.tokens.get(inputNode.nextOut));\n\n        // Correct posInc\n        assert outputFrom >= lastOutputFrom;\n        posIncAtt.setPositionIncrement(outputFrom - lastOutputFrom);\n        int toInputNodeID = inputNode.node + posLenAtt.getPositionLength();\n        InputNode toInputNode = inputNodes.get(toInputNodeID);\n\n        // Correct posLen\n        assert toInputNode.outputNode > outputFrom;\n        posLenAtt.setPositionLength(toInputNode.outputNode - outputFrom);\n        lastOutputFrom = outputFrom;\n        inputNode.nextOut++;\n        //System.out.println(\"  ret \" + this);\n\n        OutputNode outputEndNode = outputNodes.get(toInputNode.outputNode);\n\n        // Correct offsets\n\n        // This is a bit messy; we must do this so offset don't go backwards,\n        // which would otherwise happen if the replacement has more tokens\n        // than the input:\n        int startOffset = Math.max(lastStartOffset, output.startOffset);\n\n        // We must do this in case the incoming tokens have broken offsets:\n        int endOffset = Math.max(startOffset, outputEndNode.endOffset);\n        \n        offsetAtt.setOffset(startOffset, endOffset);\n        lastStartOffset = startOffset;\n\n        if (inputNode.nextOut == inputNode.tokens.size()) {\n          output.nextOut++;\n          if (output.nextOut == output.inputNodes.size()) {\n            outputFrom++;\n            inputNodes.freeBefore(output.inputNodes.get(0));\n            outputNodes.freeBefore(outputFrom);\n          }\n        }\n\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    //System.out.println(\"    break false\");\n    return false;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"098528909bb70948871fd7ed865fafb87ed73964","date":1484667487,"type":5,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/core/FlattenGraphFilter#releaseBufferedToken().mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/synonym/FlattenGraphFilter#releaseBufferedToken().mjava","sourceNew":"  private boolean releaseBufferedToken() {\n\n    // We only need the while loop (retry) if we have a hole (an output node that has no tokens leaving):\n    while (outputFrom < outputNodes.getMaxPos()) {\n      OutputNode output = outputNodes.get(outputFrom);\n      if (output.inputNodes.isEmpty()) {\n        // No tokens arrived to this node, which happens for the first node\n        // after a hole:\n        //System.out.println(\"    skip empty outputFrom=\" + outputFrom);\n        outputFrom++;\n        continue;\n      }\n\n      int maxToNode = -1;\n      for(int inputNodeID : output.inputNodes) {\n        InputNode inputNode = inputNodes.get(inputNodeID);\n        assert inputNode.outputNode == outputFrom;\n        maxToNode = Math.max(maxToNode, inputNode.maxToNode);\n      }\n      //System.out.println(\"  release maxToNode=\" + maxToNode + \" vs inputFrom=\" + inputFrom);\n\n      // TODO: we could shrink the frontier here somewhat if we\n      // always output posLen=1 as part of our \"sausagizing\":\n      if (maxToNode <= inputFrom || done) {\n        //System.out.println(\"  output node merged these inputs: \" + output.inputNodes);\n        // These tokens are now frozen\n        assert output.nextOut < output.inputNodes.size(): \"output.nextOut=\" + output.nextOut + \" vs output.inputNodes.size()=\" + output.inputNodes.size();\n        InputNode inputNode = inputNodes.get(output.inputNodes.get(output.nextOut));\n        if (done && inputNode.tokens.size() == 0 && outputFrom >= outputNodes.getMaxPos()) {\n          return false;\n        }\n        if (inputNode.tokens.size() == 0) {\n          assert inputNode.nextOut == 0;\n          assert output.nextOut == 0;\n          // Hole dest nodes should never be merged since 1) we always\n          // assign them to a new output position, and 2) since they never\n          // have arriving tokens they cannot be pushed:\n          assert output.inputNodes.size() == 1: output.inputNodes.size();\n          outputFrom++;\n          inputNodes.freeBefore(output.inputNodes.get(0));\n          outputNodes.freeBefore(outputFrom);\n          continue;\n        }\n\n        assert inputNode.nextOut < inputNode.tokens.size();\n\n        restoreState(inputNode.tokens.get(inputNode.nextOut));\n\n        // Correct posInc\n        assert outputFrom >= lastOutputFrom;\n        posIncAtt.setPositionIncrement(outputFrom - lastOutputFrom);\n        int toInputNodeID = inputNode.node + posLenAtt.getPositionLength();\n        InputNode toInputNode = inputNodes.get(toInputNodeID);\n\n        // Correct posLen\n        assert toInputNode.outputNode > outputFrom;\n        posLenAtt.setPositionLength(toInputNode.outputNode - outputFrom);\n        lastOutputFrom = outputFrom;\n        inputNode.nextOut++;\n        //System.out.println(\"  ret \" + this);\n\n        OutputNode outputEndNode = outputNodes.get(toInputNode.outputNode);\n\n        // Correct offsets\n\n        // This is a bit messy; we must do this so offset don't go backwards,\n        // which would otherwise happen if the replacement has more tokens\n        // than the input:\n        int startOffset = Math.max(lastStartOffset, output.startOffset);\n\n        // We must do this in case the incoming tokens have broken offsets:\n        int endOffset = Math.max(startOffset, outputEndNode.endOffset);\n        \n        offsetAtt.setOffset(startOffset, endOffset);\n        lastStartOffset = startOffset;\n\n        if (inputNode.nextOut == inputNode.tokens.size()) {\n          output.nextOut++;\n          if (output.nextOut == output.inputNodes.size()) {\n            outputFrom++;\n            inputNodes.freeBefore(output.inputNodes.get(0));\n            outputNodes.freeBefore(outputFrom);\n          }\n        }\n\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    //System.out.println(\"    break false\");\n    return false;\n  }\n\n","sourceOld":"  private boolean releaseBufferedToken() {\n\n    // We only need the while loop (retry) if we have a hole (an output node that has no tokens leaving):\n    while (outputFrom < outputNodes.getMaxPos()) {\n      OutputNode output = outputNodes.get(outputFrom);\n      if (output.inputNodes.isEmpty()) {\n        // No tokens arrived to this node, which happens for the first node\n        // after a hole:\n        //System.out.println(\"    skip empty outputFrom=\" + outputFrom);\n        outputFrom++;\n        continue;\n      }\n\n      int maxToNode = -1;\n      for(int inputNodeID : output.inputNodes) {\n        InputNode inputNode = inputNodes.get(inputNodeID);\n        assert inputNode.outputNode == outputFrom;\n        maxToNode = Math.max(maxToNode, inputNode.maxToNode);\n      }\n      //System.out.println(\"  release maxToNode=\" + maxToNode + \" vs inputFrom=\" + inputFrom);\n\n      // TODO: we could shrink the frontier here somewhat if we\n      // always output posLen=1 as part of our \"sausagizing\":\n      if (maxToNode <= inputFrom || done) {\n        //System.out.println(\"  output node merged these inputs: \" + output.inputNodes);\n        // These tokens are now frozen\n        assert output.nextOut < output.inputNodes.size(): \"output.nextOut=\" + output.nextOut + \" vs output.inputNodes.size()=\" + output.inputNodes.size();\n        InputNode inputNode = inputNodes.get(output.inputNodes.get(output.nextOut));\n        if (done && inputNode.tokens.size() == 0 && outputFrom >= outputNodes.getMaxPos()) {\n          return false;\n        }\n        if (inputNode.tokens.size() == 0) {\n          assert inputNode.nextOut == 0;\n          assert output.nextOut == 0;\n          // Hole dest nodes should never be merged since 1) we always\n          // assign them to a new output position, and 2) since they never\n          // have arriving tokens they cannot be pushed:\n          assert output.inputNodes.size() == 1: output.inputNodes.size();\n          outputFrom++;\n          inputNodes.freeBefore(output.inputNodes.get(0));\n          outputNodes.freeBefore(outputFrom);\n          continue;\n        }\n\n        assert inputNode.nextOut < inputNode.tokens.size();\n\n        restoreState(inputNode.tokens.get(inputNode.nextOut));\n\n        // Correct posInc\n        assert outputFrom >= lastOutputFrom;\n        posIncAtt.setPositionIncrement(outputFrom - lastOutputFrom);\n        int toInputNodeID = inputNode.node + posLenAtt.getPositionLength();\n        InputNode toInputNode = inputNodes.get(toInputNodeID);\n\n        // Correct posLen\n        assert toInputNode.outputNode > outputFrom;\n        posLenAtt.setPositionLength(toInputNode.outputNode - outputFrom);\n        lastOutputFrom = outputFrom;\n        inputNode.nextOut++;\n        //System.out.println(\"  ret \" + this);\n\n        OutputNode outputEndNode = outputNodes.get(toInputNode.outputNode);\n\n        // Correct offsets\n\n        // This is a bit messy; we must do this so offset don't go backwards,\n        // which would otherwise happen if the replacement has more tokens\n        // than the input:\n        int startOffset = Math.max(lastStartOffset, output.startOffset);\n\n        // We must do this in case the incoming tokens have broken offsets:\n        int endOffset = Math.max(startOffset, outputEndNode.endOffset);\n        \n        offsetAtt.setOffset(startOffset, endOffset);\n        lastStartOffset = startOffset;\n\n        if (inputNode.nextOut == inputNode.tokens.size()) {\n          output.nextOut++;\n          if (output.nextOut == output.inputNodes.size()) {\n            outputFrom++;\n            inputNodes.freeBefore(output.inputNodes.get(0));\n            outputNodes.freeBefore(outputFrom);\n          }\n        }\n\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    //System.out.println(\"    break false\");\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"302d34f2c66e8d489ee13078305c330cbf67b226","date":1484754357,"type":5,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/core/FlattenGraphFilter#releaseBufferedToken().mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/synonym/FlattenGraphFilter#releaseBufferedToken().mjava","sourceNew":"  private boolean releaseBufferedToken() {\n\n    // We only need the while loop (retry) if we have a hole (an output node that has no tokens leaving):\n    while (outputFrom < outputNodes.getMaxPos()) {\n      OutputNode output = outputNodes.get(outputFrom);\n      if (output.inputNodes.isEmpty()) {\n        // No tokens arrived to this node, which happens for the first node\n        // after a hole:\n        //System.out.println(\"    skip empty outputFrom=\" + outputFrom);\n        outputFrom++;\n        continue;\n      }\n\n      int maxToNode = -1;\n      for(int inputNodeID : output.inputNodes) {\n        InputNode inputNode = inputNodes.get(inputNodeID);\n        assert inputNode.outputNode == outputFrom;\n        maxToNode = Math.max(maxToNode, inputNode.maxToNode);\n      }\n      //System.out.println(\"  release maxToNode=\" + maxToNode + \" vs inputFrom=\" + inputFrom);\n\n      // TODO: we could shrink the frontier here somewhat if we\n      // always output posLen=1 as part of our \"sausagizing\":\n      if (maxToNode <= inputFrom || done) {\n        //System.out.println(\"  output node merged these inputs: \" + output.inputNodes);\n        // These tokens are now frozen\n        assert output.nextOut < output.inputNodes.size(): \"output.nextOut=\" + output.nextOut + \" vs output.inputNodes.size()=\" + output.inputNodes.size();\n        InputNode inputNode = inputNodes.get(output.inputNodes.get(output.nextOut));\n        if (done && inputNode.tokens.size() == 0 && outputFrom >= outputNodes.getMaxPos()) {\n          return false;\n        }\n        if (inputNode.tokens.size() == 0) {\n          assert inputNode.nextOut == 0;\n          assert output.nextOut == 0;\n          // Hole dest nodes should never be merged since 1) we always\n          // assign them to a new output position, and 2) since they never\n          // have arriving tokens they cannot be pushed:\n          assert output.inputNodes.size() == 1: output.inputNodes.size();\n          outputFrom++;\n          inputNodes.freeBefore(output.inputNodes.get(0));\n          outputNodes.freeBefore(outputFrom);\n          continue;\n        }\n\n        assert inputNode.nextOut < inputNode.tokens.size();\n\n        restoreState(inputNode.tokens.get(inputNode.nextOut));\n\n        // Correct posInc\n        assert outputFrom >= lastOutputFrom;\n        posIncAtt.setPositionIncrement(outputFrom - lastOutputFrom);\n        int toInputNodeID = inputNode.node + posLenAtt.getPositionLength();\n        InputNode toInputNode = inputNodes.get(toInputNodeID);\n\n        // Correct posLen\n        assert toInputNode.outputNode > outputFrom;\n        posLenAtt.setPositionLength(toInputNode.outputNode - outputFrom);\n        lastOutputFrom = outputFrom;\n        inputNode.nextOut++;\n        //System.out.println(\"  ret \" + this);\n\n        OutputNode outputEndNode = outputNodes.get(toInputNode.outputNode);\n\n        // Correct offsets\n\n        // This is a bit messy; we must do this so offset don't go backwards,\n        // which would otherwise happen if the replacement has more tokens\n        // than the input:\n        int startOffset = Math.max(lastStartOffset, output.startOffset);\n\n        // We must do this in case the incoming tokens have broken offsets:\n        int endOffset = Math.max(startOffset, outputEndNode.endOffset);\n        \n        offsetAtt.setOffset(startOffset, endOffset);\n        lastStartOffset = startOffset;\n\n        if (inputNode.nextOut == inputNode.tokens.size()) {\n          output.nextOut++;\n          if (output.nextOut == output.inputNodes.size()) {\n            outputFrom++;\n            inputNodes.freeBefore(output.inputNodes.get(0));\n            outputNodes.freeBefore(outputFrom);\n          }\n        }\n\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    //System.out.println(\"    break false\");\n    return false;\n  }\n\n","sourceOld":"  private boolean releaseBufferedToken() {\n\n    // We only need the while loop (retry) if we have a hole (an output node that has no tokens leaving):\n    while (outputFrom < outputNodes.getMaxPos()) {\n      OutputNode output = outputNodes.get(outputFrom);\n      if (output.inputNodes.isEmpty()) {\n        // No tokens arrived to this node, which happens for the first node\n        // after a hole:\n        //System.out.println(\"    skip empty outputFrom=\" + outputFrom);\n        outputFrom++;\n        continue;\n      }\n\n      int maxToNode = -1;\n      for(int inputNodeID : output.inputNodes) {\n        InputNode inputNode = inputNodes.get(inputNodeID);\n        assert inputNode.outputNode == outputFrom;\n        maxToNode = Math.max(maxToNode, inputNode.maxToNode);\n      }\n      //System.out.println(\"  release maxToNode=\" + maxToNode + \" vs inputFrom=\" + inputFrom);\n\n      // TODO: we could shrink the frontier here somewhat if we\n      // always output posLen=1 as part of our \"sausagizing\":\n      if (maxToNode <= inputFrom || done) {\n        //System.out.println(\"  output node merged these inputs: \" + output.inputNodes);\n        // These tokens are now frozen\n        assert output.nextOut < output.inputNodes.size(): \"output.nextOut=\" + output.nextOut + \" vs output.inputNodes.size()=\" + output.inputNodes.size();\n        InputNode inputNode = inputNodes.get(output.inputNodes.get(output.nextOut));\n        if (done && inputNode.tokens.size() == 0 && outputFrom >= outputNodes.getMaxPos()) {\n          return false;\n        }\n        if (inputNode.tokens.size() == 0) {\n          assert inputNode.nextOut == 0;\n          assert output.nextOut == 0;\n          // Hole dest nodes should never be merged since 1) we always\n          // assign them to a new output position, and 2) since they never\n          // have arriving tokens they cannot be pushed:\n          assert output.inputNodes.size() == 1: output.inputNodes.size();\n          outputFrom++;\n          inputNodes.freeBefore(output.inputNodes.get(0));\n          outputNodes.freeBefore(outputFrom);\n          continue;\n        }\n\n        assert inputNode.nextOut < inputNode.tokens.size();\n\n        restoreState(inputNode.tokens.get(inputNode.nextOut));\n\n        // Correct posInc\n        assert outputFrom >= lastOutputFrom;\n        posIncAtt.setPositionIncrement(outputFrom - lastOutputFrom);\n        int toInputNodeID = inputNode.node + posLenAtt.getPositionLength();\n        InputNode toInputNode = inputNodes.get(toInputNodeID);\n\n        // Correct posLen\n        assert toInputNode.outputNode > outputFrom;\n        posLenAtt.setPositionLength(toInputNode.outputNode - outputFrom);\n        lastOutputFrom = outputFrom;\n        inputNode.nextOut++;\n        //System.out.println(\"  ret \" + this);\n\n        OutputNode outputEndNode = outputNodes.get(toInputNode.outputNode);\n\n        // Correct offsets\n\n        // This is a bit messy; we must do this so offset don't go backwards,\n        // which would otherwise happen if the replacement has more tokens\n        // than the input:\n        int startOffset = Math.max(lastStartOffset, output.startOffset);\n\n        // We must do this in case the incoming tokens have broken offsets:\n        int endOffset = Math.max(startOffset, outputEndNode.endOffset);\n        \n        offsetAtt.setOffset(startOffset, endOffset);\n        lastStartOffset = startOffset;\n\n        if (inputNode.nextOut == inputNode.tokens.size()) {\n          output.nextOut++;\n          if (output.nextOut == output.inputNodes.size()) {\n            outputFrom++;\n            inputNodes.freeBefore(output.inputNodes.get(0));\n            outputNodes.freeBefore(outputFrom);\n          }\n        }\n\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    //System.out.println(\"    break false\");\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"91ce9dc05b3127c8d17a5f8ff109f35e5f625c27":["24a98f5fdd23e04f85819dbc63b47a12f7c44311"],"098528909bb70948871fd7ed865fafb87ed73964":["91ce9dc05b3127c8d17a5f8ff109f35e5f625c27"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"24a98f5fdd23e04f85819dbc63b47a12f7c44311":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["098528909bb70948871fd7ed865fafb87ed73964"],"f03e4bed5023ec3ef93a771b8888cae991cf448d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","91ce9dc05b3127c8d17a5f8ff109f35e5f625c27"],"302d34f2c66e8d489ee13078305c330cbf67b226":["f03e4bed5023ec3ef93a771b8888cae991cf448d","098528909bb70948871fd7ed865fafb87ed73964"]},"commit2Childs":{"91ce9dc05b3127c8d17a5f8ff109f35e5f625c27":["098528909bb70948871fd7ed865fafb87ed73964","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"098528909bb70948871fd7ed865fafb87ed73964":["cd5edd1f2b162a5cfa08efd17851a07373a96817","302d34f2c66e8d489ee13078305c330cbf67b226"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["24a98f5fdd23e04f85819dbc63b47a12f7c44311","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"24a98f5fdd23e04f85819dbc63b47a12f7c44311":["91ce9dc05b3127c8d17a5f8ff109f35e5f625c27"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"f03e4bed5023ec3ef93a771b8888cae991cf448d":["302d34f2c66e8d489ee13078305c330cbf67b226"],"302d34f2c66e8d489ee13078305c330cbf67b226":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","302d34f2c66e8d489ee13078305c330cbf67b226"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}