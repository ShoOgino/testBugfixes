{"path":"solr/core/src/java/org/apache/solr/handler/admin/ZookeeperInfoHandler.ZKPrinter#printPaginatedCollections().mjava","commits":[{"id":"5ad9c35f926b4bf8da0336d1300efc709c8d5a56","date":1591729157,"type":0,"author":"murblanc","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ZookeeperInfoHandler.ZKPrinter#printPaginatedCollections().mjava","pathOld":"/dev/null","sourceNew":"    // main entry point for printing collections\n    @SuppressWarnings(\"unchecked\")\n    void printPaginatedCollections() throws IOException {\n      SortedMap<String, Object> collectionStates;\n      try {\n        // support paging of the collections graph view (in case there are many collections)\n        // fetch the requested page of collections and then retrieve the state for each\n        pagingSupport.fetchPage(page, zkClient);\n        // keep track of how many collections match the filter\n        boolean applyStatusFilter = (page.filterType == FilterType.status && page.filter != null);\n        List<String> matchesStatusFilter = applyStatusFilter ? new ArrayList<String>() : null;\n        Set<String> liveNodes = applyStatusFilter ?\n            zkController.getZkStateReader().getClusterState().getLiveNodes() : null;\n\n        collectionStates = new TreeMap<>(pagingSupport);\n        for (String collection : page.selected) {\n          // Get collection state from ZK\n          String collStatePath = String.format(Locale.ROOT, \"/collections/%s/state.json\", collection);\n          String childDataStr = null;\n          try {\n            byte[] childData = zkClient.getData(collStatePath, null, null, true);\n            if (childData != null)\n              childDataStr = (new BytesRef(childData)).utf8ToString();\n          } catch (KeeperException.NoNodeException nne) {\n            log.warn(\"State for collection {} not found.\", collection);\n          } catch (Exception childErr) {\n            log.error(\"Failed to get {} due to\", collStatePath, childErr);\n          }\n\n          if (childDataStr != null) {\n            Map<String, Object> extColl = (Map<String, Object>) Utils.fromJSONString(childDataStr);\n            Object collectionState = extColl.get(collection);\n\n            if (applyStatusFilter) {\n              // verify this collection matches the filtered state\n              if (page.matchesStatusFilter((Map<String, Object>) collectionState, liveNodes)) {\n                matchesStatusFilter.add(collection);\n                collectionStates.put(collection, collectionState);\n              }\n            } else {\n              collectionStates.put(collection, collectionState);\n            }\n          }\n        }\n\n        if (applyStatusFilter) {\n          // update the paged navigation info after applying the status filter\n          page.selectPage(matchesStatusFilter);\n\n          // rebuild the Map of state data\n          SortedMap<String, Object> map = new TreeMap<String, Object>(pagingSupport);\n          for (String next : page.selected)\n            map.put(next, collectionStates.get(next));\n          collectionStates = map;\n        }\n      } catch (KeeperException | InterruptedException e) {\n        writeError(500, e.toString());\n        return;\n      }\n\n      CharArr chars = new CharArr();\n      JSONWriter json = new JSONWriter(chars, 2);\n      json.startObject();\n\n      json.writeString(\"znode\");\n      json.writeNameSeparator();\n      json.startObject();\n\n      // For some reason, without this the Json is badly formed\n      writeKeyValue(json, PATH, \"Undefined\", true);\n\n      if (collectionStates != null) {\n        CharArr collectionOut = new CharArr();\n        new JSONWriter(collectionOut, 2).write(collectionStates);\n        writeKeyValue(json, \"data\", collectionOut.toString(), false);\n      }\n\n      writeKeyValue(json, \"paging\", page.getPagingHeader(), false);\n\n      json.endObject();\n      json.endObject();\n      out.write(chars.toString());\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5ad9c35f926b4bf8da0336d1300efc709c8d5a56":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"]},"commit2Childs":{"5ad9c35f926b4bf8da0336d1300efc709c8d5a56":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}