{"path":"solr/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","commits":[{"id":"b24326411db492f92ea49f6fb947c90bc73cf19e","date":1298813468,"type":1,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputStream).mjava","sourceNew":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    defaultIndexConfig = new SolrIndexConfig(this, null, null);\n    mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n    reopenReaders = getBool(\"mainIndex/reopenReaders\", true);\n    \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(\"mainIndex/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",true, true);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",true, true);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",true, true);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",true, true);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",true, true);\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",true, true);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why thye are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way arround that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",false, true);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",false, true);\n     loadPluginInfo(IndexDeletionPolicy.class,\"mainIndex/deletionPolicy\",false, true);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",false, true);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",false, false);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  SolrConfig(SolrResourceLoader loader, String name, InputStream is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    defaultIndexConfig = new SolrIndexConfig(this, null, null);\n    mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n    reopenReaders = getBool(\"mainIndex/reopenReaders\", true);\n    \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(\"mainIndex/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",true, true);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",true, true);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",true, true);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",true, true);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",true, true);\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",true, true);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why thye are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way arround that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",false, true);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",false, true);\n     loadPluginInfo(IndexDeletionPolicy.class,\"mainIndex/deletionPolicy\",false, true);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",false, true);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",false, false);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c1c76c72faecc7c9b683ad67e99240c975ee37b3","date":1301109514,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    defaultIndexConfig = new SolrIndexConfig(this, null, null);\n    mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n    reopenReaders = getBool(\"mainIndex/reopenReaders\", true);\n    \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(\"mainIndex/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",true, true);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",true, true);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",true, true);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",true, true);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",true, true);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",true, true);\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",true, true);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why thye are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way arround that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",false, true);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",false, true);\n     loadPluginInfo(IndexDeletionPolicy.class,\"mainIndex/deletionPolicy\",false, true);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",false, true);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",false, false);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    defaultIndexConfig = new SolrIndexConfig(this, null, null);\n    mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n    reopenReaders = getBool(\"mainIndex/reopenReaders\", true);\n    \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(\"mainIndex/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",true, true);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",true, true);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",true, true);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",true, true);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",true, true);\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",true, true);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why thye are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way arround that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",false, true);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",false, true);\n     loadPluginInfo(IndexDeletionPolicy.class,\"mainIndex/deletionPolicy\",false, true);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",false, true);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",false, false);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":["e2d531c99815e9282449614650df62aad96c688e","e2d531c99815e9282449614650df62aad96c688e","e2d531c99815e9282449614650df62aad96c688e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d619839baa8ce5503e496b94a9e42ad6f079293f","date":1301309428,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"/dev/null","sourceNew":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    defaultIndexConfig = new SolrIndexConfig(this, null, null);\n    mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n    reopenReaders = getBool(\"mainIndex/reopenReaders\", true);\n    \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(\"mainIndex/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",true, true);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",true, true);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",true, true);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",true, true);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",true, true);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",true, true);\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",true, true);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why thye are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way arround that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",false, true);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",false, true);\n     loadPluginInfo(IndexDeletionPolicy.class,\"mainIndex/deletionPolicy\",false, true);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",false, true);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",false, false);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c0ef0193974807e4bddf5432a6b0287fe4d6c9df","date":1301476645,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"/dev/null","sourceNew":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    defaultIndexConfig = new SolrIndexConfig(this, null, null);\n    mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n    reopenReaders = getBool(\"mainIndex/reopenReaders\", true);\n    \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(\"mainIndex/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",true, true);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",true, true);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",true, true);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",true, true);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",true, true);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",true, true);\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",true, true);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why thye are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way arround that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",false, true);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",false, true);\n     loadPluginInfo(IndexDeletionPolicy.class,\"mainIndex/deletionPolicy\",false, true);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",false, true);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",false, false);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ed58545b60d7aa369597f02f68f1d1c9c04be47a","date":1305377120,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    defaultIndexConfig = new SolrIndexConfig(this, null, null);\n    mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n    reopenReaders = getBool(\"mainIndex/reopenReaders\", true);\n    \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(\"mainIndex/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",true, true);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",true, true);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",true, true);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",true, true);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",true, true);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",true, true);\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",true, true);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why thye are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way arround that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",false, true);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",false, true);\n     loadPluginInfo(IndexDeletionPolicy.class,\"mainIndex/deletionPolicy\",false, true);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",false, true);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",false, false);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    defaultIndexConfig = new SolrIndexConfig(this, null, null);\n    mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n    reopenReaders = getBool(\"mainIndex/reopenReaders\", true);\n    \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(\"mainIndex/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",true, true);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",true, true);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",true, true);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",true, true);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",true, true);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",true, true);\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",true, true);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why thye are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way arround that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",false, true);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",false, true);\n     loadPluginInfo(IndexDeletionPolicy.class,\"mainIndex/deletionPolicy\",false, true);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",false, true);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",false, false);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c3a8a449466c1ff7ce2274fe73dab487256964b4","date":1305735867,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    defaultIndexConfig = new SolrIndexConfig(this, null, null);\n    mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n    reopenReaders = getBool(\"mainIndex/reopenReaders\", true);\n    \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(\"mainIndex/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",true, true);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",true, true);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",true, true);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",true, true);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",true, true);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",true, true);\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",true, true);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why thye are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way arround that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",false, true);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",false, true);\n     loadPluginInfo(IndexDeletionPolicy.class,\"mainIndex/deletionPolicy\",false, true);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",false, true);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",false, false);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    defaultIndexConfig = new SolrIndexConfig(this, null, null);\n    mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n    reopenReaders = getBool(\"mainIndex/reopenReaders\", true);\n    \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(\"mainIndex/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",true, true);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",true, true);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",true, true);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",true, true);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",true, true);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",true, true);\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",true, true);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why thye are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way arround that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",false, true);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",false, true);\n     loadPluginInfo(IndexDeletionPolicy.class,\"mainIndex/deletionPolicy\",false, true);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",false, true);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",false, false);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3776dccca01c11e7046323cfad46a3b4a471233","date":1306100719,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    defaultIndexConfig = new SolrIndexConfig(this, null, null);\n    mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n    reopenReaders = getBool(\"mainIndex/reopenReaders\", true);\n    \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(\"mainIndex/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",true, true);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",true, true);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",true, true);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",true, true);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",true, true);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",true, true);\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",true, true);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why thye are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way arround that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",false, true);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",false, true);\n     loadPluginInfo(IndexDeletionPolicy.class,\"mainIndex/deletionPolicy\",false, true);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",false, true);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",false, false);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    defaultIndexConfig = new SolrIndexConfig(this, null, null);\n    mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n    reopenReaders = getBool(\"mainIndex/reopenReaders\", true);\n    \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(\"mainIndex/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",true, true);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",true, true);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",true, true);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",true, true);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",true, true);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",true, true);\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",true, true);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why thye are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way arround that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",false, true);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",false, true);\n     loadPluginInfo(IndexDeletionPolicy.class,\"mainIndex/deletionPolicy\",false, true);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",false, true);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",false, false);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"55688cada84e99928d155229fc2768df65a45bdb","date":1306274128,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    defaultIndexConfig = new SolrIndexConfig(this, null, null);\n    mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n    reopenReaders = getBool(\"mainIndex/reopenReaders\", true);\n    \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(\"mainIndex/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",true, true);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",true, true);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",true, true);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",true, true);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",true, true);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",true, true);\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",true, true);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why thye are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way arround that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",false, true);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",false, true);\n     loadPluginInfo(IndexDeletionPolicy.class,\"mainIndex/deletionPolicy\",false, true);\n     loadPluginInfo(CodecProviderFactory.class,\"mainIndex/codecProviderFactory\",false, false);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",false, true);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",false, false);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    defaultIndexConfig = new SolrIndexConfig(this, null, null);\n    mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n    reopenReaders = getBool(\"mainIndex/reopenReaders\", true);\n    \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(\"mainIndex/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",true, true);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",true, true);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",true, true);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",true, true);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",true, true);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",true, true);\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",true, true);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why thye are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way arround that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",false, true);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",false, true);\n     loadPluginInfo(IndexDeletionPolicy.class,\"mainIndex/deletionPolicy\",false, true);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",false, true);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",false, false);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","date":1306767085,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    defaultIndexConfig = new SolrIndexConfig(this, null, null);\n    mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n    reopenReaders = getBool(\"mainIndex/reopenReaders\", true);\n    \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(\"mainIndex/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",true, true);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",true, true);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",true, true);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",true, true);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",true, true);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",true, true);\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",true, true);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why thye are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way arround that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",false, true);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",false, true);\n     loadPluginInfo(IndexDeletionPolicy.class,\"mainIndex/deletionPolicy\",false, true);\n     loadPluginInfo(CodecProviderFactory.class,\"mainIndex/codecProviderFactory\",false, false);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",false, true);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",false, false);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    defaultIndexConfig = new SolrIndexConfig(this, null, null);\n    mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n    reopenReaders = getBool(\"mainIndex/reopenReaders\", true);\n    \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(\"mainIndex/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",true, true);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",true, true);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",true, true);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",true, true);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",true, true);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",true, true);\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",true, true);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why thye are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way arround that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",false, true);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",false, true);\n     loadPluginInfo(IndexDeletionPolicy.class,\"mainIndex/deletionPolicy\",false, true);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",false, true);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",false, false);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2e10cb22a8bdb44339e282925a29182bb2f3174d","date":1306841137,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    defaultIndexConfig = new SolrIndexConfig(this, null, null);\n    mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n    reopenReaders = getBool(\"mainIndex/reopenReaders\", true);\n    \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(\"mainIndex/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",true, true);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",true, true);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",true, true);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",true, true);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",true, true);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",true, true);\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",true, true);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why thye are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way arround that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",false, true);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",false, true);\n     loadPluginInfo(IndexDeletionPolicy.class,\"mainIndex/deletionPolicy\",false, true);\n     loadPluginInfo(CodecProviderFactory.class,\"mainIndex/codecProviderFactory\",false, false);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",false, true);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",false, false);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    defaultIndexConfig = new SolrIndexConfig(this, null, null);\n    mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n    reopenReaders = getBool(\"mainIndex/reopenReaders\", true);\n    \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(\"mainIndex/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",true, true);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",true, true);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",true, true);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",true, true);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",true, true);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",true, true);\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",true, true);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why thye are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way arround that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",false, true);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",false, true);\n     loadPluginInfo(IndexDeletionPolicy.class,\"mainIndex/deletionPolicy\",false, true);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",false, true);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",false, false);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    defaultIndexConfig = new SolrIndexConfig(this, null, null);\n    mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n    reopenReaders = getBool(\"mainIndex/reopenReaders\", true);\n    \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(\"mainIndex/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",true, true);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",true, true);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",true, true);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",true, true);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",true, true);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",true, true);\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",true, true);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why thye are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way arround that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",false, true);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",false, true);\n     loadPluginInfo(IndexDeletionPolicy.class,\"mainIndex/deletionPolicy\",false, true);\n     loadPluginInfo(CodecProviderFactory.class,\"mainIndex/codecProviderFactory\",false, false);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",false, true);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",false, false);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    defaultIndexConfig = new SolrIndexConfig(this, null, null);\n    mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n    reopenReaders = getBool(\"mainIndex/reopenReaders\", true);\n    \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(\"mainIndex/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",true, true);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",true, true);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",true, true);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",true, true);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",true, true);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",true, true);\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",true, true);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why thye are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way arround that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",false, true);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",false, true);\n     loadPluginInfo(IndexDeletionPolicy.class,\"mainIndex/deletionPolicy\",false, true);\n     loadPluginInfo(CodecProviderFactory.class,\"mainIndex/codecProviderFactory\",false, false);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",false, true);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",false, false);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    defaultIndexConfig = new SolrIndexConfig(this, null, null);\n    mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n    reopenReaders = getBool(\"mainIndex/reopenReaders\", true);\n    \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(\"mainIndex/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",true, true);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",true, true);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",true, true);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",true, true);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",true, true);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",true, true);\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",true, true);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why thye are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way arround that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",false, true);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",false, true);\n     loadPluginInfo(IndexDeletionPolicy.class,\"mainIndex/deletionPolicy\",false, true);\n     loadPluginInfo(CodecProviderFactory.class,\"mainIndex/codecProviderFactory\",false, false);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",false, true);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",false, false);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    defaultIndexConfig = new SolrIndexConfig(this, null, null);\n    mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n    reopenReaders = getBool(\"mainIndex/reopenReaders\", true);\n    \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(\"mainIndex/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",true, true);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",true, true);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",true, true);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",true, true);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",true, true);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",true, true);\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",true, true);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why thye are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way arround that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",false, true);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",false, true);\n     loadPluginInfo(IndexDeletionPolicy.class,\"mainIndex/deletionPolicy\",false, true);\n     loadPluginInfo(CodecProviderFactory.class,\"mainIndex/codecProviderFactory\",false, false);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",false, true);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",false, false);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrConfig#SolrConfig(SolrResourceLoader,String,InputSource).mjava","sourceNew":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    defaultIndexConfig = new SolrIndexConfig(this, null, null);\n    mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n    reopenReaders = getBool(\"mainIndex/reopenReaders\", true);\n    \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(\"mainIndex/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",true, true);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",true, true);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",true, true);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",true, true);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",true, true);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",true, true);\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",true, true);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why thye are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way arround that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",false, true);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",false, true);\n     loadPluginInfo(IndexDeletionPolicy.class,\"mainIndex/deletionPolicy\",false, true);\n     loadPluginInfo(CodecProviderFactory.class,\"mainIndex/codecProviderFactory\",false, false);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",false, true);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",false, false);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","sourceOld":"   /** Creates a configuration instance from a resource loader, a configuration name and a stream.\n   * If the stream is null, the resource loader will open the configuration stream.\n   * If the stream is not null, no attempt to load the resource will occur (the name is not used).\n   *@param loader the resource loader\n   *@param name the configuration name\n   *@param is the configuration stream\n   */\n  SolrConfig(SolrResourceLoader loader, String name, InputSource is)\n  throws ParserConfigurationException, IOException, SAXException {\n    super(loader, name, is, \"/config/\");\n    initLibs();\n    luceneMatchVersion = getLuceneVersion(\"luceneMatchVersion\");\n    defaultIndexConfig = new SolrIndexConfig(this, null, null);\n    mainIndexConfig = new SolrIndexConfig(this, \"mainIndex\", defaultIndexConfig);\n    reopenReaders = getBool(\"mainIndex/reopenReaders\", true);\n    \n    booleanQueryMaxClauseCount = getInt(\"query/maxBooleanClauses\", BooleanQuery.getMaxClauseCount());\n    log.info(\"Using Lucene MatchVersion: \" + luceneMatchVersion);\n\n    filtOptEnabled = getBool(\"query/boolTofilterOptimizer/@enabled\", false);\n    filtOptCacheSize = getInt(\"query/boolTofilterOptimizer/@cacheSize\",32);\n    filtOptThreshold = getFloat(\"query/boolTofilterOptimizer/@threshold\",.05f);\n    \n    useFilterForSortedQuery = getBool(\"query/useFilterForSortedQuery\", false);\n    queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n    queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n    enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n\n    \n    filterCacheConfig = CacheConfig.getConfig(this, \"query/filterCache\");\n    queryResultCacheConfig = CacheConfig.getConfig(this, \"query/queryResultCache\");\n    documentCacheConfig = CacheConfig.getConfig(this, \"query/documentCache\");\n    CacheConfig conf = CacheConfig.getConfig(this, \"query/fieldValueCache\");\n    if (conf == null) {\n      Map<String,String> args = new HashMap<String,String>();\n      args.put(\"name\",\"fieldValueCache\");\n      args.put(\"size\",\"10000\");\n      args.put(\"initialSize\",\"10\");\n      args.put(\"showItems\",\"-1\");\n      conf = new CacheConfig(FastLRUCache.class, args, null);\n    }\n    fieldValueCacheConfig = conf;\n    unlockOnStartup = getBool(\"mainIndex/unlockOnStartup\", false);\n    useColdSearcher = getBool(\"query/useColdSearcher\",false);\n    dataDir = get(\"dataDir\", null);\n    if (dataDir != null && dataDir.length()==0) dataDir=null;\n\n    userCacheConfigs = CacheConfig.getMultipleConfigs(this, \"query/cache\");\n\n    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);\n\n    hashSetInverseLoadFactor = 1.0f / getFloat(\"//HashDocSet/@loadFactor\",0.75f);\n    hashDocSetMaxSize= getInt(\"//HashDocSet/@maxSize\",3000);\n\n    httpCachingConfig = new HttpCachingConfig(this);\n    \n    Node jmx = getNode(\"jmx\", false);\n    if (jmx != null) {\n      jmxConfig = new JmxConfiguration(true, \n                                       get(\"jmx/@agentId\", null), \n                                       get(\"jmx/@serviceUrl\", null),\n                                       get(\"jmx/@rootName\", null));\n                                           \n    } else {\n      jmxConfig = new JmxConfiguration(false, null, null, null);\n    }\n     maxWarmingSearchers = getInt(\"query/maxWarmingSearchers\",Integer.MAX_VALUE);\n\n     loadPluginInfo(SolrRequestHandler.class,\"requestHandler\",true, true);\n     loadPluginInfo(QParserPlugin.class,\"queryParser\",true, true);\n     loadPluginInfo(QueryResponseWriter.class,\"queryResponseWriter\",true, true);\n     loadPluginInfo(ValueSourceParser.class,\"valueSourceParser\",true, true);\n     loadPluginInfo(TransformerFactory.class,\"transformer\",true, true);\n     loadPluginInfo(SearchComponent.class,\"searchComponent\",true, true);\n     loadPluginInfo(QueryConverter.class,\"queryConverter\",true, true);\n\n     // this is hackish, since it picks up all SolrEventListeners,\n     // regardless of when/how/why thye are used (or even if they are \n     // declared outside of the appropriate context) but there's no nice \n     // way arround that in the PluginInfo framework\n     loadPluginInfo(SolrEventListener.class, \"//listener\",false, true);\n\n     loadPluginInfo(DirectoryFactory.class,\"directoryFactory\",false, true);\n     loadPluginInfo(IndexDeletionPolicy.class,\"mainIndex/deletionPolicy\",false, true);\n     loadPluginInfo(CodecProviderFactory.class,\"mainIndex/codecProviderFactory\",false, false);\n     loadPluginInfo(IndexReaderFactory.class,\"indexReaderFactory\",false, true);\n     loadPluginInfo(UpdateRequestProcessorChain.class,\"updateRequestProcessorChain\",false, false);\n\n     updateHandlerInfo = loadUpdatehandlerInfo();\n\n    Config.log.info(\"Loaded SolrConfig: \" + name);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"c26f00b574427b55127e869b935845554afde1fa":["55688cada84e99928d155229fc2768df65a45bdb","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"c1c76c72faecc7c9b683ad67e99240c975ee37b3":["b24326411db492f92ea49f6fb947c90bc73cf19e"],"b24326411db492f92ea49f6fb947c90bc73cf19e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c0ef0193974807e4bddf5432a6b0287fe4d6c9df":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c1c76c72faecc7c9b683ad67e99240c975ee37b3"],"ed58545b60d7aa369597f02f68f1d1c9c04be47a":["c1c76c72faecc7c9b683ad67e99240c975ee37b3"],"c3a8a449466c1ff7ce2274fe73dab487256964b4":["d619839baa8ce5503e496b94a9e42ad6f079293f","ed58545b60d7aa369597f02f68f1d1c9c04be47a"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["5128b7b3b73fedff05fdc5ea2e6be53c1020bb91"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":["a3776dccca01c11e7046323cfad46a3b4a471233","55688cada84e99928d155229fc2768df65a45bdb"],"d619839baa8ce5503e496b94a9e42ad6f079293f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c1c76c72faecc7c9b683ad67e99240c975ee37b3"],"a3776dccca01c11e7046323cfad46a3b4a471233":["c1c76c72faecc7c9b683ad67e99240c975ee37b3","ed58545b60d7aa369597f02f68f1d1c9c04be47a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a258fbb26824fd104ed795e5d9033d2d040049ee":["55688cada84e99928d155229fc2768df65a45bdb"],"55688cada84e99928d155229fc2768df65a45bdb":["ed58545b60d7aa369597f02f68f1d1c9c04be47a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c26f00b574427b55127e869b935845554afde1fa"],"2e10cb22a8bdb44339e282925a29182bb2f3174d":["c3a8a449466c1ff7ce2274fe73dab487256964b4","55688cada84e99928d155229fc2768df65a45bdb"]},"commit2Childs":{"c26f00b574427b55127e869b935845554afde1fa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c1c76c72faecc7c9b683ad67e99240c975ee37b3":["c0ef0193974807e4bddf5432a6b0287fe4d6c9df","ed58545b60d7aa369597f02f68f1d1c9c04be47a","d619839baa8ce5503e496b94a9e42ad6f079293f","a3776dccca01c11e7046323cfad46a3b4a471233"],"b24326411db492f92ea49f6fb947c90bc73cf19e":["c1c76c72faecc7c9b683ad67e99240c975ee37b3"],"c0ef0193974807e4bddf5432a6b0287fe4d6c9df":[],"ed58545b60d7aa369597f02f68f1d1c9c04be47a":["c3a8a449466c1ff7ce2274fe73dab487256964b4","a3776dccca01c11e7046323cfad46a3b4a471233","55688cada84e99928d155229fc2768df65a45bdb"],"c3a8a449466c1ff7ce2274fe73dab487256964b4":["2e10cb22a8bdb44339e282925a29182bb2f3174d"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"d619839baa8ce5503e496b94a9e42ad6f079293f":["c3a8a449466c1ff7ce2274fe73dab487256964b4"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":["c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"a3776dccca01c11e7046323cfad46a3b4a471233":["5128b7b3b73fedff05fdc5ea2e6be53c1020bb91"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b24326411db492f92ea49f6fb947c90bc73cf19e","c0ef0193974807e4bddf5432a6b0287fe4d6c9df","d619839baa8ce5503e496b94a9e42ad6f079293f"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"55688cada84e99928d155229fc2768df65a45bdb":["c26f00b574427b55127e869b935845554afde1fa","5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","a258fbb26824fd104ed795e5d9033d2d040049ee","2e10cb22a8bdb44339e282925a29182bb2f3174d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"2e10cb22a8bdb44339e282925a29182bb2f3174d":[]},"heads":["c0ef0193974807e4bddf5432a6b0287fe4d6c9df","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817","2e10cb22a8bdb44339e282925a29182bb2f3174d"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}