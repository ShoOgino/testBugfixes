{"path":"solr/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","commits":[{"id":"893269407f5c988a4b2ee13c7ffc01ec43136c1d","date":1268598046,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","pathOld":"/dev/null","sourceNew":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      SchemaField uniqueKeyField = rb.req.getSchema().getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<Object,String>();    \n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount());\n\n      long numFound = 0;\n      Float maxScore=null;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n\n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = sortFieldValues;\n\n          queue.insert(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n\n\n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<Object,ShardDoc>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = (ShardDoc)queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","date":1268599006,"type":4,"author":"Mark Robert Miller","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","sourceNew":null,"sourceOld":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      SchemaField uniqueKeyField = rb.req.getSchema().getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<Object,String>();    \n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount());\n\n      long numFound = 0;\n      Float maxScore=null;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n\n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = sortFieldValues;\n\n          queue.insert(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n\n\n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<Object,ShardDoc>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = (ShardDoc)queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","pathOld":"src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","sourceNew":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      SchemaField uniqueKeyField = rb.req.getSchema().getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<Object,String>();    \n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount());\n\n      long numFound = 0;\n      Float maxScore=null;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n\n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = sortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n\n\n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<Object,ShardDoc>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = (ShardDoc)queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n  }\n\n","sourceOld":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      SchemaField uniqueKeyField = rb.req.getSchema().getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<Object,String>();    \n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount());\n\n      long numFound = 0;\n      Float maxScore=null;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n\n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = sortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n\n\n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<Object,ShardDoc>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = (ShardDoc)queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1da8d55113b689b06716246649de6f62430f15c0","date":1453508340,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","pathOld":"/dev/null","sourceNew":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      SchemaField uniqueKeyField = rb.req.getSchema().getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<Object,String>();    \n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount());\n\n      long numFound = 0;\n      Float maxScore=null;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n\n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = sortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n\n\n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<Object,ShardDoc>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = (ShardDoc)queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","sourceNew":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      SchemaField uniqueKeyField = rb.req.getSchema().getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<Object,String>();    \n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount());\n\n      long numFound = 0;\n      Float maxScore=null;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n\n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = sortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n\n\n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<Object,ShardDoc>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = (ShardDoc)queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n  }\n\n","sourceOld":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      SchemaField uniqueKeyField = rb.req.getSchema().getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<Object,String>();    \n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount());\n\n      long numFound = 0;\n      Float maxScore=null;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n\n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = sortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n\n\n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<Object,ShardDoc>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = (ShardDoc)queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","sourceNew":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      SchemaField uniqueKeyField = rb.req.getSchema().getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<Object,String>();    \n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount());\n\n      long numFound = 0;\n      Float maxScore=null;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n\n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = sortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n\n\n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<Object,ShardDoc>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = (ShardDoc)queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n  }\n\n","sourceOld":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      SchemaField uniqueKeyField = rb.req.getSchema().getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<Object,String>();    \n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount());\n\n      long numFound = 0;\n      Float maxScore=null;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n\n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = sortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n\n\n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<Object,ShardDoc>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = (ShardDoc)queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/QueryComponent#mergeIds(ResponseBuilder,ShardRequest).mjava","sourceNew":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      SchemaField uniqueKeyField = rb.req.getSchema().getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<Object,String>();    \n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount());\n\n      long numFound = 0;\n      Float maxScore=null;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n\n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = sortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n\n\n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<Object,ShardDoc>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = (ShardDoc)queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n  }\n\n","sourceOld":"  private void mergeIds(ResponseBuilder rb, ShardRequest sreq) {\n      SortSpec ss = rb.getSortSpec();\n      Sort sort = ss.getSort();\n\n      SortField[] sortFields = null;\n      if(sort != null) sortFields = sort.getSort();\n      else {\n        sortFields = new SortField[]{SortField.FIELD_SCORE};\n      }\n \n      SchemaField uniqueKeyField = rb.req.getSchema().getUniqueKeyField();\n\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<Object,String>();    \n\n      // Merge the docs via a priority queue so we don't have to sort *all* of the\n      // documents... we only need to order the top (rows+start)\n      ShardFieldSortedHitQueue queue;\n      queue = new ShardFieldSortedHitQueue(sortFields, ss.getOffset() + ss.getCount());\n\n      long numFound = 0;\n      Float maxScore=null;\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n\n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"sort_values\"));\n\n        // go through every doc in this response, construct a ShardDoc, and\n        // put it in the priority queue so it can be ordered.\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n\n          shardDoc.sortFieldValues = sortFieldValues;\n\n          queue.insertWithOverflow(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n\n\n      // The queue now has 0 -> queuesize docs, where queuesize <= start + rows\n      // So we want to pop the last documents off the queue to get\n      // the docs offset -> queuesize\n      int resultSize = queue.size() - ss.getOffset();\n      resultSize = Math.max(0, resultSize);  // there may not be any docs in range\n\n      Map<Object,ShardDoc> resultIds = new HashMap<Object,ShardDoc>();\n      for (int i=resultSize-1; i>=0; i--) {\n        ShardDoc shardDoc = (ShardDoc)queue.pop();\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(ss.getOffset());\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb._responseDocs = responseDocs;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"1da8d55113b689b06716246649de6f62430f15c0":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","ad94625fb8d088209f46650c8097196fec67f00c"],"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["1da8d55113b689b06716246649de6f62430f15c0"],"c26f00b574427b55127e869b935845554afde1fa":["1da8d55113b689b06716246649de6f62430f15c0","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"a258fbb26824fd104ed795e5d9033d2d040049ee":["1da8d55113b689b06716246649de6f62430f15c0"],"ad94625fb8d088209f46650c8097196fec67f00c":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c26f00b574427b55127e869b935845554afde1fa"]},"commit2Childs":{"1da8d55113b689b06716246649de6f62430f15c0":["c903c3d15906a3da96b8c0c2fb704491005fdbdb","c26f00b574427b55127e869b935845554afde1fa","a258fbb26824fd104ed795e5d9033d2d040049ee"],"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["1da8d55113b689b06716246649de6f62430f15c0"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"c26f00b574427b55127e869b935845554afde1fa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["ad94625fb8d088209f46650c8097196fec67f00c"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"ad94625fb8d088209f46650c8097196fec67f00c":["1da8d55113b689b06716246649de6f62430f15c0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"pathCommit":null}