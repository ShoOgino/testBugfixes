{"path":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","commits":[{"id":"2c007e7c4cf8c55bc2a5884e315123afaaeec87f","date":1327520966,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","pathOld":"/dev/null","sourceNew":"  boolean fetchLatestIndex(SolrCore core, boolean force) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (force && commit.getVersion() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          core.getUpdateHandler().getSolrCoreState().getIndexWriter(core).deleteAll();\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (commit.getVersion() == latestVersion && commit.getGeneration() == latestGeneration) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's version: \" + latestVersion + \", generation: \" + latestGeneration);\n      LOG.info(\"Slave's version: \" + commit.getVersion() + \", generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestVersion);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor();\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = commit.getVersion() >= latestVersion || force;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isFullCopyNeeded = true;\n      successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n      File indexDir = null ;\n      try {\n        indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestVersion);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestVersion);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) delTree(tmpIndexDir);\n        else delTree(indexDir);\n      }\n    } finally {\n      if (!successfulInstall) {\n        logReplicationTimeAndConfFiles(null, successfulInstall);\n      }\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["6c94d2661bc1c14426980ec7882e951fdcff08d0","c01638f4dd94981c1d3d52c4f7991246a5a24aba","190779ba7de3fda15afd1bbafbc383720a4b0966","b3c2c17185ad7fb0aa9b81dbd9d0395debbc4519"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","pathOld":"/dev/null","sourceNew":"  boolean fetchLatestIndex(SolrCore core, boolean force) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (force && commit.getVersion() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          core.getUpdateHandler().getSolrCoreState().getIndexWriter(core).deleteAll();\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (commit.getVersion() == latestVersion && commit.getGeneration() == latestGeneration) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's version: \" + latestVersion + \", generation: \" + latestGeneration);\n      LOG.info(\"Slave's version: \" + commit.getVersion() + \", generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestVersion);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor();\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = commit.getVersion() >= latestVersion || force;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isFullCopyNeeded = true;\n      successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n      File indexDir = null ;\n      try {\n        indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestVersion);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestVersion);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) delTree(tmpIndexDir);\n        else delTree(indexDir);\n      }\n    } finally {\n      if (!successfulInstall) {\n        logReplicationTimeAndConfFiles(null, successfulInstall);\n      }\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0d22ac6a4146774c1bc8400160fc0b6150294e92","date":1327528604,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","pathOld":"/dev/null","sourceNew":"  boolean fetchLatestIndex(SolrCore core, boolean force) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (force && commit.getVersion() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          core.getUpdateHandler().getSolrCoreState().getIndexWriter(core).deleteAll();\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (commit.getVersion() == latestVersion && commit.getGeneration() == latestGeneration) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's version: \" + latestVersion + \", generation: \" + latestGeneration);\n      LOG.info(\"Slave's version: \" + commit.getVersion() + \", generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestVersion);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor();\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = commit.getVersion() >= latestVersion || force;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isFullCopyNeeded = true;\n      successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n      File indexDir = null ;\n      try {\n        indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestVersion);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestVersion);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) delTree(tmpIndexDir);\n        else delTree(indexDir);\n      }\n    } finally {\n      if (!successfulInstall) {\n        logReplicationTimeAndConfFiles(null, successfulInstall);\n      }\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"db05ec3460be863c2b1e39675c58b412cd9afdc0","date":1327637540,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","sourceNew":"  boolean fetchLatestIndex(SolrCore core, boolean force) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (force && commit.getVersion() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          core.getUpdateHandler().getSolrCoreState().getIndexWriter(core).deleteAll();\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!force && commit.getVersion() == latestVersion && commit.getGeneration() == latestGeneration) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's version: \" + latestVersion + \", generation: \" + latestGeneration);\n      LOG.info(\"Slave's version: \" + commit.getVersion() + \", generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestVersion);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor();\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = commit.getVersion() >= latestVersion || force;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isFullCopyNeeded = true;\n      successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n      File indexDir = null ;\n      try {\n        indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestVersion);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestVersion);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) delTree(tmpIndexDir);\n        else delTree(indexDir);\n      }\n    } finally {\n      if (!successfulInstall) {\n        logReplicationTimeAndConfFiles(null, successfulInstall);\n      }\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","sourceOld":"  boolean fetchLatestIndex(SolrCore core, boolean force) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (force && commit.getVersion() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          core.getUpdateHandler().getSolrCoreState().getIndexWriter(core).deleteAll();\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (commit.getVersion() == latestVersion && commit.getGeneration() == latestGeneration) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's version: \" + latestVersion + \", generation: \" + latestGeneration);\n      LOG.info(\"Slave's version: \" + commit.getVersion() + \", generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestVersion);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor();\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = commit.getVersion() >= latestVersion || force;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isFullCopyNeeded = true;\n      successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n      File indexDir = null ;\n      try {\n        indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestVersion);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestVersion);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) delTree(tmpIndexDir);\n        else delTree(indexDir);\n      }\n    } finally {\n      if (!successfulInstall) {\n        logReplicationTimeAndConfFiles(null, successfulInstall);\n      }\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":["c01638f4dd94981c1d3d52c4f7991246a5a24aba"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"78a55f24d9b493c2a1cecf79f1d78279062b545b","date":1327688152,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","sourceNew":"  boolean fetchLatestIndex(SolrCore core, boolean force) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (force && commit.getVersion() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          core.getUpdateHandler().getSolrCoreState().getIndexWriter(core).deleteAll();\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!force && commit.getVersion() == latestVersion && commit.getGeneration() == latestGeneration) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's version: \" + latestVersion + \", generation: \" + latestGeneration);\n      LOG.info(\"Slave's version: \" + commit.getVersion() + \", generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestVersion);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor();\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = commit.getVersion() >= latestVersion || force;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isFullCopyNeeded = true;\n      successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n      File indexDir = null ;\n      try {\n        indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestVersion);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestVersion);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) delTree(tmpIndexDir);\n        else delTree(indexDir);\n      }\n    } finally {\n      if (!successfulInstall) {\n        logReplicationTimeAndConfFiles(null, successfulInstall);\n      }\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","sourceOld":"  boolean fetchLatestIndex(SolrCore core, boolean force) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (force && commit.getVersion() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          core.getUpdateHandler().getSolrCoreState().getIndexWriter(core).deleteAll();\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (commit.getVersion() == latestVersion && commit.getGeneration() == latestGeneration) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's version: \" + latestVersion + \", generation: \" + latestGeneration);\n      LOG.info(\"Slave's version: \" + commit.getVersion() + \", generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestVersion);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor();\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = commit.getVersion() >= latestVersion || force;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isFullCopyNeeded = true;\n      successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n      File indexDir = null ;\n      try {\n        indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestVersion);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestVersion);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) delTree(tmpIndexDir);\n        else delTree(indexDir);\n      }\n    } finally {\n      if (!successfulInstall) {\n        logReplicationTimeAndConfFiles(null, successfulInstall);\n      }\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fd92b8bcc88e969302510acf77bd6970da3994c4","date":1327839530,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","sourceNew":"  boolean fetchLatestIndex(SolrCore core, boolean force) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (force && commit.getVersion() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          core.getUpdateHandler().getSolrCoreState().getIndexWriter(core).deleteAll();\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!force && commit.getVersion() == latestVersion && commit.getGeneration() == latestGeneration) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's version: \" + latestVersion + \", generation: \" + latestGeneration);\n      LOG.info(\"Slave's version: \" + commit.getVersion() + \", generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestVersion);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor();\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = commit.getVersion() >= latestVersion || force;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isFullCopyNeeded = true;\n      successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n      File indexDir = null ;\n      try {\n        indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestVersion);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestVersion);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) delTree(tmpIndexDir);\n        else delTree(indexDir);\n      }\n    } finally {\n      if (!successfulInstall) {\n        logReplicationTimeAndConfFiles(null, successfulInstall);\n      }\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","sourceOld":"  boolean fetchLatestIndex(SolrCore core, boolean force) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (force && commit.getVersion() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          core.getUpdateHandler().getSolrCoreState().getIndexWriter(core).deleteAll();\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (commit.getVersion() == latestVersion && commit.getGeneration() == latestGeneration) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's version: \" + latestVersion + \", generation: \" + latestGeneration);\n      LOG.info(\"Slave's version: \" + commit.getVersion() + \", generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestVersion);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor();\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = commit.getVersion() >= latestVersion || force;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isFullCopyNeeded = true;\n      successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n      File indexDir = null ;\n      try {\n        indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestVersion);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestVersion);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) delTree(tmpIndexDir);\n        else delTree(indexDir);\n      }\n    } finally {\n      if (!successfulInstall) {\n        logReplicationTimeAndConfFiles(null, successfulInstall);\n      }\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c01638f4dd94981c1d3d52c4f7991246a5a24aba","date":1327876712,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","sourceNew":"  boolean fetchLatestIndex(SolrCore core, boolean force) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (force && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          core.getUpdateHandler().getSolrCoreState().getIndexWriter(core).deleteAll();\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!force && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor();\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper.getCommitTimestamp(commit) >= latestVersion || force;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isFullCopyNeeded = true;\n      successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n      File indexDir = null ;\n      try {\n        indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) delTree(tmpIndexDir);\n        else delTree(indexDir);\n      }\n    } finally {\n      if (!successfulInstall) {\n        logReplicationTimeAndConfFiles(null, successfulInstall);\n      }\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","sourceOld":"  boolean fetchLatestIndex(SolrCore core, boolean force) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (force && commit.getVersion() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          core.getUpdateHandler().getSolrCoreState().getIndexWriter(core).deleteAll();\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!force && commit.getVersion() == latestVersion && commit.getGeneration() == latestGeneration) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's version: \" + latestVersion + \", generation: \" + latestGeneration);\n      LOG.info(\"Slave's version: \" + commit.getVersion() + \", generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestVersion);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor();\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = commit.getVersion() >= latestVersion || force;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isFullCopyNeeded = true;\n      successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n      File indexDir = null ;\n      try {\n        indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestVersion);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestVersion);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) delTree(tmpIndexDir);\n        else delTree(indexDir);\n      }\n    } finally {\n      if (!successfulInstall) {\n        logReplicationTimeAndConfFiles(null, successfulInstall);\n      }\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","bugFix":["db05ec3460be863c2b1e39675c58b412cd9afdc0","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"bugIntro":["6c94d2661bc1c14426980ec7882e951fdcff08d0","190779ba7de3fda15afd1bbafbc383720a4b0966"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"817882884229bace7dc5d1b75f6b0e4aa1e47122","date":1327879145,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","sourceNew":"  boolean fetchLatestIndex(SolrCore core, boolean force) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (force && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          core.getUpdateHandler().getSolrCoreState().getIndexWriter(core).deleteAll();\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!force && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor();\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper.getCommitTimestamp(commit) >= latestVersion || force;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isFullCopyNeeded = true;\n      successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n      File indexDir = null ;\n      try {\n        indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) delTree(tmpIndexDir);\n        else delTree(indexDir);\n      }\n    } finally {\n      if (!successfulInstall) {\n        logReplicationTimeAndConfFiles(null, successfulInstall);\n      }\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","sourceOld":"  boolean fetchLatestIndex(SolrCore core, boolean force) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (force && commit.getVersion() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          core.getUpdateHandler().getSolrCoreState().getIndexWriter(core).deleteAll();\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!force && commit.getVersion() == latestVersion && commit.getGeneration() == latestGeneration) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's version: \" + latestVersion + \", generation: \" + latestGeneration);\n      LOG.info(\"Slave's version: \" + commit.getVersion() + \", generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestVersion);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor();\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = commit.getVersion() >= latestVersion || force;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isFullCopyNeeded = true;\n      successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n      File indexDir = null ;\n      try {\n        indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestVersion);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestVersion);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) delTree(tmpIndexDir);\n        else delTree(indexDir);\n      }\n    } finally {\n      if (!successfulInstall) {\n        logReplicationTimeAndConfFiles(null, successfulInstall);\n      }\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5b6fdfce35d0adb18836cf8711abe487a934df33","date":1327946200,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","sourceNew":"  boolean fetchLatestIndex(SolrCore core, boolean force) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (force && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          core.getUpdateHandler().getSolrCoreState().getIndexWriter(core).deleteAll();\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!force && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor();\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper.getCommitTimestamp(commit) >= latestVersion || force;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isFullCopyNeeded = true;\n      successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n      File indexDir = null ;\n      try {\n        indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) delTree(tmpIndexDir);\n        else delTree(indexDir);\n      }\n    } finally {\n      if (!successfulInstall) {\n        logReplicationTimeAndConfFiles(null, successfulInstall);\n      }\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","sourceOld":"  boolean fetchLatestIndex(SolrCore core, boolean force) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (force && commit.getVersion() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          core.getUpdateHandler().getSolrCoreState().getIndexWriter(core).deleteAll();\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!force && commit.getVersion() == latestVersion && commit.getGeneration() == latestGeneration) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's version: \" + latestVersion + \", generation: \" + latestGeneration);\n      LOG.info(\"Slave's version: \" + commit.getVersion() + \", generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestVersion);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor();\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = commit.getVersion() >= latestVersion || force;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isFullCopyNeeded = true;\n      successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n      File indexDir = null ;\n      try {\n        indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestVersion);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestVersion);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) delTree(tmpIndexDir);\n        else delTree(indexDir);\n      }\n    } finally {\n      if (!successfulInstall) {\n        logReplicationTimeAndConfFiles(null, successfulInstall);\n      }\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17423fb5ef5555fbfa7fe53c15d602faef60ba1a","date":1339512496,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","sourceNew":"  boolean fetchLatestIndex(SolrCore core, boolean force) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (force && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          core.getUpdateHandler().getSolrCoreState().getIndexWriter(core).deleteAll();\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!force && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor();\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper.getCommitTimestamp(commit) >= latestVersion || force;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isFullCopyNeeded = true;\n      LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n      successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n      File indexDir = null ;\n      try {\n        indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory \" + tmpIndexDir);\n          delTree(tmpIndexDir);\n        } else {\n          LOG.info(\"removing old index directory \" + indexDir);\n          delTree(indexDir);\n        }\n      }\n    } finally {\n      if (!successfulInstall) {\n        logReplicationTimeAndConfFiles(null, successfulInstall);\n      }\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","sourceOld":"  boolean fetchLatestIndex(SolrCore core, boolean force) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (force && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          core.getUpdateHandler().getSolrCoreState().getIndexWriter(core).deleteAll();\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!force && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor();\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper.getCommitTimestamp(commit) >= latestVersion || force;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isFullCopyNeeded = true;\n      successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n      File indexDir = null ;\n      try {\n        indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) delTree(tmpIndexDir);\n        else delTree(indexDir);\n      }\n    } finally {\n      if (!successfulInstall) {\n        logReplicationTimeAndConfFiles(null, successfulInstall);\n      }\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bd9ddb59e9d33950773d186a8b726b5610ae3aad","date":1341258232,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param force force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  @SuppressWarnings(\"unchecked\")\n  boolean fetchLatestIndex(SolrCore core, boolean force) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (force && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          core.getUpdateHandler().getSolrCoreState().getIndexWriter(core).deleteAll();\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!force && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor();\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper.getCommitTimestamp(commit) >= latestVersion || force;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isFullCopyNeeded = true;\n      LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n      successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n      File indexDir = null ;\n      try {\n        indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory \" + tmpIndexDir);\n          delTree(tmpIndexDir);\n        } else {\n          LOG.info(\"removing old index directory \" + indexDir);\n          delTree(indexDir);\n        }\n      }\n    } finally {\n      if (!successfulInstall) {\n        logReplicationTimeAndConfFiles(null, successfulInstall);\n      }\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","sourceOld":"  boolean fetchLatestIndex(SolrCore core, boolean force) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (force && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          core.getUpdateHandler().getSolrCoreState().getIndexWriter(core).deleteAll();\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!force && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor();\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper.getCommitTimestamp(commit) >= latestVersion || force;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isFullCopyNeeded = true;\n      LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n      successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n      File indexDir = null ;\n      try {\n        indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory \" + tmpIndexDir);\n          delTree(tmpIndexDir);\n        } else {\n          LOG.info(\"removing old index directory \" + indexDir);\n          delTree(indexDir);\n        }\n      }\n    } finally {\n      if (!successfulInstall) {\n        logReplicationTimeAndConfFiles(null, successfulInstall);\n      }\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":["6c94d2661bc1c14426980ec7882e951fdcff08d0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"08bcaef9e931052e4ca24133a89cc6aefaf61829","date":1342469326,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param force force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  @SuppressWarnings(\"unchecked\")\n  boolean fetchLatestIndex(SolrCore core, boolean force) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (force && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!force && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor();\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper.getCommitTimestamp(commit) >= latestVersion || force;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isFullCopyNeeded = true;\n      LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n      successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n      File indexDir = null ;\n      try {\n        indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory \" + tmpIndexDir);\n          delTree(tmpIndexDir);\n        } else {\n          LOG.info(\"removing old index directory \" + indexDir);\n          delTree(indexDir);\n        }\n      }\n    } finally {\n      if (!successfulInstall) {\n        logReplicationTimeAndConfFiles(null, successfulInstall);\n      }\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param force force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  @SuppressWarnings(\"unchecked\")\n  boolean fetchLatestIndex(SolrCore core, boolean force) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (force && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          core.getUpdateHandler().getSolrCoreState().getIndexWriter(core).deleteAll();\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!force && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor();\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper.getCommitTimestamp(commit) >= latestVersion || force;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isFullCopyNeeded = true;\n      LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n      successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n      File indexDir = null ;\n      try {\n        indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory \" + tmpIndexDir);\n          delTree(tmpIndexDir);\n        } else {\n          LOG.info(\"removing old index directory \" + indexDir);\n          delTree(indexDir);\n        }\n      }\n    } finally {\n      if (!successfulInstall) {\n        logReplicationTimeAndConfFiles(null, successfulInstall);\n      }\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":["6c94d2661bc1c14426980ec7882e951fdcff08d0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4897c5b415f476d84ec970a19c41510645887526","date":1342627582,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param force force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  @SuppressWarnings(\"unchecked\")\n  boolean fetchLatestIndex(SolrCore core, boolean force) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (force && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!force && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor();\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper.getCommitTimestamp(commit) >= latestVersion || force;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isFullCopyNeeded = true;\n      LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n      successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n\n      final File indexDir = new File(core.getIndexDir());\n      Directory oldDirectory = null;\n      try {\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n            RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n            try {\n               oldDirectory = iw.get().getDirectory();\n            } finally {\n              iw.decref();\n            }\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n        \n        if (isFullCopyNeeded) {\n          // we have to do this before commit\n          core.getDirectoryFactory().addCloseListener(oldDirectory, new CloseListener(){\n\n            @Override\n            public void onClose() {\n              LOG.info(\"removing old index directory \" + indexDir);\n              delTree(indexDir);\n            }\n            \n          });\n        }\n        \n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            core.getDirectoryFactory().doneWithDirectory(oldDirectory);\n          }\n          doCommit();\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory \" + tmpIndexDir);\n          delTree(tmpIndexDir);\n        } \n      }\n    } finally {\n      if (!successfulInstall) {\n        logReplicationTimeAndConfFiles(null, successfulInstall);\n      }\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param force force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  @SuppressWarnings(\"unchecked\")\n  boolean fetchLatestIndex(SolrCore core, boolean force) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (force && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!force && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor();\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper.getCommitTimestamp(commit) >= latestVersion || force;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isFullCopyNeeded = true;\n      LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n      successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n      File indexDir = null ;\n      try {\n        indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory \" + tmpIndexDir);\n          delTree(tmpIndexDir);\n        } else {\n          LOG.info(\"removing old index directory \" + indexDir);\n          delTree(indexDir);\n        }\n      }\n    } finally {\n      if (!successfulInstall) {\n        logReplicationTimeAndConfFiles(null, successfulInstall);\n      }\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":["6c94d2661bc1c14426980ec7882e951fdcff08d0","058801f8673d53a5abac8088204860ec29a40f0d","b6d2d51ff0b489e2d7ddc42a63f0d6cb69326469"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param force force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  @SuppressWarnings(\"unchecked\")\n  boolean fetchLatestIndex(SolrCore core, boolean force) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (force && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!force && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor();\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper.getCommitTimestamp(commit) >= latestVersion || force;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isFullCopyNeeded = true;\n      LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n      successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n\n      final File indexDir = new File(core.getIndexDir());\n      Directory oldDirectory = null;\n      try {\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n            RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n            try {\n               oldDirectory = iw.get().getDirectory();\n            } finally {\n              iw.decref();\n            }\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n        \n        if (isFullCopyNeeded) {\n          // we have to do this before commit\n          core.getDirectoryFactory().addCloseListener(oldDirectory, new CloseListener(){\n\n            @Override\n            public void onClose() {\n              LOG.info(\"removing old index directory \" + indexDir);\n              delTree(indexDir);\n            }\n            \n          });\n        }\n        \n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            core.getDirectoryFactory().doneWithDirectory(oldDirectory);\n          }\n          doCommit();\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory \" + tmpIndexDir);\n          delTree(tmpIndexDir);\n        } \n      }\n    } finally {\n      if (!successfulInstall) {\n        logReplicationTimeAndConfFiles(null, successfulInstall);\n      }\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","sourceOld":"  boolean fetchLatestIndex(SolrCore core, boolean force) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (force && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          core.getUpdateHandler().getSolrCoreState().getIndexWriter(core).deleteAll();\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!force && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor();\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper.getCommitTimestamp(commit) >= latestVersion || force;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isFullCopyNeeded = true;\n      LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n      successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n      File indexDir = null ;\n      try {\n        indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory \" + tmpIndexDir);\n          delTree(tmpIndexDir);\n        } else {\n          LOG.info(\"removing old index directory \" + indexDir);\n          delTree(indexDir);\n        }\n      }\n    } finally {\n      if (!successfulInstall) {\n        logReplicationTimeAndConfFiles(null, successfulInstall);\n      }\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d97814e287f694bcb4c679646ff4ac52fd8663c6","date":1343233467,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param force force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  @SuppressWarnings(\"unchecked\")\n  boolean fetchLatestIndex(SolrCore core, boolean force) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (force && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!force && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor();\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper.getCommitTimestamp(commit) >= latestVersion || force;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isFullCopyNeeded = true;\n      LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n      successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n\n      // make sure it's the newest known index dir...\n      final File indexDir = new File(core.getNewIndexDir());\n      Directory oldDirectory = null;\n      try {\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n            RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n            try {\n               oldDirectory = iw.get().getDirectory();\n            } finally {\n              iw.decref();\n            }\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n        \n        if (isFullCopyNeeded) {\n          // we have to do this before commit\n          core.getDirectoryFactory().addCloseListener(oldDirectory, new CloseListener(){\n\n            @Override\n            public void onClose() {\n              LOG.info(\"removing old index directory \" + indexDir);\n              delTree(indexDir);\n            }\n            \n          });\n        }\n        \n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            core.getDirectoryFactory().doneWithDirectory(oldDirectory);\n          }\n          doCommit();\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory \" + tmpIndexDir);\n          delTree(tmpIndexDir);\n        } \n      }\n    } finally {\n      if (!successfulInstall) {\n        logReplicationTimeAndConfFiles(null, successfulInstall);\n      }\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param force force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  @SuppressWarnings(\"unchecked\")\n  boolean fetchLatestIndex(SolrCore core, boolean force) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (force && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!force && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor();\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper.getCommitTimestamp(commit) >= latestVersion || force;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isFullCopyNeeded = true;\n      LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n      successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n\n      final File indexDir = new File(core.getIndexDir());\n      Directory oldDirectory = null;\n      try {\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n            RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n            try {\n               oldDirectory = iw.get().getDirectory();\n            } finally {\n              iw.decref();\n            }\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n        \n        if (isFullCopyNeeded) {\n          // we have to do this before commit\n          core.getDirectoryFactory().addCloseListener(oldDirectory, new CloseListener(){\n\n            @Override\n            public void onClose() {\n              LOG.info(\"removing old index directory \" + indexDir);\n              delTree(indexDir);\n            }\n            \n          });\n        }\n        \n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            core.getDirectoryFactory().doneWithDirectory(oldDirectory);\n          }\n          doCommit();\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory \" + tmpIndexDir);\n          delTree(tmpIndexDir);\n        } \n      }\n    } finally {\n      if (!successfulInstall) {\n        logReplicationTimeAndConfFiles(null, successfulInstall);\n      }\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":["058801f8673d53a5abac8088204860ec29a40f0d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param force force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  @SuppressWarnings(\"unchecked\")\n  boolean fetchLatestIndex(SolrCore core, boolean force) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (force && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!force && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor();\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper.getCommitTimestamp(commit) >= latestVersion || force;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isFullCopyNeeded = true;\n      LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n      successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n\n      // make sure it's the newest known index dir...\n      final File indexDir = new File(core.getNewIndexDir());\n      Directory oldDirectory = null;\n      try {\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n            RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n            try {\n               oldDirectory = iw.get().getDirectory();\n            } finally {\n              iw.decref();\n            }\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n        \n        if (isFullCopyNeeded) {\n          // we have to do this before commit\n          core.getDirectoryFactory().addCloseListener(oldDirectory, new CloseListener(){\n\n            @Override\n            public void onClose() {\n              LOG.info(\"removing old index directory \" + indexDir);\n              delTree(indexDir);\n            }\n            \n          });\n        }\n        \n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            core.getDirectoryFactory().doneWithDirectory(oldDirectory);\n          }\n          doCommit();\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory \" + tmpIndexDir);\n          delTree(tmpIndexDir);\n        } \n      }\n    } finally {\n      if (!successfulInstall) {\n        logReplicationTimeAndConfFiles(null, successfulInstall);\n      }\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param force force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  @SuppressWarnings(\"unchecked\")\n  boolean fetchLatestIndex(SolrCore core, boolean force) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (force && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          core.getUpdateHandler().getSolrCoreState().getIndexWriter(core).deleteAll();\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!force && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor();\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper.getCommitTimestamp(commit) >= latestVersion || force;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isFullCopyNeeded = true;\n      LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n      successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n      File indexDir = null ;\n      try {\n        indexDir = new File(core.getIndexDir());\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n            doCommit();\n          }\n        }\n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory \" + tmpIndexDir);\n          delTree(tmpIndexDir);\n        } else {\n          LOG.info(\"removing old index directory \" + indexDir);\n          delTree(indexDir);\n        }\n      }\n    } finally {\n      if (!successfulInstall) {\n        logReplicationTimeAndConfFiles(null, successfulInstall);\n      }\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","date":1343768312,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param force force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  @SuppressWarnings(\"unchecked\")\n  boolean fetchLatestIndex(SolrCore core, boolean force) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (force && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!force && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor();\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper.getCommitTimestamp(commit) >= latestVersion || force;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isFullCopyNeeded = true;\n      LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n      successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n\n      // make sure it's the newest known index dir...\n      final File indexDir = new File(core.getNewIndexDir());\n      Directory oldDirectory = null;\n      try {\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n            RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n            try {\n               oldDirectory = iw.get().getDirectory();\n            } finally {\n              iw.decref();\n            }\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n        \n        if (isFullCopyNeeded) {\n          // we have to do this before commit\n          core.getDirectoryFactory().addCloseListener(oldDirectory, new CloseListener(){\n\n            @Override\n            public void onClose() {\n              LOG.info(\"removing old index directory \" + indexDir);\n              delTree(indexDir);\n            }\n            \n          });\n        }\n        \n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            core.getDirectoryFactory().doneWithDirectory(oldDirectory);\n          }\n          doCommit();\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory \" + tmpIndexDir);\n          delTree(tmpIndexDir);\n        } \n      }\n    } finally {\n      if (!successfulInstall) {\n        logReplicationTimeAndConfFiles(null, successfulInstall);\n      }\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param force force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  @SuppressWarnings(\"unchecked\")\n  boolean fetchLatestIndex(SolrCore core, boolean force) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (force && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!force && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor();\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper.getCommitTimestamp(commit) >= latestVersion || force;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isFullCopyNeeded = true;\n      LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n      successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n\n      final File indexDir = new File(core.getIndexDir());\n      Directory oldDirectory = null;\n      try {\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n            RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n            try {\n               oldDirectory = iw.get().getDirectory();\n            } finally {\n              iw.decref();\n            }\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n        \n        if (isFullCopyNeeded) {\n          // we have to do this before commit\n          core.getDirectoryFactory().addCloseListener(oldDirectory, new CloseListener(){\n\n            @Override\n            public void onClose() {\n              LOG.info(\"removing old index directory \" + indexDir);\n              delTree(indexDir);\n            }\n            \n          });\n        }\n        \n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            core.getDirectoryFactory().doneWithDirectory(oldDirectory);\n          }\n          doCommit();\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory \" + tmpIndexDir);\n          delTree(tmpIndexDir);\n        } \n      }\n    } finally {\n      if (!successfulInstall) {\n        logReplicationTimeAndConfFiles(null, successfulInstall);\n      }\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1c8719b2c0b382be11f5b193b6fc14bc310e906b","date":1344770591,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param force force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  @SuppressWarnings(\"unchecked\")\n  boolean fetchLatestIndex(SolrCore core, boolean force) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (force && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!force && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper.getCommitTimestamp(commit) >= latestVersion || force;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isFullCopyNeeded = true;\n      LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n      successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n\n      // make sure it's the newest known index dir...\n      final File indexDir = new File(core.getNewIndexDir());\n      Directory oldDirectory = null;\n      try {\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n            RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n            try {\n               oldDirectory = iw.get().getDirectory();\n            } finally {\n              iw.decref();\n            }\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n        \n        if (isFullCopyNeeded) {\n          // we have to do this before commit\n          core.getDirectoryFactory().addCloseListener(oldDirectory, new CloseListener(){\n\n            @Override\n            public void onClose() {\n              LOG.info(\"removing old index directory \" + indexDir);\n              delTree(indexDir);\n            }\n            \n          });\n        }\n        \n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            core.getDirectoryFactory().doneWithDirectory(oldDirectory);\n          }\n          doCommit();\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory \" + tmpIndexDir);\n          delTree(tmpIndexDir);\n        } \n      }\n    } finally {\n      if (!successfulInstall) {\n        logReplicationTimeAndConfFiles(null, successfulInstall);\n      }\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param force force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  @SuppressWarnings(\"unchecked\")\n  boolean fetchLatestIndex(SolrCore core, boolean force) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (force && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!force && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor();\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper.getCommitTimestamp(commit) >= latestVersion || force;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isFullCopyNeeded = true;\n      LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n      successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n\n      // make sure it's the newest known index dir...\n      final File indexDir = new File(core.getNewIndexDir());\n      Directory oldDirectory = null;\n      try {\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n            RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n            try {\n               oldDirectory = iw.get().getDirectory();\n            } finally {\n              iw.decref();\n            }\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n        \n        if (isFullCopyNeeded) {\n          // we have to do this before commit\n          core.getDirectoryFactory().addCloseListener(oldDirectory, new CloseListener(){\n\n            @Override\n            public void onClose() {\n              LOG.info(\"removing old index directory \" + indexDir);\n              delTree(indexDir);\n            }\n            \n          });\n        }\n        \n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            core.getDirectoryFactory().doneWithDirectory(oldDirectory);\n          }\n          doCommit();\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory \" + tmpIndexDir);\n          delTree(tmpIndexDir);\n        } \n      }\n    } finally {\n      if (!successfulInstall) {\n        logReplicationTimeAndConfFiles(null, successfulInstall);\n      }\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":["6c94d2661bc1c14426980ec7882e951fdcff08d0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c7869f64c874ebf7f317d22c00baf2b6857797a6","date":1344856617,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param force force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  @SuppressWarnings(\"unchecked\")\n  boolean fetchLatestIndex(SolrCore core, boolean force) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (force && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!force && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper.getCommitTimestamp(commit) >= latestVersion || force;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isFullCopyNeeded = true;\n      LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n      successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n\n      // make sure it's the newest known index dir...\n      final File indexDir = new File(core.getNewIndexDir());\n      Directory oldDirectory = null;\n      try {\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n            RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n            try {\n               oldDirectory = iw.get().getDirectory();\n            } finally {\n              iw.decref();\n            }\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n        \n        if (isFullCopyNeeded) {\n          // we have to do this before commit\n          core.getDirectoryFactory().addCloseListener(oldDirectory, new CloseListener(){\n\n            @Override\n            public void onClose() {\n              LOG.info(\"removing old index directory \" + indexDir);\n              delTree(indexDir);\n            }\n            \n          });\n        }\n        \n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            core.getDirectoryFactory().doneWithDirectory(oldDirectory);\n          }\n          doCommit();\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory \" + tmpIndexDir);\n          delTree(tmpIndexDir);\n        } \n      }\n    } finally {\n      if (!successfulInstall) {\n        logReplicationTimeAndConfFiles(null, successfulInstall);\n      }\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param force force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  @SuppressWarnings(\"unchecked\")\n  boolean fetchLatestIndex(SolrCore core, boolean force) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (force && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!force && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor();\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper.getCommitTimestamp(commit) >= latestVersion || force;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isFullCopyNeeded = true;\n      LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n      successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n\n      // make sure it's the newest known index dir...\n      final File indexDir = new File(core.getNewIndexDir());\n      Directory oldDirectory = null;\n      try {\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n            RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n            try {\n               oldDirectory = iw.get().getDirectory();\n            } finally {\n              iw.decref();\n            }\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n        \n        if (isFullCopyNeeded) {\n          // we have to do this before commit\n          core.getDirectoryFactory().addCloseListener(oldDirectory, new CloseListener(){\n\n            @Override\n            public void onClose() {\n              LOG.info(\"removing old index directory \" + indexDir);\n              delTree(indexDir);\n            }\n            \n          });\n        }\n        \n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            core.getDirectoryFactory().doneWithDirectory(oldDirectory);\n          }\n          doCommit();\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory \" + tmpIndexDir);\n          delTree(tmpIndexDir);\n        } \n      }\n    } finally {\n      if (!successfulInstall) {\n        logReplicationTimeAndConfFiles(null, successfulInstall);\n      }\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9","date":1344867506,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param force force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  @SuppressWarnings(\"unchecked\")\n  boolean fetchLatestIndex(SolrCore core, boolean force) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (force && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!force && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper.getCommitTimestamp(commit) >= latestVersion || force;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isFullCopyNeeded = true;\n      LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n      successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n\n      // make sure it's the newest known index dir...\n      final File indexDir = new File(core.getNewIndexDir());\n      Directory oldDirectory = null;\n      try {\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n            RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n            try {\n               oldDirectory = iw.get().getDirectory();\n            } finally {\n              iw.decref();\n            }\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n        \n        if (isFullCopyNeeded) {\n          // we have to do this before commit\n          core.getDirectoryFactory().addCloseListener(oldDirectory, new CloseListener(){\n\n            @Override\n            public void onClose() {\n              LOG.info(\"removing old index directory \" + indexDir);\n              delTree(indexDir);\n            }\n            \n          });\n        }\n        \n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            core.getDirectoryFactory().doneWithDirectory(oldDirectory);\n          }\n          doCommit();\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory \" + tmpIndexDir);\n          delTree(tmpIndexDir);\n        } \n      }\n    } finally {\n      if (!successfulInstall) {\n        logReplicationTimeAndConfFiles(null, successfulInstall);\n      }\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param force force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  @SuppressWarnings(\"unchecked\")\n  boolean fetchLatestIndex(SolrCore core, boolean force) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (force && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!force && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor();\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper.getCommitTimestamp(commit) >= latestVersion || force;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isFullCopyNeeded = true;\n      LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n      successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n\n      // make sure it's the newest known index dir...\n      final File indexDir = new File(core.getNewIndexDir());\n      Directory oldDirectory = null;\n      try {\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n            RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n            try {\n               oldDirectory = iw.get().getDirectory();\n            } finally {\n              iw.decref();\n            }\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n        \n        if (isFullCopyNeeded) {\n          // we have to do this before commit\n          core.getDirectoryFactory().addCloseListener(oldDirectory, new CloseListener(){\n\n            @Override\n            public void onClose() {\n              LOG.info(\"removing old index directory \" + indexDir);\n              delTree(indexDir);\n            }\n            \n          });\n        }\n        \n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            core.getDirectoryFactory().doneWithDirectory(oldDirectory);\n          }\n          doCommit();\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory \" + tmpIndexDir);\n          delTree(tmpIndexDir);\n        } \n      }\n    } finally {\n      if (!successfulInstall) {\n        logReplicationTimeAndConfFiles(null, successfulInstall);\n      }\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"66c64e8cfded6a585100e6430238faaf416f3fea","date":1344964603,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper.getCommitTimestamp(commit) >= latestVersion || forceReplication;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale()) {\n        isFullCopyNeeded = true;\n      }\n      LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n      successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n\n      // make sure it's the newest known index dir...\n      final File indexDir = new File(core.getNewIndexDir());\n      Directory oldDirectory = null;\n      try {\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n            RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n            try {\n               oldDirectory = iw.get().getDirectory();\n            } finally {\n              iw.decref();\n            }\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n        \n        if (isFullCopyNeeded) {\n          // we have to do this before commit\n          core.getDirectoryFactory().addCloseListener(oldDirectory, new CloseListener(){\n\n            @Override\n            public void onClose() {\n              LOG.info(\"removing old index directory \" + indexDir);\n              delTree(indexDir);\n            }\n            \n          });\n        }\n        \n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            core.getDirectoryFactory().doneWithDirectory(oldDirectory);\n          }\n          doCommit();\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory \" + tmpIndexDir);\n          delTree(tmpIndexDir);\n        } \n      }\n    } finally {\n      if (!successfulInstall) {\n        logReplicationTimeAndConfFiles(null, successfulInstall);\n      }\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param force force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  @SuppressWarnings(\"unchecked\")\n  boolean fetchLatestIndex(SolrCore core, boolean force) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (force && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!force && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper.getCommitTimestamp(commit) >= latestVersion || force;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isFullCopyNeeded = true;\n      LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n      successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n\n      // make sure it's the newest known index dir...\n      final File indexDir = new File(core.getNewIndexDir());\n      Directory oldDirectory = null;\n      try {\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n            RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n            try {\n               oldDirectory = iw.get().getDirectory();\n            } finally {\n              iw.decref();\n            }\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n        \n        if (isFullCopyNeeded) {\n          // we have to do this before commit\n          core.getDirectoryFactory().addCloseListener(oldDirectory, new CloseListener(){\n\n            @Override\n            public void onClose() {\n              LOG.info(\"removing old index directory \" + indexDir);\n              delTree(indexDir);\n            }\n            \n          });\n        }\n        \n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            core.getDirectoryFactory().doneWithDirectory(oldDirectory);\n          }\n          doCommit();\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory \" + tmpIndexDir);\n          delTree(tmpIndexDir);\n        } \n      }\n    } finally {\n      if (!successfulInstall) {\n        logReplicationTimeAndConfFiles(null, successfulInstall);\n      }\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":["6c94d2661bc1c14426980ec7882e951fdcff08d0","be4d0855f94432c9a580ae7750c6f842d604a3e4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","date":1345029782,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper.getCommitTimestamp(commit) >= latestVersion || forceReplication;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale()) {\n        isFullCopyNeeded = true;\n      }\n      LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n      successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n\n      // make sure it's the newest known index dir...\n      final File indexDir = new File(core.getNewIndexDir());\n      Directory oldDirectory = null;\n      try {\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n            RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n            try {\n               oldDirectory = iw.get().getDirectory();\n            } finally {\n              iw.decref();\n            }\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n        \n        if (isFullCopyNeeded) {\n          // we have to do this before commit\n          core.getDirectoryFactory().addCloseListener(oldDirectory, new CloseListener(){\n\n            @Override\n            public void onClose() {\n              LOG.info(\"removing old index directory \" + indexDir);\n              delTree(indexDir);\n            }\n            \n          });\n        }\n        \n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            core.getDirectoryFactory().doneWithDirectory(oldDirectory);\n          }\n          doCommit();\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory \" + tmpIndexDir);\n          delTree(tmpIndexDir);\n        } \n      }\n    } finally {\n      if (!successfulInstall) {\n        logReplicationTimeAndConfFiles(null, successfulInstall);\n      }\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param force force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  @SuppressWarnings(\"unchecked\")\n  boolean fetchLatestIndex(SolrCore core, boolean force) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (force && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!force && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper.getCommitTimestamp(commit) >= latestVersion || force;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isFullCopyNeeded = true;\n      LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n      successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n\n      // make sure it's the newest known index dir...\n      final File indexDir = new File(core.getNewIndexDir());\n      Directory oldDirectory = null;\n      try {\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n            RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n            try {\n               oldDirectory = iw.get().getDirectory();\n            } finally {\n              iw.decref();\n            }\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n        \n        if (isFullCopyNeeded) {\n          // we have to do this before commit\n          core.getDirectoryFactory().addCloseListener(oldDirectory, new CloseListener(){\n\n            @Override\n            public void onClose() {\n              LOG.info(\"removing old index directory \" + indexDir);\n              delTree(indexDir);\n            }\n            \n          });\n        }\n        \n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            core.getDirectoryFactory().doneWithDirectory(oldDirectory);\n          }\n          doCommit();\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory \" + tmpIndexDir);\n          delTree(tmpIndexDir);\n        } \n      }\n    } finally {\n      if (!successfulInstall) {\n        logReplicationTimeAndConfFiles(null, successfulInstall);\n      }\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b05c56a41b733e02a189c48895922b5bd8c7f3d1","date":1345033322,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper.getCommitTimestamp(commit) >= latestVersion || forceReplication;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale()) {\n        isFullCopyNeeded = true;\n      }\n      LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n      successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n\n      // make sure it's the newest known index dir...\n      final File indexDir = new File(core.getNewIndexDir());\n      Directory oldDirectory = null;\n      try {\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n            RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n            try {\n               oldDirectory = iw.get().getDirectory();\n            } finally {\n              iw.decref();\n            }\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n        \n        if (isFullCopyNeeded) {\n          // we have to do this before commit\n          core.getDirectoryFactory().addCloseListener(oldDirectory, new CloseListener(){\n\n            @Override\n            public void onClose() {\n              LOG.info(\"removing old index directory \" + indexDir);\n              delTree(indexDir);\n            }\n            \n          });\n        }\n        \n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            core.getDirectoryFactory().doneWithDirectory(oldDirectory);\n          }\n          doCommit();\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory \" + tmpIndexDir);\n          delTree(tmpIndexDir);\n        } \n      }\n    } finally {\n      if (!successfulInstall) {\n        logReplicationTimeAndConfFiles(null, successfulInstall);\n      }\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param force force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  @SuppressWarnings(\"unchecked\")\n  boolean fetchLatestIndex(SolrCore core, boolean force) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (force && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!force && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper.getCommitTimestamp(commit) >= latestVersion || force;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale())\n        isFullCopyNeeded = true;\n      LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n      successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n\n      // make sure it's the newest known index dir...\n      final File indexDir = new File(core.getNewIndexDir());\n      Directory oldDirectory = null;\n      try {\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n            RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n            try {\n               oldDirectory = iw.get().getDirectory();\n            } finally {\n              iw.decref();\n            }\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n        \n        if (isFullCopyNeeded) {\n          // we have to do this before commit\n          core.getDirectoryFactory().addCloseListener(oldDirectory, new CloseListener(){\n\n            @Override\n            public void onClose() {\n              LOG.info(\"removing old index directory \" + indexDir);\n              delTree(indexDir);\n            }\n            \n          });\n        }\n        \n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            core.getDirectoryFactory().doneWithDirectory(oldDirectory);\n          }\n          doCommit();\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory \" + tmpIndexDir);\n          delTree(tmpIndexDir);\n        } \n      }\n    } finally {\n      if (!successfulInstall) {\n        logReplicationTimeAndConfFiles(null, successfulInstall);\n      }\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b6d2d51ff0b489e2d7ddc42a63f0d6cb69326469","date":1345037674,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper.getCommitTimestamp(commit) >= latestVersion || forceReplication;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale()) {\n        isFullCopyNeeded = true;\n      }\n      LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n      successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n\n      // make sure it's the newest known index dir...\n      final File indexDir = new File(core.getNewIndexDir());\n      Directory oldDirectory = null;\n      try {\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n            RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n            try {\n               oldDirectory = iw.get().getDirectory();\n            } finally {\n              iw.decref();\n            }\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n        \n        if (isFullCopyNeeded) {\n          // we have to do this before commit\n          core.getDirectoryFactory().addCloseListener(oldDirectory, new CloseListener(){\n\n            @Override\n            public void onClose() {\n              LOG.info(\"removing old index directory \" + indexDir);\n              delTree(indexDir);\n            }\n            \n          });\n        }\n        \n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            core.getDirectoryFactory().doneWithDirectory(oldDirectory);\n          }\n          doCommit(isFullCopyNeeded);\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory \" + tmpIndexDir);\n          delTree(tmpIndexDir);\n        } \n      }\n    } finally {\n      if (!successfulInstall) {\n        logReplicationTimeAndConfFiles(null, successfulInstall);\n      }\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper.getCommitTimestamp(commit) >= latestVersion || forceReplication;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale()) {\n        isFullCopyNeeded = true;\n      }\n      LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n      successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n\n      // make sure it's the newest known index dir...\n      final File indexDir = new File(core.getNewIndexDir());\n      Directory oldDirectory = null;\n      try {\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n            RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n            try {\n               oldDirectory = iw.get().getDirectory();\n            } finally {\n              iw.decref();\n            }\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n        \n        if (isFullCopyNeeded) {\n          // we have to do this before commit\n          core.getDirectoryFactory().addCloseListener(oldDirectory, new CloseListener(){\n\n            @Override\n            public void onClose() {\n              LOG.info(\"removing old index directory \" + indexDir);\n              delTree(indexDir);\n            }\n            \n          });\n        }\n        \n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            core.getDirectoryFactory().doneWithDirectory(oldDirectory);\n          }\n          doCommit();\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory \" + tmpIndexDir);\n          delTree(tmpIndexDir);\n        } \n      }\n    } finally {\n      if (!successfulInstall) {\n        logReplicationTimeAndConfFiles(null, successfulInstall);\n      }\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","bugFix":["4897c5b415f476d84ec970a19c41510645887526"],"bugIntro":["bd8bc29700397ec1886e73bae0a67ff536bad223"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"70fa1c0f4d75735ff2e1485e059d9bc5efa50598","date":1345296911,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper.getCommitTimestamp(commit) >= latestVersion || forceReplication;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale()) {\n        isFullCopyNeeded = true;\n      }\n      LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n      successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n\n      // make sure it's the newest known index dir...\n      final File indexDir = new File(core.getNewIndexDir());\n      Directory oldDirectory = null;\n      try {\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n            RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n            try {\n               oldDirectory = iw.get().getDirectory();\n            } finally {\n              iw.decref();\n            }\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n        \n        if (isFullCopyNeeded) {\n          // we have to do this before commit\n          core.getDirectoryFactory().addCloseListener(oldDirectory, new CloseListener(){\n\n            @Override\n            public void onClose() {\n              LOG.info(\"removing old index directory \" + indexDir);\n              delTree(indexDir);\n            }\n            \n          });\n        }\n        \n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            core.getDirectoryFactory().doneWithDirectory(oldDirectory);\n          }\n          doCommit(isFullCopyNeeded);\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory \" + tmpIndexDir);\n          delTree(tmpIndexDir);\n        } \n      }\n    } finally {\n      if (!successfulInstall) {\n        logReplicationTimeAndConfFiles(null, successfulInstall);\n      }\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper.getCommitTimestamp(commit) >= latestVersion || forceReplication;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale()) {\n        isFullCopyNeeded = true;\n      }\n      LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n      successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n\n      // make sure it's the newest known index dir...\n      final File indexDir = new File(core.getNewIndexDir());\n      Directory oldDirectory = null;\n      try {\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n            RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n            try {\n               oldDirectory = iw.get().getDirectory();\n            } finally {\n              iw.decref();\n            }\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n        \n        if (isFullCopyNeeded) {\n          // we have to do this before commit\n          core.getDirectoryFactory().addCloseListener(oldDirectory, new CloseListener(){\n\n            @Override\n            public void onClose() {\n              LOG.info(\"removing old index directory \" + indexDir);\n              delTree(indexDir);\n            }\n            \n          });\n        }\n        \n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            core.getDirectoryFactory().doneWithDirectory(oldDirectory);\n          }\n          doCommit();\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory \" + tmpIndexDir);\n          delTree(tmpIndexDir);\n        } \n      }\n    } finally {\n      if (!successfulInstall) {\n        logReplicationTimeAndConfFiles(null, successfulInstall);\n      }\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"616c1830142ff5c1ddedec1ed898733b73c8e23b","date":1345368925,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper.getCommitTimestamp(commit) >= latestVersion || forceReplication;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale()) {\n        isFullCopyNeeded = true;\n      }\n      LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n      successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n\n      // make sure it's the newest known index dir...\n      final File indexDir = new File(core.getNewIndexDir());\n      Directory oldDirectory = null;\n      try {\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n            RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n            try {\n               oldDirectory = iw.get().getDirectory();\n            } finally {\n              iw.decref();\n            }\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n        \n        if (isFullCopyNeeded) {\n          // we have to do this before commit\n          core.getDirectoryFactory().addCloseListener(oldDirectory, new CloseListener(){\n\n            @Override\n            public void onClose() {\n              LOG.info(\"removing old index directory \" + indexDir);\n              delTree(indexDir);\n            }\n            \n          });\n        }\n        \n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            core.getDirectoryFactory().doneWithDirectory(oldDirectory);\n          }\n          doCommit(isFullCopyNeeded);\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory \" + tmpIndexDir);\n          delTree(tmpIndexDir);\n        } \n      }\n    } finally {\n      if (!successfulInstall) {\n        logReplicationTimeAndConfFiles(null, successfulInstall);\n      }\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper.getCommitTimestamp(commit) >= latestVersion || forceReplication;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale()) {\n        isFullCopyNeeded = true;\n      }\n      LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n      successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n\n      // make sure it's the newest known index dir...\n      final File indexDir = new File(core.getNewIndexDir());\n      Directory oldDirectory = null;\n      try {\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n            RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n            try {\n               oldDirectory = iw.get().getDirectory();\n            } finally {\n              iw.decref();\n            }\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n        \n        if (isFullCopyNeeded) {\n          // we have to do this before commit\n          core.getDirectoryFactory().addCloseListener(oldDirectory, new CloseListener(){\n\n            @Override\n            public void onClose() {\n              LOG.info(\"removing old index directory \" + indexDir);\n              delTree(indexDir);\n            }\n            \n          });\n        }\n        \n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            core.getDirectoryFactory().doneWithDirectory(oldDirectory);\n          }\n          doCommit();\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory \" + tmpIndexDir);\n          delTree(tmpIndexDir);\n        } \n      }\n    } finally {\n      if (!successfulInstall) {\n        logReplicationTimeAndConfFiles(null, successfulInstall);\n      }\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d9405f486872f1e416304dfe389741f4ee2f8a4d","date":1351276739,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(final SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    Directory tmpIndexDir = null;\n    Directory indexDir = null;\n    boolean deleteTmpIdxDir = true;\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper.getCommitTimestamp(commit) >= latestVersion || forceReplication;\n      \n      String tmpIdxDirName = \"index.\" + new SimpleDateFormat(SnapShooter.DATE_FMT, Locale.ROOT).format(new Date());\n      String tmpIndex = createTempindexDir(core, tmpIdxDirName);\n\n      tmpIndexDir = core.getDirectoryFactory().get(tmpIndex, null);\n      \n      // make sure it's the newest known index dir...\n      indexDir = core.getDirectoryFactory().get(core.getNewIndexDir(), null);\n      Directory oldDirectory = null;\n\n      try {\n        \n        if (isIndexStale(indexDir)) {\n          isFullCopyNeeded = true;\n        }\n        LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n        successfulInstall = false;\n        \n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir  =  false;\n          } else {\n            successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir =  false;\n            RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n            try {\n               oldDirectory = iw.get().getDirectory();\n            } finally {\n              iw.decref();\n            }\n          } else {\n            successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n        \n        if (isFullCopyNeeded) {\n          // we have to do this before commit\n          final Directory freezeIndexDir = indexDir;\n          core.getDirectoryFactory().addCloseListener(oldDirectory, new CloseListener(){\n\n            @Override\n            public void preClose() {\n              LOG.info(\"removing old index files \" + freezeIndexDir);\n              DirectoryFactory.empty(freezeIndexDir);\n            }\n            \n            @Override\n            public void postClose() {\n              LOG.info(\"removing old index directory \" + freezeIndexDir);\n              try {\n                core.getDirectoryFactory().remove(freezeIndexDir);\n              } catch (IOException e) {\n                SolrException.log(LOG, \"Error removing directory \" + freezeIndexDir, e);\n              }\n            }\n            \n          });\n        }\n\n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            core.getDirectoryFactory().doneWithDirectory(oldDirectory);\n          }\n          doCommit(isFullCopyNeeded);\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory files \" + tmpIndexDir);\n          DirectoryFactory.empty(tmpIndexDir);\n        } \n      }\n    } finally {\n      try {\n        if (!successfulInstall) {\n          logReplicationTimeAndConfFiles(null, successfulInstall);\n        }\n        filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n        replicationStartTime = 0;\n        dirFileFetcher = null;\n        localFileFetcher = null;\n        if (fsyncService != null && !fsyncService.isShutdown()) fsyncService\n            .shutdownNow();\n        fsyncService = null;\n        stop = false;\n        fsyncException = null;\n      } finally {\n        if (tmpIndexDir != null) {\n          core.getDirectoryFactory().release(tmpIndexDir);\n        }\n        if (deleteTmpIdxDir && tmpIndexDir != null) {\n          try {\n            core.getDirectoryFactory().remove(tmpIndexDir);\n          } catch (IOException e) {\n            SolrException.log(LOG, \"Error removing directory \" + tmpIndexDir, e);\n          }\n        }\n        if (indexDir != null) {\n          core.getDirectoryFactory().release(indexDir);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper.getCommitTimestamp(commit) >= latestVersion || forceReplication;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale()) {\n        isFullCopyNeeded = true;\n      }\n      LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n      successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n\n      // make sure it's the newest known index dir...\n      final File indexDir = new File(core.getNewIndexDir());\n      Directory oldDirectory = null;\n      try {\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n            RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n            try {\n               oldDirectory = iw.get().getDirectory();\n            } finally {\n              iw.decref();\n            }\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n        \n        if (isFullCopyNeeded) {\n          // we have to do this before commit\n          core.getDirectoryFactory().addCloseListener(oldDirectory, new CloseListener(){\n\n            @Override\n            public void onClose() {\n              LOG.info(\"removing old index directory \" + indexDir);\n              delTree(indexDir);\n            }\n            \n          });\n        }\n        \n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            core.getDirectoryFactory().doneWithDirectory(oldDirectory);\n          }\n          doCommit(isFullCopyNeeded);\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory \" + tmpIndexDir);\n          delTree(tmpIndexDir);\n        } \n      }\n    } finally {\n      if (!successfulInstall) {\n        logReplicationTimeAndConfFiles(null, successfulInstall);\n      }\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":["6c94d2661bc1c14426980ec7882e951fdcff08d0","058801f8673d53a5abac8088204860ec29a40f0d","be4d0855f94432c9a580ae7750c6f842d604a3e4","0fa112cb510d1bdb66c944fe9ba78679974d3c14","190779ba7de3fda15afd1bbafbc383720a4b0966","718607d99d02778db3280e64975663762c94170d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f2126b84bd093fa3d921582a109a0ee578c28126","date":1351522501,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(final SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    Directory tmpIndexDir = null;\n    Directory indexDir = null;\n    boolean deleteTmpIdxDir = true;\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper.getCommitTimestamp(commit) >= latestVersion || forceReplication;\n      \n      String tmpIdxDirName = \"index.\" + new SimpleDateFormat(SnapShooter.DATE_FMT, Locale.ROOT).format(new Date());\n      String tmpIndex = createTempindexDir(core, tmpIdxDirName);\n\n      tmpIndexDir = core.getDirectoryFactory().get(tmpIndex, null);\n      \n      // make sure it's the newest known index dir...\n      indexDir = core.getDirectoryFactory().get(core.getNewIndexDir(), null);\n      Directory oldDirectory = null;\n\n      try {\n        \n        if (isIndexStale(indexDir)) {\n          isFullCopyNeeded = true;\n        }\n        LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n        successfulInstall = false;\n        \n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir  =  false;\n          } else {\n            successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir =  false;\n            RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n            try {\n               oldDirectory = iw.get().getDirectory();\n            } finally {\n              iw.decref();\n            }\n          } else {\n            successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n        \n        if (isFullCopyNeeded) {\n          // we have to do this before commit\n          final Directory freezeIndexDir = indexDir;\n          core.getDirectoryFactory().addCloseListener(oldDirectory, new CloseListener(){\n\n            @Override\n            public void preClose() {\n              LOG.info(\"removing old index files \" + freezeIndexDir);\n              DirectoryFactory.empty(freezeIndexDir);\n            }\n            \n            @Override\n            public void postClose() {\n              LOG.info(\"removing old index directory \" + freezeIndexDir);\n              try {\n                core.getDirectoryFactory().remove(freezeIndexDir);\n              } catch (IOException e) {\n                SolrException.log(LOG, \"Error removing directory \" + freezeIndexDir, e);\n              }\n            }\n            \n          });\n        }\n\n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            core.getDirectoryFactory().doneWithDirectory(oldDirectory);\n          }\n          doCommit(isFullCopyNeeded);\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory files \" + tmpIndexDir);\n          DirectoryFactory.empty(tmpIndexDir);\n        } \n      }\n    } finally {\n      try {\n        if (!successfulInstall) {\n          logReplicationTimeAndConfFiles(null, successfulInstall);\n        }\n        filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n        replicationStartTime = 0;\n        dirFileFetcher = null;\n        localFileFetcher = null;\n        if (fsyncService != null && !fsyncService.isShutdown()) fsyncService\n            .shutdownNow();\n        fsyncService = null;\n        stop = false;\n        fsyncException = null;\n      } finally {\n        if (tmpIndexDir != null) {\n          core.getDirectoryFactory().release(tmpIndexDir);\n        }\n        if (deleteTmpIdxDir && tmpIndexDir != null) {\n          try {\n            core.getDirectoryFactory().remove(tmpIndexDir);\n          } catch (IOException e) {\n            SolrException.log(LOG, \"Error removing directory \" + tmpIndexDir, e);\n          }\n        }\n        if (indexDir != null) {\n          core.getDirectoryFactory().release(indexDir);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper.getCommitTimestamp(commit) >= latestVersion || forceReplication;\n      File tmpIndexDir = createTempindexDir(core);\n      if (isIndexStale()) {\n        isFullCopyNeeded = true;\n      }\n      LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n      successfulInstall = false;\n      boolean deleteTmpIdxDir = true;\n\n      // make sure it's the newest known index dir...\n      final File indexDir = new File(core.getNewIndexDir());\n      Directory oldDirectory = null;\n      try {\n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIndexDir.getName());\n            deleteTmpIdxDir =  false;\n            RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n            try {\n               oldDirectory = iw.get().getDirectory();\n            } finally {\n              iw.decref();\n            }\n          } else {\n            successfulInstall = copyIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n        \n        if (isFullCopyNeeded) {\n          // we have to do this before commit\n          core.getDirectoryFactory().addCloseListener(oldDirectory, new CloseListener(){\n\n            @Override\n            public void onClose() {\n              LOG.info(\"removing old index directory \" + indexDir);\n              delTree(indexDir);\n            }\n            \n          });\n        }\n        \n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            core.getDirectoryFactory().doneWithDirectory(oldDirectory);\n          }\n          doCommit(isFullCopyNeeded);\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory \" + tmpIndexDir);\n          delTree(tmpIndexDir);\n        } \n      }\n    } finally {\n      if (!successfulInstall) {\n        logReplicationTimeAndConfFiles(null, successfulInstall);\n      }\n      filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n      replicationStartTime = 0;\n      fileFetcher = null;\n      if (fsyncService != null && !fsyncService.isShutdown()) fsyncService.shutdownNow();\n      fsyncService = null;\n      stop = false;\n      fsyncException = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2a77b0d8787d127be70f6c4055937ee9c0d4ee3b","date":1354032015,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(final SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    Directory tmpIndexDir = null;\n    String tmpIndex = null;\n    Directory indexDir = null;\n    boolean deleteTmpIdxDir = true;\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper.getCommitTimestamp(commit) >= latestVersion || forceReplication;\n      \n      String tmpIdxDirName = \"index.\" + new SimpleDateFormat(SnapShooter.DATE_FMT, Locale.ROOT).format(new Date());\n      tmpIndex = createTempindexDir(core, tmpIdxDirName);\n\n      tmpIndexDir = core.getDirectoryFactory().get(tmpIndex, null);\n      \n      // make sure it's the newest known index dir...\n      indexDir = core.getDirectoryFactory().get(core.getNewIndexDir(), null);\n      Directory oldDirectory = null;\n\n      try {\n        \n        if (isIndexStale(indexDir)) {\n          isFullCopyNeeded = true;\n        }\n        LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n        successfulInstall = false;\n        \n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir  =  false;\n          } else {\n            successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir =  false;\n            RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n            try {\n               oldDirectory = iw.get().getDirectory();\n            } finally {\n              iw.decref();\n            }\n          } else {\n            successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n        \n        if (isFullCopyNeeded) {\n          // we have to do this before commit\n          final Directory freezeIndexDir = indexDir;\n          core.getDirectoryFactory().addCloseListener(oldDirectory, new CloseListener(){\n\n            @Override\n            public void preClose() {\n              LOG.info(\"removing old index files \" + freezeIndexDir);\n              DirectoryFactory.empty(freezeIndexDir);\n            }\n            \n            @Override\n            public void postClose() {\n              LOG.info(\"removing old index directory \" + freezeIndexDir);\n              try {\n                core.getDirectoryFactory().remove(freezeIndexDir);\n              } catch (IOException e) {\n                SolrException.log(LOG, \"Error removing directory \" + freezeIndexDir, e);\n              }\n            }\n            \n          });\n        }\n\n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            core.getDirectoryFactory().doneWithDirectory(oldDirectory);\n          }\n          doCommit(isFullCopyNeeded);\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory files \" + tmpIndexDir);\n          if (tmpIndex != null && core.getDirectoryFactory().exists(tmpIndex)) {\n            DirectoryFactory.empty(tmpIndexDir);\n          }\n        } \n      }\n    } finally {\n      try {\n        if (!successfulInstall) {\n          logReplicationTimeAndConfFiles(null, successfulInstall);\n        }\n        filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n        replicationStartTime = 0;\n        dirFileFetcher = null;\n        localFileFetcher = null;\n        if (fsyncService != null && !fsyncService.isShutdown()) fsyncService\n            .shutdownNow();\n        fsyncService = null;\n        stop = false;\n        fsyncException = null;\n      } finally {\n        if (tmpIndexDir != null) {\n          core.getDirectoryFactory().release(tmpIndexDir);\n        }\n        if (deleteTmpIdxDir && tmpIndexDir != null) {\n          try {\n            core.getDirectoryFactory().remove(tmpIndexDir);\n          } catch (IOException e) {\n            SolrException.log(LOG, \"Error removing directory \" + tmpIndexDir, e);\n          }\n        }\n        if (indexDir != null) {\n          core.getDirectoryFactory().release(indexDir);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(final SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    Directory tmpIndexDir = null;\n    Directory indexDir = null;\n    boolean deleteTmpIdxDir = true;\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper.getCommitTimestamp(commit) >= latestVersion || forceReplication;\n      \n      String tmpIdxDirName = \"index.\" + new SimpleDateFormat(SnapShooter.DATE_FMT, Locale.ROOT).format(new Date());\n      String tmpIndex = createTempindexDir(core, tmpIdxDirName);\n\n      tmpIndexDir = core.getDirectoryFactory().get(tmpIndex, null);\n      \n      // make sure it's the newest known index dir...\n      indexDir = core.getDirectoryFactory().get(core.getNewIndexDir(), null);\n      Directory oldDirectory = null;\n\n      try {\n        \n        if (isIndexStale(indexDir)) {\n          isFullCopyNeeded = true;\n        }\n        LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n        successfulInstall = false;\n        \n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir  =  false;\n          } else {\n            successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir =  false;\n            RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n            try {\n               oldDirectory = iw.get().getDirectory();\n            } finally {\n              iw.decref();\n            }\n          } else {\n            successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n        \n        if (isFullCopyNeeded) {\n          // we have to do this before commit\n          final Directory freezeIndexDir = indexDir;\n          core.getDirectoryFactory().addCloseListener(oldDirectory, new CloseListener(){\n\n            @Override\n            public void preClose() {\n              LOG.info(\"removing old index files \" + freezeIndexDir);\n              DirectoryFactory.empty(freezeIndexDir);\n            }\n            \n            @Override\n            public void postClose() {\n              LOG.info(\"removing old index directory \" + freezeIndexDir);\n              try {\n                core.getDirectoryFactory().remove(freezeIndexDir);\n              } catch (IOException e) {\n                SolrException.log(LOG, \"Error removing directory \" + freezeIndexDir, e);\n              }\n            }\n            \n          });\n        }\n\n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            core.getDirectoryFactory().doneWithDirectory(oldDirectory);\n          }\n          doCommit(isFullCopyNeeded);\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory files \" + tmpIndexDir);\n          DirectoryFactory.empty(tmpIndexDir);\n        } \n      }\n    } finally {\n      try {\n        if (!successfulInstall) {\n          logReplicationTimeAndConfFiles(null, successfulInstall);\n        }\n        filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n        replicationStartTime = 0;\n        dirFileFetcher = null;\n        localFileFetcher = null;\n        if (fsyncService != null && !fsyncService.isShutdown()) fsyncService\n            .shutdownNow();\n        fsyncService = null;\n        stop = false;\n        fsyncException = null;\n      } finally {\n        if (tmpIndexDir != null) {\n          core.getDirectoryFactory().release(tmpIndexDir);\n        }\n        if (deleteTmpIdxDir && tmpIndexDir != null) {\n          try {\n            core.getDirectoryFactory().remove(tmpIndexDir);\n          } catch (IOException e) {\n            SolrException.log(LOG, \"Error removing directory \" + tmpIndexDir, e);\n          }\n        }\n        if (indexDir != null) {\n          core.getDirectoryFactory().release(indexDir);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["6c94d2661bc1c14426980ec7882e951fdcff08d0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"718607d99d02778db3280e64975663762c94170d","date":1354986964,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(final SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    Directory tmpIndexDir = null;\n    String tmpIndex = null;\n    Directory indexDir = null;\n    boolean deleteTmpIdxDir = true;\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper.getCommitTimestamp(commit) >= latestVersion || forceReplication;\n      \n      String tmpIdxDirName = \"index.\" + new SimpleDateFormat(SnapShooter.DATE_FMT, Locale.ROOT).format(new Date());\n      tmpIndex = createTempindexDir(core, tmpIdxDirName);\n\n      tmpIndexDir = core.getDirectoryFactory().get(tmpIndex, core.getSolrConfig().indexConfig.lockType);\n      \n      // make sure it's the newest known index dir...\n      indexDir = core.getDirectoryFactory().get(core.getNewIndexDir(), core.getSolrConfig().indexConfig.lockType);\n      Directory oldDirectory = null;\n\n      try {\n        \n        if (isIndexStale(indexDir)) {\n          isFullCopyNeeded = true;\n        }\n        LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n        successfulInstall = false;\n        \n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir  =  false;\n          } else {\n            successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir =  false;\n            RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n            try {\n               oldDirectory = iw.get().getDirectory();\n            } finally {\n              iw.decref();\n            }\n          } else {\n            successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n        \n        if (isFullCopyNeeded) {\n          // we have to do this before commit\n          final Directory freezeIndexDir = indexDir;\n          core.getDirectoryFactory().addCloseListener(oldDirectory, new CloseListener(){\n\n            @Override\n            public void preClose() {\n              LOG.info(\"removing old index files \" + freezeIndexDir);\n              DirectoryFactory.empty(freezeIndexDir);\n            }\n            \n            @Override\n            public void postClose() {\n              LOG.info(\"removing old index directory \" + freezeIndexDir);\n              try {\n                core.getDirectoryFactory().remove(freezeIndexDir);\n              } catch (IOException e) {\n                SolrException.log(LOG, \"Error removing directory \" + freezeIndexDir, e);\n              }\n            }\n            \n          });\n        }\n\n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            core.getDirectoryFactory().doneWithDirectory(oldDirectory);\n          }\n          doCommit(isFullCopyNeeded);\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory files \" + tmpIndexDir);\n          if (tmpIndex != null && core.getDirectoryFactory().exists(tmpIndex)) {\n            DirectoryFactory.empty(tmpIndexDir);\n          }\n        } \n      }\n    } finally {\n      try {\n        if (!successfulInstall) {\n          logReplicationTimeAndConfFiles(null, successfulInstall);\n        }\n        filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n        replicationStartTime = 0;\n        dirFileFetcher = null;\n        localFileFetcher = null;\n        if (fsyncService != null && !fsyncService.isShutdown()) fsyncService\n            .shutdownNow();\n        fsyncService = null;\n        stop = false;\n        fsyncException = null;\n      } finally {\n        if (tmpIndexDir != null) {\n          core.getDirectoryFactory().release(tmpIndexDir);\n        }\n        if (deleteTmpIdxDir && tmpIndexDir != null) {\n          try {\n            core.getDirectoryFactory().remove(tmpIndexDir);\n          } catch (IOException e) {\n            SolrException.log(LOG, \"Error removing directory \" + tmpIndexDir, e);\n          }\n        }\n        if (indexDir != null) {\n          core.getDirectoryFactory().release(indexDir);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(final SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    Directory tmpIndexDir = null;\n    String tmpIndex = null;\n    Directory indexDir = null;\n    boolean deleteTmpIdxDir = true;\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper.getCommitTimestamp(commit) >= latestVersion || forceReplication;\n      \n      String tmpIdxDirName = \"index.\" + new SimpleDateFormat(SnapShooter.DATE_FMT, Locale.ROOT).format(new Date());\n      tmpIndex = createTempindexDir(core, tmpIdxDirName);\n\n      tmpIndexDir = core.getDirectoryFactory().get(tmpIndex, null);\n      \n      // make sure it's the newest known index dir...\n      indexDir = core.getDirectoryFactory().get(core.getNewIndexDir(), null);\n      Directory oldDirectory = null;\n\n      try {\n        \n        if (isIndexStale(indexDir)) {\n          isFullCopyNeeded = true;\n        }\n        LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n        successfulInstall = false;\n        \n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir  =  false;\n          } else {\n            successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir =  false;\n            RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n            try {\n               oldDirectory = iw.get().getDirectory();\n            } finally {\n              iw.decref();\n            }\n          } else {\n            successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n        \n        if (isFullCopyNeeded) {\n          // we have to do this before commit\n          final Directory freezeIndexDir = indexDir;\n          core.getDirectoryFactory().addCloseListener(oldDirectory, new CloseListener(){\n\n            @Override\n            public void preClose() {\n              LOG.info(\"removing old index files \" + freezeIndexDir);\n              DirectoryFactory.empty(freezeIndexDir);\n            }\n            \n            @Override\n            public void postClose() {\n              LOG.info(\"removing old index directory \" + freezeIndexDir);\n              try {\n                core.getDirectoryFactory().remove(freezeIndexDir);\n              } catch (IOException e) {\n                SolrException.log(LOG, \"Error removing directory \" + freezeIndexDir, e);\n              }\n            }\n            \n          });\n        }\n\n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            core.getDirectoryFactory().doneWithDirectory(oldDirectory);\n          }\n          doCommit(isFullCopyNeeded);\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory files \" + tmpIndexDir);\n          if (tmpIndex != null && core.getDirectoryFactory().exists(tmpIndex)) {\n            DirectoryFactory.empty(tmpIndexDir);\n          }\n        } \n      }\n    } finally {\n      try {\n        if (!successfulInstall) {\n          logReplicationTimeAndConfFiles(null, successfulInstall);\n        }\n        filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n        replicationStartTime = 0;\n        dirFileFetcher = null;\n        localFileFetcher = null;\n        if (fsyncService != null && !fsyncService.isShutdown()) fsyncService\n            .shutdownNow();\n        fsyncService = null;\n        stop = false;\n        fsyncException = null;\n      } finally {\n        if (tmpIndexDir != null) {\n          core.getDirectoryFactory().release(tmpIndexDir);\n        }\n        if (deleteTmpIdxDir && tmpIndexDir != null) {\n          try {\n            core.getDirectoryFactory().remove(tmpIndexDir);\n          } catch (IOException e) {\n            SolrException.log(LOG, \"Error removing directory \" + tmpIndexDir, e);\n          }\n        }\n        if (indexDir != null) {\n          core.getDirectoryFactory().release(indexDir);\n        }\n      }\n    }\n  }\n\n","bugFix":["d9405f486872f1e416304dfe389741f4ee2f8a4d"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(final SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    Directory tmpIndexDir = null;\n    String tmpIndex = null;\n    Directory indexDir = null;\n    boolean deleteTmpIdxDir = true;\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper.getCommitTimestamp(commit) >= latestVersion || forceReplication;\n      \n      String tmpIdxDirName = \"index.\" + new SimpleDateFormat(SnapShooter.DATE_FMT, Locale.ROOT).format(new Date());\n      tmpIndex = createTempindexDir(core, tmpIdxDirName);\n\n      tmpIndexDir = core.getDirectoryFactory().get(tmpIndex, core.getSolrConfig().indexConfig.lockType);\n      \n      // make sure it's the newest known index dir...\n      indexDir = core.getDirectoryFactory().get(core.getNewIndexDir(), core.getSolrConfig().indexConfig.lockType);\n      Directory oldDirectory = null;\n\n      try {\n        \n        if (isIndexStale(indexDir)) {\n          isFullCopyNeeded = true;\n        }\n        LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n        successfulInstall = false;\n        \n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir  =  false;\n          } else {\n            successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir =  false;\n            RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n            try {\n               oldDirectory = iw.get().getDirectory();\n            } finally {\n              iw.decref();\n            }\n          } else {\n            successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n        \n        if (isFullCopyNeeded) {\n          // we have to do this before commit\n          final Directory freezeIndexDir = indexDir;\n          core.getDirectoryFactory().addCloseListener(oldDirectory, new CloseListener(){\n\n            @Override\n            public void preClose() {\n              LOG.info(\"removing old index files \" + freezeIndexDir);\n              DirectoryFactory.empty(freezeIndexDir);\n            }\n            \n            @Override\n            public void postClose() {\n              LOG.info(\"removing old index directory \" + freezeIndexDir);\n              try {\n                core.getDirectoryFactory().remove(freezeIndexDir);\n              } catch (IOException e) {\n                SolrException.log(LOG, \"Error removing directory \" + freezeIndexDir, e);\n              }\n            }\n            \n          });\n        }\n\n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            core.getDirectoryFactory().doneWithDirectory(oldDirectory);\n          }\n          doCommit(isFullCopyNeeded);\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory files \" + tmpIndexDir);\n          if (tmpIndex != null && core.getDirectoryFactory().exists(tmpIndex)) {\n            DirectoryFactory.empty(tmpIndexDir);\n          }\n        } \n      }\n    } finally {\n      try {\n        if (!successfulInstall) {\n          logReplicationTimeAndConfFiles(null, successfulInstall);\n        }\n        filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n        replicationStartTime = 0;\n        dirFileFetcher = null;\n        localFileFetcher = null;\n        if (fsyncService != null && !fsyncService.isShutdown()) fsyncService\n            .shutdownNow();\n        fsyncService = null;\n        stop = false;\n        fsyncException = null;\n      } finally {\n        if (tmpIndexDir != null) {\n          core.getDirectoryFactory().release(tmpIndexDir);\n        }\n        if (deleteTmpIdxDir && tmpIndexDir != null) {\n          try {\n            core.getDirectoryFactory().remove(tmpIndexDir);\n          } catch (IOException e) {\n            SolrException.log(LOG, \"Error removing directory \" + tmpIndexDir, e);\n          }\n        }\n        if (indexDir != null) {\n          core.getDirectoryFactory().release(indexDir);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(final SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    Directory tmpIndexDir = null;\n    Directory indexDir = null;\n    boolean deleteTmpIdxDir = true;\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper.getCommitTimestamp(commit) >= latestVersion || forceReplication;\n      \n      String tmpIdxDirName = \"index.\" + new SimpleDateFormat(SnapShooter.DATE_FMT, Locale.ROOT).format(new Date());\n      String tmpIndex = createTempindexDir(core, tmpIdxDirName);\n\n      tmpIndexDir = core.getDirectoryFactory().get(tmpIndex, null);\n      \n      // make sure it's the newest known index dir...\n      indexDir = core.getDirectoryFactory().get(core.getNewIndexDir(), null);\n      Directory oldDirectory = null;\n\n      try {\n        \n        if (isIndexStale(indexDir)) {\n          isFullCopyNeeded = true;\n        }\n        LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n        successfulInstall = false;\n        \n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir  =  false;\n          } else {\n            successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir =  false;\n            RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n            try {\n               oldDirectory = iw.get().getDirectory();\n            } finally {\n              iw.decref();\n            }\n          } else {\n            successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n        \n        if (isFullCopyNeeded) {\n          // we have to do this before commit\n          final Directory freezeIndexDir = indexDir;\n          core.getDirectoryFactory().addCloseListener(oldDirectory, new CloseListener(){\n\n            @Override\n            public void preClose() {\n              LOG.info(\"removing old index files \" + freezeIndexDir);\n              DirectoryFactory.empty(freezeIndexDir);\n            }\n            \n            @Override\n            public void postClose() {\n              LOG.info(\"removing old index directory \" + freezeIndexDir);\n              try {\n                core.getDirectoryFactory().remove(freezeIndexDir);\n              } catch (IOException e) {\n                SolrException.log(LOG, \"Error removing directory \" + freezeIndexDir, e);\n              }\n            }\n            \n          });\n        }\n\n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            core.getDirectoryFactory().doneWithDirectory(oldDirectory);\n          }\n          doCommit(isFullCopyNeeded);\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory files \" + tmpIndexDir);\n          DirectoryFactory.empty(tmpIndexDir);\n        } \n      }\n    } finally {\n      try {\n        if (!successfulInstall) {\n          logReplicationTimeAndConfFiles(null, successfulInstall);\n        }\n        filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n        replicationStartTime = 0;\n        dirFileFetcher = null;\n        localFileFetcher = null;\n        if (fsyncService != null && !fsyncService.isShutdown()) fsyncService\n            .shutdownNow();\n        fsyncService = null;\n        stop = false;\n        fsyncException = null;\n      } finally {\n        if (tmpIndexDir != null) {\n          core.getDirectoryFactory().release(tmpIndexDir);\n        }\n        if (deleteTmpIdxDir && tmpIndexDir != null) {\n          try {\n            core.getDirectoryFactory().remove(tmpIndexDir);\n          } catch (IOException e) {\n            SolrException.log(LOG, \"Error removing directory \" + tmpIndexDir, e);\n          }\n        }\n        if (indexDir != null) {\n          core.getDirectoryFactory().release(indexDir);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad3c006a1d6ec52c49f33c62a3678bf5023d9baf","date":1356053655,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(final SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    Directory tmpIndexDir = null;\n    String tmpIndex = null;\n    Directory indexDir = null;\n    String indexDirPath = null;\n    boolean deleteTmpIdxDir = true;\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper.getCommitTimestamp(commit) >= latestVersion || forceReplication;\n      \n      String tmpIdxDirName = \"index.\" + new SimpleDateFormat(SnapShooter.DATE_FMT, Locale.ROOT).format(new Date());\n      tmpIndex = createTempindexDir(core, tmpIdxDirName);\n\n      tmpIndexDir = core.getDirectoryFactory().get(tmpIndex, core.getSolrConfig().indexConfig.lockType);\n      \n      // make sure it's the newest known index dir...\n      indexDirPath = core.getNewIndexDir();\n      indexDir = core.getDirectoryFactory().get(indexDirPath, core.getSolrConfig().indexConfig.lockType);\n      Directory oldDirectory = null;\n\n      try {\n        \n        if (isIndexStale(indexDir)) {\n          isFullCopyNeeded = true;\n        }\n        LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n        successfulInstall = false;\n        \n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir  =  false;\n          } else {\n            successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir =  false;\n            RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n            try {\n               oldDirectory = iw.get().getDirectory();\n            } finally {\n              iw.decref();\n            }\n          } else {\n            successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n        \n        if (isFullCopyNeeded) {\n          // we have to do this before commit\n          final Directory freezeIndexDir = indexDir;\n          final String freezeIndexDirPath = indexDirPath;\n          core.getDirectoryFactory().addCloseListener(oldDirectory, new CloseListener(){\n\n            @Override\n            public void preClose() {\n              LOG.info(\"removing old index files \" + freezeIndexDir);\n              if (core.getDirectoryFactory().exists(freezeIndexDirPath)) {\n                DirectoryFactory.empty(freezeIndexDir);\n              }\n            }\n            \n            @Override\n            public void postClose() {\n              LOG.info(\"removing old index directory \" + freezeIndexDir);\n              try {\n                core.getDirectoryFactory().remove(freezeIndexDir);\n              } catch (IOException e) {\n                SolrException.log(LOG, \"Error removing directory \" + freezeIndexDir, e);\n              }\n            }\n            \n          });\n        }\n\n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            core.getDirectoryFactory().doneWithDirectory(oldDirectory);\n          }\n          doCommit(isFullCopyNeeded);\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory files \" + tmpIndexDir);\n          if (tmpIndex != null && core.getDirectoryFactory().exists(tmpIndex)) {\n            DirectoryFactory.empty(tmpIndexDir);\n          }\n        } \n      }\n    } finally {\n      try {\n        if (!successfulInstall) {\n          logReplicationTimeAndConfFiles(null, successfulInstall);\n        }\n        filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n        replicationStartTime = 0;\n        dirFileFetcher = null;\n        localFileFetcher = null;\n        if (fsyncService != null && !fsyncService.isShutdown()) fsyncService\n            .shutdownNow();\n        fsyncService = null;\n        stop = false;\n        fsyncException = null;\n      } finally {\n        if (tmpIndexDir != null) {\n          core.getDirectoryFactory().release(tmpIndexDir);\n        }\n        if (deleteTmpIdxDir && tmpIndexDir != null) {\n          try {\n            core.getDirectoryFactory().remove(tmpIndexDir);\n          } catch (IOException e) {\n            SolrException.log(LOG, \"Error removing directory \" + tmpIndexDir, e);\n          }\n        }\n        if (indexDir != null) {\n          core.getDirectoryFactory().release(indexDir);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(final SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    Directory tmpIndexDir = null;\n    String tmpIndex = null;\n    Directory indexDir = null;\n    boolean deleteTmpIdxDir = true;\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper.getCommitTimestamp(commit) >= latestVersion || forceReplication;\n      \n      String tmpIdxDirName = \"index.\" + new SimpleDateFormat(SnapShooter.DATE_FMT, Locale.ROOT).format(new Date());\n      tmpIndex = createTempindexDir(core, tmpIdxDirName);\n\n      tmpIndexDir = core.getDirectoryFactory().get(tmpIndex, core.getSolrConfig().indexConfig.lockType);\n      \n      // make sure it's the newest known index dir...\n      indexDir = core.getDirectoryFactory().get(core.getNewIndexDir(), core.getSolrConfig().indexConfig.lockType);\n      Directory oldDirectory = null;\n\n      try {\n        \n        if (isIndexStale(indexDir)) {\n          isFullCopyNeeded = true;\n        }\n        LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n        successfulInstall = false;\n        \n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir  =  false;\n          } else {\n            successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir =  false;\n            RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n            try {\n               oldDirectory = iw.get().getDirectory();\n            } finally {\n              iw.decref();\n            }\n          } else {\n            successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n        \n        if (isFullCopyNeeded) {\n          // we have to do this before commit\n          final Directory freezeIndexDir = indexDir;\n          core.getDirectoryFactory().addCloseListener(oldDirectory, new CloseListener(){\n\n            @Override\n            public void preClose() {\n              LOG.info(\"removing old index files \" + freezeIndexDir);\n              DirectoryFactory.empty(freezeIndexDir);\n            }\n            \n            @Override\n            public void postClose() {\n              LOG.info(\"removing old index directory \" + freezeIndexDir);\n              try {\n                core.getDirectoryFactory().remove(freezeIndexDir);\n              } catch (IOException e) {\n                SolrException.log(LOG, \"Error removing directory \" + freezeIndexDir, e);\n              }\n            }\n            \n          });\n        }\n\n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            core.getDirectoryFactory().doneWithDirectory(oldDirectory);\n          }\n          doCommit(isFullCopyNeeded);\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory files \" + tmpIndexDir);\n          if (tmpIndex != null && core.getDirectoryFactory().exists(tmpIndex)) {\n            DirectoryFactory.empty(tmpIndexDir);\n          }\n        } \n      }\n    } finally {\n      try {\n        if (!successfulInstall) {\n          logReplicationTimeAndConfFiles(null, successfulInstall);\n        }\n        filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n        replicationStartTime = 0;\n        dirFileFetcher = null;\n        localFileFetcher = null;\n        if (fsyncService != null && !fsyncService.isShutdown()) fsyncService\n            .shutdownNow();\n        fsyncService = null;\n        stop = false;\n        fsyncException = null;\n      } finally {\n        if (tmpIndexDir != null) {\n          core.getDirectoryFactory().release(tmpIndexDir);\n        }\n        if (deleteTmpIdxDir && tmpIndexDir != null) {\n          try {\n            core.getDirectoryFactory().remove(tmpIndexDir);\n          } catch (IOException e) {\n            SolrException.log(LOG, \"Error removing directory \" + tmpIndexDir, e);\n          }\n        }\n        if (indexDir != null) {\n          core.getDirectoryFactory().release(indexDir);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["6c94d2661bc1c14426980ec7882e951fdcff08d0","058801f8673d53a5abac8088204860ec29a40f0d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(final SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    Directory tmpIndexDir = null;\n    String tmpIndex = null;\n    Directory indexDir = null;\n    String indexDirPath = null;\n    boolean deleteTmpIdxDir = true;\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper.getCommitTimestamp(commit) >= latestVersion || forceReplication;\n      \n      String tmpIdxDirName = \"index.\" + new SimpleDateFormat(SnapShooter.DATE_FMT, Locale.ROOT).format(new Date());\n      tmpIndex = createTempindexDir(core, tmpIdxDirName);\n\n      tmpIndexDir = core.getDirectoryFactory().get(tmpIndex, core.getSolrConfig().indexConfig.lockType);\n      \n      // make sure it's the newest known index dir...\n      indexDirPath = core.getNewIndexDir();\n      indexDir = core.getDirectoryFactory().get(indexDirPath, core.getSolrConfig().indexConfig.lockType);\n      Directory oldDirectory = null;\n\n      try {\n        \n        if (isIndexStale(indexDir)) {\n          isFullCopyNeeded = true;\n        }\n        LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n        successfulInstall = false;\n        \n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir  =  false;\n          } else {\n            successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir =  false;\n            RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n            try {\n               oldDirectory = iw.get().getDirectory();\n            } finally {\n              iw.decref();\n            }\n          } else {\n            successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n        \n        if (isFullCopyNeeded) {\n          // we have to do this before commit\n          final Directory freezeIndexDir = indexDir;\n          final String freezeIndexDirPath = indexDirPath;\n          core.getDirectoryFactory().addCloseListener(oldDirectory, new CloseListener(){\n\n            @Override\n            public void preClose() {\n              LOG.info(\"removing old index files \" + freezeIndexDir);\n              if (core.getDirectoryFactory().exists(freezeIndexDirPath)) {\n                DirectoryFactory.empty(freezeIndexDir);\n              }\n            }\n            \n            @Override\n            public void postClose() {\n              LOG.info(\"removing old index directory \" + freezeIndexDir);\n              try {\n                core.getDirectoryFactory().remove(freezeIndexDir);\n              } catch (IOException e) {\n                SolrException.log(LOG, \"Error removing directory \" + freezeIndexDir, e);\n              }\n            }\n            \n          });\n        }\n\n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            core.getDirectoryFactory().doneWithDirectory(oldDirectory);\n          }\n          doCommit(isFullCopyNeeded);\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory files \" + tmpIndexDir);\n          if (tmpIndex != null && core.getDirectoryFactory().exists(tmpIndex)) {\n            DirectoryFactory.empty(tmpIndexDir);\n          }\n        } \n      }\n    } finally {\n      try {\n        if (!successfulInstall) {\n          logReplicationTimeAndConfFiles(null, successfulInstall);\n        }\n        filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n        replicationStartTime = 0;\n        dirFileFetcher = null;\n        localFileFetcher = null;\n        if (fsyncService != null && !fsyncService.isShutdown()) fsyncService\n            .shutdownNow();\n        fsyncService = null;\n        stop = false;\n        fsyncException = null;\n      } finally {\n        if (tmpIndexDir != null) {\n          core.getDirectoryFactory().release(tmpIndexDir);\n        }\n        if (deleteTmpIdxDir && tmpIndexDir != null) {\n          try {\n            core.getDirectoryFactory().remove(tmpIndexDir);\n          } catch (IOException e) {\n            SolrException.log(LOG, \"Error removing directory \" + tmpIndexDir, e);\n          }\n        }\n        if (indexDir != null) {\n          core.getDirectoryFactory().release(indexDir);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(final SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    Directory tmpIndexDir = null;\n    String tmpIndex = null;\n    Directory indexDir = null;\n    boolean deleteTmpIdxDir = true;\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper.getCommitTimestamp(commit) >= latestVersion || forceReplication;\n      \n      String tmpIdxDirName = \"index.\" + new SimpleDateFormat(SnapShooter.DATE_FMT, Locale.ROOT).format(new Date());\n      tmpIndex = createTempindexDir(core, tmpIdxDirName);\n\n      tmpIndexDir = core.getDirectoryFactory().get(tmpIndex, core.getSolrConfig().indexConfig.lockType);\n      \n      // make sure it's the newest known index dir...\n      indexDir = core.getDirectoryFactory().get(core.getNewIndexDir(), core.getSolrConfig().indexConfig.lockType);\n      Directory oldDirectory = null;\n\n      try {\n        \n        if (isIndexStale(indexDir)) {\n          isFullCopyNeeded = true;\n        }\n        LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n        successfulInstall = false;\n        \n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir  =  false;\n          } else {\n            successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir =  false;\n            RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n            try {\n               oldDirectory = iw.get().getDirectory();\n            } finally {\n              iw.decref();\n            }\n          } else {\n            successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n        \n        if (isFullCopyNeeded) {\n          // we have to do this before commit\n          final Directory freezeIndexDir = indexDir;\n          core.getDirectoryFactory().addCloseListener(oldDirectory, new CloseListener(){\n\n            @Override\n            public void preClose() {\n              LOG.info(\"removing old index files \" + freezeIndexDir);\n              DirectoryFactory.empty(freezeIndexDir);\n            }\n            \n            @Override\n            public void postClose() {\n              LOG.info(\"removing old index directory \" + freezeIndexDir);\n              try {\n                core.getDirectoryFactory().remove(freezeIndexDir);\n              } catch (IOException e) {\n                SolrException.log(LOG, \"Error removing directory \" + freezeIndexDir, e);\n              }\n            }\n            \n          });\n        }\n\n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            core.getDirectoryFactory().doneWithDirectory(oldDirectory);\n          }\n          doCommit(isFullCopyNeeded);\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory files \" + tmpIndexDir);\n          if (tmpIndex != null && core.getDirectoryFactory().exists(tmpIndex)) {\n            DirectoryFactory.empty(tmpIndexDir);\n          }\n        } \n      }\n    } finally {\n      try {\n        if (!successfulInstall) {\n          logReplicationTimeAndConfFiles(null, successfulInstall);\n        }\n        filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n        replicationStartTime = 0;\n        dirFileFetcher = null;\n        localFileFetcher = null;\n        if (fsyncService != null && !fsyncService.isShutdown()) fsyncService\n            .shutdownNow();\n        fsyncService = null;\n        stop = false;\n        fsyncException = null;\n      } finally {\n        if (tmpIndexDir != null) {\n          core.getDirectoryFactory().release(tmpIndexDir);\n        }\n        if (deleteTmpIdxDir && tmpIndexDir != null) {\n          try {\n            core.getDirectoryFactory().remove(tmpIndexDir);\n          } catch (IOException e) {\n            SolrException.log(LOG, \"Error removing directory \" + tmpIndexDir, e);\n          }\n        }\n        if (indexDir != null) {\n          core.getDirectoryFactory().release(indexDir);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1eda2abfda9da3ca2bc5c5872d6b8c0f4948f674","date":1358098706,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(final SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    Directory tmpIndexDir = null;\n    String tmpIndex = null;\n    Directory indexDir = null;\n    String indexDirPath = null;\n    boolean deleteTmpIdxDir = true;\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper.getCommitTimestamp(commit) >= latestVersion || forceReplication;\n      \n      String tmpIdxDirName = \"index.\" + new SimpleDateFormat(SnapShooter.DATE_FMT, Locale.ROOT).format(new Date());\n      tmpIndex = createTempindexDir(core, tmpIdxDirName);\n\n      tmpIndexDir = core.getDirectoryFactory().get(tmpIndex, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n      \n      // make sure it's the newest known index dir...\n      indexDirPath = core.getNewIndexDir();\n      indexDir = core.getDirectoryFactory().get(indexDirPath, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n      Directory oldDirectory = null;\n\n      try {\n        \n        if (isIndexStale(indexDir)) {\n          isFullCopyNeeded = true;\n        }\n        LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n        successfulInstall = false;\n        \n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir  =  false;\n          } else {\n            successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir =  false;\n            RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n            try {\n               oldDirectory = iw.get().getDirectory();\n            } finally {\n              iw.decref();\n            }\n          } else {\n            successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n        \n        if (isFullCopyNeeded) {\n          // we have to do this before commit\n          final Directory freezeIndexDir = indexDir;\n          final String freezeIndexDirPath = indexDirPath;\n          core.getDirectoryFactory().addCloseListener(oldDirectory, new CloseListener(){\n\n            @Override\n            public void preClose() {\n              LOG.info(\"removing old index files \" + freezeIndexDir);\n              if (core.getDirectoryFactory().exists(freezeIndexDirPath)) {\n                DirectoryFactory.empty(freezeIndexDir);\n              }\n            }\n            \n            @Override\n            public void postClose() {\n              LOG.info(\"removing old index directory \" + freezeIndexDir);\n              try {\n                core.getDirectoryFactory().remove(freezeIndexDir);\n              } catch (IOException e) {\n                SolrException.log(LOG, \"Error removing directory \" + freezeIndexDir, e);\n              }\n            }\n            \n          });\n        }\n\n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            core.getDirectoryFactory().doneWithDirectory(oldDirectory);\n          }\n          doCommit(isFullCopyNeeded);\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory files \" + tmpIndexDir);\n          if (tmpIndex != null && core.getDirectoryFactory().exists(tmpIndex)) {\n            DirectoryFactory.empty(tmpIndexDir);\n          }\n        } \n      }\n    } finally {\n      try {\n        if (!successfulInstall) {\n          logReplicationTimeAndConfFiles(null, successfulInstall);\n        }\n        filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n        replicationStartTime = 0;\n        dirFileFetcher = null;\n        localFileFetcher = null;\n        if (fsyncService != null && !fsyncService.isShutdown()) fsyncService\n            .shutdownNow();\n        fsyncService = null;\n        stop = false;\n        fsyncException = null;\n      } finally {\n        if (tmpIndexDir != null) {\n          core.getDirectoryFactory().release(tmpIndexDir);\n        }\n        if (deleteTmpIdxDir && tmpIndexDir != null) {\n          try {\n            core.getDirectoryFactory().remove(tmpIndexDir);\n          } catch (IOException e) {\n            SolrException.log(LOG, \"Error removing directory \" + tmpIndexDir, e);\n          }\n        }\n        if (indexDir != null) {\n          core.getDirectoryFactory().release(indexDir);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(final SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    Directory tmpIndexDir = null;\n    String tmpIndex = null;\n    Directory indexDir = null;\n    String indexDirPath = null;\n    boolean deleteTmpIdxDir = true;\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper.getCommitTimestamp(commit) >= latestVersion || forceReplication;\n      \n      String tmpIdxDirName = \"index.\" + new SimpleDateFormat(SnapShooter.DATE_FMT, Locale.ROOT).format(new Date());\n      tmpIndex = createTempindexDir(core, tmpIdxDirName);\n\n      tmpIndexDir = core.getDirectoryFactory().get(tmpIndex, core.getSolrConfig().indexConfig.lockType);\n      \n      // make sure it's the newest known index dir...\n      indexDirPath = core.getNewIndexDir();\n      indexDir = core.getDirectoryFactory().get(indexDirPath, core.getSolrConfig().indexConfig.lockType);\n      Directory oldDirectory = null;\n\n      try {\n        \n        if (isIndexStale(indexDir)) {\n          isFullCopyNeeded = true;\n        }\n        LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n        successfulInstall = false;\n        \n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir  =  false;\n          } else {\n            successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir =  false;\n            RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n            try {\n               oldDirectory = iw.get().getDirectory();\n            } finally {\n              iw.decref();\n            }\n          } else {\n            successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n        \n        if (isFullCopyNeeded) {\n          // we have to do this before commit\n          final Directory freezeIndexDir = indexDir;\n          final String freezeIndexDirPath = indexDirPath;\n          core.getDirectoryFactory().addCloseListener(oldDirectory, new CloseListener(){\n\n            @Override\n            public void preClose() {\n              LOG.info(\"removing old index files \" + freezeIndexDir);\n              if (core.getDirectoryFactory().exists(freezeIndexDirPath)) {\n                DirectoryFactory.empty(freezeIndexDir);\n              }\n            }\n            \n            @Override\n            public void postClose() {\n              LOG.info(\"removing old index directory \" + freezeIndexDir);\n              try {\n                core.getDirectoryFactory().remove(freezeIndexDir);\n              } catch (IOException e) {\n                SolrException.log(LOG, \"Error removing directory \" + freezeIndexDir, e);\n              }\n            }\n            \n          });\n        }\n\n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            core.getDirectoryFactory().doneWithDirectory(oldDirectory);\n          }\n          doCommit(isFullCopyNeeded);\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory files \" + tmpIndexDir);\n          if (tmpIndex != null && core.getDirectoryFactory().exists(tmpIndex)) {\n            DirectoryFactory.empty(tmpIndexDir);\n          }\n        } \n      }\n    } finally {\n      try {\n        if (!successfulInstall) {\n          logReplicationTimeAndConfFiles(null, successfulInstall);\n        }\n        filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n        replicationStartTime = 0;\n        dirFileFetcher = null;\n        localFileFetcher = null;\n        if (fsyncService != null && !fsyncService.isShutdown()) fsyncService\n            .shutdownNow();\n        fsyncService = null;\n        stop = false;\n        fsyncException = null;\n      } finally {\n        if (tmpIndexDir != null) {\n          core.getDirectoryFactory().release(tmpIndexDir);\n        }\n        if (deleteTmpIdxDir && tmpIndexDir != null) {\n          try {\n            core.getDirectoryFactory().remove(tmpIndexDir);\n          } catch (IOException e) {\n            SolrException.log(LOG, \"Error removing directory \" + tmpIndexDir, e);\n          }\n        }\n        if (indexDir != null) {\n          core.getDirectoryFactory().release(indexDir);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["6c94d2661bc1c14426980ec7882e951fdcff08d0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"be4d0855f94432c9a580ae7750c6f842d604a3e4","date":1358183330,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(final SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    Directory tmpIndexDir = null;\n    String tmpIndex = null;\n    Directory indexDir = null;\n    String indexDirPath = null;\n    boolean deleteTmpIdxDir = true;\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper\n          .getCommitTimestamp(commit) >= latestVersion\n          || commit.getGeneration() >= latestGeneration || forceReplication;\n\n      String tmpIdxDirName = \"index.\" + new SimpleDateFormat(SnapShooter.DATE_FMT, Locale.ROOT).format(new Date());\n      tmpIndex = createTempindexDir(core, tmpIdxDirName);\n\n      tmpIndexDir = core.getDirectoryFactory().get(tmpIndex, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n      \n      // make sure it's the newest known index dir...\n      indexDirPath = core.getNewIndexDir();\n      indexDir = core.getDirectoryFactory().get(indexDirPath, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n      Directory oldDirectory = null;\n\n      try {\n        \n        if (isIndexStale(indexDir)) {\n          isFullCopyNeeded = true;\n        }\n        LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n        successfulInstall = false;\n        \n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir  =  false;\n          } else {\n            successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir =  false;\n            RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n            try {\n               oldDirectory = iw.get().getDirectory();\n            } finally {\n              iw.decref();\n            }\n          } else {\n            successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n        \n        if (isFullCopyNeeded) {\n          // we have to do this before commit\n          final Directory freezeIndexDir = indexDir;\n          final String freezeIndexDirPath = indexDirPath;\n          core.getDirectoryFactory().addCloseListener(oldDirectory, new CloseListener(){\n\n            @Override\n            public void preClose() {\n              LOG.info(\"removing old index files \" + freezeIndexDir);\n              if (core.getDirectoryFactory().exists(freezeIndexDirPath)) {\n                DirectoryFactory.empty(freezeIndexDir);\n              }\n            }\n            \n            @Override\n            public void postClose() {\n              LOG.info(\"removing old index directory \" + freezeIndexDir);\n              try {\n                core.getDirectoryFactory().remove(freezeIndexDir);\n              } catch (IOException e) {\n                SolrException.log(LOG, \"Error removing directory \" + freezeIndexDir, e);\n              }\n            }\n            \n          });\n        }\n\n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            core.getDirectoryFactory().doneWithDirectory(oldDirectory);\n          }\n          doCommit(isFullCopyNeeded);\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory files \" + tmpIndexDir);\n          if (tmpIndex != null && core.getDirectoryFactory().exists(tmpIndex)) {\n            DirectoryFactory.empty(tmpIndexDir);\n          }\n        } \n      }\n    } finally {\n      try {\n        if (!successfulInstall) {\n          logReplicationTimeAndConfFiles(null, successfulInstall);\n        }\n        filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n        replicationStartTime = 0;\n        dirFileFetcher = null;\n        localFileFetcher = null;\n        if (fsyncService != null && !fsyncService.isShutdown()) fsyncService\n            .shutdownNow();\n        fsyncService = null;\n        stop = false;\n        fsyncException = null;\n      } finally {\n        if (tmpIndexDir != null) {\n          core.getDirectoryFactory().release(tmpIndexDir);\n        }\n        if (deleteTmpIdxDir && tmpIndexDir != null) {\n          try {\n            core.getDirectoryFactory().remove(tmpIndexDir);\n          } catch (IOException e) {\n            SolrException.log(LOG, \"Error removing directory \" + tmpIndexDir, e);\n          }\n        }\n        if (indexDir != null) {\n          core.getDirectoryFactory().release(indexDir);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(final SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    Directory tmpIndexDir = null;\n    String tmpIndex = null;\n    Directory indexDir = null;\n    String indexDirPath = null;\n    boolean deleteTmpIdxDir = true;\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper.getCommitTimestamp(commit) >= latestVersion || forceReplication;\n      \n      String tmpIdxDirName = \"index.\" + new SimpleDateFormat(SnapShooter.DATE_FMT, Locale.ROOT).format(new Date());\n      tmpIndex = createTempindexDir(core, tmpIdxDirName);\n\n      tmpIndexDir = core.getDirectoryFactory().get(tmpIndex, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n      \n      // make sure it's the newest known index dir...\n      indexDirPath = core.getNewIndexDir();\n      indexDir = core.getDirectoryFactory().get(indexDirPath, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n      Directory oldDirectory = null;\n\n      try {\n        \n        if (isIndexStale(indexDir)) {\n          isFullCopyNeeded = true;\n        }\n        LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n        successfulInstall = false;\n        \n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir  =  false;\n          } else {\n            successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir =  false;\n            RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n            try {\n               oldDirectory = iw.get().getDirectory();\n            } finally {\n              iw.decref();\n            }\n          } else {\n            successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n        \n        if (isFullCopyNeeded) {\n          // we have to do this before commit\n          final Directory freezeIndexDir = indexDir;\n          final String freezeIndexDirPath = indexDirPath;\n          core.getDirectoryFactory().addCloseListener(oldDirectory, new CloseListener(){\n\n            @Override\n            public void preClose() {\n              LOG.info(\"removing old index files \" + freezeIndexDir);\n              if (core.getDirectoryFactory().exists(freezeIndexDirPath)) {\n                DirectoryFactory.empty(freezeIndexDir);\n              }\n            }\n            \n            @Override\n            public void postClose() {\n              LOG.info(\"removing old index directory \" + freezeIndexDir);\n              try {\n                core.getDirectoryFactory().remove(freezeIndexDir);\n              } catch (IOException e) {\n                SolrException.log(LOG, \"Error removing directory \" + freezeIndexDir, e);\n              }\n            }\n            \n          });\n        }\n\n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            core.getDirectoryFactory().doneWithDirectory(oldDirectory);\n          }\n          doCommit(isFullCopyNeeded);\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory files \" + tmpIndexDir);\n          if (tmpIndex != null && core.getDirectoryFactory().exists(tmpIndex)) {\n            DirectoryFactory.empty(tmpIndexDir);\n          }\n        } \n      }\n    } finally {\n      try {\n        if (!successfulInstall) {\n          logReplicationTimeAndConfFiles(null, successfulInstall);\n        }\n        filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n        replicationStartTime = 0;\n        dirFileFetcher = null;\n        localFileFetcher = null;\n        if (fsyncService != null && !fsyncService.isShutdown()) fsyncService\n            .shutdownNow();\n        fsyncService = null;\n        stop = false;\n        fsyncException = null;\n      } finally {\n        if (tmpIndexDir != null) {\n          core.getDirectoryFactory().release(tmpIndexDir);\n        }\n        if (deleteTmpIdxDir && tmpIndexDir != null) {\n          try {\n            core.getDirectoryFactory().remove(tmpIndexDir);\n          } catch (IOException e) {\n            SolrException.log(LOG, \"Error removing directory \" + tmpIndexDir, e);\n          }\n        }\n        if (indexDir != null) {\n          core.getDirectoryFactory().release(indexDir);\n        }\n      }\n    }\n  }\n\n","bugFix":["66c64e8cfded6a585100e6430238faaf416f3fea","d9405f486872f1e416304dfe389741f4ee2f8a4d"],"bugIntro":["6c94d2661bc1c14426980ec7882e951fdcff08d0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8917bfede3b4ca30f4305c1e391e9218959cd723","date":1358189662,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(final SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    Directory tmpIndexDir = null;\n    String tmpIndex = null;\n    Directory indexDir = null;\n    String indexDirPath = null;\n    boolean deleteTmpIdxDir = true;\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper\n          .getCommitTimestamp(commit) >= latestVersion\n          || commit.getGeneration() >= latestGeneration || forceReplication;\n\n      String tmpIdxDirName = \"index.\" + new SimpleDateFormat(SnapShooter.DATE_FMT, Locale.ROOT).format(new Date());\n      tmpIndex = createTempindexDir(core, tmpIdxDirName);\n\n      tmpIndexDir = core.getDirectoryFactory().get(tmpIndex, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n      \n      // make sure it's the newest known index dir...\n      indexDirPath = core.getNewIndexDir();\n      indexDir = core.getDirectoryFactory().get(indexDirPath, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n      Directory oldDirectory = null;\n\n      try {\n        \n        if (isIndexStale(indexDir)) {\n          isFullCopyNeeded = true;\n        }\n        LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n        successfulInstall = false;\n        \n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir  =  false;\n          } else {\n            successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir =  false;\n            RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n            try {\n               oldDirectory = iw.get().getDirectory();\n            } finally {\n              iw.decref();\n            }\n          } else {\n            successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n        \n        if (isFullCopyNeeded) {\n          // we have to do this before commit\n          final Directory freezeIndexDir = indexDir;\n          final String freezeIndexDirPath = indexDirPath;\n          core.getDirectoryFactory().addCloseListener(oldDirectory, new CloseListener(){\n\n            @Override\n            public void preClose() {\n              LOG.info(\"removing old index files \" + freezeIndexDir);\n              if (core.getDirectoryFactory().exists(freezeIndexDirPath)) {\n                DirectoryFactory.empty(freezeIndexDir);\n              }\n            }\n            \n            @Override\n            public void postClose() {\n              LOG.info(\"removing old index directory \" + freezeIndexDir);\n              try {\n                core.getDirectoryFactory().remove(freezeIndexDir);\n              } catch (IOException e) {\n                SolrException.log(LOG, \"Error removing directory \" + freezeIndexDir, e);\n              }\n            }\n            \n          });\n        }\n\n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            core.getDirectoryFactory().doneWithDirectory(oldDirectory);\n          }\n          doCommit(isFullCopyNeeded);\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory files \" + tmpIndexDir);\n          if (tmpIndex != null && core.getDirectoryFactory().exists(tmpIndex)) {\n            DirectoryFactory.empty(tmpIndexDir);\n          }\n        } \n      }\n    } finally {\n      try {\n        if (!successfulInstall) {\n          logReplicationTimeAndConfFiles(null, successfulInstall);\n        }\n        filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n        replicationStartTime = 0;\n        dirFileFetcher = null;\n        localFileFetcher = null;\n        if (fsyncService != null && !fsyncService.isShutdown()) fsyncService\n            .shutdownNow();\n        fsyncService = null;\n        stop = false;\n        fsyncException = null;\n      } finally {\n        if (tmpIndexDir != null) {\n          core.getDirectoryFactory().release(tmpIndexDir);\n        }\n        if (deleteTmpIdxDir && tmpIndexDir != null) {\n          try {\n            core.getDirectoryFactory().remove(tmpIndexDir);\n          } catch (IOException e) {\n            SolrException.log(LOG, \"Error removing directory \" + tmpIndexDir, e);\n          }\n        }\n        if (indexDir != null) {\n          core.getDirectoryFactory().release(indexDir);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(final SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    Directory tmpIndexDir = null;\n    String tmpIndex = null;\n    Directory indexDir = null;\n    String indexDirPath = null;\n    boolean deleteTmpIdxDir = true;\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper.getCommitTimestamp(commit) >= latestVersion || forceReplication;\n      \n      String tmpIdxDirName = \"index.\" + new SimpleDateFormat(SnapShooter.DATE_FMT, Locale.ROOT).format(new Date());\n      tmpIndex = createTempindexDir(core, tmpIdxDirName);\n\n      tmpIndexDir = core.getDirectoryFactory().get(tmpIndex, core.getSolrConfig().indexConfig.lockType);\n      \n      // make sure it's the newest known index dir...\n      indexDirPath = core.getNewIndexDir();\n      indexDir = core.getDirectoryFactory().get(indexDirPath, core.getSolrConfig().indexConfig.lockType);\n      Directory oldDirectory = null;\n\n      try {\n        \n        if (isIndexStale(indexDir)) {\n          isFullCopyNeeded = true;\n        }\n        LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n        successfulInstall = false;\n        \n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir  =  false;\n          } else {\n            successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir =  false;\n            RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n            try {\n               oldDirectory = iw.get().getDirectory();\n            } finally {\n              iw.decref();\n            }\n          } else {\n            successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n        \n        if (isFullCopyNeeded) {\n          // we have to do this before commit\n          final Directory freezeIndexDir = indexDir;\n          final String freezeIndexDirPath = indexDirPath;\n          core.getDirectoryFactory().addCloseListener(oldDirectory, new CloseListener(){\n\n            @Override\n            public void preClose() {\n              LOG.info(\"removing old index files \" + freezeIndexDir);\n              if (core.getDirectoryFactory().exists(freezeIndexDirPath)) {\n                DirectoryFactory.empty(freezeIndexDir);\n              }\n            }\n            \n            @Override\n            public void postClose() {\n              LOG.info(\"removing old index directory \" + freezeIndexDir);\n              try {\n                core.getDirectoryFactory().remove(freezeIndexDir);\n              } catch (IOException e) {\n                SolrException.log(LOG, \"Error removing directory \" + freezeIndexDir, e);\n              }\n            }\n            \n          });\n        }\n\n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            core.getDirectoryFactory().doneWithDirectory(oldDirectory);\n          }\n          doCommit(isFullCopyNeeded);\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory files \" + tmpIndexDir);\n          if (tmpIndex != null && core.getDirectoryFactory().exists(tmpIndex)) {\n            DirectoryFactory.empty(tmpIndexDir);\n          }\n        } \n      }\n    } finally {\n      try {\n        if (!successfulInstall) {\n          logReplicationTimeAndConfFiles(null, successfulInstall);\n        }\n        filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n        replicationStartTime = 0;\n        dirFileFetcher = null;\n        localFileFetcher = null;\n        if (fsyncService != null && !fsyncService.isShutdown()) fsyncService\n            .shutdownNow();\n        fsyncService = null;\n        stop = false;\n        fsyncException = null;\n      } finally {\n        if (tmpIndexDir != null) {\n          core.getDirectoryFactory().release(tmpIndexDir);\n        }\n        if (deleteTmpIdxDir && tmpIndexDir != null) {\n          try {\n            core.getDirectoryFactory().remove(tmpIndexDir);\n          } catch (IOException e) {\n            SolrException.log(LOG, \"Error removing directory \" + tmpIndexDir, e);\n          }\n        }\n        if (indexDir != null) {\n          core.getDirectoryFactory().release(indexDir);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bd8bc29700397ec1886e73bae0a67ff536bad223","date":1362159450,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(final SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    Directory tmpIndexDir = null;\n    String tmpIndex = null;\n    Directory indexDir = null;\n    String indexDirPath = null;\n    boolean deleteTmpIdxDir = true;\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper\n          .getCommitTimestamp(commit) >= latestVersion\n          || commit.getGeneration() >= latestGeneration || forceReplication;\n\n      String tmpIdxDirName = \"index.\" + new SimpleDateFormat(SnapShooter.DATE_FMT, Locale.ROOT).format(new Date());\n      tmpIndex = createTempindexDir(core, tmpIdxDirName);\n\n      tmpIndexDir = core.getDirectoryFactory().get(tmpIndex, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n      \n      // make sure it's the newest known index dir...\n      indexDirPath = core.getNewIndexDir();\n      indexDir = core.getDirectoryFactory().get(indexDirPath, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n      Directory oldDirectory = null;\n\n      try {\n        \n        if (isIndexStale(indexDir)) {\n          isFullCopyNeeded = true;\n        }\n        LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n        successfulInstall = false;\n        \n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir  =  false;\n          } else {\n            successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir =  false;\n            RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n            try {\n               oldDirectory = iw.get().getDirectory();\n            } finally {\n              iw.decref();\n            }\n          } else {\n            successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n        \n        if (isFullCopyNeeded) {\n          // we have to do this before commit\n          final Directory freezeIndexDir = indexDir;\n          final String freezeIndexDirPath = indexDirPath;\n          core.getDirectoryFactory().addCloseListener(oldDirectory, new CloseListener(){\n\n            @Override\n            public void preClose() {\n              LOG.info(\"removing old index files \" + freezeIndexDir);\n              if (core.getDirectoryFactory().exists(freezeIndexDirPath)) {\n                DirectoryFactory.empty(freezeIndexDir);\n              }\n            }\n            \n            @Override\n            public void postClose() {\n              LOG.info(\"removing old index directory \" + freezeIndexDir);\n              try {\n                core.getDirectoryFactory().remove(freezeIndexDir);\n              } catch (IOException e) {\n                SolrException.log(LOG, \"Error removing directory \" + freezeIndexDir, e);\n              }\n            }\n            \n          });\n        }\n\n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            core.getDirectoryFactory().doneWithDirectory(oldDirectory);\n          }\n          openNewWriterAndSearcher(isFullCopyNeeded);\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory files \" + tmpIndexDir);\n          if (tmpIndex != null && core.getDirectoryFactory().exists(tmpIndex)) {\n            DirectoryFactory.empty(tmpIndexDir);\n          }\n        } \n      }\n    } finally {\n      try {\n        if (!successfulInstall) {\n          logReplicationTimeAndConfFiles(null, successfulInstall);\n        }\n        filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n        replicationStartTime = 0;\n        dirFileFetcher = null;\n        localFileFetcher = null;\n        if (fsyncService != null && !fsyncService.isShutdown()) fsyncService\n            .shutdownNow();\n        fsyncService = null;\n        stop = false;\n        fsyncException = null;\n      } finally {\n        if (tmpIndexDir != null) {\n          core.getDirectoryFactory().release(tmpIndexDir);\n        }\n        if (deleteTmpIdxDir && tmpIndexDir != null) {\n          try {\n            core.getDirectoryFactory().remove(tmpIndexDir);\n          } catch (IOException e) {\n            SolrException.log(LOG, \"Error removing directory \" + tmpIndexDir, e);\n          }\n        }\n        if (indexDir != null) {\n          core.getDirectoryFactory().release(indexDir);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(final SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    Directory tmpIndexDir = null;\n    String tmpIndex = null;\n    Directory indexDir = null;\n    String indexDirPath = null;\n    boolean deleteTmpIdxDir = true;\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper\n          .getCommitTimestamp(commit) >= latestVersion\n          || commit.getGeneration() >= latestGeneration || forceReplication;\n\n      String tmpIdxDirName = \"index.\" + new SimpleDateFormat(SnapShooter.DATE_FMT, Locale.ROOT).format(new Date());\n      tmpIndex = createTempindexDir(core, tmpIdxDirName);\n\n      tmpIndexDir = core.getDirectoryFactory().get(tmpIndex, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n      \n      // make sure it's the newest known index dir...\n      indexDirPath = core.getNewIndexDir();\n      indexDir = core.getDirectoryFactory().get(indexDirPath, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n      Directory oldDirectory = null;\n\n      try {\n        \n        if (isIndexStale(indexDir)) {\n          isFullCopyNeeded = true;\n        }\n        LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n        successfulInstall = false;\n        \n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir  =  false;\n          } else {\n            successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir =  false;\n            RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n            try {\n               oldDirectory = iw.get().getDirectory();\n            } finally {\n              iw.decref();\n            }\n          } else {\n            successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n        \n        if (isFullCopyNeeded) {\n          // we have to do this before commit\n          final Directory freezeIndexDir = indexDir;\n          final String freezeIndexDirPath = indexDirPath;\n          core.getDirectoryFactory().addCloseListener(oldDirectory, new CloseListener(){\n\n            @Override\n            public void preClose() {\n              LOG.info(\"removing old index files \" + freezeIndexDir);\n              if (core.getDirectoryFactory().exists(freezeIndexDirPath)) {\n                DirectoryFactory.empty(freezeIndexDir);\n              }\n            }\n            \n            @Override\n            public void postClose() {\n              LOG.info(\"removing old index directory \" + freezeIndexDir);\n              try {\n                core.getDirectoryFactory().remove(freezeIndexDir);\n              } catch (IOException e) {\n                SolrException.log(LOG, \"Error removing directory \" + freezeIndexDir, e);\n              }\n            }\n            \n          });\n        }\n\n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            core.getDirectoryFactory().doneWithDirectory(oldDirectory);\n          }\n          doCommit(isFullCopyNeeded);\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory files \" + tmpIndexDir);\n          if (tmpIndex != null && core.getDirectoryFactory().exists(tmpIndex)) {\n            DirectoryFactory.empty(tmpIndexDir);\n          }\n        } \n      }\n    } finally {\n      try {\n        if (!successfulInstall) {\n          logReplicationTimeAndConfFiles(null, successfulInstall);\n        }\n        filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n        replicationStartTime = 0;\n        dirFileFetcher = null;\n        localFileFetcher = null;\n        if (fsyncService != null && !fsyncService.isShutdown()) fsyncService\n            .shutdownNow();\n        fsyncService = null;\n        stop = false;\n        fsyncException = null;\n      } finally {\n        if (tmpIndexDir != null) {\n          core.getDirectoryFactory().release(tmpIndexDir);\n        }\n        if (deleteTmpIdxDir && tmpIndexDir != null) {\n          try {\n            core.getDirectoryFactory().remove(tmpIndexDir);\n          } catch (IOException e) {\n            SolrException.log(LOG, \"Error removing directory \" + tmpIndexDir, e);\n          }\n        }\n        if (indexDir != null) {\n          core.getDirectoryFactory().release(indexDir);\n        }\n      }\n    }\n  }\n\n","bugFix":["b6d2d51ff0b489e2d7ddc42a63f0d6cb69326469"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"948cb7389da6d4f397f5a0f89caf885a9033c959","date":1362946471,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(final SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    Directory tmpIndexDir = null;\n    String tmpIndex = null;\n    Directory indexDir = null;\n    String indexDirPath = null;\n    boolean deleteTmpIdxDir = true;\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper\n          .getCommitTimestamp(commit) >= latestVersion\n          || commit.getGeneration() >= latestGeneration || forceReplication;\n\n      String tmpIdxDirName = \"index.\" + new SimpleDateFormat(SnapShooter.DATE_FMT, Locale.ROOT).format(new Date());\n      tmpIndex = createTempindexDir(core, tmpIdxDirName);\n\n      tmpIndexDir = core.getDirectoryFactory().get(tmpIndex, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n      \n      // make sure it's the newest known index dir...\n      indexDirPath = core.getNewIndexDir();\n      indexDir = core.getDirectoryFactory().get(indexDirPath, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n      Directory oldDirectory = null;\n\n      try {\n        \n        if (isIndexStale(indexDir)) {\n          isFullCopyNeeded = true;\n        }\n        LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n        successfulInstall = false;\n        \n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir  =  false;\n          } else {\n            successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir =  false;\n            RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n            try {\n               oldDirectory = iw.get().getDirectory();\n            } finally {\n              iw.decref();\n            }\n          } else {\n            successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n        \n        if (isFullCopyNeeded) {\n          // we have to do this before commit\n          final Directory freezeIndexDir = indexDir;\n          final String freezeIndexDirPath = indexDirPath;\n          core.getDirectoryFactory().addCloseListener(oldDirectory, new CloseListener(){\n\n            @Override\n            public void preClose() {\n              LOG.info(\"removing old index files \" + freezeIndexDir);\n              try {\n                if (core.getDirectoryFactory().exists(freezeIndexDirPath)) {\n                  DirectoryFactory.empty(freezeIndexDir);\n                }\n              } catch (IOException e) {\n                SolrException.log(LOG, null, e);\n              }\n            }\n            \n            @Override\n            public void postClose() {\n              LOG.info(\"removing old index directory \" + freezeIndexDir);\n              try {\n                core.getDirectoryFactory().remove(freezeIndexDir);\n              } catch (IOException e) {\n                SolrException.log(LOG, \"Error removing directory \" + freezeIndexDir, e);\n              }\n            }\n            \n          });\n        }\n\n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            core.getDirectoryFactory().doneWithDirectory(oldDirectory);\n          }\n          openNewWriterAndSearcher(isFullCopyNeeded);\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory files \" + tmpIndexDir);\n          if (tmpIndex != null && core.getDirectoryFactory().exists(tmpIndex)) {\n            DirectoryFactory.empty(tmpIndexDir);\n          }\n        } \n      }\n    } finally {\n      try {\n        if (!successfulInstall) {\n          logReplicationTimeAndConfFiles(null, successfulInstall);\n        }\n        filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n        replicationStartTime = 0;\n        dirFileFetcher = null;\n        localFileFetcher = null;\n        if (fsyncService != null && !fsyncService.isShutdown()) fsyncService\n            .shutdownNow();\n        fsyncService = null;\n        stop = false;\n        fsyncException = null;\n      } finally {\n        if (tmpIndexDir != null) {\n          core.getDirectoryFactory().release(tmpIndexDir);\n        }\n        if (deleteTmpIdxDir && tmpIndexDir != null) {\n          try {\n            core.getDirectoryFactory().remove(tmpIndexDir);\n          } catch (IOException e) {\n            SolrException.log(LOG, \"Error removing directory \" + tmpIndexDir, e);\n          }\n        }\n        if (indexDir != null) {\n          core.getDirectoryFactory().release(indexDir);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(final SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    Directory tmpIndexDir = null;\n    String tmpIndex = null;\n    Directory indexDir = null;\n    String indexDirPath = null;\n    boolean deleteTmpIdxDir = true;\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper\n          .getCommitTimestamp(commit) >= latestVersion\n          || commit.getGeneration() >= latestGeneration || forceReplication;\n\n      String tmpIdxDirName = \"index.\" + new SimpleDateFormat(SnapShooter.DATE_FMT, Locale.ROOT).format(new Date());\n      tmpIndex = createTempindexDir(core, tmpIdxDirName);\n\n      tmpIndexDir = core.getDirectoryFactory().get(tmpIndex, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n      \n      // make sure it's the newest known index dir...\n      indexDirPath = core.getNewIndexDir();\n      indexDir = core.getDirectoryFactory().get(indexDirPath, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n      Directory oldDirectory = null;\n\n      try {\n        \n        if (isIndexStale(indexDir)) {\n          isFullCopyNeeded = true;\n        }\n        LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n        successfulInstall = false;\n        \n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir  =  false;\n          } else {\n            successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir =  false;\n            RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n            try {\n               oldDirectory = iw.get().getDirectory();\n            } finally {\n              iw.decref();\n            }\n          } else {\n            successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n        \n        if (isFullCopyNeeded) {\n          // we have to do this before commit\n          final Directory freezeIndexDir = indexDir;\n          final String freezeIndexDirPath = indexDirPath;\n          core.getDirectoryFactory().addCloseListener(oldDirectory, new CloseListener(){\n\n            @Override\n            public void preClose() {\n              LOG.info(\"removing old index files \" + freezeIndexDir);\n              if (core.getDirectoryFactory().exists(freezeIndexDirPath)) {\n                DirectoryFactory.empty(freezeIndexDir);\n              }\n            }\n            \n            @Override\n            public void postClose() {\n              LOG.info(\"removing old index directory \" + freezeIndexDir);\n              try {\n                core.getDirectoryFactory().remove(freezeIndexDir);\n              } catch (IOException e) {\n                SolrException.log(LOG, \"Error removing directory \" + freezeIndexDir, e);\n              }\n            }\n            \n          });\n        }\n\n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            core.getDirectoryFactory().doneWithDirectory(oldDirectory);\n          }\n          openNewWriterAndSearcher(isFullCopyNeeded);\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory files \" + tmpIndexDir);\n          if (tmpIndex != null && core.getDirectoryFactory().exists(tmpIndex)) {\n            DirectoryFactory.empty(tmpIndexDir);\n          }\n        } \n      }\n    } finally {\n      try {\n        if (!successfulInstall) {\n          logReplicationTimeAndConfFiles(null, successfulInstall);\n        }\n        filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n        replicationStartTime = 0;\n        dirFileFetcher = null;\n        localFileFetcher = null;\n        if (fsyncService != null && !fsyncService.isShutdown()) fsyncService\n            .shutdownNow();\n        fsyncService = null;\n        stop = false;\n        fsyncException = null;\n      } finally {\n        if (tmpIndexDir != null) {\n          core.getDirectoryFactory().release(tmpIndexDir);\n        }\n        if (deleteTmpIdxDir && tmpIndexDir != null) {\n          try {\n            core.getDirectoryFactory().remove(tmpIndexDir);\n          } catch (IOException e) {\n            SolrException.log(LOG, \"Error removing directory \" + tmpIndexDir, e);\n          }\n        }\n        if (indexDir != null) {\n          core.getDirectoryFactory().release(indexDir);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["058801f8673d53a5abac8088204860ec29a40f0d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4dcfb92697fbd03e488cf9e5155514e3270d0fc3","date":1363541819,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(final SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    Directory tmpIndexDir = null;\n    String tmpIndex = null;\n    Directory indexDir = null;\n    String indexDirPath = null;\n    boolean deleteTmpIdxDir = true;\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper\n          .getCommitTimestamp(commit) >= latestVersion\n          || commit.getGeneration() >= latestGeneration || forceReplication;\n\n      String tmpIdxDirName = \"index.\" + new SimpleDateFormat(SnapShooter.DATE_FMT, Locale.ROOT).format(new Date());\n      tmpIndex = createTempindexDir(core, tmpIdxDirName);\n\n      tmpIndexDir = core.getDirectoryFactory().get(tmpIndex, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n      \n      // make sure it's the newest known index dir...\n      indexDirPath = core.getNewIndexDir();\n      indexDir = core.getDirectoryFactory().get(indexDirPath, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n      Directory oldDirectory = null;\n\n      try {\n        \n        if (isIndexStale(indexDir)) {\n          isFullCopyNeeded = true;\n        }\n        LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n        successfulInstall = false;\n        \n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir  =  false;\n          } else {\n            successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir =  false;\n            RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n            try {\n               oldDirectory = iw.get().getDirectory();\n            } finally {\n              iw.decref();\n            }\n          } else {\n            successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n        \n        if (isFullCopyNeeded) {\n          // we have to do this before commit\n          final Directory freezeIndexDir = indexDir;\n          final String freezeIndexDirPath = indexDirPath;\n          core.getDirectoryFactory().addCloseListener(oldDirectory, new CloseListener(){\n\n            @Override\n            public void preClose() {\n              LOG.info(\"removing old index files \" + freezeIndexDir);\n              try {\n                if (core.getDirectoryFactory().exists(freezeIndexDirPath)) {\n                  DirectoryFactory.empty(freezeIndexDir);\n                }\n              } catch (IOException e) {\n                SolrException.log(LOG, null, e);\n              }\n            }\n            \n            @Override\n            public void postClose() {\n              LOG.info(\"removing old index directory \" + freezeIndexDir);\n              try {\n                core.getDirectoryFactory().remove(freezeIndexDir);\n              } catch (IOException e) {\n                SolrException.log(LOG, \"Error removing directory \" + freezeIndexDir, e);\n              }\n            }\n            \n          });\n        }\n\n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            core.getDirectoryFactory().doneWithDirectory(oldDirectory);\n          }\n          openNewWriterAndSearcher(isFullCopyNeeded);\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      }\n    } finally {\n      try {\n        if (!successfulInstall) {\n          logReplicationTimeAndConfFiles(null, successfulInstall);\n        }\n        filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n        replicationStartTime = 0;\n        dirFileFetcher = null;\n        localFileFetcher = null;\n        if (fsyncService != null && !fsyncService.isShutdown()) fsyncService\n            .shutdownNow();\n        fsyncService = null;\n        stop = false;\n        fsyncException = null;\n      } finally {\n        if (deleteTmpIdxDir && tmpIndexDir != null) {\n          try {\n            core.getDirectoryFactory().remove(tmpIndexDir);\n          } catch (IOException e) {\n            SolrException.log(LOG, \"Error removing directory \" + tmpIndexDir, e);\n          }\n        }\n        \n        if (tmpIndexDir != null) {\n          core.getDirectoryFactory().release(tmpIndexDir);\n        }\n        \n        if (indexDir != null) {\n          core.getDirectoryFactory().release(indexDir);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(final SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    Directory tmpIndexDir = null;\n    String tmpIndex = null;\n    Directory indexDir = null;\n    String indexDirPath = null;\n    boolean deleteTmpIdxDir = true;\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper\n          .getCommitTimestamp(commit) >= latestVersion\n          || commit.getGeneration() >= latestGeneration || forceReplication;\n\n      String tmpIdxDirName = \"index.\" + new SimpleDateFormat(SnapShooter.DATE_FMT, Locale.ROOT).format(new Date());\n      tmpIndex = createTempindexDir(core, tmpIdxDirName);\n\n      tmpIndexDir = core.getDirectoryFactory().get(tmpIndex, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n      \n      // make sure it's the newest known index dir...\n      indexDirPath = core.getNewIndexDir();\n      indexDir = core.getDirectoryFactory().get(indexDirPath, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n      Directory oldDirectory = null;\n\n      try {\n        \n        if (isIndexStale(indexDir)) {\n          isFullCopyNeeded = true;\n        }\n        LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n        successfulInstall = false;\n        \n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir  =  false;\n          } else {\n            successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir =  false;\n            RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n            try {\n               oldDirectory = iw.get().getDirectory();\n            } finally {\n              iw.decref();\n            }\n          } else {\n            successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n        \n        if (isFullCopyNeeded) {\n          // we have to do this before commit\n          final Directory freezeIndexDir = indexDir;\n          final String freezeIndexDirPath = indexDirPath;\n          core.getDirectoryFactory().addCloseListener(oldDirectory, new CloseListener(){\n\n            @Override\n            public void preClose() {\n              LOG.info(\"removing old index files \" + freezeIndexDir);\n              try {\n                if (core.getDirectoryFactory().exists(freezeIndexDirPath)) {\n                  DirectoryFactory.empty(freezeIndexDir);\n                }\n              } catch (IOException e) {\n                SolrException.log(LOG, null, e);\n              }\n            }\n            \n            @Override\n            public void postClose() {\n              LOG.info(\"removing old index directory \" + freezeIndexDir);\n              try {\n                core.getDirectoryFactory().remove(freezeIndexDir);\n              } catch (IOException e) {\n                SolrException.log(LOG, \"Error removing directory \" + freezeIndexDir, e);\n              }\n            }\n            \n          });\n        }\n\n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            core.getDirectoryFactory().doneWithDirectory(oldDirectory);\n          }\n          openNewWriterAndSearcher(isFullCopyNeeded);\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      } finally {\n        if (deleteTmpIdxDir) {\n          LOG.info(\"removing temporary index download directory files \" + tmpIndexDir);\n          if (tmpIndex != null && core.getDirectoryFactory().exists(tmpIndex)) {\n            DirectoryFactory.empty(tmpIndexDir);\n          }\n        } \n      }\n    } finally {\n      try {\n        if (!successfulInstall) {\n          logReplicationTimeAndConfFiles(null, successfulInstall);\n        }\n        filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n        replicationStartTime = 0;\n        dirFileFetcher = null;\n        localFileFetcher = null;\n        if (fsyncService != null && !fsyncService.isShutdown()) fsyncService\n            .shutdownNow();\n        fsyncService = null;\n        stop = false;\n        fsyncException = null;\n      } finally {\n        if (tmpIndexDir != null) {\n          core.getDirectoryFactory().release(tmpIndexDir);\n        }\n        if (deleteTmpIdxDir && tmpIndexDir != null) {\n          try {\n            core.getDirectoryFactory().remove(tmpIndexDir);\n          } catch (IOException e) {\n            SolrException.log(LOG, \"Error removing directory \" + tmpIndexDir, e);\n          }\n        }\n        if (indexDir != null) {\n          core.getDirectoryFactory().release(indexDir);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["6c94d2661bc1c14426980ec7882e951fdcff08d0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"058801f8673d53a5abac8088204860ec29a40f0d","date":1364178882,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(final SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    Directory tmpIndexDir = null;\n    String tmpIndex = null;\n    Directory indexDir = null;\n    String indexDirPath = null;\n    boolean deleteTmpIdxDir = true;\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper\n          .getCommitTimestamp(commit) >= latestVersion\n          || commit.getGeneration() >= latestGeneration || forceReplication;\n\n      String tmpIdxDirName = \"index.\" + new SimpleDateFormat(SnapShooter.DATE_FMT, Locale.ROOT).format(new Date());\n      tmpIndex = createTempindexDir(core, tmpIdxDirName);\n\n      tmpIndexDir = core.getDirectoryFactory().get(tmpIndex, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n      \n      // cindex dir...\n      indexDirPath = core.getIndexDir();\n      indexDir = core.getDirectoryFactory().get(indexDirPath, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n\n      try {\n        \n        if (isIndexStale(indexDir)) {\n          isFullCopyNeeded = true;\n        }\n        LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n        successfulInstall = false;\n        \n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir  =  false;\n          } else {\n            successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            if (isFullCopyNeeded) {\n              // let the system know we are changing dir's and the old one\n              // may be closed\n              if (indexDir != null) {\n                LOG.info(\"removing old index directory \" + indexDir);\n                core.getDirectoryFactory().doneWithDirectory(indexDir);\n                core.getDirectoryFactory().remove(indexDir);\n              }\n            }\n            \n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n\n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            if (indexDir != null) {\n              LOG.info(\"removing old index directory \" + indexDir);\n              core.getDirectoryFactory().doneWithDirectory(indexDir);\n              core.getDirectoryFactory().remove(indexDir);\n            }\n          }\n          openNewWriterAndSearcher(isFullCopyNeeded);\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      }\n    } finally {\n      try {\n        if (!successfulInstall) {\n          logReplicationTimeAndConfFiles(null, successfulInstall);\n        }\n        filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n        replicationStartTime = 0;\n        dirFileFetcher = null;\n        localFileFetcher = null;\n        if (fsyncService != null && !fsyncService.isShutdown()) fsyncService\n            .shutdownNow();\n        fsyncService = null;\n        stop = false;\n        fsyncException = null;\n      } finally {\n        if (deleteTmpIdxDir && tmpIndexDir != null) {\n          try {\n            core.getDirectoryFactory().doneWithDirectory(tmpIndexDir);\n            core.getDirectoryFactory().remove(tmpIndexDir);\n          } catch (IOException e) {\n            SolrException.log(LOG, \"Error removing directory \" + tmpIndexDir, e);\n          }\n        }\n        \n        if (tmpIndexDir != null) {\n          core.getDirectoryFactory().release(tmpIndexDir);\n        }\n        \n        if (indexDir != null) {\n          core.getDirectoryFactory().release(indexDir);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(final SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    Directory tmpIndexDir = null;\n    String tmpIndex = null;\n    Directory indexDir = null;\n    String indexDirPath = null;\n    boolean deleteTmpIdxDir = true;\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper\n          .getCommitTimestamp(commit) >= latestVersion\n          || commit.getGeneration() >= latestGeneration || forceReplication;\n\n      String tmpIdxDirName = \"index.\" + new SimpleDateFormat(SnapShooter.DATE_FMT, Locale.ROOT).format(new Date());\n      tmpIndex = createTempindexDir(core, tmpIdxDirName);\n\n      tmpIndexDir = core.getDirectoryFactory().get(tmpIndex, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n      \n      // make sure it's the newest known index dir...\n      indexDirPath = core.getNewIndexDir();\n      indexDir = core.getDirectoryFactory().get(indexDirPath, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n      Directory oldDirectory = null;\n\n      try {\n        \n        if (isIndexStale(indexDir)) {\n          isFullCopyNeeded = true;\n        }\n        LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n        successfulInstall = false;\n        \n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir  =  false;\n          } else {\n            successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir =  false;\n            RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n            try {\n               oldDirectory = iw.get().getDirectory();\n            } finally {\n              iw.decref();\n            }\n          } else {\n            successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n        \n        if (isFullCopyNeeded) {\n          // we have to do this before commit\n          final Directory freezeIndexDir = indexDir;\n          final String freezeIndexDirPath = indexDirPath;\n          core.getDirectoryFactory().addCloseListener(oldDirectory, new CloseListener(){\n\n            @Override\n            public void preClose() {\n              LOG.info(\"removing old index files \" + freezeIndexDir);\n              try {\n                if (core.getDirectoryFactory().exists(freezeIndexDirPath)) {\n                  DirectoryFactory.empty(freezeIndexDir);\n                }\n              } catch (IOException e) {\n                SolrException.log(LOG, null, e);\n              }\n            }\n            \n            @Override\n            public void postClose() {\n              LOG.info(\"removing old index directory \" + freezeIndexDir);\n              try {\n                core.getDirectoryFactory().remove(freezeIndexDir);\n              } catch (IOException e) {\n                SolrException.log(LOG, \"Error removing directory \" + freezeIndexDir, e);\n              }\n            }\n            \n          });\n        }\n\n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            core.getDirectoryFactory().doneWithDirectory(oldDirectory);\n          }\n          openNewWriterAndSearcher(isFullCopyNeeded);\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      }\n    } finally {\n      try {\n        if (!successfulInstall) {\n          logReplicationTimeAndConfFiles(null, successfulInstall);\n        }\n        filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n        replicationStartTime = 0;\n        dirFileFetcher = null;\n        localFileFetcher = null;\n        if (fsyncService != null && !fsyncService.isShutdown()) fsyncService\n            .shutdownNow();\n        fsyncService = null;\n        stop = false;\n        fsyncException = null;\n      } finally {\n        if (deleteTmpIdxDir && tmpIndexDir != null) {\n          try {\n            core.getDirectoryFactory().remove(tmpIndexDir);\n          } catch (IOException e) {\n            SolrException.log(LOG, \"Error removing directory \" + tmpIndexDir, e);\n          }\n        }\n        \n        if (tmpIndexDir != null) {\n          core.getDirectoryFactory().release(tmpIndexDir);\n        }\n        \n        if (indexDir != null) {\n          core.getDirectoryFactory().release(indexDir);\n        }\n      }\n    }\n  }\n\n","bugFix":["ad3c006a1d6ec52c49f33c62a3678bf5023d9baf","948cb7389da6d4f397f5a0f89caf885a9033c959","d9405f486872f1e416304dfe389741f4ee2f8a4d","d97814e287f694bcb4c679646ff4ac52fd8663c6","4897c5b415f476d84ec970a19c41510645887526"],"bugIntro":["6c94d2661bc1c14426980ec7882e951fdcff08d0","190779ba7de3fda15afd1bbafbc383720a4b0966"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d8a3067239133ceb0117bc3d48356169cf03894f","date":1372268205,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(final SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    Directory tmpIndexDir = null;\n    String tmpIndex = null;\n    Directory indexDir = null;\n    String indexDirPath = null;\n    boolean deleteTmpIdxDir = true;\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper\n          .getCommitTimestamp(commit) >= latestVersion\n          || commit.getGeneration() >= latestGeneration || forceReplication;\n\n      String tmpIdxDirName = \"index.\" + new SimpleDateFormat(SnapShooter.DATE_FMT, Locale.ROOT).format(new Date());\n      tmpIndex = createTempindexDir(core, tmpIdxDirName);\n\n      tmpIndexDir = core.getDirectoryFactory().get(tmpIndex, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n      \n      // cindex dir...\n      indexDirPath = core.getIndexDir();\n      indexDir = core.getDirectoryFactory().get(indexDirPath, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n\n      try {\n        \n        if (isIndexStale(indexDir)) {\n          isFullCopyNeeded = true;\n        }\n        LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n        successfulInstall = false;\n        \n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir  =  false;\n          } else {\n            solrCore.getUpdateHandler().getSolrCoreState()\n                .closeIndexWriter(core, true);\n            try {\n              successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n            } finally {\n              solrCore.getUpdateHandler().getSolrCoreState()\n                  .openIndexWriter(core);\n            }\n          }\n          if (successfulInstall) {\n            if (isFullCopyNeeded) {\n              // let the system know we are changing dir's and the old one\n              // may be closed\n              if (indexDir != null) {\n                LOG.info(\"removing old index directory \" + indexDir);\n                core.getDirectoryFactory().doneWithDirectory(indexDir);\n                core.getDirectoryFactory().remove(indexDir);\n              }\n            }\n            \n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir =  false;\n          } else {\n            solrCore.getUpdateHandler().getSolrCoreState().closeIndexWriter(core, true);\n            try {\n              successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n            } finally {\n              solrCore.getUpdateHandler().getSolrCoreState().openIndexWriter(core);\n            }\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n\n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            if (indexDir != null) {\n              LOG.info(\"removing old index directory \" + indexDir);\n              core.getDirectoryFactory().doneWithDirectory(indexDir);\n              core.getDirectoryFactory().remove(indexDir);\n            }\n          }\n          if (isFullCopyNeeded) {\n            solrCore.getUpdateHandler().newIndexWriter(isFullCopyNeeded);\n          }\n          \n          openNewSearcherAndUpdateCommitPoint(isFullCopyNeeded);\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      }\n    } finally {\n      try {\n        if (!successfulInstall) {\n          logReplicationTimeAndConfFiles(null, successfulInstall);\n        }\n        filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n        replicationStartTime = 0;\n        dirFileFetcher = null;\n        localFileFetcher = null;\n        if (fsyncService != null && !fsyncService.isShutdown()) fsyncService\n            .shutdownNow();\n        fsyncService = null;\n        stop = false;\n        fsyncException = null;\n      } finally {\n        if (deleteTmpIdxDir && tmpIndexDir != null) {\n          try {\n            core.getDirectoryFactory().doneWithDirectory(tmpIndexDir);\n            core.getDirectoryFactory().remove(tmpIndexDir);\n          } catch (IOException e) {\n            SolrException.log(LOG, \"Error removing directory \" + tmpIndexDir, e);\n          }\n        }\n        \n        if (tmpIndexDir != null) {\n          core.getDirectoryFactory().release(tmpIndexDir);\n        }\n        \n        if (indexDir != null) {\n          core.getDirectoryFactory().release(indexDir);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(final SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    Directory tmpIndexDir = null;\n    String tmpIndex = null;\n    Directory indexDir = null;\n    String indexDirPath = null;\n    boolean deleteTmpIdxDir = true;\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper\n          .getCommitTimestamp(commit) >= latestVersion\n          || commit.getGeneration() >= latestGeneration || forceReplication;\n\n      String tmpIdxDirName = \"index.\" + new SimpleDateFormat(SnapShooter.DATE_FMT, Locale.ROOT).format(new Date());\n      tmpIndex = createTempindexDir(core, tmpIdxDirName);\n\n      tmpIndexDir = core.getDirectoryFactory().get(tmpIndex, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n      \n      // cindex dir...\n      indexDirPath = core.getIndexDir();\n      indexDir = core.getDirectoryFactory().get(indexDirPath, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n\n      try {\n        \n        if (isIndexStale(indexDir)) {\n          isFullCopyNeeded = true;\n        }\n        LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n        successfulInstall = false;\n        \n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir  =  false;\n          } else {\n            successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            if (isFullCopyNeeded) {\n              // let the system know we are changing dir's and the old one\n              // may be closed\n              if (indexDir != null) {\n                LOG.info(\"removing old index directory \" + indexDir);\n                core.getDirectoryFactory().doneWithDirectory(indexDir);\n                core.getDirectoryFactory().remove(indexDir);\n              }\n            }\n            \n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n\n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            if (indexDir != null) {\n              LOG.info(\"removing old index directory \" + indexDir);\n              core.getDirectoryFactory().doneWithDirectory(indexDir);\n              core.getDirectoryFactory().remove(indexDir);\n            }\n          }\n          openNewWriterAndSearcher(isFullCopyNeeded);\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      }\n    } finally {\n      try {\n        if (!successfulInstall) {\n          logReplicationTimeAndConfFiles(null, successfulInstall);\n        }\n        filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n        replicationStartTime = 0;\n        dirFileFetcher = null;\n        localFileFetcher = null;\n        if (fsyncService != null && !fsyncService.isShutdown()) fsyncService\n            .shutdownNow();\n        fsyncService = null;\n        stop = false;\n        fsyncException = null;\n      } finally {\n        if (deleteTmpIdxDir && tmpIndexDir != null) {\n          try {\n            core.getDirectoryFactory().doneWithDirectory(tmpIndexDir);\n            core.getDirectoryFactory().remove(tmpIndexDir);\n          } catch (IOException e) {\n            SolrException.log(LOG, \"Error removing directory \" + tmpIndexDir, e);\n          }\n        }\n        \n        if (tmpIndexDir != null) {\n          core.getDirectoryFactory().release(tmpIndexDir);\n        }\n        \n        if (indexDir != null) {\n          core.getDirectoryFactory().release(indexDir);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["6c94d2661bc1c14426980ec7882e951fdcff08d0","190779ba7de3fda15afd1bbafbc383720a4b0966"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8dd517686f746fb280a35ebadd0abf38e864fb41","date":1372275216,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(final SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    Directory tmpIndexDir = null;\n    String tmpIndex = null;\n    Directory indexDir = null;\n    String indexDirPath = null;\n    boolean deleteTmpIdxDir = true;\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit = core.getDeletionPolicy().getLatestCommit();\n      \n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper\n          .getCommitTimestamp(commit) >= latestVersion\n          || commit.getGeneration() >= latestGeneration || forceReplication;\n\n      String tmpIdxDirName = \"index.\" + new SimpleDateFormat(SnapShooter.DATE_FMT, Locale.ROOT).format(new Date());\n      tmpIndex = createTempindexDir(core, tmpIdxDirName);\n\n      tmpIndexDir = core.getDirectoryFactory().get(tmpIndex, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n      \n      // cindex dir...\n      indexDirPath = core.getIndexDir();\n      indexDir = core.getDirectoryFactory().get(indexDirPath, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n\n      try {\n        \n        if (isIndexStale(indexDir)) {\n          isFullCopyNeeded = true;\n        }\n        LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n        successfulInstall = false;\n        \n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir  =  false;\n          } else {\n            solrCore.getUpdateHandler().getSolrCoreState()\n                .closeIndexWriter(core, true);\n            try {\n              successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n            } finally {\n              solrCore.getUpdateHandler().getSolrCoreState()\n                  .openIndexWriter(core);\n            }\n          }\n          if (successfulInstall) {\n            if (isFullCopyNeeded) {\n              // let the system know we are changing dir's and the old one\n              // may be closed\n              if (indexDir != null) {\n                LOG.info(\"removing old index directory \" + indexDir);\n                core.getDirectoryFactory().doneWithDirectory(indexDir);\n                core.getDirectoryFactory().remove(indexDir);\n              }\n            }\n            \n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir =  false;\n          } else {\n            solrCore.getUpdateHandler().getSolrCoreState().closeIndexWriter(core, true);\n            try {\n              successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n            } finally {\n              solrCore.getUpdateHandler().getSolrCoreState().openIndexWriter(core);\n            }\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n\n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            if (indexDir != null) {\n              LOG.info(\"removing old index directory \" + indexDir);\n              core.getDirectoryFactory().doneWithDirectory(indexDir);\n              core.getDirectoryFactory().remove(indexDir);\n            }\n          }\n          if (isFullCopyNeeded) {\n            solrCore.getUpdateHandler().newIndexWriter(isFullCopyNeeded);\n          }\n          \n          openNewSearcherAndUpdateCommitPoint(isFullCopyNeeded);\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      }\n    } finally {\n      try {\n        if (!successfulInstall) {\n          logReplicationTimeAndConfFiles(null, successfulInstall);\n        }\n        filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n        replicationStartTime = 0;\n        dirFileFetcher = null;\n        localFileFetcher = null;\n        if (fsyncService != null && !fsyncService.isShutdown()) fsyncService\n            .shutdownNow();\n        fsyncService = null;\n        stop = false;\n        fsyncException = null;\n      } finally {\n        if (deleteTmpIdxDir && tmpIndexDir != null) {\n          try {\n            core.getDirectoryFactory().doneWithDirectory(tmpIndexDir);\n            core.getDirectoryFactory().remove(tmpIndexDir);\n          } catch (IOException e) {\n            SolrException.log(LOG, \"Error removing directory \" + tmpIndexDir, e);\n          }\n        }\n        \n        if (tmpIndexDir != null) {\n          core.getDirectoryFactory().release(tmpIndexDir);\n        }\n        \n        if (indexDir != null) {\n          core.getDirectoryFactory().release(indexDir);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(final SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    Directory tmpIndexDir = null;\n    String tmpIndex = null;\n    Directory indexDir = null;\n    String indexDirPath = null;\n    boolean deleteTmpIdxDir = true;\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper\n          .getCommitTimestamp(commit) >= latestVersion\n          || commit.getGeneration() >= latestGeneration || forceReplication;\n\n      String tmpIdxDirName = \"index.\" + new SimpleDateFormat(SnapShooter.DATE_FMT, Locale.ROOT).format(new Date());\n      tmpIndex = createTempindexDir(core, tmpIdxDirName);\n\n      tmpIndexDir = core.getDirectoryFactory().get(tmpIndex, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n      \n      // cindex dir...\n      indexDirPath = core.getIndexDir();\n      indexDir = core.getDirectoryFactory().get(indexDirPath, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n\n      try {\n        \n        if (isIndexStale(indexDir)) {\n          isFullCopyNeeded = true;\n        }\n        LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n        successfulInstall = false;\n        \n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir  =  false;\n          } else {\n            solrCore.getUpdateHandler().getSolrCoreState()\n                .closeIndexWriter(core, true);\n            try {\n              successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n            } finally {\n              solrCore.getUpdateHandler().getSolrCoreState()\n                  .openIndexWriter(core);\n            }\n          }\n          if (successfulInstall) {\n            if (isFullCopyNeeded) {\n              // let the system know we are changing dir's and the old one\n              // may be closed\n              if (indexDir != null) {\n                LOG.info(\"removing old index directory \" + indexDir);\n                core.getDirectoryFactory().doneWithDirectory(indexDir);\n                core.getDirectoryFactory().remove(indexDir);\n              }\n            }\n            \n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir =  false;\n          } else {\n            solrCore.getUpdateHandler().getSolrCoreState().closeIndexWriter(core, true);\n            try {\n              successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n            } finally {\n              solrCore.getUpdateHandler().getSolrCoreState().openIndexWriter(core);\n            }\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n\n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            if (indexDir != null) {\n              LOG.info(\"removing old index directory \" + indexDir);\n              core.getDirectoryFactory().doneWithDirectory(indexDir);\n              core.getDirectoryFactory().remove(indexDir);\n            }\n          }\n          if (isFullCopyNeeded) {\n            solrCore.getUpdateHandler().newIndexWriter(isFullCopyNeeded);\n          }\n          \n          openNewSearcherAndUpdateCommitPoint(isFullCopyNeeded);\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      }\n    } finally {\n      try {\n        if (!successfulInstall) {\n          logReplicationTimeAndConfFiles(null, successfulInstall);\n        }\n        filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n        replicationStartTime = 0;\n        dirFileFetcher = null;\n        localFileFetcher = null;\n        if (fsyncService != null && !fsyncService.isShutdown()) fsyncService\n            .shutdownNow();\n        fsyncService = null;\n        stop = false;\n        fsyncException = null;\n      } finally {\n        if (deleteTmpIdxDir && tmpIndexDir != null) {\n          try {\n            core.getDirectoryFactory().doneWithDirectory(tmpIndexDir);\n            core.getDirectoryFactory().remove(tmpIndexDir);\n          } catch (IOException e) {\n            SolrException.log(LOG, \"Error removing directory \" + tmpIndexDir, e);\n          }\n        }\n        \n        if (tmpIndexDir != null) {\n          core.getDirectoryFactory().release(tmpIndexDir);\n        }\n        \n        if (indexDir != null) {\n          core.getDirectoryFactory().release(indexDir);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["6c94d2661bc1c14426980ec7882e951fdcff08d0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b3c2c17185ad7fb0aa9b81dbd9d0395debbc4519","date":1372696435,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(final SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    Directory tmpIndexDir = null;\n    String tmpIndex = null;\n    Directory indexDir = null;\n    String indexDirPath = null;\n    boolean deleteTmpIdxDir = true;\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      // TODO: make sure that getLatestCommit only returns commit points for the main index (i.e. no side-car indexes)\n      IndexCommit commit = core.getDeletionPolicy().getLatestCommit();\n      if (commit == null) {\n        // Presumably the IndexWriter hasn't been opened yet, and hence the deletion policy hasn't been updated with commit points\n        RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n        try {\n          searcherRefCounted = core.getNewestSearcher(false);\n          if (searcherRefCounted == null) {\n            LOG.warn(\"No open searcher found - fetch aborted\");\n            return false;\n          }\n          commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n        } finally {\n          if (searcherRefCounted != null)\n            searcherRefCounted.decref();\n        }\n      }\n\n\n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper\n          .getCommitTimestamp(commit) >= latestVersion\n          || commit.getGeneration() >= latestGeneration || forceReplication;\n\n      String tmpIdxDirName = \"index.\" + new SimpleDateFormat(SnapShooter.DATE_FMT, Locale.ROOT).format(new Date());\n      tmpIndex = createTempindexDir(core, tmpIdxDirName);\n\n      tmpIndexDir = core.getDirectoryFactory().get(tmpIndex, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n      \n      // cindex dir...\n      indexDirPath = core.getIndexDir();\n      indexDir = core.getDirectoryFactory().get(indexDirPath, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n\n      try {\n        \n        if (isIndexStale(indexDir)) {\n          isFullCopyNeeded = true;\n        }\n        LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n        successfulInstall = false;\n        \n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir  =  false;\n          } else {\n            solrCore.getUpdateHandler().getSolrCoreState()\n                .closeIndexWriter(core, true);\n            try {\n              successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n            } finally {\n              solrCore.getUpdateHandler().getSolrCoreState()\n                  .openIndexWriter(core);\n            }\n          }\n          if (successfulInstall) {\n            if (isFullCopyNeeded) {\n              // let the system know we are changing dir's and the old one\n              // may be closed\n              if (indexDir != null) {\n                LOG.info(\"removing old index directory \" + indexDir);\n                core.getDirectoryFactory().doneWithDirectory(indexDir);\n                core.getDirectoryFactory().remove(indexDir);\n              }\n            }\n            \n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir =  false;\n          } else {\n            solrCore.getUpdateHandler().getSolrCoreState().closeIndexWriter(core, true);\n            try {\n              successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n            } finally {\n              solrCore.getUpdateHandler().getSolrCoreState().openIndexWriter(core);\n            }\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n\n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            if (indexDir != null) {\n              LOG.info(\"removing old index directory \" + indexDir);\n              core.getDirectoryFactory().doneWithDirectory(indexDir);\n              core.getDirectoryFactory().remove(indexDir);\n            }\n          }\n          if (isFullCopyNeeded) {\n            solrCore.getUpdateHandler().newIndexWriter(isFullCopyNeeded);\n          }\n          \n          openNewSearcherAndUpdateCommitPoint(isFullCopyNeeded);\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      }\n    } finally {\n      try {\n        if (!successfulInstall) {\n          logReplicationTimeAndConfFiles(null, successfulInstall);\n        }\n        filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n        replicationStartTime = 0;\n        dirFileFetcher = null;\n        localFileFetcher = null;\n        if (fsyncService != null && !fsyncService.isShutdown()) fsyncService\n            .shutdownNow();\n        fsyncService = null;\n        stop = false;\n        fsyncException = null;\n      } finally {\n        if (deleteTmpIdxDir && tmpIndexDir != null) {\n          try {\n            core.getDirectoryFactory().doneWithDirectory(tmpIndexDir);\n            core.getDirectoryFactory().remove(tmpIndexDir);\n          } catch (IOException e) {\n            SolrException.log(LOG, \"Error removing directory \" + tmpIndexDir, e);\n          }\n        }\n        \n        if (tmpIndexDir != null) {\n          core.getDirectoryFactory().release(tmpIndexDir);\n        }\n        \n        if (indexDir != null) {\n          core.getDirectoryFactory().release(indexDir);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(final SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    Directory tmpIndexDir = null;\n    String tmpIndex = null;\n    Directory indexDir = null;\n    String indexDirPath = null;\n    boolean deleteTmpIdxDir = true;\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit = core.getDeletionPolicy().getLatestCommit();\n      \n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper\n          .getCommitTimestamp(commit) >= latestVersion\n          || commit.getGeneration() >= latestGeneration || forceReplication;\n\n      String tmpIdxDirName = \"index.\" + new SimpleDateFormat(SnapShooter.DATE_FMT, Locale.ROOT).format(new Date());\n      tmpIndex = createTempindexDir(core, tmpIdxDirName);\n\n      tmpIndexDir = core.getDirectoryFactory().get(tmpIndex, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n      \n      // cindex dir...\n      indexDirPath = core.getIndexDir();\n      indexDir = core.getDirectoryFactory().get(indexDirPath, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n\n      try {\n        \n        if (isIndexStale(indexDir)) {\n          isFullCopyNeeded = true;\n        }\n        LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n        successfulInstall = false;\n        \n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir  =  false;\n          } else {\n            solrCore.getUpdateHandler().getSolrCoreState()\n                .closeIndexWriter(core, true);\n            try {\n              successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n            } finally {\n              solrCore.getUpdateHandler().getSolrCoreState()\n                  .openIndexWriter(core);\n            }\n          }\n          if (successfulInstall) {\n            if (isFullCopyNeeded) {\n              // let the system know we are changing dir's and the old one\n              // may be closed\n              if (indexDir != null) {\n                LOG.info(\"removing old index directory \" + indexDir);\n                core.getDirectoryFactory().doneWithDirectory(indexDir);\n                core.getDirectoryFactory().remove(indexDir);\n              }\n            }\n            \n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir =  false;\n          } else {\n            solrCore.getUpdateHandler().getSolrCoreState().closeIndexWriter(core, true);\n            try {\n              successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n            } finally {\n              solrCore.getUpdateHandler().getSolrCoreState().openIndexWriter(core);\n            }\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n\n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            if (indexDir != null) {\n              LOG.info(\"removing old index directory \" + indexDir);\n              core.getDirectoryFactory().doneWithDirectory(indexDir);\n              core.getDirectoryFactory().remove(indexDir);\n            }\n          }\n          if (isFullCopyNeeded) {\n            solrCore.getUpdateHandler().newIndexWriter(isFullCopyNeeded);\n          }\n          \n          openNewSearcherAndUpdateCommitPoint(isFullCopyNeeded);\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      }\n    } finally {\n      try {\n        if (!successfulInstall) {\n          logReplicationTimeAndConfFiles(null, successfulInstall);\n        }\n        filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n        replicationStartTime = 0;\n        dirFileFetcher = null;\n        localFileFetcher = null;\n        if (fsyncService != null && !fsyncService.isShutdown()) fsyncService\n            .shutdownNow();\n        fsyncService = null;\n        stop = false;\n        fsyncException = null;\n      } finally {\n        if (deleteTmpIdxDir && tmpIndexDir != null) {\n          try {\n            core.getDirectoryFactory().doneWithDirectory(tmpIndexDir);\n            core.getDirectoryFactory().remove(tmpIndexDir);\n          } catch (IOException e) {\n            SolrException.log(LOG, \"Error removing directory \" + tmpIndexDir, e);\n          }\n        }\n        \n        if (tmpIndexDir != null) {\n          core.getDirectoryFactory().release(tmpIndexDir);\n        }\n        \n        if (indexDir != null) {\n          core.getDirectoryFactory().release(indexDir);\n        }\n      }\n    }\n  }\n\n","bugFix":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"bugIntro":["6c94d2661bc1c14426980ec7882e951fdcff08d0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(final SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    Directory tmpIndexDir = null;\n    String tmpIndex = null;\n    Directory indexDir = null;\n    String indexDirPath = null;\n    boolean deleteTmpIdxDir = true;\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      // TODO: make sure that getLatestCommit only returns commit points for the main index (i.e. no side-car indexes)\n      IndexCommit commit = core.getDeletionPolicy().getLatestCommit();\n      if (commit == null) {\n        // Presumably the IndexWriter hasn't been opened yet, and hence the deletion policy hasn't been updated with commit points\n        RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n        try {\n          searcherRefCounted = core.getNewestSearcher(false);\n          if (searcherRefCounted == null) {\n            LOG.warn(\"No open searcher found - fetch aborted\");\n            return false;\n          }\n          commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n        } finally {\n          if (searcherRefCounted != null)\n            searcherRefCounted.decref();\n        }\n      }\n\n\n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper\n          .getCommitTimestamp(commit) >= latestVersion\n          || commit.getGeneration() >= latestGeneration || forceReplication;\n\n      String tmpIdxDirName = \"index.\" + new SimpleDateFormat(SnapShooter.DATE_FMT, Locale.ROOT).format(new Date());\n      tmpIndex = createTempindexDir(core, tmpIdxDirName);\n\n      tmpIndexDir = core.getDirectoryFactory().get(tmpIndex, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n      \n      // cindex dir...\n      indexDirPath = core.getIndexDir();\n      indexDir = core.getDirectoryFactory().get(indexDirPath, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n\n      try {\n        \n        if (isIndexStale(indexDir)) {\n          isFullCopyNeeded = true;\n        }\n        LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n        successfulInstall = false;\n        \n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir  =  false;\n          } else {\n            solrCore.getUpdateHandler().getSolrCoreState()\n                .closeIndexWriter(core, true);\n            try {\n              successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n            } finally {\n              solrCore.getUpdateHandler().getSolrCoreState()\n                  .openIndexWriter(core);\n            }\n          }\n          if (successfulInstall) {\n            if (isFullCopyNeeded) {\n              // let the system know we are changing dir's and the old one\n              // may be closed\n              if (indexDir != null) {\n                LOG.info(\"removing old index directory \" + indexDir);\n                core.getDirectoryFactory().doneWithDirectory(indexDir);\n                core.getDirectoryFactory().remove(indexDir);\n              }\n            }\n            \n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir =  false;\n          } else {\n            solrCore.getUpdateHandler().getSolrCoreState().closeIndexWriter(core, true);\n            try {\n              successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n            } finally {\n              solrCore.getUpdateHandler().getSolrCoreState().openIndexWriter(core);\n            }\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n\n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            if (indexDir != null) {\n              LOG.info(\"removing old index directory \" + indexDir);\n              core.getDirectoryFactory().doneWithDirectory(indexDir);\n              core.getDirectoryFactory().remove(indexDir);\n            }\n          }\n          if (isFullCopyNeeded) {\n            solrCore.getUpdateHandler().newIndexWriter(isFullCopyNeeded);\n          }\n          \n          openNewSearcherAndUpdateCommitPoint(isFullCopyNeeded);\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      }\n    } finally {\n      try {\n        if (!successfulInstall) {\n          logReplicationTimeAndConfFiles(null, successfulInstall);\n        }\n        filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n        replicationStartTime = 0;\n        dirFileFetcher = null;\n        localFileFetcher = null;\n        if (fsyncService != null && !fsyncService.isShutdown()) fsyncService\n            .shutdownNow();\n        fsyncService = null;\n        stop = false;\n        fsyncException = null;\n      } finally {\n        if (deleteTmpIdxDir && tmpIndexDir != null) {\n          try {\n            core.getDirectoryFactory().doneWithDirectory(tmpIndexDir);\n            core.getDirectoryFactory().remove(tmpIndexDir);\n          } catch (IOException e) {\n            SolrException.log(LOG, \"Error removing directory \" + tmpIndexDir, e);\n          }\n        }\n        \n        if (tmpIndexDir != null) {\n          core.getDirectoryFactory().release(tmpIndexDir);\n        }\n        \n        if (indexDir != null) {\n          core.getDirectoryFactory().release(indexDir);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(final SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    Directory tmpIndexDir = null;\n    String tmpIndex = null;\n    Directory indexDir = null;\n    String indexDirPath = null;\n    boolean deleteTmpIdxDir = true;\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      IndexCommit commit;\n      RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n      try {\n        searcherRefCounted = core.getNewestSearcher(false);\n        if (searcherRefCounted == null) {\n          SolrException.log(LOG, \"No open searcher found - fetch aborted\");\n          return false;\n        }\n        commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n      } finally {\n        if (searcherRefCounted != null)\n          searcherRefCounted.decref();\n      }\n      \n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper\n          .getCommitTimestamp(commit) >= latestVersion\n          || commit.getGeneration() >= latestGeneration || forceReplication;\n\n      String tmpIdxDirName = \"index.\" + new SimpleDateFormat(SnapShooter.DATE_FMT, Locale.ROOT).format(new Date());\n      tmpIndex = createTempindexDir(core, tmpIdxDirName);\n\n      tmpIndexDir = core.getDirectoryFactory().get(tmpIndex, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n      \n      // cindex dir...\n      indexDirPath = core.getIndexDir();\n      indexDir = core.getDirectoryFactory().get(indexDirPath, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n\n      try {\n        \n        if (isIndexStale(indexDir)) {\n          isFullCopyNeeded = true;\n        }\n        LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n        successfulInstall = false;\n        \n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir  =  false;\n          } else {\n            successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            if (isFullCopyNeeded) {\n              // let the system know we are changing dir's and the old one\n              // may be closed\n              if (indexDir != null) {\n                LOG.info(\"removing old index directory \" + indexDir);\n                core.getDirectoryFactory().doneWithDirectory(indexDir);\n                core.getDirectoryFactory().remove(indexDir);\n              }\n            }\n            \n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir =  false;\n          } else {\n            successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n\n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            if (indexDir != null) {\n              LOG.info(\"removing old index directory \" + indexDir);\n              core.getDirectoryFactory().doneWithDirectory(indexDir);\n              core.getDirectoryFactory().remove(indexDir);\n            }\n          }\n          openNewWriterAndSearcher(isFullCopyNeeded);\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      }\n    } finally {\n      try {\n        if (!successfulInstall) {\n          logReplicationTimeAndConfFiles(null, successfulInstall);\n        }\n        filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n        replicationStartTime = 0;\n        dirFileFetcher = null;\n        localFileFetcher = null;\n        if (fsyncService != null && !fsyncService.isShutdown()) fsyncService\n            .shutdownNow();\n        fsyncService = null;\n        stop = false;\n        fsyncException = null;\n      } finally {\n        if (deleteTmpIdxDir && tmpIndexDir != null) {\n          try {\n            core.getDirectoryFactory().doneWithDirectory(tmpIndexDir);\n            core.getDirectoryFactory().remove(tmpIndexDir);\n          } catch (IOException e) {\n            SolrException.log(LOG, \"Error removing directory \" + tmpIndexDir, e);\n          }\n        }\n        \n        if (tmpIndexDir != null) {\n          core.getDirectoryFactory().release(tmpIndexDir);\n        }\n        \n        if (indexDir != null) {\n          core.getDirectoryFactory().release(indexDir);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"190779ba7de3fda15afd1bbafbc383720a4b0966","date":1384747256,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(final SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    Directory tmpIndexDir = null;\n    String tmpIndex = null;\n    Directory indexDir = null;\n    String indexDirPath = null;\n    boolean deleteTmpIdxDir = true;\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      // TODO: make sure that getLatestCommit only returns commit points for the main index (i.e. no side-car indexes)\n      IndexCommit commit = core.getDeletionPolicy().getLatestCommit();\n      if (commit == null) {\n        // Presumably the IndexWriter hasn't been opened yet, and hence the deletion policy hasn't been updated with commit points\n        RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n        try {\n          searcherRefCounted = core.getNewestSearcher(false);\n          if (searcherRefCounted == null) {\n            LOG.warn(\"No open searcher found - fetch aborted\");\n            return false;\n          }\n          commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n        } finally {\n          if (searcherRefCounted != null)\n            searcherRefCounted.decref();\n        }\n      }\n\n\n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generation of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index directory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper\n          .getCommitTimestamp(commit) >= latestVersion\n          || commit.getGeneration() >= latestGeneration || forceReplication;\n\n      String tmpIdxDirName = \"index.\" + new SimpleDateFormat(SnapShooter.DATE_FMT, Locale.ROOT).format(new Date());\n      tmpIndex = createTempindexDir(core, tmpIdxDirName);\n\n      tmpIndexDir = core.getDirectoryFactory().get(tmpIndex, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n      \n      // cindex dir...\n      indexDirPath = core.getIndexDir();\n      indexDir = core.getDirectoryFactory().get(indexDirPath, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n\n      try {\n        \n        if (isIndexStale(indexDir)) {\n          isFullCopyNeeded = true;\n        }\n        \n        if (!isFullCopyNeeded) {\n          // rollback - and do it before we download any files\n          // so we don't remove files we thought we didn't need\n          // to download later\n          solrCore.getUpdateHandler().getSolrCoreState()\n          .closeIndexWriter(core, true);\n        }\n        try {\n          LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\"\n              + isFullCopyNeeded);\n          successfulInstall = false;\n          \n          downloadIndexFiles(isFullCopyNeeded, indexDir, tmpIndexDir,\n              latestGeneration);\n          LOG.info(\"Total time taken for download : \"\n              + ((System.currentTimeMillis() - replicationStartTime) / 1000)\n              + \" secs\");\n          Collection<Map<String,Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n          if (!modifiedConfFiles.isEmpty()) {\n            downloadConfFiles(confFilesToDownload, latestGeneration);\n            if (isFullCopyNeeded) {\n              successfulInstall = modifyIndexProps(tmpIdxDirName);\n              deleteTmpIdxDir = false;\n            } else {\n              successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n            }\n            if (successfulInstall) {\n              if (isFullCopyNeeded) {\n                // let the system know we are changing dir's and the old one\n                // may be closed\n                if (indexDir != null) {\n                  LOG.info(\"removing old index directory \" + indexDir);\n                  core.getDirectoryFactory().doneWithDirectory(indexDir);\n                  core.getDirectoryFactory().remove(indexDir);\n                }\n              }\n              \n              LOG.info(\"Configuration files are modified, core will be reloaded\");\n              logReplicationTimeAndConfFiles(modifiedConfFiles,\n                  successfulInstall);// write to a file time of replication and\n                                     // conf files.\n              reloadCore();\n            }\n          } else {\n            terminateAndWaitFsyncService();\n            if (isFullCopyNeeded) {\n              successfulInstall = modifyIndexProps(tmpIdxDirName);\n              deleteTmpIdxDir = false;\n            } else {\n              successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n            }\n            if (successfulInstall) {\n              logReplicationTimeAndConfFiles(modifiedConfFiles,\n                  successfulInstall);\n            }\n          }\n        } finally {\n          if (!isFullCopyNeeded) {\n            solrCore.getUpdateHandler().getSolrCoreState().openIndexWriter(core);\n          }\n        }\n\n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            if (indexDir != null) {\n              LOG.info(\"removing old index directory \" + indexDir);\n              core.getDirectoryFactory().doneWithDirectory(indexDir);\n              core.getDirectoryFactory().remove(indexDir);\n            }\n          }\n          if (isFullCopyNeeded) {\n            solrCore.getUpdateHandler().newIndexWriter(isFullCopyNeeded);\n          }\n          \n          openNewSearcherAndUpdateCommitPoint(isFullCopyNeeded);\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      }\n    } finally {\n      try {\n        if (!successfulInstall) {\n          logReplicationTimeAndConfFiles(null, successfulInstall);\n        }\n        filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n        replicationStartTime = 0;\n        dirFileFetcher = null;\n        localFileFetcher = null;\n        if (fsyncService != null && !fsyncService.isShutdown()) fsyncService\n            .shutdownNow();\n        fsyncService = null;\n        stop = false;\n        fsyncException = null;\n      } finally {\n        if (deleteTmpIdxDir && tmpIndexDir != null) {\n          try {\n            core.getDirectoryFactory().doneWithDirectory(tmpIndexDir);\n            core.getDirectoryFactory().remove(tmpIndexDir);\n          } catch (IOException e) {\n            SolrException.log(LOG, \"Error removing directory \" + tmpIndexDir, e);\n          }\n        }\n        \n        if (tmpIndexDir != null) {\n          core.getDirectoryFactory().release(tmpIndexDir);\n        }\n        \n        if (indexDir != null) {\n          core.getDirectoryFactory().release(indexDir);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(final SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    Directory tmpIndexDir = null;\n    String tmpIndex = null;\n    Directory indexDir = null;\n    String indexDirPath = null;\n    boolean deleteTmpIdxDir = true;\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      // TODO: make sure that getLatestCommit only returns commit points for the main index (i.e. no side-car indexes)\n      IndexCommit commit = core.getDeletionPolicy().getLatestCommit();\n      if (commit == null) {\n        // Presumably the IndexWriter hasn't been opened yet, and hence the deletion policy hasn't been updated with commit points\n        RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n        try {\n          searcherRefCounted = core.getNewestSearcher(false);\n          if (searcherRefCounted == null) {\n            LOG.warn(\"No open searcher found - fetch aborted\");\n            return false;\n          }\n          commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n        } finally {\n          if (searcherRefCounted != null)\n            searcherRefCounted.decref();\n        }\n      }\n\n\n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper\n          .getCommitTimestamp(commit) >= latestVersion\n          || commit.getGeneration() >= latestGeneration || forceReplication;\n\n      String tmpIdxDirName = \"index.\" + new SimpleDateFormat(SnapShooter.DATE_FMT, Locale.ROOT).format(new Date());\n      tmpIndex = createTempindexDir(core, tmpIdxDirName);\n\n      tmpIndexDir = core.getDirectoryFactory().get(tmpIndex, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n      \n      // cindex dir...\n      indexDirPath = core.getIndexDir();\n      indexDir = core.getDirectoryFactory().get(indexDirPath, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n\n      try {\n        \n        if (isIndexStale(indexDir)) {\n          isFullCopyNeeded = true;\n        }\n        LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n        successfulInstall = false;\n        \n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir  =  false;\n          } else {\n            solrCore.getUpdateHandler().getSolrCoreState()\n                .closeIndexWriter(core, true);\n            try {\n              successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n            } finally {\n              solrCore.getUpdateHandler().getSolrCoreState()\n                  .openIndexWriter(core);\n            }\n          }\n          if (successfulInstall) {\n            if (isFullCopyNeeded) {\n              // let the system know we are changing dir's and the old one\n              // may be closed\n              if (indexDir != null) {\n                LOG.info(\"removing old index directory \" + indexDir);\n                core.getDirectoryFactory().doneWithDirectory(indexDir);\n                core.getDirectoryFactory().remove(indexDir);\n              }\n            }\n            \n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir =  false;\n          } else {\n            solrCore.getUpdateHandler().getSolrCoreState().closeIndexWriter(core, true);\n            try {\n              successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n            } finally {\n              solrCore.getUpdateHandler().getSolrCoreState().openIndexWriter(core);\n            }\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n\n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            if (indexDir != null) {\n              LOG.info(\"removing old index directory \" + indexDir);\n              core.getDirectoryFactory().doneWithDirectory(indexDir);\n              core.getDirectoryFactory().remove(indexDir);\n            }\n          }\n          if (isFullCopyNeeded) {\n            solrCore.getUpdateHandler().newIndexWriter(isFullCopyNeeded);\n          }\n          \n          openNewSearcherAndUpdateCommitPoint(isFullCopyNeeded);\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      }\n    } finally {\n      try {\n        if (!successfulInstall) {\n          logReplicationTimeAndConfFiles(null, successfulInstall);\n        }\n        filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n        replicationStartTime = 0;\n        dirFileFetcher = null;\n        localFileFetcher = null;\n        if (fsyncService != null && !fsyncService.isShutdown()) fsyncService\n            .shutdownNow();\n        fsyncService = null;\n        stop = false;\n        fsyncException = null;\n      } finally {\n        if (deleteTmpIdxDir && tmpIndexDir != null) {\n          try {\n            core.getDirectoryFactory().doneWithDirectory(tmpIndexDir);\n            core.getDirectoryFactory().remove(tmpIndexDir);\n          } catch (IOException e) {\n            SolrException.log(LOG, \"Error removing directory \" + tmpIndexDir, e);\n          }\n        }\n        \n        if (tmpIndexDir != null) {\n          core.getDirectoryFactory().release(tmpIndexDir);\n        }\n        \n        if (indexDir != null) {\n          core.getDirectoryFactory().release(indexDir);\n        }\n      }\n    }\n  }\n\n","bugFix":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f","d9405f486872f1e416304dfe389741f4ee2f8a4d","c01638f4dd94981c1d3d52c4f7991246a5a24aba","d8a3067239133ceb0117bc3d48356169cf03894f","058801f8673d53a5abac8088204860ec29a40f0d"],"bugIntro":["6c94d2661bc1c14426980ec7882e951fdcff08d0","b1615f6fc540ecd5dea7b03d2bac9a18bba69d5c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b1615f6fc540ecd5dea7b03d2bac9a18bba69d5c","date":1385048407,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(final SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    Directory tmpIndexDir = null;\n    String tmpIndex = null;\n    Directory indexDir = null;\n    String indexDirPath = null;\n    boolean deleteTmpIdxDir = true;\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      // TODO: make sure that getLatestCommit only returns commit points for the main index (i.e. no side-car indexes)\n      IndexCommit commit = core.getDeletionPolicy().getLatestCommit();\n      if (commit == null) {\n        // Presumably the IndexWriter hasn't been opened yet, and hence the deletion policy hasn't been updated with commit points\n        RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n        try {\n          searcherRefCounted = core.getNewestSearcher(false);\n          if (searcherRefCounted == null) {\n            LOG.warn(\"No open searcher found - fetch aborted\");\n            return false;\n          }\n          commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n        } finally {\n          if (searcherRefCounted != null)\n            searcherRefCounted.decref();\n        }\n      }\n\n\n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generation of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index directory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper\n          .getCommitTimestamp(commit) >= latestVersion\n          || commit.getGeneration() >= latestGeneration || forceReplication;\n\n      String tmpIdxDirName = \"index.\" + new SimpleDateFormat(SnapShooter.DATE_FMT, Locale.ROOT).format(new Date());\n      tmpIndex = createTempindexDir(core, tmpIdxDirName);\n\n      tmpIndexDir = core.getDirectoryFactory().get(tmpIndex, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n      \n      // cindex dir...\n      indexDirPath = core.getIndexDir();\n      indexDir = core.getDirectoryFactory().get(indexDirPath, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n\n      try {\n        \n        if (isIndexStale(indexDir)) {\n          isFullCopyNeeded = true;\n        }\n        \n        if (!isFullCopyNeeded) {\n          // rollback - and do it before we download any files\n          // so we don't remove files we thought we didn't need\n          // to download later\n          solrCore.getUpdateHandler().getSolrCoreState()\n          .closeIndexWriter(core, true);\n        }\n        \n        boolean reloadCore = false;\n        \n        try {\n          LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\"\n              + isFullCopyNeeded);\n          successfulInstall = false;\n          \n          downloadIndexFiles(isFullCopyNeeded, indexDir, tmpIndexDir,\n              latestGeneration);\n          LOG.info(\"Total time taken for download : \"\n              + ((System.currentTimeMillis() - replicationStartTime) / 1000)\n              + \" secs\");\n          Collection<Map<String,Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n          if (!modifiedConfFiles.isEmpty()) {\n            downloadConfFiles(confFilesToDownload, latestGeneration);\n            if (isFullCopyNeeded) {\n              successfulInstall = modifyIndexProps(tmpIdxDirName);\n              deleteTmpIdxDir = false;\n            } else {\n              successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n            }\n            if (successfulInstall) {\n              if (isFullCopyNeeded) {\n                // let the system know we are changing dir's and the old one\n                // may be closed\n                if (indexDir != null) {\n                  LOG.info(\"removing old index directory \" + indexDir);\n                  core.getDirectoryFactory().doneWithDirectory(indexDir);\n                  core.getDirectoryFactory().remove(indexDir);\n                }\n              }\n              \n              LOG.info(\"Configuration files are modified, core will be reloaded\");\n              logReplicationTimeAndConfFiles(modifiedConfFiles,\n                  successfulInstall);// write to a file time of replication and\n                                     // conf files.\n              reloadCore = true;\n            }\n          } else {\n            terminateAndWaitFsyncService();\n            if (isFullCopyNeeded) {\n              successfulInstall = modifyIndexProps(tmpIdxDirName);\n              deleteTmpIdxDir = false;\n            } else {\n              successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n            }\n            if (successfulInstall) {\n              logReplicationTimeAndConfFiles(modifiedConfFiles,\n                  successfulInstall);\n            }\n          }\n        } finally {\n          if (!isFullCopyNeeded) {\n            solrCore.getUpdateHandler().getSolrCoreState().openIndexWriter(core);\n          }\n        }\n        \n        // we must reload the core after we open the IW back up\n        if (reloadCore) {\n          reloadCore();\n        }\n\n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            if (indexDir != null) {\n              LOG.info(\"removing old index directory \" + indexDir);\n              core.getDirectoryFactory().doneWithDirectory(indexDir);\n              core.getDirectoryFactory().remove(indexDir);\n            }\n          }\n          if (isFullCopyNeeded) {\n            solrCore.getUpdateHandler().newIndexWriter(isFullCopyNeeded);\n          }\n          \n          openNewSearcherAndUpdateCommitPoint(isFullCopyNeeded);\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      }\n    } finally {\n      try {\n        if (!successfulInstall) {\n          logReplicationTimeAndConfFiles(null, successfulInstall);\n        }\n        filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n        replicationStartTime = 0;\n        dirFileFetcher = null;\n        localFileFetcher = null;\n        if (fsyncService != null && !fsyncService.isShutdown()) fsyncService\n            .shutdownNow();\n        fsyncService = null;\n        stop = false;\n        fsyncException = null;\n      } finally {\n        if (deleteTmpIdxDir && tmpIndexDir != null) {\n          try {\n            core.getDirectoryFactory().doneWithDirectory(tmpIndexDir);\n            core.getDirectoryFactory().remove(tmpIndexDir);\n          } catch (IOException e) {\n            SolrException.log(LOG, \"Error removing directory \" + tmpIndexDir, e);\n          }\n        }\n        \n        if (tmpIndexDir != null) {\n          core.getDirectoryFactory().release(tmpIndexDir);\n        }\n        \n        if (indexDir != null) {\n          core.getDirectoryFactory().release(indexDir);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(final SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    Directory tmpIndexDir = null;\n    String tmpIndex = null;\n    Directory indexDir = null;\n    String indexDirPath = null;\n    boolean deleteTmpIdxDir = true;\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      // TODO: make sure that getLatestCommit only returns commit points for the main index (i.e. no side-car indexes)\n      IndexCommit commit = core.getDeletionPolicy().getLatestCommit();\n      if (commit == null) {\n        // Presumably the IndexWriter hasn't been opened yet, and hence the deletion policy hasn't been updated with commit points\n        RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n        try {\n          searcherRefCounted = core.getNewestSearcher(false);\n          if (searcherRefCounted == null) {\n            LOG.warn(\"No open searcher found - fetch aborted\");\n            return false;\n          }\n          commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n        } finally {\n          if (searcherRefCounted != null)\n            searcherRefCounted.decref();\n        }\n      }\n\n\n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generation of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index directory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper\n          .getCommitTimestamp(commit) >= latestVersion\n          || commit.getGeneration() >= latestGeneration || forceReplication;\n\n      String tmpIdxDirName = \"index.\" + new SimpleDateFormat(SnapShooter.DATE_FMT, Locale.ROOT).format(new Date());\n      tmpIndex = createTempindexDir(core, tmpIdxDirName);\n\n      tmpIndexDir = core.getDirectoryFactory().get(tmpIndex, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n      \n      // cindex dir...\n      indexDirPath = core.getIndexDir();\n      indexDir = core.getDirectoryFactory().get(indexDirPath, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n\n      try {\n        \n        if (isIndexStale(indexDir)) {\n          isFullCopyNeeded = true;\n        }\n        \n        if (!isFullCopyNeeded) {\n          // rollback - and do it before we download any files\n          // so we don't remove files we thought we didn't need\n          // to download later\n          solrCore.getUpdateHandler().getSolrCoreState()\n          .closeIndexWriter(core, true);\n        }\n        try {\n          LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\"\n              + isFullCopyNeeded);\n          successfulInstall = false;\n          \n          downloadIndexFiles(isFullCopyNeeded, indexDir, tmpIndexDir,\n              latestGeneration);\n          LOG.info(\"Total time taken for download : \"\n              + ((System.currentTimeMillis() - replicationStartTime) / 1000)\n              + \" secs\");\n          Collection<Map<String,Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n          if (!modifiedConfFiles.isEmpty()) {\n            downloadConfFiles(confFilesToDownload, latestGeneration);\n            if (isFullCopyNeeded) {\n              successfulInstall = modifyIndexProps(tmpIdxDirName);\n              deleteTmpIdxDir = false;\n            } else {\n              successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n            }\n            if (successfulInstall) {\n              if (isFullCopyNeeded) {\n                // let the system know we are changing dir's and the old one\n                // may be closed\n                if (indexDir != null) {\n                  LOG.info(\"removing old index directory \" + indexDir);\n                  core.getDirectoryFactory().doneWithDirectory(indexDir);\n                  core.getDirectoryFactory().remove(indexDir);\n                }\n              }\n              \n              LOG.info(\"Configuration files are modified, core will be reloaded\");\n              logReplicationTimeAndConfFiles(modifiedConfFiles,\n                  successfulInstall);// write to a file time of replication and\n                                     // conf files.\n              reloadCore();\n            }\n          } else {\n            terminateAndWaitFsyncService();\n            if (isFullCopyNeeded) {\n              successfulInstall = modifyIndexProps(tmpIdxDirName);\n              deleteTmpIdxDir = false;\n            } else {\n              successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n            }\n            if (successfulInstall) {\n              logReplicationTimeAndConfFiles(modifiedConfFiles,\n                  successfulInstall);\n            }\n          }\n        } finally {\n          if (!isFullCopyNeeded) {\n            solrCore.getUpdateHandler().getSolrCoreState().openIndexWriter(core);\n          }\n        }\n\n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            if (indexDir != null) {\n              LOG.info(\"removing old index directory \" + indexDir);\n              core.getDirectoryFactory().doneWithDirectory(indexDir);\n              core.getDirectoryFactory().remove(indexDir);\n            }\n          }\n          if (isFullCopyNeeded) {\n            solrCore.getUpdateHandler().newIndexWriter(isFullCopyNeeded);\n          }\n          \n          openNewSearcherAndUpdateCommitPoint(isFullCopyNeeded);\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      }\n    } finally {\n      try {\n        if (!successfulInstall) {\n          logReplicationTimeAndConfFiles(null, successfulInstall);\n        }\n        filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n        replicationStartTime = 0;\n        dirFileFetcher = null;\n        localFileFetcher = null;\n        if (fsyncService != null && !fsyncService.isShutdown()) fsyncService\n            .shutdownNow();\n        fsyncService = null;\n        stop = false;\n        fsyncException = null;\n      } finally {\n        if (deleteTmpIdxDir && tmpIndexDir != null) {\n          try {\n            core.getDirectoryFactory().doneWithDirectory(tmpIndexDir);\n            core.getDirectoryFactory().remove(tmpIndexDir);\n          } catch (IOException e) {\n            SolrException.log(LOG, \"Error removing directory \" + tmpIndexDir, e);\n          }\n        }\n        \n        if (tmpIndexDir != null) {\n          core.getDirectoryFactory().release(tmpIndexDir);\n        }\n        \n        if (indexDir != null) {\n          core.getDirectoryFactory().release(indexDir);\n        }\n      }\n    }\n  }\n\n","bugFix":["190779ba7de3fda15afd1bbafbc383720a4b0966"],"bugIntro":["6c94d2661bc1c14426980ec7882e951fdcff08d0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(final SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    Directory tmpIndexDir = null;\n    String tmpIndex = null;\n    Directory indexDir = null;\n    String indexDirPath = null;\n    boolean deleteTmpIdxDir = true;\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      // TODO: make sure that getLatestCommit only returns commit points for the main index (i.e. no side-car indexes)\n      IndexCommit commit = core.getDeletionPolicy().getLatestCommit();\n      if (commit == null) {\n        // Presumably the IndexWriter hasn't been opened yet, and hence the deletion policy hasn't been updated with commit points\n        RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n        try {\n          searcherRefCounted = core.getNewestSearcher(false);\n          if (searcherRefCounted == null) {\n            LOG.warn(\"No open searcher found - fetch aborted\");\n            return false;\n          }\n          commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n        } finally {\n          if (searcherRefCounted != null)\n            searcherRefCounted.decref();\n        }\n      }\n\n\n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generation of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index directory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper\n          .getCommitTimestamp(commit) >= latestVersion\n          || commit.getGeneration() >= latestGeneration || forceReplication;\n\n      String tmpIdxDirName = \"index.\" + new SimpleDateFormat(SnapShooter.DATE_FMT, Locale.ROOT).format(new Date());\n      tmpIndex = createTempindexDir(core, tmpIdxDirName);\n\n      tmpIndexDir = core.getDirectoryFactory().get(tmpIndex, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n      \n      // cindex dir...\n      indexDirPath = core.getIndexDir();\n      indexDir = core.getDirectoryFactory().get(indexDirPath, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n\n      try {\n        \n        if (isIndexStale(indexDir)) {\n          isFullCopyNeeded = true;\n        }\n        \n        if (!isFullCopyNeeded) {\n          // rollback - and do it before we download any files\n          // so we don't remove files we thought we didn't need\n          // to download later\n          solrCore.getUpdateHandler().getSolrCoreState()\n          .closeIndexWriter(core, true);\n        }\n        \n        boolean reloadCore = false;\n        \n        try {\n          LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\"\n              + isFullCopyNeeded);\n          successfulInstall = false;\n          \n          downloadIndexFiles(isFullCopyNeeded, indexDir, tmpIndexDir,\n              latestGeneration);\n          LOG.info(\"Total time taken for download : \"\n              + ((System.currentTimeMillis() - replicationStartTime) / 1000)\n              + \" secs\");\n          Collection<Map<String,Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n          if (!modifiedConfFiles.isEmpty()) {\n            downloadConfFiles(confFilesToDownload, latestGeneration);\n            if (isFullCopyNeeded) {\n              successfulInstall = modifyIndexProps(tmpIdxDirName);\n              deleteTmpIdxDir = false;\n            } else {\n              successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n            }\n            if (successfulInstall) {\n              if (isFullCopyNeeded) {\n                // let the system know we are changing dir's and the old one\n                // may be closed\n                if (indexDir != null) {\n                  LOG.info(\"removing old index directory \" + indexDir);\n                  core.getDirectoryFactory().doneWithDirectory(indexDir);\n                  core.getDirectoryFactory().remove(indexDir);\n                }\n              }\n              \n              LOG.info(\"Configuration files are modified, core will be reloaded\");\n              logReplicationTimeAndConfFiles(modifiedConfFiles,\n                  successfulInstall);// write to a file time of replication and\n                                     // conf files.\n              reloadCore = true;\n            }\n          } else {\n            terminateAndWaitFsyncService();\n            if (isFullCopyNeeded) {\n              successfulInstall = modifyIndexProps(tmpIdxDirName);\n              deleteTmpIdxDir = false;\n            } else {\n              successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n            }\n            if (successfulInstall) {\n              logReplicationTimeAndConfFiles(modifiedConfFiles,\n                  successfulInstall);\n            }\n          }\n        } finally {\n          if (!isFullCopyNeeded) {\n            solrCore.getUpdateHandler().getSolrCoreState().openIndexWriter(core);\n          }\n        }\n        \n        // we must reload the core after we open the IW back up\n        if (reloadCore) {\n          reloadCore();\n        }\n\n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            if (indexDir != null) {\n              LOG.info(\"removing old index directory \" + indexDir);\n              core.getDirectoryFactory().doneWithDirectory(indexDir);\n              core.getDirectoryFactory().remove(indexDir);\n            }\n          }\n          if (isFullCopyNeeded) {\n            solrCore.getUpdateHandler().newIndexWriter(isFullCopyNeeded);\n          }\n          \n          openNewSearcherAndUpdateCommitPoint(isFullCopyNeeded);\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      }\n    } finally {\n      try {\n        if (!successfulInstall) {\n          logReplicationTimeAndConfFiles(null, successfulInstall);\n        }\n        filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n        replicationStartTime = 0;\n        dirFileFetcher = null;\n        localFileFetcher = null;\n        if (fsyncService != null && !fsyncService.isShutdown()) fsyncService\n            .shutdownNow();\n        fsyncService = null;\n        stop = false;\n        fsyncException = null;\n      } finally {\n        if (deleteTmpIdxDir && tmpIndexDir != null) {\n          try {\n            core.getDirectoryFactory().doneWithDirectory(tmpIndexDir);\n            core.getDirectoryFactory().remove(tmpIndexDir);\n          } catch (IOException e) {\n            SolrException.log(LOG, \"Error removing directory \" + tmpIndexDir, e);\n          }\n        }\n        \n        if (tmpIndexDir != null) {\n          core.getDirectoryFactory().release(tmpIndexDir);\n        }\n        \n        if (indexDir != null) {\n          core.getDirectoryFactory().release(indexDir);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(final SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    Directory tmpIndexDir = null;\n    String tmpIndex = null;\n    Directory indexDir = null;\n    String indexDirPath = null;\n    boolean deleteTmpIdxDir = true;\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      // TODO: make sure that getLatestCommit only returns commit points for the main index (i.e. no side-car indexes)\n      IndexCommit commit = core.getDeletionPolicy().getLatestCommit();\n      if (commit == null) {\n        // Presumably the IndexWriter hasn't been opened yet, and hence the deletion policy hasn't been updated with commit points\n        RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n        try {\n          searcherRefCounted = core.getNewestSearcher(false);\n          if (searcherRefCounted == null) {\n            LOG.warn(\"No open searcher found - fetch aborted\");\n            return false;\n          }\n          commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n        } finally {\n          if (searcherRefCounted != null)\n            searcherRefCounted.decref();\n        }\n      }\n\n\n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generateion of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index direcory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper\n          .getCommitTimestamp(commit) >= latestVersion\n          || commit.getGeneration() >= latestGeneration || forceReplication;\n\n      String tmpIdxDirName = \"index.\" + new SimpleDateFormat(SnapShooter.DATE_FMT, Locale.ROOT).format(new Date());\n      tmpIndex = createTempindexDir(core, tmpIdxDirName);\n\n      tmpIndexDir = core.getDirectoryFactory().get(tmpIndex, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n      \n      // cindex dir...\n      indexDirPath = core.getIndexDir();\n      indexDir = core.getDirectoryFactory().get(indexDirPath, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n\n      try {\n        \n        if (isIndexStale(indexDir)) {\n          isFullCopyNeeded = true;\n        }\n        LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\" + isFullCopyNeeded);\n        successfulInstall = false;\n        \n        downloadIndexFiles(isFullCopyNeeded, tmpIndexDir, latestGeneration);\n        LOG.info(\"Total time taken for download : \" + ((System.currentTimeMillis() - replicationStartTime) / 1000) + \" secs\");\n        Collection<Map<String, Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n        if (!modifiedConfFiles.isEmpty()) {\n          downloadConfFiles(confFilesToDownload, latestGeneration);\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir  =  false;\n          } else {\n            solrCore.getUpdateHandler().getSolrCoreState()\n                .closeIndexWriter(core, true);\n            try {\n              successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n            } finally {\n              solrCore.getUpdateHandler().getSolrCoreState()\n                  .openIndexWriter(core);\n            }\n          }\n          if (successfulInstall) {\n            if (isFullCopyNeeded) {\n              // let the system know we are changing dir's and the old one\n              // may be closed\n              if (indexDir != null) {\n                LOG.info(\"removing old index directory \" + indexDir);\n                core.getDirectoryFactory().doneWithDirectory(indexDir);\n                core.getDirectoryFactory().remove(indexDir);\n              }\n            }\n            \n            LOG.info(\"Configuration files are modified, core will be reloaded\");\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);//write to a file time of replication and conf files.\n            reloadCore();\n          }\n        } else {\n          terminateAndWaitFsyncService();\n          if (isFullCopyNeeded) {\n            successfulInstall = modifyIndexProps(tmpIdxDirName);\n            deleteTmpIdxDir =  false;\n          } else {\n            solrCore.getUpdateHandler().getSolrCoreState().closeIndexWriter(core, true);\n            try {\n              successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n            } finally {\n              solrCore.getUpdateHandler().getSolrCoreState().openIndexWriter(core);\n            }\n          }\n          if (successfulInstall) {\n            logReplicationTimeAndConfFiles(modifiedConfFiles, successfulInstall);\n          }\n        }\n\n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            if (indexDir != null) {\n              LOG.info(\"removing old index directory \" + indexDir);\n              core.getDirectoryFactory().doneWithDirectory(indexDir);\n              core.getDirectoryFactory().remove(indexDir);\n            }\n          }\n          if (isFullCopyNeeded) {\n            solrCore.getUpdateHandler().newIndexWriter(isFullCopyNeeded);\n          }\n          \n          openNewSearcherAndUpdateCommitPoint(isFullCopyNeeded);\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      }\n    } finally {\n      try {\n        if (!successfulInstall) {\n          logReplicationTimeAndConfFiles(null, successfulInstall);\n        }\n        filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n        replicationStartTime = 0;\n        dirFileFetcher = null;\n        localFileFetcher = null;\n        if (fsyncService != null && !fsyncService.isShutdown()) fsyncService\n            .shutdownNow();\n        fsyncService = null;\n        stop = false;\n        fsyncException = null;\n      } finally {\n        if (deleteTmpIdxDir && tmpIndexDir != null) {\n          try {\n            core.getDirectoryFactory().doneWithDirectory(tmpIndexDir);\n            core.getDirectoryFactory().remove(tmpIndexDir);\n          } catch (IOException e) {\n            SolrException.log(LOG, \"Error removing directory \" + tmpIndexDir, e);\n          }\n        }\n        \n        if (tmpIndexDir != null) {\n          core.getDirectoryFactory().release(tmpIndexDir);\n        }\n        \n        if (indexDir != null) {\n          core.getDirectoryFactory().release(indexDir);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0fa112cb510d1bdb66c944fe9ba78679974d3c14","date":1415631115,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(final SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    Directory tmpIndexDir = null;\n    String tmpIndex = null;\n    Directory indexDir = null;\n    String indexDirPath = null;\n    boolean deleteTmpIdxDir = true;\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      // TODO: make sure that getLatestCommit only returns commit points for the main index (i.e. no side-car indexes)\n      IndexCommit commit = core.getDeletionPolicy().getLatestCommit();\n      if (commit == null) {\n        // Presumably the IndexWriter hasn't been opened yet, and hence the deletion policy hasn't been updated with commit points\n        RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n        try {\n          searcherRefCounted = core.getNewestSearcher(false);\n          if (searcherRefCounted == null) {\n            LOG.warn(\"No open searcher found - fetch aborted\");\n            return false;\n          }\n          commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n        } finally {\n          if (searcherRefCounted != null)\n            searcherRefCounted.decref();\n        }\n      }\n\n\n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generation of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index directory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper\n          .getCommitTimestamp(commit) >= latestVersion\n          || commit.getGeneration() >= latestGeneration || forceReplication;\n\n      String tmpIdxDirName = \"index.\" + new SimpleDateFormat(SnapShooter.DATE_FMT, Locale.ROOT).format(new Date());\n      tmpIndex = createTempindexDir(core, tmpIdxDirName);\n\n      tmpIndexDir = core.getDirectoryFactory().get(tmpIndex, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n      \n      // cindex dir...\n      indexDirPath = core.getIndexDir();\n      indexDir = core.getDirectoryFactory().get(indexDirPath, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n\n      try {\n        \n        if (isIndexStale(indexDir)) {\n          isFullCopyNeeded = true;\n        }\n        \n        if (!isFullCopyNeeded) {\n          // rollback - and do it before we download any files\n          // so we don't remove files we thought we didn't need\n          // to download later\n          solrCore.getUpdateHandler().getSolrCoreState()\n          .closeIndexWriter(core, true);\n        }\n        \n        boolean reloadCore = false;\n        \n        try {\n          LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\"\n              + isFullCopyNeeded);\n          successfulInstall = false;\n          \n          downloadIndexFiles(isFullCopyNeeded, indexDir, tmpIndexDir,\n              latestGeneration);\n          LOG.info(\"Total time taken for download : \"\n              + ((System.currentTimeMillis() - replicationStartTime) / 1000)\n              + \" secs\");\n          Collection<Map<String,Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n          if (!modifiedConfFiles.isEmpty()) {\n            downloadConfFiles(confFilesToDownload, latestGeneration);\n            if (isFullCopyNeeded) {\n              successfulInstall = modifyIndexProps(tmpIdxDirName);\n              deleteTmpIdxDir = false;\n            } else {\n              successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n            }\n            if (successfulInstall) {\n              if (isFullCopyNeeded) {\n                // let the system know we are changing dir's and the old one\n                // may be closed\n                if (indexDir != null) {\n                  LOG.info(\"removing old index directory \" + indexDir);\n                  core.getDirectoryFactory().doneWithDirectory(indexDir);\n                  core.getDirectoryFactory().remove(indexDir);\n                }\n              }\n              \n              LOG.info(\"Configuration files are modified, core will be reloaded\");\n              logReplicationTimeAndConfFiles(modifiedConfFiles,\n                  successfulInstall);// write to a file time of replication and\n                                     // conf files.\n              reloadCore = true;\n            }\n          } else {\n            terminateAndWaitFsyncService();\n            if (isFullCopyNeeded) {\n              successfulInstall = modifyIndexProps(tmpIdxDirName);\n              deleteTmpIdxDir = false;\n            } else {\n              successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n            }\n            if (successfulInstall) {\n              logReplicationTimeAndConfFiles(modifiedConfFiles,\n                  successfulInstall);\n            }\n          }\n        } finally {\n          if (!isFullCopyNeeded) {\n            solrCore.getUpdateHandler().getSolrCoreState().openIndexWriter(core);\n          }\n        }\n        \n        // we must reload the core after we open the IW back up\n        if (reloadCore) {\n          reloadCore();\n        }\n\n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            if (indexDir != null) {\n              LOG.info(\"removing old index directory \" + indexDir);\n              core.getDirectoryFactory().doneWithDirectory(indexDir);\n              core.getDirectoryFactory().remove(indexDir);\n            }\n          }\n          if (isFullCopyNeeded) {\n            solrCore.getUpdateHandler().newIndexWriter(isFullCopyNeeded);\n          }\n          \n          openNewSearcherAndUpdateCommitPoint(isFullCopyNeeded);\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      }\n    } finally {\n      try {\n        if (!successfulInstall) {\n          try {\n            logReplicationTimeAndConfFiles(null, successfulInstall);\n          } catch(Exception e) {\n            LOG.error(\"caught\", e);\n          }\n        }\n        filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n        replicationStartTime = 0;\n        dirFileFetcher = null;\n        localFileFetcher = null;\n        if (fsyncService != null && !fsyncService.isShutdown()) fsyncService\n            .shutdownNow();\n        fsyncService = null;\n        stop = false;\n        fsyncException = null;\n      } finally {\n        if (deleteTmpIdxDir && tmpIndexDir != null) {\n          try {\n            core.getDirectoryFactory().doneWithDirectory(tmpIndexDir);\n            core.getDirectoryFactory().remove(tmpIndexDir);\n          } catch (IOException e) {\n            SolrException.log(LOG, \"Error removing directory \" + tmpIndexDir, e);\n          }\n        }\n        \n        if (tmpIndexDir != null) {\n          core.getDirectoryFactory().release(tmpIndexDir);\n        }\n        \n        if (indexDir != null) {\n          core.getDirectoryFactory().release(indexDir);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(final SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    Directory tmpIndexDir = null;\n    String tmpIndex = null;\n    Directory indexDir = null;\n    String indexDirPath = null;\n    boolean deleteTmpIdxDir = true;\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      // TODO: make sure that getLatestCommit only returns commit points for the main index (i.e. no side-car indexes)\n      IndexCommit commit = core.getDeletionPolicy().getLatestCommit();\n      if (commit == null) {\n        // Presumably the IndexWriter hasn't been opened yet, and hence the deletion policy hasn't been updated with commit points\n        RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n        try {\n          searcherRefCounted = core.getNewestSearcher(false);\n          if (searcherRefCounted == null) {\n            LOG.warn(\"No open searcher found - fetch aborted\");\n            return false;\n          }\n          commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n        } finally {\n          if (searcherRefCounted != null)\n            searcherRefCounted.decref();\n        }\n      }\n\n\n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generation of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index directory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper\n          .getCommitTimestamp(commit) >= latestVersion\n          || commit.getGeneration() >= latestGeneration || forceReplication;\n\n      String tmpIdxDirName = \"index.\" + new SimpleDateFormat(SnapShooter.DATE_FMT, Locale.ROOT).format(new Date());\n      tmpIndex = createTempindexDir(core, tmpIdxDirName);\n\n      tmpIndexDir = core.getDirectoryFactory().get(tmpIndex, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n      \n      // cindex dir...\n      indexDirPath = core.getIndexDir();\n      indexDir = core.getDirectoryFactory().get(indexDirPath, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n\n      try {\n        \n        if (isIndexStale(indexDir)) {\n          isFullCopyNeeded = true;\n        }\n        \n        if (!isFullCopyNeeded) {\n          // rollback - and do it before we download any files\n          // so we don't remove files we thought we didn't need\n          // to download later\n          solrCore.getUpdateHandler().getSolrCoreState()\n          .closeIndexWriter(core, true);\n        }\n        \n        boolean reloadCore = false;\n        \n        try {\n          LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\"\n              + isFullCopyNeeded);\n          successfulInstall = false;\n          \n          downloadIndexFiles(isFullCopyNeeded, indexDir, tmpIndexDir,\n              latestGeneration);\n          LOG.info(\"Total time taken for download : \"\n              + ((System.currentTimeMillis() - replicationStartTime) / 1000)\n              + \" secs\");\n          Collection<Map<String,Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n          if (!modifiedConfFiles.isEmpty()) {\n            downloadConfFiles(confFilesToDownload, latestGeneration);\n            if (isFullCopyNeeded) {\n              successfulInstall = modifyIndexProps(tmpIdxDirName);\n              deleteTmpIdxDir = false;\n            } else {\n              successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n            }\n            if (successfulInstall) {\n              if (isFullCopyNeeded) {\n                // let the system know we are changing dir's and the old one\n                // may be closed\n                if (indexDir != null) {\n                  LOG.info(\"removing old index directory \" + indexDir);\n                  core.getDirectoryFactory().doneWithDirectory(indexDir);\n                  core.getDirectoryFactory().remove(indexDir);\n                }\n              }\n              \n              LOG.info(\"Configuration files are modified, core will be reloaded\");\n              logReplicationTimeAndConfFiles(modifiedConfFiles,\n                  successfulInstall);// write to a file time of replication and\n                                     // conf files.\n              reloadCore = true;\n            }\n          } else {\n            terminateAndWaitFsyncService();\n            if (isFullCopyNeeded) {\n              successfulInstall = modifyIndexProps(tmpIdxDirName);\n              deleteTmpIdxDir = false;\n            } else {\n              successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n            }\n            if (successfulInstall) {\n              logReplicationTimeAndConfFiles(modifiedConfFiles,\n                  successfulInstall);\n            }\n          }\n        } finally {\n          if (!isFullCopyNeeded) {\n            solrCore.getUpdateHandler().getSolrCoreState().openIndexWriter(core);\n          }\n        }\n        \n        // we must reload the core after we open the IW back up\n        if (reloadCore) {\n          reloadCore();\n        }\n\n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            if (indexDir != null) {\n              LOG.info(\"removing old index directory \" + indexDir);\n              core.getDirectoryFactory().doneWithDirectory(indexDir);\n              core.getDirectoryFactory().remove(indexDir);\n            }\n          }\n          if (isFullCopyNeeded) {\n            solrCore.getUpdateHandler().newIndexWriter(isFullCopyNeeded);\n          }\n          \n          openNewSearcherAndUpdateCommitPoint(isFullCopyNeeded);\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      }\n    } finally {\n      try {\n        if (!successfulInstall) {\n          logReplicationTimeAndConfFiles(null, successfulInstall);\n        }\n        filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n        replicationStartTime = 0;\n        dirFileFetcher = null;\n        localFileFetcher = null;\n        if (fsyncService != null && !fsyncService.isShutdown()) fsyncService\n            .shutdownNow();\n        fsyncService = null;\n        stop = false;\n        fsyncException = null;\n      } finally {\n        if (deleteTmpIdxDir && tmpIndexDir != null) {\n          try {\n            core.getDirectoryFactory().doneWithDirectory(tmpIndexDir);\n            core.getDirectoryFactory().remove(tmpIndexDir);\n          } catch (IOException e) {\n            SolrException.log(LOG, \"Error removing directory \" + tmpIndexDir, e);\n          }\n        }\n        \n        if (tmpIndexDir != null) {\n          core.getDirectoryFactory().release(tmpIndexDir);\n        }\n        \n        if (indexDir != null) {\n          core.getDirectoryFactory().release(indexDir);\n        }\n      }\n    }\n  }\n\n","bugFix":["d9405f486872f1e416304dfe389741f4ee2f8a4d"],"bugIntro":["6c94d2661bc1c14426980ec7882e951fdcff08d0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1b7910b51406c081814c946331386da674f26aa5","date":1421770778,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(final SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    Directory tmpIndexDir = null;\n    String tmpIndex = null;\n    Directory indexDir = null;\n    String indexDirPath = null;\n    boolean deleteTmpIdxDir = true;\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      // TODO: make sure that getLatestCommit only returns commit points for the main index (i.e. no side-car indexes)\n      IndexCommit commit = core.getDeletionPolicy().getLatestCommit();\n      if (commit == null) {\n        // Presumably the IndexWriter hasn't been opened yet, and hence the deletion policy hasn't been updated with commit points\n        RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n        try {\n          searcherRefCounted = core.getNewestSearcher(false);\n          if (searcherRefCounted == null) {\n            LOG.warn(\"No open searcher found - fetch aborted\");\n            return false;\n          }\n          commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n        } finally {\n          if (searcherRefCounted != null)\n            searcherRefCounted.decref();\n        }\n      }\n\n\n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generation of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index directory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper\n          .getCommitTimestamp(commit) >= latestVersion\n          || commit.getGeneration() >= latestGeneration || forceReplication;\n\n      String tmpIdxDirName = \"index.\" + new SimpleDateFormat(SnapShooter.DATE_FMT, Locale.ROOT).format(new Date());\n      tmpIndex = createTempindexDir(core, tmpIdxDirName);\n\n      tmpIndexDir = core.getDirectoryFactory().get(tmpIndex, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n      \n      // cindex dir...\n      indexDirPath = core.getIndexDir();\n      indexDir = core.getDirectoryFactory().get(indexDirPath, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n\n      try {\n        \n        if (isIndexStale(indexDir)) {\n          isFullCopyNeeded = true;\n        }\n        \n        if (!isFullCopyNeeded) {\n          // a searcher might be using some flushed but committed segments\n          // because of soft commits (which open a searcher on IW's data)\n          // so we need to close the existing searcher on the last commit\n          // and wait until we are able to clean up all unused lucene files\n          if (solrCore.getCoreDescriptor().getCoreContainer().isZooKeeperAware()) {\n            solrCore.closeSearcher();\n          }\n\n          // rollback and reopen index writer and wait until all unused files\n          // are successfully deleted\n          solrCore.getUpdateHandler().newIndexWriter(true);\n          RefCounted<IndexWriter> writer = solrCore.getUpdateHandler().getSolrCoreState().getIndexWriter(null);\n          try {\n            IndexWriter indexWriter = writer.get();\n            int c = 0;\n            indexWriter.deleteUnusedFiles();\n            while (hasUnusedFiles(indexDir, commit)) {\n              indexWriter.deleteUnusedFiles();\n              LOG.info(\"Sleeping for 1000ms to wait for unused lucene index files to be delete-able\");\n              Thread.sleep(1000);\n              c++;\n              if (c >= 30)  {\n                LOG.warn(\"SnapPuller unable to cleanup unused lucene index files so we must do a full copy instead\");\n                isFullCopyNeeded = true;\n                break;\n              }\n            }\n            if (c > 0)  {\n              LOG.info(\"SnapPuller slept for \" + (c * 1000) + \"ms for unused lucene index files to be delete-able\");\n            }\n          } finally {\n            writer.decref();\n          }\n          solrCore.getUpdateHandler().getSolrCoreState().closeIndexWriter(core, true);\n        }\n        boolean reloadCore = false;\n        \n        try {\n          LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\"\n              + isFullCopyNeeded);\n          successfulInstall = false;\n          \n          downloadIndexFiles(isFullCopyNeeded, indexDir, tmpIndexDir,\n              latestGeneration);\n          LOG.info(\"Total time taken for download : \"\n              + ((System.currentTimeMillis() - replicationStartTime) / 1000)\n              + \" secs\");\n          Collection<Map<String,Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n          if (!modifiedConfFiles.isEmpty()) {\n            downloadConfFiles(confFilesToDownload, latestGeneration);\n            if (isFullCopyNeeded) {\n              successfulInstall = modifyIndexProps(tmpIdxDirName);\n              deleteTmpIdxDir = false;\n            } else {\n              successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n            }\n            if (successfulInstall) {\n              if (isFullCopyNeeded) {\n                // let the system know we are changing dir's and the old one\n                // may be closed\n                if (indexDir != null) {\n                  LOG.info(\"removing old index directory \" + indexDir);\n                  core.getDirectoryFactory().doneWithDirectory(indexDir);\n                  core.getDirectoryFactory().remove(indexDir);\n                }\n              }\n              \n              LOG.info(\"Configuration files are modified, core will be reloaded\");\n              logReplicationTimeAndConfFiles(modifiedConfFiles,\n                  successfulInstall);// write to a file time of replication and\n                                     // conf files.\n              reloadCore = true;\n            }\n          } else {\n            terminateAndWaitFsyncService();\n            if (isFullCopyNeeded) {\n              successfulInstall = modifyIndexProps(tmpIdxDirName);\n              deleteTmpIdxDir = false;\n            } else {\n              successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n            }\n            if (successfulInstall) {\n              logReplicationTimeAndConfFiles(modifiedConfFiles,\n                  successfulInstall);\n            }\n          }\n        } finally {\n          if (!isFullCopyNeeded) {\n            solrCore.getUpdateHandler().getSolrCoreState().openIndexWriter(core);\n          }\n        }\n        \n        // we must reload the core after we open the IW back up\n        if (reloadCore) {\n          reloadCore();\n        }\n\n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            if (indexDir != null) {\n              LOG.info(\"removing old index directory \" + indexDir);\n              core.getDirectoryFactory().doneWithDirectory(indexDir);\n              core.getDirectoryFactory().remove(indexDir);\n            }\n          }\n          if (isFullCopyNeeded) {\n            solrCore.getUpdateHandler().newIndexWriter(isFullCopyNeeded);\n          }\n          \n          openNewSearcherAndUpdateCommitPoint(isFullCopyNeeded);\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      }\n    } finally {\n      try {\n        if (!successfulInstall) {\n          try {\n            logReplicationTimeAndConfFiles(null, successfulInstall);\n          } catch(Exception e) {\n            LOG.error(\"caught\", e);\n          }\n        }\n        filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n        replicationStartTime = 0;\n        dirFileFetcher = null;\n        localFileFetcher = null;\n        if (fsyncService != null && !fsyncService.isShutdown()) fsyncService\n            .shutdownNow();\n        fsyncService = null;\n        stop = false;\n        fsyncException = null;\n      } finally {\n        if (deleteTmpIdxDir && tmpIndexDir != null) {\n          try {\n            core.getDirectoryFactory().doneWithDirectory(tmpIndexDir);\n            core.getDirectoryFactory().remove(tmpIndexDir);\n          } catch (IOException e) {\n            SolrException.log(LOG, \"Error removing directory \" + tmpIndexDir, e);\n          }\n        }\n        \n        if (tmpIndexDir != null) {\n          core.getDirectoryFactory().release(tmpIndexDir);\n        }\n        \n        if (indexDir != null) {\n          core.getDirectoryFactory().release(indexDir);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(final SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    Directory tmpIndexDir = null;\n    String tmpIndex = null;\n    Directory indexDir = null;\n    String indexDirPath = null;\n    boolean deleteTmpIdxDir = true;\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      // TODO: make sure that getLatestCommit only returns commit points for the main index (i.e. no side-car indexes)\n      IndexCommit commit = core.getDeletionPolicy().getLatestCommit();\n      if (commit == null) {\n        // Presumably the IndexWriter hasn't been opened yet, and hence the deletion policy hasn't been updated with commit points\n        RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n        try {\n          searcherRefCounted = core.getNewestSearcher(false);\n          if (searcherRefCounted == null) {\n            LOG.warn(\"No open searcher found - fetch aborted\");\n            return false;\n          }\n          commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n        } finally {\n          if (searcherRefCounted != null)\n            searcherRefCounted.decref();\n        }\n      }\n\n\n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generation of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index directory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper\n          .getCommitTimestamp(commit) >= latestVersion\n          || commit.getGeneration() >= latestGeneration || forceReplication;\n\n      String tmpIdxDirName = \"index.\" + new SimpleDateFormat(SnapShooter.DATE_FMT, Locale.ROOT).format(new Date());\n      tmpIndex = createTempindexDir(core, tmpIdxDirName);\n\n      tmpIndexDir = core.getDirectoryFactory().get(tmpIndex, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n      \n      // cindex dir...\n      indexDirPath = core.getIndexDir();\n      indexDir = core.getDirectoryFactory().get(indexDirPath, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n\n      try {\n        \n        if (isIndexStale(indexDir)) {\n          isFullCopyNeeded = true;\n        }\n        \n        if (!isFullCopyNeeded) {\n          // rollback - and do it before we download any files\n          // so we don't remove files we thought we didn't need\n          // to download later\n          solrCore.getUpdateHandler().getSolrCoreState()\n          .closeIndexWriter(core, true);\n        }\n        \n        boolean reloadCore = false;\n        \n        try {\n          LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\"\n              + isFullCopyNeeded);\n          successfulInstall = false;\n          \n          downloadIndexFiles(isFullCopyNeeded, indexDir, tmpIndexDir,\n              latestGeneration);\n          LOG.info(\"Total time taken for download : \"\n              + ((System.currentTimeMillis() - replicationStartTime) / 1000)\n              + \" secs\");\n          Collection<Map<String,Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n          if (!modifiedConfFiles.isEmpty()) {\n            downloadConfFiles(confFilesToDownload, latestGeneration);\n            if (isFullCopyNeeded) {\n              successfulInstall = modifyIndexProps(tmpIdxDirName);\n              deleteTmpIdxDir = false;\n            } else {\n              successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n            }\n            if (successfulInstall) {\n              if (isFullCopyNeeded) {\n                // let the system know we are changing dir's and the old one\n                // may be closed\n                if (indexDir != null) {\n                  LOG.info(\"removing old index directory \" + indexDir);\n                  core.getDirectoryFactory().doneWithDirectory(indexDir);\n                  core.getDirectoryFactory().remove(indexDir);\n                }\n              }\n              \n              LOG.info(\"Configuration files are modified, core will be reloaded\");\n              logReplicationTimeAndConfFiles(modifiedConfFiles,\n                  successfulInstall);// write to a file time of replication and\n                                     // conf files.\n              reloadCore = true;\n            }\n          } else {\n            terminateAndWaitFsyncService();\n            if (isFullCopyNeeded) {\n              successfulInstall = modifyIndexProps(tmpIdxDirName);\n              deleteTmpIdxDir = false;\n            } else {\n              successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n            }\n            if (successfulInstall) {\n              logReplicationTimeAndConfFiles(modifiedConfFiles,\n                  successfulInstall);\n            }\n          }\n        } finally {\n          if (!isFullCopyNeeded) {\n            solrCore.getUpdateHandler().getSolrCoreState().openIndexWriter(core);\n          }\n        }\n        \n        // we must reload the core after we open the IW back up\n        if (reloadCore) {\n          reloadCore();\n        }\n\n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            if (indexDir != null) {\n              LOG.info(\"removing old index directory \" + indexDir);\n              core.getDirectoryFactory().doneWithDirectory(indexDir);\n              core.getDirectoryFactory().remove(indexDir);\n            }\n          }\n          if (isFullCopyNeeded) {\n            solrCore.getUpdateHandler().newIndexWriter(isFullCopyNeeded);\n          }\n          \n          openNewSearcherAndUpdateCommitPoint(isFullCopyNeeded);\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      }\n    } finally {\n      try {\n        if (!successfulInstall) {\n          try {\n            logReplicationTimeAndConfFiles(null, successfulInstall);\n          } catch(Exception e) {\n            LOG.error(\"caught\", e);\n          }\n        }\n        filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n        replicationStartTime = 0;\n        dirFileFetcher = null;\n        localFileFetcher = null;\n        if (fsyncService != null && !fsyncService.isShutdown()) fsyncService\n            .shutdownNow();\n        fsyncService = null;\n        stop = false;\n        fsyncException = null;\n      } finally {\n        if (deleteTmpIdxDir && tmpIndexDir != null) {\n          try {\n            core.getDirectoryFactory().doneWithDirectory(tmpIndexDir);\n            core.getDirectoryFactory().remove(tmpIndexDir);\n          } catch (IOException e) {\n            SolrException.log(LOG, \"Error removing directory \" + tmpIndexDir, e);\n          }\n        }\n        \n        if (tmpIndexDir != null) {\n          core.getDirectoryFactory().release(tmpIndexDir);\n        }\n        \n        if (indexDir != null) {\n          core.getDirectoryFactory().release(indexDir);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["6c94d2661bc1c14426980ec7882e951fdcff08d0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"dea8e36e8c36d610840396c282a5affe3f722f4e","date":1422297045,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(final SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    Directory tmpIndexDir = null;\n    String tmpIndex = null;\n    Directory indexDir = null;\n    String indexDirPath = null;\n    boolean deleteTmpIdxDir = true;\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      // TODO: make sure that getLatestCommit only returns commit points for the main index (i.e. no side-car indexes)\n      IndexCommit commit = core.getDeletionPolicy().getLatestCommit();\n      if (commit == null) {\n        // Presumably the IndexWriter hasn't been opened yet, and hence the deletion policy hasn't been updated with commit points\n        RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n        try {\n          searcherRefCounted = core.getNewestSearcher(false);\n          if (searcherRefCounted == null) {\n            LOG.warn(\"No open searcher found - fetch aborted\");\n            return false;\n          }\n          commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n        } finally {\n          if (searcherRefCounted != null)\n            searcherRefCounted.decref();\n        }\n      }\n\n\n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generation of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index directory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper\n          .getCommitTimestamp(commit) >= latestVersion\n          || commit.getGeneration() >= latestGeneration || forceReplication;\n\n      String tmpIdxDirName = \"index.\" + new SimpleDateFormat(SnapShooter.DATE_FMT, Locale.ROOT).format(new Date());\n      tmpIndex = createTempindexDir(core, tmpIdxDirName);\n\n      tmpIndexDir = core.getDirectoryFactory().get(tmpIndex, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n      \n      // cindex dir...\n      indexDirPath = core.getIndexDir();\n      indexDir = core.getDirectoryFactory().get(indexDirPath, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n\n      try {\n        \n        if (isIndexStale(indexDir)) {\n          isFullCopyNeeded = true;\n        }\n        \n        if (!isFullCopyNeeded) {\n          // a searcher might be using some flushed but committed segments\n          // because of soft commits (which open a searcher on IW's data)\n          // so we need to close the existing searcher on the last commit\n          // and wait until we are able to clean up all unused lucene files\n          if (solrCore.getCoreDescriptor().getCoreContainer().isZooKeeperAware()) {\n            solrCore.closeSearcher();\n          }\n\n          // rollback and reopen index writer and wait until all unused files\n          // are successfully deleted\n          solrCore.getUpdateHandler().newIndexWriter(true);\n          RefCounted<IndexWriter> writer = solrCore.getUpdateHandler().getSolrCoreState().getIndexWriter(null);\n          try {\n            IndexWriter indexWriter = writer.get();\n            int c = 0;\n            indexWriter.deleteUnusedFiles();\n            while (hasUnusedFiles(indexDir, commit)) {\n              indexWriter.deleteUnusedFiles();\n              LOG.info(\"Sleeping for 1000ms to wait for unused lucene index files to be delete-able\");\n              Thread.sleep(1000);\n              c++;\n              if (c >= 30)  {\n                LOG.warn(\"SnapPuller unable to cleanup unused lucene index files so we must do a full copy instead\");\n                isFullCopyNeeded = true;\n                break;\n              }\n            }\n            if (c > 0)  {\n              LOG.info(\"SnapPuller slept for \" + (c * 1000) + \"ms for unused lucene index files to be delete-able\");\n            }\n          } finally {\n            writer.decref();\n          }\n          solrCore.getUpdateHandler().getSolrCoreState().closeIndexWriter(core, true);\n        }\n        boolean reloadCore = false;\n        \n        try {\n          LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\"\n              + isFullCopyNeeded);\n          successfulInstall = false;\n          \n          downloadIndexFiles(isFullCopyNeeded, indexDir, tmpIndexDir,\n              latestGeneration);\n          LOG.info(\"Total time taken for download : \"\n              + ((System.currentTimeMillis() - replicationStartTime) / 1000)\n              + \" secs\");\n          Collection<Map<String,Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n          if (!modifiedConfFiles.isEmpty()) {\n            downloadConfFiles(confFilesToDownload, latestGeneration);\n            if (isFullCopyNeeded) {\n              successfulInstall = modifyIndexProps(tmpIdxDirName);\n              deleteTmpIdxDir = false;\n            } else {\n              successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n            }\n            if (successfulInstall) {\n              if (isFullCopyNeeded) {\n                // let the system know we are changing dir's and the old one\n                // may be closed\n                if (indexDir != null) {\n                  LOG.info(\"removing old index directory \" + indexDir);\n                  core.getDirectoryFactory().doneWithDirectory(indexDir);\n                  core.getDirectoryFactory().remove(indexDir);\n                }\n              }\n              \n              LOG.info(\"Configuration files are modified, core will be reloaded\");\n              logReplicationTimeAndConfFiles(modifiedConfFiles,\n                  successfulInstall);// write to a file time of replication and\n                                     // conf files.\n              reloadCore = true;\n            }\n          } else {\n            terminateAndWaitFsyncService();\n            if (isFullCopyNeeded) {\n              successfulInstall = modifyIndexProps(tmpIdxDirName);\n              deleteTmpIdxDir = false;\n            } else {\n              successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n            }\n            if (successfulInstall) {\n              logReplicationTimeAndConfFiles(modifiedConfFiles,\n                  successfulInstall);\n            }\n          }\n        } finally {\n          if (!isFullCopyNeeded) {\n            solrCore.getUpdateHandler().getSolrCoreState().openIndexWriter(core);\n          }\n        }\n        \n        // we must reload the core after we open the IW back up\n        if (reloadCore) {\n          reloadCore();\n        }\n\n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            if (indexDir != null) {\n              LOG.info(\"removing old index directory \" + indexDir);\n              core.getDirectoryFactory().doneWithDirectory(indexDir);\n              core.getDirectoryFactory().remove(indexDir);\n            }\n          }\n          if (isFullCopyNeeded) {\n            solrCore.getUpdateHandler().newIndexWriter(isFullCopyNeeded);\n          }\n          \n          openNewSearcherAndUpdateCommitPoint();\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      }\n    } finally {\n      try {\n        if (!successfulInstall) {\n          try {\n            logReplicationTimeAndConfFiles(null, successfulInstall);\n          } catch(Exception e) {\n            LOG.error(\"caught\", e);\n          }\n        }\n        filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n        replicationStartTime = 0;\n        dirFileFetcher = null;\n        localFileFetcher = null;\n        if (fsyncService != null && !fsyncService.isShutdown()) fsyncService\n            .shutdownNow();\n        fsyncService = null;\n        stop = false;\n        fsyncException = null;\n      } finally {\n        if (deleteTmpIdxDir && tmpIndexDir != null) {\n          try {\n            core.getDirectoryFactory().doneWithDirectory(tmpIndexDir);\n            core.getDirectoryFactory().remove(tmpIndexDir);\n          } catch (IOException e) {\n            SolrException.log(LOG, \"Error removing directory \" + tmpIndexDir, e);\n          }\n        }\n        \n        if (tmpIndexDir != null) {\n          core.getDirectoryFactory().release(tmpIndexDir);\n        }\n        \n        if (indexDir != null) {\n          core.getDirectoryFactory().release(indexDir);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(final SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    Directory tmpIndexDir = null;\n    String tmpIndex = null;\n    Directory indexDir = null;\n    String indexDirPath = null;\n    boolean deleteTmpIdxDir = true;\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      // TODO: make sure that getLatestCommit only returns commit points for the main index (i.e. no side-car indexes)\n      IndexCommit commit = core.getDeletionPolicy().getLatestCommit();\n      if (commit == null) {\n        // Presumably the IndexWriter hasn't been opened yet, and hence the deletion policy hasn't been updated with commit points\n        RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n        try {\n          searcherRefCounted = core.getNewestSearcher(false);\n          if (searcherRefCounted == null) {\n            LOG.warn(\"No open searcher found - fetch aborted\");\n            return false;\n          }\n          commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n        } finally {\n          if (searcherRefCounted != null)\n            searcherRefCounted.decref();\n        }\n      }\n\n\n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generation of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index directory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper\n          .getCommitTimestamp(commit) >= latestVersion\n          || commit.getGeneration() >= latestGeneration || forceReplication;\n\n      String tmpIdxDirName = \"index.\" + new SimpleDateFormat(SnapShooter.DATE_FMT, Locale.ROOT).format(new Date());\n      tmpIndex = createTempindexDir(core, tmpIdxDirName);\n\n      tmpIndexDir = core.getDirectoryFactory().get(tmpIndex, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n      \n      // cindex dir...\n      indexDirPath = core.getIndexDir();\n      indexDir = core.getDirectoryFactory().get(indexDirPath, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n\n      try {\n        \n        if (isIndexStale(indexDir)) {\n          isFullCopyNeeded = true;\n        }\n        \n        if (!isFullCopyNeeded) {\n          // a searcher might be using some flushed but committed segments\n          // because of soft commits (which open a searcher on IW's data)\n          // so we need to close the existing searcher on the last commit\n          // and wait until we are able to clean up all unused lucene files\n          if (solrCore.getCoreDescriptor().getCoreContainer().isZooKeeperAware()) {\n            solrCore.closeSearcher();\n          }\n\n          // rollback and reopen index writer and wait until all unused files\n          // are successfully deleted\n          solrCore.getUpdateHandler().newIndexWriter(true);\n          RefCounted<IndexWriter> writer = solrCore.getUpdateHandler().getSolrCoreState().getIndexWriter(null);\n          try {\n            IndexWriter indexWriter = writer.get();\n            int c = 0;\n            indexWriter.deleteUnusedFiles();\n            while (hasUnusedFiles(indexDir, commit)) {\n              indexWriter.deleteUnusedFiles();\n              LOG.info(\"Sleeping for 1000ms to wait for unused lucene index files to be delete-able\");\n              Thread.sleep(1000);\n              c++;\n              if (c >= 30)  {\n                LOG.warn(\"SnapPuller unable to cleanup unused lucene index files so we must do a full copy instead\");\n                isFullCopyNeeded = true;\n                break;\n              }\n            }\n            if (c > 0)  {\n              LOG.info(\"SnapPuller slept for \" + (c * 1000) + \"ms for unused lucene index files to be delete-able\");\n            }\n          } finally {\n            writer.decref();\n          }\n          solrCore.getUpdateHandler().getSolrCoreState().closeIndexWriter(core, true);\n        }\n        boolean reloadCore = false;\n        \n        try {\n          LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\"\n              + isFullCopyNeeded);\n          successfulInstall = false;\n          \n          downloadIndexFiles(isFullCopyNeeded, indexDir, tmpIndexDir,\n              latestGeneration);\n          LOG.info(\"Total time taken for download : \"\n              + ((System.currentTimeMillis() - replicationStartTime) / 1000)\n              + \" secs\");\n          Collection<Map<String,Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n          if (!modifiedConfFiles.isEmpty()) {\n            downloadConfFiles(confFilesToDownload, latestGeneration);\n            if (isFullCopyNeeded) {\n              successfulInstall = modifyIndexProps(tmpIdxDirName);\n              deleteTmpIdxDir = false;\n            } else {\n              successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n            }\n            if (successfulInstall) {\n              if (isFullCopyNeeded) {\n                // let the system know we are changing dir's and the old one\n                // may be closed\n                if (indexDir != null) {\n                  LOG.info(\"removing old index directory \" + indexDir);\n                  core.getDirectoryFactory().doneWithDirectory(indexDir);\n                  core.getDirectoryFactory().remove(indexDir);\n                }\n              }\n              \n              LOG.info(\"Configuration files are modified, core will be reloaded\");\n              logReplicationTimeAndConfFiles(modifiedConfFiles,\n                  successfulInstall);// write to a file time of replication and\n                                     // conf files.\n              reloadCore = true;\n            }\n          } else {\n            terminateAndWaitFsyncService();\n            if (isFullCopyNeeded) {\n              successfulInstall = modifyIndexProps(tmpIdxDirName);\n              deleteTmpIdxDir = false;\n            } else {\n              successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n            }\n            if (successfulInstall) {\n              logReplicationTimeAndConfFiles(modifiedConfFiles,\n                  successfulInstall);\n            }\n          }\n        } finally {\n          if (!isFullCopyNeeded) {\n            solrCore.getUpdateHandler().getSolrCoreState().openIndexWriter(core);\n          }\n        }\n        \n        // we must reload the core after we open the IW back up\n        if (reloadCore) {\n          reloadCore();\n        }\n\n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            if (indexDir != null) {\n              LOG.info(\"removing old index directory \" + indexDir);\n              core.getDirectoryFactory().doneWithDirectory(indexDir);\n              core.getDirectoryFactory().remove(indexDir);\n            }\n          }\n          if (isFullCopyNeeded) {\n            solrCore.getUpdateHandler().newIndexWriter(isFullCopyNeeded);\n          }\n          \n          openNewSearcherAndUpdateCommitPoint(isFullCopyNeeded);\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      }\n    } finally {\n      try {\n        if (!successfulInstall) {\n          try {\n            logReplicationTimeAndConfFiles(null, successfulInstall);\n          } catch(Exception e) {\n            LOG.error(\"caught\", e);\n          }\n        }\n        filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n        replicationStartTime = 0;\n        dirFileFetcher = null;\n        localFileFetcher = null;\n        if (fsyncService != null && !fsyncService.isShutdown()) fsyncService\n            .shutdownNow();\n        fsyncService = null;\n        stop = false;\n        fsyncException = null;\n      } finally {\n        if (deleteTmpIdxDir && tmpIndexDir != null) {\n          try {\n            core.getDirectoryFactory().doneWithDirectory(tmpIndexDir);\n            core.getDirectoryFactory().remove(tmpIndexDir);\n          } catch (IOException e) {\n            SolrException.log(LOG, \"Error removing directory \" + tmpIndexDir, e);\n          }\n        }\n        \n        if (tmpIndexDir != null) {\n          core.getDirectoryFactory().release(tmpIndexDir);\n        }\n        \n        if (indexDir != null) {\n          core.getDirectoryFactory().release(indexDir);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["6c94d2661bc1c14426980ec7882e951fdcff08d0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9f5e2ce7174b645aee7b07eab55640cf0b28916b","date":1422438107,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(final SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    Directory tmpIndexDir = null;\n    String tmpIndex = null;\n    Directory indexDir = null;\n    String indexDirPath = null;\n    boolean deleteTmpIdxDir = true;\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      // TODO: make sure that getLatestCommit only returns commit points for the main index (i.e. no side-car indexes)\n      IndexCommit commit = core.getDeletionPolicy().getLatestCommit();\n      if (commit == null) {\n        // Presumably the IndexWriter hasn't been opened yet, and hence the deletion policy hasn't been updated with commit points\n        RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n        try {\n          searcherRefCounted = core.getNewestSearcher(false);\n          if (searcherRefCounted == null) {\n            LOG.warn(\"No open searcher found - fetch aborted\");\n            return false;\n          }\n          commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n        } finally {\n          if (searcherRefCounted != null)\n            searcherRefCounted.decref();\n        }\n      }\n\n\n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generation of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index directory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper\n          .getCommitTimestamp(commit) >= latestVersion\n          || commit.getGeneration() >= latestGeneration || forceReplication;\n\n      String tmpIdxDirName = \"index.\" + new SimpleDateFormat(SnapShooter.DATE_FMT, Locale.ROOT).format(new Date());\n      tmpIndex = createTempindexDir(core, tmpIdxDirName);\n\n      tmpIndexDir = core.getDirectoryFactory().get(tmpIndex, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n      \n      // cindex dir...\n      indexDirPath = core.getIndexDir();\n      indexDir = core.getDirectoryFactory().get(indexDirPath, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n\n      try {\n        \n        if (isIndexStale(indexDir)) {\n          isFullCopyNeeded = true;\n        }\n        \n        if (!isFullCopyNeeded) {\n          // a searcher might be using some flushed but not committed segments\n          // because of soft commits (which open a searcher on IW's data)\n          // so we need to close the existing searcher on the last commit\n          // and wait until we are able to clean up all unused lucene files\n          if (solrCore.getCoreDescriptor().getCoreContainer().isZooKeeperAware()) {\n            solrCore.closeSearcher();\n          }\n\n          // rollback and reopen index writer and wait until all unused files\n          // are successfully deleted\n          solrCore.getUpdateHandler().newIndexWriter(true);\n          RefCounted<IndexWriter> writer = solrCore.getUpdateHandler().getSolrCoreState().getIndexWriter(null);\n          try {\n            IndexWriter indexWriter = writer.get();\n            int c = 0;\n            indexWriter.deleteUnusedFiles();\n            while (hasUnusedFiles(indexDir, commit)) {\n              indexWriter.deleteUnusedFiles();\n              LOG.info(\"Sleeping for 1000ms to wait for unused lucene index files to be delete-able\");\n              Thread.sleep(1000);\n              c++;\n              if (c >= 30)  {\n                LOG.warn(\"SnapPuller unable to cleanup unused lucene index files so we must do a full copy instead\");\n                isFullCopyNeeded = true;\n                break;\n              }\n            }\n            if (c > 0)  {\n              LOG.info(\"SnapPuller slept for \" + (c * 1000) + \"ms for unused lucene index files to be delete-able\");\n            }\n          } finally {\n            writer.decref();\n          }\n          solrCore.getUpdateHandler().getSolrCoreState().closeIndexWriter(core, true);\n        }\n        boolean reloadCore = false;\n        \n        try {\n          LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\"\n              + isFullCopyNeeded);\n          successfulInstall = false;\n          \n          downloadIndexFiles(isFullCopyNeeded, indexDir, tmpIndexDir,\n              latestGeneration);\n          LOG.info(\"Total time taken for download : \"\n              + ((System.currentTimeMillis() - replicationStartTime) / 1000)\n              + \" secs\");\n          Collection<Map<String,Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n          if (!modifiedConfFiles.isEmpty()) {\n            downloadConfFiles(confFilesToDownload, latestGeneration);\n            if (isFullCopyNeeded) {\n              successfulInstall = modifyIndexProps(tmpIdxDirName);\n              deleteTmpIdxDir = false;\n            } else {\n              successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n            }\n            if (successfulInstall) {\n              if (isFullCopyNeeded) {\n                // let the system know we are changing dir's and the old one\n                // may be closed\n                if (indexDir != null) {\n                  LOG.info(\"removing old index directory \" + indexDir);\n                  core.getDirectoryFactory().doneWithDirectory(indexDir);\n                  core.getDirectoryFactory().remove(indexDir);\n                }\n              }\n              \n              LOG.info(\"Configuration files are modified, core will be reloaded\");\n              logReplicationTimeAndConfFiles(modifiedConfFiles,\n                  successfulInstall);// write to a file time of replication and\n                                     // conf files.\n              reloadCore = true;\n            }\n          } else {\n            terminateAndWaitFsyncService();\n            if (isFullCopyNeeded) {\n              successfulInstall = modifyIndexProps(tmpIdxDirName);\n              deleteTmpIdxDir = false;\n            } else {\n              successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n            }\n            if (successfulInstall) {\n              logReplicationTimeAndConfFiles(modifiedConfFiles,\n                  successfulInstall);\n            }\n          }\n        } finally {\n          if (!isFullCopyNeeded) {\n            solrCore.getUpdateHandler().getSolrCoreState().openIndexWriter(core);\n          }\n        }\n        \n        // we must reload the core after we open the IW back up\n        if (reloadCore) {\n          reloadCore();\n        }\n\n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            if (indexDir != null) {\n              LOG.info(\"removing old index directory \" + indexDir);\n              core.getDirectoryFactory().doneWithDirectory(indexDir);\n              core.getDirectoryFactory().remove(indexDir);\n            }\n          }\n          if (isFullCopyNeeded) {\n            solrCore.getUpdateHandler().newIndexWriter(isFullCopyNeeded);\n          }\n          \n          openNewSearcherAndUpdateCommitPoint();\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      }\n    } finally {\n      try {\n        if (!successfulInstall) {\n          try {\n            logReplicationTimeAndConfFiles(null, successfulInstall);\n          } catch(Exception e) {\n            LOG.error(\"caught\", e);\n          }\n        }\n        filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n        replicationStartTime = 0;\n        dirFileFetcher = null;\n        localFileFetcher = null;\n        if (fsyncService != null && !fsyncService.isShutdown()) fsyncService\n            .shutdownNow();\n        fsyncService = null;\n        stop = false;\n        fsyncException = null;\n      } finally {\n        if (deleteTmpIdxDir && tmpIndexDir != null) {\n          try {\n            core.getDirectoryFactory().doneWithDirectory(tmpIndexDir);\n            core.getDirectoryFactory().remove(tmpIndexDir);\n          } catch (IOException e) {\n            SolrException.log(LOG, \"Error removing directory \" + tmpIndexDir, e);\n          }\n        }\n        \n        if (tmpIndexDir != null) {\n          core.getDirectoryFactory().release(tmpIndexDir);\n        }\n        \n        if (indexDir != null) {\n          core.getDirectoryFactory().release(indexDir);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(final SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    Directory tmpIndexDir = null;\n    String tmpIndex = null;\n    Directory indexDir = null;\n    String indexDirPath = null;\n    boolean deleteTmpIdxDir = true;\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      // TODO: make sure that getLatestCommit only returns commit points for the main index (i.e. no side-car indexes)\n      IndexCommit commit = core.getDeletionPolicy().getLatestCommit();\n      if (commit == null) {\n        // Presumably the IndexWriter hasn't been opened yet, and hence the deletion policy hasn't been updated with commit points\n        RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n        try {\n          searcherRefCounted = core.getNewestSearcher(false);\n          if (searcherRefCounted == null) {\n            LOG.warn(\"No open searcher found - fetch aborted\");\n            return false;\n          }\n          commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n        } finally {\n          if (searcherRefCounted != null)\n            searcherRefCounted.decref();\n        }\n      }\n\n\n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generation of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index directory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper\n          .getCommitTimestamp(commit) >= latestVersion\n          || commit.getGeneration() >= latestGeneration || forceReplication;\n\n      String tmpIdxDirName = \"index.\" + new SimpleDateFormat(SnapShooter.DATE_FMT, Locale.ROOT).format(new Date());\n      tmpIndex = createTempindexDir(core, tmpIdxDirName);\n\n      tmpIndexDir = core.getDirectoryFactory().get(tmpIndex, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n      \n      // cindex dir...\n      indexDirPath = core.getIndexDir();\n      indexDir = core.getDirectoryFactory().get(indexDirPath, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n\n      try {\n        \n        if (isIndexStale(indexDir)) {\n          isFullCopyNeeded = true;\n        }\n        \n        if (!isFullCopyNeeded) {\n          // a searcher might be using some flushed but committed segments\n          // because of soft commits (which open a searcher on IW's data)\n          // so we need to close the existing searcher on the last commit\n          // and wait until we are able to clean up all unused lucene files\n          if (solrCore.getCoreDescriptor().getCoreContainer().isZooKeeperAware()) {\n            solrCore.closeSearcher();\n          }\n\n          // rollback and reopen index writer and wait until all unused files\n          // are successfully deleted\n          solrCore.getUpdateHandler().newIndexWriter(true);\n          RefCounted<IndexWriter> writer = solrCore.getUpdateHandler().getSolrCoreState().getIndexWriter(null);\n          try {\n            IndexWriter indexWriter = writer.get();\n            int c = 0;\n            indexWriter.deleteUnusedFiles();\n            while (hasUnusedFiles(indexDir, commit)) {\n              indexWriter.deleteUnusedFiles();\n              LOG.info(\"Sleeping for 1000ms to wait for unused lucene index files to be delete-able\");\n              Thread.sleep(1000);\n              c++;\n              if (c >= 30)  {\n                LOG.warn(\"SnapPuller unable to cleanup unused lucene index files so we must do a full copy instead\");\n                isFullCopyNeeded = true;\n                break;\n              }\n            }\n            if (c > 0)  {\n              LOG.info(\"SnapPuller slept for \" + (c * 1000) + \"ms for unused lucene index files to be delete-able\");\n            }\n          } finally {\n            writer.decref();\n          }\n          solrCore.getUpdateHandler().getSolrCoreState().closeIndexWriter(core, true);\n        }\n        boolean reloadCore = false;\n        \n        try {\n          LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\"\n              + isFullCopyNeeded);\n          successfulInstall = false;\n          \n          downloadIndexFiles(isFullCopyNeeded, indexDir, tmpIndexDir,\n              latestGeneration);\n          LOG.info(\"Total time taken for download : \"\n              + ((System.currentTimeMillis() - replicationStartTime) / 1000)\n              + \" secs\");\n          Collection<Map<String,Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n          if (!modifiedConfFiles.isEmpty()) {\n            downloadConfFiles(confFilesToDownload, latestGeneration);\n            if (isFullCopyNeeded) {\n              successfulInstall = modifyIndexProps(tmpIdxDirName);\n              deleteTmpIdxDir = false;\n            } else {\n              successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n            }\n            if (successfulInstall) {\n              if (isFullCopyNeeded) {\n                // let the system know we are changing dir's and the old one\n                // may be closed\n                if (indexDir != null) {\n                  LOG.info(\"removing old index directory \" + indexDir);\n                  core.getDirectoryFactory().doneWithDirectory(indexDir);\n                  core.getDirectoryFactory().remove(indexDir);\n                }\n              }\n              \n              LOG.info(\"Configuration files are modified, core will be reloaded\");\n              logReplicationTimeAndConfFiles(modifiedConfFiles,\n                  successfulInstall);// write to a file time of replication and\n                                     // conf files.\n              reloadCore = true;\n            }\n          } else {\n            terminateAndWaitFsyncService();\n            if (isFullCopyNeeded) {\n              successfulInstall = modifyIndexProps(tmpIdxDirName);\n              deleteTmpIdxDir = false;\n            } else {\n              successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n            }\n            if (successfulInstall) {\n              logReplicationTimeAndConfFiles(modifiedConfFiles,\n                  successfulInstall);\n            }\n          }\n        } finally {\n          if (!isFullCopyNeeded) {\n            solrCore.getUpdateHandler().getSolrCoreState().openIndexWriter(core);\n          }\n        }\n        \n        // we must reload the core after we open the IW back up\n        if (reloadCore) {\n          reloadCore();\n        }\n\n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            if (indexDir != null) {\n              LOG.info(\"removing old index directory \" + indexDir);\n              core.getDirectoryFactory().doneWithDirectory(indexDir);\n              core.getDirectoryFactory().remove(indexDir);\n            }\n          }\n          if (isFullCopyNeeded) {\n            solrCore.getUpdateHandler().newIndexWriter(isFullCopyNeeded);\n          }\n          \n          openNewSearcherAndUpdateCommitPoint();\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      }\n    } finally {\n      try {\n        if (!successfulInstall) {\n          try {\n            logReplicationTimeAndConfFiles(null, successfulInstall);\n          } catch(Exception e) {\n            LOG.error(\"caught\", e);\n          }\n        }\n        filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n        replicationStartTime = 0;\n        dirFileFetcher = null;\n        localFileFetcher = null;\n        if (fsyncService != null && !fsyncService.isShutdown()) fsyncService\n            .shutdownNow();\n        fsyncService = null;\n        stop = false;\n        fsyncException = null;\n      } finally {\n        if (deleteTmpIdxDir && tmpIndexDir != null) {\n          try {\n            core.getDirectoryFactory().doneWithDirectory(tmpIndexDir);\n            core.getDirectoryFactory().remove(tmpIndexDir);\n          } catch (IOException e) {\n            SolrException.log(LOG, \"Error removing directory \" + tmpIndexDir, e);\n          }\n        }\n        \n        if (tmpIndexDir != null) {\n          core.getDirectoryFactory().release(tmpIndexDir);\n        }\n        \n        if (indexDir != null) {\n          core.getDirectoryFactory().release(indexDir);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["6c94d2661bc1c14426980ec7882e951fdcff08d0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8d50ba1695a40ff11a41bbfc1ad45c7bfd6a5738","date":1423258737,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(final SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    Directory tmpIndexDir = null;\n    String tmpIndex = null;\n    Directory indexDir = null;\n    String indexDirPath = null;\n    boolean deleteTmpIdxDir = true;\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      // TODO: make sure that getLatestCommit only returns commit points for the main index (i.e. no side-car indexes)\n      IndexCommit commit = core.getDeletionPolicy().getLatestCommit();\n      if (commit == null) {\n        // Presumably the IndexWriter hasn't been opened yet, and hence the deletion policy hasn't been updated with commit points\n        RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n        try {\n          searcherRefCounted = core.getNewestSearcher(false);\n          if (searcherRefCounted == null) {\n            LOG.warn(\"No open searcher found - fetch aborted\");\n            return false;\n          }\n          commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n        } finally {\n          if (searcherRefCounted != null)\n            searcherRefCounted.decref();\n        }\n      }\n\n\n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generation of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index directory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper\n          .getCommitTimestamp(commit) >= latestVersion\n          || commit.getGeneration() >= latestGeneration || forceReplication;\n\n      String tmpIdxDirName = \"index.\" + new SimpleDateFormat(SnapShooter.DATE_FMT, Locale.ROOT).format(new Date());\n      tmpIndex = createTempindexDir(core, tmpIdxDirName);\n\n      tmpIndexDir = core.getDirectoryFactory().get(tmpIndex, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n      \n      // cindex dir...\n      indexDirPath = core.getIndexDir();\n      indexDir = core.getDirectoryFactory().get(indexDirPath, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n\n      try {\n        \n        if (isIndexStale(indexDir)) {\n          isFullCopyNeeded = true;\n        }\n        \n        if (!isFullCopyNeeded) {\n          // a searcher might be using some flushed but not committed segments\n          // because of soft commits (which open a searcher on IW's data)\n          // so we need to close the existing searcher on the last commit\n          // and wait until we are able to clean up all unused lucene files\n          if (solrCore.getCoreDescriptor().getCoreContainer().isZooKeeperAware()) {\n            solrCore.closeSearcher();\n          }\n\n          // rollback and reopen index writer and wait until all unused files\n          // are successfully deleted\n          solrCore.getUpdateHandler().newIndexWriter(true);\n          RefCounted<IndexWriter> writer = solrCore.getUpdateHandler().getSolrCoreState().getIndexWriter(null);\n          try {\n            IndexWriter indexWriter = writer.get();\n            int c = 0;\n            indexWriter.deleteUnusedFiles();\n            while (hasUnusedFiles(indexDir, commit)) {\n              indexWriter.deleteUnusedFiles();\n              LOG.info(\"Sleeping for 1000ms to wait for unused lucene index files to be delete-able\");\n              Thread.sleep(1000);\n              c++;\n              if (c >= 30)  {\n                LOG.warn(\"SnapPuller unable to cleanup unused lucene index files so we must do a full copy instead\");\n                isFullCopyNeeded = true;\n                break;\n              }\n            }\n            if (c > 0)  {\n              LOG.info(\"SnapPuller slept for \" + (c * 1000) + \"ms for unused lucene index files to be delete-able\");\n            }\n          } finally {\n            writer.decref();\n          }\n          solrCore.getUpdateHandler().getSolrCoreState().closeIndexWriter(core, true);\n        }\n        boolean reloadCore = false;\n        \n        try {\n          LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\"\n              + isFullCopyNeeded);\n          successfulInstall = false;\n          \n          downloadIndexFiles(isFullCopyNeeded, indexDir, tmpIndexDir, latestGeneration);\n          LOG.info(\"Total time taken for download : \"\n              + ((System.currentTimeMillis() - replicationStartTime) / 1000)\n              + \" secs\");\n          Collection<Map<String,Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n          if (!modifiedConfFiles.isEmpty()) {\n            downloadConfFiles(confFilesToDownload, latestGeneration);\n            if (isFullCopyNeeded) {\n              successfulInstall = modifyIndexProps(tmpIdxDirName);\n              deleteTmpIdxDir = false;\n            } else {\n              successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n            }\n            if (successfulInstall) {\n              if (isFullCopyNeeded) {\n                // let the system know we are changing dir's and the old one\n                // may be closed\n                if (indexDir != null) {\n                  LOG.info(\"removing old index directory \" + indexDir);\n                  core.getDirectoryFactory().doneWithDirectory(indexDir);\n                  core.getDirectoryFactory().remove(indexDir);\n                }\n              }\n              \n              LOG.info(\"Configuration files are modified, core will be reloaded\");\n              logReplicationTimeAndConfFiles(modifiedConfFiles,\n                  successfulInstall);// write to a file time of replication and\n                                     // conf files.\n              reloadCore = true;\n            }\n          } else {\n            terminateAndWaitFsyncService();\n            if (isFullCopyNeeded) {\n              successfulInstall = modifyIndexProps(tmpIdxDirName);\n              deleteTmpIdxDir = false;\n            } else {\n              successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n            }\n            if (successfulInstall) {\n              logReplicationTimeAndConfFiles(modifiedConfFiles,\n                  successfulInstall);\n            }\n          }\n        } finally {\n          if (!isFullCopyNeeded) {\n            solrCore.getUpdateHandler().getSolrCoreState().openIndexWriter(core);\n          }\n        }\n        \n        // we must reload the core after we open the IW back up\n        if (reloadCore) {\n          reloadCore();\n        }\n\n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            if (indexDir != null) {\n              LOG.info(\"removing old index directory \" + indexDir);\n              core.getDirectoryFactory().doneWithDirectory(indexDir);\n              core.getDirectoryFactory().remove(indexDir);\n            }\n          }\n          if (isFullCopyNeeded) {\n            solrCore.getUpdateHandler().newIndexWriter(isFullCopyNeeded);\n          }\n          \n          openNewSearcherAndUpdateCommitPoint();\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      }\n    } finally {\n      try {\n        if (!successfulInstall) {\n          try {\n            logReplicationTimeAndConfFiles(null, successfulInstall);\n          } catch(Exception e) {\n            LOG.error(\"caught\", e);\n          }\n        }\n        filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n        replicationStartTime = 0;\n        dirFileFetcher = null;\n        localFileFetcher = null;\n        if (fsyncService != null && !fsyncService.isShutdown()) fsyncService\n            .shutdownNow();\n        fsyncService = null;\n        stop = false;\n        fsyncException = null;\n      } finally {\n        if (deleteTmpIdxDir && tmpIndexDir != null) {\n          try {\n            core.getDirectoryFactory().doneWithDirectory(tmpIndexDir);\n            core.getDirectoryFactory().remove(tmpIndexDir);\n          } catch (IOException e) {\n            SolrException.log(LOG, \"Error removing directory \" + tmpIndexDir, e);\n          }\n        }\n        \n        if (tmpIndexDir != null) {\n          core.getDirectoryFactory().release(tmpIndexDir);\n        }\n        \n        if (indexDir != null) {\n          core.getDirectoryFactory().release(indexDir);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(final SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    Directory tmpIndexDir = null;\n    String tmpIndex = null;\n    Directory indexDir = null;\n    String indexDirPath = null;\n    boolean deleteTmpIdxDir = true;\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      // TODO: make sure that getLatestCommit only returns commit points for the main index (i.e. no side-car indexes)\n      IndexCommit commit = core.getDeletionPolicy().getLatestCommit();\n      if (commit == null) {\n        // Presumably the IndexWriter hasn't been opened yet, and hence the deletion policy hasn't been updated with commit points\n        RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n        try {\n          searcherRefCounted = core.getNewestSearcher(false);\n          if (searcherRefCounted == null) {\n            LOG.warn(\"No open searcher found - fetch aborted\");\n            return false;\n          }\n          commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n        } finally {\n          if (searcherRefCounted != null)\n            searcherRefCounted.decref();\n        }\n      }\n\n\n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generation of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index directory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper\n          .getCommitTimestamp(commit) >= latestVersion\n          || commit.getGeneration() >= latestGeneration || forceReplication;\n\n      String tmpIdxDirName = \"index.\" + new SimpleDateFormat(SnapShooter.DATE_FMT, Locale.ROOT).format(new Date());\n      tmpIndex = createTempindexDir(core, tmpIdxDirName);\n\n      tmpIndexDir = core.getDirectoryFactory().get(tmpIndex, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n      \n      // cindex dir...\n      indexDirPath = core.getIndexDir();\n      indexDir = core.getDirectoryFactory().get(indexDirPath, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n\n      try {\n        \n        if (isIndexStale(indexDir)) {\n          isFullCopyNeeded = true;\n        }\n        \n        if (!isFullCopyNeeded) {\n          // a searcher might be using some flushed but not committed segments\n          // because of soft commits (which open a searcher on IW's data)\n          // so we need to close the existing searcher on the last commit\n          // and wait until we are able to clean up all unused lucene files\n          if (solrCore.getCoreDescriptor().getCoreContainer().isZooKeeperAware()) {\n            solrCore.closeSearcher();\n          }\n\n          // rollback and reopen index writer and wait until all unused files\n          // are successfully deleted\n          solrCore.getUpdateHandler().newIndexWriter(true);\n          RefCounted<IndexWriter> writer = solrCore.getUpdateHandler().getSolrCoreState().getIndexWriter(null);\n          try {\n            IndexWriter indexWriter = writer.get();\n            int c = 0;\n            indexWriter.deleteUnusedFiles();\n            while (hasUnusedFiles(indexDir, commit)) {\n              indexWriter.deleteUnusedFiles();\n              LOG.info(\"Sleeping for 1000ms to wait for unused lucene index files to be delete-able\");\n              Thread.sleep(1000);\n              c++;\n              if (c >= 30)  {\n                LOG.warn(\"SnapPuller unable to cleanup unused lucene index files so we must do a full copy instead\");\n                isFullCopyNeeded = true;\n                break;\n              }\n            }\n            if (c > 0)  {\n              LOG.info(\"SnapPuller slept for \" + (c * 1000) + \"ms for unused lucene index files to be delete-able\");\n            }\n          } finally {\n            writer.decref();\n          }\n          solrCore.getUpdateHandler().getSolrCoreState().closeIndexWriter(core, true);\n        }\n        boolean reloadCore = false;\n        \n        try {\n          LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\"\n              + isFullCopyNeeded);\n          successfulInstall = false;\n          \n          downloadIndexFiles(isFullCopyNeeded, indexDir, tmpIndexDir,\n              latestGeneration);\n          LOG.info(\"Total time taken for download : \"\n              + ((System.currentTimeMillis() - replicationStartTime) / 1000)\n              + \" secs\");\n          Collection<Map<String,Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n          if (!modifiedConfFiles.isEmpty()) {\n            downloadConfFiles(confFilesToDownload, latestGeneration);\n            if (isFullCopyNeeded) {\n              successfulInstall = modifyIndexProps(tmpIdxDirName);\n              deleteTmpIdxDir = false;\n            } else {\n              successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n            }\n            if (successfulInstall) {\n              if (isFullCopyNeeded) {\n                // let the system know we are changing dir's and the old one\n                // may be closed\n                if (indexDir != null) {\n                  LOG.info(\"removing old index directory \" + indexDir);\n                  core.getDirectoryFactory().doneWithDirectory(indexDir);\n                  core.getDirectoryFactory().remove(indexDir);\n                }\n              }\n              \n              LOG.info(\"Configuration files are modified, core will be reloaded\");\n              logReplicationTimeAndConfFiles(modifiedConfFiles,\n                  successfulInstall);// write to a file time of replication and\n                                     // conf files.\n              reloadCore = true;\n            }\n          } else {\n            terminateAndWaitFsyncService();\n            if (isFullCopyNeeded) {\n              successfulInstall = modifyIndexProps(tmpIdxDirName);\n              deleteTmpIdxDir = false;\n            } else {\n              successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n            }\n            if (successfulInstall) {\n              logReplicationTimeAndConfFiles(modifiedConfFiles,\n                  successfulInstall);\n            }\n          }\n        } finally {\n          if (!isFullCopyNeeded) {\n            solrCore.getUpdateHandler().getSolrCoreState().openIndexWriter(core);\n          }\n        }\n        \n        // we must reload the core after we open the IW back up\n        if (reloadCore) {\n          reloadCore();\n        }\n\n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            if (indexDir != null) {\n              LOG.info(\"removing old index directory \" + indexDir);\n              core.getDirectoryFactory().doneWithDirectory(indexDir);\n              core.getDirectoryFactory().remove(indexDir);\n            }\n          }\n          if (isFullCopyNeeded) {\n            solrCore.getUpdateHandler().newIndexWriter(isFullCopyNeeded);\n          }\n          \n          openNewSearcherAndUpdateCommitPoint();\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      }\n    } finally {\n      try {\n        if (!successfulInstall) {\n          try {\n            logReplicationTimeAndConfFiles(null, successfulInstall);\n          } catch(Exception e) {\n            LOG.error(\"caught\", e);\n          }\n        }\n        filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n        replicationStartTime = 0;\n        dirFileFetcher = null;\n        localFileFetcher = null;\n        if (fsyncService != null && !fsyncService.isShutdown()) fsyncService\n            .shutdownNow();\n        fsyncService = null;\n        stop = false;\n        fsyncException = null;\n      } finally {\n        if (deleteTmpIdxDir && tmpIndexDir != null) {\n          try {\n            core.getDirectoryFactory().doneWithDirectory(tmpIndexDir);\n            core.getDirectoryFactory().remove(tmpIndexDir);\n          } catch (IOException e) {\n            SolrException.log(LOG, \"Error removing directory \" + tmpIndexDir, e);\n          }\n        }\n        \n        if (tmpIndexDir != null) {\n          core.getDirectoryFactory().release(tmpIndexDir);\n        }\n        \n        if (indexDir != null) {\n          core.getDirectoryFactory().release(indexDir);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["6c94d2661bc1c14426980ec7882e951fdcff08d0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"20f6b7cff3771384f27af0f059795d7e64aff6b9","date":1425498309,"type":5,"author":"Ramkumar Aiyengar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/IndexFetcher#fetchLatestIndex(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","sourceNew":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(final SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    Directory tmpIndexDir = null;\n    String tmpIndex = null;\n    Directory indexDir = null;\n    String indexDirPath = null;\n    boolean deleteTmpIdxDir = true;\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      // TODO: make sure that getLatestCommit only returns commit points for the main index (i.e. no side-car indexes)\n      IndexCommit commit = core.getDeletionPolicy().getLatestCommit();\n      if (commit == null) {\n        // Presumably the IndexWriter hasn't been opened yet, and hence the deletion policy hasn't been updated with commit points\n        RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n        try {\n          searcherRefCounted = core.getNewestSearcher(false);\n          if (searcherRefCounted == null) {\n            LOG.warn(\"No open searcher found - fetch aborted\");\n            return false;\n          }\n          commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n        } finally {\n          if (searcherRefCounted != null)\n            searcherRefCounted.decref();\n        }\n      }\n\n\n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generation of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index directory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper\n          .getCommitTimestamp(commit) >= latestVersion\n          || commit.getGeneration() >= latestGeneration || forceReplication;\n\n      String tmpIdxDirName = \"index.\" + new SimpleDateFormat(SnapShooter.DATE_FMT, Locale.ROOT).format(new Date());\n      tmpIndex = createTempindexDir(core, tmpIdxDirName);\n\n      tmpIndexDir = core.getDirectoryFactory().get(tmpIndex, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n      \n      // cindex dir...\n      indexDirPath = core.getIndexDir();\n      indexDir = core.getDirectoryFactory().get(indexDirPath, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n\n      try {\n        \n        if (isIndexStale(indexDir)) {\n          isFullCopyNeeded = true;\n        }\n        \n        if (!isFullCopyNeeded) {\n          // a searcher might be using some flushed but not committed segments\n          // because of soft commits (which open a searcher on IW's data)\n          // so we need to close the existing searcher on the last commit\n          // and wait until we are able to clean up all unused lucene files\n          if (solrCore.getCoreDescriptor().getCoreContainer().isZooKeeperAware()) {\n            solrCore.closeSearcher();\n          }\n\n          // rollback and reopen index writer and wait until all unused files\n          // are successfully deleted\n          solrCore.getUpdateHandler().newIndexWriter(true);\n          RefCounted<IndexWriter> writer = solrCore.getUpdateHandler().getSolrCoreState().getIndexWriter(null);\n          try {\n            IndexWriter indexWriter = writer.get();\n            int c = 0;\n            indexWriter.deleteUnusedFiles();\n            while (hasUnusedFiles(indexDir, commit)) {\n              indexWriter.deleteUnusedFiles();\n              LOG.info(\"Sleeping for 1000ms to wait for unused lucene index files to be delete-able\");\n              Thread.sleep(1000);\n              c++;\n              if (c >= 30)  {\n                LOG.warn(\"IndexFetcher unable to cleanup unused lucene index files so we must do a full copy instead\");\n                isFullCopyNeeded = true;\n                break;\n              }\n            }\n            if (c > 0)  {\n              LOG.info(\"IndexFetcher slept for \" + (c * 1000) + \"ms for unused lucene index files to be delete-able\");\n            }\n          } finally {\n            writer.decref();\n          }\n          solrCore.getUpdateHandler().getSolrCoreState().closeIndexWriter(core, true);\n        }\n        boolean reloadCore = false;\n        \n        try {\n          LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\"\n              + isFullCopyNeeded);\n          successfulInstall = false;\n          \n          downloadIndexFiles(isFullCopyNeeded, indexDir, tmpIndexDir, latestGeneration);\n          LOG.info(\"Total time taken for download : \"\n              + ((System.currentTimeMillis() - replicationStartTime) / 1000)\n              + \" secs\");\n          Collection<Map<String,Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n          if (!modifiedConfFiles.isEmpty()) {\n            downloadConfFiles(confFilesToDownload, latestGeneration);\n            if (isFullCopyNeeded) {\n              successfulInstall = modifyIndexProps(tmpIdxDirName);\n              deleteTmpIdxDir = false;\n            } else {\n              successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n            }\n            if (successfulInstall) {\n              if (isFullCopyNeeded) {\n                // let the system know we are changing dir's and the old one\n                // may be closed\n                if (indexDir != null) {\n                  LOG.info(\"removing old index directory \" + indexDir);\n                  core.getDirectoryFactory().doneWithDirectory(indexDir);\n                  core.getDirectoryFactory().remove(indexDir);\n                }\n              }\n              \n              LOG.info(\"Configuration files are modified, core will be reloaded\");\n              logReplicationTimeAndConfFiles(modifiedConfFiles,\n                  successfulInstall);// write to a file time of replication and\n                                     // conf files.\n              reloadCore = true;\n            }\n          } else {\n            terminateAndWaitFsyncService();\n            if (isFullCopyNeeded) {\n              successfulInstall = modifyIndexProps(tmpIdxDirName);\n              deleteTmpIdxDir = false;\n            } else {\n              successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n            }\n            if (successfulInstall) {\n              logReplicationTimeAndConfFiles(modifiedConfFiles,\n                  successfulInstall);\n            }\n          }\n        } finally {\n          if (!isFullCopyNeeded) {\n            solrCore.getUpdateHandler().getSolrCoreState().openIndexWriter(core);\n          }\n        }\n        \n        // we must reload the core after we open the IW back up\n        if (reloadCore) {\n          reloadCore();\n        }\n\n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            if (indexDir != null) {\n              LOG.info(\"removing old index directory \" + indexDir);\n              core.getDirectoryFactory().doneWithDirectory(indexDir);\n              core.getDirectoryFactory().remove(indexDir);\n            }\n          }\n          if (isFullCopyNeeded) {\n            solrCore.getUpdateHandler().newIndexWriter(isFullCopyNeeded);\n          }\n          \n          openNewSearcherAndUpdateCommitPoint();\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      }\n    } finally {\n      try {\n        if (!successfulInstall) {\n          try {\n            logReplicationTimeAndConfFiles(null, successfulInstall);\n          } catch(Exception e) {\n            LOG.error(\"caught\", e);\n          }\n        }\n        filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n        replicationStartTime = 0;\n        dirFileFetcher = null;\n        localFileFetcher = null;\n        if (fsyncService != null && !fsyncService.isShutdown()) fsyncService\n            .shutdownNow();\n        fsyncService = null;\n        stop = false;\n        fsyncException = null;\n      } finally {\n        if (deleteTmpIdxDir && tmpIndexDir != null) {\n          try {\n            core.getDirectoryFactory().doneWithDirectory(tmpIndexDir);\n            core.getDirectoryFactory().remove(tmpIndexDir);\n          } catch (IOException e) {\n            SolrException.log(LOG, \"Error removing directory \" + tmpIndexDir, e);\n          }\n        }\n        \n        if (tmpIndexDir != null) {\n          core.getDirectoryFactory().release(tmpIndexDir);\n        }\n        \n        if (indexDir != null) {\n          core.getDirectoryFactory().release(indexDir);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(final SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    Directory tmpIndexDir = null;\n    String tmpIndex = null;\n    Directory indexDir = null;\n    String indexDirPath = null;\n    boolean deleteTmpIdxDir = true;\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      // TODO: make sure that getLatestCommit only returns commit points for the main index (i.e. no side-car indexes)\n      IndexCommit commit = core.getDeletionPolicy().getLatestCommit();\n      if (commit == null) {\n        // Presumably the IndexWriter hasn't been opened yet, and hence the deletion policy hasn't been updated with commit points\n        RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n        try {\n          searcherRefCounted = core.getNewestSearcher(false);\n          if (searcherRefCounted == null) {\n            LOG.warn(\"No open searcher found - fetch aborted\");\n            return false;\n          }\n          commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n        } finally {\n          if (searcherRefCounted != null)\n            searcherRefCounted.decref();\n        }\n      }\n\n\n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generation of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index directory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper\n          .getCommitTimestamp(commit) >= latestVersion\n          || commit.getGeneration() >= latestGeneration || forceReplication;\n\n      String tmpIdxDirName = \"index.\" + new SimpleDateFormat(SnapShooter.DATE_FMT, Locale.ROOT).format(new Date());\n      tmpIndex = createTempindexDir(core, tmpIdxDirName);\n\n      tmpIndexDir = core.getDirectoryFactory().get(tmpIndex, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n      \n      // cindex dir...\n      indexDirPath = core.getIndexDir();\n      indexDir = core.getDirectoryFactory().get(indexDirPath, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n\n      try {\n        \n        if (isIndexStale(indexDir)) {\n          isFullCopyNeeded = true;\n        }\n        \n        if (!isFullCopyNeeded) {\n          // a searcher might be using some flushed but not committed segments\n          // because of soft commits (which open a searcher on IW's data)\n          // so we need to close the existing searcher on the last commit\n          // and wait until we are able to clean up all unused lucene files\n          if (solrCore.getCoreDescriptor().getCoreContainer().isZooKeeperAware()) {\n            solrCore.closeSearcher();\n          }\n\n          // rollback and reopen index writer and wait until all unused files\n          // are successfully deleted\n          solrCore.getUpdateHandler().newIndexWriter(true);\n          RefCounted<IndexWriter> writer = solrCore.getUpdateHandler().getSolrCoreState().getIndexWriter(null);\n          try {\n            IndexWriter indexWriter = writer.get();\n            int c = 0;\n            indexWriter.deleteUnusedFiles();\n            while (hasUnusedFiles(indexDir, commit)) {\n              indexWriter.deleteUnusedFiles();\n              LOG.info(\"Sleeping for 1000ms to wait for unused lucene index files to be delete-able\");\n              Thread.sleep(1000);\n              c++;\n              if (c >= 30)  {\n                LOG.warn(\"SnapPuller unable to cleanup unused lucene index files so we must do a full copy instead\");\n                isFullCopyNeeded = true;\n                break;\n              }\n            }\n            if (c > 0)  {\n              LOG.info(\"SnapPuller slept for \" + (c * 1000) + \"ms for unused lucene index files to be delete-able\");\n            }\n          } finally {\n            writer.decref();\n          }\n          solrCore.getUpdateHandler().getSolrCoreState().closeIndexWriter(core, true);\n        }\n        boolean reloadCore = false;\n        \n        try {\n          LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\"\n              + isFullCopyNeeded);\n          successfulInstall = false;\n          \n          downloadIndexFiles(isFullCopyNeeded, indexDir, tmpIndexDir, latestGeneration);\n          LOG.info(\"Total time taken for download : \"\n              + ((System.currentTimeMillis() - replicationStartTime) / 1000)\n              + \" secs\");\n          Collection<Map<String,Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n          if (!modifiedConfFiles.isEmpty()) {\n            downloadConfFiles(confFilesToDownload, latestGeneration);\n            if (isFullCopyNeeded) {\n              successfulInstall = modifyIndexProps(tmpIdxDirName);\n              deleteTmpIdxDir = false;\n            } else {\n              successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n            }\n            if (successfulInstall) {\n              if (isFullCopyNeeded) {\n                // let the system know we are changing dir's and the old one\n                // may be closed\n                if (indexDir != null) {\n                  LOG.info(\"removing old index directory \" + indexDir);\n                  core.getDirectoryFactory().doneWithDirectory(indexDir);\n                  core.getDirectoryFactory().remove(indexDir);\n                }\n              }\n              \n              LOG.info(\"Configuration files are modified, core will be reloaded\");\n              logReplicationTimeAndConfFiles(modifiedConfFiles,\n                  successfulInstall);// write to a file time of replication and\n                                     // conf files.\n              reloadCore = true;\n            }\n          } else {\n            terminateAndWaitFsyncService();\n            if (isFullCopyNeeded) {\n              successfulInstall = modifyIndexProps(tmpIdxDirName);\n              deleteTmpIdxDir = false;\n            } else {\n              successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n            }\n            if (successfulInstall) {\n              logReplicationTimeAndConfFiles(modifiedConfFiles,\n                  successfulInstall);\n            }\n          }\n        } finally {\n          if (!isFullCopyNeeded) {\n            solrCore.getUpdateHandler().getSolrCoreState().openIndexWriter(core);\n          }\n        }\n        \n        // we must reload the core after we open the IW back up\n        if (reloadCore) {\n          reloadCore();\n        }\n\n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            if (indexDir != null) {\n              LOG.info(\"removing old index directory \" + indexDir);\n              core.getDirectoryFactory().doneWithDirectory(indexDir);\n              core.getDirectoryFactory().remove(indexDir);\n            }\n          }\n          if (isFullCopyNeeded) {\n            solrCore.getUpdateHandler().newIndexWriter(isFullCopyNeeded);\n          }\n          \n          openNewSearcherAndUpdateCommitPoint();\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      }\n    } finally {\n      try {\n        if (!successfulInstall) {\n          try {\n            logReplicationTimeAndConfFiles(null, successfulInstall);\n          } catch(Exception e) {\n            LOG.error(\"caught\", e);\n          }\n        }\n        filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n        replicationStartTime = 0;\n        dirFileFetcher = null;\n        localFileFetcher = null;\n        if (fsyncService != null && !fsyncService.isShutdown()) fsyncService\n            .shutdownNow();\n        fsyncService = null;\n        stop = false;\n        fsyncException = null;\n      } finally {\n        if (deleteTmpIdxDir && tmpIndexDir != null) {\n          try {\n            core.getDirectoryFactory().doneWithDirectory(tmpIndexDir);\n            core.getDirectoryFactory().remove(tmpIndexDir);\n          } catch (IOException e) {\n            SolrException.log(LOG, \"Error removing directory \" + tmpIndexDir, e);\n          }\n        }\n        \n        if (tmpIndexDir != null) {\n          core.getDirectoryFactory().release(tmpIndexDir);\n        }\n        \n        if (indexDir != null) {\n          core.getDirectoryFactory().release(indexDir);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["6c94d2661bc1c14426980ec7882e951fdcff08d0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":4,"author":"Ryan Ernst","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/handler/SnapPuller#fetchLatestIndex(SolrCore,boolean).mjava","sourceNew":null,"sourceOld":"  /**\n   * This command downloads all the necessary files from master to install a index commit point. Only changed files are\n   * downloaded. It also downloads the conf files (if they are modified).\n   *\n   * @param core the SolrCore\n   * @param forceReplication force a replication in all cases \n   * @return true on success, false if slave is already in sync\n   * @throws IOException if an exception occurs\n   */\n  boolean fetchLatestIndex(final SolrCore core, boolean forceReplication) throws IOException, InterruptedException {\n    successfulInstall = false;\n    replicationStartTime = System.currentTimeMillis();\n    Directory tmpIndexDir = null;\n    String tmpIndex = null;\n    Directory indexDir = null;\n    String indexDirPath = null;\n    boolean deleteTmpIdxDir = true;\n    try {\n      //get the current 'replicateable' index version in the master\n      NamedList response = null;\n      try {\n        response = getLatestVersion();\n      } catch (Exception e) {\n        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n        return false;\n      }\n      long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n      long latestGeneration = (Long) response.get(GENERATION);\n\n      // TODO: make sure that getLatestCommit only returns commit points for the main index (i.e. no side-car indexes)\n      IndexCommit commit = core.getDeletionPolicy().getLatestCommit();\n      if (commit == null) {\n        // Presumably the IndexWriter hasn't been opened yet, and hence the deletion policy hasn't been updated with commit points\n        RefCounted<SolrIndexSearcher> searcherRefCounted = null;\n        try {\n          searcherRefCounted = core.getNewestSearcher(false);\n          if (searcherRefCounted == null) {\n            LOG.warn(\"No open searcher found - fetch aborted\");\n            return false;\n          }\n          commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n        } finally {\n          if (searcherRefCounted != null)\n            searcherRefCounted.decref();\n        }\n      }\n\n\n      if (latestVersion == 0L) {\n        if (forceReplication && commit.getGeneration() != 0) {\n          // since we won't get the files for an empty index,\n          // we just clear ours and commit\n          RefCounted<IndexWriter> iw = core.getUpdateHandler().getSolrCoreState().getIndexWriter(core);\n          try {\n            iw.get().deleteAll();\n          } finally {\n            iw.decref();\n          }\n          SolrQueryRequest req = new LocalSolrQueryRequest(core,\n              new ModifiableSolrParams());\n          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));\n        }\n        \n        //there is nothing to be replicated\n        successfulInstall = true;\n        return true;\n      }\n      \n      if (!forceReplication && IndexDeletionPolicyWrapper.getCommitTimestamp(commit) == latestVersion) {\n        //master and slave are already in sync just return\n        LOG.info(\"Slave in sync with master.\");\n        successfulInstall = true;\n        return true;\n      }\n      LOG.info(\"Master's generation: \" + latestGeneration);\n      LOG.info(\"Slave's generation: \" + commit.getGeneration());\n      LOG.info(\"Starting replication process\");\n      // get the list of files first\n      fetchFileList(latestGeneration);\n      // this can happen if the commit point is deleted before we fetch the file list.\n      if(filesToDownload.isEmpty()) return false;\n      LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n\n      // Create the sync service\n      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory(\"fsyncService\"));\n      // use a synchronized list because the list is read by other threads (to show details)\n      filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());\n      // if the generation of master is older than that of the slave , it means they are not compatible to be copied\n      // then a new index directory to be created and all the files need to be copied\n      boolean isFullCopyNeeded = IndexDeletionPolicyWrapper\n          .getCommitTimestamp(commit) >= latestVersion\n          || commit.getGeneration() >= latestGeneration || forceReplication;\n\n      String tmpIdxDirName = \"index.\" + new SimpleDateFormat(SnapShooter.DATE_FMT, Locale.ROOT).format(new Date());\n      tmpIndex = createTempindexDir(core, tmpIdxDirName);\n\n      tmpIndexDir = core.getDirectoryFactory().get(tmpIndex, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n      \n      // cindex dir...\n      indexDirPath = core.getIndexDir();\n      indexDir = core.getDirectoryFactory().get(indexDirPath, DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);\n\n      try {\n        \n        if (isIndexStale(indexDir)) {\n          isFullCopyNeeded = true;\n        }\n        \n        if (!isFullCopyNeeded) {\n          // a searcher might be using some flushed but not committed segments\n          // because of soft commits (which open a searcher on IW's data)\n          // so we need to close the existing searcher on the last commit\n          // and wait until we are able to clean up all unused lucene files\n          if (solrCore.getCoreDescriptor().getCoreContainer().isZooKeeperAware()) {\n            solrCore.closeSearcher();\n          }\n\n          // rollback and reopen index writer and wait until all unused files\n          // are successfully deleted\n          solrCore.getUpdateHandler().newIndexWriter(true);\n          RefCounted<IndexWriter> writer = solrCore.getUpdateHandler().getSolrCoreState().getIndexWriter(null);\n          try {\n            IndexWriter indexWriter = writer.get();\n            int c = 0;\n            indexWriter.deleteUnusedFiles();\n            while (hasUnusedFiles(indexDir, commit)) {\n              indexWriter.deleteUnusedFiles();\n              LOG.info(\"Sleeping for 1000ms to wait for unused lucene index files to be delete-able\");\n              Thread.sleep(1000);\n              c++;\n              if (c >= 30)  {\n                LOG.warn(\"SnapPuller unable to cleanup unused lucene index files so we must do a full copy instead\");\n                isFullCopyNeeded = true;\n                break;\n              }\n            }\n            if (c > 0)  {\n              LOG.info(\"SnapPuller slept for \" + (c * 1000) + \"ms for unused lucene index files to be delete-able\");\n            }\n          } finally {\n            writer.decref();\n          }\n          solrCore.getUpdateHandler().getSolrCoreState().closeIndexWriter(core, true);\n        }\n        boolean reloadCore = false;\n        \n        try {\n          LOG.info(\"Starting download to \" + tmpIndexDir + \" fullCopy=\"\n              + isFullCopyNeeded);\n          successfulInstall = false;\n          \n          downloadIndexFiles(isFullCopyNeeded, indexDir, tmpIndexDir, latestGeneration);\n          LOG.info(\"Total time taken for download : \"\n              + ((System.currentTimeMillis() - replicationStartTime) / 1000)\n              + \" secs\");\n          Collection<Map<String,Object>> modifiedConfFiles = getModifiedConfFiles(confFilesToDownload);\n          if (!modifiedConfFiles.isEmpty()) {\n            downloadConfFiles(confFilesToDownload, latestGeneration);\n            if (isFullCopyNeeded) {\n              successfulInstall = modifyIndexProps(tmpIdxDirName);\n              deleteTmpIdxDir = false;\n            } else {\n              successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n            }\n            if (successfulInstall) {\n              if (isFullCopyNeeded) {\n                // let the system know we are changing dir's and the old one\n                // may be closed\n                if (indexDir != null) {\n                  LOG.info(\"removing old index directory \" + indexDir);\n                  core.getDirectoryFactory().doneWithDirectory(indexDir);\n                  core.getDirectoryFactory().remove(indexDir);\n                }\n              }\n              \n              LOG.info(\"Configuration files are modified, core will be reloaded\");\n              logReplicationTimeAndConfFiles(modifiedConfFiles,\n                  successfulInstall);// write to a file time of replication and\n                                     // conf files.\n              reloadCore = true;\n            }\n          } else {\n            terminateAndWaitFsyncService();\n            if (isFullCopyNeeded) {\n              successfulInstall = modifyIndexProps(tmpIdxDirName);\n              deleteTmpIdxDir = false;\n            } else {\n              successfulInstall = moveIndexFiles(tmpIndexDir, indexDir);\n            }\n            if (successfulInstall) {\n              logReplicationTimeAndConfFiles(modifiedConfFiles,\n                  successfulInstall);\n            }\n          }\n        } finally {\n          if (!isFullCopyNeeded) {\n            solrCore.getUpdateHandler().getSolrCoreState().openIndexWriter(core);\n          }\n        }\n        \n        // we must reload the core after we open the IW back up\n        if (reloadCore) {\n          reloadCore();\n        }\n\n        if (successfulInstall) {\n          if (isFullCopyNeeded) {\n            // let the system know we are changing dir's and the old one\n            // may be closed\n            if (indexDir != null) {\n              LOG.info(\"removing old index directory \" + indexDir);\n              core.getDirectoryFactory().doneWithDirectory(indexDir);\n              core.getDirectoryFactory().remove(indexDir);\n            }\n          }\n          if (isFullCopyNeeded) {\n            solrCore.getUpdateHandler().newIndexWriter(isFullCopyNeeded);\n          }\n          \n          openNewSearcherAndUpdateCommitPoint();\n        }\n        \n        replicationStartTime = 0;\n        return successfulInstall;\n      } catch (ReplicationHandlerException e) {\n        LOG.error(\"User aborted Replication\");\n        return false;\n      } catch (SolrException e) {\n        throw e;\n      } catch (InterruptedException e) {\n        throw new InterruptedException(\"Index fetch interrupted\");\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Index fetch failed : \", e);\n      }\n    } finally {\n      try {\n        if (!successfulInstall) {\n          try {\n            logReplicationTimeAndConfFiles(null, successfulInstall);\n          } catch(Exception e) {\n            LOG.error(\"caught\", e);\n          }\n        }\n        filesToDownload = filesDownloaded = confFilesDownloaded = confFilesToDownload = null;\n        replicationStartTime = 0;\n        dirFileFetcher = null;\n        localFileFetcher = null;\n        if (fsyncService != null && !fsyncService.isShutdown()) fsyncService\n            .shutdownNow();\n        fsyncService = null;\n        stop = false;\n        fsyncException = null;\n      } finally {\n        if (deleteTmpIdxDir && tmpIndexDir != null) {\n          try {\n            core.getDirectoryFactory().doneWithDirectory(tmpIndexDir);\n            core.getDirectoryFactory().remove(tmpIndexDir);\n          } catch (IOException e) {\n            SolrException.log(LOG, \"Error removing directory \" + tmpIndexDir, e);\n          }\n        }\n        \n        if (tmpIndexDir != null) {\n          core.getDirectoryFactory().release(tmpIndexDir);\n        }\n        \n        if (indexDir != null) {\n          core.getDirectoryFactory().release(indexDir);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"616c1830142ff5c1ddedec1ed898733b73c8e23b":["c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","b6d2d51ff0b489e2d7ddc42a63f0d6cb69326469"],"948cb7389da6d4f397f5a0f89caf885a9033c959":["bd8bc29700397ec1886e73bae0a67ff536bad223"],"be4d0855f94432c9a580ae7750c6f842d604a3e4":["1eda2abfda9da3ca2bc5c5872d6b8c0f4948f674"],"db05ec3460be863c2b1e39675c58b412cd9afdc0":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["058801f8673d53a5abac8088204860ec29a40f0d","b3c2c17185ad7fb0aa9b81dbd9d0395debbc4519"],"b05c56a41b733e02a189c48895922b5bd8c7f3d1":["c7869f64c874ebf7f317d22c00baf2b6857797a6","66c64e8cfded6a585100e6430238faaf416f3fea"],"8917bfede3b4ca30f4305c1e391e9218959cd723":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","be4d0855f94432c9a580ae7750c6f842d604a3e4"],"d9405f486872f1e416304dfe389741f4ee2f8a4d":["b6d2d51ff0b489e2d7ddc42a63f0d6cb69326469"],"2a77b0d8787d127be70f6c4055937ee9c0d4ee3b":["d9405f486872f1e416304dfe389741f4ee2f8a4d"],"b3c2c17185ad7fb0aa9b81dbd9d0395debbc4519":["8dd517686f746fb280a35ebadd0abf38e864fb41"],"d97814e287f694bcb4c679646ff4ac52fd8663c6":["4897c5b415f476d84ec970a19c41510645887526"],"aba371508186796cc6151d8223a5b4e16d02e26e":["bd9ddb59e9d33950773d186a8b726b5610ae3aad","d97814e287f694bcb4c679646ff4ac52fd8663c6"],"70fa1c0f4d75735ff2e1485e059d9bc5efa50598":["b05c56a41b733e02a189c48895922b5bd8c7f3d1","b6d2d51ff0b489e2d7ddc42a63f0d6cb69326469"],"f2126b84bd093fa3d921582a109a0ee578c28126":["b6d2d51ff0b489e2d7ddc42a63f0d6cb69326469","d9405f486872f1e416304dfe389741f4ee2f8a4d"],"66c64e8cfded6a585100e6430238faaf416f3fea":["1c8719b2c0b382be11f5b193b6fc14bc310e906b"],"8dd517686f746fb280a35ebadd0abf38e864fb41":["d8a3067239133ceb0117bc3d48356169cf03894f"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"b6d2d51ff0b489e2d7ddc42a63f0d6cb69326469":["66c64e8cfded6a585100e6430238faaf416f3fea"],"058801f8673d53a5abac8088204860ec29a40f0d":["4dcfb92697fbd03e488cf9e5155514e3270d0fc3"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["17423fb5ef5555fbfa7fe53c15d602faef60ba1a","4897c5b415f476d84ec970a19c41510645887526"],"8d50ba1695a40ff11a41bbfc1ad45c7bfd6a5738":["9f5e2ce7174b645aee7b07eab55640cf0b28916b"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["b3c2c17185ad7fb0aa9b81dbd9d0395debbc4519","b1615f6fc540ecd5dea7b03d2bac9a18bba69d5c"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["407687e67faf6e1f02a211ca078d8e3eed631027","ad3c006a1d6ec52c49f33c62a3678bf5023d9baf"],"b1615f6fc540ecd5dea7b03d2bac9a18bba69d5c":["190779ba7de3fda15afd1bbafbc383720a4b0966"],"c01638f4dd94981c1d3d52c4f7991246a5a24aba":["db05ec3460be863c2b1e39675c58b412cd9afdc0"],"1eda2abfda9da3ca2bc5c5872d6b8c0f4948f674":["ad3c006a1d6ec52c49f33c62a3678bf5023d9baf"],"17423fb5ef5555fbfa7fe53c15d602faef60ba1a":["c01638f4dd94981c1d3d52c4f7991246a5a24aba"],"fd92b8bcc88e969302510acf77bd6970da3994c4":["0d22ac6a4146774c1bc8400160fc0b6150294e92","db05ec3460be863c2b1e39675c58b412cd9afdc0"],"d8a3067239133ceb0117bc3d48356169cf03894f":["058801f8673d53a5abac8088204860ec29a40f0d"],"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198":["d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9","66c64e8cfded6a585100e6430238faaf416f3fea"],"bd8bc29700397ec1886e73bae0a67ff536bad223":["be4d0855f94432c9a580ae7750c6f842d604a3e4"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["8d50ba1695a40ff11a41bbfc1ad45c7bfd6a5738","20f6b7cff3771384f27af0f059795d7e64aff6b9"],"20f6b7cff3771384f27af0f059795d7e64aff6b9":["8d50ba1695a40ff11a41bbfc1ad45c7bfd6a5738"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":["b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","1c8719b2c0b382be11f5b193b6fc14bc310e906b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5b6fdfce35d0adb18836cf8711abe487a934df33":["78a55f24d9b493c2a1cecf79f1d78279062b545b","c01638f4dd94981c1d3d52c4f7991246a5a24aba"],"190779ba7de3fda15afd1bbafbc383720a4b0966":["b3c2c17185ad7fb0aa9b81dbd9d0395debbc4519"],"d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9":["aba371508186796cc6151d8223a5b4e16d02e26e","1c8719b2c0b382be11f5b193b6fc14bc310e906b"],"78a55f24d9b493c2a1cecf79f1d78279062b545b":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","db05ec3460be863c2b1e39675c58b412cd9afdc0"],"407687e67faf6e1f02a211ca078d8e3eed631027":["d9405f486872f1e416304dfe389741f4ee2f8a4d","718607d99d02778db3280e64975663762c94170d"],"1b7910b51406c081814c946331386da674f26aa5":["0fa112cb510d1bdb66c944fe9ba78679974d3c14"],"4dcfb92697fbd03e488cf9e5155514e3270d0fc3":["948cb7389da6d4f397f5a0f89caf885a9033c959"],"ad3c006a1d6ec52c49f33c62a3678bf5023d9baf":["718607d99d02778db3280e64975663762c94170d"],"9f5e2ce7174b645aee7b07eab55640cf0b28916b":["dea8e36e8c36d610840396c282a5affe3f722f4e"],"bd9ddb59e9d33950773d186a8b726b5610ae3aad":["17423fb5ef5555fbfa7fe53c15d602faef60ba1a"],"0fa112cb510d1bdb66c944fe9ba78679974d3c14":["b1615f6fc540ecd5dea7b03d2bac9a18bba69d5c"],"817882884229bace7dc5d1b75f6b0e4aa1e47122":["fd92b8bcc88e969302510acf77bd6970da3994c4","c01638f4dd94981c1d3d52c4f7991246a5a24aba"],"dea8e36e8c36d610840396c282a5affe3f722f4e":["1b7910b51406c081814c946331386da674f26aa5"],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":["fe33227f6805edab2036cbb80645cc4e2d1fa424","d97814e287f694bcb4c679646ff4ac52fd8663c6"],"4897c5b415f476d84ec970a19c41510645887526":["08bcaef9e931052e4ca24133a89cc6aefaf61829"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"08bcaef9e931052e4ca24133a89cc6aefaf61829":["bd9ddb59e9d33950773d186a8b726b5610ae3aad"],"718607d99d02778db3280e64975663762c94170d":["2a77b0d8787d127be70f6c4055937ee9c0d4ee3b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["20f6b7cff3771384f27af0f059795d7e64aff6b9"],"1c8719b2c0b382be11f5b193b6fc14bc310e906b":["d97814e287f694bcb4c679646ff4ac52fd8663c6"]},"commit2Childs":{"616c1830142ff5c1ddedec1ed898733b73c8e23b":[],"948cb7389da6d4f397f5a0f89caf885a9033c959":["4dcfb92697fbd03e488cf9e5155514e3270d0fc3"],"be4d0855f94432c9a580ae7750c6f842d604a3e4":["8917bfede3b4ca30f4305c1e391e9218959cd723","bd8bc29700397ec1886e73bae0a67ff536bad223"],"db05ec3460be863c2b1e39675c58b412cd9afdc0":["c01638f4dd94981c1d3d52c4f7991246a5a24aba","fd92b8bcc88e969302510acf77bd6970da3994c4","78a55f24d9b493c2a1cecf79f1d78279062b545b"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"b05c56a41b733e02a189c48895922b5bd8c7f3d1":["70fa1c0f4d75735ff2e1485e059d9bc5efa50598"],"8917bfede3b4ca30f4305c1e391e9218959cd723":[],"d9405f486872f1e416304dfe389741f4ee2f8a4d":["2a77b0d8787d127be70f6c4055937ee9c0d4ee3b","f2126b84bd093fa3d921582a109a0ee578c28126","407687e67faf6e1f02a211ca078d8e3eed631027"],"2a77b0d8787d127be70f6c4055937ee9c0d4ee3b":["718607d99d02778db3280e64975663762c94170d"],"b3c2c17185ad7fb0aa9b81dbd9d0395debbc4519":["37a0f60745e53927c4c876cfe5b5a58170f0646c","74f45af4339b0daf7a95c820ab88c1aea74fbce0","190779ba7de3fda15afd1bbafbc383720a4b0966"],"d97814e287f694bcb4c679646ff4ac52fd8663c6":["aba371508186796cc6151d8223a5b4e16d02e26e","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","1c8719b2c0b382be11f5b193b6fc14bc310e906b"],"aba371508186796cc6151d8223a5b4e16d02e26e":["d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9"],"70fa1c0f4d75735ff2e1485e059d9bc5efa50598":[],"f2126b84bd093fa3d921582a109a0ee578c28126":[],"66c64e8cfded6a585100e6430238faaf416f3fea":["b05c56a41b733e02a189c48895922b5bd8c7f3d1","b6d2d51ff0b489e2d7ddc42a63f0d6cb69326469","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198"],"8dd517686f746fb280a35ebadd0abf38e864fb41":["b3c2c17185ad7fb0aa9b81dbd9d0395debbc4519"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["78a55f24d9b493c2a1cecf79f1d78279062b545b"],"b6d2d51ff0b489e2d7ddc42a63f0d6cb69326469":["616c1830142ff5c1ddedec1ed898733b73c8e23b","d9405f486872f1e416304dfe389741f4ee2f8a4d","70fa1c0f4d75735ff2e1485e059d9bc5efa50598","f2126b84bd093fa3d921582a109a0ee578c28126"],"058801f8673d53a5abac8088204860ec29a40f0d":["37a0f60745e53927c4c876cfe5b5a58170f0646c","d8a3067239133ceb0117bc3d48356169cf03894f"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f"],"8d50ba1695a40ff11a41bbfc1ad45c7bfd6a5738":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","20f6b7cff3771384f27af0f059795d7e64aff6b9"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["8917bfede3b4ca30f4305c1e391e9218959cd723"],"b1615f6fc540ecd5dea7b03d2bac9a18bba69d5c":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","0fa112cb510d1bdb66c944fe9ba78679974d3c14"],"c01638f4dd94981c1d3d52c4f7991246a5a24aba":["17423fb5ef5555fbfa7fe53c15d602faef60ba1a","5b6fdfce35d0adb18836cf8711abe487a934df33","817882884229bace7dc5d1b75f6b0e4aa1e47122"],"1eda2abfda9da3ca2bc5c5872d6b8c0f4948f674":["be4d0855f94432c9a580ae7750c6f842d604a3e4"],"17423fb5ef5555fbfa7fe53c15d602faef60ba1a":["fe33227f6805edab2036cbb80645cc4e2d1fa424","bd9ddb59e9d33950773d186a8b726b5610ae3aad"],"fd92b8bcc88e969302510acf77bd6970da3994c4":["817882884229bace7dc5d1b75f6b0e4aa1e47122"],"d8a3067239133ceb0117bc3d48356169cf03894f":["8dd517686f746fb280a35ebadd0abf38e864fb41"],"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198":["616c1830142ff5c1ddedec1ed898733b73c8e23b"],"bd8bc29700397ec1886e73bae0a67ff536bad223":["948cb7389da6d4f397f5a0f89caf885a9033c959"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["fd92b8bcc88e969302510acf77bd6970da3994c4"],"20f6b7cff3771384f27af0f059795d7e64aff6b9":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":["b05c56a41b733e02a189c48895922b5bd8c7f3d1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","0d22ac6a4146774c1bc8400160fc0b6150294e92","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"5b6fdfce35d0adb18836cf8711abe487a934df33":[],"190779ba7de3fda15afd1bbafbc383720a4b0966":["b1615f6fc540ecd5dea7b03d2bac9a18bba69d5c"],"d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9":["c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198"],"78a55f24d9b493c2a1cecf79f1d78279062b545b":["5b6fdfce35d0adb18836cf8711abe487a934df33"],"407687e67faf6e1f02a211ca078d8e3eed631027":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064"],"1b7910b51406c081814c946331386da674f26aa5":["dea8e36e8c36d610840396c282a5affe3f722f4e"],"4dcfb92697fbd03e488cf9e5155514e3270d0fc3":["058801f8673d53a5abac8088204860ec29a40f0d"],"ad3c006a1d6ec52c49f33c62a3678bf5023d9baf":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","1eda2abfda9da3ca2bc5c5872d6b8c0f4948f674"],"9f5e2ce7174b645aee7b07eab55640cf0b28916b":["8d50ba1695a40ff11a41bbfc1ad45c7bfd6a5738"],"bd9ddb59e9d33950773d186a8b726b5610ae3aad":["aba371508186796cc6151d8223a5b4e16d02e26e","08bcaef9e931052e4ca24133a89cc6aefaf61829"],"0fa112cb510d1bdb66c944fe9ba78679974d3c14":["1b7910b51406c081814c946331386da674f26aa5"],"817882884229bace7dc5d1b75f6b0e4aa1e47122":[],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":["c7869f64c874ebf7f317d22c00baf2b6857797a6"],"dea8e36e8c36d610840396c282a5affe3f722f4e":["9f5e2ce7174b645aee7b07eab55640cf0b28916b"],"4897c5b415f476d84ec970a19c41510645887526":["d97814e287f694bcb4c679646ff4ac52fd8663c6","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["db05ec3460be863c2b1e39675c58b412cd9afdc0","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","0d22ac6a4146774c1bc8400160fc0b6150294e92"],"08bcaef9e931052e4ca24133a89cc6aefaf61829":["4897c5b415f476d84ec970a19c41510645887526"],"718607d99d02778db3280e64975663762c94170d":["407687e67faf6e1f02a211ca078d8e3eed631027","ad3c006a1d6ec52c49f33c62a3678bf5023d9baf"],"1c8719b2c0b382be11f5b193b6fc14bc310e906b":["66c64e8cfded6a585100e6430238faaf416f3fea","c7869f64c874ebf7f317d22c00baf2b6857797a6","d0ba34ddeec9e4ab657150c29a5614a7bfbb53c9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["616c1830142ff5c1ddedec1ed898733b73c8e23b","37a0f60745e53927c4c876cfe5b5a58170f0646c","8917bfede3b4ca30f4305c1e391e9218959cd723","70fa1c0f4d75735ff2e1485e059d9bc5efa50598","f2126b84bd093fa3d921582a109a0ee578c28126","74f45af4339b0daf7a95c820ab88c1aea74fbce0","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","5b6fdfce35d0adb18836cf8711abe487a934df33","817882884229bace7dc5d1b75f6b0e4aa1e47122","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}