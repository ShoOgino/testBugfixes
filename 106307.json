{"path":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#tryAllPermutations(List[String],int[],int,boolean).mjava","commits":[{"id":"8c7a6584aa35e033d783e02c6f4eefa6ad21c7fe","date":1430750405,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#tryAllPermutations(List[String],int[],int,boolean).mjava","pathOld":"/dev/null","sourceNew":"  private Map<Position, String> tryAllPermutations(List<String> shardNames,\n                                                   int[] shardOrder,\n                                                   int nonWildCardShardRules,\n                                                   boolean fuzzyPhase) {\n\n\n    Iterator<int[]> shardPermutations = nonWildCardShardRules > 0 ?\n        permutations(shardNames.size()) :\n        singletonList(shardOrder).iterator();\n\n    for (; shardPermutations.hasNext(); ) {\n      int[] p = shardPermutations.next();\n      for (int i = 0; i < p.length; i++) {\n        List<Position> positions = new ArrayList<>();\n        for (int pos : p) {\n          for (int j = 0; j < shardVsReplicaCount.get(shardNames.get(pos)); j++) {\n            positions.add(new Position(shardNames.get(pos), j));\n          }\n        }\n        Collections.sort(positions);\n        for (Iterator<int[]> it = permutations(rules.size()); it.hasNext(); ) {\n          int[] permutation = it.next();\n          Map<Position, String> result = tryAPermutationOfRules(permutation, positions, fuzzyPhase);\n          if (result != null) return result;\n        }\n      }\n    }\n\n    return null;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["1ec72b74555d8a495bc670cbefeed16fa1b0c145"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1ec72b74555d8a495bc670cbefeed16fa1b0c145","date":1456188153,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#tryAllPermutations(List[String],int[],int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#tryAllPermutations(List[String],int[],int,boolean).mjava","sourceNew":"  private Map<Position, String> tryAllPermutations(List<String> shardNames,\n                                                   int[] shardOrder,\n                                                   int nonWildCardShardRules,\n                                                   boolean fuzzyPhase) {\n\n\n    Iterator<int[]> shardPermutations = nonWildCardShardRules > 0 ?\n        permutations(shardNames.size()) :\n        singletonList(shardOrder).iterator();\n\n    for (; shardPermutations.hasNext(); ) {\n      int[] p = shardPermutations.next();\n      List<Position> positions = new ArrayList<>();\n      for (int pos : p) {\n        for (int j = 0; j < shardVsReplicaCount.get(shardNames.get(pos)); j++) {\n          positions.add(new Position(shardNames.get(pos), j));\n        }\n      }\n      Collections.sort(positions);\n      for (Iterator<int[]> it = permutations(rules.size()); it.hasNext(); ) {\n        int[] permutation = it.next();\n        Map<Position, String> result = tryAPermutationOfRules(permutation, positions, fuzzyPhase);\n        if (result != null) return result;\n      }\n    }\n\n    return null;\n  }\n\n","sourceOld":"  private Map<Position, String> tryAllPermutations(List<String> shardNames,\n                                                   int[] shardOrder,\n                                                   int nonWildCardShardRules,\n                                                   boolean fuzzyPhase) {\n\n\n    Iterator<int[]> shardPermutations = nonWildCardShardRules > 0 ?\n        permutations(shardNames.size()) :\n        singletonList(shardOrder).iterator();\n\n    for (; shardPermutations.hasNext(); ) {\n      int[] p = shardPermutations.next();\n      for (int i = 0; i < p.length; i++) {\n        List<Position> positions = new ArrayList<>();\n        for (int pos : p) {\n          for (int j = 0; j < shardVsReplicaCount.get(shardNames.get(pos)); j++) {\n            positions.add(new Position(shardNames.get(pos), j));\n          }\n        }\n        Collections.sort(positions);\n        for (Iterator<int[]> it = permutations(rules.size()); it.hasNext(); ) {\n          int[] permutation = it.next();\n          Map<Position, String> result = tryAPermutationOfRules(permutation, positions, fuzzyPhase);\n          if (result != null) return result;\n        }\n      }\n    }\n\n    return null;\n  }\n\n","bugFix":["8c7a6584aa35e033d783e02c6f4eefa6ad21c7fe"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"61c45e99cf6676da48f19d7511c73712ad39402b","date":1495508331,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#tryAllPermutations(List[String],int[],int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#tryAllPermutations(List[String],int[],int,boolean).mjava","sourceNew":"  private Map<Position, String> tryAllPermutations(List<String> shardNames,\n                                                   int[] shardOrder,\n                                                   int nonWildCardShardRules,\n                                                   boolean fuzzyPhase) {\n\n\n    Iterator<int[]> shardPermutations = nonWildCardShardRules > 0 ?\n        permutations(shardNames.size()) :\n        singletonList(shardOrder).iterator();\n\n    for (; shardPermutations.hasNext(); ) {\n      int[] p = shardPermutations.next();\n      List<Position> positions = new ArrayList<>();\n      for (int pos : p) {\n        for (int j = 0; j < shardVsReplicaCount.get(shardNames.get(pos)); j++) {\n          positions.add(new Position(shardNames.get(pos), j, Replica.Type.NRT));\n        }\n      }\n      Collections.sort(positions);\n      for (Iterator<int[]> it = permutations(rules.size()); it.hasNext(); ) {\n        int[] permutation = it.next();\n        Map<Position, String> result = tryAPermutationOfRules(permutation, positions, fuzzyPhase);\n        if (result != null) return result;\n      }\n    }\n\n    return null;\n  }\n\n","sourceOld":"  private Map<Position, String> tryAllPermutations(List<String> shardNames,\n                                                   int[] shardOrder,\n                                                   int nonWildCardShardRules,\n                                                   boolean fuzzyPhase) {\n\n\n    Iterator<int[]> shardPermutations = nonWildCardShardRules > 0 ?\n        permutations(shardNames.size()) :\n        singletonList(shardOrder).iterator();\n\n    for (; shardPermutations.hasNext(); ) {\n      int[] p = shardPermutations.next();\n      List<Position> positions = new ArrayList<>();\n      for (int pos : p) {\n        for (int j = 0; j < shardVsReplicaCount.get(shardNames.get(pos)); j++) {\n          positions.add(new Position(shardNames.get(pos), j));\n        }\n      }\n      Collections.sort(positions);\n      for (Iterator<int[]> it = permutations(rules.size()); it.hasNext(); ) {\n        int[] permutation = it.next();\n        Map<Position, String> result = tryAPermutationOfRules(permutation, positions, fuzzyPhase);\n        if (result != null) return result;\n      }\n    }\n\n    return null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#tryAllPermutations(List[String],int[],int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#tryAllPermutations(List[String],int[],int,boolean).mjava","sourceNew":"  private Map<Position, String> tryAllPermutations(List<String> shardNames,\n                                                   int[] shardOrder,\n                                                   int nonWildCardShardRules,\n                                                   boolean fuzzyPhase) {\n\n\n    Iterator<int[]> shardPermutations = nonWildCardShardRules > 0 ?\n        permutations(shardNames.size()) :\n        singletonList(shardOrder).iterator();\n\n    for (; shardPermutations.hasNext(); ) {\n      int[] p = shardPermutations.next();\n      List<Position> positions = new ArrayList<>();\n      for (int pos : p) {\n        for (int j = 0; j < shardVsReplicaCount.get(shardNames.get(pos)); j++) {\n          positions.add(new Position(shardNames.get(pos), j, Replica.Type.NRT));\n        }\n      }\n      Collections.sort(positions);\n      for (Iterator<int[]> it = permutations(rules.size()); it.hasNext(); ) {\n        int[] permutation = it.next();\n        Map<Position, String> result = tryAPermutationOfRules(permutation, positions, fuzzyPhase);\n        if (result != null) return result;\n      }\n    }\n\n    return null;\n  }\n\n","sourceOld":"  private Map<Position, String> tryAllPermutations(List<String> shardNames,\n                                                   int[] shardOrder,\n                                                   int nonWildCardShardRules,\n                                                   boolean fuzzyPhase) {\n\n\n    Iterator<int[]> shardPermutations = nonWildCardShardRules > 0 ?\n        permutations(shardNames.size()) :\n        singletonList(shardOrder).iterator();\n\n    for (; shardPermutations.hasNext(); ) {\n      int[] p = shardPermutations.next();\n      List<Position> positions = new ArrayList<>();\n      for (int pos : p) {\n        for (int j = 0; j < shardVsReplicaCount.get(shardNames.get(pos)); j++) {\n          positions.add(new Position(shardNames.get(pos), j));\n        }\n      }\n      Collections.sort(positions);\n      for (Iterator<int[]> it = permutations(rules.size()); it.hasNext(); ) {\n        int[] permutation = it.next();\n        Map<Position, String> result = tryAPermutationOfRules(permutation, positions, fuzzyPhase);\n        if (result != null) return result;\n      }\n    }\n\n    return null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"969718c368b28ed1b2335ea2deb275c696cddb4f","date":1498803580,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#tryAllPermutations(List[String],int[],int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#tryAllPermutations(List[String],int[],int,boolean).mjava","sourceNew":"  private Map<ReplicaPosition, String> tryAllPermutations(List<String> shardNames,\n                                                          int[] shardOrder,\n                                                          int nonWildCardShardRules,\n                                                          boolean fuzzyPhase) {\n\n\n    Iterator<int[]> shardPermutations = nonWildCardShardRules > 0 ?\n        permutations(shardNames.size()) :\n        singletonList(shardOrder).iterator();\n\n    for (; shardPermutations.hasNext(); ) {\n      int[] p = shardPermutations.next();\n      List<ReplicaPosition> replicaPositions = new ArrayList<>();\n      for (int pos : p) {\n        for (int j = 0; j < shardVsReplicaCount.get(shardNames.get(pos)); j++) {\n          replicaPositions.add(new ReplicaPosition(shardNames.get(pos), j, Replica.Type.NRT));\n        }\n      }\n      Collections.sort(replicaPositions);\n      for (Iterator<int[]> it = permutations(rules.size()); it.hasNext(); ) {\n        int[] permutation = it.next();\n        Map<ReplicaPosition, String> result = tryAPermutationOfRules(permutation, replicaPositions, fuzzyPhase);\n        if (result != null) return result;\n      }\n    }\n\n    return null;\n  }\n\n","sourceOld":"  private Map<Position, String> tryAllPermutations(List<String> shardNames,\n                                                   int[] shardOrder,\n                                                   int nonWildCardShardRules,\n                                                   boolean fuzzyPhase) {\n\n\n    Iterator<int[]> shardPermutations = nonWildCardShardRules > 0 ?\n        permutations(shardNames.size()) :\n        singletonList(shardOrder).iterator();\n\n    for (; shardPermutations.hasNext(); ) {\n      int[] p = shardPermutations.next();\n      List<Position> positions = new ArrayList<>();\n      for (int pos : p) {\n        for (int j = 0; j < shardVsReplicaCount.get(shardNames.get(pos)); j++) {\n          positions.add(new Position(shardNames.get(pos), j, Replica.Type.NRT));\n        }\n      }\n      Collections.sort(positions);\n      for (Iterator<int[]> it = permutations(rules.size()); it.hasNext(); ) {\n        int[] permutation = it.next();\n        Map<Position, String> result = tryAPermutationOfRules(permutation, positions, fuzzyPhase);\n        if (result != null) return result;\n      }\n    }\n\n    return null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d92226151c91fb4bebcca6d18782d1c84aee2cd","date":1498804792,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#tryAllPermutations(List[String],int[],int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#tryAllPermutations(List[String],int[],int,boolean).mjava","sourceNew":"  private Map<ReplicaPosition, String> tryAllPermutations(List<String> shardNames,\n                                                          int[] shardOrder,\n                                                          int nonWildCardShardRules,\n                                                          boolean fuzzyPhase) {\n\n\n    Iterator<int[]> shardPermutations = nonWildCardShardRules > 0 ?\n        permutations(shardNames.size()) :\n        singletonList(shardOrder).iterator();\n\n    for (; shardPermutations.hasNext(); ) {\n      int[] p = shardPermutations.next();\n      List<ReplicaPosition> replicaPositions = new ArrayList<>();\n      for (int pos : p) {\n        for (int j = 0; j < shardVsReplicaCount.get(shardNames.get(pos)); j++) {\n          replicaPositions.add(new ReplicaPosition(shardNames.get(pos), j, Replica.Type.NRT));\n        }\n      }\n      Collections.sort(replicaPositions);\n      for (Iterator<int[]> it = permutations(rules.size()); it.hasNext(); ) {\n        int[] permutation = it.next();\n        Map<ReplicaPosition, String> result = tryAPermutationOfRules(permutation, replicaPositions, fuzzyPhase);\n        if (result != null) return result;\n      }\n    }\n\n    return null;\n  }\n\n","sourceOld":"  private Map<Position, String> tryAllPermutations(List<String> shardNames,\n                                                   int[] shardOrder,\n                                                   int nonWildCardShardRules,\n                                                   boolean fuzzyPhase) {\n\n\n    Iterator<int[]> shardPermutations = nonWildCardShardRules > 0 ?\n        permutations(shardNames.size()) :\n        singletonList(shardOrder).iterator();\n\n    for (; shardPermutations.hasNext(); ) {\n      int[] p = shardPermutations.next();\n      List<Position> positions = new ArrayList<>();\n      for (int pos : p) {\n        for (int j = 0; j < shardVsReplicaCount.get(shardNames.get(pos)); j++) {\n          positions.add(new Position(shardNames.get(pos), j, Replica.Type.NRT));\n        }\n      }\n      Collections.sort(positions);\n      for (Iterator<int[]> it = permutations(rules.size()); it.hasNext(); ) {\n        int[] permutation = it.next();\n        Map<Position, String> result = tryAPermutationOfRules(permutation, positions, fuzzyPhase);\n        if (result != null) return result;\n      }\n    }\n\n    return null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e9017cf144952056066919f1ebc7897ff9bd71b1":["1ec72b74555d8a495bc670cbefeed16fa1b0c145","61c45e99cf6676da48f19d7511c73712ad39402b"],"61c45e99cf6676da48f19d7511c73712ad39402b":["1ec72b74555d8a495bc670cbefeed16fa1b0c145"],"969718c368b28ed1b2335ea2deb275c696cddb4f":["61c45e99cf6676da48f19d7511c73712ad39402b"],"0d92226151c91fb4bebcca6d18782d1c84aee2cd":["e9017cf144952056066919f1ebc7897ff9bd71b1"],"8c7a6584aa35e033d783e02c6f4eefa6ad21c7fe":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1ec72b74555d8a495bc670cbefeed16fa1b0c145":["8c7a6584aa35e033d783e02c6f4eefa6ad21c7fe"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["969718c368b28ed1b2335ea2deb275c696cddb4f"]},"commit2Childs":{"e9017cf144952056066919f1ebc7897ff9bd71b1":["0d92226151c91fb4bebcca6d18782d1c84aee2cd"],"61c45e99cf6676da48f19d7511c73712ad39402b":["e9017cf144952056066919f1ebc7897ff9bd71b1","969718c368b28ed1b2335ea2deb275c696cddb4f"],"969718c368b28ed1b2335ea2deb275c696cddb4f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0d92226151c91fb4bebcca6d18782d1c84aee2cd":[],"8c7a6584aa35e033d783e02c6f4eefa6ad21c7fe":["1ec72b74555d8a495bc670cbefeed16fa1b0c145"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8c7a6584aa35e033d783e02c6f4eefa6ad21c7fe"],"1ec72b74555d8a495bc670cbefeed16fa1b0c145":["e9017cf144952056066919f1ebc7897ff9bd71b1","61c45e99cf6676da48f19d7511c73712ad39402b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["0d92226151c91fb4bebcca6d18782d1c84aee2cd","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}