{"path":"solr/core/src/test/org/apache/solr/update/TestDocBasedVersionConstraints#testConcurrentAdds().mjava","commits":[{"id":"45a4348f3ba3bf4ff6cbb4169fe5bf7d28288cd0","date":1383246815,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestDocBasedVersionConstraints#testConcurrentAdds().mjava","pathOld":"/dev/null","sourceNew":"  /** \n   * Constantly hammer the same doc with multiple concurrent threads and diff versions,\n   * confirm that the highest version wins.\n   */\n  public void testConcurrentAdds() throws Exception {\n    final int NUM_DOCS = atLeast(50);\n    final int MAX_CONCURENT = atLeast(10);\n    ExecutorService runner = Executors.newFixedThreadPool(MAX_CONCURENT);\n    // runner = Executors.newFixedThreadPool(1);    // to test single threaded\n    try {\n      for (int id = 0; id < NUM_DOCS; id++) {\n        final int numAdds = _TestUtil.nextInt(random(),3,MAX_CONCURENT);\n        final int winner = _TestUtil.nextInt(random(),0,numAdds-1);\n        final int winnerVersion = atLeast(100);\n        final boolean winnerIsDeleted = (0 == _TestUtil.nextInt(random(),0,4));\n        List<Callable<Object>> tasks = new ArrayList<Callable<Object>>(numAdds);\n        for (int variant = 0; variant < numAdds; variant++) {\n          final boolean iShouldWin = (variant==winner);\n          final long version = (iShouldWin ? winnerVersion \n                                : _TestUtil.nextInt(random(),1,winnerVersion-1));\n          if ((iShouldWin && winnerIsDeleted)\n              || (!iShouldWin && 0 == _TestUtil.nextInt(random(),0,4))) {\n            tasks.add(delayedDelete(\"\"+id, \"\"+version));\n          } else {\n            tasks.add(delayedAdd(\"id\",\"\"+id,\"name\",\"name\"+id+\"_\"+variant,\n                                 \"my_version_l\", \"\"+ version));\n          }\n        }\n        runner.invokeAll(tasks);\n        final String expectedDoc = \"{'id':'\"+id+\"','my_version_l':\"+winnerVersion +\n          ( ! winnerIsDeleted ? \",'name':'name\"+id+\"_\"+winner+\"'}\" : \"}\");\n\n        assertJQ(req(\"qt\",\"/get\", \"id\",\"\"+id, \"fl\",\"id,name,my_version_l\")\n                 , \"=={'doc':\" + expectedDoc + \"}\");\n        assertU(commit());\n        assertJQ(req(\"q\",\"id:\"+id,\n                     \"fl\",\"id,name,my_version_l\")\n                 ,\"/response/numFound==1\"\n                 ,\"/response/docs==[\"+expectedDoc+\"]\");\n      }\n    } finally {\n      runner.shutdownNow();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"257f1c3d639bda6ee901a2a6c29580a8aa6d3a1a","date":1383256030,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestDocBasedVersionConstraints#testConcurrentAdds().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestDocBasedVersionConstraints#testConcurrentAdds().mjava","sourceNew":"  /** \n   * Constantly hammer the same doc with multiple concurrent threads and diff versions,\n   * confirm that the highest version wins.\n   */\n  public void testConcurrentAdds() throws Exception {\n    final int NUM_DOCS = atLeast(50);\n    final int MAX_CONCURENT = atLeast(10);\n    ExecutorService runner = Executors.newFixedThreadPool(MAX_CONCURENT, new DefaultSolrThreadFactory(\"TestDocBasedVersionConstraints\"));\n    // runner = Executors.newFixedThreadPool(1);    // to test single threaded\n    try {\n      for (int id = 0; id < NUM_DOCS; id++) {\n        final int numAdds = _TestUtil.nextInt(random(),3,MAX_CONCURENT);\n        final int winner = _TestUtil.nextInt(random(),0,numAdds-1);\n        final int winnerVersion = atLeast(100);\n        final boolean winnerIsDeleted = (0 == _TestUtil.nextInt(random(),0,4));\n        List<Callable<Object>> tasks = new ArrayList<Callable<Object>>(numAdds);\n        for (int variant = 0; variant < numAdds; variant++) {\n          final boolean iShouldWin = (variant==winner);\n          final long version = (iShouldWin ? winnerVersion \n                                : _TestUtil.nextInt(random(),1,winnerVersion-1));\n          if ((iShouldWin && winnerIsDeleted)\n              || (!iShouldWin && 0 == _TestUtil.nextInt(random(),0,4))) {\n            tasks.add(delayedDelete(\"\"+id, \"\"+version));\n          } else {\n            tasks.add(delayedAdd(\"id\",\"\"+id,\"name\",\"name\"+id+\"_\"+variant,\n                                 \"my_version_l\", \"\"+ version));\n          }\n        }\n        runner.invokeAll(tasks);\n        final String expectedDoc = \"{'id':'\"+id+\"','my_version_l':\"+winnerVersion +\n          ( ! winnerIsDeleted ? \",'name':'name\"+id+\"_\"+winner+\"'}\" : \"}\");\n\n        assertJQ(req(\"qt\",\"/get\", \"id\",\"\"+id, \"fl\",\"id,name,my_version_l\")\n                 , \"=={'doc':\" + expectedDoc + \"}\");\n        assertU(commit());\n        assertJQ(req(\"q\",\"id:\"+id,\n                     \"fl\",\"id,name,my_version_l\")\n                 ,\"/response/numFound==1\"\n                 ,\"/response/docs==[\"+expectedDoc+\"]\");\n      }\n    } finally {\n      runner.shutdownNow();\n    }\n  }\n\n","sourceOld":"  /** \n   * Constantly hammer the same doc with multiple concurrent threads and diff versions,\n   * confirm that the highest version wins.\n   */\n  public void testConcurrentAdds() throws Exception {\n    final int NUM_DOCS = atLeast(50);\n    final int MAX_CONCURENT = atLeast(10);\n    ExecutorService runner = Executors.newFixedThreadPool(MAX_CONCURENT);\n    // runner = Executors.newFixedThreadPool(1);    // to test single threaded\n    try {\n      for (int id = 0; id < NUM_DOCS; id++) {\n        final int numAdds = _TestUtil.nextInt(random(),3,MAX_CONCURENT);\n        final int winner = _TestUtil.nextInt(random(),0,numAdds-1);\n        final int winnerVersion = atLeast(100);\n        final boolean winnerIsDeleted = (0 == _TestUtil.nextInt(random(),0,4));\n        List<Callable<Object>> tasks = new ArrayList<Callable<Object>>(numAdds);\n        for (int variant = 0; variant < numAdds; variant++) {\n          final boolean iShouldWin = (variant==winner);\n          final long version = (iShouldWin ? winnerVersion \n                                : _TestUtil.nextInt(random(),1,winnerVersion-1));\n          if ((iShouldWin && winnerIsDeleted)\n              || (!iShouldWin && 0 == _TestUtil.nextInt(random(),0,4))) {\n            tasks.add(delayedDelete(\"\"+id, \"\"+version));\n          } else {\n            tasks.add(delayedAdd(\"id\",\"\"+id,\"name\",\"name\"+id+\"_\"+variant,\n                                 \"my_version_l\", \"\"+ version));\n          }\n        }\n        runner.invokeAll(tasks);\n        final String expectedDoc = \"{'id':'\"+id+\"','my_version_l':\"+winnerVersion +\n          ( ! winnerIsDeleted ? \",'name':'name\"+id+\"_\"+winner+\"'}\" : \"}\");\n\n        assertJQ(req(\"qt\",\"/get\", \"id\",\"\"+id, \"fl\",\"id,name,my_version_l\")\n                 , \"=={'doc':\" + expectedDoc + \"}\");\n        assertU(commit());\n        assertJQ(req(\"q\",\"id:\"+id,\n                     \"fl\",\"id,name,my_version_l\")\n                 ,\"/response/numFound==1\"\n                 ,\"/response/docs==[\"+expectedDoc+\"]\");\n      }\n    } finally {\n      runner.shutdownNow();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestDocBasedVersionConstraints#testConcurrentAdds().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestDocBasedVersionConstraints#testConcurrentAdds().mjava","sourceNew":"  /** \n   * Constantly hammer the same doc with multiple concurrent threads and diff versions,\n   * confirm that the highest version wins.\n   */\n  public void testConcurrentAdds() throws Exception {\n    final int NUM_DOCS = atLeast(50);\n    final int MAX_CONCURENT = atLeast(10);\n    ExecutorService runner = Executors.newFixedThreadPool(MAX_CONCURENT, new DefaultSolrThreadFactory(\"TestDocBasedVersionConstraints\"));\n    // runner = Executors.newFixedThreadPool(1);    // to test single threaded\n    try {\n      for (int id = 0; id < NUM_DOCS; id++) {\n        final int numAdds = TestUtil.nextInt(random(), 3, MAX_CONCURENT);\n        final int winner = TestUtil.nextInt(random(), 0, numAdds - 1);\n        final int winnerVersion = atLeast(100);\n        final boolean winnerIsDeleted = (0 == TestUtil.nextInt(random(), 0, 4));\n        List<Callable<Object>> tasks = new ArrayList<Callable<Object>>(numAdds);\n        for (int variant = 0; variant < numAdds; variant++) {\n          final boolean iShouldWin = (variant==winner);\n          final long version = (iShouldWin ? winnerVersion \n                                : TestUtil.nextInt(random(), 1, winnerVersion - 1));\n          if ((iShouldWin && winnerIsDeleted)\n              || (!iShouldWin && 0 == TestUtil.nextInt(random(), 0, 4))) {\n            tasks.add(delayedDelete(\"\"+id, \"\"+version));\n          } else {\n            tasks.add(delayedAdd(\"id\",\"\"+id,\"name\",\"name\"+id+\"_\"+variant,\n                                 \"my_version_l\", \"\"+ version));\n          }\n        }\n        runner.invokeAll(tasks);\n        final String expectedDoc = \"{'id':'\"+id+\"','my_version_l':\"+winnerVersion +\n          ( ! winnerIsDeleted ? \",'name':'name\"+id+\"_\"+winner+\"'}\" : \"}\");\n\n        assertJQ(req(\"qt\",\"/get\", \"id\",\"\"+id, \"fl\",\"id,name,my_version_l\")\n                 , \"=={'doc':\" + expectedDoc + \"}\");\n        assertU(commit());\n        assertJQ(req(\"q\",\"id:\"+id,\n                     \"fl\",\"id,name,my_version_l\")\n                 ,\"/response/numFound==1\"\n                 ,\"/response/docs==[\"+expectedDoc+\"]\");\n      }\n    } finally {\n      runner.shutdownNow();\n    }\n  }\n\n","sourceOld":"  /** \n   * Constantly hammer the same doc with multiple concurrent threads and diff versions,\n   * confirm that the highest version wins.\n   */\n  public void testConcurrentAdds() throws Exception {\n    final int NUM_DOCS = atLeast(50);\n    final int MAX_CONCURENT = atLeast(10);\n    ExecutorService runner = Executors.newFixedThreadPool(MAX_CONCURENT, new DefaultSolrThreadFactory(\"TestDocBasedVersionConstraints\"));\n    // runner = Executors.newFixedThreadPool(1);    // to test single threaded\n    try {\n      for (int id = 0; id < NUM_DOCS; id++) {\n        final int numAdds = _TestUtil.nextInt(random(),3,MAX_CONCURENT);\n        final int winner = _TestUtil.nextInt(random(),0,numAdds-1);\n        final int winnerVersion = atLeast(100);\n        final boolean winnerIsDeleted = (0 == _TestUtil.nextInt(random(),0,4));\n        List<Callable<Object>> tasks = new ArrayList<Callable<Object>>(numAdds);\n        for (int variant = 0; variant < numAdds; variant++) {\n          final boolean iShouldWin = (variant==winner);\n          final long version = (iShouldWin ? winnerVersion \n                                : _TestUtil.nextInt(random(),1,winnerVersion-1));\n          if ((iShouldWin && winnerIsDeleted)\n              || (!iShouldWin && 0 == _TestUtil.nextInt(random(),0,4))) {\n            tasks.add(delayedDelete(\"\"+id, \"\"+version));\n          } else {\n            tasks.add(delayedAdd(\"id\",\"\"+id,\"name\",\"name\"+id+\"_\"+variant,\n                                 \"my_version_l\", \"\"+ version));\n          }\n        }\n        runner.invokeAll(tasks);\n        final String expectedDoc = \"{'id':'\"+id+\"','my_version_l':\"+winnerVersion +\n          ( ! winnerIsDeleted ? \",'name':'name\"+id+\"_\"+winner+\"'}\" : \"}\");\n\n        assertJQ(req(\"qt\",\"/get\", \"id\",\"\"+id, \"fl\",\"id,name,my_version_l\")\n                 , \"=={'doc':\" + expectedDoc + \"}\");\n        assertU(commit());\n        assertJQ(req(\"q\",\"id:\"+id,\n                     \"fl\",\"id,name,my_version_l\")\n                 ,\"/response/numFound==1\"\n                 ,\"/response/docs==[\"+expectedDoc+\"]\");\n      }\n    } finally {\n      runner.shutdownNow();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestDocBasedVersionConstraints#testConcurrentAdds().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestDocBasedVersionConstraints#testConcurrentAdds().mjava","sourceNew":"  /** \n   * Constantly hammer the same doc with multiple concurrent threads and diff versions,\n   * confirm that the highest version wins.\n   */\n  public void testConcurrentAdds() throws Exception {\n    final int NUM_DOCS = atLeast(50);\n    final int MAX_CONCURENT = atLeast(10);\n    ExecutorService runner = Executors.newFixedThreadPool(MAX_CONCURENT, new DefaultSolrThreadFactory(\"TestDocBasedVersionConstraints\"));\n    // runner = Executors.newFixedThreadPool(1);    // to test single threaded\n    try {\n      for (int id = 0; id < NUM_DOCS; id++) {\n        final int numAdds = TestUtil.nextInt(random(), 3, MAX_CONCURENT);\n        final int winner = TestUtil.nextInt(random(), 0, numAdds - 1);\n        final int winnerVersion = atLeast(100);\n        final boolean winnerIsDeleted = (0 == TestUtil.nextInt(random(), 0, 4));\n        List<Callable<Object>> tasks = new ArrayList<>(numAdds);\n        for (int variant = 0; variant < numAdds; variant++) {\n          final boolean iShouldWin = (variant==winner);\n          final long version = (iShouldWin ? winnerVersion \n                                : TestUtil.nextInt(random(), 1, winnerVersion - 1));\n          if ((iShouldWin && winnerIsDeleted)\n              || (!iShouldWin && 0 == TestUtil.nextInt(random(), 0, 4))) {\n            tasks.add(delayedDelete(\"\"+id, \"\"+version));\n          } else {\n            tasks.add(delayedAdd(\"id\",\"\"+id,\"name\",\"name\"+id+\"_\"+variant,\n                                 \"my_version_l\", \"\"+ version));\n          }\n        }\n        runner.invokeAll(tasks);\n        final String expectedDoc = \"{'id':'\"+id+\"','my_version_l':\"+winnerVersion +\n          ( ! winnerIsDeleted ? \",'name':'name\"+id+\"_\"+winner+\"'}\" : \"}\");\n\n        assertJQ(req(\"qt\",\"/get\", \"id\",\"\"+id, \"fl\",\"id,name,my_version_l\")\n                 , \"=={'doc':\" + expectedDoc + \"}\");\n        assertU(commit());\n        assertJQ(req(\"q\",\"id:\"+id,\n                     \"fl\",\"id,name,my_version_l\")\n                 ,\"/response/numFound==1\"\n                 ,\"/response/docs==[\"+expectedDoc+\"]\");\n      }\n    } finally {\n      runner.shutdownNow();\n    }\n  }\n\n","sourceOld":"  /** \n   * Constantly hammer the same doc with multiple concurrent threads and diff versions,\n   * confirm that the highest version wins.\n   */\n  public void testConcurrentAdds() throws Exception {\n    final int NUM_DOCS = atLeast(50);\n    final int MAX_CONCURENT = atLeast(10);\n    ExecutorService runner = Executors.newFixedThreadPool(MAX_CONCURENT, new DefaultSolrThreadFactory(\"TestDocBasedVersionConstraints\"));\n    // runner = Executors.newFixedThreadPool(1);    // to test single threaded\n    try {\n      for (int id = 0; id < NUM_DOCS; id++) {\n        final int numAdds = TestUtil.nextInt(random(), 3, MAX_CONCURENT);\n        final int winner = TestUtil.nextInt(random(), 0, numAdds - 1);\n        final int winnerVersion = atLeast(100);\n        final boolean winnerIsDeleted = (0 == TestUtil.nextInt(random(), 0, 4));\n        List<Callable<Object>> tasks = new ArrayList<Callable<Object>>(numAdds);\n        for (int variant = 0; variant < numAdds; variant++) {\n          final boolean iShouldWin = (variant==winner);\n          final long version = (iShouldWin ? winnerVersion \n                                : TestUtil.nextInt(random(), 1, winnerVersion - 1));\n          if ((iShouldWin && winnerIsDeleted)\n              || (!iShouldWin && 0 == TestUtil.nextInt(random(), 0, 4))) {\n            tasks.add(delayedDelete(\"\"+id, \"\"+version));\n          } else {\n            tasks.add(delayedAdd(\"id\",\"\"+id,\"name\",\"name\"+id+\"_\"+variant,\n                                 \"my_version_l\", \"\"+ version));\n          }\n        }\n        runner.invokeAll(tasks);\n        final String expectedDoc = \"{'id':'\"+id+\"','my_version_l':\"+winnerVersion +\n          ( ! winnerIsDeleted ? \",'name':'name\"+id+\"_\"+winner+\"'}\" : \"}\");\n\n        assertJQ(req(\"qt\",\"/get\", \"id\",\"\"+id, \"fl\",\"id,name,my_version_l\")\n                 , \"=={'doc':\" + expectedDoc + \"}\");\n        assertU(commit());\n        assertJQ(req(\"q\",\"id:\"+id,\n                     \"fl\",\"id,name,my_version_l\")\n                 ,\"/response/numFound==1\"\n                 ,\"/response/docs==[\"+expectedDoc+\"]\");\n      }\n    } finally {\n      runner.shutdownNow();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f8973f28b29873ff0d7a016e562c9036ae649a9","date":1428098193,"type":3,"author":"Ramkumar Aiyengar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestDocBasedVersionConstraints#testConcurrentAdds().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestDocBasedVersionConstraints#testConcurrentAdds().mjava","sourceNew":"  /** \n   * Constantly hammer the same doc with multiple concurrent threads and diff versions,\n   * confirm that the highest version wins.\n   */\n  public void testConcurrentAdds() throws Exception {\n    final int NUM_DOCS = atLeast(50);\n    final int MAX_CONCURENT = atLeast(10);\n    ExecutorService runner = Executors.newFixedThreadPool(MAX_CONCURENT, new DefaultSolrThreadFactory(\"TestDocBasedVersionConstraints\"));\n    // runner = Executors.newFixedThreadPool(1);    // to test single threaded\n    try {\n      for (int id = 0; id < NUM_DOCS; id++) {\n        final int numAdds = TestUtil.nextInt(random(), 3, MAX_CONCURENT);\n        final int winner = TestUtil.nextInt(random(), 0, numAdds - 1);\n        final int winnerVersion = atLeast(100);\n        final boolean winnerIsDeleted = (0 == TestUtil.nextInt(random(), 0, 4));\n        List<Callable<Object>> tasks = new ArrayList<>(numAdds);\n        for (int variant = 0; variant < numAdds; variant++) {\n          final boolean iShouldWin = (variant==winner);\n          final long version = (iShouldWin ? winnerVersion \n                                : TestUtil.nextInt(random(), 1, winnerVersion - 1));\n          if ((iShouldWin && winnerIsDeleted)\n              || (!iShouldWin && 0 == TestUtil.nextInt(random(), 0, 4))) {\n            tasks.add(delayedDelete(\"\"+id, \"\"+version));\n          } else {\n            tasks.add(delayedAdd(\"id\",\"\"+id,\"name\",\"name\"+id+\"_\"+variant,\n                                 \"my_version_l\", \"\"+ version));\n          }\n        }\n        runner.invokeAll(tasks);\n        final String expectedDoc = \"{'id':'\"+id+\"','my_version_l':\"+winnerVersion +\n          ( ! winnerIsDeleted ? \",'name':'name\"+id+\"_\"+winner+\"'}\" : \"}\");\n\n        assertJQ(req(\"qt\",\"/get\", \"id\",\"\"+id, \"fl\",\"id,name,my_version_l\")\n                 , \"=={'doc':\" + expectedDoc + \"}\");\n        assertU(commit());\n        assertJQ(req(\"q\",\"id:\"+id,\n                     \"fl\",\"id,name,my_version_l\")\n                 ,\"/response/numFound==1\"\n                 ,\"/response/docs==[\"+expectedDoc+\"]\");\n      }\n    } finally {\n      runner.shutdownNow();\n    }\n  }\n\n","sourceOld":"  /** \n   * Constantly hammer the same doc with multiple concurrent threads and diff versions,\n   * confirm that the highest version wins.\n   */\n  public void testConcurrentAdds() throws Exception {\n    final int NUM_DOCS = atLeast(50);\n    final int MAX_CONCURENT = atLeast(10);\n    ExecutorService runner = Executors.newFixedThreadPool(MAX_CONCURENT, new DefaultSolrThreadFactory(\"TestDocBasedVersionConstraints\"));\n    // runner = Executors.newFixedThreadPool(1);    // to test single threaded\n    try {\n      for (int id = 0; id < NUM_DOCS; id++) {\n        final int numAdds = TestUtil.nextInt(random(), 3, MAX_CONCURENT);\n        final int winner = TestUtil.nextInt(random(), 0, numAdds - 1);\n        final int winnerVersion = atLeast(100);\n        final boolean winnerIsDeleted = (0 == TestUtil.nextInt(random(), 0, 4));\n        List<Callable<Object>> tasks = new ArrayList<>(numAdds);\n        for (int variant = 0; variant < numAdds; variant++) {\n          final boolean iShouldWin = (variant==winner);\n          final long version = (iShouldWin ? winnerVersion \n                                : TestUtil.nextInt(random(), 1, winnerVersion - 1));\n          if ((iShouldWin && winnerIsDeleted)\n              || (!iShouldWin && 0 == TestUtil.nextInt(random(), 0, 4))) {\n            tasks.add(delayedDelete(\"\"+id, \"\"+version));\n          } else {\n            tasks.add(delayedAdd(\"id\",\"\"+id,\"name\",\"name\"+id+\"_\"+variant,\n                                 \"my_version_l\", \"\"+ version));\n          }\n        }\n        runner.invokeAll(tasks);\n        final String expectedDoc = \"{'id':'\"+id+\"','my_version_l':\"+winnerVersion +\n          ( ! winnerIsDeleted ? \",'name':'name\"+id+\"_\"+winner+\"'}\" : \"}\");\n\n        assertJQ(req(\"qt\",\"/get\", \"id\",\"\"+id, \"fl\",\"id,name,my_version_l\")\n                 , \"=={'doc':\" + expectedDoc + \"}\");\n        assertU(commit());\n        assertJQ(req(\"q\",\"id:\"+id,\n                     \"fl\",\"id,name,my_version_l\")\n                 ,\"/response/numFound==1\"\n                 ,\"/response/docs==[\"+expectedDoc+\"]\");\n      }\n    } finally {\n      runner.shutdownNow();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cb5af3afeddbb803fb785098176e6e177c34261b","date":1428905393,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestDocBasedVersionConstraints#testConcurrentAdds().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestDocBasedVersionConstraints#testConcurrentAdds().mjava","sourceNew":"  /** \n   * Constantly hammer the same doc with multiple concurrent threads and diff versions,\n   * confirm that the highest version wins.\n   */\n  public void testConcurrentAdds() throws Exception {\n    final int NUM_DOCS = atLeast(50);\n    final int MAX_CONCURENT = atLeast(10);\n    ExecutorService runner = ExecutorUtil.newMDCAwareFixedThreadPool(MAX_CONCURENT, new DefaultSolrThreadFactory(\"TestDocBasedVersionConstraints\"));\n    // runner = Executors.newFixedThreadPool(1);    // to test single threaded\n    try {\n      for (int id = 0; id < NUM_DOCS; id++) {\n        final int numAdds = TestUtil.nextInt(random(), 3, MAX_CONCURENT);\n        final int winner = TestUtil.nextInt(random(), 0, numAdds - 1);\n        final int winnerVersion = atLeast(100);\n        final boolean winnerIsDeleted = (0 == TestUtil.nextInt(random(), 0, 4));\n        List<Callable<Object>> tasks = new ArrayList<>(numAdds);\n        for (int variant = 0; variant < numAdds; variant++) {\n          final boolean iShouldWin = (variant==winner);\n          final long version = (iShouldWin ? winnerVersion \n                                : TestUtil.nextInt(random(), 1, winnerVersion - 1));\n          if ((iShouldWin && winnerIsDeleted)\n              || (!iShouldWin && 0 == TestUtil.nextInt(random(), 0, 4))) {\n            tasks.add(delayedDelete(\"\"+id, \"\"+version));\n          } else {\n            tasks.add(delayedAdd(\"id\",\"\"+id,\"name\",\"name\"+id+\"_\"+variant,\n                                 \"my_version_l\", \"\"+ version));\n          }\n        }\n        runner.invokeAll(tasks);\n        final String expectedDoc = \"{'id':'\"+id+\"','my_version_l':\"+winnerVersion +\n          ( ! winnerIsDeleted ? \",'name':'name\"+id+\"_\"+winner+\"'}\" : \"}\");\n\n        assertJQ(req(\"qt\",\"/get\", \"id\",\"\"+id, \"fl\",\"id,name,my_version_l\")\n                 , \"=={'doc':\" + expectedDoc + \"}\");\n        assertU(commit());\n        assertJQ(req(\"q\",\"id:\"+id,\n                     \"fl\",\"id,name,my_version_l\")\n                 ,\"/response/numFound==1\"\n                 ,\"/response/docs==[\"+expectedDoc+\"]\");\n      }\n    } finally {\n      ExecutorUtil.shutdownAndAwaitTermination(runner);\n    }\n  }\n\n","sourceOld":"  /** \n   * Constantly hammer the same doc with multiple concurrent threads and diff versions,\n   * confirm that the highest version wins.\n   */\n  public void testConcurrentAdds() throws Exception {\n    final int NUM_DOCS = atLeast(50);\n    final int MAX_CONCURENT = atLeast(10);\n    ExecutorService runner = Executors.newFixedThreadPool(MAX_CONCURENT, new DefaultSolrThreadFactory(\"TestDocBasedVersionConstraints\"));\n    // runner = Executors.newFixedThreadPool(1);    // to test single threaded\n    try {\n      for (int id = 0; id < NUM_DOCS; id++) {\n        final int numAdds = TestUtil.nextInt(random(), 3, MAX_CONCURENT);\n        final int winner = TestUtil.nextInt(random(), 0, numAdds - 1);\n        final int winnerVersion = atLeast(100);\n        final boolean winnerIsDeleted = (0 == TestUtil.nextInt(random(), 0, 4));\n        List<Callable<Object>> tasks = new ArrayList<>(numAdds);\n        for (int variant = 0; variant < numAdds; variant++) {\n          final boolean iShouldWin = (variant==winner);\n          final long version = (iShouldWin ? winnerVersion \n                                : TestUtil.nextInt(random(), 1, winnerVersion - 1));\n          if ((iShouldWin && winnerIsDeleted)\n              || (!iShouldWin && 0 == TestUtil.nextInt(random(), 0, 4))) {\n            tasks.add(delayedDelete(\"\"+id, \"\"+version));\n          } else {\n            tasks.add(delayedAdd(\"id\",\"\"+id,\"name\",\"name\"+id+\"_\"+variant,\n                                 \"my_version_l\", \"\"+ version));\n          }\n        }\n        runner.invokeAll(tasks);\n        final String expectedDoc = \"{'id':'\"+id+\"','my_version_l':\"+winnerVersion +\n          ( ! winnerIsDeleted ? \",'name':'name\"+id+\"_\"+winner+\"'}\" : \"}\");\n\n        assertJQ(req(\"qt\",\"/get\", \"id\",\"\"+id, \"fl\",\"id,name,my_version_l\")\n                 , \"=={'doc':\" + expectedDoc + \"}\");\n        assertU(commit());\n        assertJQ(req(\"q\",\"id:\"+id,\n                     \"fl\",\"id,name,my_version_l\")\n                 ,\"/response/numFound==1\"\n                 ,\"/response/docs==[\"+expectedDoc+\"]\");\n      }\n    } finally {\n      runner.shutdownNow();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"667eea18b7ca87af38d05d81d479f943a717a6b1","date":1548452298,"type":5,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/processor/TestDocBasedVersionConstraints#testConcurrentAdds().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestDocBasedVersionConstraints#testConcurrentAdds().mjava","sourceNew":"  /** \n   * Constantly hammer the same doc with multiple concurrent threads and diff versions,\n   * confirm that the highest version wins.\n   */\n  public void testConcurrentAdds() throws Exception {\n    final int NUM_DOCS = atLeast(50);\n    final int MAX_CONCURENT = atLeast(10);\n    ExecutorService runner = ExecutorUtil.newMDCAwareFixedThreadPool(MAX_CONCURENT, new DefaultSolrThreadFactory(\"TestDocBasedVersionConstraints\"));\n    // runner = Executors.newFixedThreadPool(1);    // to test single threaded\n    try {\n      for (int id = 0; id < NUM_DOCS; id++) {\n        final int numAdds = TestUtil.nextInt(random(), 3, MAX_CONCURENT);\n        final int winner = TestUtil.nextInt(random(), 0, numAdds - 1);\n        final int winnerVersion = atLeast(100);\n        final boolean winnerIsDeleted = (0 == TestUtil.nextInt(random(), 0, 4));\n        List<Callable<Object>> tasks = new ArrayList<>(numAdds);\n        for (int variant = 0; variant < numAdds; variant++) {\n          final boolean iShouldWin = (variant==winner);\n          final long version = (iShouldWin ? winnerVersion \n                                : TestUtil.nextInt(random(), 1, winnerVersion - 1));\n          if ((iShouldWin && winnerIsDeleted)\n              || (!iShouldWin && 0 == TestUtil.nextInt(random(), 0, 4))) {\n            tasks.add(delayedDelete(\"\"+id, \"\"+version));\n          } else {\n            tasks.add(delayedAdd(\"id\",\"\"+id,\"name\",\"name\"+id+\"_\"+variant,\n                                 \"my_version_l\", \"\"+ version));\n          }\n        }\n        runner.invokeAll(tasks);\n        final String expectedDoc = \"{'id':'\"+id+\"','my_version_l':\"+winnerVersion +\n          ( ! winnerIsDeleted ? \",'name':'name\"+id+\"_\"+winner+\"'}\" : \"}\");\n\n        assertJQ(req(\"qt\",\"/get\", \"id\",\"\"+id, \"fl\",\"id,name,my_version_l\")\n                 , \"=={'doc':\" + expectedDoc + \"}\");\n        assertU(commit());\n        assertJQ(req(\"q\",\"id:\"+id,\n                     \"fl\",\"id,name,my_version_l\")\n                 ,\"/response/numFound==1\"\n                 ,\"/response/docs==[\"+expectedDoc+\"]\");\n      }\n    } finally {\n      ExecutorUtil.shutdownAndAwaitTermination(runner);\n    }\n  }\n\n","sourceOld":"  /** \n   * Constantly hammer the same doc with multiple concurrent threads and diff versions,\n   * confirm that the highest version wins.\n   */\n  public void testConcurrentAdds() throws Exception {\n    final int NUM_DOCS = atLeast(50);\n    final int MAX_CONCURENT = atLeast(10);\n    ExecutorService runner = ExecutorUtil.newMDCAwareFixedThreadPool(MAX_CONCURENT, new DefaultSolrThreadFactory(\"TestDocBasedVersionConstraints\"));\n    // runner = Executors.newFixedThreadPool(1);    // to test single threaded\n    try {\n      for (int id = 0; id < NUM_DOCS; id++) {\n        final int numAdds = TestUtil.nextInt(random(), 3, MAX_CONCURENT);\n        final int winner = TestUtil.nextInt(random(), 0, numAdds - 1);\n        final int winnerVersion = atLeast(100);\n        final boolean winnerIsDeleted = (0 == TestUtil.nextInt(random(), 0, 4));\n        List<Callable<Object>> tasks = new ArrayList<>(numAdds);\n        for (int variant = 0; variant < numAdds; variant++) {\n          final boolean iShouldWin = (variant==winner);\n          final long version = (iShouldWin ? winnerVersion \n                                : TestUtil.nextInt(random(), 1, winnerVersion - 1));\n          if ((iShouldWin && winnerIsDeleted)\n              || (!iShouldWin && 0 == TestUtil.nextInt(random(), 0, 4))) {\n            tasks.add(delayedDelete(\"\"+id, \"\"+version));\n          } else {\n            tasks.add(delayedAdd(\"id\",\"\"+id,\"name\",\"name\"+id+\"_\"+variant,\n                                 \"my_version_l\", \"\"+ version));\n          }\n        }\n        runner.invokeAll(tasks);\n        final String expectedDoc = \"{'id':'\"+id+\"','my_version_l':\"+winnerVersion +\n          ( ! winnerIsDeleted ? \",'name':'name\"+id+\"_\"+winner+\"'}\" : \"}\");\n\n        assertJQ(req(\"qt\",\"/get\", \"id\",\"\"+id, \"fl\",\"id,name,my_version_l\")\n                 , \"=={'doc':\" + expectedDoc + \"}\");\n        assertU(commit());\n        assertJQ(req(\"q\",\"id:\"+id,\n                     \"fl\",\"id,name,my_version_l\")\n                 ,\"/response/numFound==1\"\n                 ,\"/response/docs==[\"+expectedDoc+\"]\");\n      }\n    } finally {\n      ExecutorUtil.shutdownAndAwaitTermination(runner);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["6613659748fe4411a7dcf85266e55db1f95f7315"],"257f1c3d639bda6ee901a2a6c29580a8aa6d3a1a":["45a4348f3ba3bf4ff6cbb4169fe5bf7d28288cd0"],"6613659748fe4411a7dcf85266e55db1f95f7315":["257f1c3d639bda6ee901a2a6c29580a8aa6d3a1a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"45a4348f3ba3bf4ff6cbb4169fe5bf7d28288cd0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"667eea18b7ca87af38d05d81d479f943a717a6b1":["cb5af3afeddbb803fb785098176e6e177c34261b"],"3f8973f28b29873ff0d7a016e562c9036ae649a9":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"cb5af3afeddbb803fb785098176e6e177c34261b":["3f8973f28b29873ff0d7a016e562c9036ae649a9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["667eea18b7ca87af38d05d81d479f943a717a6b1"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["3f8973f28b29873ff0d7a016e562c9036ae649a9"],"257f1c3d639bda6ee901a2a6c29580a8aa6d3a1a":["6613659748fe4411a7dcf85266e55db1f95f7315"],"6613659748fe4411a7dcf85266e55db1f95f7315":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["45a4348f3ba3bf4ff6cbb4169fe5bf7d28288cd0"],"45a4348f3ba3bf4ff6cbb4169fe5bf7d28288cd0":["257f1c3d639bda6ee901a2a6c29580a8aa6d3a1a"],"667eea18b7ca87af38d05d81d479f943a717a6b1":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3f8973f28b29873ff0d7a016e562c9036ae649a9":["cb5af3afeddbb803fb785098176e6e177c34261b"],"cb5af3afeddbb803fb785098176e6e177c34261b":["667eea18b7ca87af38d05d81d479f943a717a6b1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}