{"path":"modules/analysis/kuromoji/src/java/org/apache/lucene/analysis/ja/JapaneseTokenizer#add(Dictionary,Position,int,int,Type,boolean).mjava","commits":[{"id":"98d45c1ff2c99694b6de2201175f9b8b8b27b597","date":1332757908,"type":1,"author":"Christian Moen","isMerge":false,"pathNew":"modules/analysis/kuromoji/src/java/org/apache/lucene/analysis/ja/JapaneseTokenizer#add(Dictionary,Position,int,int,Type,boolean).mjava","pathOld":"modules/analysis/kuromoji/src/java/org/apache/lucene/analysis/kuromoji/KuromojiTokenizer#add(Dictionary,Position,int,int,Type,boolean).mjava","sourceNew":"  private void add(Dictionary dict, Position fromPosData, int endPos, int wordID, Type type, boolean addPenalty) throws IOException {\n    final int wordCost = dict.getWordCost(wordID);\n    final int leftID = dict.getLeftId(wordID);\n    int leastCost = Integer.MAX_VALUE;\n    int leastIDX = -1;\n    assert fromPosData.count > 0;\n    for(int idx=0;idx<fromPosData.count;idx++) {\n      // Cost is path cost so far, plus word cost (added at\n      // end of loop), plus bigram cost:\n      final int cost = fromPosData.costs[idx] + costs.get(fromPosData.lastRightID[idx], leftID);\n      if (VERBOSE) {\n        System.out.println(\"      fromIDX=\" + idx + \": cost=\" + cost + \" (prevCost=\" + fromPosData.costs[idx] + \" wordCost=\" + wordCost + \" bgCost=\" + costs.get(fromPosData.lastRightID[idx], leftID) + \" leftID=\" + leftID);\n      }\n      if (cost < leastCost) {\n        leastCost = cost;\n        leastIDX = idx;\n        if (VERBOSE) {\n          System.out.println(\"        **\");\n        }\n      }\n    }\n\n    leastCost += wordCost;\n\n    if (VERBOSE) {\n      System.out.println(\"      + cost=\" + leastCost + \" wordID=\" + wordID + \" leftID=\" + leftID + \" leastIDX=\" + leastIDX + \" toPos=\" + endPos + \" toPos.idx=\" + positions.get(endPos).count);\n    }\n\n    if ((addPenalty || (!outputCompounds && searchMode)) && type != Type.USER) {\n      final int penalty = computePenalty(fromPosData.pos, endPos - fromPosData.pos);\n      if (VERBOSE) {\n        if (penalty > 0) {\n          System.out.println(\"        + penalty=\" + penalty + \" cost=\" + (leastCost+penalty));\n        }\n      }\n      leastCost += penalty;\n    }\n\n    //positions.get(endPos).add(leastCost, dict.getRightId(wordID), fromPosData.pos, leastIDX, wordID, type);\n    assert leftID == dict.getRightId(wordID);\n    positions.get(endPos).add(leastCost, leftID, fromPosData.pos, leastIDX, wordID, type);\n  }\n\n","sourceOld":"  private void add(Dictionary dict, Position fromPosData, int endPos, int wordID, Type type, boolean addPenalty) throws IOException {\n    final int wordCost = dict.getWordCost(wordID);\n    final int leftID = dict.getLeftId(wordID);\n    int leastCost = Integer.MAX_VALUE;\n    int leastIDX = -1;\n    assert fromPosData.count > 0;\n    for(int idx=0;idx<fromPosData.count;idx++) {\n      // Cost is path cost so far, plus word cost (added at\n      // end of loop), plus bigram cost:\n      final int cost = fromPosData.costs[idx] + costs.get(fromPosData.lastRightID[idx], leftID);\n      if (VERBOSE) {\n        System.out.println(\"      fromIDX=\" + idx + \": cost=\" + cost + \" (prevCost=\" + fromPosData.costs[idx] + \" wordCost=\" + wordCost + \" bgCost=\" + costs.get(fromPosData.lastRightID[idx], leftID) + \" leftID=\" + leftID);\n      }\n      if (cost < leastCost) {\n        leastCost = cost;\n        leastIDX = idx;\n        if (VERBOSE) {\n          System.out.println(\"        **\");\n        }\n      }\n    }\n\n    leastCost += wordCost;\n\n    if (VERBOSE) {\n      System.out.println(\"      + cost=\" + leastCost + \" wordID=\" + wordID + \" leftID=\" + leftID + \" leastIDX=\" + leastIDX + \" toPos=\" + endPos + \" toPos.idx=\" + positions.get(endPos).count);\n    }\n\n    if ((addPenalty || (!outputCompounds && searchMode)) && type != Type.USER) {\n      final int penalty = computePenalty(fromPosData.pos, endPos - fromPosData.pos);\n      if (VERBOSE) {\n        if (penalty > 0) {\n          System.out.println(\"        + penalty=\" + penalty + \" cost=\" + (leastCost+penalty));\n        }\n      }\n      leastCost += penalty;\n    }\n\n    //positions.get(endPos).add(leastCost, dict.getRightId(wordID), fromPosData.pos, leastIDX, wordID, type);\n    assert leftID == dict.getRightId(wordID);\n    positions.get(endPos).add(leastCost, leftID, fromPosData.pos, leastIDX, wordID, type);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/kuromoji/src/java/org/apache/lucene/analysis/ja/JapaneseTokenizer#add(Dictionary,Position,int,int,Type,boolean).mjava","pathOld":"modules/analysis/kuromoji/src/java/org/apache/lucene/analysis/ja/JapaneseTokenizer#add(Dictionary,Position,int,int,Type,boolean).mjava","sourceNew":"  private void add(Dictionary dict, Position fromPosData, int endPos, int wordID, Type type, boolean addPenalty) throws IOException {\n    final int wordCost = dict.getWordCost(wordID);\n    final int leftID = dict.getLeftId(wordID);\n    int leastCost = Integer.MAX_VALUE;\n    int leastIDX = -1;\n    assert fromPosData.count > 0;\n    for(int idx=0;idx<fromPosData.count;idx++) {\n      // Cost is path cost so far, plus word cost (added at\n      // end of loop), plus bigram cost:\n      final int cost = fromPosData.costs[idx] + costs.get(fromPosData.lastRightID[idx], leftID);\n      if (VERBOSE) {\n        System.out.println(\"      fromIDX=\" + idx + \": cost=\" + cost + \" (prevCost=\" + fromPosData.costs[idx] + \" wordCost=\" + wordCost + \" bgCost=\" + costs.get(fromPosData.lastRightID[idx], leftID) + \" leftID=\" + leftID);\n      }\n      if (cost < leastCost) {\n        leastCost = cost;\n        leastIDX = idx;\n        if (VERBOSE) {\n          System.out.println(\"        **\");\n        }\n      }\n    }\n\n    leastCost += wordCost;\n\n    if (VERBOSE) {\n      System.out.println(\"      + cost=\" + leastCost + \" wordID=\" + wordID + \" leftID=\" + leftID + \" leastIDX=\" + leastIDX + \" toPos=\" + endPos + \" toPos.idx=\" + positions.get(endPos).count);\n    }\n\n    if ((addPenalty || (!outputCompounds && searchMode)) && type != Type.USER) {\n      final int penalty = computePenalty(fromPosData.pos, endPos - fromPosData.pos);\n      if (VERBOSE) {\n        if (penalty > 0) {\n          System.out.println(\"        + penalty=\" + penalty + \" cost=\" + (leastCost+penalty));\n        }\n      }\n      leastCost += penalty;\n    }\n\n    //positions.get(endPos).add(leastCost, dict.getRightId(wordID), fromPosData.pos, leastIDX, wordID, type);\n    assert leftID == dict.getRightId(wordID);\n    positions.get(endPos).add(leastCost, leftID, fromPosData.pos, leastIDX, wordID, type);\n  }\n\n","sourceOld":"  private void add(Dictionary dict, Position fromPosData, int endPos, int wordID, Type type, boolean addPenalty) throws IOException {\n    final int wordCost = dict.getWordCost(wordID);\n    final int leftID = dict.getLeftId(wordID);\n    int leastCost = Integer.MAX_VALUE;\n    int leastIDX = -1;\n    assert fromPosData.count > 0;\n    for(int idx=0;idx<fromPosData.count;idx++) {\n      // Cost is path cost so far, plus word cost (added at\n      // end of loop), plus bigram cost:\n      final int cost = fromPosData.costs[idx] + costs.get(fromPosData.lastRightID[idx], leftID);\n      if (VERBOSE) {\n        System.out.println(\"      fromIDX=\" + idx + \": cost=\" + cost + \" (prevCost=\" + fromPosData.costs[idx] + \" wordCost=\" + wordCost + \" bgCost=\" + costs.get(fromPosData.lastRightID[idx], leftID) + \" leftID=\" + leftID);\n      }\n      if (cost < leastCost) {\n        leastCost = cost;\n        leastIDX = idx;\n        if (VERBOSE) {\n          System.out.println(\"        **\");\n        }\n      }\n    }\n\n    leastCost += wordCost;\n\n    if (VERBOSE) {\n      System.out.println(\"      + cost=\" + leastCost + \" wordID=\" + wordID + \" leftID=\" + leftID + \" leastIDX=\" + leastIDX + \" toPos=\" + endPos + \" toPos.idx=\" + positions.get(endPos).count);\n    }\n\n    if ((addPenalty || (!outputCompounds && searchMode)) && type != Type.USER) {\n      final int penalty = computePenalty(fromPosData.pos, endPos - fromPosData.pos);\n      if (VERBOSE) {\n        if (penalty > 0) {\n          System.out.println(\"        + penalty=\" + penalty + \" cost=\" + (leastCost+penalty));\n        }\n      }\n      leastCost += penalty;\n    }\n\n    //positions.get(endPos).add(leastCost, dict.getRightId(wordID), fromPosData.pos, leastIDX, wordID, type);\n    assert leftID == dict.getRightId(wordID);\n    positions.get(endPos).add(leastCost, leftID, fromPosData.pos, leastIDX, wordID, type);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["98d45c1ff2c99694b6de2201175f9b8b8b27b597"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"98d45c1ff2c99694b6de2201175f9b8b8b27b597":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b89678825b68eccaf09e6ab71675fc0b0af1e099"]},"commit2Childs":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["98d45c1ff2c99694b6de2201175f9b8b8b27b597"],"98d45c1ff2c99694b6de2201175f9b8b8b27b597":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}