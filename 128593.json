{"path":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/CategoryPath#CategoryPath(String,char).mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/CategoryPath#CategoryPath(String,char).mjava","pathOld":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/CategoryPath#CategoryPath(String,char).mjava","sourceNew":"  /**\n   * Construct a new CategoryPath object, given a single string with\n   * components separated by a given delimiter character.\n   * <P>\n   * The initial capacity of the constructed object will be exactly what is\n   * needed to hold the given path. This fact is convenient when creating a\n   * temporary object that will not be reused later.\n   */\n  public CategoryPath(String pathString, char delimiter) {\n    if (pathString.length() == 0) {\n      ncomponents = 0;\n      chars = new char[0];\n      ends = new short[0];\n      return;\n    }\n\n    // This constructor is often used for creating a temporary object\n    // (one which will not be reused to hold multiple paths), so we want\n    // to do our best to allocate exactly the needed size - not less (to\n    // avoid reallocation) and not more (so as not to waste space).\n    // To do this, we unfortunately need to make an additional pass on the\n    // given string:\n    int nparts = 1;\n    for (int i = pathString.indexOf(delimiter); i >= 0; i = pathString\n        .indexOf(delimiter, i + 1)) {\n      nparts++;\n    }\n\n    ends = new short[nparts];\n    chars = new char[pathString.length() - nparts + 1];\n    ncomponents = 0;\n\n    add(pathString, delimiter);\n  }\n\n","sourceOld":"  /**\n   * Construct a new CategoryPath object, given a single string with\n   * components separated by a given delimiter character.\n   * <P>\n   * The initial capacity of the constructed object will be exactly what is\n   * needed to hold the given path. This fact is convenient when creating a\n   * temporary object that will not be reused later.\n   */\n  public CategoryPath(String pathString, char delimiter) {\n    if (pathString.length() == 0) {\n      ncomponents = 0;\n      chars = new char[0];\n      ends = new short[0];\n      return;\n    }\n\n    // This constructor is often used for creating a temporary object\n    // (one which will not be reused to hold multiple paths), so we want\n    // to do our best to allocate exactly the needed size - not less (to\n    // avoid reallocation) and not more (so as not to waste space).\n    // To do this, we unfortunately need to make an additional pass on the\n    // given string:\n    int nparts = 1;\n    for (int i = pathString.indexOf(delimiter); i >= 0; i = pathString\n        .indexOf(delimiter, i + 1)) {\n      nparts++;\n    }\n\n    ends = new short[nparts];\n    chars = new char[pathString.length() - nparts + 1];\n    ncomponents = 0;\n\n    add(pathString, delimiter);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d90771c07d45c6ad884c5ef9cb3a6eeb257238d1","date":1357499264,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/CategoryPath#CategoryPath(String,char).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/CategoryPath#CategoryPath(String,char).mjava","sourceNew":"  /** Construct from a given path, separating path components with {@code delimiter}. */\n  public CategoryPath(String pathString, char delimiter) {\n    String[] comps = pathString.split(Character.toString(delimiter));\n    if (comps.length == 1 && comps[0].isEmpty()) {\n      components = EMPTY.components;\n      length = 0;\n    } else {\n      components = comps;\n      length = components.length;\n    }\n  }\n\n","sourceOld":"  /**\n   * Construct a new CategoryPath object, given a single string with\n   * components separated by a given delimiter character.\n   * <P>\n   * The initial capacity of the constructed object will be exactly what is\n   * needed to hold the given path. This fact is convenient when creating a\n   * temporary object that will not be reused later.\n   */\n  public CategoryPath(String pathString, char delimiter) {\n    if (pathString.length() == 0) {\n      ncomponents = 0;\n      chars = new char[0];\n      ends = new short[0];\n      return;\n    }\n\n    // This constructor is often used for creating a temporary object\n    // (one which will not be reused to hold multiple paths), so we want\n    // to do our best to allocate exactly the needed size - not less (to\n    // avoid reallocation) and not more (so as not to waste space).\n    // To do this, we unfortunately need to make an additional pass on the\n    // given string:\n    int nparts = 1;\n    for (int i = pathString.indexOf(delimiter); i >= 0; i = pathString\n        .indexOf(delimiter, i + 1)) {\n      nparts++;\n    }\n\n    ends = new short[nparts];\n    chars = new char[pathString.length() - nparts + 1];\n    ncomponents = 0;\n\n    add(pathString, delimiter);\n  }\n\n","bugFix":null,"bugIntro":["96bab49347cfd234e1aef7eeb5a965f2bfe5b934"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/CategoryPath#CategoryPath(String,char).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/CategoryPath#CategoryPath(String,char).mjava","sourceNew":"  /** Construct from a given path, separating path components with {@code delimiter}. */\n  public CategoryPath(String pathString, char delimiter) {\n    String[] comps = pathString.split(Character.toString(delimiter));\n    if (comps.length == 1 && comps[0].isEmpty()) {\n      components = EMPTY.components;\n      length = 0;\n    } else {\n      components = comps;\n      length = components.length;\n    }\n  }\n\n","sourceOld":"  /**\n   * Construct a new CategoryPath object, given a single string with\n   * components separated by a given delimiter character.\n   * <P>\n   * The initial capacity of the constructed object will be exactly what is\n   * needed to hold the given path. This fact is convenient when creating a\n   * temporary object that will not be reused later.\n   */\n  public CategoryPath(String pathString, char delimiter) {\n    if (pathString.length() == 0) {\n      ncomponents = 0;\n      chars = new char[0];\n      ends = new short[0];\n      return;\n    }\n\n    // This constructor is often used for creating a temporary object\n    // (one which will not be reused to hold multiple paths), so we want\n    // to do our best to allocate exactly the needed size - not less (to\n    // avoid reallocation) and not more (so as not to waste space).\n    // To do this, we unfortunately need to make an additional pass on the\n    // given string:\n    int nparts = 1;\n    for (int i = pathString.indexOf(delimiter); i >= 0; i = pathString\n        .indexOf(delimiter, i + 1)) {\n      nparts++;\n    }\n\n    ends = new short[nparts];\n    chars = new char[pathString.length() - nparts + 1];\n    ncomponents = 0;\n\n    add(pathString, delimiter);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"92a7cdc9f75cac72d21026048992b5a768dfa914","date":1358938986,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/CategoryPath#CategoryPath(String,char).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/CategoryPath#CategoryPath(String,char).mjava","sourceNew":"  /** Construct from a given path, separating path components with {@code delimiter}. */\n  public CategoryPath(final String pathString, final char delimiter) {\n    String[] comps = pathString.split(Character.toString(delimiter));\n    if (comps.length == 1 && comps[0].isEmpty()) {\n      components = EMPTY.components;\n      length = 0;\n    } else {\n      components = comps;\n      length = components.length;\n    }\n  }\n\n","sourceOld":"  /** Construct from a given path, separating path components with {@code delimiter}. */\n  public CategoryPath(String pathString, char delimiter) {\n    String[] comps = pathString.split(Character.toString(delimiter));\n    if (comps.length == 1 && comps[0].isEmpty()) {\n      components = EMPTY.components;\n      length = 0;\n    } else {\n      components = comps;\n      length = components.length;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b2d5244a676b83c2d551c3746e8181588ba619e1","date":1359031414,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/CategoryPath#CategoryPath(String,char).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/CategoryPath#CategoryPath(String,char).mjava","sourceNew":"  /** Construct from a given path, separating path components with {@code delimiter}. */\n  public CategoryPath(final String pathString, final char delimiter) {\n    String[] comps = pathString.split(Character.toString(delimiter));\n    if (comps.length == 1 && comps[0].isEmpty()) {\n      components = EMPTY.components;\n      length = 0;\n    } else {\n      components = comps;\n      length = components.length;\n    }\n  }\n\n","sourceOld":"  /** Construct from a given path, separating path components with {@code delimiter}. */\n  public CategoryPath(String pathString, char delimiter) {\n    String[] comps = pathString.split(Character.toString(delimiter));\n    if (comps.length == 1 && comps[0].isEmpty()) {\n      components = EMPTY.components;\n      length = 0;\n    } else {\n      components = comps;\n      length = components.length;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"96bab49347cfd234e1aef7eeb5a965f2bfe5b934","date":1359367929,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/CategoryPath#CategoryPath(String,char).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/CategoryPath#CategoryPath(String,char).mjava","sourceNew":"  /** Construct from a given path, separating path components with {@code delimiter}. */\n  public CategoryPath(final String pathString, final char delimiter) {\n    String[] comps = pathString.split(Character.toString(delimiter));\n    if (comps.length == 1 && comps[0].isEmpty()) {\n      components = null;\n      length = 0;\n    } else {\n      components = comps;\n      length = components.length;\n    }\n  }\n\n","sourceOld":"  /** Construct from a given path, separating path components with {@code delimiter}. */\n  public CategoryPath(final String pathString, final char delimiter) {\n    String[] comps = pathString.split(Character.toString(delimiter));\n    if (comps.length == 1 && comps[0].isEmpty()) {\n      components = EMPTY.components;\n      length = 0;\n    } else {\n      components = comps;\n      length = components.length;\n    }\n  }\n\n","bugFix":["d90771c07d45c6ad884c5ef9cb3a6eeb257238d1"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9f98959552975d79aafaf0f964262eac98ded407","date":1359372702,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/CategoryPath#CategoryPath(String,char).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/CategoryPath#CategoryPath(String,char).mjava","sourceNew":"  /** Construct from a given path, separating path components with {@code delimiter}. */\n  public CategoryPath(final String pathString, final char delimiter) {\n    String[] comps = pathString.split(Character.toString(delimiter));\n    if (comps.length == 1 && comps[0].isEmpty()) {\n      components = null;\n      length = 0;\n    } else {\n      for (String comp : comps) {\n        if (comp == null || comp.isEmpty()) {\n          throw new IllegalArgumentException(\"empty or null components not allowed: \" + Arrays.toString(comps));\n        }\n      }\n      components = comps;\n      length = components.length;\n    }\n  }\n\n","sourceOld":"  /** Construct from a given path, separating path components with {@code delimiter}. */\n  public CategoryPath(final String pathString, final char delimiter) {\n    String[] comps = pathString.split(Character.toString(delimiter));\n    if (comps.length == 1 && comps[0].isEmpty()) {\n      components = null;\n      length = 0;\n    } else {\n      components = comps;\n      length = components.length;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"de522d9303bd67c8473a269a1319125d1f3700e0","date":1359477856,"type":3,"author":"Adrien Grand","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/CategoryPath#CategoryPath(String,char).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/CategoryPath#CategoryPath(String,char).mjava","sourceNew":"  /** Construct from a given path, separating path components with {@code delimiter}. */\n  public CategoryPath(final String pathString, final char delimiter) {\n    String[] comps = pathString.split(Character.toString(delimiter));\n    if (comps.length == 1 && comps[0].isEmpty()) {\n      components = null;\n      length = 0;\n    } else {\n      for (String comp : comps) {\n        if (comp == null || comp.isEmpty()) {\n          throw new IllegalArgumentException(\"empty or null components not allowed: \" + Arrays.toString(comps));\n        }\n      }\n      components = comps;\n      length = components.length;\n    }\n  }\n\n","sourceOld":"  /** Construct from a given path, separating path components with {@code delimiter}. */\n  public CategoryPath(final String pathString, final char delimiter) {\n    String[] comps = pathString.split(Character.toString(delimiter));\n    if (comps.length == 1 && comps[0].isEmpty()) {\n      components = EMPTY.components;\n      length = 0;\n    } else {\n      components = comps;\n      length = components.length;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fb8457dd0880f5547d70dbf40ea4f1c5e7787798","date":1363378339,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/CategoryPath#CategoryPath(String,char).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/CategoryPath#CategoryPath(String,char).mjava","sourceNew":"  /** Construct from a given path, separating path components with {@code delimiter}. */\n  public CategoryPath(final String pathString, final char delimiter) {\n    String[] comps = pathString.split(Pattern.quote(Character.toString(delimiter)));\n    if (comps.length == 1 && comps[0].isEmpty()) {\n      components = null;\n      length = 0;\n    } else {\n      for (String comp : comps) {\n        if (comp == null || comp.isEmpty()) {\n          throw new IllegalArgumentException(\"empty or null components not allowed: \" + Arrays.toString(comps));\n        }\n      }\n      components = comps;\n      length = components.length;\n    }\n  }\n\n","sourceOld":"  /** Construct from a given path, separating path components with {@code delimiter}. */\n  public CategoryPath(final String pathString, final char delimiter) {\n    String[] comps = pathString.split(Character.toString(delimiter));\n    if (comps.length == 1 && comps[0].isEmpty()) {\n      components = null;\n      length = 0;\n    } else {\n      for (String comp : comps) {\n        if (comp == null || comp.isEmpty()) {\n          throw new IllegalArgumentException(\"empty or null components not allowed: \" + Arrays.toString(comps));\n        }\n      }\n      components = comps;\n      length = components.length;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"95dac0f45251471041578dd8de89dfc7fbb28f8b","date":1370889677,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/CategoryPath#CategoryPath(String,char).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/CategoryPath#CategoryPath(String,char).mjava","sourceNew":"  /** Construct from a given path, separating path components with {@code delimiter}. */\n  public CategoryPath(final String pathString, final char delimiter) {\n    if (pathString.length() > MAX_CATEGORY_PATH_LENGTH) {\n      throw new IllegalArgumentException(\"category path exceeds maximum allowed path length: max=\"\n              + MAX_CATEGORY_PATH_LENGTH + \" len=\" + pathString.length()\n              + \" path=\" + pathString.substring(0, 30) + \"...\");\n    }\n\n    String[] comps = pathString.split(Pattern.quote(Character.toString(delimiter)));\n    if (comps.length == 1 && comps[0].isEmpty()) {\n      components = null;\n      length = 0;\n    } else {\n      for (String comp : comps) {\n        if (comp == null || comp.isEmpty()) {\n          throw new IllegalArgumentException(\"empty or null components not allowed: \" + Arrays.toString(comps));\n        }\n      }\n      components = comps;\n      length = components.length;\n    }\n  }\n\n","sourceOld":"  /** Construct from a given path, separating path components with {@code delimiter}. */\n  public CategoryPath(final String pathString, final char delimiter) {\n    String[] comps = pathString.split(Pattern.quote(Character.toString(delimiter)));\n    if (comps.length == 1 && comps[0].isEmpty()) {\n      components = null;\n      length = 0;\n    } else {\n      for (String comp : comps) {\n        if (comp == null || comp.isEmpty()) {\n          throw new IllegalArgumentException(\"empty or null components not allowed: \" + Arrays.toString(comps));\n        }\n      }\n      components = comps;\n      length = components.length;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c190847801a50f4dd20fd639bdc29b54ea3b288b","date":1384461522,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/FacetLabel#FacetLabel(String,char).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/CategoryPath#CategoryPath(String,char).mjava","sourceNew":"  /** Construct from a given path, separating path components with {@code delimiter}. */\n  public FacetLabel(final String pathString, final char delimiter) {\n    if (pathString.length() > MAX_CATEGORY_PATH_LENGTH) {\n      throw new IllegalArgumentException(\"category path exceeds maximum allowed path length: max=\"\n              + MAX_CATEGORY_PATH_LENGTH + \" len=\" + pathString.length()\n              + \" path=\" + pathString.substring(0, 30) + \"...\");\n    }\n\n    String[] comps = pathString.split(Pattern.quote(Character.toString(delimiter)));\n    if (comps.length == 1 && comps[0].isEmpty()) {\n      components = null;\n      length = 0;\n    } else {\n      for (String comp : comps) {\n        if (comp == null || comp.isEmpty()) {\n          throw new IllegalArgumentException(\"empty or null components not allowed: \" + Arrays.toString(comps));\n        }\n      }\n      components = comps;\n      length = components.length;\n    }\n  }\n\n","sourceOld":"  /** Construct from a given path, separating path components with {@code delimiter}. */\n  public CategoryPath(final String pathString, final char delimiter) {\n    if (pathString.length() > MAX_CATEGORY_PATH_LENGTH) {\n      throw new IllegalArgumentException(\"category path exceeds maximum allowed path length: max=\"\n              + MAX_CATEGORY_PATH_LENGTH + \" len=\" + pathString.length()\n              + \" path=\" + pathString.substring(0, 30) + \"...\");\n    }\n\n    String[] comps = pathString.split(Pattern.quote(Character.toString(delimiter)));\n    if (comps.length == 1 && comps[0].isEmpty()) {\n      components = null;\n      length = 0;\n    } else {\n      for (String comp : comps) {\n        if (comp == null || comp.isEmpty()) {\n          throw new IllegalArgumentException(\"empty or null components not allowed: \" + Arrays.toString(comps));\n        }\n      }\n      components = comps;\n      length = components.length;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cc728b07df73b197e6d940d27f9b08b63918f13","date":1388834348,"type":4,"author":"Michael McCandless","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/CategoryPath#CategoryPath(String,char).mjava","sourceNew":null,"sourceOld":"  /** Construct from a given path, separating path components with {@code delimiter}. */\n  public CategoryPath(final String pathString, final char delimiter) {\n    if (pathString.length() > MAX_CATEGORY_PATH_LENGTH) {\n      throw new IllegalArgumentException(\"category path exceeds maximum allowed path length: max=\"\n              + MAX_CATEGORY_PATH_LENGTH + \" len=\" + pathString.length()\n              + \" path=\" + pathString.substring(0, 30) + \"...\");\n    }\n\n    String[] comps = pathString.split(Pattern.quote(Character.toString(delimiter)));\n    if (comps.length == 1 && comps[0].isEmpty()) {\n      components = null;\n      length = 0;\n    } else {\n      for (String comp : comps) {\n        if (comp == null || comp.isEmpty()) {\n          throw new IllegalArgumentException(\"empty or null components not allowed: \" + Arrays.toString(comps));\n        }\n      }\n      components = comps;\n      length = components.length;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["b89678825b68eccaf09e6ab71675fc0b0af1e099","d90771c07d45c6ad884c5ef9cb3a6eeb257238d1"],"92a7cdc9f75cac72d21026048992b5a768dfa914":["d90771c07d45c6ad884c5ef9cb3a6eeb257238d1"],"9f98959552975d79aafaf0f964262eac98ded407":["96bab49347cfd234e1aef7eeb5a965f2bfe5b934"],"fb8457dd0880f5547d70dbf40ea4f1c5e7787798":["9f98959552975d79aafaf0f964262eac98ded407"],"de522d9303bd67c8473a269a1319125d1f3700e0":["b2d5244a676b83c2d551c3746e8181588ba619e1","9f98959552975d79aafaf0f964262eac98ded407"],"c190847801a50f4dd20fd639bdc29b54ea3b288b":["95dac0f45251471041578dd8de89dfc7fbb28f8b"],"b2d5244a676b83c2d551c3746e8181588ba619e1":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","92a7cdc9f75cac72d21026048992b5a768dfa914"],"d90771c07d45c6ad884c5ef9cb3a6eeb257238d1":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"96bab49347cfd234e1aef7eeb5a965f2bfe5b934":["92a7cdc9f75cac72d21026048992b5a768dfa914"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"95dac0f45251471041578dd8de89dfc7fbb28f8b":["fb8457dd0880f5547d70dbf40ea4f1c5e7787798"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["95dac0f45251471041578dd8de89dfc7fbb28f8b","c190847801a50f4dd20fd639bdc29b54ea3b288b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3cc728b07df73b197e6d940d27f9b08b63918f13"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["b2d5244a676b83c2d551c3746e8181588ba619e1"],"92a7cdc9f75cac72d21026048992b5a768dfa914":["b2d5244a676b83c2d551c3746e8181588ba619e1","96bab49347cfd234e1aef7eeb5a965f2bfe5b934"],"9f98959552975d79aafaf0f964262eac98ded407":["fb8457dd0880f5547d70dbf40ea4f1c5e7787798","de522d9303bd67c8473a269a1319125d1f3700e0"],"fb8457dd0880f5547d70dbf40ea4f1c5e7787798":["95dac0f45251471041578dd8de89dfc7fbb28f8b"],"de522d9303bd67c8473a269a1319125d1f3700e0":[],"b2d5244a676b83c2d551c3746e8181588ba619e1":["de522d9303bd67c8473a269a1319125d1f3700e0"],"c190847801a50f4dd20fd639bdc29b54ea3b288b":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"d90771c07d45c6ad884c5ef9cb3a6eeb257238d1":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","92a7cdc9f75cac72d21026048992b5a768dfa914"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","d90771c07d45c6ad884c5ef9cb3a6eeb257238d1"],"96bab49347cfd234e1aef7eeb5a965f2bfe5b934":["9f98959552975d79aafaf0f964262eac98ded407"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"95dac0f45251471041578dd8de89dfc7fbb28f8b":["c190847801a50f4dd20fd639bdc29b54ea3b288b","3cc728b07df73b197e6d940d27f9b08b63918f13"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["de522d9303bd67c8473a269a1319125d1f3700e0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}