{"path":"solr/core/src/java/org/apache/solr/schema/IndexSchema#getCopyFieldProperties(boolean,Set[String],Set[String]).mjava","commits":[{"id":"d2fa053a06c9c158f82d8e8b53b9a95031f43ebd","date":1364185773,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#getCopyFieldProperties(boolean,Set[String],Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/rest/CopyFieldCollectionResource#get().mjava","sourceNew":"  /**\n   * Returns a list of copyField directives, with optional details and optionally restricting to those\n   * directives that contain the requested source and/or destination field names.\n   * \n   * @param showDetails If true, source and destination dynamic bases, and explicit fields matched by source globs,\n   *                    will be added to dynamic copyField directives where appropriate\n   * @param requestedSourceFields If not null, output is restricted to those copyField directives\n   *                              with the requested source field names \n   * @param requestedDestinationFields If not null, output is restricted to those copyField directives\n   *                                   with the requested destination field names \n   * @return a list of copyField directives \n   */\n  public List<SimpleOrderedMap<Object>> getCopyFieldProperties\n      (boolean showDetails, Set<String> requestedSourceFields, Set<String> requestedDestinationFields) {\n    List<SimpleOrderedMap<Object>> copyFieldProperties = new ArrayList<SimpleOrderedMap<Object>>();\n    SortedMap<String,List<CopyField>> sortedCopyFields = new TreeMap<String,List<CopyField>>(copyFieldsMap);\n    for (List<CopyField> copyFields : sortedCopyFields.values()) {\n      Collections.sort(copyFields, new Comparator<CopyField>() {\n        @Override\n        public int compare(CopyField cf1, CopyField cf2) {\n          // sources are all be the same, just sorting by destination here\n          return cf1.getDestination().getName().compareTo(cf2.getDestination().getName());\n        }\n      });\n      for (CopyField copyField : copyFields) {\n        final String source = copyField.getSource().getName();\n        final String destination = copyField.getDestination().getName();\n        if (   (null == requestedSourceFields      || requestedSourceFields.contains(source))\n            && (null == requestedDestinationFields || requestedDestinationFields.contains(destination))) {\n          SimpleOrderedMap<Object> props = new SimpleOrderedMap<Object>();\n          props.add(SOURCE, source);\n          props.add(DESTINATION, destination);\n            if (0 != copyField.getMaxChars()) {\n              props.add(MAX_CHARS, copyField.getMaxChars());\n            }\n          copyFieldProperties.add(props);\n        }\n      }\n    }\n    for (IndexSchema.DynamicCopy dynamicCopy : dynamicCopyFields) {\n      final String source = dynamicCopy.getRegex();\n      final String destination = dynamicCopy.getDestFieldName();\n      if (   (null == requestedSourceFields      || requestedSourceFields.contains(source))\n          && (null == requestedDestinationFields || requestedDestinationFields.contains(destination))) {\n        SimpleOrderedMap<Object> dynamicCopyProps = new SimpleOrderedMap<Object>();\n\n        dynamicCopyProps.add(SOURCE, dynamicCopy.getRegex());\n        if (showDetails) {\n          IndexSchema.DynamicField sourceDynamicBase = dynamicCopy.getSourceDynamicBase();\n          if (null != sourceDynamicBase) {\n            dynamicCopyProps.add(SOURCE_DYNAMIC_BASE, sourceDynamicBase.getRegex());\n          } else if (source.contains(\"*\")) {\n            List<String> sourceExplicitFields = new ArrayList<String>();\n            Pattern pattern = Pattern.compile(source.replace(\"*\", \".*\"));   // glob->regex\n            for (String field : fields.keySet()) {\n              if (pattern.matcher(field).matches()) {\n                sourceExplicitFields.add(field);\n              }\n            }\n            if (sourceExplicitFields.size() > 0) {\n              Collections.sort(sourceExplicitFields);\n              dynamicCopyProps.add(SOURCE_EXPLICIT_FIELDS, sourceExplicitFields);\n            }\n          }\n        }\n        \n        dynamicCopyProps.add(DESTINATION, dynamicCopy.getDestFieldName());\n        if (showDetails) {\n          IndexSchema.DynamicField destDynamicBase = dynamicCopy.getDestDynamicBase();\n          if (null != destDynamicBase) {\n            dynamicCopyProps.add(DESTINATION_DYNAMIC_BASE, destDynamicBase.getRegex());\n          }\n        }\n\n        if (0 != dynamicCopy.getMaxChars()) {\n          dynamicCopyProps.add(MAX_CHARS, dynamicCopy.getMaxChars());\n        }\n\n        copyFieldProperties.add(dynamicCopyProps);\n      }\n    }\n    return copyFieldProperties;\n  }\n\n","sourceOld":"  @Override\n  public Representation get() {\n    try {\n      final List<SimpleOrderedMap<Object>> props = new ArrayList<SimpleOrderedMap<Object>>();\n      SortedMap<String,List<CopyField>> sortedCopyFields = new TreeMap<String, List<CopyField>>(getSchema().getCopyFieldsMap());\n      for (List<CopyField> copyFields : sortedCopyFields.values()) {\n        Collections.sort(copyFields, new Comparator<CopyField>() {\n          @Override\n          public int compare(CopyField cf1, CopyField cf2) {\n            // source should all be the same => already sorted\n            return cf1.getDestination().getName().compareTo(cf2.getDestination().getName());\n          }\n        });\n        for (CopyField copyField : copyFields) {\n          final String source = copyField.getSource().getName();\n          final String destination = copyField.getDestination().getName();\n          if (   (null == requestedSourceFields      || requestedSourceFields.contains(source))\n              && (null == requestedDestinationFields || requestedDestinationFields.contains(destination))) {\n            SimpleOrderedMap<Object> copyFieldProps = new SimpleOrderedMap<Object>();\n            copyFieldProps.add(SOURCE, source);\n            copyFieldProps.add(DESTINATION, destination);\n            if (0 != copyField.getMaxChars()) {\n              copyFieldProps.add(MAX_CHARS, copyField.getMaxChars());\n            }\n            props.add(copyFieldProps);\n          }\n        }\n      }\n      for (IndexSchema.DynamicCopy dynamicCopy : getSchema().getDynamicCopyFields()) {\n        final String source = dynamicCopy.getRegex();\n        final String destination = dynamicCopy.getDestFieldName();\n        if (   (null == requestedSourceFields      || requestedSourceFields.contains(source))\n            && (null == requestedDestinationFields || requestedDestinationFields.contains(destination))) {\n          SimpleOrderedMap<Object> dynamicCopyProps = new SimpleOrderedMap<Object>();\n\n          dynamicCopyProps.add(SOURCE, dynamicCopy.getRegex());\n          IndexSchema.DynamicField sourceDynamicBase = dynamicCopy.getSourceDynamicBase();\n          if (null != sourceDynamicBase) {\n            dynamicCopyProps.add(SOURCE_DYNAMIC_BASE, sourceDynamicBase.getRegex());\n          } else if (source.contains(\"*\")) {\n            List<String> sourceExplicitFields = new ArrayList<String>();\n            Pattern pattern = Pattern.compile(source.replace(\"*\", \".*\"));   // glob->regex\n            for (String field : getSchema().getFields().keySet()) {\n              if (pattern.matcher(field).matches()) {\n                sourceExplicitFields.add(field);\n              }\n            }\n            if (sourceExplicitFields.size() > 0) {\n              Collections.sort(sourceExplicitFields);\n              dynamicCopyProps.add(SOURCE_EXPLICIT_FIELDS, sourceExplicitFields);\n            }\n          }\n          \n          dynamicCopyProps.add(DESTINATION, dynamicCopy.getDestFieldName());\n          IndexSchema.DynamicField destDynamicBase = dynamicCopy.getDestDynamicBase();\n          if (null != destDynamicBase) {\n            dynamicCopyProps.add(DESTINATION_DYNAMIC_BASE, destDynamicBase.getRegex());\n          }\n          \n          if (0 != dynamicCopy.getMaxChars()) {\n            dynamicCopyProps.add(MAX_CHARS, dynamicCopy.getMaxChars());\n          }\n\n          props.add(dynamicCopyProps);\n        }\n      }\n      getSolrResponse().add(SchemaRestApi.COPY_FIELDS, props);\n    } catch (Exception e) {\n      getSolrResponse().setException(e);\n    }\n    handlePostExecution(log);\n\n    return new SolrOutputRepresentation();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#getCopyFieldProperties(boolean,Set[String],Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#getCopyFieldProperties(boolean,Set[String],Set[String]).mjava","sourceNew":"  /**\n   * Returns a list of copyField directives, with optional details and optionally restricting to those\n   * directives that contain the requested source and/or destination field names.\n   * \n   * @param showDetails If true, source and destination dynamic bases, and explicit fields matched by source globs,\n   *                    will be added to dynamic copyField directives where appropriate\n   * @param requestedSourceFields If not null, output is restricted to those copyField directives\n   *                              with the requested source field names \n   * @param requestedDestinationFields If not null, output is restricted to those copyField directives\n   *                                   with the requested destination field names \n   * @return a list of copyField directives \n   */\n  public List<SimpleOrderedMap<Object>> getCopyFieldProperties\n      (boolean showDetails, Set<String> requestedSourceFields, Set<String> requestedDestinationFields) {\n    List<SimpleOrderedMap<Object>> copyFieldProperties = new ArrayList<>();\n    SortedMap<String,List<CopyField>> sortedCopyFields = new TreeMap<>(copyFieldsMap);\n    for (List<CopyField> copyFields : sortedCopyFields.values()) {\n      Collections.sort(copyFields, new Comparator<CopyField>() {\n        @Override\n        public int compare(CopyField cf1, CopyField cf2) {\n          // sources are all be the same, just sorting by destination here\n          return cf1.getDestination().getName().compareTo(cf2.getDestination().getName());\n        }\n      });\n      for (CopyField copyField : copyFields) {\n        final String source = copyField.getSource().getName();\n        final String destination = copyField.getDestination().getName();\n        if (   (null == requestedSourceFields      || requestedSourceFields.contains(source))\n            && (null == requestedDestinationFields || requestedDestinationFields.contains(destination))) {\n          SimpleOrderedMap<Object> props = new SimpleOrderedMap<>();\n          props.add(SOURCE, source);\n          props.add(DESTINATION, destination);\n            if (0 != copyField.getMaxChars()) {\n              props.add(MAX_CHARS, copyField.getMaxChars());\n            }\n          copyFieldProperties.add(props);\n        }\n      }\n    }\n    for (IndexSchema.DynamicCopy dynamicCopy : dynamicCopyFields) {\n      final String source = dynamicCopy.getRegex();\n      final String destination = dynamicCopy.getDestFieldName();\n      if (   (null == requestedSourceFields      || requestedSourceFields.contains(source))\n          && (null == requestedDestinationFields || requestedDestinationFields.contains(destination))) {\n        SimpleOrderedMap<Object> dynamicCopyProps = new SimpleOrderedMap<>();\n\n        dynamicCopyProps.add(SOURCE, dynamicCopy.getRegex());\n        if (showDetails) {\n          IndexSchema.DynamicField sourceDynamicBase = dynamicCopy.getSourceDynamicBase();\n          if (null != sourceDynamicBase) {\n            dynamicCopyProps.add(SOURCE_DYNAMIC_BASE, sourceDynamicBase.getRegex());\n          } else if (source.contains(\"*\")) {\n            List<String> sourceExplicitFields = new ArrayList<>();\n            Pattern pattern = Pattern.compile(source.replace(\"*\", \".*\"));   // glob->regex\n            for (String field : fields.keySet()) {\n              if (pattern.matcher(field).matches()) {\n                sourceExplicitFields.add(field);\n              }\n            }\n            if (sourceExplicitFields.size() > 0) {\n              Collections.sort(sourceExplicitFields);\n              dynamicCopyProps.add(SOURCE_EXPLICIT_FIELDS, sourceExplicitFields);\n            }\n          }\n        }\n        \n        dynamicCopyProps.add(DESTINATION, dynamicCopy.getDestFieldName());\n        if (showDetails) {\n          IndexSchema.DynamicField destDynamicBase = dynamicCopy.getDestDynamicBase();\n          if (null != destDynamicBase) {\n            dynamicCopyProps.add(DESTINATION_DYNAMIC_BASE, destDynamicBase.getRegex());\n          }\n        }\n\n        if (0 != dynamicCopy.getMaxChars()) {\n          dynamicCopyProps.add(MAX_CHARS, dynamicCopy.getMaxChars());\n        }\n\n        copyFieldProperties.add(dynamicCopyProps);\n      }\n    }\n    return copyFieldProperties;\n  }\n\n","sourceOld":"  /**\n   * Returns a list of copyField directives, with optional details and optionally restricting to those\n   * directives that contain the requested source and/or destination field names.\n   * \n   * @param showDetails If true, source and destination dynamic bases, and explicit fields matched by source globs,\n   *                    will be added to dynamic copyField directives where appropriate\n   * @param requestedSourceFields If not null, output is restricted to those copyField directives\n   *                              with the requested source field names \n   * @param requestedDestinationFields If not null, output is restricted to those copyField directives\n   *                                   with the requested destination field names \n   * @return a list of copyField directives \n   */\n  public List<SimpleOrderedMap<Object>> getCopyFieldProperties\n      (boolean showDetails, Set<String> requestedSourceFields, Set<String> requestedDestinationFields) {\n    List<SimpleOrderedMap<Object>> copyFieldProperties = new ArrayList<SimpleOrderedMap<Object>>();\n    SortedMap<String,List<CopyField>> sortedCopyFields = new TreeMap<String,List<CopyField>>(copyFieldsMap);\n    for (List<CopyField> copyFields : sortedCopyFields.values()) {\n      Collections.sort(copyFields, new Comparator<CopyField>() {\n        @Override\n        public int compare(CopyField cf1, CopyField cf2) {\n          // sources are all be the same, just sorting by destination here\n          return cf1.getDestination().getName().compareTo(cf2.getDestination().getName());\n        }\n      });\n      for (CopyField copyField : copyFields) {\n        final String source = copyField.getSource().getName();\n        final String destination = copyField.getDestination().getName();\n        if (   (null == requestedSourceFields      || requestedSourceFields.contains(source))\n            && (null == requestedDestinationFields || requestedDestinationFields.contains(destination))) {\n          SimpleOrderedMap<Object> props = new SimpleOrderedMap<Object>();\n          props.add(SOURCE, source);\n          props.add(DESTINATION, destination);\n            if (0 != copyField.getMaxChars()) {\n              props.add(MAX_CHARS, copyField.getMaxChars());\n            }\n          copyFieldProperties.add(props);\n        }\n      }\n    }\n    for (IndexSchema.DynamicCopy dynamicCopy : dynamicCopyFields) {\n      final String source = dynamicCopy.getRegex();\n      final String destination = dynamicCopy.getDestFieldName();\n      if (   (null == requestedSourceFields      || requestedSourceFields.contains(source))\n          && (null == requestedDestinationFields || requestedDestinationFields.contains(destination))) {\n        SimpleOrderedMap<Object> dynamicCopyProps = new SimpleOrderedMap<Object>();\n\n        dynamicCopyProps.add(SOURCE, dynamicCopy.getRegex());\n        if (showDetails) {\n          IndexSchema.DynamicField sourceDynamicBase = dynamicCopy.getSourceDynamicBase();\n          if (null != sourceDynamicBase) {\n            dynamicCopyProps.add(SOURCE_DYNAMIC_BASE, sourceDynamicBase.getRegex());\n          } else if (source.contains(\"*\")) {\n            List<String> sourceExplicitFields = new ArrayList<String>();\n            Pattern pattern = Pattern.compile(source.replace(\"*\", \".*\"));   // glob->regex\n            for (String field : fields.keySet()) {\n              if (pattern.matcher(field).matches()) {\n                sourceExplicitFields.add(field);\n              }\n            }\n            if (sourceExplicitFields.size() > 0) {\n              Collections.sort(sourceExplicitFields);\n              dynamicCopyProps.add(SOURCE_EXPLICIT_FIELDS, sourceExplicitFields);\n            }\n          }\n        }\n        \n        dynamicCopyProps.add(DESTINATION, dynamicCopy.getDestFieldName());\n        if (showDetails) {\n          IndexSchema.DynamicField destDynamicBase = dynamicCopy.getDestDynamicBase();\n          if (null != destDynamicBase) {\n            dynamicCopyProps.add(DESTINATION_DYNAMIC_BASE, destDynamicBase.getRegex());\n          }\n        }\n\n        if (0 != dynamicCopy.getMaxChars()) {\n          dynamicCopyProps.add(MAX_CHARS, dynamicCopy.getMaxChars());\n        }\n\n        copyFieldProperties.add(dynamicCopyProps);\n      }\n    }\n    return copyFieldProperties;\n  }\n\n","bugFix":null,"bugIntro":["cbf48bc10d8aa7b417d61814c87fee4f942cdeca"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"eeeea2295d6355a29e259130a5c48ace73022d7c","date":1426569216,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#getCopyFieldProperties(boolean,Set[String],Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#getCopyFieldProperties(boolean,Set[String],Set[String]).mjava","sourceNew":"  /**\n   * Returns a list of copyField directives, with optional details and optionally restricting to those\n   * directives that contain the requested source and/or destination field names.\n   * \n   * @param showDetails If true, source and destination dynamic bases, and explicit fields matched by source globs,\n   *                    will be added to dynamic copyField directives where appropriate\n   * @param requestedSourceFields If not null, output is restricted to those copyField directives\n   *                              with the requested source field names \n   * @param requestedDestinationFields If not null, output is restricted to those copyField directives\n   *                                   with the requested destination field names \n   * @return a list of copyField directives \n   */\n  public List<SimpleOrderedMap<Object>> getCopyFieldProperties\n      (boolean showDetails, Set<String> requestedSourceFields, Set<String> requestedDestinationFields) {\n    List<SimpleOrderedMap<Object>> copyFieldProperties = new ArrayList<>();\n    SortedMap<String,List<CopyField>> sortedCopyFields = new TreeMap<>(copyFieldsMap);\n    for (List<CopyField> copyFields : sortedCopyFields.values()) {\n      copyFields = new ArrayList<>(copyFields);\n      Collections.sort(copyFields, new Comparator<CopyField>() {\n        @Override\n        public int compare(CopyField cf1, CopyField cf2) {\n          // sources are all the same, just sorting by destination here\n          return cf1.getDestination().getName().compareTo(cf2.getDestination().getName());\n        }\n      });\n      for (CopyField copyField : copyFields) {\n        final String source = copyField.getSource().getName();\n        final String destination = copyField.getDestination().getName();\n        if (   (null == requestedSourceFields      || requestedSourceFields.contains(source))\n            && (null == requestedDestinationFields || requestedDestinationFields.contains(destination))) {\n          SimpleOrderedMap<Object> props = new SimpleOrderedMap<>();\n          props.add(SOURCE, source);\n          props.add(DESTINATION, destination);\n            if (0 != copyField.getMaxChars()) {\n              props.add(MAX_CHARS, copyField.getMaxChars());\n            }\n          copyFieldProperties.add(props);\n        }\n      }\n    }\n    for (IndexSchema.DynamicCopy dynamicCopy : dynamicCopyFields) {\n      final String source = dynamicCopy.getRegex();\n      final String destination = dynamicCopy.getDestFieldName();\n      if (   (null == requestedSourceFields      || requestedSourceFields.contains(source))\n          && (null == requestedDestinationFields || requestedDestinationFields.contains(destination))) {\n        SimpleOrderedMap<Object> dynamicCopyProps = new SimpleOrderedMap<>();\n\n        dynamicCopyProps.add(SOURCE, dynamicCopy.getRegex());\n        if (showDetails) {\n          IndexSchema.DynamicField sourceDynamicBase = dynamicCopy.getSourceDynamicBase();\n          if (null != sourceDynamicBase) {\n            dynamicCopyProps.add(SOURCE_DYNAMIC_BASE, sourceDynamicBase.getRegex());\n          } else if (source.contains(\"*\")) {\n            List<String> sourceExplicitFields = new ArrayList<>();\n            Pattern pattern = Pattern.compile(source.replace(\"*\", \".*\"));   // glob->regex\n            for (String field : fields.keySet()) {\n              if (pattern.matcher(field).matches()) {\n                sourceExplicitFields.add(field);\n              }\n            }\n            if (sourceExplicitFields.size() > 0) {\n              Collections.sort(sourceExplicitFields);\n              dynamicCopyProps.add(SOURCE_EXPLICIT_FIELDS, sourceExplicitFields);\n            }\n          }\n        }\n        \n        dynamicCopyProps.add(DESTINATION, dynamicCopy.getDestFieldName());\n        if (showDetails) {\n          IndexSchema.DynamicField destDynamicBase = dynamicCopy.getDestDynamicBase();\n          if (null != destDynamicBase) {\n            dynamicCopyProps.add(DESTINATION_DYNAMIC_BASE, destDynamicBase.getRegex());\n          }\n        }\n\n        if (0 != dynamicCopy.getMaxChars()) {\n          dynamicCopyProps.add(MAX_CHARS, dynamicCopy.getMaxChars());\n        }\n\n        copyFieldProperties.add(dynamicCopyProps);\n      }\n    }\n    return copyFieldProperties;\n  }\n\n","sourceOld":"  /**\n   * Returns a list of copyField directives, with optional details and optionally restricting to those\n   * directives that contain the requested source and/or destination field names.\n   * \n   * @param showDetails If true, source and destination dynamic bases, and explicit fields matched by source globs,\n   *                    will be added to dynamic copyField directives where appropriate\n   * @param requestedSourceFields If not null, output is restricted to those copyField directives\n   *                              with the requested source field names \n   * @param requestedDestinationFields If not null, output is restricted to those copyField directives\n   *                                   with the requested destination field names \n   * @return a list of copyField directives \n   */\n  public List<SimpleOrderedMap<Object>> getCopyFieldProperties\n      (boolean showDetails, Set<String> requestedSourceFields, Set<String> requestedDestinationFields) {\n    List<SimpleOrderedMap<Object>> copyFieldProperties = new ArrayList<>();\n    SortedMap<String,List<CopyField>> sortedCopyFields = new TreeMap<>(copyFieldsMap);\n    for (List<CopyField> copyFields : sortedCopyFields.values()) {\n      Collections.sort(copyFields, new Comparator<CopyField>() {\n        @Override\n        public int compare(CopyField cf1, CopyField cf2) {\n          // sources are all be the same, just sorting by destination here\n          return cf1.getDestination().getName().compareTo(cf2.getDestination().getName());\n        }\n      });\n      for (CopyField copyField : copyFields) {\n        final String source = copyField.getSource().getName();\n        final String destination = copyField.getDestination().getName();\n        if (   (null == requestedSourceFields      || requestedSourceFields.contains(source))\n            && (null == requestedDestinationFields || requestedDestinationFields.contains(destination))) {\n          SimpleOrderedMap<Object> props = new SimpleOrderedMap<>();\n          props.add(SOURCE, source);\n          props.add(DESTINATION, destination);\n            if (0 != copyField.getMaxChars()) {\n              props.add(MAX_CHARS, copyField.getMaxChars());\n            }\n          copyFieldProperties.add(props);\n        }\n      }\n    }\n    for (IndexSchema.DynamicCopy dynamicCopy : dynamicCopyFields) {\n      final String source = dynamicCopy.getRegex();\n      final String destination = dynamicCopy.getDestFieldName();\n      if (   (null == requestedSourceFields      || requestedSourceFields.contains(source))\n          && (null == requestedDestinationFields || requestedDestinationFields.contains(destination))) {\n        SimpleOrderedMap<Object> dynamicCopyProps = new SimpleOrderedMap<>();\n\n        dynamicCopyProps.add(SOURCE, dynamicCopy.getRegex());\n        if (showDetails) {\n          IndexSchema.DynamicField sourceDynamicBase = dynamicCopy.getSourceDynamicBase();\n          if (null != sourceDynamicBase) {\n            dynamicCopyProps.add(SOURCE_DYNAMIC_BASE, sourceDynamicBase.getRegex());\n          } else if (source.contains(\"*\")) {\n            List<String> sourceExplicitFields = new ArrayList<>();\n            Pattern pattern = Pattern.compile(source.replace(\"*\", \".*\"));   // glob->regex\n            for (String field : fields.keySet()) {\n              if (pattern.matcher(field).matches()) {\n                sourceExplicitFields.add(field);\n              }\n            }\n            if (sourceExplicitFields.size() > 0) {\n              Collections.sort(sourceExplicitFields);\n              dynamicCopyProps.add(SOURCE_EXPLICIT_FIELDS, sourceExplicitFields);\n            }\n          }\n        }\n        \n        dynamicCopyProps.add(DESTINATION, dynamicCopy.getDestFieldName());\n        if (showDetails) {\n          IndexSchema.DynamicField destDynamicBase = dynamicCopy.getDestDynamicBase();\n          if (null != destDynamicBase) {\n            dynamicCopyProps.add(DESTINATION_DYNAMIC_BASE, destDynamicBase.getRegex());\n          }\n        }\n\n        if (0 != dynamicCopy.getMaxChars()) {\n          dynamicCopyProps.add(MAX_CHARS, dynamicCopy.getMaxChars());\n        }\n\n        copyFieldProperties.add(dynamicCopyProps);\n      }\n    }\n    return copyFieldProperties;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#getCopyFieldProperties(boolean,Set[String],Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#getCopyFieldProperties(boolean,Set[String],Set[String]).mjava","sourceNew":"  /**\n   * Returns a list of copyField directives, with optional details and optionally restricting to those\n   * directives that contain the requested source and/or destination field names.\n   * \n   * @param showDetails If true, source and destination dynamic bases, and explicit fields matched by source globs,\n   *                    will be added to dynamic copyField directives where appropriate\n   * @param requestedSourceFields If not null, output is restricted to those copyField directives\n   *                              with the requested source field names \n   * @param requestedDestinationFields If not null, output is restricted to those copyField directives\n   *                                   with the requested destination field names \n   * @return a list of copyField directives \n   */\n  public List<SimpleOrderedMap<Object>> getCopyFieldProperties\n      (boolean showDetails, Set<String> requestedSourceFields, Set<String> requestedDestinationFields) {\n    List<SimpleOrderedMap<Object>> copyFieldProperties = new ArrayList<>();\n    SortedMap<String,List<CopyField>> sortedCopyFields = new TreeMap<>(copyFieldsMap);\n    for (List<CopyField> copyFields : sortedCopyFields.values()) {\n      copyFields = new ArrayList<>(copyFields);\n      Collections.sort(copyFields, new Comparator<CopyField>() {\n        @Override\n        public int compare(CopyField cf1, CopyField cf2) {\n          // sources are all the same, just sorting by destination here\n          return cf1.getDestination().getName().compareTo(cf2.getDestination().getName());\n        }\n      });\n      for (CopyField copyField : copyFields) {\n        final String source = copyField.getSource().getName();\n        final String destination = copyField.getDestination().getName();\n        if (   (null == requestedSourceFields      || requestedSourceFields.contains(source))\n            && (null == requestedDestinationFields || requestedDestinationFields.contains(destination))) {\n          SimpleOrderedMap<Object> props = new SimpleOrderedMap<>();\n          props.add(SOURCE, source);\n          props.add(DESTINATION, destination);\n            if (0 != copyField.getMaxChars()) {\n              props.add(MAX_CHARS, copyField.getMaxChars());\n            }\n          copyFieldProperties.add(props);\n        }\n      }\n    }\n    for (IndexSchema.DynamicCopy dynamicCopy : dynamicCopyFields) {\n      final String source = dynamicCopy.getRegex();\n      final String destination = dynamicCopy.getDestFieldName();\n      if (   (null == requestedSourceFields      || requestedSourceFields.contains(source))\n          && (null == requestedDestinationFields || requestedDestinationFields.contains(destination))) {\n        SimpleOrderedMap<Object> dynamicCopyProps = new SimpleOrderedMap<>();\n\n        dynamicCopyProps.add(SOURCE, dynamicCopy.getRegex());\n        if (showDetails) {\n          IndexSchema.DynamicField sourceDynamicBase = dynamicCopy.getSourceDynamicBase();\n          if (null != sourceDynamicBase) {\n            dynamicCopyProps.add(SOURCE_DYNAMIC_BASE, sourceDynamicBase.getRegex());\n          } else if (source.contains(\"*\")) {\n            List<String> sourceExplicitFields = new ArrayList<>();\n            Pattern pattern = Pattern.compile(source.replace(\"*\", \".*\"));   // glob->regex\n            for (String field : fields.keySet()) {\n              if (pattern.matcher(field).matches()) {\n                sourceExplicitFields.add(field);\n              }\n            }\n            if (sourceExplicitFields.size() > 0) {\n              Collections.sort(sourceExplicitFields);\n              dynamicCopyProps.add(SOURCE_EXPLICIT_FIELDS, sourceExplicitFields);\n            }\n          }\n        }\n        \n        dynamicCopyProps.add(DESTINATION, dynamicCopy.getDestFieldName());\n        if (showDetails) {\n          IndexSchema.DynamicField destDynamicBase = dynamicCopy.getDestDynamicBase();\n          if (null != destDynamicBase) {\n            dynamicCopyProps.add(DESTINATION_DYNAMIC_BASE, destDynamicBase.getRegex());\n          }\n        }\n\n        if (0 != dynamicCopy.getMaxChars()) {\n          dynamicCopyProps.add(MAX_CHARS, dynamicCopy.getMaxChars());\n        }\n\n        copyFieldProperties.add(dynamicCopyProps);\n      }\n    }\n    return copyFieldProperties;\n  }\n\n","sourceOld":"  /**\n   * Returns a list of copyField directives, with optional details and optionally restricting to those\n   * directives that contain the requested source and/or destination field names.\n   * \n   * @param showDetails If true, source and destination dynamic bases, and explicit fields matched by source globs,\n   *                    will be added to dynamic copyField directives where appropriate\n   * @param requestedSourceFields If not null, output is restricted to those copyField directives\n   *                              with the requested source field names \n   * @param requestedDestinationFields If not null, output is restricted to those copyField directives\n   *                                   with the requested destination field names \n   * @return a list of copyField directives \n   */\n  public List<SimpleOrderedMap<Object>> getCopyFieldProperties\n      (boolean showDetails, Set<String> requestedSourceFields, Set<String> requestedDestinationFields) {\n    List<SimpleOrderedMap<Object>> copyFieldProperties = new ArrayList<>();\n    SortedMap<String,List<CopyField>> sortedCopyFields = new TreeMap<>(copyFieldsMap);\n    for (List<CopyField> copyFields : sortedCopyFields.values()) {\n      Collections.sort(copyFields, new Comparator<CopyField>() {\n        @Override\n        public int compare(CopyField cf1, CopyField cf2) {\n          // sources are all be the same, just sorting by destination here\n          return cf1.getDestination().getName().compareTo(cf2.getDestination().getName());\n        }\n      });\n      for (CopyField copyField : copyFields) {\n        final String source = copyField.getSource().getName();\n        final String destination = copyField.getDestination().getName();\n        if (   (null == requestedSourceFields      || requestedSourceFields.contains(source))\n            && (null == requestedDestinationFields || requestedDestinationFields.contains(destination))) {\n          SimpleOrderedMap<Object> props = new SimpleOrderedMap<>();\n          props.add(SOURCE, source);\n          props.add(DESTINATION, destination);\n            if (0 != copyField.getMaxChars()) {\n              props.add(MAX_CHARS, copyField.getMaxChars());\n            }\n          copyFieldProperties.add(props);\n        }\n      }\n    }\n    for (IndexSchema.DynamicCopy dynamicCopy : dynamicCopyFields) {\n      final String source = dynamicCopy.getRegex();\n      final String destination = dynamicCopy.getDestFieldName();\n      if (   (null == requestedSourceFields      || requestedSourceFields.contains(source))\n          && (null == requestedDestinationFields || requestedDestinationFields.contains(destination))) {\n        SimpleOrderedMap<Object> dynamicCopyProps = new SimpleOrderedMap<>();\n\n        dynamicCopyProps.add(SOURCE, dynamicCopy.getRegex());\n        if (showDetails) {\n          IndexSchema.DynamicField sourceDynamicBase = dynamicCopy.getSourceDynamicBase();\n          if (null != sourceDynamicBase) {\n            dynamicCopyProps.add(SOURCE_DYNAMIC_BASE, sourceDynamicBase.getRegex());\n          } else if (source.contains(\"*\")) {\n            List<String> sourceExplicitFields = new ArrayList<>();\n            Pattern pattern = Pattern.compile(source.replace(\"*\", \".*\"));   // glob->regex\n            for (String field : fields.keySet()) {\n              if (pattern.matcher(field).matches()) {\n                sourceExplicitFields.add(field);\n              }\n            }\n            if (sourceExplicitFields.size() > 0) {\n              Collections.sort(sourceExplicitFields);\n              dynamicCopyProps.add(SOURCE_EXPLICIT_FIELDS, sourceExplicitFields);\n            }\n          }\n        }\n        \n        dynamicCopyProps.add(DESTINATION, dynamicCopy.getDestFieldName());\n        if (showDetails) {\n          IndexSchema.DynamicField destDynamicBase = dynamicCopy.getDestDynamicBase();\n          if (null != destDynamicBase) {\n            dynamicCopyProps.add(DESTINATION_DYNAMIC_BASE, destDynamicBase.getRegex());\n          }\n        }\n\n        if (0 != dynamicCopy.getMaxChars()) {\n          dynamicCopyProps.add(MAX_CHARS, dynamicCopy.getMaxChars());\n        }\n\n        copyFieldProperties.add(dynamicCopyProps);\n      }\n    }\n    return copyFieldProperties;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cbf48bc10d8aa7b417d61814c87fee4f942cdeca","date":1431530397,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#getCopyFieldProperties(boolean,Set[String],Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#getCopyFieldProperties(boolean,Set[String],Set[String]).mjava","sourceNew":"  /**\n   * Returns a list of copyField directives, with optional details and optionally restricting to those\n   * directives that contain the requested source and/or destination field names.\n   * \n   * @param showDetails If true, source and destination dynamic bases, and explicit fields matched by source globs,\n   *                    will be added to dynamic copyField directives where appropriate\n   * @param requestedSourceFields If not null, output is restricted to those copyField directives\n   *                              with the requested source field names \n   * @param requestedDestinationFields If not null, output is restricted to those copyField directives\n   *                                   with the requested destination field names \n   * @return a list of copyField directives \n   */\n  public List<SimpleOrderedMap<Object>> getCopyFieldProperties\n      (boolean showDetails, Set<String> requestedSourceFields, Set<String> requestedDestinationFields) {\n    List<SimpleOrderedMap<Object>> copyFieldProperties = new ArrayList<>();\n    SortedMap<String,List<CopyField>> sortedCopyFields = new TreeMap<>(copyFieldsMap);\n    for (List<CopyField> copyFields : sortedCopyFields.values()) {\n      copyFields = new ArrayList<>(copyFields);\n      Collections.sort(copyFields, new Comparator<CopyField>() {\n        @Override\n        public int compare(CopyField cf1, CopyField cf2) {\n          // sources are all the same, just sorting by destination here\n          return cf1.getDestination().getName().compareTo(cf2.getDestination().getName());\n        }\n      });\n      for (CopyField copyField : copyFields) {\n        final String source = copyField.getSource().getName();\n        final String destination = copyField.getDestination().getName();\n        if (   (null == requestedSourceFields      || requestedSourceFields.contains(source))\n            && (null == requestedDestinationFields || requestedDestinationFields.contains(destination))) {\n          SimpleOrderedMap<Object> props = new SimpleOrderedMap<>();\n          props.add(SOURCE, source);\n          props.add(DESTINATION, destination);\n            if (0 != copyField.getMaxChars()) {\n              props.add(MAX_CHARS, copyField.getMaxChars());\n            }\n          copyFieldProperties.add(props);\n        }\n      }\n    }\n    if (null != dynamicCopyFields) {\n      for (IndexSchema.DynamicCopy dynamicCopy : dynamicCopyFields) {\n        final String source = dynamicCopy.getRegex();\n        final String destination = dynamicCopy.getDestFieldName();\n        if ((null == requestedSourceFields || requestedSourceFields.contains(source))\n            && (null == requestedDestinationFields || requestedDestinationFields.contains(destination))) {\n          SimpleOrderedMap<Object> dynamicCopyProps = new SimpleOrderedMap<>();\n\n          dynamicCopyProps.add(SOURCE, dynamicCopy.getRegex());\n          if (showDetails) {\n            IndexSchema.DynamicField sourceDynamicBase = dynamicCopy.getSourceDynamicBase();\n            if (null != sourceDynamicBase) {\n              dynamicCopyProps.add(SOURCE_DYNAMIC_BASE, sourceDynamicBase.getRegex());\n            } else if (source.contains(\"*\")) {\n              List<String> sourceExplicitFields = new ArrayList<>();\n              Pattern pattern = Pattern.compile(source.replace(\"*\", \".*\"));   // glob->regex\n              for (String field : fields.keySet()) {\n                if (pattern.matcher(field).matches()) {\n                  sourceExplicitFields.add(field);\n                }\n              }\n              if (sourceExplicitFields.size() > 0) {\n                Collections.sort(sourceExplicitFields);\n                dynamicCopyProps.add(SOURCE_EXPLICIT_FIELDS, sourceExplicitFields);\n              }\n            }\n          }\n\n          dynamicCopyProps.add(DESTINATION, dynamicCopy.getDestFieldName());\n          if (showDetails) {\n            IndexSchema.DynamicField destDynamicBase = dynamicCopy.getDestDynamicBase();\n            if (null != destDynamicBase) {\n              dynamicCopyProps.add(DESTINATION_DYNAMIC_BASE, destDynamicBase.getRegex());\n            }\n          }\n\n          if (0 != dynamicCopy.getMaxChars()) {\n            dynamicCopyProps.add(MAX_CHARS, dynamicCopy.getMaxChars());\n          }\n\n          copyFieldProperties.add(dynamicCopyProps);\n        }\n      }\n    }\n    return copyFieldProperties;\n  }\n\n","sourceOld":"  /**\n   * Returns a list of copyField directives, with optional details and optionally restricting to those\n   * directives that contain the requested source and/or destination field names.\n   * \n   * @param showDetails If true, source and destination dynamic bases, and explicit fields matched by source globs,\n   *                    will be added to dynamic copyField directives where appropriate\n   * @param requestedSourceFields If not null, output is restricted to those copyField directives\n   *                              with the requested source field names \n   * @param requestedDestinationFields If not null, output is restricted to those copyField directives\n   *                                   with the requested destination field names \n   * @return a list of copyField directives \n   */\n  public List<SimpleOrderedMap<Object>> getCopyFieldProperties\n      (boolean showDetails, Set<String> requestedSourceFields, Set<String> requestedDestinationFields) {\n    List<SimpleOrderedMap<Object>> copyFieldProperties = new ArrayList<>();\n    SortedMap<String,List<CopyField>> sortedCopyFields = new TreeMap<>(copyFieldsMap);\n    for (List<CopyField> copyFields : sortedCopyFields.values()) {\n      copyFields = new ArrayList<>(copyFields);\n      Collections.sort(copyFields, new Comparator<CopyField>() {\n        @Override\n        public int compare(CopyField cf1, CopyField cf2) {\n          // sources are all the same, just sorting by destination here\n          return cf1.getDestination().getName().compareTo(cf2.getDestination().getName());\n        }\n      });\n      for (CopyField copyField : copyFields) {\n        final String source = copyField.getSource().getName();\n        final String destination = copyField.getDestination().getName();\n        if (   (null == requestedSourceFields      || requestedSourceFields.contains(source))\n            && (null == requestedDestinationFields || requestedDestinationFields.contains(destination))) {\n          SimpleOrderedMap<Object> props = new SimpleOrderedMap<>();\n          props.add(SOURCE, source);\n          props.add(DESTINATION, destination);\n            if (0 != copyField.getMaxChars()) {\n              props.add(MAX_CHARS, copyField.getMaxChars());\n            }\n          copyFieldProperties.add(props);\n        }\n      }\n    }\n    for (IndexSchema.DynamicCopy dynamicCopy : dynamicCopyFields) {\n      final String source = dynamicCopy.getRegex();\n      final String destination = dynamicCopy.getDestFieldName();\n      if (   (null == requestedSourceFields      || requestedSourceFields.contains(source))\n          && (null == requestedDestinationFields || requestedDestinationFields.contains(destination))) {\n        SimpleOrderedMap<Object> dynamicCopyProps = new SimpleOrderedMap<>();\n\n        dynamicCopyProps.add(SOURCE, dynamicCopy.getRegex());\n        if (showDetails) {\n          IndexSchema.DynamicField sourceDynamicBase = dynamicCopy.getSourceDynamicBase();\n          if (null != sourceDynamicBase) {\n            dynamicCopyProps.add(SOURCE_DYNAMIC_BASE, sourceDynamicBase.getRegex());\n          } else if (source.contains(\"*\")) {\n            List<String> sourceExplicitFields = new ArrayList<>();\n            Pattern pattern = Pattern.compile(source.replace(\"*\", \".*\"));   // glob->regex\n            for (String field : fields.keySet()) {\n              if (pattern.matcher(field).matches()) {\n                sourceExplicitFields.add(field);\n              }\n            }\n            if (sourceExplicitFields.size() > 0) {\n              Collections.sort(sourceExplicitFields);\n              dynamicCopyProps.add(SOURCE_EXPLICIT_FIELDS, sourceExplicitFields);\n            }\n          }\n        }\n        \n        dynamicCopyProps.add(DESTINATION, dynamicCopy.getDestFieldName());\n        if (showDetails) {\n          IndexSchema.DynamicField destDynamicBase = dynamicCopy.getDestDynamicBase();\n          if (null != destDynamicBase) {\n            dynamicCopyProps.add(DESTINATION_DYNAMIC_BASE, destDynamicBase.getRegex());\n          }\n        }\n\n        if (0 != dynamicCopy.getMaxChars()) {\n          dynamicCopyProps.add(MAX_CHARS, dynamicCopy.getMaxChars());\n        }\n\n        copyFieldProperties.add(dynamicCopyProps);\n      }\n    }\n    return copyFieldProperties;\n  }\n\n","bugFix":["d2fa053a06c9c158f82d8e8b53b9a95031f43ebd","634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"bugIntro":["43320f4e37917fa7fd8f8c1e703fc6eaf55d78b3"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3a0c04b71951333291abc7f317109a6a5957bd28","date":1457097827,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#getCopyFieldProperties(boolean,Set[String],Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#getCopyFieldProperties(boolean,Set[String],Set[String]).mjava","sourceNew":"  /**\n   * Returns a list of copyField directives, with optional details and optionally restricting to those\n   * directives that contain the requested source and/or destination field names.\n   * \n   * @param showDetails If true, source and destination dynamic bases, and explicit fields matched by source globs,\n   *                    will be added to dynamic copyField directives where appropriate\n   * @param requestedSourceFields If not null, output is restricted to those copyField directives\n   *                              with the requested source field names \n   * @param requestedDestinationFields If not null, output is restricted to those copyField directives\n   *                                   with the requested destination field names \n   * @return a list of copyField directives \n   */\n  public List<SimpleOrderedMap<Object>> getCopyFieldProperties\n      (boolean showDetails, Set<String> requestedSourceFields, Set<String> requestedDestinationFields) {\n    List<SimpleOrderedMap<Object>> copyFieldProperties = new ArrayList<>();\n    SortedMap<String,List<CopyField>> sortedCopyFields = new TreeMap<>(copyFieldsMap);\n    for (List<CopyField> copyFields : sortedCopyFields.values()) {\n      copyFields = new ArrayList<>(copyFields);\n      Collections.sort(copyFields, (cf1, cf2) -> {\n        // sources are all the same, just sorting by destination here\n        return cf1.getDestination().getName().compareTo(cf2.getDestination().getName());\n      });\n      for (CopyField copyField : copyFields) {\n        final String source = copyField.getSource().getName();\n        final String destination = copyField.getDestination().getName();\n        if (   (null == requestedSourceFields      || requestedSourceFields.contains(source))\n            && (null == requestedDestinationFields || requestedDestinationFields.contains(destination))) {\n          SimpleOrderedMap<Object> props = new SimpleOrderedMap<>();\n          props.add(SOURCE, source);\n          props.add(DESTINATION, destination);\n            if (0 != copyField.getMaxChars()) {\n              props.add(MAX_CHARS, copyField.getMaxChars());\n            }\n          copyFieldProperties.add(props);\n        }\n      }\n    }\n    if (null != dynamicCopyFields) {\n      for (IndexSchema.DynamicCopy dynamicCopy : dynamicCopyFields) {\n        final String source = dynamicCopy.getRegex();\n        final String destination = dynamicCopy.getDestFieldName();\n        if ((null == requestedSourceFields || requestedSourceFields.contains(source))\n            && (null == requestedDestinationFields || requestedDestinationFields.contains(destination))) {\n          SimpleOrderedMap<Object> dynamicCopyProps = new SimpleOrderedMap<>();\n\n          dynamicCopyProps.add(SOURCE, dynamicCopy.getRegex());\n          if (showDetails) {\n            IndexSchema.DynamicField sourceDynamicBase = dynamicCopy.getSourceDynamicBase();\n            if (null != sourceDynamicBase) {\n              dynamicCopyProps.add(SOURCE_DYNAMIC_BASE, sourceDynamicBase.getRegex());\n            } else if (source.contains(\"*\")) {\n              List<String> sourceExplicitFields = new ArrayList<>();\n              Pattern pattern = Pattern.compile(source.replace(\"*\", \".*\"));   // glob->regex\n              for (String field : fields.keySet()) {\n                if (pattern.matcher(field).matches()) {\n                  sourceExplicitFields.add(field);\n                }\n              }\n              if (sourceExplicitFields.size() > 0) {\n                Collections.sort(sourceExplicitFields);\n                dynamicCopyProps.add(SOURCE_EXPLICIT_FIELDS, sourceExplicitFields);\n              }\n            }\n          }\n\n          dynamicCopyProps.add(DESTINATION, dynamicCopy.getDestFieldName());\n          if (showDetails) {\n            IndexSchema.DynamicField destDynamicBase = dynamicCopy.getDestDynamicBase();\n            if (null != destDynamicBase) {\n              dynamicCopyProps.add(DESTINATION_DYNAMIC_BASE, destDynamicBase.getRegex());\n            }\n          }\n\n          if (0 != dynamicCopy.getMaxChars()) {\n            dynamicCopyProps.add(MAX_CHARS, dynamicCopy.getMaxChars());\n          }\n\n          copyFieldProperties.add(dynamicCopyProps);\n        }\n      }\n    }\n    return copyFieldProperties;\n  }\n\n","sourceOld":"  /**\n   * Returns a list of copyField directives, with optional details and optionally restricting to those\n   * directives that contain the requested source and/or destination field names.\n   * \n   * @param showDetails If true, source and destination dynamic bases, and explicit fields matched by source globs,\n   *                    will be added to dynamic copyField directives where appropriate\n   * @param requestedSourceFields If not null, output is restricted to those copyField directives\n   *                              with the requested source field names \n   * @param requestedDestinationFields If not null, output is restricted to those copyField directives\n   *                                   with the requested destination field names \n   * @return a list of copyField directives \n   */\n  public List<SimpleOrderedMap<Object>> getCopyFieldProperties\n      (boolean showDetails, Set<String> requestedSourceFields, Set<String> requestedDestinationFields) {\n    List<SimpleOrderedMap<Object>> copyFieldProperties = new ArrayList<>();\n    SortedMap<String,List<CopyField>> sortedCopyFields = new TreeMap<>(copyFieldsMap);\n    for (List<CopyField> copyFields : sortedCopyFields.values()) {\n      copyFields = new ArrayList<>(copyFields);\n      Collections.sort(copyFields, new Comparator<CopyField>() {\n        @Override\n        public int compare(CopyField cf1, CopyField cf2) {\n          // sources are all the same, just sorting by destination here\n          return cf1.getDestination().getName().compareTo(cf2.getDestination().getName());\n        }\n      });\n      for (CopyField copyField : copyFields) {\n        final String source = copyField.getSource().getName();\n        final String destination = copyField.getDestination().getName();\n        if (   (null == requestedSourceFields      || requestedSourceFields.contains(source))\n            && (null == requestedDestinationFields || requestedDestinationFields.contains(destination))) {\n          SimpleOrderedMap<Object> props = new SimpleOrderedMap<>();\n          props.add(SOURCE, source);\n          props.add(DESTINATION, destination);\n            if (0 != copyField.getMaxChars()) {\n              props.add(MAX_CHARS, copyField.getMaxChars());\n            }\n          copyFieldProperties.add(props);\n        }\n      }\n    }\n    if (null != dynamicCopyFields) {\n      for (IndexSchema.DynamicCopy dynamicCopy : dynamicCopyFields) {\n        final String source = dynamicCopy.getRegex();\n        final String destination = dynamicCopy.getDestFieldName();\n        if ((null == requestedSourceFields || requestedSourceFields.contains(source))\n            && (null == requestedDestinationFields || requestedDestinationFields.contains(destination))) {\n          SimpleOrderedMap<Object> dynamicCopyProps = new SimpleOrderedMap<>();\n\n          dynamicCopyProps.add(SOURCE, dynamicCopy.getRegex());\n          if (showDetails) {\n            IndexSchema.DynamicField sourceDynamicBase = dynamicCopy.getSourceDynamicBase();\n            if (null != sourceDynamicBase) {\n              dynamicCopyProps.add(SOURCE_DYNAMIC_BASE, sourceDynamicBase.getRegex());\n            } else if (source.contains(\"*\")) {\n              List<String> sourceExplicitFields = new ArrayList<>();\n              Pattern pattern = Pattern.compile(source.replace(\"*\", \".*\"));   // glob->regex\n              for (String field : fields.keySet()) {\n                if (pattern.matcher(field).matches()) {\n                  sourceExplicitFields.add(field);\n                }\n              }\n              if (sourceExplicitFields.size() > 0) {\n                Collections.sort(sourceExplicitFields);\n                dynamicCopyProps.add(SOURCE_EXPLICIT_FIELDS, sourceExplicitFields);\n              }\n            }\n          }\n\n          dynamicCopyProps.add(DESTINATION, dynamicCopy.getDestFieldName());\n          if (showDetails) {\n            IndexSchema.DynamicField destDynamicBase = dynamicCopy.getDestDynamicBase();\n            if (null != destDynamicBase) {\n              dynamicCopyProps.add(DESTINATION_DYNAMIC_BASE, destDynamicBase.getRegex());\n            }\n          }\n\n          if (0 != dynamicCopy.getMaxChars()) {\n            dynamicCopyProps.add(MAX_CHARS, dynamicCopy.getMaxChars());\n          }\n\n          copyFieldProperties.add(dynamicCopyProps);\n        }\n      }\n    }\n    return copyFieldProperties;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"43320f4e37917fa7fd8f8c1e703fc6eaf55d78b3","date":1570208701,"type":3,"author":"Thomas Wöckinger","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#getCopyFieldProperties(boolean,Set[String],Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#getCopyFieldProperties(boolean,Set[String],Set[String]).mjava","sourceNew":"  /**\n   * Returns a list of copyField directives, with optional details and optionally restricting to those\n   * directives that contain the requested source and/or destination field names.\n   * \n   * @param showDetails If true, source and destination dynamic bases, and explicit fields matched by source globs,\n   *                    will be added to dynamic copyField directives where appropriate\n   * @param requestedSourceFields If not null, output is restricted to those copyField directives\n   *                              with the requested source field names \n   * @param requestedDestinationFields If not null, output is restricted to those copyField directives\n   *                                   with the requested destination field names \n   * @return a list of copyField directives \n   */\n  public List<SimpleOrderedMap<Object>> getCopyFieldProperties\n      (boolean showDetails, Set<String> requestedSourceFields, Set<String> requestedDestinationFields) {\n    List<SimpleOrderedMap<Object>> copyFieldProperties = new ArrayList<>();\n    SortedMap<String,List<CopyField>> sortedCopyFields = new TreeMap<>(copyFieldsMap);\n    for (List<CopyField> copyFields : sortedCopyFields.values()) {\n      copyFields = new ArrayList<>(copyFields);\n      Collections.sort(copyFields, (cf1, cf2) -> {\n        // sources are all the same, just sorting by destination here\n        return cf1.getDestination().getName().compareTo(cf2.getDestination().getName());\n      });\n      for (CopyField copyField : copyFields) {\n        final String source = copyField.getSource().getName();\n        final String destination = copyField.getDestination().getName();\n        if (   (null == requestedSourceFields      || requestedSourceFields.contains(source))\n            && (null == requestedDestinationFields || requestedDestinationFields.contains(destination))) {\n          SimpleOrderedMap<Object> props = new SimpleOrderedMap<>();\n          props.add(SOURCE, source);\n          props.add(DESTINATION, destination);\n            if (0 != copyField.getMaxChars()) {\n              props.add(MAX_CHARS, copyField.getMaxChars());\n            }\n          copyFieldProperties.add(props);\n        }\n      }\n    }\n    for (IndexSchema.DynamicCopy dynamicCopy : dynamicCopyFields) {\n      final String source = dynamicCopy.getRegex();\n      final String destination = dynamicCopy.getDestFieldName();\n      if ((null == requestedSourceFields || requestedSourceFields.contains(source))\n          && (null == requestedDestinationFields || requestedDestinationFields.contains(destination))) {\n        SimpleOrderedMap<Object> dynamicCopyProps = new SimpleOrderedMap<>();\n\n        dynamicCopyProps.add(SOURCE, dynamicCopy.getRegex());\n        if (showDetails) {\n          IndexSchema.DynamicField sourceDynamicBase = dynamicCopy.getSourceDynamicBase();\n          if (null != sourceDynamicBase) {\n            dynamicCopyProps.add(SOURCE_DYNAMIC_BASE, sourceDynamicBase.getRegex());\n          } else if (source.contains(\"*\")) {\n            List<String> sourceExplicitFields = new ArrayList<>();\n            Pattern pattern = Pattern.compile(source.replace(\"*\", \".*\")); // glob->regex\n            for (String field : fields.keySet()) {\n              if (pattern.matcher(field).matches()) {\n                sourceExplicitFields.add(field);\n              }\n            }\n            if (sourceExplicitFields.size() > 0) {\n              Collections.sort(sourceExplicitFields);\n              dynamicCopyProps.add(SOURCE_EXPLICIT_FIELDS, sourceExplicitFields);\n            }\n          }\n        }\n\n        dynamicCopyProps.add(DESTINATION, dynamicCopy.getDestFieldName());\n        if (showDetails) {\n          IndexSchema.DynamicField destDynamicBase = dynamicCopy.getDestDynamicBase();\n          if (null != destDynamicBase) {\n            dynamicCopyProps.add(DESTINATION_DYNAMIC_BASE, destDynamicBase.getRegex());\n          }\n        }\n\n        if (0 != dynamicCopy.getMaxChars()) {\n          dynamicCopyProps.add(MAX_CHARS, dynamicCopy.getMaxChars());\n        }\n\n        copyFieldProperties.add(dynamicCopyProps);\n      }\n    }\n    return copyFieldProperties;\n  }\n\n","sourceOld":"  /**\n   * Returns a list of copyField directives, with optional details and optionally restricting to those\n   * directives that contain the requested source and/or destination field names.\n   * \n   * @param showDetails If true, source and destination dynamic bases, and explicit fields matched by source globs,\n   *                    will be added to dynamic copyField directives where appropriate\n   * @param requestedSourceFields If not null, output is restricted to those copyField directives\n   *                              with the requested source field names \n   * @param requestedDestinationFields If not null, output is restricted to those copyField directives\n   *                                   with the requested destination field names \n   * @return a list of copyField directives \n   */\n  public List<SimpleOrderedMap<Object>> getCopyFieldProperties\n      (boolean showDetails, Set<String> requestedSourceFields, Set<String> requestedDestinationFields) {\n    List<SimpleOrderedMap<Object>> copyFieldProperties = new ArrayList<>();\n    SortedMap<String,List<CopyField>> sortedCopyFields = new TreeMap<>(copyFieldsMap);\n    for (List<CopyField> copyFields : sortedCopyFields.values()) {\n      copyFields = new ArrayList<>(copyFields);\n      Collections.sort(copyFields, (cf1, cf2) -> {\n        // sources are all the same, just sorting by destination here\n        return cf1.getDestination().getName().compareTo(cf2.getDestination().getName());\n      });\n      for (CopyField copyField : copyFields) {\n        final String source = copyField.getSource().getName();\n        final String destination = copyField.getDestination().getName();\n        if (   (null == requestedSourceFields      || requestedSourceFields.contains(source))\n            && (null == requestedDestinationFields || requestedDestinationFields.contains(destination))) {\n          SimpleOrderedMap<Object> props = new SimpleOrderedMap<>();\n          props.add(SOURCE, source);\n          props.add(DESTINATION, destination);\n            if (0 != copyField.getMaxChars()) {\n              props.add(MAX_CHARS, copyField.getMaxChars());\n            }\n          copyFieldProperties.add(props);\n        }\n      }\n    }\n    if (null != dynamicCopyFields) {\n      for (IndexSchema.DynamicCopy dynamicCopy : dynamicCopyFields) {\n        final String source = dynamicCopy.getRegex();\n        final String destination = dynamicCopy.getDestFieldName();\n        if ((null == requestedSourceFields || requestedSourceFields.contains(source))\n            && (null == requestedDestinationFields || requestedDestinationFields.contains(destination))) {\n          SimpleOrderedMap<Object> dynamicCopyProps = new SimpleOrderedMap<>();\n\n          dynamicCopyProps.add(SOURCE, dynamicCopy.getRegex());\n          if (showDetails) {\n            IndexSchema.DynamicField sourceDynamicBase = dynamicCopy.getSourceDynamicBase();\n            if (null != sourceDynamicBase) {\n              dynamicCopyProps.add(SOURCE_DYNAMIC_BASE, sourceDynamicBase.getRegex());\n            } else if (source.contains(\"*\")) {\n              List<String> sourceExplicitFields = new ArrayList<>();\n              Pattern pattern = Pattern.compile(source.replace(\"*\", \".*\"));   // glob->regex\n              for (String field : fields.keySet()) {\n                if (pattern.matcher(field).matches()) {\n                  sourceExplicitFields.add(field);\n                }\n              }\n              if (sourceExplicitFields.size() > 0) {\n                Collections.sort(sourceExplicitFields);\n                dynamicCopyProps.add(SOURCE_EXPLICIT_FIELDS, sourceExplicitFields);\n              }\n            }\n          }\n\n          dynamicCopyProps.add(DESTINATION, dynamicCopy.getDestFieldName());\n          if (showDetails) {\n            IndexSchema.DynamicField destDynamicBase = dynamicCopy.getDestDynamicBase();\n            if (null != destDynamicBase) {\n              dynamicCopyProps.add(DESTINATION_DYNAMIC_BASE, destDynamicBase.getRegex());\n            }\n          }\n\n          if (0 != dynamicCopy.getMaxChars()) {\n            dynamicCopyProps.add(MAX_CHARS, dynamicCopy.getMaxChars());\n          }\n\n          copyFieldProperties.add(dynamicCopyProps);\n        }\n      }\n    }\n    return copyFieldProperties;\n  }\n\n","bugFix":["d2fa053a06c9c158f82d8e8b53b9a95031f43ebd","cbf48bc10d8aa7b417d61814c87fee4f942cdeca"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":3,"author":"jimczi","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#getCopyFieldProperties(boolean,Set[String],Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#getCopyFieldProperties(boolean,Set[String],Set[String]).mjava","sourceNew":"  /**\n   * Returns a list of copyField directives, with optional details and optionally restricting to those\n   * directives that contain the requested source and/or destination field names.\n   * \n   * @param showDetails If true, source and destination dynamic bases, and explicit fields matched by source globs,\n   *                    will be added to dynamic copyField directives where appropriate\n   * @param requestedSourceFields If not null, output is restricted to those copyField directives\n   *                              with the requested source field names \n   * @param requestedDestinationFields If not null, output is restricted to those copyField directives\n   *                                   with the requested destination field names \n   * @return a list of copyField directives \n   */\n  public List<SimpleOrderedMap<Object>> getCopyFieldProperties\n      (boolean showDetails, Set<String> requestedSourceFields, Set<String> requestedDestinationFields) {\n    List<SimpleOrderedMap<Object>> copyFieldProperties = new ArrayList<>();\n    SortedMap<String,List<CopyField>> sortedCopyFields = new TreeMap<>(copyFieldsMap);\n    for (List<CopyField> copyFields : sortedCopyFields.values()) {\n      copyFields = new ArrayList<>(copyFields);\n      Collections.sort(copyFields, (cf1, cf2) -> {\n        // sources are all the same, just sorting by destination here\n        return cf1.getDestination().getName().compareTo(cf2.getDestination().getName());\n      });\n      for (CopyField copyField : copyFields) {\n        final String source = copyField.getSource().getName();\n        final String destination = copyField.getDestination().getName();\n        if (   (null == requestedSourceFields      || requestedSourceFields.contains(source))\n            && (null == requestedDestinationFields || requestedDestinationFields.contains(destination))) {\n          SimpleOrderedMap<Object> props = new SimpleOrderedMap<>();\n          props.add(SOURCE, source);\n          props.add(DESTINATION, destination);\n            if (0 != copyField.getMaxChars()) {\n              props.add(MAX_CHARS, copyField.getMaxChars());\n            }\n          copyFieldProperties.add(props);\n        }\n      }\n    }\n    for (IndexSchema.DynamicCopy dynamicCopy : dynamicCopyFields) {\n      final String source = dynamicCopy.getRegex();\n      final String destination = dynamicCopy.getDestFieldName();\n      if ((null == requestedSourceFields || requestedSourceFields.contains(source))\n          && (null == requestedDestinationFields || requestedDestinationFields.contains(destination))) {\n        SimpleOrderedMap<Object> dynamicCopyProps = new SimpleOrderedMap<>();\n\n        dynamicCopyProps.add(SOURCE, dynamicCopy.getRegex());\n        if (showDetails) {\n          IndexSchema.DynamicField sourceDynamicBase = dynamicCopy.getSourceDynamicBase();\n          if (null != sourceDynamicBase) {\n            dynamicCopyProps.add(SOURCE_DYNAMIC_BASE, sourceDynamicBase.getRegex());\n          } else if (source.contains(\"*\")) {\n            List<String> sourceExplicitFields = new ArrayList<>();\n            Pattern pattern = Pattern.compile(source.replace(\"*\", \".*\")); // glob->regex\n            for (String field : fields.keySet()) {\n              if (pattern.matcher(field).matches()) {\n                sourceExplicitFields.add(field);\n              }\n            }\n            if (sourceExplicitFields.size() > 0) {\n              Collections.sort(sourceExplicitFields);\n              dynamicCopyProps.add(SOURCE_EXPLICIT_FIELDS, sourceExplicitFields);\n            }\n          }\n        }\n\n        dynamicCopyProps.add(DESTINATION, dynamicCopy.getDestFieldName());\n        if (showDetails) {\n          IndexSchema.DynamicField destDynamicBase = dynamicCopy.getDestDynamicBase();\n          if (null != destDynamicBase) {\n            dynamicCopyProps.add(DESTINATION_DYNAMIC_BASE, destDynamicBase.getRegex());\n          }\n        }\n\n        if (0 != dynamicCopy.getMaxChars()) {\n          dynamicCopyProps.add(MAX_CHARS, dynamicCopy.getMaxChars());\n        }\n\n        copyFieldProperties.add(dynamicCopyProps);\n      }\n    }\n    return copyFieldProperties;\n  }\n\n","sourceOld":"  /**\n   * Returns a list of copyField directives, with optional details and optionally restricting to those\n   * directives that contain the requested source and/or destination field names.\n   * \n   * @param showDetails If true, source and destination dynamic bases, and explicit fields matched by source globs,\n   *                    will be added to dynamic copyField directives where appropriate\n   * @param requestedSourceFields If not null, output is restricted to those copyField directives\n   *                              with the requested source field names \n   * @param requestedDestinationFields If not null, output is restricted to those copyField directives\n   *                                   with the requested destination field names \n   * @return a list of copyField directives \n   */\n  public List<SimpleOrderedMap<Object>> getCopyFieldProperties\n      (boolean showDetails, Set<String> requestedSourceFields, Set<String> requestedDestinationFields) {\n    List<SimpleOrderedMap<Object>> copyFieldProperties = new ArrayList<>();\n    SortedMap<String,List<CopyField>> sortedCopyFields = new TreeMap<>(copyFieldsMap);\n    for (List<CopyField> copyFields : sortedCopyFields.values()) {\n      copyFields = new ArrayList<>(copyFields);\n      Collections.sort(copyFields, (cf1, cf2) -> {\n        // sources are all the same, just sorting by destination here\n        return cf1.getDestination().getName().compareTo(cf2.getDestination().getName());\n      });\n      for (CopyField copyField : copyFields) {\n        final String source = copyField.getSource().getName();\n        final String destination = copyField.getDestination().getName();\n        if (   (null == requestedSourceFields      || requestedSourceFields.contains(source))\n            && (null == requestedDestinationFields || requestedDestinationFields.contains(destination))) {\n          SimpleOrderedMap<Object> props = new SimpleOrderedMap<>();\n          props.add(SOURCE, source);\n          props.add(DESTINATION, destination);\n            if (0 != copyField.getMaxChars()) {\n              props.add(MAX_CHARS, copyField.getMaxChars());\n            }\n          copyFieldProperties.add(props);\n        }\n      }\n    }\n    if (null != dynamicCopyFields) {\n      for (IndexSchema.DynamicCopy dynamicCopy : dynamicCopyFields) {\n        final String source = dynamicCopy.getRegex();\n        final String destination = dynamicCopy.getDestFieldName();\n        if ((null == requestedSourceFields || requestedSourceFields.contains(source))\n            && (null == requestedDestinationFields || requestedDestinationFields.contains(destination))) {\n          SimpleOrderedMap<Object> dynamicCopyProps = new SimpleOrderedMap<>();\n\n          dynamicCopyProps.add(SOURCE, dynamicCopy.getRegex());\n          if (showDetails) {\n            IndexSchema.DynamicField sourceDynamicBase = dynamicCopy.getSourceDynamicBase();\n            if (null != sourceDynamicBase) {\n              dynamicCopyProps.add(SOURCE_DYNAMIC_BASE, sourceDynamicBase.getRegex());\n            } else if (source.contains(\"*\")) {\n              List<String> sourceExplicitFields = new ArrayList<>();\n              Pattern pattern = Pattern.compile(source.replace(\"*\", \".*\"));   // glob->regex\n              for (String field : fields.keySet()) {\n                if (pattern.matcher(field).matches()) {\n                  sourceExplicitFields.add(field);\n                }\n              }\n              if (sourceExplicitFields.size() > 0) {\n                Collections.sort(sourceExplicitFields);\n                dynamicCopyProps.add(SOURCE_EXPLICIT_FIELDS, sourceExplicitFields);\n              }\n            }\n          }\n\n          dynamicCopyProps.add(DESTINATION, dynamicCopy.getDestFieldName());\n          if (showDetails) {\n            IndexSchema.DynamicField destDynamicBase = dynamicCopy.getDestDynamicBase();\n            if (null != destDynamicBase) {\n              dynamicCopyProps.add(DESTINATION_DYNAMIC_BASE, destDynamicBase.getRegex());\n            }\n          }\n\n          if (0 != dynamicCopy.getMaxChars()) {\n            dynamicCopyProps.add(MAX_CHARS, dynamicCopy.getMaxChars());\n          }\n\n          copyFieldProperties.add(dynamicCopyProps);\n        }\n      }\n    }\n    return copyFieldProperties;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b2ed9b72e5fa27a7bd4857f222ca815341979d4a","date":1594879524,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#getCopyFieldProperties(boolean,Set[String],Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/IndexSchema#getCopyFieldProperties(boolean,Set[String],Set[String]).mjava","sourceNew":"  /**\n   * Returns a list of copyField directives, with optional details and optionally restricting to those\n   * directives that contain the requested source and/or destination field names.\n   *\n   * @param showDetails If true, source and destination dynamic bases, and explicit fields matched by source globs,\n   *                    will be added to dynamic copyField directives where appropriate\n   * @param requestedSourceFields If not null, output is restricted to those copyField directives\n   *                              with the requested source field names\n   * @param requestedDestinationFields If not null, output is restricted to those copyField directives\n   *                                   with the requested destination field names\n   * @return a list of copyField directives\n   */\n  public List<SimpleOrderedMap<Object>> getCopyFieldProperties\n      (boolean showDetails, Set<String> requestedSourceFields, Set<String> requestedDestinationFields) {\n    List<SimpleOrderedMap<Object>> copyFieldProperties = new ArrayList<>();\n    SortedMap<String,List<CopyField>> sortedCopyFields = new TreeMap<>(copyFieldsMap);\n    for (List<CopyField> copyFields : sortedCopyFields.values()) {\n      copyFields = new ArrayList<>(copyFields);\n      Collections.sort(copyFields, (cf1, cf2) -> {\n        // sources are all the same, just sorting by destination here\n        return cf1.getDestination().getName().compareTo(cf2.getDestination().getName());\n      });\n      for (CopyField copyField : copyFields) {\n        final String source = copyField.getSource().getName();\n        final String destination = copyField.getDestination().getName();\n        if (   (null == requestedSourceFields      || requestedSourceFields.contains(source))\n            && (null == requestedDestinationFields || requestedDestinationFields.contains(destination))) {\n          SimpleOrderedMap<Object> props = new SimpleOrderedMap<>();\n          props.add(SOURCE, source);\n          props.add(DESTINATION, destination);\n            if (0 != copyField.getMaxChars()) {\n              props.add(MAX_CHARS, copyField.getMaxChars());\n            }\n          copyFieldProperties.add(props);\n        }\n      }\n    }\n    for (IndexSchema.DynamicCopy dynamicCopy : dynamicCopyFields) {\n      final String source = dynamicCopy.getRegex();\n      final String destination = dynamicCopy.getDestFieldName();\n      if ((null == requestedSourceFields || requestedSourceFields.contains(source))\n          && (null == requestedDestinationFields || requestedDestinationFields.contains(destination))) {\n        SimpleOrderedMap<Object> dynamicCopyProps = new SimpleOrderedMap<>();\n\n        dynamicCopyProps.add(SOURCE, dynamicCopy.getRegex());\n        if (showDetails) {\n          IndexSchema.DynamicField sourceDynamicBase = dynamicCopy.getSourceDynamicBase();\n          if (null != sourceDynamicBase) {\n            dynamicCopyProps.add(SOURCE_DYNAMIC_BASE, sourceDynamicBase.getRegex());\n          } else if (source.contains(\"*\")) {\n            List<String> sourceExplicitFields = new ArrayList<>();\n            Pattern pattern = Pattern.compile(source.replace(\"*\", \".*\")); // glob->regex\n            for (String field : fields.keySet()) {\n              if (pattern.matcher(field).matches()) {\n                sourceExplicitFields.add(field);\n              }\n            }\n            if (sourceExplicitFields.size() > 0) {\n              Collections.sort(sourceExplicitFields);\n              dynamicCopyProps.add(SOURCE_EXPLICIT_FIELDS, sourceExplicitFields);\n            }\n          }\n        }\n\n        dynamicCopyProps.add(DESTINATION, dynamicCopy.getDestFieldName());\n        if (showDetails) {\n          IndexSchema.DynamicField destDynamicBase = dynamicCopy.getDestDynamicBase();\n          if (null != destDynamicBase) {\n            dynamicCopyProps.add(DESTINATION_DYNAMIC_BASE, destDynamicBase.getRegex());\n          }\n        }\n\n        if (0 != dynamicCopy.getMaxChars()) {\n          dynamicCopyProps.add(MAX_CHARS, dynamicCopy.getMaxChars());\n        }\n\n        copyFieldProperties.add(dynamicCopyProps);\n      }\n    }\n    return copyFieldProperties;\n  }\n\n","sourceOld":"  /**\n   * Returns a list of copyField directives, with optional details and optionally restricting to those\n   * directives that contain the requested source and/or destination field names.\n   * \n   * @param showDetails If true, source and destination dynamic bases, and explicit fields matched by source globs,\n   *                    will be added to dynamic copyField directives where appropriate\n   * @param requestedSourceFields If not null, output is restricted to those copyField directives\n   *                              with the requested source field names \n   * @param requestedDestinationFields If not null, output is restricted to those copyField directives\n   *                                   with the requested destination field names \n   * @return a list of copyField directives \n   */\n  public List<SimpleOrderedMap<Object>> getCopyFieldProperties\n      (boolean showDetails, Set<String> requestedSourceFields, Set<String> requestedDestinationFields) {\n    List<SimpleOrderedMap<Object>> copyFieldProperties = new ArrayList<>();\n    SortedMap<String,List<CopyField>> sortedCopyFields = new TreeMap<>(copyFieldsMap);\n    for (List<CopyField> copyFields : sortedCopyFields.values()) {\n      copyFields = new ArrayList<>(copyFields);\n      Collections.sort(copyFields, (cf1, cf2) -> {\n        // sources are all the same, just sorting by destination here\n        return cf1.getDestination().getName().compareTo(cf2.getDestination().getName());\n      });\n      for (CopyField copyField : copyFields) {\n        final String source = copyField.getSource().getName();\n        final String destination = copyField.getDestination().getName();\n        if (   (null == requestedSourceFields      || requestedSourceFields.contains(source))\n            && (null == requestedDestinationFields || requestedDestinationFields.contains(destination))) {\n          SimpleOrderedMap<Object> props = new SimpleOrderedMap<>();\n          props.add(SOURCE, source);\n          props.add(DESTINATION, destination);\n            if (0 != copyField.getMaxChars()) {\n              props.add(MAX_CHARS, copyField.getMaxChars());\n            }\n          copyFieldProperties.add(props);\n        }\n      }\n    }\n    for (IndexSchema.DynamicCopy dynamicCopy : dynamicCopyFields) {\n      final String source = dynamicCopy.getRegex();\n      final String destination = dynamicCopy.getDestFieldName();\n      if ((null == requestedSourceFields || requestedSourceFields.contains(source))\n          && (null == requestedDestinationFields || requestedDestinationFields.contains(destination))) {\n        SimpleOrderedMap<Object> dynamicCopyProps = new SimpleOrderedMap<>();\n\n        dynamicCopyProps.add(SOURCE, dynamicCopy.getRegex());\n        if (showDetails) {\n          IndexSchema.DynamicField sourceDynamicBase = dynamicCopy.getSourceDynamicBase();\n          if (null != sourceDynamicBase) {\n            dynamicCopyProps.add(SOURCE_DYNAMIC_BASE, sourceDynamicBase.getRegex());\n          } else if (source.contains(\"*\")) {\n            List<String> sourceExplicitFields = new ArrayList<>();\n            Pattern pattern = Pattern.compile(source.replace(\"*\", \".*\")); // glob->regex\n            for (String field : fields.keySet()) {\n              if (pattern.matcher(field).matches()) {\n                sourceExplicitFields.add(field);\n              }\n            }\n            if (sourceExplicitFields.size() > 0) {\n              Collections.sort(sourceExplicitFields);\n              dynamicCopyProps.add(SOURCE_EXPLICIT_FIELDS, sourceExplicitFields);\n            }\n          }\n        }\n\n        dynamicCopyProps.add(DESTINATION, dynamicCopy.getDestFieldName());\n        if (showDetails) {\n          IndexSchema.DynamicField destDynamicBase = dynamicCopy.getDestDynamicBase();\n          if (null != destDynamicBase) {\n            dynamicCopyProps.add(DESTINATION_DYNAMIC_BASE, destDynamicBase.getRegex());\n          }\n        }\n\n        if (0 != dynamicCopy.getMaxChars()) {\n          dynamicCopyProps.add(MAX_CHARS, dynamicCopy.getMaxChars());\n        }\n\n        copyFieldProperties.add(dynamicCopyProps);\n      }\n    }\n    return copyFieldProperties;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["d2fa053a06c9c158f82d8e8b53b9a95031f43ebd"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","eeeea2295d6355a29e259130a5c48ace73022d7c"],"b2ed9b72e5fa27a7bd4857f222ca815341979d4a":["43320f4e37917fa7fd8f8c1e703fc6eaf55d78b3"],"eeeea2295d6355a29e259130a5c48ace73022d7c":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"d2fa053a06c9c158f82d8e8b53b9a95031f43ebd":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cbf48bc10d8aa7b417d61814c87fee4f942cdeca":["eeeea2295d6355a29e259130a5c48ace73022d7c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"43320f4e37917fa7fd8f8c1e703fc6eaf55d78b3":["3a0c04b71951333291abc7f317109a6a5957bd28"],"3a0c04b71951333291abc7f317109a6a5957bd28":["cbf48bc10d8aa7b417d61814c87fee4f942cdeca"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b2ed9b72e5fa27a7bd4857f222ca815341979d4a"],"b0b597c65628ca9e73913a07e81691f8229bae35":["3a0c04b71951333291abc7f317109a6a5957bd28","43320f4e37917fa7fd8f8c1e703fc6eaf55d78b3"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","eeeea2295d6355a29e259130a5c48ace73022d7c"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"b2ed9b72e5fa27a7bd4857f222ca815341979d4a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d2fa053a06c9c158f82d8e8b53b9a95031f43ebd":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"eeeea2295d6355a29e259130a5c48ace73022d7c":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cbf48bc10d8aa7b417d61814c87fee4f942cdeca"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d2fa053a06c9c158f82d8e8b53b9a95031f43ebd"],"cbf48bc10d8aa7b417d61814c87fee4f942cdeca":["3a0c04b71951333291abc7f317109a6a5957bd28"],"43320f4e37917fa7fd8f8c1e703fc6eaf55d78b3":["b2ed9b72e5fa27a7bd4857f222ca815341979d4a","b0b597c65628ca9e73913a07e81691f8229bae35"],"3a0c04b71951333291abc7f317109a6a5957bd28":["43320f4e37917fa7fd8f8c1e703fc6eaf55d78b3","b0b597c65628ca9e73913a07e81691f8229bae35"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}