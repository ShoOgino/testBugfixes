{"path":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testExactFileNames().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testExactFileNames().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testExactFileNames().mjava","sourceNew":"  public void testExactFileNames() throws IOException {\n\n    String outputDirName = \"lucene.backwardscompat0.index\";\n    File outputDir = _TestUtil.getTempDir(outputDirName);\n    _TestUtil.rmDir(outputDir);\n\n    try {\n      Directory dir = newFSDirectory(outputDir);\n\n      LogMergePolicy mergePolicy = newLogMergePolicy(true, 10);\n      mergePolicy.setNoCFSRatio(1); // This test expects all of its segments to be in CFS\n\n      IndexWriter writer = new IndexWriter(\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).\n              setMaxBufferedDocs(-1).\n              setRAMBufferSizeMB(16.0).\n              setMergePolicy(mergePolicy)\n      );\n      for(int i=0;i<35;i++) {\n        addDoc(writer, i);\n      }\n      assertEquals(\"wrong doc count\", 35, writer.maxDoc());\n      writer.close();\n\n      // Delete one doc so we get a .del file:\n      writer = new IndexWriter(\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random))\n            .setMergePolicy(NoMergePolicy.NO_COMPOUND_FILES)\n      );\n      Term searchTerm = new Term(\"id\", \"7\");\n      writer.deleteDocuments(searchTerm);\n      writer.close();\n\n      // Now verify file names... TODO: fix this test better, we could populate from \n      // separateFiles() or something.\n      String[] expected = new String[] {\"_0.cfs\", \"_0.cfe\",\n                               \"_0_1.del\",\n                               \"segments_2\",\n                               \"segments.gen\"};\n      \n      String[] expectedSimpleText = new String[] {\"_0.cfs\", \"_0.cfe\",\n          \"_0_1.liv\",\n          \"segments_2\",\n          \"segments.gen\"};\n\n      String[] actual = dir.listAll();\n      Arrays.sort(expected);\n      Arrays.sort(expectedSimpleText);\n      Arrays.sort(actual);\n      if (!Arrays.equals(expected, actual) && !Arrays.equals(expectedSimpleText, actual)) {\n        fail(\"incorrect filenames in index: expected:\\n    \" + asString(expected) \n            + \"\\n or \" + asString(expectedSimpleText) + \"\\n actual:\\n    \" + asString(actual));\n      }\n      dir.close();\n    } finally {\n      _TestUtil.rmDir(outputDir);\n    }\n  }\n\n","sourceOld":"  public void testExactFileNames() throws IOException {\n\n    String outputDirName = \"lucene.backwardscompat0.index\";\n    File outputDir = _TestUtil.getTempDir(outputDirName);\n    _TestUtil.rmDir(outputDir);\n\n    try {\n      Directory dir = newFSDirectory(outputDir);\n\n      LogMergePolicy mergePolicy = newLogMergePolicy(true, 10);\n      mergePolicy.setNoCFSRatio(1); // This test expects all of its segments to be in CFS\n\n      IndexWriter writer = new IndexWriter(\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).\n              setMaxBufferedDocs(-1).\n              setRAMBufferSizeMB(16.0).\n              setMergePolicy(mergePolicy)\n      );\n      for(int i=0;i<35;i++) {\n        addDoc(writer, i);\n      }\n      assertEquals(\"wrong doc count\", 35, writer.maxDoc());\n      writer.close();\n\n      // Delete one doc so we get a .del file:\n      writer = new IndexWriter(\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random))\n            .setMergePolicy(NoMergePolicy.NO_COMPOUND_FILES)\n      );\n      Term searchTerm = new Term(\"id\", \"7\");\n      writer.deleteDocuments(searchTerm);\n      writer.close();\n\n      // Now verify file names... TODO: fix this test better, we could populate from \n      // separateFiles() or something.\n      String[] expected = new String[] {\"_0.cfs\", \"_0.cfe\",\n                               \"_0_1.del\",\n                               \"segments_2\",\n                               \"segments.gen\"};\n      \n      String[] expectedSimpleText = new String[] {\"_0.cfs\", \"_0.cfe\",\n          \"_0_1.liv\",\n          \"segments_2\",\n          \"segments.gen\"};\n\n      String[] actual = dir.listAll();\n      Arrays.sort(expected);\n      Arrays.sort(expectedSimpleText);\n      Arrays.sort(actual);\n      if (!Arrays.equals(expected, actual) && !Arrays.equals(expectedSimpleText, actual)) {\n        fail(\"incorrect filenames in index: expected:\\n    \" + asString(expected) \n            + \"\\n or \" + asString(expectedSimpleText) + \"\\n actual:\\n    \" + asString(actual));\n      }\n      dir.close();\n    } finally {\n      _TestUtil.rmDir(outputDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testExactFileNames().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testExactFileNames().mjava","sourceNew":"  public void testExactFileNames() throws IOException {\n\n    String outputDirName = \"lucene.backwardscompat0.index\";\n    File outputDir = _TestUtil.getTempDir(outputDirName);\n    _TestUtil.rmDir(outputDir);\n\n    try {\n      Directory dir = newFSDirectory(outputDir);\n\n      LogMergePolicy mergePolicy = newLogMergePolicy(true, 10);\n      mergePolicy.setNoCFSRatio(1); // This test expects all of its segments to be in CFS\n\n      IndexWriter writer = new IndexWriter(\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).\n              setMaxBufferedDocs(-1).\n              setRAMBufferSizeMB(16.0).\n              setMergePolicy(mergePolicy)\n      );\n      for(int i=0;i<35;i++) {\n        addDoc(writer, i);\n      }\n      assertEquals(\"wrong doc count\", 35, writer.maxDoc());\n      writer.close();\n\n      // Delete one doc so we get a .del file:\n      writer = new IndexWriter(\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()))\n            .setMergePolicy(NoMergePolicy.NO_COMPOUND_FILES)\n      );\n      Term searchTerm = new Term(\"id\", \"7\");\n      writer.deleteDocuments(searchTerm);\n      writer.close();\n\n      // Now verify file names... TODO: fix this test better, we could populate from \n      // separateFiles() or something.\n      String[] expected = new String[] {\"_0.cfs\", \"_0.cfe\",\n                               \"_0_1.del\",\n                               \"segments_2\",\n                               \"segments.gen\"};\n      \n      String[] expectedSimpleText = new String[] {\"_0.cfs\", \"_0.cfe\",\n          \"_0_1.liv\",\n          \"segments_2\",\n          \"segments.gen\"};\n\n      String[] actual = dir.listAll();\n      Arrays.sort(expected);\n      Arrays.sort(expectedSimpleText);\n      Arrays.sort(actual);\n      if (!Arrays.equals(expected, actual) && !Arrays.equals(expectedSimpleText, actual)) {\n        fail(\"incorrect filenames in index: expected:\\n    \" + asString(expected) \n            + \"\\n or \" + asString(expectedSimpleText) + \"\\n actual:\\n    \" + asString(actual));\n      }\n      dir.close();\n    } finally {\n      _TestUtil.rmDir(outputDir);\n    }\n  }\n\n","sourceOld":"  public void testExactFileNames() throws IOException {\n\n    String outputDirName = \"lucene.backwardscompat0.index\";\n    File outputDir = _TestUtil.getTempDir(outputDirName);\n    _TestUtil.rmDir(outputDir);\n\n    try {\n      Directory dir = newFSDirectory(outputDir);\n\n      LogMergePolicy mergePolicy = newLogMergePolicy(true, 10);\n      mergePolicy.setNoCFSRatio(1); // This test expects all of its segments to be in CFS\n\n      IndexWriter writer = new IndexWriter(\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).\n              setMaxBufferedDocs(-1).\n              setRAMBufferSizeMB(16.0).\n              setMergePolicy(mergePolicy)\n      );\n      for(int i=0;i<35;i++) {\n        addDoc(writer, i);\n      }\n      assertEquals(\"wrong doc count\", 35, writer.maxDoc());\n      writer.close();\n\n      // Delete one doc so we get a .del file:\n      writer = new IndexWriter(\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random))\n            .setMergePolicy(NoMergePolicy.NO_COMPOUND_FILES)\n      );\n      Term searchTerm = new Term(\"id\", \"7\");\n      writer.deleteDocuments(searchTerm);\n      writer.close();\n\n      // Now verify file names... TODO: fix this test better, we could populate from \n      // separateFiles() or something.\n      String[] expected = new String[] {\"_0.cfs\", \"_0.cfe\",\n                               \"_0_1.del\",\n                               \"segments_2\",\n                               \"segments.gen\"};\n      \n      String[] expectedSimpleText = new String[] {\"_0.cfs\", \"_0.cfe\",\n          \"_0_1.liv\",\n          \"segments_2\",\n          \"segments.gen\"};\n\n      String[] actual = dir.listAll();\n      Arrays.sort(expected);\n      Arrays.sort(expectedSimpleText);\n      Arrays.sort(actual);\n      if (!Arrays.equals(expected, actual) && !Arrays.equals(expectedSimpleText, actual)) {\n        fail(\"incorrect filenames in index: expected:\\n    \" + asString(expected) \n            + \"\\n or \" + asString(expectedSimpleText) + \"\\n actual:\\n    \" + asString(actual));\n      }\n      dir.close();\n    } finally {\n      _TestUtil.rmDir(outputDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4356000e349e38c9fb48034695b7c309abd54557","date":1337460341,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testExactFileNames().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testExactFileNames().mjava","sourceNew":"  public void testExactFileNames() throws IOException {\n\n    String outputDirName = \"lucene.backwardscompat0.index\";\n    File outputDir = _TestUtil.getTempDir(outputDirName);\n    _TestUtil.rmDir(outputDir);\n\n    try {\n      Directory dir = newFSDirectory(outputDir);\n\n      LogMergePolicy mergePolicy = newLogMergePolicy(true, 10);\n      mergePolicy.setNoCFSRatio(1); // This test expects all of its segments to be in CFS\n\n      IndexWriter writer = new IndexWriter(\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).\n              setMaxBufferedDocs(-1).\n              setRAMBufferSizeMB(16.0).\n              setMergePolicy(mergePolicy)\n      );\n      for(int i=0;i<35;i++) {\n        addDoc(writer, i);\n      }\n      assertEquals(\"wrong doc count\", 35, writer.maxDoc());\n      writer.close();\n\n      // Delete one doc so we get a .del file:\n      writer = new IndexWriter(\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()))\n            .setMergePolicy(NoMergePolicy.NO_COMPOUND_FILES)\n      );\n      Term searchTerm = new Term(\"id\", \"7\");\n      writer.deleteDocuments(searchTerm);\n      writer.close();\n\n      // Now verify file names... TODO: fix this test better, we could populate from \n      // separateFiles() or something.\n      String[] expected = new String[] {\"_0.cfs\", \"_0.cfe\",\n                                        \"_0_1.del\",\n                                        \"_0.si\",\n                                        \"segments_2\",\n                                        \"segments.gen\"};\n      \n      String[] expectedSimpleText = new String[] {\"_0.cfs\", \"_0.cfe\",\n                                                  \"_0_1.liv\",\n                                                  \"_0.si\",\n                                                  \"segments_2\",\n                                                  \"segments.gen\"};\n\n      String[] actual = dir.listAll();\n      Arrays.sort(expected);\n      Arrays.sort(expectedSimpleText);\n      Arrays.sort(actual);\n      if (!Arrays.equals(expected, actual) && !Arrays.equals(expectedSimpleText, actual)) {\n        fail(\"incorrect filenames in index: expected:\\n    \" + asString(expected) \n            + \"\\n or \" + asString(expectedSimpleText) + \"\\n actual:\\n    \" + asString(actual));\n      }\n      dir.close();\n    } finally {\n      _TestUtil.rmDir(outputDir);\n    }\n  }\n\n","sourceOld":"  public void testExactFileNames() throws IOException {\n\n    String outputDirName = \"lucene.backwardscompat0.index\";\n    File outputDir = _TestUtil.getTempDir(outputDirName);\n    _TestUtil.rmDir(outputDir);\n\n    try {\n      Directory dir = newFSDirectory(outputDir);\n\n      LogMergePolicy mergePolicy = newLogMergePolicy(true, 10);\n      mergePolicy.setNoCFSRatio(1); // This test expects all of its segments to be in CFS\n\n      IndexWriter writer = new IndexWriter(\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).\n              setMaxBufferedDocs(-1).\n              setRAMBufferSizeMB(16.0).\n              setMergePolicy(mergePolicy)\n      );\n      for(int i=0;i<35;i++) {\n        addDoc(writer, i);\n      }\n      assertEquals(\"wrong doc count\", 35, writer.maxDoc());\n      writer.close();\n\n      // Delete one doc so we get a .del file:\n      writer = new IndexWriter(\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()))\n            .setMergePolicy(NoMergePolicy.NO_COMPOUND_FILES)\n      );\n      Term searchTerm = new Term(\"id\", \"7\");\n      writer.deleteDocuments(searchTerm);\n      writer.close();\n\n      // Now verify file names... TODO: fix this test better, we could populate from \n      // separateFiles() or something.\n      String[] expected = new String[] {\"_0.cfs\", \"_0.cfe\",\n                               \"_0_1.del\",\n                               \"segments_2\",\n                               \"segments.gen\"};\n      \n      String[] expectedSimpleText = new String[] {\"_0.cfs\", \"_0.cfe\",\n          \"_0_1.liv\",\n          \"segments_2\",\n          \"segments.gen\"};\n\n      String[] actual = dir.listAll();\n      Arrays.sort(expected);\n      Arrays.sort(expectedSimpleText);\n      Arrays.sort(actual);\n      if (!Arrays.equals(expected, actual) && !Arrays.equals(expectedSimpleText, actual)) {\n        fail(\"incorrect filenames in index: expected:\\n    \" + asString(expected) \n            + \"\\n or \" + asString(expectedSimpleText) + \"\\n actual:\\n    \" + asString(actual));\n      }\n      dir.close();\n    } finally {\n      _TestUtil.rmDir(outputDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"615ddbd81799980d0fdd95e0238e1c498b6f47b0","date":1338233290,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testExactFileNames().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testExactFileNames().mjava","sourceNew":"  public void testExactFileNames() throws IOException {\n\n    String outputDirName = \"lucene.backwardscompat0.index\";\n    File outputDir = _TestUtil.getTempDir(outputDirName);\n    _TestUtil.rmDir(outputDir);\n\n    try {\n      Directory dir = newFSDirectory(outputDir);\n\n      LogMergePolicy mergePolicy = newLogMergePolicy(true, 10);\n      mergePolicy.setNoCFSRatio(1); // This test expects all of its segments to be in CFS\n\n      IndexWriter writer = new IndexWriter(\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).\n              setMaxBufferedDocs(-1).\n              setRAMBufferSizeMB(16.0).\n              setMergePolicy(mergePolicy)\n      );\n      for(int i=0;i<35;i++) {\n        addDoc(writer, i);\n      }\n      assertEquals(\"wrong doc count\", 35, writer.maxDoc());\n      writer.close();\n\n      // Delete one doc so we get a .del file:\n      writer = new IndexWriter(\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()))\n            .setMergePolicy(NoMergePolicy.NO_COMPOUND_FILES)\n      );\n      Term searchTerm = new Term(\"id\", \"7\");\n      writer.deleteDocuments(searchTerm);\n      writer.close();\n\n      // Now verify file names... TODO: fix this test better, we could populate from \n      // separateFiles() or something.\n      String[] expected = new String[] {\"_0.cfs\", \"_0.cfe\",\n                                        \"_0_1.del\",\n                                        \"_0.si\",\n                                        \"segments_2\",\n                                        \"segments.gen\"};\n      \n      String[] expectedSimpleText = new String[] {\"_0.cfs\", \"_0.cfe\",\n                                                  \"_0_1.liv\",\n                                                  \"_0.si\",\n                                                  \"segments_2\",\n                                                  \"segments.gen\"};\n\n      String[] actual = dir.listAll();\n      Arrays.sort(expected);\n      Arrays.sort(expectedSimpleText);\n      Arrays.sort(actual);\n      if (!Arrays.equals(expected, actual) && !Arrays.equals(expectedSimpleText, actual)) {\n        fail(\"incorrect filenames in index: expected:\\n    \" + asString(expected) \n            + \"\\n or \" + asString(expectedSimpleText) + \"\\n actual:\\n    \" + asString(actual));\n      }\n      dir.close();\n    } finally {\n      _TestUtil.rmDir(outputDir);\n    }\n  }\n\n","sourceOld":"  public void testExactFileNames() throws IOException {\n\n    String outputDirName = \"lucene.backwardscompat0.index\";\n    File outputDir = _TestUtil.getTempDir(outputDirName);\n    _TestUtil.rmDir(outputDir);\n\n    try {\n      Directory dir = newFSDirectory(outputDir);\n\n      LogMergePolicy mergePolicy = newLogMergePolicy(true, 10);\n      mergePolicy.setNoCFSRatio(1); // This test expects all of its segments to be in CFS\n\n      IndexWriter writer = new IndexWriter(\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).\n              setMaxBufferedDocs(-1).\n              setRAMBufferSizeMB(16.0).\n              setMergePolicy(mergePolicy)\n      );\n      for(int i=0;i<35;i++) {\n        addDoc(writer, i);\n      }\n      assertEquals(\"wrong doc count\", 35, writer.maxDoc());\n      writer.close();\n\n      // Delete one doc so we get a .del file:\n      writer = new IndexWriter(\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()))\n            .setMergePolicy(NoMergePolicy.NO_COMPOUND_FILES)\n      );\n      Term searchTerm = new Term(\"id\", \"7\");\n      writer.deleteDocuments(searchTerm);\n      writer.close();\n\n      // Now verify file names... TODO: fix this test better, we could populate from \n      // separateFiles() or something.\n      String[] expected = new String[] {\"_0.cfs\", \"_0.cfe\",\n                               \"_0_1.del\",\n                               \"segments_2\",\n                               \"segments.gen\"};\n      \n      String[] expectedSimpleText = new String[] {\"_0.cfs\", \"_0.cfe\",\n          \"_0_1.liv\",\n          \"segments_2\",\n          \"segments.gen\"};\n\n      String[] actual = dir.listAll();\n      Arrays.sort(expected);\n      Arrays.sort(expectedSimpleText);\n      Arrays.sort(actual);\n      if (!Arrays.equals(expected, actual) && !Arrays.equals(expectedSimpleText, actual)) {\n        fail(\"incorrect filenames in index: expected:\\n    \" + asString(expected) \n            + \"\\n or \" + asString(expectedSimpleText) + \"\\n actual:\\n    \" + asString(actual));\n      }\n      dir.close();\n    } finally {\n      _TestUtil.rmDir(outputDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"87cac19d31b40ed41f53dd03ed03b6ca5a836098","date":1345969354,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testExactFileNames().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testExactFileNames().mjava","sourceNew":"  public void testExactFileNames() throws IOException {\n\n    String outputDirName = \"lucene.backwardscompat0.index\";\n    File outputDir = _TestUtil.getTempDir(outputDirName);\n    _TestUtil.rmDir(outputDir);\n\n    try {\n      Directory dir = newFSDirectory(outputDir);\n\n      LogMergePolicy mergePolicy = newLogMergePolicy(true, 10);\n      \n      // This test expects all of its segments to be in CFS:\n      mergePolicy.setNoCFSRatio(1.0); \n      mergePolicy.setMaxCFSSegmentSizeMB(Double.POSITIVE_INFINITY);\n\n      IndexWriter writer = new IndexWriter(\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).\n              setMaxBufferedDocs(-1).\n              setRAMBufferSizeMB(16.0).\n              setMergePolicy(mergePolicy)\n      );\n      for(int i=0;i<35;i++) {\n        addDoc(writer, i);\n      }\n      assertEquals(\"wrong doc count\", 35, writer.maxDoc());\n      writer.close();\n\n      // Delete one doc so we get a .del file:\n      writer = new IndexWriter(\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()))\n            .setMergePolicy(NoMergePolicy.NO_COMPOUND_FILES)\n      );\n      Term searchTerm = new Term(\"id\", \"7\");\n      writer.deleteDocuments(searchTerm);\n      writer.close();\n\n      // Now verify file names... TODO: fix this test better, we could populate from \n      // separateFiles() or something.\n      String[] expected = new String[] {\"_0.cfs\", \"_0.cfe\",\n                                        \"_0_1.del\",\n                                        \"_0.si\",\n                                        \"segments_2\",\n                                        \"segments.gen\"};\n      \n      String[] expectedSimpleText = new String[] {\"_0.cfs\", \"_0.cfe\",\n                                                  \"_0_1.liv\",\n                                                  \"_0.si\",\n                                                  \"segments_2\",\n                                                  \"segments.gen\"};\n\n      String[] actual = dir.listAll();\n      Arrays.sort(expected);\n      Arrays.sort(expectedSimpleText);\n      Arrays.sort(actual);\n      if (!Arrays.equals(expected, actual) && !Arrays.equals(expectedSimpleText, actual)) {\n        fail(\"incorrect filenames in index: expected:\\n    \" + asString(expected) \n            + \"\\n or \" + asString(expectedSimpleText) + \"\\n actual:\\n    \" + asString(actual));\n      }\n      dir.close();\n    } finally {\n      _TestUtil.rmDir(outputDir);\n    }\n  }\n\n","sourceOld":"  public void testExactFileNames() throws IOException {\n\n    String outputDirName = \"lucene.backwardscompat0.index\";\n    File outputDir = _TestUtil.getTempDir(outputDirName);\n    _TestUtil.rmDir(outputDir);\n\n    try {\n      Directory dir = newFSDirectory(outputDir);\n\n      LogMergePolicy mergePolicy = newLogMergePolicy(true, 10);\n      mergePolicy.setNoCFSRatio(1); // This test expects all of its segments to be in CFS\n\n      IndexWriter writer = new IndexWriter(\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).\n              setMaxBufferedDocs(-1).\n              setRAMBufferSizeMB(16.0).\n              setMergePolicy(mergePolicy)\n      );\n      for(int i=0;i<35;i++) {\n        addDoc(writer, i);\n      }\n      assertEquals(\"wrong doc count\", 35, writer.maxDoc());\n      writer.close();\n\n      // Delete one doc so we get a .del file:\n      writer = new IndexWriter(\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()))\n            .setMergePolicy(NoMergePolicy.NO_COMPOUND_FILES)\n      );\n      Term searchTerm = new Term(\"id\", \"7\");\n      writer.deleteDocuments(searchTerm);\n      writer.close();\n\n      // Now verify file names... TODO: fix this test better, we could populate from \n      // separateFiles() or something.\n      String[] expected = new String[] {\"_0.cfs\", \"_0.cfe\",\n                                        \"_0_1.del\",\n                                        \"_0.si\",\n                                        \"segments_2\",\n                                        \"segments.gen\"};\n      \n      String[] expectedSimpleText = new String[] {\"_0.cfs\", \"_0.cfe\",\n                                                  \"_0_1.liv\",\n                                                  \"_0.si\",\n                                                  \"segments_2\",\n                                                  \"segments.gen\"};\n\n      String[] actual = dir.listAll();\n      Arrays.sort(expected);\n      Arrays.sort(expectedSimpleText);\n      Arrays.sort(actual);\n      if (!Arrays.equals(expected, actual) && !Arrays.equals(expectedSimpleText, actual)) {\n        fail(\"incorrect filenames in index: expected:\\n    \" + asString(expected) \n            + \"\\n or \" + asString(expectedSimpleText) + \"\\n actual:\\n    \" + asString(actual));\n      }\n      dir.close();\n    } finally {\n      _TestUtil.rmDir(outputDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"05a14b2611ead08655a2b2bdc61632eb31316e57","date":1346366621,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testExactFileNames().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testExactFileNames().mjava","sourceNew":"  public void testExactFileNames() throws IOException {\n\n    String outputDirName = \"lucene.backwardscompat0.index\";\n    File outputDir = _TestUtil.getTempDir(outputDirName);\n    _TestUtil.rmDir(outputDir);\n\n    try {\n      Directory dir = newFSDirectory(outputDir);\n\n      LogMergePolicy mergePolicy = newLogMergePolicy(true, 10);\n      \n      // This test expects all of its segments to be in CFS:\n      mergePolicy.setNoCFSRatio(1.0); \n      mergePolicy.setMaxCFSSegmentSizeMB(Double.POSITIVE_INFINITY);\n\n      IndexWriter writer = new IndexWriter(\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).\n              setMaxBufferedDocs(-1).\n              setRAMBufferSizeMB(16.0).\n              setMergePolicy(mergePolicy)\n      );\n      for(int i=0;i<35;i++) {\n        addDoc(writer, i);\n      }\n      assertEquals(\"wrong doc count\", 35, writer.maxDoc());\n      writer.close();\n\n      // Delete one doc so we get a .del file:\n      writer = new IndexWriter(\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()))\n            .setMergePolicy(NoMergePolicy.NO_COMPOUND_FILES)\n      );\n      Term searchTerm = new Term(\"id\", \"7\");\n      writer.deleteDocuments(searchTerm);\n      writer.close();\n\n      // Now verify file names... TODO: fix this test better, we could populate from \n      // separateFiles() or something.\n      String[] expected = new String[] {\"_0.cfs\", \"_0.cfe\",\n                                        \"_0_1.del\",\n                                        \"_0.si\",\n                                        \"segments_2\",\n                                        \"segments.gen\"};\n      \n      String[] expectedSimpleText = new String[] {\"_0.cfs\", \"_0.cfe\",\n                                                  \"_0_1.liv\",\n                                                  \"_0.si\",\n                                                  \"segments_2\",\n                                                  \"segments.gen\"};\n\n      String[] actual = dir.listAll();\n      Arrays.sort(expected);\n      Arrays.sort(expectedSimpleText);\n      Arrays.sort(actual);\n      if (!Arrays.equals(expected, actual) && !Arrays.equals(expectedSimpleText, actual)) {\n        fail(\"incorrect filenames in index: expected:\\n    \" + asString(expected) \n            + \"\\n or \" + asString(expectedSimpleText) + \"\\n actual:\\n    \" + asString(actual));\n      }\n      dir.close();\n    } finally {\n      _TestUtil.rmDir(outputDir);\n    }\n  }\n\n","sourceOld":"  public void testExactFileNames() throws IOException {\n\n    String outputDirName = \"lucene.backwardscompat0.index\";\n    File outputDir = _TestUtil.getTempDir(outputDirName);\n    _TestUtil.rmDir(outputDir);\n\n    try {\n      Directory dir = newFSDirectory(outputDir);\n\n      LogMergePolicy mergePolicy = newLogMergePolicy(true, 10);\n      mergePolicy.setNoCFSRatio(1); // This test expects all of its segments to be in CFS\n\n      IndexWriter writer = new IndexWriter(\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).\n              setMaxBufferedDocs(-1).\n              setRAMBufferSizeMB(16.0).\n              setMergePolicy(mergePolicy)\n      );\n      for(int i=0;i<35;i++) {\n        addDoc(writer, i);\n      }\n      assertEquals(\"wrong doc count\", 35, writer.maxDoc());\n      writer.close();\n\n      // Delete one doc so we get a .del file:\n      writer = new IndexWriter(\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()))\n            .setMergePolicy(NoMergePolicy.NO_COMPOUND_FILES)\n      );\n      Term searchTerm = new Term(\"id\", \"7\");\n      writer.deleteDocuments(searchTerm);\n      writer.close();\n\n      // Now verify file names... TODO: fix this test better, we could populate from \n      // separateFiles() or something.\n      String[] expected = new String[] {\"_0.cfs\", \"_0.cfe\",\n                                        \"_0_1.del\",\n                                        \"_0.si\",\n                                        \"segments_2\",\n                                        \"segments.gen\"};\n      \n      String[] expectedSimpleText = new String[] {\"_0.cfs\", \"_0.cfe\",\n                                                  \"_0_1.liv\",\n                                                  \"_0.si\",\n                                                  \"segments_2\",\n                                                  \"segments.gen\"};\n\n      String[] actual = dir.listAll();\n      Arrays.sort(expected);\n      Arrays.sort(expectedSimpleText);\n      Arrays.sort(actual);\n      if (!Arrays.equals(expected, actual) && !Arrays.equals(expectedSimpleText, actual)) {\n        fail(\"incorrect filenames in index: expected:\\n    \" + asString(expected) \n            + \"\\n or \" + asString(expectedSimpleText) + \"\\n actual:\\n    \" + asString(actual));\n      }\n      dir.close();\n    } finally {\n      _TestUtil.rmDir(outputDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"088a7ef694fd43d5d9a4d200c4005865f773d1e7","date":1371136274,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testExactFileNames().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testExactFileNames().mjava","sourceNew":"  public void testExactFileNames() throws IOException {\n\n    String outputDirName = \"lucene.backwardscompat0.index\";\n    File outputDir = _TestUtil.getTempDir(outputDirName);\n    _TestUtil.rmDir(outputDir);\n\n    try {\n      Directory dir = newFSDirectory(outputDir);\n\n      MergePolicy mergePolicy = newLogMergePolicy(true, 10);\n      \n      // This test expects all of its segments to be in CFS:\n      mergePolicy.setNoCFSRatio(1.0); \n      mergePolicy.setMaxCFSSegmentSizeMB(Double.POSITIVE_INFINITY);\n\n      IndexWriter writer = new IndexWriter(\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).\n              setMaxBufferedDocs(-1).\n              setRAMBufferSizeMB(16.0).\n              setMergePolicy(mergePolicy).setUseCompoundFile(true)\n      );\n      for(int i=0;i<35;i++) {\n        addDoc(writer, i);\n      }\n      assertEquals(\"wrong doc count\", 35, writer.maxDoc());\n      writer.close();\n\n      // Delete one doc so we get a .del file:\n      writer = new IndexWriter(\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()))\n            .setMergePolicy(NoMergePolicy.NO_COMPOUND_FILES).setUseCompoundFile(true)\n      );\n      Term searchTerm = new Term(\"id\", \"7\");\n      writer.deleteDocuments(searchTerm);\n      writer.close();\n\n      // Now verify file names... TODO: fix this test better, we could populate from \n      // separateFiles() or something.\n      String[] expected = new String[] {\"_0.cfs\", \"_0.cfe\",\n                                        \"_0_1.del\",\n                                        \"_0.si\",\n                                        \"segments_2\",\n                                        \"segments.gen\"};\n      \n      String[] expectedSimpleText = new String[] {\"_0.cfs\", \"_0.cfe\",\n                                                  \"_0_1.liv\",\n                                                  \"_0.si\",\n                                                  \"segments_2\",\n                                                  \"segments.gen\"};\n\n      String[] actual = dir.listAll();\n      Arrays.sort(expected);\n      Arrays.sort(expectedSimpleText);\n      Arrays.sort(actual);\n      if (!Arrays.equals(expected, actual) && !Arrays.equals(expectedSimpleText, actual)) {\n        fail(\"incorrect filenames in index: expected:\\n    \" + asString(expected) \n            + \"\\n or \" + asString(expectedSimpleText) + \"\\n actual:\\n    \" + asString(actual));\n      }\n      dir.close();\n    } finally {\n      _TestUtil.rmDir(outputDir);\n    }\n  }\n\n","sourceOld":"  public void testExactFileNames() throws IOException {\n\n    String outputDirName = \"lucene.backwardscompat0.index\";\n    File outputDir = _TestUtil.getTempDir(outputDirName);\n    _TestUtil.rmDir(outputDir);\n\n    try {\n      Directory dir = newFSDirectory(outputDir);\n\n      LogMergePolicy mergePolicy = newLogMergePolicy(true, 10);\n      \n      // This test expects all of its segments to be in CFS:\n      mergePolicy.setNoCFSRatio(1.0); \n      mergePolicy.setMaxCFSSegmentSizeMB(Double.POSITIVE_INFINITY);\n\n      IndexWriter writer = new IndexWriter(\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).\n              setMaxBufferedDocs(-1).\n              setRAMBufferSizeMB(16.0).\n              setMergePolicy(mergePolicy)\n      );\n      for(int i=0;i<35;i++) {\n        addDoc(writer, i);\n      }\n      assertEquals(\"wrong doc count\", 35, writer.maxDoc());\n      writer.close();\n\n      // Delete one doc so we get a .del file:\n      writer = new IndexWriter(\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()))\n            .setMergePolicy(NoMergePolicy.NO_COMPOUND_FILES)\n      );\n      Term searchTerm = new Term(\"id\", \"7\");\n      writer.deleteDocuments(searchTerm);\n      writer.close();\n\n      // Now verify file names... TODO: fix this test better, we could populate from \n      // separateFiles() or something.\n      String[] expected = new String[] {\"_0.cfs\", \"_0.cfe\",\n                                        \"_0_1.del\",\n                                        \"_0.si\",\n                                        \"segments_2\",\n                                        \"segments.gen\"};\n      \n      String[] expectedSimpleText = new String[] {\"_0.cfs\", \"_0.cfe\",\n                                                  \"_0_1.liv\",\n                                                  \"_0.si\",\n                                                  \"segments_2\",\n                                                  \"segments.gen\"};\n\n      String[] actual = dir.listAll();\n      Arrays.sort(expected);\n      Arrays.sort(expectedSimpleText);\n      Arrays.sort(actual);\n      if (!Arrays.equals(expected, actual) && !Arrays.equals(expectedSimpleText, actual)) {\n        fail(\"incorrect filenames in index: expected:\\n    \" + asString(expected) \n            + \"\\n or \" + asString(expectedSimpleText) + \"\\n actual:\\n    \" + asString(actual));\n      }\n      dir.close();\n    } finally {\n      _TestUtil.rmDir(outputDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testExactFileNames().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testExactFileNames().mjava","sourceNew":"  public void testExactFileNames() throws IOException {\n\n    String outputDirName = \"lucene.backwardscompat0.index\";\n    File outputDir = TestUtil.getTempDir(outputDirName);\n    TestUtil.rmDir(outputDir);\n\n    try {\n      Directory dir = newFSDirectory(outputDir);\n\n      MergePolicy mergePolicy = newLogMergePolicy(true, 10);\n      \n      // This test expects all of its segments to be in CFS:\n      mergePolicy.setNoCFSRatio(1.0); \n      mergePolicy.setMaxCFSSegmentSizeMB(Double.POSITIVE_INFINITY);\n\n      IndexWriter writer = new IndexWriter(\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).\n              setMaxBufferedDocs(-1).\n              setRAMBufferSizeMB(16.0).\n              setMergePolicy(mergePolicy).setUseCompoundFile(true)\n      );\n      for(int i=0;i<35;i++) {\n        addDoc(writer, i);\n      }\n      assertEquals(\"wrong doc count\", 35, writer.maxDoc());\n      writer.close();\n\n      // Delete one doc so we get a .del file:\n      writer = new IndexWriter(\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()))\n            .setMergePolicy(NoMergePolicy.NO_COMPOUND_FILES).setUseCompoundFile(true)\n      );\n      Term searchTerm = new Term(\"id\", \"7\");\n      writer.deleteDocuments(searchTerm);\n      writer.close();\n\n      // Now verify file names... TODO: fix this test better, we could populate from \n      // separateFiles() or something.\n      String[] expected = new String[] {\"_0.cfs\", \"_0.cfe\",\n                                        \"_0_1.del\",\n                                        \"_0.si\",\n                                        \"segments_2\",\n                                        \"segments.gen\"};\n      \n      String[] expectedSimpleText = new String[] {\"_0.cfs\", \"_0.cfe\",\n                                                  \"_0_1.liv\",\n                                                  \"_0.si\",\n                                                  \"segments_2\",\n                                                  \"segments.gen\"};\n\n      String[] actual = dir.listAll();\n      Arrays.sort(expected);\n      Arrays.sort(expectedSimpleText);\n      Arrays.sort(actual);\n      if (!Arrays.equals(expected, actual) && !Arrays.equals(expectedSimpleText, actual)) {\n        fail(\"incorrect filenames in index: expected:\\n    \" + asString(expected) \n            + \"\\n or \" + asString(expectedSimpleText) + \"\\n actual:\\n    \" + asString(actual));\n      }\n      dir.close();\n    } finally {\n      TestUtil.rmDir(outputDir);\n    }\n  }\n\n","sourceOld":"  public void testExactFileNames() throws IOException {\n\n    String outputDirName = \"lucene.backwardscompat0.index\";\n    File outputDir = _TestUtil.getTempDir(outputDirName);\n    _TestUtil.rmDir(outputDir);\n\n    try {\n      Directory dir = newFSDirectory(outputDir);\n\n      MergePolicy mergePolicy = newLogMergePolicy(true, 10);\n      \n      // This test expects all of its segments to be in CFS:\n      mergePolicy.setNoCFSRatio(1.0); \n      mergePolicy.setMaxCFSSegmentSizeMB(Double.POSITIVE_INFINITY);\n\n      IndexWriter writer = new IndexWriter(\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).\n              setMaxBufferedDocs(-1).\n              setRAMBufferSizeMB(16.0).\n              setMergePolicy(mergePolicy).setUseCompoundFile(true)\n      );\n      for(int i=0;i<35;i++) {\n        addDoc(writer, i);\n      }\n      assertEquals(\"wrong doc count\", 35, writer.maxDoc());\n      writer.close();\n\n      // Delete one doc so we get a .del file:\n      writer = new IndexWriter(\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()))\n            .setMergePolicy(NoMergePolicy.NO_COMPOUND_FILES).setUseCompoundFile(true)\n      );\n      Term searchTerm = new Term(\"id\", \"7\");\n      writer.deleteDocuments(searchTerm);\n      writer.close();\n\n      // Now verify file names... TODO: fix this test better, we could populate from \n      // separateFiles() or something.\n      String[] expected = new String[] {\"_0.cfs\", \"_0.cfe\",\n                                        \"_0_1.del\",\n                                        \"_0.si\",\n                                        \"segments_2\",\n                                        \"segments.gen\"};\n      \n      String[] expectedSimpleText = new String[] {\"_0.cfs\", \"_0.cfe\",\n                                                  \"_0_1.liv\",\n                                                  \"_0.si\",\n                                                  \"segments_2\",\n                                                  \"segments.gen\"};\n\n      String[] actual = dir.listAll();\n      Arrays.sort(expected);\n      Arrays.sort(expectedSimpleText);\n      Arrays.sort(actual);\n      if (!Arrays.equals(expected, actual) && !Arrays.equals(expectedSimpleText, actual)) {\n        fail(\"incorrect filenames in index: expected:\\n    \" + asString(expected) \n            + \"\\n or \" + asString(expectedSimpleText) + \"\\n actual:\\n    \" + asString(actual));\n      }\n      dir.close();\n    } finally {\n      _TestUtil.rmDir(outputDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0d579490a72f2e6297eaa648940611234c57cf1","date":1395917140,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testExactFileNames().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testExactFileNames().mjava","sourceNew":"  public void testExactFileNames() throws IOException {\n\n    String outputDirName = \"lucene.backwardscompat0.index\";\n    File outputDir = TestUtil.createTempDir(outputDirName);\n    TestUtil.rmDir(outputDir);\n\n    try {\n      Directory dir = newFSDirectory(outputDir);\n\n      MergePolicy mergePolicy = newLogMergePolicy(true, 10);\n      \n      // This test expects all of its segments to be in CFS:\n      mergePolicy.setNoCFSRatio(1.0); \n      mergePolicy.setMaxCFSSegmentSizeMB(Double.POSITIVE_INFINITY);\n\n      IndexWriter writer = new IndexWriter(\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).\n              setMaxBufferedDocs(-1).\n              setRAMBufferSizeMB(16.0).\n              setMergePolicy(mergePolicy).setUseCompoundFile(true)\n      );\n      for(int i=0;i<35;i++) {\n        addDoc(writer, i);\n      }\n      assertEquals(\"wrong doc count\", 35, writer.maxDoc());\n      writer.close();\n\n      // Delete one doc so we get a .del file:\n      writer = new IndexWriter(\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()))\n            .setMergePolicy(NoMergePolicy.NO_COMPOUND_FILES).setUseCompoundFile(true)\n      );\n      Term searchTerm = new Term(\"id\", \"7\");\n      writer.deleteDocuments(searchTerm);\n      writer.close();\n\n      // Now verify file names... TODO: fix this test better, we could populate from \n      // separateFiles() or something.\n      String[] expected = new String[] {\"_0.cfs\", \"_0.cfe\",\n                                        \"_0_1.del\",\n                                        \"_0.si\",\n                                        \"segments_2\",\n                                        \"segments.gen\"};\n      \n      String[] expectedSimpleText = new String[] {\"_0.cfs\", \"_0.cfe\",\n                                                  \"_0_1.liv\",\n                                                  \"_0.si\",\n                                                  \"segments_2\",\n                                                  \"segments.gen\"};\n\n      String[] actual = dir.listAll();\n      Arrays.sort(expected);\n      Arrays.sort(expectedSimpleText);\n      Arrays.sort(actual);\n      if (!Arrays.equals(expected, actual) && !Arrays.equals(expectedSimpleText, actual)) {\n        fail(\"incorrect filenames in index: expected:\\n    \" + asString(expected) \n            + \"\\n or \" + asString(expectedSimpleText) + \"\\n actual:\\n    \" + asString(actual));\n      }\n      dir.close();\n    } finally {\n      TestUtil.rmDir(outputDir);\n    }\n  }\n\n","sourceOld":"  public void testExactFileNames() throws IOException {\n\n    String outputDirName = \"lucene.backwardscompat0.index\";\n    File outputDir = TestUtil.getTempDir(outputDirName);\n    TestUtil.rmDir(outputDir);\n\n    try {\n      Directory dir = newFSDirectory(outputDir);\n\n      MergePolicy mergePolicy = newLogMergePolicy(true, 10);\n      \n      // This test expects all of its segments to be in CFS:\n      mergePolicy.setNoCFSRatio(1.0); \n      mergePolicy.setMaxCFSSegmentSizeMB(Double.POSITIVE_INFINITY);\n\n      IndexWriter writer = new IndexWriter(\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).\n              setMaxBufferedDocs(-1).\n              setRAMBufferSizeMB(16.0).\n              setMergePolicy(mergePolicy).setUseCompoundFile(true)\n      );\n      for(int i=0;i<35;i++) {\n        addDoc(writer, i);\n      }\n      assertEquals(\"wrong doc count\", 35, writer.maxDoc());\n      writer.close();\n\n      // Delete one doc so we get a .del file:\n      writer = new IndexWriter(\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()))\n            .setMergePolicy(NoMergePolicy.NO_COMPOUND_FILES).setUseCompoundFile(true)\n      );\n      Term searchTerm = new Term(\"id\", \"7\");\n      writer.deleteDocuments(searchTerm);\n      writer.close();\n\n      // Now verify file names... TODO: fix this test better, we could populate from \n      // separateFiles() or something.\n      String[] expected = new String[] {\"_0.cfs\", \"_0.cfe\",\n                                        \"_0_1.del\",\n                                        \"_0.si\",\n                                        \"segments_2\",\n                                        \"segments.gen\"};\n      \n      String[] expectedSimpleText = new String[] {\"_0.cfs\", \"_0.cfe\",\n                                                  \"_0_1.liv\",\n                                                  \"_0.si\",\n                                                  \"segments_2\",\n                                                  \"segments.gen\"};\n\n      String[] actual = dir.listAll();\n      Arrays.sort(expected);\n      Arrays.sort(expectedSimpleText);\n      Arrays.sort(actual);\n      if (!Arrays.equals(expected, actual) && !Arrays.equals(expectedSimpleText, actual)) {\n        fail(\"incorrect filenames in index: expected:\\n    \" + asString(expected) \n            + \"\\n or \" + asString(expectedSimpleText) + \"\\n actual:\\n    \" + asString(actual));\n      }\n      dir.close();\n    } finally {\n      TestUtil.rmDir(outputDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5eb2511ababf862ea11e10761c70ee560cd84510","date":1396607225,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testExactFileNames().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testExactFileNames().mjava","sourceNew":"  public void testExactFileNames() throws IOException {\n\n    String outputDirName = \"lucene.backwardscompat0.index\";\n    File outputDir = TestUtil.createTempDir(outputDirName);\n    TestUtil.rm(outputDir);\n\n    try {\n      Directory dir = newFSDirectory(outputDir);\n\n      MergePolicy mergePolicy = newLogMergePolicy(true, 10);\n      \n      // This test expects all of its segments to be in CFS:\n      mergePolicy.setNoCFSRatio(1.0); \n      mergePolicy.setMaxCFSSegmentSizeMB(Double.POSITIVE_INFINITY);\n\n      IndexWriter writer = new IndexWriter(\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).\n              setMaxBufferedDocs(-1).\n              setRAMBufferSizeMB(16.0).\n              setMergePolicy(mergePolicy).setUseCompoundFile(true)\n      );\n      for(int i=0;i<35;i++) {\n        addDoc(writer, i);\n      }\n      assertEquals(\"wrong doc count\", 35, writer.maxDoc());\n      writer.close();\n\n      // Delete one doc so we get a .del file:\n      writer = new IndexWriter(\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()))\n            .setMergePolicy(NoMergePolicy.NO_COMPOUND_FILES).setUseCompoundFile(true)\n      );\n      Term searchTerm = new Term(\"id\", \"7\");\n      writer.deleteDocuments(searchTerm);\n      writer.close();\n\n      // Now verify file names... TODO: fix this test better, we could populate from \n      // separateFiles() or something.\n      String[] expected = new String[] {\"_0.cfs\", \"_0.cfe\",\n                                        \"_0_1.del\",\n                                        \"_0.si\",\n                                        \"segments_2\",\n                                        \"segments.gen\"};\n      \n      String[] expectedSimpleText = new String[] {\"_0.cfs\", \"_0.cfe\",\n                                                  \"_0_1.liv\",\n                                                  \"_0.si\",\n                                                  \"segments_2\",\n                                                  \"segments.gen\"};\n\n      String[] actual = dir.listAll();\n      Arrays.sort(expected);\n      Arrays.sort(expectedSimpleText);\n      Arrays.sort(actual);\n      if (!Arrays.equals(expected, actual) && !Arrays.equals(expectedSimpleText, actual)) {\n        fail(\"incorrect filenames in index: expected:\\n    \" + asString(expected) \n            + \"\\n or \" + asString(expectedSimpleText) + \"\\n actual:\\n    \" + asString(actual));\n      }\n      dir.close();\n    } finally {\n      TestUtil.rm(outputDir);\n    }\n  }\n\n","sourceOld":"  public void testExactFileNames() throws IOException {\n\n    String outputDirName = \"lucene.backwardscompat0.index\";\n    File outputDir = TestUtil.createTempDir(outputDirName);\n    TestUtil.rmDir(outputDir);\n\n    try {\n      Directory dir = newFSDirectory(outputDir);\n\n      MergePolicy mergePolicy = newLogMergePolicy(true, 10);\n      \n      // This test expects all of its segments to be in CFS:\n      mergePolicy.setNoCFSRatio(1.0); \n      mergePolicy.setMaxCFSSegmentSizeMB(Double.POSITIVE_INFINITY);\n\n      IndexWriter writer = new IndexWriter(\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).\n              setMaxBufferedDocs(-1).\n              setRAMBufferSizeMB(16.0).\n              setMergePolicy(mergePolicy).setUseCompoundFile(true)\n      );\n      for(int i=0;i<35;i++) {\n        addDoc(writer, i);\n      }\n      assertEquals(\"wrong doc count\", 35, writer.maxDoc());\n      writer.close();\n\n      // Delete one doc so we get a .del file:\n      writer = new IndexWriter(\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()))\n            .setMergePolicy(NoMergePolicy.NO_COMPOUND_FILES).setUseCompoundFile(true)\n      );\n      Term searchTerm = new Term(\"id\", \"7\");\n      writer.deleteDocuments(searchTerm);\n      writer.close();\n\n      // Now verify file names... TODO: fix this test better, we could populate from \n      // separateFiles() or something.\n      String[] expected = new String[] {\"_0.cfs\", \"_0.cfe\",\n                                        \"_0_1.del\",\n                                        \"_0.si\",\n                                        \"segments_2\",\n                                        \"segments.gen\"};\n      \n      String[] expectedSimpleText = new String[] {\"_0.cfs\", \"_0.cfe\",\n                                                  \"_0_1.liv\",\n                                                  \"_0.si\",\n                                                  \"segments_2\",\n                                                  \"segments.gen\"};\n\n      String[] actual = dir.listAll();\n      Arrays.sort(expected);\n      Arrays.sort(expectedSimpleText);\n      Arrays.sort(actual);\n      if (!Arrays.equals(expected, actual) && !Arrays.equals(expectedSimpleText, actual)) {\n        fail(\"incorrect filenames in index: expected:\\n    \" + asString(expected) \n            + \"\\n or \" + asString(expectedSimpleText) + \"\\n actual:\\n    \" + asString(actual));\n      }\n      dir.close();\n    } finally {\n      TestUtil.rmDir(outputDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a9a24bae1e63c3bb5ff2fb47b0119240d840ee7c","date":1396633078,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testExactFileNames().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testExactFileNames().mjava","sourceNew":"  public void testExactFileNames() throws IOException {\n\n    String outputDirName = \"lucene.backwardscompat0.index\";\n    File outputDir = createTempDir(outputDirName);\n    TestUtil.rm(outputDir);\n\n    try {\n      Directory dir = newFSDirectory(outputDir);\n\n      MergePolicy mergePolicy = newLogMergePolicy(true, 10);\n      \n      // This test expects all of its segments to be in CFS:\n      mergePolicy.setNoCFSRatio(1.0); \n      mergePolicy.setMaxCFSSegmentSizeMB(Double.POSITIVE_INFINITY);\n\n      IndexWriter writer = new IndexWriter(\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).\n              setMaxBufferedDocs(-1).\n              setRAMBufferSizeMB(16.0).\n              setMergePolicy(mergePolicy).setUseCompoundFile(true)\n      );\n      for(int i=0;i<35;i++) {\n        addDoc(writer, i);\n      }\n      assertEquals(\"wrong doc count\", 35, writer.maxDoc());\n      writer.close();\n\n      // Delete one doc so we get a .del file:\n      writer = new IndexWriter(\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()))\n            .setMergePolicy(NoMergePolicy.NO_COMPOUND_FILES).setUseCompoundFile(true)\n      );\n      Term searchTerm = new Term(\"id\", \"7\");\n      writer.deleteDocuments(searchTerm);\n      writer.close();\n\n      // Now verify file names... TODO: fix this test better, we could populate from \n      // separateFiles() or something.\n      String[] expected = new String[] {\"_0.cfs\", \"_0.cfe\",\n                                        \"_0_1.del\",\n                                        \"_0.si\",\n                                        \"segments_2\",\n                                        \"segments.gen\"};\n      \n      String[] expectedSimpleText = new String[] {\"_0.cfs\", \"_0.cfe\",\n                                                  \"_0_1.liv\",\n                                                  \"_0.si\",\n                                                  \"segments_2\",\n                                                  \"segments.gen\"};\n\n      String[] actual = dir.listAll();\n      Arrays.sort(expected);\n      Arrays.sort(expectedSimpleText);\n      Arrays.sort(actual);\n      if (!Arrays.equals(expected, actual) && !Arrays.equals(expectedSimpleText, actual)) {\n        fail(\"incorrect filenames in index: expected:\\n    \" + asString(expected) \n            + \"\\n or \" + asString(expectedSimpleText) + \"\\n actual:\\n    \" + asString(actual));\n      }\n      dir.close();\n    } finally {\n      TestUtil.rm(outputDir);\n    }\n  }\n\n","sourceOld":"  public void testExactFileNames() throws IOException {\n\n    String outputDirName = \"lucene.backwardscompat0.index\";\n    File outputDir = TestUtil.createTempDir(outputDirName);\n    TestUtil.rm(outputDir);\n\n    try {\n      Directory dir = newFSDirectory(outputDir);\n\n      MergePolicy mergePolicy = newLogMergePolicy(true, 10);\n      \n      // This test expects all of its segments to be in CFS:\n      mergePolicy.setNoCFSRatio(1.0); \n      mergePolicy.setMaxCFSSegmentSizeMB(Double.POSITIVE_INFINITY);\n\n      IndexWriter writer = new IndexWriter(\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).\n              setMaxBufferedDocs(-1).\n              setRAMBufferSizeMB(16.0).\n              setMergePolicy(mergePolicy).setUseCompoundFile(true)\n      );\n      for(int i=0;i<35;i++) {\n        addDoc(writer, i);\n      }\n      assertEquals(\"wrong doc count\", 35, writer.maxDoc());\n      writer.close();\n\n      // Delete one doc so we get a .del file:\n      writer = new IndexWriter(\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()))\n            .setMergePolicy(NoMergePolicy.NO_COMPOUND_FILES).setUseCompoundFile(true)\n      );\n      Term searchTerm = new Term(\"id\", \"7\");\n      writer.deleteDocuments(searchTerm);\n      writer.close();\n\n      // Now verify file names... TODO: fix this test better, we could populate from \n      // separateFiles() or something.\n      String[] expected = new String[] {\"_0.cfs\", \"_0.cfe\",\n                                        \"_0_1.del\",\n                                        \"_0.si\",\n                                        \"segments_2\",\n                                        \"segments.gen\"};\n      \n      String[] expectedSimpleText = new String[] {\"_0.cfs\", \"_0.cfe\",\n                                                  \"_0_1.liv\",\n                                                  \"_0.si\",\n                                                  \"segments_2\",\n                                                  \"segments.gen\"};\n\n      String[] actual = dir.listAll();\n      Arrays.sort(expected);\n      Arrays.sort(expectedSimpleText);\n      Arrays.sort(actual);\n      if (!Arrays.equals(expected, actual) && !Arrays.equals(expectedSimpleText, actual)) {\n        fail(\"incorrect filenames in index: expected:\\n    \" + asString(expected) \n            + \"\\n or \" + asString(expectedSimpleText) + \"\\n actual:\\n    \" + asString(actual));\n      }\n      dir.close();\n    } finally {\n      TestUtil.rm(outputDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2a0f5bb79c600763ffe7b8141df59a3169d31e48","date":1396689440,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testExactFileNames().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testExactFileNames().mjava","sourceNew":"  public void testExactFileNames() throws IOException {\n\n    String outputDirName = \"lucene.backwardscompat0.index\";\n    File outputDir = createTempDir(outputDirName);\n    TestUtil.rm(outputDir);\n\n    try {\n      Directory dir = newFSDirectory(outputDir);\n\n      MergePolicy mergePolicy = newLogMergePolicy(true, 10);\n      \n      // This test expects all of its segments to be in CFS:\n      mergePolicy.setNoCFSRatio(1.0); \n      mergePolicy.setMaxCFSSegmentSizeMB(Double.POSITIVE_INFINITY);\n\n      IndexWriter writer = new IndexWriter(\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).\n              setMaxBufferedDocs(-1).\n              setRAMBufferSizeMB(16.0).\n              setMergePolicy(mergePolicy).setUseCompoundFile(true)\n      );\n      for(int i=0;i<35;i++) {\n        addDoc(writer, i);\n      }\n      assertEquals(\"wrong doc count\", 35, writer.maxDoc());\n      writer.close();\n\n      // Delete one doc so we get a .del file:\n      writer = new IndexWriter(\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()))\n            .setMergePolicy(NoMergePolicy.NO_COMPOUND_FILES).setUseCompoundFile(true)\n      );\n      Term searchTerm = new Term(\"id\", \"7\");\n      writer.deleteDocuments(searchTerm);\n      writer.close();\n\n      // Now verify file names... TODO: fix this test better, we could populate from \n      // separateFiles() or something.\n      String[] expected = new String[] {\"_0.cfs\", \"_0.cfe\",\n                                        \"_0_1.del\",\n                                        \"_0.si\",\n                                        \"segments_2\",\n                                        \"segments.gen\"};\n      \n      String[] expectedSimpleText = new String[] {\"_0.cfs\", \"_0.cfe\",\n                                                  \"_0_1.liv\",\n                                                  \"_0.si\",\n                                                  \"segments_2\",\n                                                  \"segments.gen\"};\n\n      String[] actual = dir.listAll();\n      Arrays.sort(expected);\n      Arrays.sort(expectedSimpleText);\n      Arrays.sort(actual);\n      if (!Arrays.equals(expected, actual) && !Arrays.equals(expectedSimpleText, actual)) {\n        fail(\"incorrect filenames in index: expected:\\n    \" + asString(expected) \n            + \"\\n or \" + asString(expectedSimpleText) + \"\\n actual:\\n    \" + asString(actual));\n      }\n      dir.close();\n    } finally {\n      TestUtil.rm(outputDir);\n    }\n  }\n\n","sourceOld":"  public void testExactFileNames() throws IOException {\n\n    String outputDirName = \"lucene.backwardscompat0.index\";\n    File outputDir = TestUtil.getTempDir(outputDirName);\n    TestUtil.rmDir(outputDir);\n\n    try {\n      Directory dir = newFSDirectory(outputDir);\n\n      MergePolicy mergePolicy = newLogMergePolicy(true, 10);\n      \n      // This test expects all of its segments to be in CFS:\n      mergePolicy.setNoCFSRatio(1.0); \n      mergePolicy.setMaxCFSSegmentSizeMB(Double.POSITIVE_INFINITY);\n\n      IndexWriter writer = new IndexWriter(\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).\n              setMaxBufferedDocs(-1).\n              setRAMBufferSizeMB(16.0).\n              setMergePolicy(mergePolicy).setUseCompoundFile(true)\n      );\n      for(int i=0;i<35;i++) {\n        addDoc(writer, i);\n      }\n      assertEquals(\"wrong doc count\", 35, writer.maxDoc());\n      writer.close();\n\n      // Delete one doc so we get a .del file:\n      writer = new IndexWriter(\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()))\n            .setMergePolicy(NoMergePolicy.NO_COMPOUND_FILES).setUseCompoundFile(true)\n      );\n      Term searchTerm = new Term(\"id\", \"7\");\n      writer.deleteDocuments(searchTerm);\n      writer.close();\n\n      // Now verify file names... TODO: fix this test better, we could populate from \n      // separateFiles() or something.\n      String[] expected = new String[] {\"_0.cfs\", \"_0.cfe\",\n                                        \"_0_1.del\",\n                                        \"_0.si\",\n                                        \"segments_2\",\n                                        \"segments.gen\"};\n      \n      String[] expectedSimpleText = new String[] {\"_0.cfs\", \"_0.cfe\",\n                                                  \"_0_1.liv\",\n                                                  \"_0.si\",\n                                                  \"segments_2\",\n                                                  \"segments.gen\"};\n\n      String[] actual = dir.listAll();\n      Arrays.sort(expected);\n      Arrays.sort(expectedSimpleText);\n      Arrays.sort(actual);\n      if (!Arrays.equals(expected, actual) && !Arrays.equals(expectedSimpleText, actual)) {\n        fail(\"incorrect filenames in index: expected:\\n    \" + asString(expected) \n            + \"\\n or \" + asString(expectedSimpleText) + \"\\n actual:\\n    \" + asString(actual));\n      }\n      dir.close();\n    } finally {\n      TestUtil.rmDir(outputDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae14298f4eec6d5faee6a149f88ba57d14a6f21a","date":1396971290,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testExactFileNames().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testExactFileNames().mjava","sourceNew":"  public void testExactFileNames() throws IOException {\n\n    String outputDirName = \"lucene.backwardscompat0.index\";\n    File outputDir = createTempDir(outputDirName);\n    TestUtil.rm(outputDir);\n\n    try {\n      Directory dir = newFSDirectory(outputDir);\n\n      MergePolicy mergePolicy = newLogMergePolicy(true, 10);\n      \n      // This test expects all of its segments to be in CFS:\n      mergePolicy.setNoCFSRatio(1.0); \n      mergePolicy.setMaxCFSSegmentSizeMB(Double.POSITIVE_INFINITY);\n\n      IndexWriter writer = new IndexWriter(\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).\n              setMaxBufferedDocs(-1).\n              setRAMBufferSizeMB(16.0).\n              setMergePolicy(mergePolicy).setUseCompoundFile(true)\n      );\n      for(int i=0;i<35;i++) {\n        addDoc(writer, i);\n      }\n      assertEquals(\"wrong doc count\", 35, writer.maxDoc());\n      writer.shutdown();\n\n      // Delete one doc so we get a .del file:\n      writer = new IndexWriter(\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()))\n            .setMergePolicy(NoMergePolicy.NO_COMPOUND_FILES).setUseCompoundFile(true)\n      );\n      Term searchTerm = new Term(\"id\", \"7\");\n      writer.deleteDocuments(searchTerm);\n      writer.shutdown();\n\n      // Now verify file names... TODO: fix this test better, we could populate from \n      // separateFiles() or something.\n      String[] expected = new String[] {\"_0.cfs\", \"_0.cfe\",\n                                        \"_0_1.del\",\n                                        \"_0.si\",\n                                        \"segments_2\",\n                                        \"segments.gen\"};\n      \n      String[] expectedSimpleText = new String[] {\"_0.cfs\", \"_0.cfe\",\n                                                  \"_0_1.liv\",\n                                                  \"_0.si\",\n                                                  \"segments_2\",\n                                                  \"segments.gen\"};\n\n      String[] actual = dir.listAll();\n      Arrays.sort(expected);\n      Arrays.sort(expectedSimpleText);\n      Arrays.sort(actual);\n      if (!Arrays.equals(expected, actual) && !Arrays.equals(expectedSimpleText, actual)) {\n        fail(\"incorrect filenames in index: expected:\\n    \" + asString(expected) \n            + \"\\n or \" + asString(expectedSimpleText) + \"\\n actual:\\n    \" + asString(actual));\n      }\n      dir.close();\n    } finally {\n      TestUtil.rm(outputDir);\n    }\n  }\n\n","sourceOld":"  public void testExactFileNames() throws IOException {\n\n    String outputDirName = \"lucene.backwardscompat0.index\";\n    File outputDir = createTempDir(outputDirName);\n    TestUtil.rm(outputDir);\n\n    try {\n      Directory dir = newFSDirectory(outputDir);\n\n      MergePolicy mergePolicy = newLogMergePolicy(true, 10);\n      \n      // This test expects all of its segments to be in CFS:\n      mergePolicy.setNoCFSRatio(1.0); \n      mergePolicy.setMaxCFSSegmentSizeMB(Double.POSITIVE_INFINITY);\n\n      IndexWriter writer = new IndexWriter(\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).\n              setMaxBufferedDocs(-1).\n              setRAMBufferSizeMB(16.0).\n              setMergePolicy(mergePolicy).setUseCompoundFile(true)\n      );\n      for(int i=0;i<35;i++) {\n        addDoc(writer, i);\n      }\n      assertEquals(\"wrong doc count\", 35, writer.maxDoc());\n      writer.close();\n\n      // Delete one doc so we get a .del file:\n      writer = new IndexWriter(\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()))\n            .setMergePolicy(NoMergePolicy.NO_COMPOUND_FILES).setUseCompoundFile(true)\n      );\n      Term searchTerm = new Term(\"id\", \"7\");\n      writer.deleteDocuments(searchTerm);\n      writer.close();\n\n      // Now verify file names... TODO: fix this test better, we could populate from \n      // separateFiles() or something.\n      String[] expected = new String[] {\"_0.cfs\", \"_0.cfe\",\n                                        \"_0_1.del\",\n                                        \"_0.si\",\n                                        \"segments_2\",\n                                        \"segments.gen\"};\n      \n      String[] expectedSimpleText = new String[] {\"_0.cfs\", \"_0.cfe\",\n                                                  \"_0_1.liv\",\n                                                  \"_0.si\",\n                                                  \"segments_2\",\n                                                  \"segments.gen\"};\n\n      String[] actual = dir.listAll();\n      Arrays.sort(expected);\n      Arrays.sort(expectedSimpleText);\n      Arrays.sort(actual);\n      if (!Arrays.equals(expected, actual) && !Arrays.equals(expectedSimpleText, actual)) {\n        fail(\"incorrect filenames in index: expected:\\n    \" + asString(expected) \n            + \"\\n or \" + asString(expectedSimpleText) + \"\\n actual:\\n    \" + asString(actual));\n      }\n      dir.close();\n    } finally {\n      TestUtil.rm(outputDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"50805be75df24f05d29a4d2a496c7ec825cde9eb","date":1398078566,"type":4,"author":"Robert Muir","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testExactFileNames().mjava","sourceNew":null,"sourceOld":"  public void testExactFileNames() throws IOException {\n\n    String outputDirName = \"lucene.backwardscompat0.index\";\n    File outputDir = createTempDir(outputDirName);\n    TestUtil.rm(outputDir);\n\n    try {\n      Directory dir = newFSDirectory(outputDir);\n\n      MergePolicy mergePolicy = newLogMergePolicy(true, 10);\n      \n      // This test expects all of its segments to be in CFS:\n      mergePolicy.setNoCFSRatio(1.0); \n      mergePolicy.setMaxCFSSegmentSizeMB(Double.POSITIVE_INFINITY);\n\n      IndexWriter writer = new IndexWriter(\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).\n              setMaxBufferedDocs(-1).\n              setRAMBufferSizeMB(16.0).\n              setMergePolicy(mergePolicy).setUseCompoundFile(true)\n      );\n      for(int i=0;i<35;i++) {\n        addDoc(writer, i);\n      }\n      assertEquals(\"wrong doc count\", 35, writer.maxDoc());\n      writer.shutdown();\n\n      // Delete one doc so we get a .del file:\n      writer = new IndexWriter(\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()))\n            .setMergePolicy(NoMergePolicy.NO_COMPOUND_FILES).setUseCompoundFile(true)\n      );\n      Term searchTerm = new Term(\"id\", \"7\");\n      writer.deleteDocuments(searchTerm);\n      writer.shutdown();\n\n      // Now verify file names... TODO: fix this test better, we could populate from \n      // separateFiles() or something.\n      String[] expected = new String[] {\"_0.cfs\", \"_0.cfe\",\n                                        \"_0_1.del\",\n                                        \"_0.si\",\n                                        \"segments_2\",\n                                        \"segments.gen\"};\n      \n      String[] expectedSimpleText = new String[] {\"_0.cfs\", \"_0.cfe\",\n                                                  \"_0_1.liv\",\n                                                  \"_0.si\",\n                                                  \"segments_2\",\n                                                  \"segments.gen\"};\n\n      String[] actual = dir.listAll();\n      Arrays.sort(expected);\n      Arrays.sort(expectedSimpleText);\n      Arrays.sort(actual);\n      if (!Arrays.equals(expected, actual) && !Arrays.equals(expectedSimpleText, actual)) {\n        fail(\"incorrect filenames in index: expected:\\n    \" + asString(expected) \n            + \"\\n or \" + asString(expectedSimpleText) + \"\\n actual:\\n    \" + asString(actual));\n      }\n      dir.close();\n    } finally {\n      TestUtil.rm(outputDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5eb2511ababf862ea11e10761c70ee560cd84510":["d0d579490a72f2e6297eaa648940611234c57cf1","6613659748fe4411a7dcf85266e55db1f95f7315"],"2a0f5bb79c600763ffe7b8141df59a3169d31e48":["6613659748fe4411a7dcf85266e55db1f95f7315","a9a24bae1e63c3bb5ff2fb47b0119240d840ee7c"],"6613659748fe4411a7dcf85266e55db1f95f7315":["088a7ef694fd43d5d9a4d200c4005865f773d1e7"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d0d579490a72f2e6297eaa648940611234c57cf1":["6613659748fe4411a7dcf85266e55db1f95f7315"],"05a14b2611ead08655a2b2bdc61632eb31316e57":["615ddbd81799980d0fdd95e0238e1c498b6f47b0","87cac19d31b40ed41f53dd03ed03b6ca5a836098"],"87cac19d31b40ed41f53dd03ed03b6ca5a836098":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"088a7ef694fd43d5d9a4d200c4005865f773d1e7":["87cac19d31b40ed41f53dd03ed03b6ca5a836098"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["629c38c4ae4e303d0617e05fbfe508140b32f0a3","4356000e349e38c9fb48034695b7c309abd54557"],"4356000e349e38c9fb48034695b7c309abd54557":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"a9a24bae1e63c3bb5ff2fb47b0119240d840ee7c":["5eb2511ababf862ea11e10761c70ee560cd84510"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"50805be75df24f05d29a4d2a496c7ec825cde9eb":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["2a0f5bb79c600763ffe7b8141df59a3169d31e48"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["50805be75df24f05d29a4d2a496c7ec825cde9eb"]},"commit2Childs":{"5eb2511ababf862ea11e10761c70ee560cd84510":["a9a24bae1e63c3bb5ff2fb47b0119240d840ee7c"],"2a0f5bb79c600763ffe7b8141df59a3169d31e48":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"6613659748fe4411a7dcf85266e55db1f95f7315":["5eb2511ababf862ea11e10761c70ee560cd84510","2a0f5bb79c600763ffe7b8141df59a3169d31e48","d0d579490a72f2e6297eaa648940611234c57cf1"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"d0d579490a72f2e6297eaa648940611234c57cf1":["5eb2511ababf862ea11e10761c70ee560cd84510"],"05a14b2611ead08655a2b2bdc61632eb31316e57":[],"87cac19d31b40ed41f53dd03ed03b6ca5a836098":["05a14b2611ead08655a2b2bdc61632eb31316e57","088a7ef694fd43d5d9a4d200c4005865f773d1e7"],"088a7ef694fd43d5d9a4d200c4005865f773d1e7":["6613659748fe4411a7dcf85266e55db1f95f7315"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["05a14b2611ead08655a2b2bdc61632eb31316e57","87cac19d31b40ed41f53dd03ed03b6ca5a836098"],"4356000e349e38c9fb48034695b7c309abd54557":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"a9a24bae1e63c3bb5ff2fb47b0119240d840ee7c":["2a0f5bb79c600763ffe7b8141df59a3169d31e48"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"50805be75df24f05d29a4d2a496c7ec825cde9eb":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["50805be75df24f05d29a4d2a496c7ec825cde9eb"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["615ddbd81799980d0fdd95e0238e1c498b6f47b0","4356000e349e38c9fb48034695b7c309abd54557"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["05a14b2611ead08655a2b2bdc61632eb31316e57","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}