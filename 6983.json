{"path":"lucene/core/src/test/org/apache/lucene/util/fst/TestBytesStore#verify(BytesStore,byte[],int).mjava","commits":[{"id":"87e78f3c129251e74ecc2ff73a32de0f27cf09d5","date":1358006150,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestBytesStore#verify(BytesStore,byte[],int).mjava","pathOld":"/dev/null","sourceNew":"  private void verify(BytesStore bytes, byte[] expected, int totalLength) throws Exception {\n    assertEquals(totalLength, bytes.getPosition());\n    if (totalLength == 0) {\n      return;\n    }\n    if (VERBOSE) {\n      System.out.println(\"  verify...\");\n    }\n    \n    // First verify whole thing in one blast:\n    byte[] actual = new byte[totalLength];\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"    bulk: reversed\");\n      }\n      // reversed\n      FST.BytesReader r = bytes.getReverseReader();\n      assertTrue(r.reversed());\n      r.setPosition(totalLength-1);\n      r.readBytes(actual, 0, actual.length);\n      int start = 0;\n      int end = totalLength - 1;\n      while(start < end) {\n        byte b = actual[start];\n        actual[start] = actual[end];\n        actual[end] = b;\n        start++;\n        end--;\n      }\n    } else {\n      // forward\n      if (VERBOSE) {\n        System.out.println(\"    bulk: forward\");\n      }\n      FST.BytesReader r = bytes.getForwardReader();\n      assertFalse(r.reversed());\n      r.readBytes(actual, 0, actual.length);\n    }\n\n    for(int i=0;i<totalLength;i++) {\n      assertEquals(\"byte @ index=\" + i, expected[i], actual[i]);\n    }\n\n    FST.BytesReader r;\n\n    // Then verify ops:\n    boolean reversed = random().nextBoolean();\n    if (reversed) {\n      if (VERBOSE) {\n        System.out.println(\"    ops: reversed\");\n      }\n      r = bytes.getReverseReader();\n    } else {\n      if (VERBOSE) {\n        System.out.println(\"    ops: forward\");\n      }\n      r = bytes.getForwardReader();\n    }\n\n    if (totalLength > 1) {\n      int numOps = _TestUtil.nextInt(random(), 100, 200);\n      for(int op=0;op<numOps;op++) {\n\n        int numBytes = random().nextInt(Math.min(1000, totalLength-1));\n        int pos;\n        if (reversed) {\n          pos = _TestUtil.nextInt(random(), numBytes, totalLength-1);\n        } else {\n          pos = random().nextInt(totalLength-numBytes);\n        }\n        if (VERBOSE) {\n          System.out.println(\"    op iter=\" + op + \" reversed=\" + reversed + \" numBytes=\" + numBytes + \" pos=\" + pos);\n        }\n        byte[] temp = new byte[numBytes];\n        r.setPosition(pos);\n        assertEquals(pos, r.getPosition());\n        r.readBytes(temp, 0, temp.length);\n        for(int i=0;i<numBytes;i++) {\n          byte expectedByte;\n          if (reversed) {\n            expectedByte = expected[pos - i];\n          } else {\n            expectedByte = expected[pos + i];\n          }\n          assertEquals(\"byte @ index=\" + i, expectedByte, temp[i]);\n        }\n\n        int left;\n        int expectedPos;\n\n        if (reversed) {\n          expectedPos = pos-numBytes;\n          left = r.getPosition();\n        } else {\n          expectedPos = pos+numBytes;\n          left = totalLength - r.getPosition();\n        }\n        assertEquals(expectedPos, r.getPosition());\n\n        if (left > 4) {\n          int skipBytes = random().nextInt(left-4);\n\n          int expectedInt = 0;\n          if (reversed) {\n            expectedPos -= skipBytes;\n            expectedInt |= (expected[expectedPos--]&0xFF)<<24;\n            expectedInt |= (expected[expectedPos--]&0xFF)<<16;\n            expectedInt |= (expected[expectedPos--]&0xFF)<<8;\n            expectedInt |= (expected[expectedPos--]&0xFF);\n          } else {\n            expectedPos += skipBytes;\n            expectedInt |= (expected[expectedPos++]&0xFF)<<24;\n            expectedInt |= (expected[expectedPos++]&0xFF)<<16;\n            expectedInt |= (expected[expectedPos++]&0xFF)<<8;\n            expectedInt |= (expected[expectedPos++]&0xFF);\n          }\n\n          if (VERBOSE) {\n            System.out.println(\"    skip numBytes=\" + skipBytes);\n            System.out.println(\"    readInt\");\n          }\n\n          r.skipBytes(skipBytes);\n          assertEquals(expectedInt, r.readInt());\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3c397b1515e745d8b12d70edfc0e17cb7eac7f0","date":1358188277,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestBytesStore#verify(BytesStore,byte[],int).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestBytesStore#verify(BytesStore,byte[],int).mjava","sourceNew":"  private void verify(BytesStore bytes, byte[] expected, int totalLength) throws Exception {\n    assertEquals(totalLength, bytes.getPosition());\n    if (totalLength == 0) {\n      return;\n    }\n    if (VERBOSE) {\n      System.out.println(\"  verify...\");\n    }\n    \n    // First verify whole thing in one blast:\n    byte[] actual = new byte[totalLength];\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"    bulk: reversed\");\n      }\n      // reversed\n      FST.BytesReader r = bytes.getReverseReader();\n      assertTrue(r.reversed());\n      r.setPosition(totalLength-1);\n      r.readBytes(actual, 0, actual.length);\n      int start = 0;\n      int end = totalLength - 1;\n      while(start < end) {\n        byte b = actual[start];\n        actual[start] = actual[end];\n        actual[end] = b;\n        start++;\n        end--;\n      }\n    } else {\n      // forward\n      if (VERBOSE) {\n        System.out.println(\"    bulk: forward\");\n      }\n      FST.BytesReader r = bytes.getForwardReader();\n      assertFalse(r.reversed());\n      r.readBytes(actual, 0, actual.length);\n    }\n\n    for(int i=0;i<totalLength;i++) {\n      assertEquals(\"byte @ index=\" + i, expected[i], actual[i]);\n    }\n\n    FST.BytesReader r;\n\n    // Then verify ops:\n    boolean reversed = random().nextBoolean();\n    if (reversed) {\n      if (VERBOSE) {\n        System.out.println(\"    ops: reversed\");\n      }\n      r = bytes.getReverseReader();\n    } else {\n      if (VERBOSE) {\n        System.out.println(\"    ops: forward\");\n      }\n      r = bytes.getForwardReader();\n    }\n\n    if (totalLength > 1) {\n      int numOps = _TestUtil.nextInt(random(), 100, 200);\n      for(int op=0;op<numOps;op++) {\n\n        int numBytes = random().nextInt(Math.min(1000, totalLength-1));\n        int pos;\n        if (reversed) {\n          pos = _TestUtil.nextInt(random(), numBytes, totalLength-1);\n        } else {\n          pos = random().nextInt(totalLength-numBytes);\n        }\n        if (VERBOSE) {\n          System.out.println(\"    op iter=\" + op + \" reversed=\" + reversed + \" numBytes=\" + numBytes + \" pos=\" + pos);\n        }\n        byte[] temp = new byte[numBytes];\n        r.setPosition(pos);\n        assertEquals(pos, r.getPosition());\n        r.readBytes(temp, 0, temp.length);\n        for(int i=0;i<numBytes;i++) {\n          byte expectedByte;\n          if (reversed) {\n            expectedByte = expected[pos - i];\n          } else {\n            expectedByte = expected[pos + i];\n          }\n          assertEquals(\"byte @ index=\" + i, expectedByte, temp[i]);\n        }\n\n        int left;\n        int expectedPos;\n\n        if (reversed) {\n          expectedPos = pos-numBytes;\n          left = (int) r.getPosition();\n        } else {\n          expectedPos = pos+numBytes;\n          left = (int) (totalLength - r.getPosition());\n        }\n        assertEquals(expectedPos, r.getPosition());\n\n        if (left > 4) {\n          int skipBytes = random().nextInt(left-4);\n\n          int expectedInt = 0;\n          if (reversed) {\n            expectedPos -= skipBytes;\n            expectedInt |= (expected[expectedPos--]&0xFF)<<24;\n            expectedInt |= (expected[expectedPos--]&0xFF)<<16;\n            expectedInt |= (expected[expectedPos--]&0xFF)<<8;\n            expectedInt |= (expected[expectedPos--]&0xFF);\n          } else {\n            expectedPos += skipBytes;\n            expectedInt |= (expected[expectedPos++]&0xFF)<<24;\n            expectedInt |= (expected[expectedPos++]&0xFF)<<16;\n            expectedInt |= (expected[expectedPos++]&0xFF)<<8;\n            expectedInt |= (expected[expectedPos++]&0xFF);\n          }\n\n          if (VERBOSE) {\n            System.out.println(\"    skip numBytes=\" + skipBytes);\n            System.out.println(\"    readInt\");\n          }\n\n          r.skipBytes(skipBytes);\n          assertEquals(expectedInt, r.readInt());\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void verify(BytesStore bytes, byte[] expected, int totalLength) throws Exception {\n    assertEquals(totalLength, bytes.getPosition());\n    if (totalLength == 0) {\n      return;\n    }\n    if (VERBOSE) {\n      System.out.println(\"  verify...\");\n    }\n    \n    // First verify whole thing in one blast:\n    byte[] actual = new byte[totalLength];\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"    bulk: reversed\");\n      }\n      // reversed\n      FST.BytesReader r = bytes.getReverseReader();\n      assertTrue(r.reversed());\n      r.setPosition(totalLength-1);\n      r.readBytes(actual, 0, actual.length);\n      int start = 0;\n      int end = totalLength - 1;\n      while(start < end) {\n        byte b = actual[start];\n        actual[start] = actual[end];\n        actual[end] = b;\n        start++;\n        end--;\n      }\n    } else {\n      // forward\n      if (VERBOSE) {\n        System.out.println(\"    bulk: forward\");\n      }\n      FST.BytesReader r = bytes.getForwardReader();\n      assertFalse(r.reversed());\n      r.readBytes(actual, 0, actual.length);\n    }\n\n    for(int i=0;i<totalLength;i++) {\n      assertEquals(\"byte @ index=\" + i, expected[i], actual[i]);\n    }\n\n    FST.BytesReader r;\n\n    // Then verify ops:\n    boolean reversed = random().nextBoolean();\n    if (reversed) {\n      if (VERBOSE) {\n        System.out.println(\"    ops: reversed\");\n      }\n      r = bytes.getReverseReader();\n    } else {\n      if (VERBOSE) {\n        System.out.println(\"    ops: forward\");\n      }\n      r = bytes.getForwardReader();\n    }\n\n    if (totalLength > 1) {\n      int numOps = _TestUtil.nextInt(random(), 100, 200);\n      for(int op=0;op<numOps;op++) {\n\n        int numBytes = random().nextInt(Math.min(1000, totalLength-1));\n        int pos;\n        if (reversed) {\n          pos = _TestUtil.nextInt(random(), numBytes, totalLength-1);\n        } else {\n          pos = random().nextInt(totalLength-numBytes);\n        }\n        if (VERBOSE) {\n          System.out.println(\"    op iter=\" + op + \" reversed=\" + reversed + \" numBytes=\" + numBytes + \" pos=\" + pos);\n        }\n        byte[] temp = new byte[numBytes];\n        r.setPosition(pos);\n        assertEquals(pos, r.getPosition());\n        r.readBytes(temp, 0, temp.length);\n        for(int i=0;i<numBytes;i++) {\n          byte expectedByte;\n          if (reversed) {\n            expectedByte = expected[pos - i];\n          } else {\n            expectedByte = expected[pos + i];\n          }\n          assertEquals(\"byte @ index=\" + i, expectedByte, temp[i]);\n        }\n\n        int left;\n        int expectedPos;\n\n        if (reversed) {\n          expectedPos = pos-numBytes;\n          left = r.getPosition();\n        } else {\n          expectedPos = pos+numBytes;\n          left = totalLength - r.getPosition();\n        }\n        assertEquals(expectedPos, r.getPosition());\n\n        if (left > 4) {\n          int skipBytes = random().nextInt(left-4);\n\n          int expectedInt = 0;\n          if (reversed) {\n            expectedPos -= skipBytes;\n            expectedInt |= (expected[expectedPos--]&0xFF)<<24;\n            expectedInt |= (expected[expectedPos--]&0xFF)<<16;\n            expectedInt |= (expected[expectedPos--]&0xFF)<<8;\n            expectedInt |= (expected[expectedPos--]&0xFF);\n          } else {\n            expectedPos += skipBytes;\n            expectedInt |= (expected[expectedPos++]&0xFF)<<24;\n            expectedInt |= (expected[expectedPos++]&0xFF)<<16;\n            expectedInt |= (expected[expectedPos++]&0xFF)<<8;\n            expectedInt |= (expected[expectedPos++]&0xFF);\n          }\n\n          if (VERBOSE) {\n            System.out.println(\"    skip numBytes=\" + skipBytes);\n            System.out.println(\"    readInt\");\n          }\n\n          r.skipBytes(skipBytes);\n          assertEquals(expectedInt, r.readInt());\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8917bfede3b4ca30f4305c1e391e9218959cd723","date":1358189662,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestBytesStore#verify(BytesStore,byte[],int).mjava","pathOld":"/dev/null","sourceNew":"  private void verify(BytesStore bytes, byte[] expected, int totalLength) throws Exception {\n    assertEquals(totalLength, bytes.getPosition());\n    if (totalLength == 0) {\n      return;\n    }\n    if (VERBOSE) {\n      System.out.println(\"  verify...\");\n    }\n    \n    // First verify whole thing in one blast:\n    byte[] actual = new byte[totalLength];\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"    bulk: reversed\");\n      }\n      // reversed\n      FST.BytesReader r = bytes.getReverseReader();\n      assertTrue(r.reversed());\n      r.setPosition(totalLength-1);\n      r.readBytes(actual, 0, actual.length);\n      int start = 0;\n      int end = totalLength - 1;\n      while(start < end) {\n        byte b = actual[start];\n        actual[start] = actual[end];\n        actual[end] = b;\n        start++;\n        end--;\n      }\n    } else {\n      // forward\n      if (VERBOSE) {\n        System.out.println(\"    bulk: forward\");\n      }\n      FST.BytesReader r = bytes.getForwardReader();\n      assertFalse(r.reversed());\n      r.readBytes(actual, 0, actual.length);\n    }\n\n    for(int i=0;i<totalLength;i++) {\n      assertEquals(\"byte @ index=\" + i, expected[i], actual[i]);\n    }\n\n    FST.BytesReader r;\n\n    // Then verify ops:\n    boolean reversed = random().nextBoolean();\n    if (reversed) {\n      if (VERBOSE) {\n        System.out.println(\"    ops: reversed\");\n      }\n      r = bytes.getReverseReader();\n    } else {\n      if (VERBOSE) {\n        System.out.println(\"    ops: forward\");\n      }\n      r = bytes.getForwardReader();\n    }\n\n    if (totalLength > 1) {\n      int numOps = _TestUtil.nextInt(random(), 100, 200);\n      for(int op=0;op<numOps;op++) {\n\n        int numBytes = random().nextInt(Math.min(1000, totalLength-1));\n        int pos;\n        if (reversed) {\n          pos = _TestUtil.nextInt(random(), numBytes, totalLength-1);\n        } else {\n          pos = random().nextInt(totalLength-numBytes);\n        }\n        if (VERBOSE) {\n          System.out.println(\"    op iter=\" + op + \" reversed=\" + reversed + \" numBytes=\" + numBytes + \" pos=\" + pos);\n        }\n        byte[] temp = new byte[numBytes];\n        r.setPosition(pos);\n        assertEquals(pos, r.getPosition());\n        r.readBytes(temp, 0, temp.length);\n        for(int i=0;i<numBytes;i++) {\n          byte expectedByte;\n          if (reversed) {\n            expectedByte = expected[pos - i];\n          } else {\n            expectedByte = expected[pos + i];\n          }\n          assertEquals(\"byte @ index=\" + i, expectedByte, temp[i]);\n        }\n\n        int left;\n        int expectedPos;\n\n        if (reversed) {\n          expectedPos = pos-numBytes;\n          left = (int) r.getPosition();\n        } else {\n          expectedPos = pos+numBytes;\n          left = (int) (totalLength - r.getPosition());\n        }\n        assertEquals(expectedPos, r.getPosition());\n\n        if (left > 4) {\n          int skipBytes = random().nextInt(left-4);\n\n          int expectedInt = 0;\n          if (reversed) {\n            expectedPos -= skipBytes;\n            expectedInt |= (expected[expectedPos--]&0xFF)<<24;\n            expectedInt |= (expected[expectedPos--]&0xFF)<<16;\n            expectedInt |= (expected[expectedPos--]&0xFF)<<8;\n            expectedInt |= (expected[expectedPos--]&0xFF);\n          } else {\n            expectedPos += skipBytes;\n            expectedInt |= (expected[expectedPos++]&0xFF)<<24;\n            expectedInt |= (expected[expectedPos++]&0xFF)<<16;\n            expectedInt |= (expected[expectedPos++]&0xFF)<<8;\n            expectedInt |= (expected[expectedPos++]&0xFF);\n          }\n\n          if (VERBOSE) {\n            System.out.println(\"    skip numBytes=\" + skipBytes);\n            System.out.println(\"    readInt\");\n          }\n\n          r.skipBytes(skipBytes);\n          assertEquals(expectedInt, r.readInt());\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestBytesStore#verify(BytesStore,byte[],int).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestBytesStore#verify(BytesStore,byte[],int).mjava","sourceNew":"  private void verify(BytesStore bytes, byte[] expected, int totalLength) throws Exception {\n    assertEquals(totalLength, bytes.getPosition());\n    if (totalLength == 0) {\n      return;\n    }\n    if (VERBOSE) {\n      System.out.println(\"  verify...\");\n    }\n    \n    // First verify whole thing in one blast:\n    byte[] actual = new byte[totalLength];\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"    bulk: reversed\");\n      }\n      // reversed\n      FST.BytesReader r = bytes.getReverseReader();\n      assertTrue(r.reversed());\n      r.setPosition(totalLength-1);\n      r.readBytes(actual, 0, actual.length);\n      int start = 0;\n      int end = totalLength - 1;\n      while(start < end) {\n        byte b = actual[start];\n        actual[start] = actual[end];\n        actual[end] = b;\n        start++;\n        end--;\n      }\n    } else {\n      // forward\n      if (VERBOSE) {\n        System.out.println(\"    bulk: forward\");\n      }\n      FST.BytesReader r = bytes.getForwardReader();\n      assertFalse(r.reversed());\n      r.readBytes(actual, 0, actual.length);\n    }\n\n    for(int i=0;i<totalLength;i++) {\n      assertEquals(\"byte @ index=\" + i, expected[i], actual[i]);\n    }\n\n    FST.BytesReader r;\n\n    // Then verify ops:\n    boolean reversed = random().nextBoolean();\n    if (reversed) {\n      if (VERBOSE) {\n        System.out.println(\"    ops: reversed\");\n      }\n      r = bytes.getReverseReader();\n    } else {\n      if (VERBOSE) {\n        System.out.println(\"    ops: forward\");\n      }\n      r = bytes.getForwardReader();\n    }\n\n    if (totalLength > 1) {\n      int numOps = TestUtil.nextInt(random(), 100, 200);\n      for(int op=0;op<numOps;op++) {\n\n        int numBytes = random().nextInt(Math.min(1000, totalLength-1));\n        int pos;\n        if (reversed) {\n          pos = TestUtil.nextInt(random(), numBytes, totalLength - 1);\n        } else {\n          pos = random().nextInt(totalLength-numBytes);\n        }\n        if (VERBOSE) {\n          System.out.println(\"    op iter=\" + op + \" reversed=\" + reversed + \" numBytes=\" + numBytes + \" pos=\" + pos);\n        }\n        byte[] temp = new byte[numBytes];\n        r.setPosition(pos);\n        assertEquals(pos, r.getPosition());\n        r.readBytes(temp, 0, temp.length);\n        for(int i=0;i<numBytes;i++) {\n          byte expectedByte;\n          if (reversed) {\n            expectedByte = expected[pos - i];\n          } else {\n            expectedByte = expected[pos + i];\n          }\n          assertEquals(\"byte @ index=\" + i, expectedByte, temp[i]);\n        }\n\n        int left;\n        int expectedPos;\n\n        if (reversed) {\n          expectedPos = pos-numBytes;\n          left = (int) r.getPosition();\n        } else {\n          expectedPos = pos+numBytes;\n          left = (int) (totalLength - r.getPosition());\n        }\n        assertEquals(expectedPos, r.getPosition());\n\n        if (left > 4) {\n          int skipBytes = random().nextInt(left-4);\n\n          int expectedInt = 0;\n          if (reversed) {\n            expectedPos -= skipBytes;\n            expectedInt |= (expected[expectedPos--]&0xFF)<<24;\n            expectedInt |= (expected[expectedPos--]&0xFF)<<16;\n            expectedInt |= (expected[expectedPos--]&0xFF)<<8;\n            expectedInt |= (expected[expectedPos--]&0xFF);\n          } else {\n            expectedPos += skipBytes;\n            expectedInt |= (expected[expectedPos++]&0xFF)<<24;\n            expectedInt |= (expected[expectedPos++]&0xFF)<<16;\n            expectedInt |= (expected[expectedPos++]&0xFF)<<8;\n            expectedInt |= (expected[expectedPos++]&0xFF);\n          }\n\n          if (VERBOSE) {\n            System.out.println(\"    skip numBytes=\" + skipBytes);\n            System.out.println(\"    readInt\");\n          }\n\n          r.skipBytes(skipBytes);\n          assertEquals(expectedInt, r.readInt());\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void verify(BytesStore bytes, byte[] expected, int totalLength) throws Exception {\n    assertEquals(totalLength, bytes.getPosition());\n    if (totalLength == 0) {\n      return;\n    }\n    if (VERBOSE) {\n      System.out.println(\"  verify...\");\n    }\n    \n    // First verify whole thing in one blast:\n    byte[] actual = new byte[totalLength];\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"    bulk: reversed\");\n      }\n      // reversed\n      FST.BytesReader r = bytes.getReverseReader();\n      assertTrue(r.reversed());\n      r.setPosition(totalLength-1);\n      r.readBytes(actual, 0, actual.length);\n      int start = 0;\n      int end = totalLength - 1;\n      while(start < end) {\n        byte b = actual[start];\n        actual[start] = actual[end];\n        actual[end] = b;\n        start++;\n        end--;\n      }\n    } else {\n      // forward\n      if (VERBOSE) {\n        System.out.println(\"    bulk: forward\");\n      }\n      FST.BytesReader r = bytes.getForwardReader();\n      assertFalse(r.reversed());\n      r.readBytes(actual, 0, actual.length);\n    }\n\n    for(int i=0;i<totalLength;i++) {\n      assertEquals(\"byte @ index=\" + i, expected[i], actual[i]);\n    }\n\n    FST.BytesReader r;\n\n    // Then verify ops:\n    boolean reversed = random().nextBoolean();\n    if (reversed) {\n      if (VERBOSE) {\n        System.out.println(\"    ops: reversed\");\n      }\n      r = bytes.getReverseReader();\n    } else {\n      if (VERBOSE) {\n        System.out.println(\"    ops: forward\");\n      }\n      r = bytes.getForwardReader();\n    }\n\n    if (totalLength > 1) {\n      int numOps = _TestUtil.nextInt(random(), 100, 200);\n      for(int op=0;op<numOps;op++) {\n\n        int numBytes = random().nextInt(Math.min(1000, totalLength-1));\n        int pos;\n        if (reversed) {\n          pos = _TestUtil.nextInt(random(), numBytes, totalLength-1);\n        } else {\n          pos = random().nextInt(totalLength-numBytes);\n        }\n        if (VERBOSE) {\n          System.out.println(\"    op iter=\" + op + \" reversed=\" + reversed + \" numBytes=\" + numBytes + \" pos=\" + pos);\n        }\n        byte[] temp = new byte[numBytes];\n        r.setPosition(pos);\n        assertEquals(pos, r.getPosition());\n        r.readBytes(temp, 0, temp.length);\n        for(int i=0;i<numBytes;i++) {\n          byte expectedByte;\n          if (reversed) {\n            expectedByte = expected[pos - i];\n          } else {\n            expectedByte = expected[pos + i];\n          }\n          assertEquals(\"byte @ index=\" + i, expectedByte, temp[i]);\n        }\n\n        int left;\n        int expectedPos;\n\n        if (reversed) {\n          expectedPos = pos-numBytes;\n          left = (int) r.getPosition();\n        } else {\n          expectedPos = pos+numBytes;\n          left = (int) (totalLength - r.getPosition());\n        }\n        assertEquals(expectedPos, r.getPosition());\n\n        if (left > 4) {\n          int skipBytes = random().nextInt(left-4);\n\n          int expectedInt = 0;\n          if (reversed) {\n            expectedPos -= skipBytes;\n            expectedInt |= (expected[expectedPos--]&0xFF)<<24;\n            expectedInt |= (expected[expectedPos--]&0xFF)<<16;\n            expectedInt |= (expected[expectedPos--]&0xFF)<<8;\n            expectedInt |= (expected[expectedPos--]&0xFF);\n          } else {\n            expectedPos += skipBytes;\n            expectedInt |= (expected[expectedPos++]&0xFF)<<24;\n            expectedInt |= (expected[expectedPos++]&0xFF)<<16;\n            expectedInt |= (expected[expectedPos++]&0xFF)<<8;\n            expectedInt |= (expected[expectedPos++]&0xFF);\n          }\n\n          if (VERBOSE) {\n            System.out.println(\"    skip numBytes=\" + skipBytes);\n            System.out.println(\"    readInt\");\n          }\n\n          r.skipBytes(skipBytes);\n          assertEquals(expectedInt, r.readInt());\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3c397b1515e745d8b12d70edfc0e17cb7eac7f0":["87e78f3c129251e74ecc2ff73a32de0f27cf09d5"],"6613659748fe4411a7dcf85266e55db1f95f7315":["d3c397b1515e745d8b12d70edfc0e17cb7eac7f0"],"8917bfede3b4ca30f4305c1e391e9218959cd723":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","d3c397b1515e745d8b12d70edfc0e17cb7eac7f0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"87e78f3c129251e74ecc2ff73a32de0f27cf09d5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6613659748fe4411a7dcf85266e55db1f95f7315"]},"commit2Childs":{"d3c397b1515e745d8b12d70edfc0e17cb7eac7f0":["6613659748fe4411a7dcf85266e55db1f95f7315","8917bfede3b4ca30f4305c1e391e9218959cd723"],"6613659748fe4411a7dcf85266e55db1f95f7315":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"8917bfede3b4ca30f4305c1e391e9218959cd723":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8917bfede3b4ca30f4305c1e391e9218959cd723","87e78f3c129251e74ecc2ff73a32de0f27cf09d5"],"87e78f3c129251e74ecc2ff73a32de0f27cf09d5":["d3c397b1515e745d8b12d70edfc0e17cb7eac7f0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["8917bfede3b4ca30f4305c1e391e9218959cd723","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}