{"path":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Stemmer#stem(char[],int).mjava","commits":[{"id":"dc3f094cafa4a87b4066e1d6710fa4e6afe6260e","date":1393532367,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Stemmer#stem(char[],int).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell2/Stemmer#stem(char[],int).mjava","sourceNew":"  /**\n   * Find the stem(s) of the provided word\n   * \n   * @param word Word to find the stems for\n   * @return List of stems for the word\n   */\n  public List<CharsRef> stem(char word[], int length) {\n    if (dictionary.ignoreCase) {\n      charUtils.toLowerCase(word, 0, length);\n    }\n    List<CharsRef> stems = new ArrayList<CharsRef>();\n    if (dictionary.lookupWord(word, 0, length, scratch) != null) {\n      stems.add(new CharsRef(word, 0, length));\n    }\n    stems.addAll(stem(word, length, Dictionary.NOFLAGS, 0));\n    return stems;\n  }\n\n","sourceOld":"  /**\n   * Find the stem(s) of the provided word\n   * \n   * @param word Word to find the stems for\n   * @return List of stems for the word\n   */\n  public List<CharsRef> stem(char word[], int length) {\n    List<CharsRef> stems = new ArrayList<CharsRef>();\n    if (dictionary.lookupWord(word, 0, length, scratch) != null) {\n      stems.add(new CharsRef(word, 0, length));\n    }\n    stems.addAll(stem(word, length, Dictionary.NOFLAGS, 0));\n    return stems;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ba791bce8103c79e38f957e9c5a53a75871bd918","date":1393539206,"type":1,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Stemmer#stem(char[],int).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/HunspellStemmer#stem(char[],int).mjava","sourceNew":"  /**\n   * Find the stem(s) of the provided word\n   * \n   * @param word Word to find the stems for\n   * @return List of stems for the word\n   */\n  public List<CharsRef> stem(char word[], int length) {\n    if (dictionary.ignoreCase) {\n      charUtils.toLowerCase(word, 0, length);\n    }\n    List<CharsRef> stems = new ArrayList<CharsRef>();\n    if (dictionary.lookupWord(word, 0, length, scratch) != null) {\n      stems.add(new CharsRef(word, 0, length));\n    }\n    stems.addAll(stem(word, length, Dictionary.NOFLAGS, 0));\n    return stems;\n  }\n\n","sourceOld":"  /**\n   * Find the stem(s) of the provided word\n   * \n   * @param word Word to find the stems for\n   * @return List of stems for the word\n   */\n  public List<Stem> stem(char word[], int length) {\n    List<Stem> stems = new ArrayList<Stem>();\n    if (dictionary.lookupWord(word, 0, length) != null) {\n      stems.add(new Stem(word, length));\n    }\n    stems.addAll(stem(word, length, null, 0));\n    return stems;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b58bd8dd457a9b46b007c641d5b6e747afb8904a","date":1393616676,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Stemmer#stem(char[],int).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Stemmer#stem(char[],int).mjava","sourceNew":"  /**\n   * Find the stem(s) of the provided word\n   * \n   * @param word Word to find the stems for\n   * @return List of stems for the word\n   */\n  public List<CharsRef> stem(char word[], int length) {\n    if (dictionary.ignoreCase) {\n      charUtils.toLowerCase(word, 0, length);\n    }\n    List<CharsRef> stems = new ArrayList<CharsRef>();\n    IntsRef forms = dictionary.lookupWord(word, 0, length);\n    if (forms != null) {\n      // TODO: some forms should not be added, e.g. ONLYINCOMPOUND\n      // just because it exists, does not make it valid...\n      for (int i = 0; i < forms.length; i++) {\n        stems.add(new CharsRef(word, 0, length));\n      }\n    }\n    stems.addAll(stem(word, length, Dictionary.NOFLAGS, 0));\n    return stems;\n  }\n\n","sourceOld":"  /**\n   * Find the stem(s) of the provided word\n   * \n   * @param word Word to find the stems for\n   * @return List of stems for the word\n   */\n  public List<CharsRef> stem(char word[], int length) {\n    if (dictionary.ignoreCase) {\n      charUtils.toLowerCase(word, 0, length);\n    }\n    List<CharsRef> stems = new ArrayList<CharsRef>();\n    if (dictionary.lookupWord(word, 0, length, scratch) != null) {\n      stems.add(new CharsRef(word, 0, length));\n    }\n    stems.addAll(stem(word, length, Dictionary.NOFLAGS, 0));\n    return stems;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1bc1343e76d5f1ad7d6a35dd8c55fb52f9b4e3a7","date":1393724838,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Stemmer#stem(char[],int).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Stemmer#stem(char[],int).mjava","sourceNew":"  /**\n   * Find the stem(s) of the provided word\n   * \n   * @param word Word to find the stems for\n   * @return List of stems for the word\n   */\n  public List<CharsRef> stem(char word[], int length) {\n    if (dictionary.ignoreCase) {\n      charUtils.toLowerCase(word, 0, length);\n    }\n    List<CharsRef> stems = new ArrayList<CharsRef>();\n    IntsRef forms = dictionary.lookupWord(word, 0, length);\n    if (forms != null) {\n      // TODO: some forms should not be added, e.g. ONLYINCOMPOUND\n      // just because it exists, does not make it valid...\n      for (int i = 0; i < forms.length; i++) {\n        stems.add(new CharsRef(word, 0, length));\n      }\n    }\n    stems.addAll(stem(word, length, -1, -1, -1, 0, true, true, false));\n    return stems;\n  }\n\n","sourceOld":"  /**\n   * Find the stem(s) of the provided word\n   * \n   * @param word Word to find the stems for\n   * @return List of stems for the word\n   */\n  public List<CharsRef> stem(char word[], int length) {\n    if (dictionary.ignoreCase) {\n      charUtils.toLowerCase(word, 0, length);\n    }\n    List<CharsRef> stems = new ArrayList<CharsRef>();\n    IntsRef forms = dictionary.lookupWord(word, 0, length);\n    if (forms != null) {\n      // TODO: some forms should not be added, e.g. ONLYINCOMPOUND\n      // just because it exists, does not make it valid...\n      for (int i = 0; i < forms.length; i++) {\n        stems.add(new CharsRef(word, 0, length));\n      }\n    }\n    stems.addAll(stem(word, length, Dictionary.NOFLAGS, 0));\n    return stems;\n  }\n\n","bugFix":["f01af929441dec992bb546ac539c0bf40ae90965"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"38e7d0aeceab994177a0a6b52f475611b52f09bf","date":1393856424,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Stemmer#stem(char[],int).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Stemmer#stem(char[],int).mjava","sourceNew":"  /**\n   * Find the stem(s) of the provided word\n   * \n   * @param word Word to find the stems for\n   * @return List of stems for the word\n   */\n  public List<CharsRef> stem(char word[], int length) {\n    if (dictionary.ignoreCase) {\n      charUtils.toLowerCase(word, 0, length);\n    }\n    List<CharsRef> stems = new ArrayList<CharsRef>();\n    IntsRef forms = dictionary.lookupWord(word, 0, length);\n    if (forms != null) {\n      // TODO: some forms should not be added, e.g. ONLYINCOMPOUND\n      // just because it exists, does not make it valid...\n      for (int i = 0; i < forms.length; i++) {\n        stems.add(new CharsRef(word, 0, length));\n      }\n    }\n    stems.addAll(stem(word, length, -1, -1, -1, 0, true, true, false, false));\n    return stems;\n  }\n\n","sourceOld":"  /**\n   * Find the stem(s) of the provided word\n   * \n   * @param word Word to find the stems for\n   * @return List of stems for the word\n   */\n  public List<CharsRef> stem(char word[], int length) {\n    if (dictionary.ignoreCase) {\n      charUtils.toLowerCase(word, 0, length);\n    }\n    List<CharsRef> stems = new ArrayList<CharsRef>();\n    IntsRef forms = dictionary.lookupWord(word, 0, length);\n    if (forms != null) {\n      // TODO: some forms should not be added, e.g. ONLYINCOMPOUND\n      // just because it exists, does not make it valid...\n      for (int i = 0; i < forms.length; i++) {\n        stems.add(new CharsRef(word, 0, length));\n      }\n    }\n    stems.addAll(stem(word, length, -1, -1, -1, 0, true, true, false));\n    return stems;\n  }\n\n","bugFix":null,"bugIntro":["23ccc3a9bdacbdab4dbedf7c926b76298d8bd1db"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5ae9942cbee38a49d234c2f022e3a265133d1914","date":1393952688,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Stemmer#stem(char[],int).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Stemmer#stem(char[],int).mjava","sourceNew":"  /**\n   * Find the stem(s) of the provided word\n   * \n   * @param word Word to find the stems for\n   * @return List of stems for the word\n   */\n  public List<CharsRef> stem(char word[], int length) {    \n\n    if (dictionary.needsInputCleaning) {\n      scratchSegment.setLength(0);\n      scratchSegment.append(word, 0, length);\n      CharSequence cleaned = dictionary.cleanInput(scratchSegment, segment);\n      scratchBuffer = ArrayUtil.grow(scratchBuffer, cleaned.length());\n      length = segment.length();\n      segment.getChars(0, length, scratchBuffer, 0);\n      word = scratchBuffer;\n    }\n    \n    List<CharsRef> stems = new ArrayList<CharsRef>();\n    IntsRef forms = dictionary.lookupWord(word, 0, length);\n    if (forms != null) {\n      // TODO: some forms should not be added, e.g. ONLYINCOMPOUND\n      // just because it exists, does not make it valid...\n      for (int i = 0; i < forms.length; i++) {\n        stems.add(newStem(word, length));\n      }\n    }\n    stems.addAll(stem(word, length, -1, -1, -1, 0, true, true, false, false));\n    return stems;\n  }\n\n","sourceOld":"  /**\n   * Find the stem(s) of the provided word\n   * \n   * @param word Word to find the stems for\n   * @return List of stems for the word\n   */\n  public List<CharsRef> stem(char word[], int length) {\n    if (dictionary.ignoreCase) {\n      charUtils.toLowerCase(word, 0, length);\n    }\n    List<CharsRef> stems = new ArrayList<CharsRef>();\n    IntsRef forms = dictionary.lookupWord(word, 0, length);\n    if (forms != null) {\n      // TODO: some forms should not be added, e.g. ONLYINCOMPOUND\n      // just because it exists, does not make it valid...\n      for (int i = 0; i < forms.length; i++) {\n        stems.add(new CharsRef(word, 0, length));\n      }\n    }\n    stems.addAll(stem(word, length, -1, -1, -1, 0, true, true, false, false));\n    return stems;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"96ea64d994d340044e0d57aeb6a5871539d10ca5","date":1394225445,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Stemmer#stem(char[],int).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Stemmer#stem(char[],int).mjava","sourceNew":"  /**\n   * Find the stem(s) of the provided word\n   * \n   * @param word Word to find the stems for\n   * @return List of stems for the word\n   */\n  public List<CharsRef> stem(char word[], int length) {    \n\n    if (dictionary.needsInputCleaning) {\n      scratchSegment.setLength(0);\n      scratchSegment.append(word, 0, length);\n      CharSequence cleaned = dictionary.cleanInput(scratchSegment, segment);\n      scratchBuffer = ArrayUtil.grow(scratchBuffer, cleaned.length());\n      length = segment.length();\n      segment.getChars(0, length, scratchBuffer, 0);\n      word = scratchBuffer;\n    }\n    \n    List<CharsRef> stems = new ArrayList<CharsRef>();\n    IntsRef forms = dictionary.lookupWord(word, 0, length);\n    if (forms != null) {\n      // TODO: some forms should not be added, e.g. ONLYINCOMPOUND\n      // just because it exists, does not make it valid...\n      for (int i = 0; i < forms.length; i++) {\n        stems.add(newStem(word, length));\n      }\n    }\n    stems.addAll(stem(word, length, -1, -1, -1, 0, true, true, false, false));\n    return stems;\n  }\n\n","sourceOld":"  /**\n   * Find the stem(s) of the provided word\n   * \n   * @param word Word to find the stems for\n   * @return List of stems for the word\n   */\n  public List<CharsRef> stem(char word[], int length) {\n    if (dictionary.ignoreCase) {\n      charUtils.toLowerCase(word, 0, length);\n    }\n    List<CharsRef> stems = new ArrayList<CharsRef>();\n    IntsRef forms = dictionary.lookupWord(word, 0, length);\n    if (forms != null) {\n      // TODO: some forms should not be added, e.g. ONLYINCOMPOUND\n      // just because it exists, does not make it valid...\n      for (int i = 0; i < forms.length; i++) {\n        stems.add(new CharsRef(word, 0, length));\n      }\n    }\n    stems.addAll(stem(word, length, -1, -1, -1, 0, true, true, false, false));\n    return stems;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Stemmer#stem(char[],int).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Stemmer#stem(char[],int).mjava","sourceNew":"  /**\n   * Find the stem(s) of the provided word\n   * \n   * @param word Word to find the stems for\n   * @return List of stems for the word\n   */\n  public List<CharsRef> stem(char word[], int length) {    \n\n    if (dictionary.needsInputCleaning) {\n      scratchSegment.setLength(0);\n      scratchSegment.append(word, 0, length);\n      CharSequence cleaned = dictionary.cleanInput(scratchSegment, segment);\n      scratchBuffer = ArrayUtil.grow(scratchBuffer, cleaned.length());\n      length = segment.length();\n      segment.getChars(0, length, scratchBuffer, 0);\n      word = scratchBuffer;\n    }\n    \n    List<CharsRef> stems = new ArrayList<>();\n    IntsRef forms = dictionary.lookupWord(word, 0, length);\n    if (forms != null) {\n      // TODO: some forms should not be added, e.g. ONLYINCOMPOUND\n      // just because it exists, does not make it valid...\n      for (int i = 0; i < forms.length; i++) {\n        stems.add(newStem(word, length));\n      }\n    }\n    stems.addAll(stem(word, length, -1, -1, -1, 0, true, true, false, false));\n    return stems;\n  }\n\n","sourceOld":"  /**\n   * Find the stem(s) of the provided word\n   * \n   * @param word Word to find the stems for\n   * @return List of stems for the word\n   */\n  public List<CharsRef> stem(char word[], int length) {    \n\n    if (dictionary.needsInputCleaning) {\n      scratchSegment.setLength(0);\n      scratchSegment.append(word, 0, length);\n      CharSequence cleaned = dictionary.cleanInput(scratchSegment, segment);\n      scratchBuffer = ArrayUtil.grow(scratchBuffer, cleaned.length());\n      length = segment.length();\n      segment.getChars(0, length, scratchBuffer, 0);\n      word = scratchBuffer;\n    }\n    \n    List<CharsRef> stems = new ArrayList<CharsRef>();\n    IntsRef forms = dictionary.lookupWord(word, 0, length);\n    if (forms != null) {\n      // TODO: some forms should not be added, e.g. ONLYINCOMPOUND\n      // just because it exists, does not make it valid...\n      for (int i = 0; i < forms.length; i++) {\n        stems.add(newStem(word, length));\n      }\n    }\n    stems.addAll(stem(word, length, -1, -1, -1, 0, true, true, false, false));\n    return stems;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"23ccc3a9bdacbdab4dbedf7c926b76298d8bd1db","date":1397463062,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Stemmer#stem(char[],int).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Stemmer#stem(char[],int).mjava","sourceNew":"  /**\n   * Find the stem(s) of the provided word\n   * \n   * @param word Word to find the stems for\n   * @return List of stems for the word\n   */\n  public List<CharsRef> stem(char word[], int length) {    \n\n    if (dictionary.needsInputCleaning) {\n      scratchSegment.setLength(0);\n      scratchSegment.append(word, 0, length);\n      CharSequence cleaned = dictionary.cleanInput(scratchSegment, segment);\n      scratchBuffer = ArrayUtil.grow(scratchBuffer, cleaned.length());\n      length = segment.length();\n      segment.getChars(0, length, scratchBuffer, 0);\n      word = scratchBuffer;\n    }\n    \n    List<CharsRef> stems = new ArrayList<>();\n    IntsRef forms = dictionary.lookupWord(word, 0, length);\n    if (forms != null) {\n      // TODO: some forms should not be added, e.g. ONLYINCOMPOUND\n      // just because it exists, does not make it valid...\n      for (int i = 0; i < forms.length; i++) {\n        stems.add(newStem(word, length));\n      }\n    }\n    try {\n      stems.addAll(stem(word, length, -1, -1, -1, 0, true, true, false, false));\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n    return stems;\n  }\n\n","sourceOld":"  /**\n   * Find the stem(s) of the provided word\n   * \n   * @param word Word to find the stems for\n   * @return List of stems for the word\n   */\n  public List<CharsRef> stem(char word[], int length) {    \n\n    if (dictionary.needsInputCleaning) {\n      scratchSegment.setLength(0);\n      scratchSegment.append(word, 0, length);\n      CharSequence cleaned = dictionary.cleanInput(scratchSegment, segment);\n      scratchBuffer = ArrayUtil.grow(scratchBuffer, cleaned.length());\n      length = segment.length();\n      segment.getChars(0, length, scratchBuffer, 0);\n      word = scratchBuffer;\n    }\n    \n    List<CharsRef> stems = new ArrayList<>();\n    IntsRef forms = dictionary.lookupWord(word, 0, length);\n    if (forms != null) {\n      // TODO: some forms should not be added, e.g. ONLYINCOMPOUND\n      // just because it exists, does not make it valid...\n      for (int i = 0; i < forms.length; i++) {\n        stems.add(newStem(word, length));\n      }\n    }\n    stems.addAll(stem(word, length, -1, -1, -1, 0, true, true, false, false));\n    return stems;\n  }\n\n","bugFix":["38e7d0aeceab994177a0a6b52f475611b52f09bf"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5916de6e2f6deb9da923b2710f6451668e94a20c","date":1403356557,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Stemmer#stem(char[],int).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Stemmer#stem(char[],int).mjava","sourceNew":"  /**\n   * Find the stem(s) of the provided word\n   * \n   * @param word Word to find the stems for\n   * @return List of stems for the word\n   */\n  public List<CharsRef> stem(char word[], int length) {    \n\n    if (dictionary.needsInputCleaning) {\n      scratchSegment.setLength(0);\n      scratchSegment.append(word, 0, length);\n      CharSequence cleaned = dictionary.cleanInput(scratchSegment, segment);\n      scratchBuffer = ArrayUtil.grow(scratchBuffer, cleaned.length());\n      length = segment.length();\n      segment.getChars(0, length, scratchBuffer, 0);\n      word = scratchBuffer;\n    }\n    \n    List<CharsRef> stems = new ArrayList<>();\n    IntsRef forms = dictionary.lookupWord(word, 0, length);\n    if (forms != null) {\n      // TODO: some forms should not be added, e.g. ONLYINCOMPOUND\n      // just because it exists, does not make it valid...\n      for (int i = 0; i < forms.length; i += formStep) {\n        stems.add(newStem(word, length, forms, i));\n      }\n    }\n    try {\n      boolean v = stems.addAll(stem(word, length, -1, -1, -1, 0, true, true, false, false));\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n    return stems;\n  }\n\n","sourceOld":"  /**\n   * Find the stem(s) of the provided word\n   * \n   * @param word Word to find the stems for\n   * @return List of stems for the word\n   */\n  public List<CharsRef> stem(char word[], int length) {    \n\n    if (dictionary.needsInputCleaning) {\n      scratchSegment.setLength(0);\n      scratchSegment.append(word, 0, length);\n      CharSequence cleaned = dictionary.cleanInput(scratchSegment, segment);\n      scratchBuffer = ArrayUtil.grow(scratchBuffer, cleaned.length());\n      length = segment.length();\n      segment.getChars(0, length, scratchBuffer, 0);\n      word = scratchBuffer;\n    }\n    \n    List<CharsRef> stems = new ArrayList<>();\n    IntsRef forms = dictionary.lookupWord(word, 0, length);\n    if (forms != null) {\n      // TODO: some forms should not be added, e.g. ONLYINCOMPOUND\n      // just because it exists, does not make it valid...\n      for (int i = 0; i < forms.length; i++) {\n        stems.add(newStem(word, length));\n      }\n    }\n    try {\n      stems.addAll(stem(word, length, -1, -1, -1, 0, true, true, false, false));\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n    return stems;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"422da43e6414338103dfc37b7c8c68dcbe309d87","date":1405540909,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Stemmer#stem(char[],int).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Stemmer#stem(char[],int).mjava","sourceNew":"  /**\n   * Find the stem(s) of the provided word\n   * \n   * @param word Word to find the stems for\n   * @return List of stems for the word\n   */\n  public List<CharsRef> stem(char word[], int length) {    \n\n    if (dictionary.needsInputCleaning) {\n      scratchSegment.setLength(0);\n      scratchSegment.append(word, 0, length);\n      CharSequence cleaned = dictionary.cleanInput(scratchSegment, segment);\n      scratchBuffer = ArrayUtil.grow(scratchBuffer, cleaned.length());\n      length = segment.length();\n      segment.getChars(0, length, scratchBuffer, 0);\n      word = scratchBuffer;\n    }\n    \n    int caseType = caseOf(word, length);\n    if (caseType == UPPER_CASE) {\n      // upper: union exact, title, lower\n      caseFoldTitle(word, length);\n      caseFoldLower(titleBuffer, length);\n      List<CharsRef> list = doStem(word, length, false);\n      list.addAll(doStem(titleBuffer, length, true));\n      list.addAll(doStem(lowerBuffer, length, true));\n      return list;\n    } else if (caseType == TITLE_CASE) {\n      // title: union exact, lower\n      caseFoldLower(word, length);\n      List<CharsRef> list = doStem(word, length, false);\n      list.addAll(doStem(lowerBuffer, length, true));\n      return list;\n    } else {\n      // exact match only\n      return doStem(word, length, false);\n    }\n  }\n\n","sourceOld":"  /**\n   * Find the stem(s) of the provided word\n   * \n   * @param word Word to find the stems for\n   * @return List of stems for the word\n   */\n  public List<CharsRef> stem(char word[], int length) {    \n\n    if (dictionary.needsInputCleaning) {\n      scratchSegment.setLength(0);\n      scratchSegment.append(word, 0, length);\n      CharSequence cleaned = dictionary.cleanInput(scratchSegment, segment);\n      scratchBuffer = ArrayUtil.grow(scratchBuffer, cleaned.length());\n      length = segment.length();\n      segment.getChars(0, length, scratchBuffer, 0);\n      word = scratchBuffer;\n    }\n    \n    List<CharsRef> stems = new ArrayList<>();\n    IntsRef forms = dictionary.lookupWord(word, 0, length);\n    if (forms != null) {\n      // TODO: some forms should not be added, e.g. ONLYINCOMPOUND\n      // just because it exists, does not make it valid...\n      for (int i = 0; i < forms.length; i += formStep) {\n        stems.add(newStem(word, length, forms, i));\n      }\n    }\n    try {\n      boolean v = stems.addAll(stem(word, length, -1, -1, -1, 0, true, true, false, false));\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n    return stems;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["5ae9942cbee38a49d234c2f022e3a265133d1914"],"96ea64d994d340044e0d57aeb6a5871539d10ca5":["38e7d0aeceab994177a0a6b52f475611b52f09bf","5ae9942cbee38a49d234c2f022e3a265133d1914"],"b58bd8dd457a9b46b007c641d5b6e747afb8904a":["ba791bce8103c79e38f957e9c5a53a75871bd918"],"38e7d0aeceab994177a0a6b52f475611b52f09bf":["1bc1343e76d5f1ad7d6a35dd8c55fb52f9b4e3a7"],"1bc1343e76d5f1ad7d6a35dd8c55fb52f9b4e3a7":["b58bd8dd457a9b46b007c641d5b6e747afb8904a"],"5916de6e2f6deb9da923b2710f6451668e94a20c":["23ccc3a9bdacbdab4dbedf7c926b76298d8bd1db"],"ba791bce8103c79e38f957e9c5a53a75871bd918":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","dc3f094cafa4a87b4066e1d6710fa4e6afe6260e"],"dc3f094cafa4a87b4066e1d6710fa4e6afe6260e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5ae9942cbee38a49d234c2f022e3a265133d1914":["38e7d0aeceab994177a0a6b52f475611b52f09bf"],"23ccc3a9bdacbdab4dbedf7c926b76298d8bd1db":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"422da43e6414338103dfc37b7c8c68dcbe309d87":["5916de6e2f6deb9da923b2710f6451668e94a20c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["422da43e6414338103dfc37b7c8c68dcbe309d87"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["23ccc3a9bdacbdab4dbedf7c926b76298d8bd1db"],"96ea64d994d340044e0d57aeb6a5871539d10ca5":[],"b58bd8dd457a9b46b007c641d5b6e747afb8904a":["1bc1343e76d5f1ad7d6a35dd8c55fb52f9b4e3a7"],"38e7d0aeceab994177a0a6b52f475611b52f09bf":["96ea64d994d340044e0d57aeb6a5871539d10ca5","5ae9942cbee38a49d234c2f022e3a265133d1914"],"1bc1343e76d5f1ad7d6a35dd8c55fb52f9b4e3a7":["38e7d0aeceab994177a0a6b52f475611b52f09bf"],"5916de6e2f6deb9da923b2710f6451668e94a20c":["422da43e6414338103dfc37b7c8c68dcbe309d87"],"ba791bce8103c79e38f957e9c5a53a75871bd918":["b58bd8dd457a9b46b007c641d5b6e747afb8904a"],"dc3f094cafa4a87b4066e1d6710fa4e6afe6260e":["ba791bce8103c79e38f957e9c5a53a75871bd918"],"5ae9942cbee38a49d234c2f022e3a265133d1914":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","96ea64d994d340044e0d57aeb6a5871539d10ca5"],"23ccc3a9bdacbdab4dbedf7c926b76298d8bd1db":["5916de6e2f6deb9da923b2710f6451668e94a20c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ba791bce8103c79e38f957e9c5a53a75871bd918","dc3f094cafa4a87b4066e1d6710fa4e6afe6260e"],"422da43e6414338103dfc37b7c8c68dcbe309d87":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["96ea64d994d340044e0d57aeb6a5871539d10ca5","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}