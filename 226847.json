{"path":"solr/core/src/java/org/apache/solr/update/UpdateLog#seedBucketsWithHighestVersion(SolrIndexSearcher,VersionInfo).mjava","commits":[{"id":"773a737806859660d4756f710adc0ad53e05f9d5","date":1432140757,"type":0,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#seedBucketsWithHighestVersion(SolrIndexSearcher,VersionInfo).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Used to seed all version buckets with the max value of the version field in the index.\n   */\n  protected Long seedBucketsWithHighestVersion(SolrIndexSearcher newSearcher, VersionInfo versions) {\n    Long highestVersion = null;\n    long startMs = System.currentTimeMillis();\n\n    RecentUpdates recentUpdates = null;\n    try {\n      recentUpdates = getRecentUpdates();\n      long maxVersionFromRecent = recentUpdates.getMaxRecentVersion();\n      long maxVersionFromIndex = versions.getMaxVersionFromIndex(newSearcher);\n\n      long maxVersion = Math.max(maxVersionFromIndex, maxVersionFromRecent);\n      if (maxVersion == 0L) {\n        maxVersion = versions.getNewClock();\n        log.warn(\"Could not find max version in index or recent updates, using new clock {}\", maxVersion);\n      }\n\n      // seed all version buckets with the highest value from recent and index\n      versions.seedBucketsWithHighestVersion(maxVersion);\n\n      highestVersion = maxVersion;\n    } catch (IOException ioExc) {\n      log.warn(\"Failed to determine the max value of the version field due to: \"+ioExc, ioExc);\n    } finally {\n      if (recentUpdates != null)\n        recentUpdates.close();\n    }\n\n    long tookMs = (System.currentTimeMillis() - startMs);\n    log.info(\"Took {} ms to seed version buckets with highest version {}\",\n        tookMs, String.valueOf(highestVersion));\n\n    return highestVersion;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9220b7d1848f68bc299608612f8e0139c4036fcf","date":1432485783,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#seedBucketsWithHighestVersion(SolrIndexSearcher,VersionInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#seedBucketsWithHighestVersion(SolrIndexSearcher,VersionInfo).mjava","sourceNew":"  /**\n   * Used to seed all version buckets with the max value of the version field in the index.\n   */\n  protected Long seedBucketsWithHighestVersion(SolrIndexSearcher newSearcher, VersionInfo versions) {\n    Long highestVersion = null;\n    long startMs = System.currentTimeMillis();\n\n    RecentUpdates recentUpdates = null;\n    try {\n      recentUpdates = getRecentUpdates();\n      long maxVersionFromRecent = recentUpdates.getMaxRecentVersion();\n      long maxVersionFromIndex = versions.getMaxVersionFromIndex(newSearcher);\n\n      long maxVersion = Math.max(maxVersionFromIndex, maxVersionFromRecent);\n      if (maxVersion == 0L) {\n        maxVersion = versions.getNewClock();\n        log.info(\"Could not find max version in index or recent updates, using new clock {}\", maxVersion);\n      }\n\n      // seed all version buckets with the highest value from recent and index\n      versions.seedBucketsWithHighestVersion(maxVersion);\n\n      highestVersion = maxVersion;\n    } catch (IOException ioExc) {\n      log.warn(\"Failed to determine the max value of the version field due to: \"+ioExc, ioExc);\n    } finally {\n      if (recentUpdates != null)\n        recentUpdates.close();\n    }\n\n    long tookMs = (System.currentTimeMillis() - startMs);\n    log.info(\"Took {} ms to seed version buckets with highest version {}\",\n        tookMs, String.valueOf(highestVersion));\n\n    return highestVersion;\n  }\n\n","sourceOld":"  /**\n   * Used to seed all version buckets with the max value of the version field in the index.\n   */\n  protected Long seedBucketsWithHighestVersion(SolrIndexSearcher newSearcher, VersionInfo versions) {\n    Long highestVersion = null;\n    long startMs = System.currentTimeMillis();\n\n    RecentUpdates recentUpdates = null;\n    try {\n      recentUpdates = getRecentUpdates();\n      long maxVersionFromRecent = recentUpdates.getMaxRecentVersion();\n      long maxVersionFromIndex = versions.getMaxVersionFromIndex(newSearcher);\n\n      long maxVersion = Math.max(maxVersionFromIndex, maxVersionFromRecent);\n      if (maxVersion == 0L) {\n        maxVersion = versions.getNewClock();\n        log.warn(\"Could not find max version in index or recent updates, using new clock {}\", maxVersion);\n      }\n\n      // seed all version buckets with the highest value from recent and index\n      versions.seedBucketsWithHighestVersion(maxVersion);\n\n      highestVersion = maxVersion;\n    } catch (IOException ioExc) {\n      log.warn(\"Failed to determine the max value of the version field due to: \"+ioExc, ioExc);\n    } finally {\n      if (recentUpdates != null)\n        recentUpdates.close();\n    }\n\n    long tookMs = (System.currentTimeMillis() - startMs);\n    log.info(\"Took {} ms to seed version buckets with highest version {}\",\n        tookMs, String.valueOf(highestVersion));\n\n    return highestVersion;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bcf9886c8ff537aafde14de48ebf744f5673f08b","date":1439041198,"type":3,"author":"Ramkumar Aiyengar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#seedBucketsWithHighestVersion(SolrIndexSearcher,VersionInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#seedBucketsWithHighestVersion(SolrIndexSearcher,VersionInfo).mjava","sourceNew":"  /**\n   * Used to seed all version buckets with the max value of the version field in the index.\n   */\n  protected Long seedBucketsWithHighestVersion(SolrIndexSearcher newSearcher, VersionInfo versions) {\n    Long highestVersion = null;\n    final RTimer timer = new RTimer();\n\n    RecentUpdates recentUpdates = null;\n    try {\n      recentUpdates = getRecentUpdates();\n      long maxVersionFromRecent = recentUpdates.getMaxRecentVersion();\n      long maxVersionFromIndex = versions.getMaxVersionFromIndex(newSearcher);\n\n      long maxVersion = Math.max(maxVersionFromIndex, maxVersionFromRecent);\n      if (maxVersion == 0L) {\n        maxVersion = versions.getNewClock();\n        log.info(\"Could not find max version in index or recent updates, using new clock {}\", maxVersion);\n      }\n\n      // seed all version buckets with the highest value from recent and index\n      versions.seedBucketsWithHighestVersion(maxVersion);\n\n      highestVersion = maxVersion;\n    } catch (IOException ioExc) {\n      log.warn(\"Failed to determine the max value of the version field due to: \"+ioExc, ioExc);\n    } finally {\n      if (recentUpdates != null)\n        recentUpdates.close();\n    }\n\n    log.info(\"Took {}ms to seed version buckets with highest version {}\",\n        timer.getTime(), String.valueOf(highestVersion));\n\n    return highestVersion;\n  }\n\n","sourceOld":"  /**\n   * Used to seed all version buckets with the max value of the version field in the index.\n   */\n  protected Long seedBucketsWithHighestVersion(SolrIndexSearcher newSearcher, VersionInfo versions) {\n    Long highestVersion = null;\n    long startMs = System.currentTimeMillis();\n\n    RecentUpdates recentUpdates = null;\n    try {\n      recentUpdates = getRecentUpdates();\n      long maxVersionFromRecent = recentUpdates.getMaxRecentVersion();\n      long maxVersionFromIndex = versions.getMaxVersionFromIndex(newSearcher);\n\n      long maxVersion = Math.max(maxVersionFromIndex, maxVersionFromRecent);\n      if (maxVersion == 0L) {\n        maxVersion = versions.getNewClock();\n        log.info(\"Could not find max version in index or recent updates, using new clock {}\", maxVersion);\n      }\n\n      // seed all version buckets with the highest value from recent and index\n      versions.seedBucketsWithHighestVersion(maxVersion);\n\n      highestVersion = maxVersion;\n    } catch (IOException ioExc) {\n      log.warn(\"Failed to determine the max value of the version field due to: \"+ioExc, ioExc);\n    } finally {\n      if (recentUpdates != null)\n        recentUpdates.close();\n    }\n\n    long tookMs = (System.currentTimeMillis() - startMs);\n    log.info(\"Took {} ms to seed version buckets with highest version {}\",\n        tookMs, String.valueOf(highestVersion));\n\n    return highestVersion;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a9186bf60d7c6f504d4d5b01cfee95dc4bd15e53","date":1449051812,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#seedBucketsWithHighestVersion(SolrIndexSearcher,VersionInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#seedBucketsWithHighestVersion(SolrIndexSearcher,VersionInfo).mjava","sourceNew":"  /**\n   * Used to seed all version buckets with the max value of the version field in the index.\n   */\n  protected Long seedBucketsWithHighestVersion(SolrIndexSearcher newSearcher, VersionInfo versions) {\n    Long highestVersion = null;\n    final RTimer timer = new RTimer();\n\n    try (RecentUpdates recentUpdates = getRecentUpdates()) {\n      long maxVersionFromRecent = recentUpdates.getMaxRecentVersion();\n      long maxVersionFromIndex = versions.getMaxVersionFromIndex(newSearcher);\n\n      long maxVersion = Math.max(maxVersionFromIndex, maxVersionFromRecent);\n      if (maxVersion == 0L) {\n        maxVersion = versions.getNewClock();\n        log.info(\"Could not find max version in index or recent updates, using new clock {}\", maxVersion);\n      }\n\n      // seed all version buckets with the highest value from recent and index\n      versions.seedBucketsWithHighestVersion(maxVersion);\n\n      highestVersion = maxVersion;\n    } catch (IOException ioExc) {\n      log.warn(\"Failed to determine the max value of the version field due to: \"+ioExc, ioExc);\n    }\n\n    log.info(\"Took {}ms to seed version buckets with highest version {}\",\n        timer.getTime(), String.valueOf(highestVersion));\n\n    return highestVersion;\n  }\n\n","sourceOld":"  /**\n   * Used to seed all version buckets with the max value of the version field in the index.\n   */\n  protected Long seedBucketsWithHighestVersion(SolrIndexSearcher newSearcher, VersionInfo versions) {\n    Long highestVersion = null;\n    final RTimer timer = new RTimer();\n\n    RecentUpdates recentUpdates = null;\n    try {\n      recentUpdates = getRecentUpdates();\n      long maxVersionFromRecent = recentUpdates.getMaxRecentVersion();\n      long maxVersionFromIndex = versions.getMaxVersionFromIndex(newSearcher);\n\n      long maxVersion = Math.max(maxVersionFromIndex, maxVersionFromRecent);\n      if (maxVersion == 0L) {\n        maxVersion = versions.getNewClock();\n        log.info(\"Could not find max version in index or recent updates, using new clock {}\", maxVersion);\n      }\n\n      // seed all version buckets with the highest value from recent and index\n      versions.seedBucketsWithHighestVersion(maxVersion);\n\n      highestVersion = maxVersion;\n    } catch (IOException ioExc) {\n      log.warn(\"Failed to determine the max value of the version field due to: \"+ioExc, ioExc);\n    } finally {\n      if (recentUpdates != null)\n        recentUpdates.close();\n    }\n\n    log.info(\"Took {}ms to seed version buckets with highest version {}\",\n        timer.getTime(), String.valueOf(highestVersion));\n\n    return highestVersion;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d62172dd2fc1195c7e475550ac394a9948a18ae","date":1474974102,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#seedBucketsWithHighestVersion(SolrIndexSearcher,VersionInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#seedBucketsWithHighestVersion(SolrIndexSearcher,VersionInfo).mjava","sourceNew":"  /**\n   * Used to seed all version buckets with the max value of the version field in the index.\n   */\n  protected Long seedBucketsWithHighestVersion(SolrIndexSearcher newSearcher, VersionInfo versions) {\n    Long highestVersion = null;\n    final RTimer timer = new RTimer();\n\n    try (RecentUpdates recentUpdates = getRecentUpdates()) {\n      long maxVersionFromRecent = recentUpdates.getMaxRecentVersion();\n      long maxVersionFromIndex = versions.getMaxVersionFromIndex(newSearcher);\n\n      long maxVersion = Math.max(maxVersionFromIndex, maxVersionFromRecent);\n      if (maxVersion == 0L) {\n        maxVersion = versions.getNewClock();\n        log.info(\"Could not find max version in index or recent updates, using new clock {}\", maxVersion);\n      }\n\n      // seed all version buckets with the highest value from recent and index\n      versions.seedBucketsWithHighestVersion(maxVersion);\n\n      highestVersion = maxVersion;\n    } catch (IOException ioExc) {\n      log.warn(\"Failed to determine the max value of the version field due to: \"+ioExc, ioExc);\n    }\n\n    log.debug(\"Took {}ms to seed version buckets with highest version {}\",\n        timer.getTime(), String.valueOf(highestVersion));\n\n    return highestVersion;\n  }\n\n","sourceOld":"  /**\n   * Used to seed all version buckets with the max value of the version field in the index.\n   */\n  protected Long seedBucketsWithHighestVersion(SolrIndexSearcher newSearcher, VersionInfo versions) {\n    Long highestVersion = null;\n    final RTimer timer = new RTimer();\n\n    try (RecentUpdates recentUpdates = getRecentUpdates()) {\n      long maxVersionFromRecent = recentUpdates.getMaxRecentVersion();\n      long maxVersionFromIndex = versions.getMaxVersionFromIndex(newSearcher);\n\n      long maxVersion = Math.max(maxVersionFromIndex, maxVersionFromRecent);\n      if (maxVersion == 0L) {\n        maxVersion = versions.getNewClock();\n        log.info(\"Could not find max version in index or recent updates, using new clock {}\", maxVersion);\n      }\n\n      // seed all version buckets with the highest value from recent and index\n      versions.seedBucketsWithHighestVersion(maxVersion);\n\n      highestVersion = maxVersion;\n    } catch (IOException ioExc) {\n      log.warn(\"Failed to determine the max value of the version field due to: \"+ioExc, ioExc);\n    }\n\n    log.info(\"Took {}ms to seed version buckets with highest version {}\",\n        timer.getTime(), String.valueOf(highestVersion));\n\n    return highestVersion;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#seedBucketsWithHighestVersion(SolrIndexSearcher,VersionInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#seedBucketsWithHighestVersion(SolrIndexSearcher,VersionInfo).mjava","sourceNew":"  /**\n   * Used to seed all version buckets with the max value of the version field in the index.\n   */\n  protected Long seedBucketsWithHighestVersion(SolrIndexSearcher newSearcher, VersionInfo versions) {\n    Long highestVersion = null;\n    final RTimer timer = new RTimer();\n\n    try (RecentUpdates recentUpdates = getRecentUpdates()) {\n      long maxVersionFromRecent = recentUpdates.getMaxRecentVersion();\n      long maxVersionFromIndex = versions.getMaxVersionFromIndex(newSearcher);\n\n      long maxVersion = Math.max(maxVersionFromIndex, maxVersionFromRecent);\n      if (maxVersion == 0L) {\n        maxVersion = versions.getNewClock();\n        log.info(\"Could not find max version in index or recent updates, using new clock {}\", maxVersion);\n      }\n\n      // seed all version buckets with the highest value from recent and index\n      versions.seedBucketsWithHighestVersion(maxVersion);\n\n      highestVersion = maxVersion;\n    } catch (IOException ioExc) {\n      log.warn(\"Failed to determine the max value of the version field due to: \"+ioExc, ioExc);\n    }\n\n    log.debug(\"Took {}ms to seed version buckets with highest version {}\",\n        timer.getTime(), String.valueOf(highestVersion));\n\n    return highestVersion;\n  }\n\n","sourceOld":"  /**\n   * Used to seed all version buckets with the max value of the version field in the index.\n   */\n  protected Long seedBucketsWithHighestVersion(SolrIndexSearcher newSearcher, VersionInfo versions) {\n    Long highestVersion = null;\n    final RTimer timer = new RTimer();\n\n    try (RecentUpdates recentUpdates = getRecentUpdates()) {\n      long maxVersionFromRecent = recentUpdates.getMaxRecentVersion();\n      long maxVersionFromIndex = versions.getMaxVersionFromIndex(newSearcher);\n\n      long maxVersion = Math.max(maxVersionFromIndex, maxVersionFromRecent);\n      if (maxVersion == 0L) {\n        maxVersion = versions.getNewClock();\n        log.info(\"Could not find max version in index or recent updates, using new clock {}\", maxVersion);\n      }\n\n      // seed all version buckets with the highest value from recent and index\n      versions.seedBucketsWithHighestVersion(maxVersion);\n\n      highestVersion = maxVersion;\n    } catch (IOException ioExc) {\n      log.warn(\"Failed to determine the max value of the version field due to: \"+ioExc, ioExc);\n    }\n\n    log.info(\"Took {}ms to seed version buckets with highest version {}\",\n        timer.getTime(), String.valueOf(highestVersion));\n\n    return highestVersion;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#seedBucketsWithHighestVersion(SolrIndexSearcher,VersionInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#seedBucketsWithHighestVersion(SolrIndexSearcher,VersionInfo).mjava","sourceNew":"  /**\n   * Used to seed all version buckets with the max value of the version field in the index.\n   */\n  protected Long seedBucketsWithHighestVersion(SolrIndexSearcher newSearcher, VersionInfo versions) {\n    Long highestVersion = null;\n    final RTimer timer = new RTimer();\n\n    try (RecentUpdates recentUpdates = getRecentUpdates()) {\n      long maxVersionFromRecent = recentUpdates.getMaxRecentVersion();\n      long maxVersionFromIndex = versions.getMaxVersionFromIndex(newSearcher);\n\n      long maxVersion = Math.max(maxVersionFromIndex, maxVersionFromRecent);\n      if (maxVersion == 0L) {\n        maxVersion = versions.getNewClock();\n        log.info(\"Could not find max version in index or recent updates, using new clock {}\", maxVersion);\n      }\n\n      // seed all version buckets with the highest value from recent and index\n      versions.seedBucketsWithHighestVersion(maxVersion);\n\n      highestVersion = maxVersion;\n    } catch (IOException ioExc) {\n      log.warn(\"Failed to determine the max value of the version field due to: \"+ioExc, ioExc);\n    }\n\n    log.debug(\"Took {}ms to seed version buckets with highest version {}\",\n        timer.getTime(), String.valueOf(highestVersion));\n\n    return highestVersion;\n  }\n\n","sourceOld":"  /**\n   * Used to seed all version buckets with the max value of the version field in the index.\n   */\n  protected Long seedBucketsWithHighestVersion(SolrIndexSearcher newSearcher, VersionInfo versions) {\n    Long highestVersion = null;\n    final RTimer timer = new RTimer();\n\n    try (RecentUpdates recentUpdates = getRecentUpdates()) {\n      long maxVersionFromRecent = recentUpdates.getMaxRecentVersion();\n      long maxVersionFromIndex = versions.getMaxVersionFromIndex(newSearcher);\n\n      long maxVersion = Math.max(maxVersionFromIndex, maxVersionFromRecent);\n      if (maxVersion == 0L) {\n        maxVersion = versions.getNewClock();\n        log.info(\"Could not find max version in index or recent updates, using new clock {}\", maxVersion);\n      }\n\n      // seed all version buckets with the highest value from recent and index\n      versions.seedBucketsWithHighestVersion(maxVersion);\n\n      highestVersion = maxVersion;\n    } catch (IOException ioExc) {\n      log.warn(\"Failed to determine the max value of the version field due to: \"+ioExc, ioExc);\n    }\n\n    log.info(\"Took {}ms to seed version buckets with highest version {}\",\n        timer.getTime(), String.valueOf(highestVersion));\n\n    return highestVersion;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"740d649f013f07efbeb73ca854f106c60166e7c0","date":1587431295,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#seedBucketsWithHighestVersion(SolrIndexSearcher,VersionInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#seedBucketsWithHighestVersion(SolrIndexSearcher,VersionInfo).mjava","sourceNew":"  /**\n   * Used to seed all version buckets with the max value of the version field in the index.\n   */\n  protected Long seedBucketsWithHighestVersion(SolrIndexSearcher newSearcher, VersionInfo versions) {\n    Long highestVersion = null;\n    final RTimer timer = new RTimer();\n\n    try (RecentUpdates recentUpdates = getRecentUpdates()) {\n      long maxVersionFromRecent = recentUpdates.getMaxRecentVersion();\n      long maxVersionFromIndex = versions.getMaxVersionFromIndex(newSearcher);\n\n      long maxVersion = Math.max(maxVersionFromIndex, maxVersionFromRecent);\n      if (maxVersion == 0L) {\n        maxVersion = versions.getNewClock();\n        log.info(\"Could not find max version in index or recent updates, using new clock {}\", maxVersion);\n      }\n\n      // seed all version buckets with the highest value from recent and index\n      versions.seedBucketsWithHighestVersion(maxVersion);\n\n      highestVersion = maxVersion;\n    } catch (IOException ioExc) {\n      log.warn(\"Failed to determine the max value of the version field due to: \", ioExc);\n    }\n\n    if (debug) {\n      log.debug(\"Took {}ms to seed version buckets with highest version {}\",\n          timer.getTime(), highestVersion);\n    }\n\n    return highestVersion;\n  }\n\n","sourceOld":"  /**\n   * Used to seed all version buckets with the max value of the version field in the index.\n   */\n  protected Long seedBucketsWithHighestVersion(SolrIndexSearcher newSearcher, VersionInfo versions) {\n    Long highestVersion = null;\n    final RTimer timer = new RTimer();\n\n    try (RecentUpdates recentUpdates = getRecentUpdates()) {\n      long maxVersionFromRecent = recentUpdates.getMaxRecentVersion();\n      long maxVersionFromIndex = versions.getMaxVersionFromIndex(newSearcher);\n\n      long maxVersion = Math.max(maxVersionFromIndex, maxVersionFromRecent);\n      if (maxVersion == 0L) {\n        maxVersion = versions.getNewClock();\n        log.info(\"Could not find max version in index or recent updates, using new clock {}\", maxVersion);\n      }\n\n      // seed all version buckets with the highest value from recent and index\n      versions.seedBucketsWithHighestVersion(maxVersion);\n\n      highestVersion = maxVersion;\n    } catch (IOException ioExc) {\n      log.warn(\"Failed to determine the max value of the version field due to: \"+ioExc, ioExc);\n    }\n\n    log.debug(\"Took {}ms to seed version buckets with highest version {}\",\n        timer.getTime(), String.valueOf(highestVersion));\n\n    return highestVersion;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"740d649f013f07efbeb73ca854f106c60166e7c0":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"9220b7d1848f68bc299608612f8e0139c4036fcf":["773a737806859660d4756f710adc0ad53e05f9d5"],"773a737806859660d4756f710adc0ad53e05f9d5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0d62172dd2fc1195c7e475550ac394a9948a18ae":["a9186bf60d7c6f504d4d5b01cfee95dc4bd15e53"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["a9186bf60d7c6f504d4d5b01cfee95dc4bd15e53","0d62172dd2fc1195c7e475550ac394a9948a18ae"],"a9186bf60d7c6f504d4d5b01cfee95dc4bd15e53":["bcf9886c8ff537aafde14de48ebf744f5673f08b"],"bcf9886c8ff537aafde14de48ebf744f5673f08b":["9220b7d1848f68bc299608612f8e0139c4036fcf"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a9186bf60d7c6f504d4d5b01cfee95dc4bd15e53","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["740d649f013f07efbeb73ca854f106c60166e7c0"]},"commit2Childs":{"740d649f013f07efbeb73ca854f106c60166e7c0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9220b7d1848f68bc299608612f8e0139c4036fcf":["bcf9886c8ff537aafde14de48ebf744f5673f08b"],"773a737806859660d4756f710adc0ad53e05f9d5":["9220b7d1848f68bc299608612f8e0139c4036fcf"],"0d62172dd2fc1195c7e475550ac394a9948a18ae":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["740d649f013f07efbeb73ca854f106c60166e7c0","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["773a737806859660d4756f710adc0ad53e05f9d5"],"a9186bf60d7c6f504d4d5b01cfee95dc4bd15e53":["0d62172dd2fc1195c7e475550ac394a9948a18ae","17e5da53e4e5bd659e22add9bba1cfa222e7e30d","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"bcf9886c8ff537aafde14de48ebf744f5673f08b":["a9186bf60d7c6f504d4d5b01cfee95dc4bd15e53"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}