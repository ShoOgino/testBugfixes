{"path":"lucene/src/java/org/apache/lucene/search/ConjunctionScorer#ConjunctionScorer(Similarity,Scorer...).mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/ConjunctionScorer#ConjunctionScorer(Similarity,Scorer...).mjava","pathOld":"src/java/org/apache/lucene/search/ConjunctionScorer#ConjunctionScorer(Similarity,Scorer...).mjava","sourceNew":"  public ConjunctionScorer(Similarity similarity, Scorer... scorers) throws IOException {\n    super(similarity);\n    this.scorers = scorers;\n    coord = similarity.coord(scorers.length, scorers.length);\n    \n    for (int i = 0; i < scorers.length; i++) {\n      if (scorers[i].nextDoc() == NO_MORE_DOCS) {\n        // If even one of the sub-scorers does not have any documents, this\n        // scorer should not attempt to do any more work.\n        lastDoc = NO_MORE_DOCS;\n        return;\n      }\n    }\n\n    // Sort the array the first time...\n    // We don't need to sort the array in any future calls because we know\n    // it will already start off sorted (all scorers on same doc).\n    \n    // note that this comparator is not consistent with equals!\n    Arrays.sort(scorers, new Comparator<Scorer>() {         // sort the array\n      public int compare(Scorer o1, Scorer o2) {\n        return o1.docID() - o2.docID();\n      }\n    });\n\n    // NOTE: doNext() must be called before the re-sorting of the array later on.\n    // The reason is this: assume there are 5 scorers, whose first docs are 1,\n    // 2, 3, 5, 5 respectively. Sorting (above) leaves the array as is. Calling\n    // doNext() here advances all the first scorers to 5 (or a larger doc ID\n    // they all agree on). \n    // However, if we re-sort before doNext() is called, the order will be 5, 3,\n    // 2, 1, 5 and then doNext() will stop immediately, since the first scorer's\n    // docs equals the last one. So the invariant that after calling doNext() \n    // all scorers are on the same doc ID is broken.\n    if (doNext() == NO_MORE_DOCS) {\n      // The scorers did not agree on any document.\n      lastDoc = NO_MORE_DOCS;\n      return;\n    }\n\n    // If first-time skip distance is any predictor of\n    // scorer sparseness, then we should always try to skip first on\n    // those scorers.\n    // Keep last scorer in it's last place (it will be the first\n    // to be skipped on), but reverse all of the others so that\n    // they will be skipped on in order of original high skip.\n    int end = scorers.length - 1;\n    int max = end >> 1;\n    for (int i = 0; i < max; i++) {\n      Scorer tmp = scorers[i];\n      int idx = end - i - 1;\n      scorers[i] = scorers[idx];\n      scorers[idx] = tmp;\n    }\n  }\n\n","sourceOld":"  public ConjunctionScorer(Similarity similarity, Scorer... scorers) throws IOException {\n    super(similarity);\n    this.scorers = scorers;\n    coord = similarity.coord(scorers.length, scorers.length);\n    \n    for (int i = 0; i < scorers.length; i++) {\n      if (scorers[i].nextDoc() == NO_MORE_DOCS) {\n        // If even one of the sub-scorers does not have any documents, this\n        // scorer should not attempt to do any more work.\n        lastDoc = NO_MORE_DOCS;\n        return;\n      }\n    }\n\n    // Sort the array the first time...\n    // We don't need to sort the array in any future calls because we know\n    // it will already start off sorted (all scorers on same doc).\n    \n    // note that this comparator is not consistent with equals!\n    Arrays.sort(scorers, new Comparator<Scorer>() {         // sort the array\n      public int compare(Scorer o1, Scorer o2) {\n        return o1.docID() - o2.docID();\n      }\n    });\n\n    // NOTE: doNext() must be called before the re-sorting of the array later on.\n    // The reason is this: assume there are 5 scorers, whose first docs are 1,\n    // 2, 3, 5, 5 respectively. Sorting (above) leaves the array as is. Calling\n    // doNext() here advances all the first scorers to 5 (or a larger doc ID\n    // they all agree on). \n    // However, if we re-sort before doNext() is called, the order will be 5, 3,\n    // 2, 1, 5 and then doNext() will stop immediately, since the first scorer's\n    // docs equals the last one. So the invariant that after calling doNext() \n    // all scorers are on the same doc ID is broken.\n    if (doNext() == NO_MORE_DOCS) {\n      // The scorers did not agree on any document.\n      lastDoc = NO_MORE_DOCS;\n      return;\n    }\n\n    // If first-time skip distance is any predictor of\n    // scorer sparseness, then we should always try to skip first on\n    // those scorers.\n    // Keep last scorer in it's last place (it will be the first\n    // to be skipped on), but reverse all of the others so that\n    // they will be skipped on in order of original high skip.\n    int end = scorers.length - 1;\n    int max = end >> 1;\n    for (int i = 0; i < max; i++) {\n      Scorer tmp = scorers[i];\n      int idx = end - i - 1;\n      scorers[i] = scorers[idx];\n      scorers[idx] = tmp;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae7aa98ce0c64f3b2b81087d14ff9ae992b4903b","date":1288192616,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/ConjunctionScorer#ConjunctionScorer(Similarity,Scorer...).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/ConjunctionScorer#ConjunctionScorer(Similarity,Scorer...).mjava","sourceNew":"  public ConjunctionScorer(Similarity similarity, Scorer... scorers) throws IOException {\n    super(similarity);\n    this.scorers = scorers;\n    coord = similarity.coord(scorers.length, scorers.length);\n    \n    for (int i = 0; i < scorers.length; i++) {\n      if (scorers[i].nextDoc() == NO_MORE_DOCS) {\n        // If even one of the sub-scorers does not have any documents, this\n        // scorer should not attempt to do any more work.\n        lastDoc = NO_MORE_DOCS;\n        return;\n      }\n    }\n\n    // Sort the array the first time...\n    // We don't need to sort the array in any future calls because we know\n    // it will already start off sorted (all scorers on same doc).\n    \n    // Note that this comparator is not consistent with equals!\n    // Also we use mergeSort here to be stable (so order of Scoreres that\n    // match on first document keeps preserved):\n    ArrayUtil.mergeSort(scorers, new Comparator<Scorer>() { // sort the array\n      public int compare(Scorer o1, Scorer o2) {\n        return o1.docID() - o2.docID();\n      }\n    });\n\n    // NOTE: doNext() must be called before the re-sorting of the array later on.\n    // The reason is this: assume there are 5 scorers, whose first docs are 1,\n    // 2, 3, 5, 5 respectively. Sorting (above) leaves the array as is. Calling\n    // doNext() here advances all the first scorers to 5 (or a larger doc ID\n    // they all agree on). \n    // However, if we re-sort before doNext() is called, the order will be 5, 3,\n    // 2, 1, 5 and then doNext() will stop immediately, since the first scorer's\n    // docs equals the last one. So the invariant that after calling doNext() \n    // all scorers are on the same doc ID is broken.\n    if (doNext() == NO_MORE_DOCS) {\n      // The scorers did not agree on any document.\n      lastDoc = NO_MORE_DOCS;\n      return;\n    }\n\n    // If first-time skip distance is any predictor of\n    // scorer sparseness, then we should always try to skip first on\n    // those scorers.\n    // Keep last scorer in it's last place (it will be the first\n    // to be skipped on), but reverse all of the others so that\n    // they will be skipped on in order of original high skip.\n    int end = scorers.length - 1;\n    int max = end >> 1;\n    for (int i = 0; i < max; i++) {\n      Scorer tmp = scorers[i];\n      int idx = end - i - 1;\n      scorers[i] = scorers[idx];\n      scorers[idx] = tmp;\n    }\n  }\n\n","sourceOld":"  public ConjunctionScorer(Similarity similarity, Scorer... scorers) throws IOException {\n    super(similarity);\n    this.scorers = scorers;\n    coord = similarity.coord(scorers.length, scorers.length);\n    \n    for (int i = 0; i < scorers.length; i++) {\n      if (scorers[i].nextDoc() == NO_MORE_DOCS) {\n        // If even one of the sub-scorers does not have any documents, this\n        // scorer should not attempt to do any more work.\n        lastDoc = NO_MORE_DOCS;\n        return;\n      }\n    }\n\n    // Sort the array the first time...\n    // We don't need to sort the array in any future calls because we know\n    // it will already start off sorted (all scorers on same doc).\n    \n    // note that this comparator is not consistent with equals!\n    Arrays.sort(scorers, new Comparator<Scorer>() {         // sort the array\n      public int compare(Scorer o1, Scorer o2) {\n        return o1.docID() - o2.docID();\n      }\n    });\n\n    // NOTE: doNext() must be called before the re-sorting of the array later on.\n    // The reason is this: assume there are 5 scorers, whose first docs are 1,\n    // 2, 3, 5, 5 respectively. Sorting (above) leaves the array as is. Calling\n    // doNext() here advances all the first scorers to 5 (or a larger doc ID\n    // they all agree on). \n    // However, if we re-sort before doNext() is called, the order will be 5, 3,\n    // 2, 1, 5 and then doNext() will stop immediately, since the first scorer's\n    // docs equals the last one. So the invariant that after calling doNext() \n    // all scorers are on the same doc ID is broken.\n    if (doNext() == NO_MORE_DOCS) {\n      // The scorers did not agree on any document.\n      lastDoc = NO_MORE_DOCS;\n      return;\n    }\n\n    // If first-time skip distance is any predictor of\n    // scorer sparseness, then we should always try to skip first on\n    // those scorers.\n    // Keep last scorer in it's last place (it will be the first\n    // to be skipped on), but reverse all of the others so that\n    // they will be skipped on in order of original high skip.\n    int end = scorers.length - 1;\n    int max = end >> 1;\n    for (int i = 0; i < max; i++) {\n      Scorer tmp = scorers[i];\n      int idx = end - i - 1;\n      scorers[i] = scorers[idx];\n      scorers[idx] = tmp;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ca0ffea399542e8aac8ed7608f34f8ec4cb8904d","date":1288424244,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/ConjunctionScorer#ConjunctionScorer(Similarity,Scorer...).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/ConjunctionScorer#ConjunctionScorer(Similarity,Scorer...).mjava","sourceNew":"  public ConjunctionScorer(Similarity similarity, Scorer... scorers) throws IOException {\n    super(similarity);\n    this.scorers = scorers;\n    coord = similarity.coord(scorers.length, scorers.length);\n    \n    for (int i = 0; i < scorers.length; i++) {\n      if (scorers[i].nextDoc() == NO_MORE_DOCS) {\n        // If even one of the sub-scorers does not have any documents, this\n        // scorer should not attempt to do any more work.\n        lastDoc = NO_MORE_DOCS;\n        return;\n      }\n    }\n\n    // Sort the array the first time...\n    // We don't need to sort the array in any future calls because we know\n    // it will already start off sorted (all scorers on same doc).\n    \n    // Note that this comparator is not consistent with equals!\n    // Also we use mergeSort here to be stable (so order of Scoreres that\n    // match on first document keeps preserved):\n    ArrayUtil.mergeSort(scorers, new Comparator<Scorer>() { // sort the array\n      public int compare(Scorer o1, Scorer o2) {\n        return o1.docID() - o2.docID();\n      }\n    });\n\n    // NOTE: doNext() must be called before the re-sorting of the array later on.\n    // The reason is this: assume there are 5 scorers, whose first docs are 1,\n    // 2, 3, 5, 5 respectively. Sorting (above) leaves the array as is. Calling\n    // doNext() here advances all the first scorers to 5 (or a larger doc ID\n    // they all agree on). \n    // However, if we re-sort before doNext() is called, the order will be 5, 3,\n    // 2, 1, 5 and then doNext() will stop immediately, since the first scorer's\n    // docs equals the last one. So the invariant that after calling doNext() \n    // all scorers are on the same doc ID is broken.\n    if (doNext() == NO_MORE_DOCS) {\n      // The scorers did not agree on any document.\n      lastDoc = NO_MORE_DOCS;\n      return;\n    }\n\n    // If first-time skip distance is any predictor of\n    // scorer sparseness, then we should always try to skip first on\n    // those scorers.\n    // Keep last scorer in it's last place (it will be the first\n    // to be skipped on), but reverse all of the others so that\n    // they will be skipped on in order of original high skip.\n    int end = scorers.length - 1;\n    int max = end >> 1;\n    for (int i = 0; i < max; i++) {\n      Scorer tmp = scorers[i];\n      int idx = end - i - 1;\n      scorers[i] = scorers[idx];\n      scorers[idx] = tmp;\n    }\n  }\n\n","sourceOld":"  public ConjunctionScorer(Similarity similarity, Scorer... scorers) throws IOException {\n    super(similarity);\n    this.scorers = scorers;\n    coord = similarity.coord(scorers.length, scorers.length);\n    \n    for (int i = 0; i < scorers.length; i++) {\n      if (scorers[i].nextDoc() == NO_MORE_DOCS) {\n        // If even one of the sub-scorers does not have any documents, this\n        // scorer should not attempt to do any more work.\n        lastDoc = NO_MORE_DOCS;\n        return;\n      }\n    }\n\n    // Sort the array the first time...\n    // We don't need to sort the array in any future calls because we know\n    // it will already start off sorted (all scorers on same doc).\n    \n    // note that this comparator is not consistent with equals!\n    Arrays.sort(scorers, new Comparator<Scorer>() {         // sort the array\n      public int compare(Scorer o1, Scorer o2) {\n        return o1.docID() - o2.docID();\n      }\n    });\n\n    // NOTE: doNext() must be called before the re-sorting of the array later on.\n    // The reason is this: assume there are 5 scorers, whose first docs are 1,\n    // 2, 3, 5, 5 respectively. Sorting (above) leaves the array as is. Calling\n    // doNext() here advances all the first scorers to 5 (or a larger doc ID\n    // they all agree on). \n    // However, if we re-sort before doNext() is called, the order will be 5, 3,\n    // 2, 1, 5 and then doNext() will stop immediately, since the first scorer's\n    // docs equals the last one. So the invariant that after calling doNext() \n    // all scorers are on the same doc ID is broken.\n    if (doNext() == NO_MORE_DOCS) {\n      // The scorers did not agree on any document.\n      lastDoc = NO_MORE_DOCS;\n      return;\n    }\n\n    // If first-time skip distance is any predictor of\n    // scorer sparseness, then we should always try to skip first on\n    // those scorers.\n    // Keep last scorer in it's last place (it will be the first\n    // to be skipped on), but reverse all of the others so that\n    // they will be skipped on in order of original high skip.\n    int end = scorers.length - 1;\n    int max = end >> 1;\n    for (int i = 0; i < max; i++) {\n      Scorer tmp = scorers[i];\n      int idx = end - i - 1;\n      scorers[i] = scorers[idx];\n      scorers[idx] = tmp;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/ConjunctionScorer#ConjunctionScorer(Similarity,Scorer...).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/ConjunctionScorer#ConjunctionScorer(Similarity,Scorer...).mjava","sourceNew":"  public ConjunctionScorer(Similarity similarity, Scorer... scorers) throws IOException {\n    super(similarity);\n    this.scorers = scorers;\n    coord = similarity.coord(scorers.length, scorers.length);\n    \n    for (int i = 0; i < scorers.length; i++) {\n      if (scorers[i].nextDoc() == NO_MORE_DOCS) {\n        // If even one of the sub-scorers does not have any documents, this\n        // scorer should not attempt to do any more work.\n        lastDoc = NO_MORE_DOCS;\n        return;\n      }\n    }\n\n    // Sort the array the first time...\n    // We don't need to sort the array in any future calls because we know\n    // it will already start off sorted (all scorers on same doc).\n    \n    // Note that this comparator is not consistent with equals!\n    // Also we use mergeSort here to be stable (so order of Scoreres that\n    // match on first document keeps preserved):\n    ArrayUtil.mergeSort(scorers, new Comparator<Scorer>() { // sort the array\n      public int compare(Scorer o1, Scorer o2) {\n        return o1.docID() - o2.docID();\n      }\n    });\n\n    // NOTE: doNext() must be called before the re-sorting of the array later on.\n    // The reason is this: assume there are 5 scorers, whose first docs are 1,\n    // 2, 3, 5, 5 respectively. Sorting (above) leaves the array as is. Calling\n    // doNext() here advances all the first scorers to 5 (or a larger doc ID\n    // they all agree on). \n    // However, if we re-sort before doNext() is called, the order will be 5, 3,\n    // 2, 1, 5 and then doNext() will stop immediately, since the first scorer's\n    // docs equals the last one. So the invariant that after calling doNext() \n    // all scorers are on the same doc ID is broken.\n    if (doNext() == NO_MORE_DOCS) {\n      // The scorers did not agree on any document.\n      lastDoc = NO_MORE_DOCS;\n      return;\n    }\n\n    // If first-time skip distance is any predictor of\n    // scorer sparseness, then we should always try to skip first on\n    // those scorers.\n    // Keep last scorer in it's last place (it will be the first\n    // to be skipped on), but reverse all of the others so that\n    // they will be skipped on in order of original high skip.\n    int end = scorers.length - 1;\n    int max = end >> 1;\n    for (int i = 0; i < max; i++) {\n      Scorer tmp = scorers[i];\n      int idx = end - i - 1;\n      scorers[i] = scorers[idx];\n      scorers[idx] = tmp;\n    }\n  }\n\n","sourceOld":"  public ConjunctionScorer(Similarity similarity, Scorer... scorers) throws IOException {\n    super(similarity);\n    this.scorers = scorers;\n    coord = similarity.coord(scorers.length, scorers.length);\n    \n    for (int i = 0; i < scorers.length; i++) {\n      if (scorers[i].nextDoc() == NO_MORE_DOCS) {\n        // If even one of the sub-scorers does not have any documents, this\n        // scorer should not attempt to do any more work.\n        lastDoc = NO_MORE_DOCS;\n        return;\n      }\n    }\n\n    // Sort the array the first time...\n    // We don't need to sort the array in any future calls because we know\n    // it will already start off sorted (all scorers on same doc).\n    \n    // note that this comparator is not consistent with equals!\n    Arrays.sort(scorers, new Comparator<Scorer>() {         // sort the array\n      public int compare(Scorer o1, Scorer o2) {\n        return o1.docID() - o2.docID();\n      }\n    });\n\n    // NOTE: doNext() must be called before the re-sorting of the array later on.\n    // The reason is this: assume there are 5 scorers, whose first docs are 1,\n    // 2, 3, 5, 5 respectively. Sorting (above) leaves the array as is. Calling\n    // doNext() here advances all the first scorers to 5 (or a larger doc ID\n    // they all agree on). \n    // However, if we re-sort before doNext() is called, the order will be 5, 3,\n    // 2, 1, 5 and then doNext() will stop immediately, since the first scorer's\n    // docs equals the last one. So the invariant that after calling doNext() \n    // all scorers are on the same doc ID is broken.\n    if (doNext() == NO_MORE_DOCS) {\n      // The scorers did not agree on any document.\n      lastDoc = NO_MORE_DOCS;\n      return;\n    }\n\n    // If first-time skip distance is any predictor of\n    // scorer sparseness, then we should always try to skip first on\n    // those scorers.\n    // Keep last scorer in it's last place (it will be the first\n    // to be skipped on), but reverse all of the others so that\n    // they will be skipped on in order of original high skip.\n    int end = scorers.length - 1;\n    int max = end >> 1;\n    for (int i = 0; i < max; i++) {\n      Scorer tmp = scorers[i];\n      int idx = end - i - 1;\n      scorers[i] = scorers[idx];\n      scorers[idx] = tmp;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3e00f80591de714c6975f454e33e0fa5218b5902","date":1294514405,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/ConjunctionScorer#ConjunctionScorer(float,Scorer...).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/ConjunctionScorer#ConjunctionScorer(Similarity,Scorer...).mjava","sourceNew":"  public ConjunctionScorer(float coord, Scorer... scorers) throws IOException {\n    super(null);\n    this.scorers = scorers;\n    this.coord = coord;\n    \n    for (int i = 0; i < scorers.length; i++) {\n      if (scorers[i].nextDoc() == NO_MORE_DOCS) {\n        // If even one of the sub-scorers does not have any documents, this\n        // scorer should not attempt to do any more work.\n        lastDoc = NO_MORE_DOCS;\n        return;\n      }\n    }\n\n    // Sort the array the first time...\n    // We don't need to sort the array in any future calls because we know\n    // it will already start off sorted (all scorers on same doc).\n    \n    // Note that this comparator is not consistent with equals!\n    // Also we use mergeSort here to be stable (so order of Scoreres that\n    // match on first document keeps preserved):\n    ArrayUtil.mergeSort(scorers, new Comparator<Scorer>() { // sort the array\n      public int compare(Scorer o1, Scorer o2) {\n        return o1.docID() - o2.docID();\n      }\n    });\n\n    // NOTE: doNext() must be called before the re-sorting of the array later on.\n    // The reason is this: assume there are 5 scorers, whose first docs are 1,\n    // 2, 3, 5, 5 respectively. Sorting (above) leaves the array as is. Calling\n    // doNext() here advances all the first scorers to 5 (or a larger doc ID\n    // they all agree on). \n    // However, if we re-sort before doNext() is called, the order will be 5, 3,\n    // 2, 1, 5 and then doNext() will stop immediately, since the first scorer's\n    // docs equals the last one. So the invariant that after calling doNext() \n    // all scorers are on the same doc ID is broken.\n    if (doNext() == NO_MORE_DOCS) {\n      // The scorers did not agree on any document.\n      lastDoc = NO_MORE_DOCS;\n      return;\n    }\n\n    // If first-time skip distance is any predictor of\n    // scorer sparseness, then we should always try to skip first on\n    // those scorers.\n    // Keep last scorer in it's last place (it will be the first\n    // to be skipped on), but reverse all of the others so that\n    // they will be skipped on in order of original high skip.\n    int end = scorers.length - 1;\n    int max = end >> 1;\n    for (int i = 0; i < max; i++) {\n      Scorer tmp = scorers[i];\n      int idx = end - i - 1;\n      scorers[i] = scorers[idx];\n      scorers[idx] = tmp;\n    }\n  }\n\n","sourceOld":"  public ConjunctionScorer(Similarity similarity, Scorer... scorers) throws IOException {\n    super(similarity);\n    this.scorers = scorers;\n    coord = similarity.coord(scorers.length, scorers.length);\n    \n    for (int i = 0; i < scorers.length; i++) {\n      if (scorers[i].nextDoc() == NO_MORE_DOCS) {\n        // If even one of the sub-scorers does not have any documents, this\n        // scorer should not attempt to do any more work.\n        lastDoc = NO_MORE_DOCS;\n        return;\n      }\n    }\n\n    // Sort the array the first time...\n    // We don't need to sort the array in any future calls because we know\n    // it will already start off sorted (all scorers on same doc).\n    \n    // Note that this comparator is not consistent with equals!\n    // Also we use mergeSort here to be stable (so order of Scoreres that\n    // match on first document keeps preserved):\n    ArrayUtil.mergeSort(scorers, new Comparator<Scorer>() { // sort the array\n      public int compare(Scorer o1, Scorer o2) {\n        return o1.docID() - o2.docID();\n      }\n    });\n\n    // NOTE: doNext() must be called before the re-sorting of the array later on.\n    // The reason is this: assume there are 5 scorers, whose first docs are 1,\n    // 2, 3, 5, 5 respectively. Sorting (above) leaves the array as is. Calling\n    // doNext() here advances all the first scorers to 5 (or a larger doc ID\n    // they all agree on). \n    // However, if we re-sort before doNext() is called, the order will be 5, 3,\n    // 2, 1, 5 and then doNext() will stop immediately, since the first scorer's\n    // docs equals the last one. So the invariant that after calling doNext() \n    // all scorers are on the same doc ID is broken.\n    if (doNext() == NO_MORE_DOCS) {\n      // The scorers did not agree on any document.\n      lastDoc = NO_MORE_DOCS;\n      return;\n    }\n\n    // If first-time skip distance is any predictor of\n    // scorer sparseness, then we should always try to skip first on\n    // those scorers.\n    // Keep last scorer in it's last place (it will be the first\n    // to be skipped on), but reverse all of the others so that\n    // they will be skipped on in order of original high skip.\n    int end = scorers.length - 1;\n    int max = end >> 1;\n    for (int i = 0; i < max; i++) {\n      Scorer tmp = scorers[i];\n      int idx = end - i - 1;\n      scorers[i] = scorers[idx];\n      scorers[idx] = tmp;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"868da859b43505d9d2a023bfeae6dd0c795f5295","date":1294948401,"type":4,"author":"Michael Busch","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/search/ConjunctionScorer#ConjunctionScorer(Similarity,Scorer...).mjava","sourceNew":null,"sourceOld":"  public ConjunctionScorer(Similarity similarity, Scorer... scorers) throws IOException {\n    super(similarity);\n    this.scorers = scorers;\n    coord = similarity.coord(scorers.length, scorers.length);\n    \n    for (int i = 0; i < scorers.length; i++) {\n      if (scorers[i].nextDoc() == NO_MORE_DOCS) {\n        // If even one of the sub-scorers does not have any documents, this\n        // scorer should not attempt to do any more work.\n        lastDoc = NO_MORE_DOCS;\n        return;\n      }\n    }\n\n    // Sort the array the first time...\n    // We don't need to sort the array in any future calls because we know\n    // it will already start off sorted (all scorers on same doc).\n    \n    // Note that this comparator is not consistent with equals!\n    // Also we use mergeSort here to be stable (so order of Scoreres that\n    // match on first document keeps preserved):\n    ArrayUtil.mergeSort(scorers, new Comparator<Scorer>() { // sort the array\n      public int compare(Scorer o1, Scorer o2) {\n        return o1.docID() - o2.docID();\n      }\n    });\n\n    // NOTE: doNext() must be called before the re-sorting of the array later on.\n    // The reason is this: assume there are 5 scorers, whose first docs are 1,\n    // 2, 3, 5, 5 respectively. Sorting (above) leaves the array as is. Calling\n    // doNext() here advances all the first scorers to 5 (or a larger doc ID\n    // they all agree on). \n    // However, if we re-sort before doNext() is called, the order will be 5, 3,\n    // 2, 1, 5 and then doNext() will stop immediately, since the first scorer's\n    // docs equals the last one. So the invariant that after calling doNext() \n    // all scorers are on the same doc ID is broken.\n    if (doNext() == NO_MORE_DOCS) {\n      // The scorers did not agree on any document.\n      lastDoc = NO_MORE_DOCS;\n      return;\n    }\n\n    // If first-time skip distance is any predictor of\n    // scorer sparseness, then we should always try to skip first on\n    // those scorers.\n    // Keep last scorer in it's last place (it will be the first\n    // to be skipped on), but reverse all of the others so that\n    // they will be skipped on in order of original high skip.\n    int end = scorers.length - 1;\n    int max = end >> 1;\n    for (int i = 0; i < max; i++) {\n      Scorer tmp = scorers[i];\n      int idx = end - i - 1;\n      scorers[i] = scorers[idx];\n      scorers[idx] = tmp;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":4,"author":"Simon Willnauer","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/search/ConjunctionScorer#ConjunctionScorer(Similarity,Scorer...).mjava","sourceNew":null,"sourceOld":"  public ConjunctionScorer(Similarity similarity, Scorer... scorers) throws IOException {\n    super(similarity);\n    this.scorers = scorers;\n    coord = similarity.coord(scorers.length, scorers.length);\n    \n    for (int i = 0; i < scorers.length; i++) {\n      if (scorers[i].nextDoc() == NO_MORE_DOCS) {\n        // If even one of the sub-scorers does not have any documents, this\n        // scorer should not attempt to do any more work.\n        lastDoc = NO_MORE_DOCS;\n        return;\n      }\n    }\n\n    // Sort the array the first time...\n    // We don't need to sort the array in any future calls because we know\n    // it will already start off sorted (all scorers on same doc).\n    \n    // Note that this comparator is not consistent with equals!\n    // Also we use mergeSort here to be stable (so order of Scoreres that\n    // match on first document keeps preserved):\n    ArrayUtil.mergeSort(scorers, new Comparator<Scorer>() { // sort the array\n      public int compare(Scorer o1, Scorer o2) {\n        return o1.docID() - o2.docID();\n      }\n    });\n\n    // NOTE: doNext() must be called before the re-sorting of the array later on.\n    // The reason is this: assume there are 5 scorers, whose first docs are 1,\n    // 2, 3, 5, 5 respectively. Sorting (above) leaves the array as is. Calling\n    // doNext() here advances all the first scorers to 5 (or a larger doc ID\n    // they all agree on). \n    // However, if we re-sort before doNext() is called, the order will be 5, 3,\n    // 2, 1, 5 and then doNext() will stop immediately, since the first scorer's\n    // docs equals the last one. So the invariant that after calling doNext() \n    // all scorers are on the same doc ID is broken.\n    if (doNext() == NO_MORE_DOCS) {\n      // The scorers did not agree on any document.\n      lastDoc = NO_MORE_DOCS;\n      return;\n    }\n\n    // If first-time skip distance is any predictor of\n    // scorer sparseness, then we should always try to skip first on\n    // those scorers.\n    // Keep last scorer in it's last place (it will be the first\n    // to be skipped on), but reverse all of the others so that\n    // they will be skipped on in order of original high skip.\n    int end = scorers.length - 1;\n    int max = end >> 1;\n    for (int i = 0; i < max; i++) {\n      Scorer tmp = scorers[i];\n      int idx = end - i - 1;\n      scorers[i] = scorers[idx];\n      scorers[idx] = tmp;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ae7aa98ce0c64f3b2b81087d14ff9ae992b4903b":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"3e00f80591de714c6975f454e33e0fa5218b5902":["ae7aa98ce0c64f3b2b81087d14ff9ae992b4903b"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["ca0ffea399542e8aac8ed7608f34f8ec4cb8904d","3e00f80591de714c6975f454e33e0fa5218b5902"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["9454a6510e2db155fb01faa5c049b06ece95fab9","ae7aa98ce0c64f3b2b81087d14ff9ae992b4903b"],"ca0ffea399542e8aac8ed7608f34f8ec4cb8904d":["9454a6510e2db155fb01faa5c049b06ece95fab9","ae7aa98ce0c64f3b2b81087d14ff9ae992b4903b"],"868da859b43505d9d2a023bfeae6dd0c795f5295":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","3e00f80591de714c6975f454e33e0fa5218b5902"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3e00f80591de714c6975f454e33e0fa5218b5902"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"ae7aa98ce0c64f3b2b81087d14ff9ae992b4903b":["3e00f80591de714c6975f454e33e0fa5218b5902","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","ca0ffea399542e8aac8ed7608f34f8ec4cb8904d"],"3e00f80591de714c6975f454e33e0fa5218b5902":["29ef99d61cda9641b6250bf9567329a6e65f901d","868da859b43505d9d2a023bfeae6dd0c795f5295","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"29ef99d61cda9641b6250bf9567329a6e65f901d":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["868da859b43505d9d2a023bfeae6dd0c795f5295"],"ca0ffea399542e8aac8ed7608f34f8ec4cb8904d":["29ef99d61cda9641b6250bf9567329a6e65f901d"],"868da859b43505d9d2a023bfeae6dd0c795f5295":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["ae7aa98ce0c64f3b2b81087d14ff9ae992b4903b","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","ca0ffea399542e8aac8ed7608f34f8ec4cb8904d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["29ef99d61cda9641b6250bf9567329a6e65f901d","868da859b43505d9d2a023bfeae6dd0c795f5295","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}