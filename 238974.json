{"path":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#process().mjava","commits":[{"id":"ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d","date":1426480823,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#process().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void process() throws IOException {\n    sf = fcontext.searcher.getSchema().getField(freq.field);\n\n    response = getRangeCountsIndexed();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["459698d341a59ca453792f38503b2821b68e7d7b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":0,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#process().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void process() throws IOException {\n    sf = fcontext.searcher.getSchema().getField(freq.field);\n\n    response = getRangeCountsIndexed();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"330e80d31a51e837b9cc906035e114377c0501dc","date":1429994103,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#process().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#process().mjava","sourceNew":"  @Override\n  public void process() throws IOException {\n    sf = fcontext.searcher.getSchema().getField(freq.field);\n\n    response = getRangeCounts();\n  }\n\n","sourceOld":"  @Override\n  public void process() throws IOException {\n    sf = fcontext.searcher.getSchema().getField(freq.field);\n\n    response = getRangeCountsIndexed();\n  }\n\n","bugFix":null,"bugIntro":["c05b634713ca09b2267477408773904d4c69dd9d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"637b14d3587fbf956ba5f8d39409d579d34f69de","date":1430057809,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#process().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#process().mjava","sourceNew":"  @Override\n  public void process() throws IOException {\n    // Under the normal mincount=0, each shard will need to return 0 counts since we don't calculate buckets at the top level.\n    // But if mincount>0 then our sub mincount can be set to 1.\n\n    effectiveMincount = fcontext.isShard() ? (freq.mincount > 0 ? 1 : 0) : freq.mincount;\n    sf = fcontext.searcher.getSchema().getField(freq.field);\n    response = getRangeCounts();\n  }\n\n","sourceOld":"  @Override\n  public void process() throws IOException {\n    sf = fcontext.searcher.getSchema().getField(freq.field);\n\n    response = getRangeCounts();\n  }\n\n","bugFix":null,"bugIntro":["459698d341a59ca453792f38503b2821b68e7d7b","c05b634713ca09b2267477408773904d4c69dd9d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"faf1236ae092482293a7e0659e347d172185ef6f","date":1430314113,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#process().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#process().mjava","sourceNew":"  @Override\n  public void process() throws IOException {\n    super.process();\n\n    // Under the normal mincount=0, each shard will need to return 0 counts since we don't calculate buckets at the top level.\n    // But if mincount>0 then our sub mincount can be set to 1.\n\n    effectiveMincount = fcontext.isShard() ? (freq.mincount > 0 ? 1 : 0) : freq.mincount;\n    sf = fcontext.searcher.getSchema().getField(freq.field);\n    response = getRangeCounts();\n  }\n\n","sourceOld":"  @Override\n  public void process() throws IOException {\n    // Under the normal mincount=0, each shard will need to return 0 counts since we don't calculate buckets at the top level.\n    // But if mincount>0 then our sub mincount can be set to 1.\n\n    effectiveMincount = fcontext.isShard() ? (freq.mincount > 0 ? 1 : 0) : freq.mincount;\n    sf = fcontext.searcher.getSchema().getField(freq.field);\n    response = getRangeCounts();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"459698d341a59ca453792f38503b2821b68e7d7b","date":1515273825,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#process().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#process().mjava","sourceNew":"  @Override\n  public void process() throws IOException {\n    super.process();\n\n    // Under the normal mincount=0, each shard will need to return 0 counts since we don't calculate buckets at the top level.\n    // If mincount>0 then we could *potentially* set our sub mincount to 1...\n    // ...but that would require sorting the buckets (by their val) at the top level\n    //\n    // Tather then do that, which could be complicated by non trivial field types, we'll force the sub-shard effectiveMincount\n    // to be 0, ensuring that we can trivially merge all the buckets from every shard\n    // (we have to filter the merged buckets by the original mincount either way)\n    effectiveMincount = fcontext.isShard() ? 0 : freq.mincount;\n    sf = fcontext.searcher.getSchema().getField(freq.field);\n    response = getRangeCounts();\n  }\n\n","sourceOld":"  @Override\n  public void process() throws IOException {\n    super.process();\n\n    // Under the normal mincount=0, each shard will need to return 0 counts since we don't calculate buckets at the top level.\n    // But if mincount>0 then our sub mincount can be set to 1.\n\n    effectiveMincount = fcontext.isShard() ? (freq.mincount > 0 ? 1 : 0) : freq.mincount;\n    sf = fcontext.searcher.getSchema().getField(freq.field);\n    response = getRangeCounts();\n  }\n\n","bugFix":["637b14d3587fbf956ba5f8d39409d579d34f69de","ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d"],"bugIntro":["c05b634713ca09b2267477408773904d4c69dd9d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#process().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#process().mjava","sourceNew":"  @Override\n  public void process() throws IOException {\n    super.process();\n\n    // Under the normal mincount=0, each shard will need to return 0 counts since we don't calculate buckets at the top level.\n    // If mincount>0 then we could *potentially* set our sub mincount to 1...\n    // ...but that would require sorting the buckets (by their val) at the top level\n    //\n    // Tather then do that, which could be complicated by non trivial field types, we'll force the sub-shard effectiveMincount\n    // to be 0, ensuring that we can trivially merge all the buckets from every shard\n    // (we have to filter the merged buckets by the original mincount either way)\n    effectiveMincount = fcontext.isShard() ? 0 : freq.mincount;\n    sf = fcontext.searcher.getSchema().getField(freq.field);\n    response = getRangeCounts();\n  }\n\n","sourceOld":"  @Override\n  public void process() throws IOException {\n    super.process();\n\n    // Under the normal mincount=0, each shard will need to return 0 counts since we don't calculate buckets at the top level.\n    // But if mincount>0 then our sub mincount can be set to 1.\n\n    effectiveMincount = fcontext.isShard() ? (freq.mincount > 0 ? 1 : 0) : freq.mincount;\n    sf = fcontext.searcher.getSchema().getField(freq.field);\n    response = getRangeCounts();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c05b634713ca09b2267477408773904d4c69dd9d","date":1530894845,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#process().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#process().mjava","sourceNew":"  @Override\n  public void process() throws IOException {\n    super.process();\n\n    if (fcontext.facetInfo != null) { // refinement?\n      response = refineFacets();\n    } else {\n      // phase#1: build list of all buckets and return full facets...\n      createRangeList();\n      response = getRangeCountsIndexed();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process() throws IOException {\n    super.process();\n\n    // Under the normal mincount=0, each shard will need to return 0 counts since we don't calculate buckets at the top level.\n    // If mincount>0 then we could *potentially* set our sub mincount to 1...\n    // ...but that would require sorting the buckets (by their val) at the top level\n    //\n    // Tather then do that, which could be complicated by non trivial field types, we'll force the sub-shard effectiveMincount\n    // to be 0, ensuring that we can trivially merge all the buckets from every shard\n    // (we have to filter the merged buckets by the original mincount either way)\n    effectiveMincount = fcontext.isShard() ? 0 : freq.mincount;\n    sf = fcontext.searcher.getSchema().getField(freq.field);\n    response = getRangeCounts();\n  }\n\n","bugFix":["459698d341a59ca453792f38503b2821b68e7d7b","330e80d31a51e837b9cc906035e114377c0501dc","637b14d3587fbf956ba5f8d39409d579d34f69de"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#process().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#process().mjava","sourceNew":"  @Override\n  public void process() throws IOException {\n    super.process();\n\n    if (fcontext.facetInfo != null) { // refinement?\n      response = refineFacets();\n    } else {\n      // phase#1: build list of all buckets and return full facets...\n      createRangeList();\n      response = getRangeCountsIndexed();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process() throws IOException {\n    super.process();\n\n    // Under the normal mincount=0, each shard will need to return 0 counts since we don't calculate buckets at the top level.\n    // If mincount>0 then we could *potentially* set our sub mincount to 1...\n    // ...but that would require sorting the buckets (by their val) at the top level\n    //\n    // Tather then do that, which could be complicated by non trivial field types, we'll force the sub-shard effectiveMincount\n    // to be 0, ensuring that we can trivially merge all the buckets from every shard\n    // (we have to filter the merged buckets by the original mincount either way)\n    effectiveMincount = fcontext.isShard() ? 0 : freq.mincount;\n    sf = fcontext.searcher.getSchema().getField(freq.field);\n    response = getRangeCounts();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#process().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#process().mjava","sourceNew":"  @Override\n  public void process() throws IOException {\n    super.process();\n\n    if (fcontext.facetInfo != null) { // refinement?\n      response = refineFacets();\n    } else {\n      // phase#1: build list of all buckets and return full facets...\n      createRangeList();\n      response = getRangeCountsIndexed();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process() throws IOException {\n    super.process();\n\n    // Under the normal mincount=0, each shard will need to return 0 counts since we don't calculate buckets at the top level.\n    // If mincount>0 then we could *potentially* set our sub mincount to 1...\n    // ...but that would require sorting the buckets (by their val) at the top level\n    //\n    // Tather then do that, which could be complicated by non trivial field types, we'll force the sub-shard effectiveMincount\n    // to be 0, ensuring that we can trivially merge all the buckets from every shard\n    // (we have to filter the merged buckets by the original mincount either way)\n    effectiveMincount = fcontext.isShard() ? 0 : freq.mincount;\n    sf = fcontext.searcher.getSchema().getField(freq.field);\n    response = getRangeCounts();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a56a9893014b284af4d1af451e6c02e7ffdf5b6e","date":1590065972,"type":5,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor#process().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#process().mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\"})\n  public void process() throws IOException {\n    super.process();\n\n    if (fcontext.facetInfo != null) { // refinement?\n      response = refineFacets();\n    } else {\n      // phase#1: build list of all buckets and return full facets...\n      createRangeList();\n      response = getRangeCountsIndexed();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process() throws IOException {\n    super.process();\n\n    if (fcontext.facetInfo != null) { // refinement?\n      response = refineFacets();\n    } else {\n      // phase#1: build list of all buckets and return full facets...\n      createRangeList();\n      response = getRangeCountsIndexed();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b94236357aaa22b76c10629851fe4e376e0cea82":["faf1236ae092482293a7e0659e347d172185ef6f","459698d341a59ca453792f38503b2821b68e7d7b"],"459698d341a59ca453792f38503b2821b68e7d7b":["faf1236ae092482293a7e0659e347d172185ef6f"],"637b14d3587fbf956ba5f8d39409d579d34f69de":["330e80d31a51e837b9cc906035e114377c0501dc"],"faf1236ae092482293a7e0659e347d172185ef6f":["637b14d3587fbf956ba5f8d39409d579d34f69de"],"c05b634713ca09b2267477408773904d4c69dd9d":["b94236357aaa22b76c10629851fe4e376e0cea82"],"330e80d31a51e837b9cc906035e114377c0501dc":["ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d"],"a56a9893014b284af4d1af451e6c02e7ffdf5b6e":["c05b634713ca09b2267477408773904d4c69dd9d"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["b94236357aaa22b76c10629851fe4e376e0cea82","c05b634713ca09b2267477408773904d4c69dd9d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a56a9893014b284af4d1af451e6c02e7ffdf5b6e"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["b94236357aaa22b76c10629851fe4e376e0cea82","c05b634713ca09b2267477408773904d4c69dd9d"]},"commit2Childs":{"b94236357aaa22b76c10629851fe4e376e0cea82":["c05b634713ca09b2267477408773904d4c69dd9d","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"459698d341a59ca453792f38503b2821b68e7d7b":["b94236357aaa22b76c10629851fe4e376e0cea82"],"637b14d3587fbf956ba5f8d39409d579d34f69de":["faf1236ae092482293a7e0659e347d172185ef6f"],"faf1236ae092482293a7e0659e347d172185ef6f":["b94236357aaa22b76c10629851fe4e376e0cea82","459698d341a59ca453792f38503b2821b68e7d7b"],"c05b634713ca09b2267477408773904d4c69dd9d":["a56a9893014b284af4d1af451e6c02e7ffdf5b6e","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"330e80d31a51e837b9cc906035e114377c0501dc":["637b14d3587fbf956ba5f8d39409d579d34f69de"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"a56a9893014b284af4d1af451e6c02e7ffdf5b6e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d"],"ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d":["330e80d31a51e837b9cc906035e114377c0501dc","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}