{"path":"solr/core/src/java/org/apache/solr/search/stats/ExactStatsCache#doReturnLocalStats(ResponseBuilder,SolrIndexSearcher).mjava","commits":[{"id":"df72a23fb74bebe914e3f3972063a884327c0436","date":1570470832,"type":1,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/stats/ExactStatsCache#doReturnLocalStats(ResponseBuilder,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/stats/ExactStatsCache#returnLocalStats(ResponseBuilder,SolrIndexSearcher).mjava","sourceNew":"  @Override\n  protected void doReturnLocalStats(ResponseBuilder rb, SolrIndexSearcher searcher) {\n    Query q = rb.getQuery();\n    try {\n      Set<Term> additionalTerms = StatsUtil.termsFromEncodedString(rb.req.getParams().get(TERMS_KEY));\n      Set<String> additionalFields = StatsUtil.fieldsFromString(rb.req.getParams().get(FIELDS_KEY));\n      HashSet<Term> terms = new HashSet<>();\n      HashMap<String,TermStats> statsMap = new HashMap<>();\n      HashMap<String,CollectionStats> colMap = new HashMap<>();\n      IndexSearcher statsCollectingSearcher = new IndexSearcher(searcher.getIndexReader()){\n        @Override\n        public CollectionStatistics collectionStatistics(String field) throws IOException {\n          CollectionStatistics cs = super.collectionStatistics(field);\n          if (cs != null) {\n            colMap.put(field, new CollectionStats(cs));\n          }\n          return cs;\n        }\n\n        @Override\n        public TermStatistics termStatistics(Term term, int docFreq, long totalTermFreq) throws IOException {\n          TermStatistics ts = super.termStatistics(term, docFreq, totalTermFreq);\n          terms.add(term);\n          statsMap.put(term.toString(), new TermStats(term.field(), ts));\n          return ts;\n        }\n      };\n      statsCollectingSearcher.createWeight(searcher.rewrite(q), ScoreMode.COMPLETE, 1);\n      for (String field : additionalFields) {\n        if (colMap.containsKey(field)) {\n          continue;\n        }\n        statsCollectingSearcher.collectionStatistics(field);\n      }\n      for (Term term : additionalTerms) {\n        statsCollectingSearcher.createWeight(searcher.rewrite(new TermQuery(term)), ScoreMode.COMPLETE, 1);\n      }\n\n      CloudDescriptor cloudDescriptor = searcher.getCore().getCoreDescriptor().getCloudDescriptor();\n      if (cloudDescriptor != null) {\n        rb.rsp.add(ShardParams.SHARD_NAME, cloudDescriptor.getShardId());\n      }\n      if (!terms.isEmpty()) {\n        rb.rsp.add(TERMS_KEY, StatsUtil.termsToEncodedString(terms));\n      }\n      if (!statsMap.isEmpty()) { //Don't add empty keys\n        String termStatsString = StatsUtil.termStatsMapToString(statsMap);\n        rb.rsp.add(TERM_STATS_KEY, termStatsString);\n        if (log.isDebugEnabled()) {\n          log.debug(\"termStats={}, terms={}, numDocs={}\", termStatsString, terms, searcher.maxDoc());\n        }\n      }\n      if (!colMap.isEmpty()) {\n        String colStatsString = StatsUtil.colStatsMapToString(colMap);\n        rb.rsp.add(COL_STATS_KEY, colStatsString);\n        if (log.isDebugEnabled()) {\n          log.debug(\"collectionStats={}, terms={}, numDocs={}\", colStatsString, terms, searcher.maxDoc());\n        }\n      }\n    } catch (IOException e) {\n      log.error(\"Error collecting local stats, query='\" + q.toString() + \"'\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error collecting local stats.\", e);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void returnLocalStats(ResponseBuilder rb, SolrIndexSearcher searcher) {\n    Query q = rb.getQuery();\n    try {\n      HashSet<Term> terms = new HashSet<>();\n      HashMap<String,TermStats> statsMap = new HashMap<>();\n      HashMap<String,CollectionStats> colMap = new HashMap<>();\n      IndexSearcher statsCollectingSearcher = new IndexSearcher(searcher.getIndexReader()){\n        @Override\n        public CollectionStatistics collectionStatistics(String field) throws IOException {\n          CollectionStatistics cs = super.collectionStatistics(field);\n          if (cs != null) {\n            colMap.put(field, new CollectionStats(cs));\n          }\n          return cs;\n        }\n\n        @Override\n        public TermStatistics termStatistics(Term term, int docFreq, long totalTermFreq) throws IOException {\n          TermStatistics ts = super.termStatistics(term, docFreq, totalTermFreq);\n          terms.add(term);\n          statsMap.put(term.toString(), new TermStats(term.field(), ts));\n          return ts;\n        }\n      };\n      statsCollectingSearcher.createWeight(searcher.rewrite(q), ScoreMode.COMPLETE, 1);\n\n      for (Term t : terms) {\n        rb.rsp.add(TERMS_KEY, t.toString());\n      }\n      if (statsMap.size() != 0) { //Don't add empty keys\n        String termStatsString = StatsUtil.termStatsMapToString(statsMap);\n        rb.rsp.add(TERM_STATS_KEY, termStatsString);\n        if (log.isDebugEnabled()) {\n          log.debug(\"termStats={}, terms={}, numDocs={}\", termStatsString, terms, searcher.maxDoc());\n        }\n      }\n      if (colMap.size() != 0){\n        String colStatsString = StatsUtil.colStatsMapToString(colMap);\n        rb.rsp.add(COL_STATS_KEY, colStatsString);\n        if (log.isDebugEnabled()) {\n          log.debug(\"collectionStats={}, terms={}, numDocs={}\", colStatsString, terms, searcher.maxDoc());\n        }\n      }\n    } catch (IOException e) {\n      log.error(\"Error collecting local stats, query='\" + q.toString() + \"'\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error collecting local stats.\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":0,"author":"jimczi","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/stats/ExactStatsCache#doReturnLocalStats(ResponseBuilder,SolrIndexSearcher).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  protected void doReturnLocalStats(ResponseBuilder rb, SolrIndexSearcher searcher) {\n    Query q = rb.getQuery();\n    try {\n      Set<Term> additionalTerms = StatsUtil.termsFromEncodedString(rb.req.getParams().get(TERMS_KEY));\n      Set<String> additionalFields = StatsUtil.fieldsFromString(rb.req.getParams().get(FIELDS_KEY));\n      HashSet<Term> terms = new HashSet<>();\n      HashMap<String,TermStats> statsMap = new HashMap<>();\n      HashMap<String,CollectionStats> colMap = new HashMap<>();\n      IndexSearcher statsCollectingSearcher = new IndexSearcher(searcher.getIndexReader()){\n        @Override\n        public CollectionStatistics collectionStatistics(String field) throws IOException {\n          CollectionStatistics cs = super.collectionStatistics(field);\n          if (cs != null) {\n            colMap.put(field, new CollectionStats(cs));\n          }\n          return cs;\n        }\n\n        @Override\n        public TermStatistics termStatistics(Term term, int docFreq, long totalTermFreq) throws IOException {\n          TermStatistics ts = super.termStatistics(term, docFreq, totalTermFreq);\n          terms.add(term);\n          statsMap.put(term.toString(), new TermStats(term.field(), ts));\n          return ts;\n        }\n      };\n      statsCollectingSearcher.createWeight(searcher.rewrite(q), ScoreMode.COMPLETE, 1);\n      for (String field : additionalFields) {\n        if (colMap.containsKey(field)) {\n          continue;\n        }\n        statsCollectingSearcher.collectionStatistics(field);\n      }\n      for (Term term : additionalTerms) {\n        statsCollectingSearcher.createWeight(searcher.rewrite(new TermQuery(term)), ScoreMode.COMPLETE, 1);\n      }\n\n      CloudDescriptor cloudDescriptor = searcher.getCore().getCoreDescriptor().getCloudDescriptor();\n      if (cloudDescriptor != null) {\n        rb.rsp.add(ShardParams.SHARD_NAME, cloudDescriptor.getShardId());\n      }\n      if (!terms.isEmpty()) {\n        rb.rsp.add(TERMS_KEY, StatsUtil.termsToEncodedString(terms));\n      }\n      if (!statsMap.isEmpty()) { //Don't add empty keys\n        String termStatsString = StatsUtil.termStatsMapToString(statsMap);\n        rb.rsp.add(TERM_STATS_KEY, termStatsString);\n        if (log.isDebugEnabled()) {\n          log.debug(\"termStats={}, terms={}, numDocs={}\", termStatsString, terms, searcher.maxDoc());\n        }\n      }\n      if (!colMap.isEmpty()) {\n        String colStatsString = StatsUtil.colStatsMapToString(colMap);\n        rb.rsp.add(COL_STATS_KEY, colStatsString);\n        if (log.isDebugEnabled()) {\n          log.debug(\"collectionStats={}, terms={}, numDocs={}\", colStatsString, terms, searcher.maxDoc());\n        }\n      }\n    } catch (IOException e) {\n      log.error(\"Error collecting local stats, query='\" + q.toString() + \"'\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error collecting local stats.\", e);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54faedfb0e03479a38f5ee82f2dfaeea536e9404","date":1587251295,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/stats/ExactStatsCache#doReturnLocalStats(ResponseBuilder,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/stats/ExactStatsCache#doReturnLocalStats(ResponseBuilder,SolrIndexSearcher).mjava","sourceNew":"  @Override\n  protected void doReturnLocalStats(ResponseBuilder rb, SolrIndexSearcher searcher) {\n    Query q = rb.getQuery();\n    try {\n      Set<Term> additionalTerms = StatsUtil.termsFromEncodedString(rb.req.getParams().get(TERMS_KEY));\n      Set<String> additionalFields = StatsUtil.fieldsFromString(rb.req.getParams().get(FIELDS_KEY));\n      HashSet<Term> terms = new HashSet<>();\n      HashMap<String,TermStats> statsMap = new HashMap<>();\n      HashMap<String,CollectionStats> colMap = new HashMap<>();\n      IndexSearcher statsCollectingSearcher = new IndexSearcher(searcher.getIndexReader()){\n        @Override\n        public CollectionStatistics collectionStatistics(String field) throws IOException {\n          CollectionStatistics cs = super.collectionStatistics(field);\n          if (cs != null) {\n            colMap.put(field, new CollectionStats(cs));\n          }\n          return cs;\n        }\n\n        @Override\n        public TermStatistics termStatistics(Term term, int docFreq, long totalTermFreq) throws IOException {\n          TermStatistics ts = super.termStatistics(term, docFreq, totalTermFreq);\n          terms.add(term);\n          statsMap.put(term.toString(), new TermStats(term.field(), ts));\n          return ts;\n        }\n      };\n      statsCollectingSearcher.createWeight(searcher.rewrite(q), ScoreMode.COMPLETE, 1);\n      for (String field : additionalFields) {\n        if (colMap.containsKey(field)) {\n          continue;\n        }\n        statsCollectingSearcher.collectionStatistics(field);\n      }\n      for (Term term : additionalTerms) {\n        statsCollectingSearcher.createWeight(searcher.rewrite(new TermQuery(term)), ScoreMode.COMPLETE, 1);\n      }\n\n      CloudDescriptor cloudDescriptor = searcher.getCore().getCoreDescriptor().getCloudDescriptor();\n      if (cloudDescriptor != null) {\n        rb.rsp.add(ShardParams.SHARD_NAME, cloudDescriptor.getShardId());\n      }\n      if (!terms.isEmpty()) {\n        rb.rsp.add(TERMS_KEY, StatsUtil.termsToEncodedString(terms));\n      }\n      if (!statsMap.isEmpty()) { //Don't add empty keys\n        String termStatsString = StatsUtil.termStatsMapToString(statsMap);\n        rb.rsp.add(TERM_STATS_KEY, termStatsString);\n        if (log.isDebugEnabled()) {\n          log.debug(\"termStats={}, terms={}, numDocs={}\", termStatsString, terms, searcher.maxDoc());\n        }\n      }\n      if (!colMap.isEmpty()) {\n        String colStatsString = StatsUtil.colStatsMapToString(colMap);\n        rb.rsp.add(COL_STATS_KEY, colStatsString);\n        if (log.isDebugEnabled()) {\n          log.debug(\"collectionStats={}, terms={}, numDocs={}\", colStatsString, terms, searcher.maxDoc());\n        }\n      }\n    } catch (IOException e) {\n      log.error(\"Error collecting local stats, query='{}'\", q, e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error collecting local stats.\", e);\n    }\n  }\n\n","sourceOld":"  @Override\n  protected void doReturnLocalStats(ResponseBuilder rb, SolrIndexSearcher searcher) {\n    Query q = rb.getQuery();\n    try {\n      Set<Term> additionalTerms = StatsUtil.termsFromEncodedString(rb.req.getParams().get(TERMS_KEY));\n      Set<String> additionalFields = StatsUtil.fieldsFromString(rb.req.getParams().get(FIELDS_KEY));\n      HashSet<Term> terms = new HashSet<>();\n      HashMap<String,TermStats> statsMap = new HashMap<>();\n      HashMap<String,CollectionStats> colMap = new HashMap<>();\n      IndexSearcher statsCollectingSearcher = new IndexSearcher(searcher.getIndexReader()){\n        @Override\n        public CollectionStatistics collectionStatistics(String field) throws IOException {\n          CollectionStatistics cs = super.collectionStatistics(field);\n          if (cs != null) {\n            colMap.put(field, new CollectionStats(cs));\n          }\n          return cs;\n        }\n\n        @Override\n        public TermStatistics termStatistics(Term term, int docFreq, long totalTermFreq) throws IOException {\n          TermStatistics ts = super.termStatistics(term, docFreq, totalTermFreq);\n          terms.add(term);\n          statsMap.put(term.toString(), new TermStats(term.field(), ts));\n          return ts;\n        }\n      };\n      statsCollectingSearcher.createWeight(searcher.rewrite(q), ScoreMode.COMPLETE, 1);\n      for (String field : additionalFields) {\n        if (colMap.containsKey(field)) {\n          continue;\n        }\n        statsCollectingSearcher.collectionStatistics(field);\n      }\n      for (Term term : additionalTerms) {\n        statsCollectingSearcher.createWeight(searcher.rewrite(new TermQuery(term)), ScoreMode.COMPLETE, 1);\n      }\n\n      CloudDescriptor cloudDescriptor = searcher.getCore().getCoreDescriptor().getCloudDescriptor();\n      if (cloudDescriptor != null) {\n        rb.rsp.add(ShardParams.SHARD_NAME, cloudDescriptor.getShardId());\n      }\n      if (!terms.isEmpty()) {\n        rb.rsp.add(TERMS_KEY, StatsUtil.termsToEncodedString(terms));\n      }\n      if (!statsMap.isEmpty()) { //Don't add empty keys\n        String termStatsString = StatsUtil.termStatsMapToString(statsMap);\n        rb.rsp.add(TERM_STATS_KEY, termStatsString);\n        if (log.isDebugEnabled()) {\n          log.debug(\"termStats={}, terms={}, numDocs={}\", termStatsString, terms, searcher.maxDoc());\n        }\n      }\n      if (!colMap.isEmpty()) {\n        String colStatsString = StatsUtil.colStatsMapToString(colMap);\n        rb.rsp.add(COL_STATS_KEY, colStatsString);\n        if (log.isDebugEnabled()) {\n          log.debug(\"collectionStats={}, terms={}, numDocs={}\", colStatsString, terms, searcher.maxDoc());\n        }\n      }\n    } catch (IOException e) {\n      log.error(\"Error collecting local stats, query='\" + q.toString() + \"'\", e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error collecting local stats.\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"54faedfb0e03479a38f5ee82f2dfaeea536e9404":["df72a23fb74bebe914e3f3972063a884327c0436"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"df72a23fb74bebe914e3f3972063a884327c0436":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["54faedfb0e03479a38f5ee82f2dfaeea536e9404"],"b0b597c65628ca9e73913a07e81691f8229bae35":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","df72a23fb74bebe914e3f3972063a884327c0436"]},"commit2Childs":{"54faedfb0e03479a38f5ee82f2dfaeea536e9404":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["df72a23fb74bebe914e3f3972063a884327c0436","b0b597c65628ca9e73913a07e81691f8229bae35"],"df72a23fb74bebe914e3f3972063a884327c0436":["54faedfb0e03479a38f5ee82f2dfaeea536e9404","b0b597c65628ca9e73913a07e81691f8229bae35"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}