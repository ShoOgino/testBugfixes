{"path":"solr/core/src/java/org/apache/solr/response/SortingResponseWriter#write(Writer,SolrQueryRequest,SolrQueryResponse).mjava","commits":[{"id":"901b27c7f633ab98e138aafb0b9c3ba22aac6b28","date":1408052893,"type":0,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/response/SortingResponseWriter#write(Writer,SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"/dev/null","sourceNew":"  public void write(Writer writer, SolrQueryRequest req, SolrQueryResponse res) throws IOException {\n    Exception e1 = res.getException();\n    if(e1 != null) {\n      e1.printStackTrace(new PrintWriter(writer));\n      return;\n    }\n    SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n    SortSpec sortSpec = info.getResponseBuilder().getSortSpec();\n\n    if(sortSpec == null) {\n      throw new IOException(new SyntaxError(\"No sort criteria was provided.\"));\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Sort sort = searcher.weightSort(sortSpec.getSort());\n\n    if(sort == null) {\n      throw new IOException(new SyntaxError(\"No sort criteria was provided.\"));\n    }\n\n    if(sort.needsScores()) {\n      throw new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"));\n    }\n\n    FixedBitSet[] sets = (FixedBitSet[])req.getContext().get(\"export\");\n    Integer th = (Integer)req.getContext().get(\"totalHits\");\n\n    if(sets == null) {\n      throw new IOException(new SyntaxError(\"xport RankQuery is required for xsort: rq={!xport}\"));\n    }\n\n    int totalHits = th.intValue();\n    SolrParams params = req.getParams();\n    String fl = params.get(\"fl\");\n\n    if(fl == null) {\n      throw new IOException(new SyntaxError(\"export field list (fl) must be specified.\"));\n    }\n\n    String[] fields = fl.split(\",\");\n\n    for(int i=0;i<fields.length; i++) {\n      if(fl.trim().equals(\"score\")) {\n        throw new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"));\n      }\n    }\n\n    FieldWriter[] fieldWriters = getFieldWriters(fields, req.getSearcher());\n    writer.write(\"{\\\"numFound\\\":\"+totalHits+\", \\\"docs\\\":[\");\n\n    //Write the data.\n    List<AtomicReaderContext> leaves = req.getSearcher().getTopReaderContext().leaves();\n    SortDoc sortDoc = getSortDoc(req.getSearcher(), sort.getSort());\n    int count = 0;\n    int queueSize = 30000;\n    SortQueue queue = new SortQueue(queueSize, sortDoc);\n    SortDoc[] outDocs = new SortDoc[queueSize];\n\n    long total = 0;\n\n    while(count < totalHits) {\n      //long begin = System.nanoTime();\n      boolean commaNeeded = false;\n      queue.reset();\n      SortDoc top = queue.top();\n      for(int i=0; i<leaves.size(); i++) {\n        sortDoc.setNextReader(leaves.get(i));\n        DocIdSetIterator it = sets[i].iterator();\n        int docId = -1;\n        while((docId = it.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          sortDoc.setValues(docId);\n          if(top.lessThan(sortDoc)) {\n            top.setValues(sortDoc);\n            top = queue.updateTop();\n          }\n        }\n      }\n\n      int outDocsIndex = -1;\n\n      for(int i=0; i<queueSize; i++) {\n        SortDoc s = queue.pop();\n        if(s.docId > -1) {\n          outDocs[++outDocsIndex] = s;\n        }\n      }\n\n     //long end = System.nanoTime();\n\n      count += (outDocsIndex+1);\n\n      for(int i=outDocsIndex; i>=0; --i) {\n        SortDoc s = outDocs[i];\n        if(commaNeeded){writer.write(',');}\n        writer.write('{');\n        writeDoc(s, leaves, fieldWriters, sets, writer);\n        writer.write('}');\n        commaNeeded = true;\n        s.reset();\n      }\n      //total+=end-begin;\n    }\n\n    //System.out.println(\"Sort Time 2:\"+Long.toString(total/1000000));\n    writer.write(\"]}\");\n    writer.flush();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["a55bf71f91aeded06b44ad1abea6666ea168b697","24e98791f8207d0adf6998892a9e9eeec5db0f40"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"87e99c34422d54f9b012110d0d3c0406fba05085","date":1408119816,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/response/SortingResponseWriter#write(Writer,SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/SortingResponseWriter#write(Writer,SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  public void write(Writer writer, SolrQueryRequest req, SolrQueryResponse res) throws IOException {\n    Exception e1 = res.getException();\n    if(e1 != null) {\n      e1.printStackTrace(new PrintWriter(writer));\n      return;\n    }\n    SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n    SortSpec sortSpec = info.getResponseBuilder().getSortSpec();\n\n    if(sortSpec == null) {\n      throw new IOException(new SyntaxError(\"No sort criteria was provided.\"));\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Sort sort = searcher.weightSort(sortSpec.getSort());\n\n    if(sort == null) {\n      throw new IOException(new SyntaxError(\"No sort criteria was provided.\"));\n    }\n\n    if(sort.needsScores()) {\n      throw new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"));\n    }\n\n    FixedBitSet[] sets = (FixedBitSet[])req.getContext().get(\"export\");\n    Integer th = (Integer)req.getContext().get(\"totalHits\");\n\n    if(sets == null) {\n      throw new IOException(new SyntaxError(\"xport RankQuery is required for xsort: rq={!xport}\"));\n    }\n\n    int totalHits = th.intValue();\n    SolrParams params = req.getParams();\n    String fl = params.get(\"fl\");\n\n    if(fl == null) {\n      throw new IOException(new SyntaxError(\"export field list (fl) must be specified.\"));\n    }\n\n    String[] fields = fl.split(\",\");\n\n    for(int i=0;i<fields.length; i++) {\n      if(fl.trim().equals(\"score\")) {\n        throw new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"));\n      }\n    }\n\n    FieldWriter[] fieldWriters = getFieldWriters(fields, req.getSearcher());\n    writer.write(\"{\\\"numFound\\\":\"+totalHits+\", \\\"docs\\\":[\");\n\n    //Write the data.\n    List<AtomicReaderContext> leaves = req.getSearcher().getTopReaderContext().leaves();\n    SortDoc sortDoc = getSortDoc(req.getSearcher(), sort.getSort());\n    int count = 0;\n    int queueSize = 30000;\n    SortQueue queue = new SortQueue(queueSize, sortDoc);\n    SortDoc[] outDocs = new SortDoc[queueSize];\n\n    long total = 0;\n\n    while(count < totalHits) {\n      //long begin = System.nanoTime();\n      boolean commaNeeded = false;\n      queue.reset();\n      SortDoc top = queue.top();\n      for(int i=0; i<leaves.size(); i++) {\n        sortDoc.setNextReader(leaves.get(i));\n        DocIdSetIterator it = sets[i].iterator();\n        int docId = -1;\n        while((docId = it.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          sortDoc.setValues(docId);\n          if(top.lessThan(sortDoc)) {\n            top.setValues(sortDoc);\n            top = queue.updateTop();\n          }\n        }\n      }\n\n      int outDocsIndex = -1;\n\n      for(int i=0; i<queueSize; i++) {\n        SortDoc s = queue.pop();\n        if(s.docId > -1) {\n          outDocs[++outDocsIndex] = s;\n        }\n      }\n\n     //long end = System.nanoTime();\n\n      count += (outDocsIndex+1);\n\n      try {\n        for(int i=outDocsIndex; i>=0; --i) {\n          SortDoc s = outDocs[i];\n          if(commaNeeded){writer.write(',');}\n          writer.write('{');\n          writeDoc(s, leaves, fieldWriters, sets, writer);\n          writer.write('}');\n          commaNeeded = true;\n          s.reset();\n        }\n      } catch(Throwable e) {\n        Throwable ex = e;\n        while(ex != null) {\n          String m = ex.getMessage();\n          if(m != null && m.contains(\"Broken pipe\")) {\n            logger.info(\"Early client disconnect during export\");\n            return;\n          }\n          ex = ex.getCause();\n        }\n\n        if(e instanceof IOException) {\n          throw ((IOException)e);\n        } else {\n          throw new IOException(e);\n        }\n      }\n    }\n\n    //System.out.println(\"Sort Time 2:\"+Long.toString(total/1000000));\n    writer.write(\"]}\");\n    writer.flush();\n  }\n\n","sourceOld":"  public void write(Writer writer, SolrQueryRequest req, SolrQueryResponse res) throws IOException {\n    Exception e1 = res.getException();\n    if(e1 != null) {\n      e1.printStackTrace(new PrintWriter(writer));\n      return;\n    }\n    SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n    SortSpec sortSpec = info.getResponseBuilder().getSortSpec();\n\n    if(sortSpec == null) {\n      throw new IOException(new SyntaxError(\"No sort criteria was provided.\"));\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Sort sort = searcher.weightSort(sortSpec.getSort());\n\n    if(sort == null) {\n      throw new IOException(new SyntaxError(\"No sort criteria was provided.\"));\n    }\n\n    if(sort.needsScores()) {\n      throw new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"));\n    }\n\n    FixedBitSet[] sets = (FixedBitSet[])req.getContext().get(\"export\");\n    Integer th = (Integer)req.getContext().get(\"totalHits\");\n\n    if(sets == null) {\n      throw new IOException(new SyntaxError(\"xport RankQuery is required for xsort: rq={!xport}\"));\n    }\n\n    int totalHits = th.intValue();\n    SolrParams params = req.getParams();\n    String fl = params.get(\"fl\");\n\n    if(fl == null) {\n      throw new IOException(new SyntaxError(\"export field list (fl) must be specified.\"));\n    }\n\n    String[] fields = fl.split(\",\");\n\n    for(int i=0;i<fields.length; i++) {\n      if(fl.trim().equals(\"score\")) {\n        throw new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"));\n      }\n    }\n\n    FieldWriter[] fieldWriters = getFieldWriters(fields, req.getSearcher());\n    writer.write(\"{\\\"numFound\\\":\"+totalHits+\", \\\"docs\\\":[\");\n\n    //Write the data.\n    List<AtomicReaderContext> leaves = req.getSearcher().getTopReaderContext().leaves();\n    SortDoc sortDoc = getSortDoc(req.getSearcher(), sort.getSort());\n    int count = 0;\n    int queueSize = 30000;\n    SortQueue queue = new SortQueue(queueSize, sortDoc);\n    SortDoc[] outDocs = new SortDoc[queueSize];\n\n    long total = 0;\n\n    while(count < totalHits) {\n      //long begin = System.nanoTime();\n      boolean commaNeeded = false;\n      queue.reset();\n      SortDoc top = queue.top();\n      for(int i=0; i<leaves.size(); i++) {\n        sortDoc.setNextReader(leaves.get(i));\n        DocIdSetIterator it = sets[i].iterator();\n        int docId = -1;\n        while((docId = it.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          sortDoc.setValues(docId);\n          if(top.lessThan(sortDoc)) {\n            top.setValues(sortDoc);\n            top = queue.updateTop();\n          }\n        }\n      }\n\n      int outDocsIndex = -1;\n\n      for(int i=0; i<queueSize; i++) {\n        SortDoc s = queue.pop();\n        if(s.docId > -1) {\n          outDocs[++outDocsIndex] = s;\n        }\n      }\n\n     //long end = System.nanoTime();\n\n      count += (outDocsIndex+1);\n\n      for(int i=outDocsIndex; i>=0; --i) {\n        SortDoc s = outDocs[i];\n        if(commaNeeded){writer.write(',');}\n        writer.write('{');\n        writeDoc(s, leaves, fieldWriters, sets, writer);\n        writer.write('}');\n        commaNeeded = true;\n        s.reset();\n      }\n      //total+=end-begin;\n    }\n\n    //System.out.println(\"Sort Time 2:\"+Long.toString(total/1000000));\n    writer.write(\"]}\");\n    writer.flush();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cefbebfd2697abbd58b1da2de54fee000fee5ac8","date":1408711239,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/response/SortingResponseWriter#write(Writer,SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/SortingResponseWriter#write(Writer,SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  public void write(Writer writer, SolrQueryRequest req, SolrQueryResponse res) throws IOException {\n    Exception e1 = res.getException();\n    if(e1 != null) {\n      if(!(e1 instanceof IgnoreException)) {\n        e1.printStackTrace(new PrintWriter(writer));\n      }\n      return;\n    }\n    SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n    SortSpec sortSpec = info.getResponseBuilder().getSortSpec();\n\n    if(sortSpec == null) {\n      throw new IOException(new SyntaxError(\"No sort criteria was provided.\"));\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Sort sort = searcher.weightSort(sortSpec.getSort());\n\n    if(sort == null) {\n      throw new IOException(new SyntaxError(\"No sort criteria was provided.\"));\n    }\n\n    if(sort.needsScores()) {\n      throw new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"));\n    }\n\n    FixedBitSet[] sets = (FixedBitSet[])req.getContext().get(\"export\");\n    Integer th = (Integer)req.getContext().get(\"totalHits\");\n\n    if(sets == null) {\n      throw new IOException(new SyntaxError(\"xport RankQuery is required for xsort: rq={!xport}\"));\n    }\n\n    int totalHits = th.intValue();\n    SolrParams params = req.getParams();\n    String fl = params.get(\"fl\");\n\n    if(fl == null) {\n      throw new IOException(new SyntaxError(\"export field list (fl) must be specified.\"));\n    }\n\n    String[] fields = fl.split(\",\");\n\n    for(int i=0;i<fields.length; i++) {\n      if(fl.trim().equals(\"score\")) {\n        throw new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"));\n      }\n    }\n\n    FieldWriter[] fieldWriters = getFieldWriters(fields, req.getSearcher());\n    writer.write(\"{\\\"numFound\\\":\"+totalHits+\", \\\"docs\\\":[\");\n\n    //Write the data.\n    List<AtomicReaderContext> leaves = req.getSearcher().getTopReaderContext().leaves();\n    SortDoc sortDoc = getSortDoc(req.getSearcher(), sort.getSort());\n    int count = 0;\n    int queueSize = 30000;\n    SortQueue queue = new SortQueue(queueSize, sortDoc);\n    SortDoc[] outDocs = new SortDoc[queueSize];\n\n    long total = 0;\n\n    while(count < totalHits) {\n      //long begin = System.nanoTime();\n      boolean commaNeeded = false;\n      queue.reset();\n      SortDoc top = queue.top();\n      for(int i=0; i<leaves.size(); i++) {\n        sortDoc.setNextReader(leaves.get(i));\n        DocIdSetIterator it = sets[i].iterator();\n        int docId = -1;\n        while((docId = it.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          sortDoc.setValues(docId);\n          if(top.lessThan(sortDoc)) {\n            top.setValues(sortDoc);\n            top = queue.updateTop();\n          }\n        }\n      }\n\n      int outDocsIndex = -1;\n\n      for(int i=0; i<queueSize; i++) {\n        SortDoc s = queue.pop();\n        if(s.docId > -1) {\n          outDocs[++outDocsIndex] = s;\n        }\n      }\n\n     //long end = System.nanoTime();\n\n      count += (outDocsIndex+1);\n\n      try {\n        for(int i=outDocsIndex; i>=0; --i) {\n          SortDoc s = outDocs[i];\n          if(commaNeeded){writer.write(',');}\n          writer.write('{');\n          writeDoc(s, leaves, fieldWriters, sets, writer);\n          writer.write('}');\n          commaNeeded = true;\n          s.reset();\n        }\n      } catch(Throwable e) {\n        Throwable ex = e;\n        while(ex != null) {\n          String m = ex.getMessage();\n          if(m != null && m.contains(\"Broken pipe\")) {\n            throw new IgnoreException();\n          }\n          ex = ex.getCause();\n        }\n\n        if(e instanceof IOException) {\n          throw ((IOException)e);\n        } else {\n          throw new IOException(e);\n        }\n      }\n    }\n\n    //System.out.println(\"Sort Time 2:\"+Long.toString(total/1000000));\n    writer.write(\"]}\");\n    writer.flush();\n  }\n\n","sourceOld":"  public void write(Writer writer, SolrQueryRequest req, SolrQueryResponse res) throws IOException {\n    Exception e1 = res.getException();\n    if(e1 != null) {\n      e1.printStackTrace(new PrintWriter(writer));\n      return;\n    }\n    SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n    SortSpec sortSpec = info.getResponseBuilder().getSortSpec();\n\n    if(sortSpec == null) {\n      throw new IOException(new SyntaxError(\"No sort criteria was provided.\"));\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Sort sort = searcher.weightSort(sortSpec.getSort());\n\n    if(sort == null) {\n      throw new IOException(new SyntaxError(\"No sort criteria was provided.\"));\n    }\n\n    if(sort.needsScores()) {\n      throw new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"));\n    }\n\n    FixedBitSet[] sets = (FixedBitSet[])req.getContext().get(\"export\");\n    Integer th = (Integer)req.getContext().get(\"totalHits\");\n\n    if(sets == null) {\n      throw new IOException(new SyntaxError(\"xport RankQuery is required for xsort: rq={!xport}\"));\n    }\n\n    int totalHits = th.intValue();\n    SolrParams params = req.getParams();\n    String fl = params.get(\"fl\");\n\n    if(fl == null) {\n      throw new IOException(new SyntaxError(\"export field list (fl) must be specified.\"));\n    }\n\n    String[] fields = fl.split(\",\");\n\n    for(int i=0;i<fields.length; i++) {\n      if(fl.trim().equals(\"score\")) {\n        throw new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"));\n      }\n    }\n\n    FieldWriter[] fieldWriters = getFieldWriters(fields, req.getSearcher());\n    writer.write(\"{\\\"numFound\\\":\"+totalHits+\", \\\"docs\\\":[\");\n\n    //Write the data.\n    List<AtomicReaderContext> leaves = req.getSearcher().getTopReaderContext().leaves();\n    SortDoc sortDoc = getSortDoc(req.getSearcher(), sort.getSort());\n    int count = 0;\n    int queueSize = 30000;\n    SortQueue queue = new SortQueue(queueSize, sortDoc);\n    SortDoc[] outDocs = new SortDoc[queueSize];\n\n    long total = 0;\n\n    while(count < totalHits) {\n      //long begin = System.nanoTime();\n      boolean commaNeeded = false;\n      queue.reset();\n      SortDoc top = queue.top();\n      for(int i=0; i<leaves.size(); i++) {\n        sortDoc.setNextReader(leaves.get(i));\n        DocIdSetIterator it = sets[i].iterator();\n        int docId = -1;\n        while((docId = it.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          sortDoc.setValues(docId);\n          if(top.lessThan(sortDoc)) {\n            top.setValues(sortDoc);\n            top = queue.updateTop();\n          }\n        }\n      }\n\n      int outDocsIndex = -1;\n\n      for(int i=0; i<queueSize; i++) {\n        SortDoc s = queue.pop();\n        if(s.docId > -1) {\n          outDocs[++outDocsIndex] = s;\n        }\n      }\n\n     //long end = System.nanoTime();\n\n      count += (outDocsIndex+1);\n\n      try {\n        for(int i=outDocsIndex; i>=0; --i) {\n          SortDoc s = outDocs[i];\n          if(commaNeeded){writer.write(',');}\n          writer.write('{');\n          writeDoc(s, leaves, fieldWriters, sets, writer);\n          writer.write('}');\n          commaNeeded = true;\n          s.reset();\n        }\n      } catch(Throwable e) {\n        Throwable ex = e;\n        while(ex != null) {\n          String m = ex.getMessage();\n          if(m != null && m.contains(\"Broken pipe\")) {\n            logger.info(\"Early client disconnect during export\");\n            return;\n          }\n          ex = ex.getCause();\n        }\n\n        if(e instanceof IOException) {\n          throw ((IOException)e);\n        } else {\n          throw new IOException(e);\n        }\n      }\n    }\n\n    //System.out.println(\"Sort Time 2:\"+Long.toString(total/1000000));\n    writer.write(\"]}\");\n    writer.flush();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c9fb5f46e264daf5ba3860defe623a89d202dd87","date":1411516315,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/response/SortingResponseWriter#write(Writer,SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/SortingResponseWriter#write(Writer,SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  public void write(Writer writer, SolrQueryRequest req, SolrQueryResponse res) throws IOException {\n    Exception e1 = res.getException();\n    if(e1 != null) {\n      if(!(e1 instanceof IgnoreException)) {\n        e1.printStackTrace(new PrintWriter(writer));\n      }\n      return;\n    }\n    SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n    SortSpec sortSpec = info.getResponseBuilder().getSortSpec();\n\n    if(sortSpec == null) {\n      throw new IOException(new SyntaxError(\"No sort criteria was provided.\"));\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Sort sort = searcher.weightSort(sortSpec.getSort());\n\n    if(sort == null) {\n      throw new IOException(new SyntaxError(\"No sort criteria was provided.\"));\n    }\n\n    if(sort.needsScores()) {\n      throw new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"));\n    }\n\n    FixedBitSet[] sets = (FixedBitSet[])req.getContext().get(\"export\");\n    Integer th = (Integer)req.getContext().get(\"totalHits\");\n\n    if(sets == null) {\n      throw new IOException(new SyntaxError(\"xport RankQuery is required for xsort: rq={!xport}\"));\n    }\n\n    int totalHits = th.intValue();\n    SolrParams params = req.getParams();\n    String fl = params.get(\"fl\");\n\n    if(fl == null) {\n      throw new IOException(new SyntaxError(\"export field list (fl) must be specified.\"));\n    }\n\n    String[] fields = fl.split(\",\");\n\n    for(int i=0;i<fields.length; i++) {\n      if(fl.trim().equals(\"score\")) {\n        throw new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"));\n      }\n    }\n\n    FieldWriter[] fieldWriters = getFieldWriters(fields, req.getSearcher());\n    writer.write(\"{\\\"numFound\\\":\"+totalHits+\", \\\"docs\\\":[\");\n\n    //Write the data.\n    List<LeafReaderContext> leaves = req.getSearcher().getTopReaderContext().leaves();\n    SortDoc sortDoc = getSortDoc(req.getSearcher(), sort.getSort());\n    int count = 0;\n    int queueSize = 30000;\n    SortQueue queue = new SortQueue(queueSize, sortDoc);\n    SortDoc[] outDocs = new SortDoc[queueSize];\n\n    long total = 0;\n\n    while(count < totalHits) {\n      //long begin = System.nanoTime();\n      boolean commaNeeded = false;\n      queue.reset();\n      SortDoc top = queue.top();\n      for(int i=0; i<leaves.size(); i++) {\n        sortDoc.setNextReader(leaves.get(i));\n        DocIdSetIterator it = sets[i].iterator();\n        int docId = -1;\n        while((docId = it.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          sortDoc.setValues(docId);\n          if(top.lessThan(sortDoc)) {\n            top.setValues(sortDoc);\n            top = queue.updateTop();\n          }\n        }\n      }\n\n      int outDocsIndex = -1;\n\n      for(int i=0; i<queueSize; i++) {\n        SortDoc s = queue.pop();\n        if(s.docId > -1) {\n          outDocs[++outDocsIndex] = s;\n        }\n      }\n\n     //long end = System.nanoTime();\n\n      count += (outDocsIndex+1);\n\n      try {\n        for(int i=outDocsIndex; i>=0; --i) {\n          SortDoc s = outDocs[i];\n          if(commaNeeded){writer.write(',');}\n          writer.write('{');\n          writeDoc(s, leaves, fieldWriters, sets, writer);\n          writer.write('}');\n          commaNeeded = true;\n          s.reset();\n        }\n      } catch(Throwable e) {\n        Throwable ex = e;\n        while(ex != null) {\n          String m = ex.getMessage();\n          if(m != null && m.contains(\"Broken pipe\")) {\n            throw new IgnoreException();\n          }\n          ex = ex.getCause();\n        }\n\n        if(e instanceof IOException) {\n          throw ((IOException)e);\n        } else {\n          throw new IOException(e);\n        }\n      }\n    }\n\n    //System.out.println(\"Sort Time 2:\"+Long.toString(total/1000000));\n    writer.write(\"]}\");\n    writer.flush();\n  }\n\n","sourceOld":"  public void write(Writer writer, SolrQueryRequest req, SolrQueryResponse res) throws IOException {\n    Exception e1 = res.getException();\n    if(e1 != null) {\n      if(!(e1 instanceof IgnoreException)) {\n        e1.printStackTrace(new PrintWriter(writer));\n      }\n      return;\n    }\n    SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n    SortSpec sortSpec = info.getResponseBuilder().getSortSpec();\n\n    if(sortSpec == null) {\n      throw new IOException(new SyntaxError(\"No sort criteria was provided.\"));\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Sort sort = searcher.weightSort(sortSpec.getSort());\n\n    if(sort == null) {\n      throw new IOException(new SyntaxError(\"No sort criteria was provided.\"));\n    }\n\n    if(sort.needsScores()) {\n      throw new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"));\n    }\n\n    FixedBitSet[] sets = (FixedBitSet[])req.getContext().get(\"export\");\n    Integer th = (Integer)req.getContext().get(\"totalHits\");\n\n    if(sets == null) {\n      throw new IOException(new SyntaxError(\"xport RankQuery is required for xsort: rq={!xport}\"));\n    }\n\n    int totalHits = th.intValue();\n    SolrParams params = req.getParams();\n    String fl = params.get(\"fl\");\n\n    if(fl == null) {\n      throw new IOException(new SyntaxError(\"export field list (fl) must be specified.\"));\n    }\n\n    String[] fields = fl.split(\",\");\n\n    for(int i=0;i<fields.length; i++) {\n      if(fl.trim().equals(\"score\")) {\n        throw new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"));\n      }\n    }\n\n    FieldWriter[] fieldWriters = getFieldWriters(fields, req.getSearcher());\n    writer.write(\"{\\\"numFound\\\":\"+totalHits+\", \\\"docs\\\":[\");\n\n    //Write the data.\n    List<AtomicReaderContext> leaves = req.getSearcher().getTopReaderContext().leaves();\n    SortDoc sortDoc = getSortDoc(req.getSearcher(), sort.getSort());\n    int count = 0;\n    int queueSize = 30000;\n    SortQueue queue = new SortQueue(queueSize, sortDoc);\n    SortDoc[] outDocs = new SortDoc[queueSize];\n\n    long total = 0;\n\n    while(count < totalHits) {\n      //long begin = System.nanoTime();\n      boolean commaNeeded = false;\n      queue.reset();\n      SortDoc top = queue.top();\n      for(int i=0; i<leaves.size(); i++) {\n        sortDoc.setNextReader(leaves.get(i));\n        DocIdSetIterator it = sets[i].iterator();\n        int docId = -1;\n        while((docId = it.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          sortDoc.setValues(docId);\n          if(top.lessThan(sortDoc)) {\n            top.setValues(sortDoc);\n            top = queue.updateTop();\n          }\n        }\n      }\n\n      int outDocsIndex = -1;\n\n      for(int i=0; i<queueSize; i++) {\n        SortDoc s = queue.pop();\n        if(s.docId > -1) {\n          outDocs[++outDocsIndex] = s;\n        }\n      }\n\n     //long end = System.nanoTime();\n\n      count += (outDocsIndex+1);\n\n      try {\n        for(int i=outDocsIndex; i>=0; --i) {\n          SortDoc s = outDocs[i];\n          if(commaNeeded){writer.write(',');}\n          writer.write('{');\n          writeDoc(s, leaves, fieldWriters, sets, writer);\n          writer.write('}');\n          commaNeeded = true;\n          s.reset();\n        }\n      } catch(Throwable e) {\n        Throwable ex = e;\n        while(ex != null) {\n          String m = ex.getMessage();\n          if(m != null && m.contains(\"Broken pipe\")) {\n            throw new IgnoreException();\n          }\n          ex = ex.getCause();\n        }\n\n        if(e instanceof IOException) {\n          throw ((IOException)e);\n        } else {\n          throw new IOException(e);\n        }\n      }\n    }\n\n    //System.out.println(\"Sort Time 2:\"+Long.toString(total/1000000));\n    writer.write(\"]}\");\n    writer.flush();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"80c55596a764e2d397e982828e75fcac5ce430a0","date":1413987559,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/response/SortingResponseWriter#write(Writer,SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/SortingResponseWriter#write(Writer,SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  public void write(Writer writer, SolrQueryRequest req, SolrQueryResponse res) throws IOException {\n    Exception e1 = res.getException();\n    if(e1 != null) {\n      if(!(e1 instanceof IgnoreException)) {\n        e1.printStackTrace(new PrintWriter(writer));\n      }\n      return;\n    }\n    SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n    SortSpec sortSpec = info.getResponseBuilder().getSortSpec();\n\n    if(sortSpec == null) {\n      throw new IOException(new SyntaxError(\"No sort criteria was provided.\"));\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Sort sort = searcher.weightSort(sortSpec.getSort());\n\n    if(sort == null) {\n      throw new IOException(new SyntaxError(\"No sort criteria was provided.\"));\n    }\n\n    if(sort.needsScores()) {\n      throw new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"));\n    }\n\n    FixedBitSet[] sets = (FixedBitSet[])req.getContext().get(\"export\");\n    Integer th = (Integer)req.getContext().get(\"totalHits\");\n\n    if(sets == null) {\n      throw new IOException(new SyntaxError(\"xport RankQuery is required for xsort: rq={!xport}\"));\n    }\n\n    int totalHits = th.intValue();\n    SolrParams params = req.getParams();\n    String fl = params.get(\"fl\");\n\n    if(fl == null) {\n      throw new IOException(new SyntaxError(\"export field list (fl) must be specified.\"));\n    }\n\n    String[] fields = fl.split(\",\");\n\n    for(int i=0;i<fields.length; i++) {\n      if(fl.trim().equals(\"score\")) {\n        throw new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"));\n      }\n    }\n\n    FieldWriter[] fieldWriters = getFieldWriters(fields, req.getSearcher());\n    writer.write(\"{\\\"numFound\\\":\"+totalHits+\", \\\"docs\\\":[\");\n\n    //Write the data.\n    List<LeafReaderContext> leaves = req.getSearcher().getTopReaderContext().leaves();\n    SortDoc sortDoc = getSortDoc(req.getSearcher(), sort.getSort());\n    int count = 0;\n    int queueSize = 30000;\n    SortQueue queue = new SortQueue(queueSize, sortDoc);\n    SortDoc[] outDocs = new SortDoc[queueSize];\n\n    while(count < totalHits) {\n      //long begin = System.nanoTime();\n      boolean commaNeeded = false;\n      queue.reset();\n      SortDoc top = queue.top();\n      for(int i=0; i<leaves.size(); i++) {\n        sortDoc.setNextReader(leaves.get(i));\n        DocIdSetIterator it = new FixedBitSetIterator(sets[i], 0); // cost is not useful here\n        int docId = -1;\n        while((docId = it.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          sortDoc.setValues(docId);\n          if(top.lessThan(sortDoc)) {\n            top.setValues(sortDoc);\n            top = queue.updateTop();\n          }\n        }\n      }\n\n      int outDocsIndex = -1;\n\n      for(int i=0; i<queueSize; i++) {\n        SortDoc s = queue.pop();\n        if(s.docId > -1) {\n          outDocs[++outDocsIndex] = s;\n        }\n      }\n\n     //long end = System.nanoTime();\n\n      count += (outDocsIndex+1);\n\n      try {\n        for(int i=outDocsIndex; i>=0; --i) {\n          SortDoc s = outDocs[i];\n          if(commaNeeded){writer.write(',');}\n          writer.write('{');\n          writeDoc(s, leaves, fieldWriters, sets, writer);\n          writer.write('}');\n          commaNeeded = true;\n          s.reset();\n        }\n      } catch(Throwable e) {\n        Throwable ex = e;\n        while(ex != null) {\n          String m = ex.getMessage();\n          if(m != null && m.contains(\"Broken pipe\")) {\n            throw new IgnoreException();\n          }\n          ex = ex.getCause();\n        }\n\n        if(e instanceof IOException) {\n          throw ((IOException)e);\n        } else {\n          throw new IOException(e);\n        }\n      }\n    }\n\n    //System.out.println(\"Sort Time 2:\"+Long.toString(total/1000000));\n    writer.write(\"]}\");\n    writer.flush();\n  }\n\n","sourceOld":"  public void write(Writer writer, SolrQueryRequest req, SolrQueryResponse res) throws IOException {\n    Exception e1 = res.getException();\n    if(e1 != null) {\n      if(!(e1 instanceof IgnoreException)) {\n        e1.printStackTrace(new PrintWriter(writer));\n      }\n      return;\n    }\n    SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n    SortSpec sortSpec = info.getResponseBuilder().getSortSpec();\n\n    if(sortSpec == null) {\n      throw new IOException(new SyntaxError(\"No sort criteria was provided.\"));\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Sort sort = searcher.weightSort(sortSpec.getSort());\n\n    if(sort == null) {\n      throw new IOException(new SyntaxError(\"No sort criteria was provided.\"));\n    }\n\n    if(sort.needsScores()) {\n      throw new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"));\n    }\n\n    FixedBitSet[] sets = (FixedBitSet[])req.getContext().get(\"export\");\n    Integer th = (Integer)req.getContext().get(\"totalHits\");\n\n    if(sets == null) {\n      throw new IOException(new SyntaxError(\"xport RankQuery is required for xsort: rq={!xport}\"));\n    }\n\n    int totalHits = th.intValue();\n    SolrParams params = req.getParams();\n    String fl = params.get(\"fl\");\n\n    if(fl == null) {\n      throw new IOException(new SyntaxError(\"export field list (fl) must be specified.\"));\n    }\n\n    String[] fields = fl.split(\",\");\n\n    for(int i=0;i<fields.length; i++) {\n      if(fl.trim().equals(\"score\")) {\n        throw new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"));\n      }\n    }\n\n    FieldWriter[] fieldWriters = getFieldWriters(fields, req.getSearcher());\n    writer.write(\"{\\\"numFound\\\":\"+totalHits+\", \\\"docs\\\":[\");\n\n    //Write the data.\n    List<LeafReaderContext> leaves = req.getSearcher().getTopReaderContext().leaves();\n    SortDoc sortDoc = getSortDoc(req.getSearcher(), sort.getSort());\n    int count = 0;\n    int queueSize = 30000;\n    SortQueue queue = new SortQueue(queueSize, sortDoc);\n    SortDoc[] outDocs = new SortDoc[queueSize];\n\n    long total = 0;\n\n    while(count < totalHits) {\n      //long begin = System.nanoTime();\n      boolean commaNeeded = false;\n      queue.reset();\n      SortDoc top = queue.top();\n      for(int i=0; i<leaves.size(); i++) {\n        sortDoc.setNextReader(leaves.get(i));\n        DocIdSetIterator it = sets[i].iterator();\n        int docId = -1;\n        while((docId = it.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          sortDoc.setValues(docId);\n          if(top.lessThan(sortDoc)) {\n            top.setValues(sortDoc);\n            top = queue.updateTop();\n          }\n        }\n      }\n\n      int outDocsIndex = -1;\n\n      for(int i=0; i<queueSize; i++) {\n        SortDoc s = queue.pop();\n        if(s.docId > -1) {\n          outDocs[++outDocsIndex] = s;\n        }\n      }\n\n     //long end = System.nanoTime();\n\n      count += (outDocsIndex+1);\n\n      try {\n        for(int i=outDocsIndex; i>=0; --i) {\n          SortDoc s = outDocs[i];\n          if(commaNeeded){writer.write(',');}\n          writer.write('{');\n          writeDoc(s, leaves, fieldWriters, sets, writer);\n          writer.write('}');\n          commaNeeded = true;\n          s.reset();\n        }\n      } catch(Throwable e) {\n        Throwable ex = e;\n        while(ex != null) {\n          String m = ex.getMessage();\n          if(m != null && m.contains(\"Broken pipe\")) {\n            throw new IgnoreException();\n          }\n          ex = ex.getCause();\n        }\n\n        if(e instanceof IOException) {\n          throw ((IOException)e);\n        } else {\n          throw new IOException(e);\n        }\n      }\n    }\n\n    //System.out.println(\"Sort Time 2:\"+Long.toString(total/1000000));\n    writer.write(\"]}\");\n    writer.flush();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0abcec02c9851c46c70a75bd42fb6e4d5348ac9e","date":1414135939,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/response/SortingResponseWriter#write(Writer,SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/SortingResponseWriter#write(Writer,SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  public void write(Writer writer, SolrQueryRequest req, SolrQueryResponse res) throws IOException {\n    Exception e1 = res.getException();\n    if(e1 != null) {\n      if(!(e1 instanceof IgnoreException)) {\n        e1.printStackTrace(new PrintWriter(writer));\n      }\n      return;\n    }\n    SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n    SortSpec sortSpec = info.getResponseBuilder().getSortSpec();\n\n    if(sortSpec == null) {\n      throw new IOException(new SyntaxError(\"No sort criteria was provided.\"));\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Sort sort = searcher.weightSort(sortSpec.getSort());\n\n    if(sort == null) {\n      throw new IOException(new SyntaxError(\"No sort criteria was provided.\"));\n    }\n\n    if(sort.needsScores()) {\n      throw new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"));\n    }\n\n    FixedBitSet[] sets = (FixedBitSet[])req.getContext().get(\"export\");\n    Integer th = (Integer)req.getContext().get(\"totalHits\");\n\n    if(sets == null) {\n      throw new IOException(new SyntaxError(\"xport RankQuery is required for xsort: rq={!xport}\"));\n    }\n\n    int totalHits = th.intValue();\n    SolrParams params = req.getParams();\n    String fl = params.get(\"fl\");\n\n    if(fl == null) {\n      throw new IOException(new SyntaxError(\"export field list (fl) must be specified.\"));\n    }\n\n    String[] fields = fl.split(\",\");\n\n    for(int i=0;i<fields.length; i++) {\n      if(fl.trim().equals(\"score\")) {\n        throw new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"));\n      }\n    }\n\n    FieldWriter[] fieldWriters = getFieldWriters(fields, req.getSearcher());\n    writer.write(\"{\\\"numFound\\\":\"+totalHits+\", \\\"docs\\\":[\");\n\n    //Write the data.\n    List<LeafReaderContext> leaves = req.getSearcher().getTopReaderContext().leaves();\n    SortDoc sortDoc = getSortDoc(req.getSearcher(), sort.getSort());\n    int count = 0;\n    int queueSize = 30000;\n    SortQueue queue = new SortQueue(queueSize, sortDoc);\n    SortDoc[] outDocs = new SortDoc[queueSize];\n\n    while(count < totalHits) {\n      //long begin = System.nanoTime();\n      boolean commaNeeded = false;\n      queue.reset();\n      SortDoc top = queue.top();\n      for(int i=0; i<leaves.size(); i++) {\n        sortDoc.setNextReader(leaves.get(i));\n        DocIdSetIterator it = new BitSetIterator(sets[i], 0); // cost is not useful here\n        int docId = -1;\n        while((docId = it.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          sortDoc.setValues(docId);\n          if(top.lessThan(sortDoc)) {\n            top.setValues(sortDoc);\n            top = queue.updateTop();\n          }\n        }\n      }\n\n      int outDocsIndex = -1;\n\n      for(int i=0; i<queueSize; i++) {\n        SortDoc s = queue.pop();\n        if(s.docId > -1) {\n          outDocs[++outDocsIndex] = s;\n        }\n      }\n\n     //long end = System.nanoTime();\n\n      count += (outDocsIndex+1);\n\n      try {\n        for(int i=outDocsIndex; i>=0; --i) {\n          SortDoc s = outDocs[i];\n          if(commaNeeded){writer.write(',');}\n          writer.write('{');\n          writeDoc(s, leaves, fieldWriters, sets, writer);\n          writer.write('}');\n          commaNeeded = true;\n          s.reset();\n        }\n      } catch(Throwable e) {\n        Throwable ex = e;\n        while(ex != null) {\n          String m = ex.getMessage();\n          if(m != null && m.contains(\"Broken pipe\")) {\n            throw new IgnoreException();\n          }\n          ex = ex.getCause();\n        }\n\n        if(e instanceof IOException) {\n          throw ((IOException)e);\n        } else {\n          throw new IOException(e);\n        }\n      }\n    }\n\n    //System.out.println(\"Sort Time 2:\"+Long.toString(total/1000000));\n    writer.write(\"]}\");\n    writer.flush();\n  }\n\n","sourceOld":"  public void write(Writer writer, SolrQueryRequest req, SolrQueryResponse res) throws IOException {\n    Exception e1 = res.getException();\n    if(e1 != null) {\n      if(!(e1 instanceof IgnoreException)) {\n        e1.printStackTrace(new PrintWriter(writer));\n      }\n      return;\n    }\n    SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n    SortSpec sortSpec = info.getResponseBuilder().getSortSpec();\n\n    if(sortSpec == null) {\n      throw new IOException(new SyntaxError(\"No sort criteria was provided.\"));\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Sort sort = searcher.weightSort(sortSpec.getSort());\n\n    if(sort == null) {\n      throw new IOException(new SyntaxError(\"No sort criteria was provided.\"));\n    }\n\n    if(sort.needsScores()) {\n      throw new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"));\n    }\n\n    FixedBitSet[] sets = (FixedBitSet[])req.getContext().get(\"export\");\n    Integer th = (Integer)req.getContext().get(\"totalHits\");\n\n    if(sets == null) {\n      throw new IOException(new SyntaxError(\"xport RankQuery is required for xsort: rq={!xport}\"));\n    }\n\n    int totalHits = th.intValue();\n    SolrParams params = req.getParams();\n    String fl = params.get(\"fl\");\n\n    if(fl == null) {\n      throw new IOException(new SyntaxError(\"export field list (fl) must be specified.\"));\n    }\n\n    String[] fields = fl.split(\",\");\n\n    for(int i=0;i<fields.length; i++) {\n      if(fl.trim().equals(\"score\")) {\n        throw new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"));\n      }\n    }\n\n    FieldWriter[] fieldWriters = getFieldWriters(fields, req.getSearcher());\n    writer.write(\"{\\\"numFound\\\":\"+totalHits+\", \\\"docs\\\":[\");\n\n    //Write the data.\n    List<LeafReaderContext> leaves = req.getSearcher().getTopReaderContext().leaves();\n    SortDoc sortDoc = getSortDoc(req.getSearcher(), sort.getSort());\n    int count = 0;\n    int queueSize = 30000;\n    SortQueue queue = new SortQueue(queueSize, sortDoc);\n    SortDoc[] outDocs = new SortDoc[queueSize];\n\n    while(count < totalHits) {\n      //long begin = System.nanoTime();\n      boolean commaNeeded = false;\n      queue.reset();\n      SortDoc top = queue.top();\n      for(int i=0; i<leaves.size(); i++) {\n        sortDoc.setNextReader(leaves.get(i));\n        DocIdSetIterator it = new FixedBitSetIterator(sets[i], 0); // cost is not useful here\n        int docId = -1;\n        while((docId = it.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          sortDoc.setValues(docId);\n          if(top.lessThan(sortDoc)) {\n            top.setValues(sortDoc);\n            top = queue.updateTop();\n          }\n        }\n      }\n\n      int outDocsIndex = -1;\n\n      for(int i=0; i<queueSize; i++) {\n        SortDoc s = queue.pop();\n        if(s.docId > -1) {\n          outDocs[++outDocsIndex] = s;\n        }\n      }\n\n     //long end = System.nanoTime();\n\n      count += (outDocsIndex+1);\n\n      try {\n        for(int i=outDocsIndex; i>=0; --i) {\n          SortDoc s = outDocs[i];\n          if(commaNeeded){writer.write(',');}\n          writer.write('{');\n          writeDoc(s, leaves, fieldWriters, sets, writer);\n          writer.write('}');\n          commaNeeded = true;\n          s.reset();\n        }\n      } catch(Throwable e) {\n        Throwable ex = e;\n        while(ex != null) {\n          String m = ex.getMessage();\n          if(m != null && m.contains(\"Broken pipe\")) {\n            throw new IgnoreException();\n          }\n          ex = ex.getCause();\n        }\n\n        if(e instanceof IOException) {\n          throw ((IOException)e);\n        } else {\n          throw new IOException(e);\n        }\n      }\n    }\n\n    //System.out.println(\"Sort Time 2:\"+Long.toString(total/1000000));\n    writer.write(\"]}\");\n    writer.flush();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"26d51e4b5ed27629c3d8933c24bc8741b4e04412","date":1415225907,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/response/SortingResponseWriter#write(Writer,SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/SortingResponseWriter#write(Writer,SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  public void write(Writer writer, SolrQueryRequest req, SolrQueryResponse res) throws IOException {\n    Exception e1 = res.getException();\n    if(e1 != null) {\n      if(!(e1 instanceof IgnoreException)) {\n        e1.printStackTrace(new PrintWriter(writer));\n      }\n      return;\n    }\n    SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n    SortSpec sortSpec = info.getResponseBuilder().getSortSpec();\n\n    if(sortSpec == null) {\n      throw new IOException(new SyntaxError(\"No sort criteria was provided.\"));\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Sort sort = searcher.weightSort(sortSpec.getSort());\n\n    if(sort == null) {\n      throw new IOException(new SyntaxError(\"No sort criteria was provided.\"));\n    }\n\n    if(sort.needsScores()) {\n      throw new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"));\n    }\n\n    FixedBitSet[] sets = (FixedBitSet[])req.getContext().get(\"export\");\n    Integer th = (Integer)req.getContext().get(\"totalHits\");\n\n    if(sets == null) {\n      throw new IOException(new SyntaxError(\"xport RankQuery is required for xsort: rq={!xport}\"));\n    }\n\n    int totalHits = th.intValue();\n    SolrParams params = req.getParams();\n    String fl = params.get(\"fl\");\n\n    if(fl == null) {\n      throw new IOException(new SyntaxError(\"export field list (fl) must be specified.\"));\n    }\n\n    String[] fields = fl.split(\",\");\n\n    for(int i=0;i<fields.length; i++) {\n      if(fl.trim().equals(\"score\")) {\n        throw new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"));\n      }\n    }\n\n    FieldWriter[] fieldWriters = getFieldWriters(fields, req.getSearcher());\n    writer.write(\"{\\\"responseHeader\\\": {\\\"status\\\": 0}, \\\"response\\\":{\\\"numFound\\\":\"+totalHits+\", \\\"docs\\\":[\");\n\n    //Write the data.\n    List<LeafReaderContext> leaves = req.getSearcher().getTopReaderContext().leaves();\n    SortDoc sortDoc = getSortDoc(req.getSearcher(), sort.getSort());\n    int count = 0;\n    int queueSize = 30000;\n    SortQueue queue = new SortQueue(queueSize, sortDoc);\n    SortDoc[] outDocs = new SortDoc[queueSize];\n\n    boolean commaNeeded = false;\n    while(count < totalHits) {\n      //long begin = System.nanoTime();\n      queue.reset();\n      SortDoc top = queue.top();\n      for(int i=0; i<leaves.size(); i++) {\n        sortDoc.setNextReader(leaves.get(i));\n        DocIdSetIterator it = new BitSetIterator(sets[i], 0); // cost is not useful here\n        int docId = -1;\n        while((docId = it.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          sortDoc.setValues(docId);\n          if(top.lessThan(sortDoc)) {\n            top.setValues(sortDoc);\n            top = queue.updateTop();\n          }\n        }\n      }\n\n      int outDocsIndex = -1;\n\n      for(int i=0; i<queueSize; i++) {\n        SortDoc s = queue.pop();\n        if(s.docId > -1) {\n          outDocs[++outDocsIndex] = s;\n        }\n      }\n\n     //long end = System.nanoTime();\n\n      count += (outDocsIndex+1);\n\n      try {\n        for(int i=outDocsIndex; i>=0; --i) {\n          SortDoc s = outDocs[i];\n          if(commaNeeded){writer.write(',');}\n          writer.write('{');\n          writeDoc(s, leaves, fieldWriters, sets, writer);\n          writer.write('}');\n          commaNeeded = true;\n          s.reset();\n        }\n      } catch(Throwable e) {\n        Throwable ex = e;\n        while(ex != null) {\n          String m = ex.getMessage();\n          if(m != null && m.contains(\"Broken pipe\")) {\n            throw new IgnoreException();\n          }\n          ex = ex.getCause();\n        }\n\n        if(e instanceof IOException) {\n          throw ((IOException)e);\n        } else {\n          throw new IOException(e);\n        }\n      }\n    }\n\n    //System.out.println(\"Sort Time 2:\"+Long.toString(total/1000000));\n    writer.write(\"]}}\");\n    writer.flush();\n  }\n\n","sourceOld":"  public void write(Writer writer, SolrQueryRequest req, SolrQueryResponse res) throws IOException {\n    Exception e1 = res.getException();\n    if(e1 != null) {\n      if(!(e1 instanceof IgnoreException)) {\n        e1.printStackTrace(new PrintWriter(writer));\n      }\n      return;\n    }\n    SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n    SortSpec sortSpec = info.getResponseBuilder().getSortSpec();\n\n    if(sortSpec == null) {\n      throw new IOException(new SyntaxError(\"No sort criteria was provided.\"));\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Sort sort = searcher.weightSort(sortSpec.getSort());\n\n    if(sort == null) {\n      throw new IOException(new SyntaxError(\"No sort criteria was provided.\"));\n    }\n\n    if(sort.needsScores()) {\n      throw new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"));\n    }\n\n    FixedBitSet[] sets = (FixedBitSet[])req.getContext().get(\"export\");\n    Integer th = (Integer)req.getContext().get(\"totalHits\");\n\n    if(sets == null) {\n      throw new IOException(new SyntaxError(\"xport RankQuery is required for xsort: rq={!xport}\"));\n    }\n\n    int totalHits = th.intValue();\n    SolrParams params = req.getParams();\n    String fl = params.get(\"fl\");\n\n    if(fl == null) {\n      throw new IOException(new SyntaxError(\"export field list (fl) must be specified.\"));\n    }\n\n    String[] fields = fl.split(\",\");\n\n    for(int i=0;i<fields.length; i++) {\n      if(fl.trim().equals(\"score\")) {\n        throw new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"));\n      }\n    }\n\n    FieldWriter[] fieldWriters = getFieldWriters(fields, req.getSearcher());\n    writer.write(\"{\\\"numFound\\\":\"+totalHits+\", \\\"docs\\\":[\");\n\n    //Write the data.\n    List<LeafReaderContext> leaves = req.getSearcher().getTopReaderContext().leaves();\n    SortDoc sortDoc = getSortDoc(req.getSearcher(), sort.getSort());\n    int count = 0;\n    int queueSize = 30000;\n    SortQueue queue = new SortQueue(queueSize, sortDoc);\n    SortDoc[] outDocs = new SortDoc[queueSize];\n\n    while(count < totalHits) {\n      //long begin = System.nanoTime();\n      boolean commaNeeded = false;\n      queue.reset();\n      SortDoc top = queue.top();\n      for(int i=0; i<leaves.size(); i++) {\n        sortDoc.setNextReader(leaves.get(i));\n        DocIdSetIterator it = new BitSetIterator(sets[i], 0); // cost is not useful here\n        int docId = -1;\n        while((docId = it.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          sortDoc.setValues(docId);\n          if(top.lessThan(sortDoc)) {\n            top.setValues(sortDoc);\n            top = queue.updateTop();\n          }\n        }\n      }\n\n      int outDocsIndex = -1;\n\n      for(int i=0; i<queueSize; i++) {\n        SortDoc s = queue.pop();\n        if(s.docId > -1) {\n          outDocs[++outDocsIndex] = s;\n        }\n      }\n\n     //long end = System.nanoTime();\n\n      count += (outDocsIndex+1);\n\n      try {\n        for(int i=outDocsIndex; i>=0; --i) {\n          SortDoc s = outDocs[i];\n          if(commaNeeded){writer.write(',');}\n          writer.write('{');\n          writeDoc(s, leaves, fieldWriters, sets, writer);\n          writer.write('}');\n          commaNeeded = true;\n          s.reset();\n        }\n      } catch(Throwable e) {\n        Throwable ex = e;\n        while(ex != null) {\n          String m = ex.getMessage();\n          if(m != null && m.contains(\"Broken pipe\")) {\n            throw new IgnoreException();\n          }\n          ex = ex.getCause();\n        }\n\n        if(e instanceof IOException) {\n          throw ((IOException)e);\n        } else {\n          throw new IOException(e);\n        }\n      }\n    }\n\n    //System.out.println(\"Sort Time 2:\"+Long.toString(total/1000000));\n    writer.write(\"]}\");\n    writer.flush();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a55bf71f91aeded06b44ad1abea6666ea168b697","date":1435941127,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/response/SortingResponseWriter#write(Writer,SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/SortingResponseWriter#write(Writer,SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  public void write(Writer writer, SolrQueryRequest req, SolrQueryResponse res) throws IOException {\n    Exception e1 = res.getException();\n    if(e1 != null) {\n      if(!(e1 instanceof IgnoreException)) {\n        e1.printStackTrace(new PrintWriter(writer));\n      }\n      return;\n    }\n\n    SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n    SortSpec sortSpec = info.getResponseBuilder().getSortSpec();\n    Exception exception = null;\n\n    if(sortSpec == null) {\n      exception = new IOException(new SyntaxError(\"No sort criteria was provided.\"));\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Sort sort = searcher.weightSort(sortSpec.getSort());\n\n    if(sort == null) {\n      exception = new IOException(new SyntaxError(\"No sort criteria was provided.\"));\n    }\n\n    if(sort.needsScores()) {\n      exception = new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"));\n    }\n\n    FixedBitSet[] sets = (FixedBitSet[])req.getContext().get(\"export\");\n    Integer th = (Integer)req.getContext().get(\"totalHits\");\n\n    if(sets == null) {\n      exception = new IOException(new SyntaxError(\"xport RankQuery is required for xsort: rq={!xport}\"));\n    }\n\n    int totalHits = th.intValue();\n    SolrParams params = req.getParams();\n    String fl = params.get(\"fl\");\n\n    if(fl == null) {\n      exception = new IOException(new SyntaxError(\"export field list (fl) must be specified.\"));\n    }\n\n    String[] fields = fl.split(\",\");\n\n    for(int i=0;i<fields.length; i++) {\n      if(fl.trim().equals(\"score\")) {\n        exception =  new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"));\n        break;\n      }\n    }\n\n    FieldWriter[] fieldWriters = null;\n\n    try {\n      fieldWriters = getFieldWriters(fields, req.getSearcher());\n    }catch(Exception e) {\n      exception = e;\n    }\n\n    writer.write(\"{\\\"responseHeader\\\": {\\\"status\\\": 0}, \\\"response\\\":{\\\"numFound\\\":\"+totalHits+\", \\\"docs\\\":[\");\n\n    if(exception != null) {\n      //We have an exception. Send it back to the client and return.\n      writeException(exception, writer);\n      writer.write(\"]}}\");\n      writer.flush();\n      return;\n    }\n\n    //Write the data.\n    List<LeafReaderContext> leaves = req.getSearcher().getTopReaderContext().leaves();\n    SortDoc sortDoc = getSortDoc(req.getSearcher(), sort.getSort());\n    int count = 0;\n    int queueSize = 30000;\n    SortQueue queue = new SortQueue(queueSize, sortDoc);\n    SortDoc[] outDocs = new SortDoc[queueSize];\n\n    boolean commaNeeded = false;\n    while(count < totalHits) {\n      //long begin = System.nanoTime();\n      queue.reset();\n      SortDoc top = queue.top();\n      for(int i=0; i<leaves.size(); i++) {\n        sortDoc.setNextReader(leaves.get(i));\n        DocIdSetIterator it = new BitSetIterator(sets[i], 0); // cost is not useful here\n        int docId = -1;\n        while((docId = it.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          sortDoc.setValues(docId);\n          if(top.lessThan(sortDoc)) {\n            top.setValues(sortDoc);\n            top = queue.updateTop();\n          }\n        }\n      }\n\n      int outDocsIndex = -1;\n\n      for(int i=0; i<queueSize; i++) {\n        SortDoc s = queue.pop();\n        if(s.docId > -1) {\n          outDocs[++outDocsIndex] = s;\n        }\n      }\n\n     //long end = System.nanoTime();\n\n      count += (outDocsIndex+1);\n\n      try {\n        for(int i=outDocsIndex; i>=0; --i) {\n          SortDoc s = outDocs[i];\n          if(commaNeeded){writer.write(',');}\n          writer.write('{');\n          writeDoc(s, leaves, fieldWriters, sets, writer);\n          writer.write('}');\n          commaNeeded = true;\n          s.reset();\n        }\n      } catch(Throwable e) {\n        Throwable ex = e;\n        while(ex != null) {\n          String m = ex.getMessage();\n          if(m != null && m.contains(\"Broken pipe\")) {\n            throw new IgnoreException();\n          }\n          ex = ex.getCause();\n        }\n\n        if(e instanceof IOException) {\n          throw ((IOException)e);\n        } else {\n          throw new IOException(e);\n        }\n      }\n    }\n\n    //System.out.println(\"Sort Time 2:\"+Long.toString(total/1000000));\n    writer.write(\"]}}\");\n    writer.flush();\n  }\n\n","sourceOld":"  public void write(Writer writer, SolrQueryRequest req, SolrQueryResponse res) throws IOException {\n    Exception e1 = res.getException();\n    if(e1 != null) {\n      if(!(e1 instanceof IgnoreException)) {\n        e1.printStackTrace(new PrintWriter(writer));\n      }\n      return;\n    }\n    SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n    SortSpec sortSpec = info.getResponseBuilder().getSortSpec();\n\n    if(sortSpec == null) {\n      throw new IOException(new SyntaxError(\"No sort criteria was provided.\"));\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Sort sort = searcher.weightSort(sortSpec.getSort());\n\n    if(sort == null) {\n      throw new IOException(new SyntaxError(\"No sort criteria was provided.\"));\n    }\n\n    if(sort.needsScores()) {\n      throw new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"));\n    }\n\n    FixedBitSet[] sets = (FixedBitSet[])req.getContext().get(\"export\");\n    Integer th = (Integer)req.getContext().get(\"totalHits\");\n\n    if(sets == null) {\n      throw new IOException(new SyntaxError(\"xport RankQuery is required for xsort: rq={!xport}\"));\n    }\n\n    int totalHits = th.intValue();\n    SolrParams params = req.getParams();\n    String fl = params.get(\"fl\");\n\n    if(fl == null) {\n      throw new IOException(new SyntaxError(\"export field list (fl) must be specified.\"));\n    }\n\n    String[] fields = fl.split(\",\");\n\n    for(int i=0;i<fields.length; i++) {\n      if(fl.trim().equals(\"score\")) {\n        throw new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"));\n      }\n    }\n\n    FieldWriter[] fieldWriters = getFieldWriters(fields, req.getSearcher());\n    writer.write(\"{\\\"responseHeader\\\": {\\\"status\\\": 0}, \\\"response\\\":{\\\"numFound\\\":\"+totalHits+\", \\\"docs\\\":[\");\n\n    //Write the data.\n    List<LeafReaderContext> leaves = req.getSearcher().getTopReaderContext().leaves();\n    SortDoc sortDoc = getSortDoc(req.getSearcher(), sort.getSort());\n    int count = 0;\n    int queueSize = 30000;\n    SortQueue queue = new SortQueue(queueSize, sortDoc);\n    SortDoc[] outDocs = new SortDoc[queueSize];\n\n    boolean commaNeeded = false;\n    while(count < totalHits) {\n      //long begin = System.nanoTime();\n      queue.reset();\n      SortDoc top = queue.top();\n      for(int i=0; i<leaves.size(); i++) {\n        sortDoc.setNextReader(leaves.get(i));\n        DocIdSetIterator it = new BitSetIterator(sets[i], 0); // cost is not useful here\n        int docId = -1;\n        while((docId = it.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          sortDoc.setValues(docId);\n          if(top.lessThan(sortDoc)) {\n            top.setValues(sortDoc);\n            top = queue.updateTop();\n          }\n        }\n      }\n\n      int outDocsIndex = -1;\n\n      for(int i=0; i<queueSize; i++) {\n        SortDoc s = queue.pop();\n        if(s.docId > -1) {\n          outDocs[++outDocsIndex] = s;\n        }\n      }\n\n     //long end = System.nanoTime();\n\n      count += (outDocsIndex+1);\n\n      try {\n        for(int i=outDocsIndex; i>=0; --i) {\n          SortDoc s = outDocs[i];\n          if(commaNeeded){writer.write(',');}\n          writer.write('{');\n          writeDoc(s, leaves, fieldWriters, sets, writer);\n          writer.write('}');\n          commaNeeded = true;\n          s.reset();\n        }\n      } catch(Throwable e) {\n        Throwable ex = e;\n        while(ex != null) {\n          String m = ex.getMessage();\n          if(m != null && m.contains(\"Broken pipe\")) {\n            throw new IgnoreException();\n          }\n          ex = ex.getCause();\n        }\n\n        if(e instanceof IOException) {\n          throw ((IOException)e);\n        } else {\n          throw new IOException(e);\n        }\n      }\n    }\n\n    //System.out.println(\"Sort Time 2:\"+Long.toString(total/1000000));\n    writer.write(\"]}}\");\n    writer.flush();\n  }\n\n","bugFix":["901b27c7f633ab98e138aafb0b9c3ba22aac6b28"],"bugIntro":["24e98791f8207d0adf6998892a9e9eeec5db0f40"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8da9a71da64ce12a97dcfcdd912893aeb1fa2981","date":1437510515,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/response/SortingResponseWriter#write(Writer,SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/SortingResponseWriter#write(Writer,SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  public void write(Writer writer, SolrQueryRequest req, SolrQueryResponse res) throws IOException {\n    Exception e1 = res.getException();\n    if(e1 != null) {\n      if(!(e1 instanceof IgnoreException)) {\n        writeException(e1, writer, false);\n      }\n      return;\n    }\n\n    SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n    SortSpec sortSpec = info.getResponseBuilder().getSortSpec();\n    Exception exception = null;\n\n    if(sortSpec == null) {\n      exception = new IOException(new SyntaxError(\"No sort criteria was provided.\"));\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Sort sort = searcher.weightSort(sortSpec.getSort());\n\n    if(sort == null) {\n      exception = new IOException(new SyntaxError(\"No sort criteria was provided.\"));\n    }\n\n    if(sort.needsScores()) {\n      exception = new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"));\n    }\n\n    FixedBitSet[] sets = (FixedBitSet[])req.getContext().get(\"export\");\n    Integer th = (Integer)req.getContext().get(\"totalHits\");\n\n    if(sets == null) {\n      exception = new IOException(new SyntaxError(\"xport RankQuery is required for xsort: rq={!xport}\"));\n    }\n\n    int totalHits = th.intValue();\n    SolrParams params = req.getParams();\n    String fl = params.get(\"fl\");\n\n    if(fl == null) {\n      exception = new IOException(new SyntaxError(\"export field list (fl) must be specified.\"));\n    }\n\n    String[] fields = fl.split(\",\");\n\n    for(int i=0;i<fields.length; i++) {\n      if(fl.trim().equals(\"score\")) {\n        exception =  new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"));\n        break;\n      }\n    }\n\n    FieldWriter[] fieldWriters = null;\n\n    try {\n      fieldWriters = getFieldWriters(fields, req.getSearcher());\n    }catch(Exception e) {\n      exception = e;\n    }\n\n\n    if(exception != null) {\n      writeException(exception, writer, true);\n      return;\n    }\n\n    writer.write(\"{\\\"responseHeader\\\": {\\\"status\\\": 0}, \\\"response\\\":{\\\"numFound\\\":\"+totalHits+\", \\\"docs\\\":[\");\n\n\n    //Write the data.\n    List<LeafReaderContext> leaves = req.getSearcher().getTopReaderContext().leaves();\n    SortDoc sortDoc = getSortDoc(req.getSearcher(), sort.getSort());\n    int count = 0;\n    int queueSize = 30000;\n    SortQueue queue = new SortQueue(queueSize, sortDoc);\n    SortDoc[] outDocs = new SortDoc[queueSize];\n\n    boolean commaNeeded = false;\n    while(count < totalHits) {\n      //long begin = System.nanoTime();\n      queue.reset();\n      SortDoc top = queue.top();\n      for(int i=0; i<leaves.size(); i++) {\n        sortDoc.setNextReader(leaves.get(i));\n        DocIdSetIterator it = new BitSetIterator(sets[i], 0); // cost is not useful here\n        int docId = -1;\n        while((docId = it.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          sortDoc.setValues(docId);\n          if(top.lessThan(sortDoc)) {\n            top.setValues(sortDoc);\n            top = queue.updateTop();\n          }\n        }\n      }\n\n      int outDocsIndex = -1;\n\n      for(int i=0; i<queueSize; i++) {\n        SortDoc s = queue.pop();\n        if(s.docId > -1) {\n          outDocs[++outDocsIndex] = s;\n        }\n      }\n\n     //long end = System.nanoTime();\n\n      count += (outDocsIndex+1);\n\n      try {\n        for(int i=outDocsIndex; i>=0; --i) {\n          SortDoc s = outDocs[i];\n          if(commaNeeded){writer.write(',');}\n          writer.write('{');\n          writeDoc(s, leaves, fieldWriters, sets, writer);\n          writer.write('}');\n          commaNeeded = true;\n          s.reset();\n        }\n      } catch(Throwable e) {\n        Throwable ex = e;\n        e.printStackTrace();\n        while(ex != null) {\n          String m = ex.getMessage();\n          if(m != null && m.contains(\"Broken pipe\")) {\n            throw new IgnoreException();\n          }\n          ex = ex.getCause();\n        }\n\n        if(e instanceof IOException) {\n          throw ((IOException)e);\n        } else {\n          throw new IOException(e);\n        }\n      }\n    }\n\n    //System.out.println(\"Sort Time 2:\"+Long.toString(total/1000000));\n    writer.write(\"]}}\");\n    writer.flush();\n  }\n\n","sourceOld":"  public void write(Writer writer, SolrQueryRequest req, SolrQueryResponse res) throws IOException {\n    Exception e1 = res.getException();\n    if(e1 != null) {\n      if(!(e1 instanceof IgnoreException)) {\n        e1.printStackTrace(new PrintWriter(writer));\n      }\n      return;\n    }\n\n    SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n    SortSpec sortSpec = info.getResponseBuilder().getSortSpec();\n    Exception exception = null;\n\n    if(sortSpec == null) {\n      exception = new IOException(new SyntaxError(\"No sort criteria was provided.\"));\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Sort sort = searcher.weightSort(sortSpec.getSort());\n\n    if(sort == null) {\n      exception = new IOException(new SyntaxError(\"No sort criteria was provided.\"));\n    }\n\n    if(sort.needsScores()) {\n      exception = new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"));\n    }\n\n    FixedBitSet[] sets = (FixedBitSet[])req.getContext().get(\"export\");\n    Integer th = (Integer)req.getContext().get(\"totalHits\");\n\n    if(sets == null) {\n      exception = new IOException(new SyntaxError(\"xport RankQuery is required for xsort: rq={!xport}\"));\n    }\n\n    int totalHits = th.intValue();\n    SolrParams params = req.getParams();\n    String fl = params.get(\"fl\");\n\n    if(fl == null) {\n      exception = new IOException(new SyntaxError(\"export field list (fl) must be specified.\"));\n    }\n\n    String[] fields = fl.split(\",\");\n\n    for(int i=0;i<fields.length; i++) {\n      if(fl.trim().equals(\"score\")) {\n        exception =  new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"));\n        break;\n      }\n    }\n\n    FieldWriter[] fieldWriters = null;\n\n    try {\n      fieldWriters = getFieldWriters(fields, req.getSearcher());\n    }catch(Exception e) {\n      exception = e;\n    }\n\n    writer.write(\"{\\\"responseHeader\\\": {\\\"status\\\": 0}, \\\"response\\\":{\\\"numFound\\\":\"+totalHits+\", \\\"docs\\\":[\");\n\n    if(exception != null) {\n      //We have an exception. Send it back to the client and return.\n      writeException(exception, writer);\n      writer.write(\"]}}\");\n      writer.flush();\n      return;\n    }\n\n    //Write the data.\n    List<LeafReaderContext> leaves = req.getSearcher().getTopReaderContext().leaves();\n    SortDoc sortDoc = getSortDoc(req.getSearcher(), sort.getSort());\n    int count = 0;\n    int queueSize = 30000;\n    SortQueue queue = new SortQueue(queueSize, sortDoc);\n    SortDoc[] outDocs = new SortDoc[queueSize];\n\n    boolean commaNeeded = false;\n    while(count < totalHits) {\n      //long begin = System.nanoTime();\n      queue.reset();\n      SortDoc top = queue.top();\n      for(int i=0; i<leaves.size(); i++) {\n        sortDoc.setNextReader(leaves.get(i));\n        DocIdSetIterator it = new BitSetIterator(sets[i], 0); // cost is not useful here\n        int docId = -1;\n        while((docId = it.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          sortDoc.setValues(docId);\n          if(top.lessThan(sortDoc)) {\n            top.setValues(sortDoc);\n            top = queue.updateTop();\n          }\n        }\n      }\n\n      int outDocsIndex = -1;\n\n      for(int i=0; i<queueSize; i++) {\n        SortDoc s = queue.pop();\n        if(s.docId > -1) {\n          outDocs[++outDocsIndex] = s;\n        }\n      }\n\n     //long end = System.nanoTime();\n\n      count += (outDocsIndex+1);\n\n      try {\n        for(int i=outDocsIndex; i>=0; --i) {\n          SortDoc s = outDocs[i];\n          if(commaNeeded){writer.write(',');}\n          writer.write('{');\n          writeDoc(s, leaves, fieldWriters, sets, writer);\n          writer.write('}');\n          commaNeeded = true;\n          s.reset();\n        }\n      } catch(Throwable e) {\n        Throwable ex = e;\n        while(ex != null) {\n          String m = ex.getMessage();\n          if(m != null && m.contains(\"Broken pipe\")) {\n            throw new IgnoreException();\n          }\n          ex = ex.getCause();\n        }\n\n        if(e instanceof IOException) {\n          throw ((IOException)e);\n        } else {\n          throw new IOException(e);\n        }\n      }\n    }\n\n    //System.out.println(\"Sort Time 2:\"+Long.toString(total/1000000));\n    writer.write(\"]}}\");\n    writer.flush();\n  }\n\n","bugFix":null,"bugIntro":["24e98791f8207d0adf6998892a9e9eeec5db0f40"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d12ee9465d37a9eedeee8a630aa7551b013cd4e4","date":1450303849,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/response/SortingResponseWriter#write(Writer,SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/SortingResponseWriter#write(Writer,SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  public void write(Writer writer, SolrQueryRequest req, SolrQueryResponse res) throws IOException {\n    Exception e1 = res.getException();\n    if(e1 != null) {\n      if(!(e1 instanceof IgnoreException)) {\n        writeException(e1, writer, false);\n      }\n      return;\n    }\n\n    SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n    SortSpec sortSpec = info.getResponseBuilder().getSortSpec();\n    Exception exception = null;\n\n    if(sortSpec == null) {\n      exception = new IOException(new SyntaxError(\"No sort criteria was provided.\"));\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Sort sort = searcher.weightSort(sortSpec.getSort());\n\n    if(sort == null) {\n      exception = new IOException(new SyntaxError(\"No sort criteria was provided.\"));\n    }\n\n    if(sort != null && sort.needsScores()) {\n      exception = new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"));\n    }\n\n    FixedBitSet[] sets = (FixedBitSet[])req.getContext().get(\"export\");\n    Integer th = (Integer)req.getContext().get(\"totalHits\");\n\n    if(sets == null) {\n      exception = new IOException(new SyntaxError(\"xport RankQuery is required for xsort: rq={!xport}\"));\n    }\n\n    int totalHits = th.intValue();\n    SolrParams params = req.getParams();\n    String fl = params.get(\"fl\");\n\n    String[] fields = null;\n\n    if(fl == null) {\n      exception = new IOException(new SyntaxError(\"export field list (fl) must be specified.\"));\n    } else  {\n      fields = fl.split(\",\");\n\n      for(int i=0;i<fields.length; i++) {\n        if(fl.trim().equals(\"score\")) {\n          exception =  new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"));\n          break;\n        }\n      }\n    }\n\n    FieldWriter[] fieldWriters = null;\n\n    try {\n      fieldWriters = getFieldWriters(fields, req.getSearcher());\n    }catch(Exception e) {\n      exception = e;\n    }\n\n\n    if(exception != null) {\n      writeException(exception, writer, true);\n      return;\n    }\n\n    writer.write(\"{\\\"responseHeader\\\": {\\\"status\\\": 0}, \\\"response\\\":{\\\"numFound\\\":\"+totalHits+\", \\\"docs\\\":[\");\n\n\n    //Write the data.\n    List<LeafReaderContext> leaves = req.getSearcher().getTopReaderContext().leaves();\n    SortDoc sortDoc = getSortDoc(req.getSearcher(), sort.getSort());\n    int count = 0;\n    int queueSize = 30000;\n    SortQueue queue = new SortQueue(queueSize, sortDoc);\n    SortDoc[] outDocs = new SortDoc[queueSize];\n\n    boolean commaNeeded = false;\n    while(count < totalHits) {\n      //long begin = System.nanoTime();\n      queue.reset();\n      SortDoc top = queue.top();\n      for(int i=0; i<leaves.size(); i++) {\n        sortDoc.setNextReader(leaves.get(i));\n        DocIdSetIterator it = new BitSetIterator(sets[i], 0); // cost is not useful here\n        int docId = -1;\n        while((docId = it.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          sortDoc.setValues(docId);\n          if(top.lessThan(sortDoc)) {\n            top.setValues(sortDoc);\n            top = queue.updateTop();\n          }\n        }\n      }\n\n      int outDocsIndex = -1;\n\n      for(int i=0; i<queueSize; i++) {\n        SortDoc s = queue.pop();\n        if(s.docId > -1) {\n          outDocs[++outDocsIndex] = s;\n        }\n      }\n\n     //long end = System.nanoTime();\n\n      count += (outDocsIndex+1);\n\n      try {\n        for(int i=outDocsIndex; i>=0; --i) {\n          SortDoc s = outDocs[i];\n          if(commaNeeded){writer.write(',');}\n          writer.write('{');\n          writeDoc(s, leaves, fieldWriters, sets, writer);\n          writer.write('}');\n          commaNeeded = true;\n          s.reset();\n        }\n      } catch(Throwable e) {\n        Throwable ex = e;\n        e.printStackTrace();\n        while(ex != null) {\n          String m = ex.getMessage();\n          if(m != null && m.contains(\"Broken pipe\")) {\n            throw new IgnoreException();\n          }\n          ex = ex.getCause();\n        }\n\n        if(e instanceof IOException) {\n          throw ((IOException)e);\n        } else {\n          throw new IOException(e);\n        }\n      }\n    }\n\n    //System.out.println(\"Sort Time 2:\"+Long.toString(total/1000000));\n    writer.write(\"]}}\");\n    writer.flush();\n  }\n\n","sourceOld":"  public void write(Writer writer, SolrQueryRequest req, SolrQueryResponse res) throws IOException {\n    Exception e1 = res.getException();\n    if(e1 != null) {\n      if(!(e1 instanceof IgnoreException)) {\n        writeException(e1, writer, false);\n      }\n      return;\n    }\n\n    SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n    SortSpec sortSpec = info.getResponseBuilder().getSortSpec();\n    Exception exception = null;\n\n    if(sortSpec == null) {\n      exception = new IOException(new SyntaxError(\"No sort criteria was provided.\"));\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Sort sort = searcher.weightSort(sortSpec.getSort());\n\n    if(sort == null) {\n      exception = new IOException(new SyntaxError(\"No sort criteria was provided.\"));\n    }\n\n    if(sort.needsScores()) {\n      exception = new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"));\n    }\n\n    FixedBitSet[] sets = (FixedBitSet[])req.getContext().get(\"export\");\n    Integer th = (Integer)req.getContext().get(\"totalHits\");\n\n    if(sets == null) {\n      exception = new IOException(new SyntaxError(\"xport RankQuery is required for xsort: rq={!xport}\"));\n    }\n\n    int totalHits = th.intValue();\n    SolrParams params = req.getParams();\n    String fl = params.get(\"fl\");\n\n    if(fl == null) {\n      exception = new IOException(new SyntaxError(\"export field list (fl) must be specified.\"));\n    }\n\n    String[] fields = fl.split(\",\");\n\n    for(int i=0;i<fields.length; i++) {\n      if(fl.trim().equals(\"score\")) {\n        exception =  new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"));\n        break;\n      }\n    }\n\n    FieldWriter[] fieldWriters = null;\n\n    try {\n      fieldWriters = getFieldWriters(fields, req.getSearcher());\n    }catch(Exception e) {\n      exception = e;\n    }\n\n\n    if(exception != null) {\n      writeException(exception, writer, true);\n      return;\n    }\n\n    writer.write(\"{\\\"responseHeader\\\": {\\\"status\\\": 0}, \\\"response\\\":{\\\"numFound\\\":\"+totalHits+\", \\\"docs\\\":[\");\n\n\n    //Write the data.\n    List<LeafReaderContext> leaves = req.getSearcher().getTopReaderContext().leaves();\n    SortDoc sortDoc = getSortDoc(req.getSearcher(), sort.getSort());\n    int count = 0;\n    int queueSize = 30000;\n    SortQueue queue = new SortQueue(queueSize, sortDoc);\n    SortDoc[] outDocs = new SortDoc[queueSize];\n\n    boolean commaNeeded = false;\n    while(count < totalHits) {\n      //long begin = System.nanoTime();\n      queue.reset();\n      SortDoc top = queue.top();\n      for(int i=0; i<leaves.size(); i++) {\n        sortDoc.setNextReader(leaves.get(i));\n        DocIdSetIterator it = new BitSetIterator(sets[i], 0); // cost is not useful here\n        int docId = -1;\n        while((docId = it.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          sortDoc.setValues(docId);\n          if(top.lessThan(sortDoc)) {\n            top.setValues(sortDoc);\n            top = queue.updateTop();\n          }\n        }\n      }\n\n      int outDocsIndex = -1;\n\n      for(int i=0; i<queueSize; i++) {\n        SortDoc s = queue.pop();\n        if(s.docId > -1) {\n          outDocs[++outDocsIndex] = s;\n        }\n      }\n\n     //long end = System.nanoTime();\n\n      count += (outDocsIndex+1);\n\n      try {\n        for(int i=outDocsIndex; i>=0; --i) {\n          SortDoc s = outDocs[i];\n          if(commaNeeded){writer.write(',');}\n          writer.write('{');\n          writeDoc(s, leaves, fieldWriters, sets, writer);\n          writer.write('}');\n          commaNeeded = true;\n          s.reset();\n        }\n      } catch(Throwable e) {\n        Throwable ex = e;\n        e.printStackTrace();\n        while(ex != null) {\n          String m = ex.getMessage();\n          if(m != null && m.contains(\"Broken pipe\")) {\n            throw new IgnoreException();\n          }\n          ex = ex.getCause();\n        }\n\n        if(e instanceof IOException) {\n          throw ((IOException)e);\n        } else {\n          throw new IOException(e);\n        }\n      }\n    }\n\n    //System.out.println(\"Sort Time 2:\"+Long.toString(total/1000000));\n    writer.write(\"]}}\");\n    writer.flush();\n  }\n\n","bugFix":null,"bugIntro":["24e98791f8207d0adf6998892a9e9eeec5db0f40"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a027750b86452a8dcd054ac993d54b203dae9102","date":1451953949,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/response/SortingResponseWriter#write(Writer,SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/SortingResponseWriter#write(Writer,SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  public void write(Writer writer, SolrQueryRequest req, SolrQueryResponse res) throws IOException {\n    Exception e1 = res.getException();\n    if(e1 != null) {\n      if(!(e1 instanceof IgnoreException)) {\n        writeException(e1, writer, false);\n      }\n      return;\n    }\n\n    SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n    SortSpec sortSpec = info.getResponseBuilder().getSortSpec();\n    Exception exception = null;\n\n    if(sortSpec == null) {\n      exception = new IOException(new SyntaxError(\"No sort criteria was provided.\"));\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Sort sort = searcher.weightSort(sortSpec.getSort());\n\n    if(sort == null) {\n      exception = new IOException(new SyntaxError(\"No sort criteria was provided.\"));\n    }\n\n    if(sort != null && sort.needsScores()) {\n      exception = new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"));\n    }\n\n    FixedBitSet[] sets = (FixedBitSet[])req.getContext().get(\"export\");\n    Integer th = (Integer)req.getContext().get(\"totalHits\");\n\n    if(sets == null) {\n      exception = new IOException(new SyntaxError(\"xport RankQuery is required for xsort: rq={!xport}\"));\n    }\n\n    int totalHits = th.intValue();\n    SolrParams params = req.getParams();\n    String fl = params.get(\"fl\");\n\n    String[] fields = null;\n\n    if(fl == null) {\n      exception = new IOException(new SyntaxError(\"export field list (fl) must be specified.\"));\n    } else  {\n      fields = fl.split(\",\");\n\n      for(int i=0;i<fields.length; i++) {\n\n        fields[i] = fields[i].trim();\n\n        if(fields[i].equals(\"score\")) {\n          exception =  new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"));\n          break;\n        }\n      }\n    }\n\n    FieldWriter[] fieldWriters = null;\n\n    try {\n      fieldWriters = getFieldWriters(fields, req.getSearcher());\n    }catch(Exception e) {\n      exception = e;\n    }\n\n\n    if(exception != null) {\n      writeException(exception, writer, true);\n      return;\n    }\n\n    writer.write(\"{\\\"responseHeader\\\": {\\\"status\\\": 0}, \\\"response\\\":{\\\"numFound\\\":\"+totalHits+\", \\\"docs\\\":[\");\n\n\n    //Write the data.\n    List<LeafReaderContext> leaves = req.getSearcher().getTopReaderContext().leaves();\n    SortDoc sortDoc = getSortDoc(req.getSearcher(), sort.getSort());\n    int count = 0;\n    int queueSize = 30000;\n    SortQueue queue = new SortQueue(queueSize, sortDoc);\n    SortDoc[] outDocs = new SortDoc[queueSize];\n\n    boolean commaNeeded = false;\n    while(count < totalHits) {\n      //long begin = System.nanoTime();\n      queue.reset();\n      SortDoc top = queue.top();\n      for(int i=0; i<leaves.size(); i++) {\n        sortDoc.setNextReader(leaves.get(i));\n        DocIdSetIterator it = new BitSetIterator(sets[i], 0); // cost is not useful here\n        int docId = -1;\n        while((docId = it.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          sortDoc.setValues(docId);\n          if(top.lessThan(sortDoc)) {\n            top.setValues(sortDoc);\n            top = queue.updateTop();\n          }\n        }\n      }\n\n      int outDocsIndex = -1;\n\n      for(int i=0; i<queueSize; i++) {\n        SortDoc s = queue.pop();\n        if(s.docId > -1) {\n          outDocs[++outDocsIndex] = s;\n        }\n      }\n\n     //long end = System.nanoTime();\n\n      count += (outDocsIndex+1);\n\n      try {\n        for(int i=outDocsIndex; i>=0; --i) {\n          SortDoc s = outDocs[i];\n          if(commaNeeded){writer.write(',');}\n          writer.write('{');\n          writeDoc(s, leaves, fieldWriters, sets, writer);\n          writer.write('}');\n          commaNeeded = true;\n          s.reset();\n        }\n      } catch(Throwable e) {\n        Throwable ex = e;\n        e.printStackTrace();\n        while(ex != null) {\n          String m = ex.getMessage();\n          if(m != null && m.contains(\"Broken pipe\")) {\n            throw new IgnoreException();\n          }\n          ex = ex.getCause();\n        }\n\n        if(e instanceof IOException) {\n          throw ((IOException)e);\n        } else {\n          throw new IOException(e);\n        }\n      }\n    }\n\n    //System.out.println(\"Sort Time 2:\"+Long.toString(total/1000000));\n    writer.write(\"]}}\");\n    writer.flush();\n  }\n\n","sourceOld":"  public void write(Writer writer, SolrQueryRequest req, SolrQueryResponse res) throws IOException {\n    Exception e1 = res.getException();\n    if(e1 != null) {\n      if(!(e1 instanceof IgnoreException)) {\n        writeException(e1, writer, false);\n      }\n      return;\n    }\n\n    SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n    SortSpec sortSpec = info.getResponseBuilder().getSortSpec();\n    Exception exception = null;\n\n    if(sortSpec == null) {\n      exception = new IOException(new SyntaxError(\"No sort criteria was provided.\"));\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Sort sort = searcher.weightSort(sortSpec.getSort());\n\n    if(sort == null) {\n      exception = new IOException(new SyntaxError(\"No sort criteria was provided.\"));\n    }\n\n    if(sort != null && sort.needsScores()) {\n      exception = new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"));\n    }\n\n    FixedBitSet[] sets = (FixedBitSet[])req.getContext().get(\"export\");\n    Integer th = (Integer)req.getContext().get(\"totalHits\");\n\n    if(sets == null) {\n      exception = new IOException(new SyntaxError(\"xport RankQuery is required for xsort: rq={!xport}\"));\n    }\n\n    int totalHits = th.intValue();\n    SolrParams params = req.getParams();\n    String fl = params.get(\"fl\");\n\n    String[] fields = null;\n\n    if(fl == null) {\n      exception = new IOException(new SyntaxError(\"export field list (fl) must be specified.\"));\n    } else  {\n      fields = fl.split(\",\");\n\n      for(int i=0;i<fields.length; i++) {\n        if(fl.trim().equals(\"score\")) {\n          exception =  new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"));\n          break;\n        }\n      }\n    }\n\n    FieldWriter[] fieldWriters = null;\n\n    try {\n      fieldWriters = getFieldWriters(fields, req.getSearcher());\n    }catch(Exception e) {\n      exception = e;\n    }\n\n\n    if(exception != null) {\n      writeException(exception, writer, true);\n      return;\n    }\n\n    writer.write(\"{\\\"responseHeader\\\": {\\\"status\\\": 0}, \\\"response\\\":{\\\"numFound\\\":\"+totalHits+\", \\\"docs\\\":[\");\n\n\n    //Write the data.\n    List<LeafReaderContext> leaves = req.getSearcher().getTopReaderContext().leaves();\n    SortDoc sortDoc = getSortDoc(req.getSearcher(), sort.getSort());\n    int count = 0;\n    int queueSize = 30000;\n    SortQueue queue = new SortQueue(queueSize, sortDoc);\n    SortDoc[] outDocs = new SortDoc[queueSize];\n\n    boolean commaNeeded = false;\n    while(count < totalHits) {\n      //long begin = System.nanoTime();\n      queue.reset();\n      SortDoc top = queue.top();\n      for(int i=0; i<leaves.size(); i++) {\n        sortDoc.setNextReader(leaves.get(i));\n        DocIdSetIterator it = new BitSetIterator(sets[i], 0); // cost is not useful here\n        int docId = -1;\n        while((docId = it.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          sortDoc.setValues(docId);\n          if(top.lessThan(sortDoc)) {\n            top.setValues(sortDoc);\n            top = queue.updateTop();\n          }\n        }\n      }\n\n      int outDocsIndex = -1;\n\n      for(int i=0; i<queueSize; i++) {\n        SortDoc s = queue.pop();\n        if(s.docId > -1) {\n          outDocs[++outDocsIndex] = s;\n        }\n      }\n\n     //long end = System.nanoTime();\n\n      count += (outDocsIndex+1);\n\n      try {\n        for(int i=outDocsIndex; i>=0; --i) {\n          SortDoc s = outDocs[i];\n          if(commaNeeded){writer.write(',');}\n          writer.write('{');\n          writeDoc(s, leaves, fieldWriters, sets, writer);\n          writer.write('}');\n          commaNeeded = true;\n          s.reset();\n        }\n      } catch(Throwable e) {\n        Throwable ex = e;\n        e.printStackTrace();\n        while(ex != null) {\n          String m = ex.getMessage();\n          if(m != null && m.contains(\"Broken pipe\")) {\n            throw new IgnoreException();\n          }\n          ex = ex.getCause();\n        }\n\n        if(e instanceof IOException) {\n          throw ((IOException)e);\n        } else {\n          throw new IOException(e);\n        }\n      }\n    }\n\n    //System.out.println(\"Sort Time 2:\"+Long.toString(total/1000000));\n    writer.write(\"]}}\");\n    writer.flush();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7f1f5e4b31ec44927335e2ad6eebc4c1f8c0abf5","date":1465691899,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/response/SortingResponseWriter#write(Writer,SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/SortingResponseWriter#write(Writer,SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  public void write(Writer writer, SolrQueryRequest req, SolrQueryResponse res) throws IOException {\n    Exception e1 = res.getException();\n    if(e1 != null) {\n      if(!(e1 instanceof IgnoreException)) {\n        writeException(e1, writer, false);\n      }\n      return;\n    }\n\n    SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n    SortSpec sortSpec = info.getResponseBuilder().getSortSpec();\n    Exception exception = null;\n\n    if(sortSpec == null) {\n      exception = new IOException(new SyntaxError(\"No sort criteria was provided.\"));\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Sort sort = searcher.weightSort(sortSpec.getSort());\n\n    if(sort == null) {\n      exception = new IOException(new SyntaxError(\"No sort criteria was provided.\"));\n    }\n\n    if(sort != null && sort.needsScores()) {\n      exception = new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"));\n    }\n\n    // There is a bailout in SolrIndexSearcher.getDocListNC when there are _no_ docs in the index at all.\n    // if (lastDocRequested <= 0) {\n    // That causes the totalHits and export entries in the context to _not_ get set.\n    // The only time that really matters is when we search against an _empty_ set. That's too obscure\n    // a condition to handle as part of this patch, if someone wants to pursue it it can be reproduced with:\n    // ant test  -Dtestcase=StreamingTest -Dtests.method=testAllValidExportTypes -Dtests.seed=10F13879D0D1D6AD -Dtests.slow=true -Dtests.locale=es-PA -Dtests.timezone=America/Bahia_Banderas -Dtests.asserts=true -Dtests.file.encoding=ISO-8859-1\n    // You'll have to uncomment the if below to hit the null pointer exception.\n    // This is such an unusual case (i.e. an empty index) that catching this concdition here is probably OK.\n    // This came to light in the very artifical case of indexing a single doc to Cloud.\n    int totalHits = 0;\n    FixedBitSet[] sets = null;\n    if (req.getContext().get(\"totalHits\") != null) {\n      totalHits = ((Integer)req.getContext().get(\"totalHits\")).intValue();\n      sets = (FixedBitSet[]) req.getContext().get(\"export\");\n      if (sets == null) {\n        exception = new IOException(new SyntaxError(\"xport RankQuery is required for xsort: rq={!xport}\"));\n      }\n    }\n    SolrParams params = req.getParams();\n    String fl = params.get(\"fl\");\n\n    String[] fields = null;\n\n    if(fl == null) {\n      exception = new IOException(new SyntaxError(\"export field list (fl) must be specified.\"));\n    } else  {\n      fields = fl.split(\",\");\n\n      for(int i=0;i<fields.length; i++) {\n\n        fields[i] = fields[i].trim();\n\n        if(fields[i].equals(\"score\")) {\n          exception =  new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"));\n          break;\n        }\n      }\n    }\n\n    FieldWriter[] fieldWriters = null;\n\n    try {\n      fieldWriters = getFieldWriters(fields, req.getSearcher());\n    } catch (Exception e) {\n      exception = e;\n    }\n\n\n    if(exception != null) {\n      writeException(exception, writer, true);\n      return;\n    }\n\n    writer.write(\"{\\\"responseHeader\\\": {\\\"status\\\": 0}, \\\"response\\\":{\\\"numFound\\\":\"+totalHits+\", \\\"docs\\\":[\");\n\n\n    //Write the data.\n    List<LeafReaderContext> leaves = req.getSearcher().getTopReaderContext().leaves();\n    SortDoc sortDoc = getSortDoc(req.getSearcher(), sort.getSort());\n    int count = 0;\n    int queueSize = 30000;\n    SortQueue queue = new SortQueue(queueSize, sortDoc);\n    SortDoc[] outDocs = new SortDoc[queueSize];\n\n    boolean commaNeeded = false;\n    while(count < totalHits) {\n      //long begin = System.nanoTime();\n      queue.reset();\n      SortDoc top = queue.top();\n      for(int i=0; i<leaves.size(); i++) {\n        sortDoc.setNextReader(leaves.get(i));\n        DocIdSetIterator it = new BitSetIterator(sets[i], 0); // cost is not useful here\n        int docId = -1;\n        while((docId = it.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          sortDoc.setValues(docId);\n          if(top.lessThan(sortDoc)) {\n            top.setValues(sortDoc);\n            top = queue.updateTop();\n          }\n        }\n      }\n\n      int outDocsIndex = -1;\n\n      for(int i=0; i<queueSize; i++) {\n        SortDoc s = queue.pop();\n        if(s.docId > -1) {\n          outDocs[++outDocsIndex] = s;\n        }\n      }\n\n     //long end = System.nanoTime();\n\n      count += (outDocsIndex+1);\n\n      try {\n        for(int i=outDocsIndex; i>=0; --i) {\n          SortDoc s = outDocs[i];\n          if(commaNeeded){writer.write(',');}\n          writer.write('{');\n          writeDoc(s, leaves, fieldWriters, sets, writer);\n          writer.write('}');\n          commaNeeded = true;\n          s.reset();\n        }\n      } catch(Throwable e) {\n        Throwable ex = e;\n        e.printStackTrace();\n        while(ex != null) {\n          String m = ex.getMessage();\n          if(m != null && m.contains(\"Broken pipe\")) {\n            throw new IgnoreException();\n          }\n          ex = ex.getCause();\n        }\n\n        if(e instanceof IOException) {\n          throw ((IOException)e);\n        } else {\n          throw new IOException(e);\n        }\n      }\n    }\n\n    //System.out.println(\"Sort Time 2:\"+Long.toString(total/1000000));\n    writer.write(\"]}}\");\n    writer.flush();\n  }\n\n","sourceOld":"  public void write(Writer writer, SolrQueryRequest req, SolrQueryResponse res) throws IOException {\n    Exception e1 = res.getException();\n    if(e1 != null) {\n      if(!(e1 instanceof IgnoreException)) {\n        writeException(e1, writer, false);\n      }\n      return;\n    }\n\n    SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n    SortSpec sortSpec = info.getResponseBuilder().getSortSpec();\n    Exception exception = null;\n\n    if(sortSpec == null) {\n      exception = new IOException(new SyntaxError(\"No sort criteria was provided.\"));\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Sort sort = searcher.weightSort(sortSpec.getSort());\n\n    if(sort == null) {\n      exception = new IOException(new SyntaxError(\"No sort criteria was provided.\"));\n    }\n\n    if(sort != null && sort.needsScores()) {\n      exception = new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"));\n    }\n\n    FixedBitSet[] sets = (FixedBitSet[])req.getContext().get(\"export\");\n    Integer th = (Integer)req.getContext().get(\"totalHits\");\n\n    if(sets == null) {\n      exception = new IOException(new SyntaxError(\"xport RankQuery is required for xsort: rq={!xport}\"));\n    }\n\n    int totalHits = th.intValue();\n    SolrParams params = req.getParams();\n    String fl = params.get(\"fl\");\n\n    String[] fields = null;\n\n    if(fl == null) {\n      exception = new IOException(new SyntaxError(\"export field list (fl) must be specified.\"));\n    } else  {\n      fields = fl.split(\",\");\n\n      for(int i=0;i<fields.length; i++) {\n\n        fields[i] = fields[i].trim();\n\n        if(fields[i].equals(\"score\")) {\n          exception =  new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"));\n          break;\n        }\n      }\n    }\n\n    FieldWriter[] fieldWriters = null;\n\n    try {\n      fieldWriters = getFieldWriters(fields, req.getSearcher());\n    }catch(Exception e) {\n      exception = e;\n    }\n\n\n    if(exception != null) {\n      writeException(exception, writer, true);\n      return;\n    }\n\n    writer.write(\"{\\\"responseHeader\\\": {\\\"status\\\": 0}, \\\"response\\\":{\\\"numFound\\\":\"+totalHits+\", \\\"docs\\\":[\");\n\n\n    //Write the data.\n    List<LeafReaderContext> leaves = req.getSearcher().getTopReaderContext().leaves();\n    SortDoc sortDoc = getSortDoc(req.getSearcher(), sort.getSort());\n    int count = 0;\n    int queueSize = 30000;\n    SortQueue queue = new SortQueue(queueSize, sortDoc);\n    SortDoc[] outDocs = new SortDoc[queueSize];\n\n    boolean commaNeeded = false;\n    while(count < totalHits) {\n      //long begin = System.nanoTime();\n      queue.reset();\n      SortDoc top = queue.top();\n      for(int i=0; i<leaves.size(); i++) {\n        sortDoc.setNextReader(leaves.get(i));\n        DocIdSetIterator it = new BitSetIterator(sets[i], 0); // cost is not useful here\n        int docId = -1;\n        while((docId = it.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          sortDoc.setValues(docId);\n          if(top.lessThan(sortDoc)) {\n            top.setValues(sortDoc);\n            top = queue.updateTop();\n          }\n        }\n      }\n\n      int outDocsIndex = -1;\n\n      for(int i=0; i<queueSize; i++) {\n        SortDoc s = queue.pop();\n        if(s.docId > -1) {\n          outDocs[++outDocsIndex] = s;\n        }\n      }\n\n     //long end = System.nanoTime();\n\n      count += (outDocsIndex+1);\n\n      try {\n        for(int i=outDocsIndex; i>=0; --i) {\n          SortDoc s = outDocs[i];\n          if(commaNeeded){writer.write(',');}\n          writer.write('{');\n          writeDoc(s, leaves, fieldWriters, sets, writer);\n          writer.write('}');\n          commaNeeded = true;\n          s.reset();\n        }\n      } catch(Throwable e) {\n        Throwable ex = e;\n        e.printStackTrace();\n        while(ex != null) {\n          String m = ex.getMessage();\n          if(m != null && m.contains(\"Broken pipe\")) {\n            throw new IgnoreException();\n          }\n          ex = ex.getCause();\n        }\n\n        if(e instanceof IOException) {\n          throw ((IOException)e);\n        } else {\n          throw new IOException(e);\n        }\n      }\n    }\n\n    //System.out.println(\"Sort Time 2:\"+Long.toString(total/1000000));\n    writer.write(\"]}}\");\n    writer.flush();\n  }\n\n","bugFix":null,"bugIntro":["24e98791f8207d0adf6998892a9e9eeec5db0f40"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/response/SortingResponseWriter#write(Writer,SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/SortingResponseWriter#write(Writer,SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  public void write(Writer writer, SolrQueryRequest req, SolrQueryResponse res) throws IOException {\n    Exception e1 = res.getException();\n    if(e1 != null) {\n      if(!(e1 instanceof IgnoreException)) {\n        writeException(e1, writer, false);\n      }\n      return;\n    }\n\n    SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n    SortSpec sortSpec = info.getResponseBuilder().getSortSpec();\n    Exception exception = null;\n\n    if(sortSpec == null) {\n      exception = new IOException(new SyntaxError(\"No sort criteria was provided.\"));\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Sort sort = searcher.weightSort(sortSpec.getSort());\n\n    if(sort == null) {\n      exception = new IOException(new SyntaxError(\"No sort criteria was provided.\"));\n    }\n\n    if(sort != null && sort.needsScores()) {\n      exception = new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"));\n    }\n\n    // There is a bailout in SolrIndexSearcher.getDocListNC when there are _no_ docs in the index at all.\n    // if (lastDocRequested <= 0) {\n    // That causes the totalHits and export entries in the context to _not_ get set.\n    // The only time that really matters is when we search against an _empty_ set. That's too obscure\n    // a condition to handle as part of this patch, if someone wants to pursue it it can be reproduced with:\n    // ant test  -Dtestcase=StreamingTest -Dtests.method=testAllValidExportTypes -Dtests.seed=10F13879D0D1D6AD -Dtests.slow=true -Dtests.locale=es-PA -Dtests.timezone=America/Bahia_Banderas -Dtests.asserts=true -Dtests.file.encoding=ISO-8859-1\n    // You'll have to uncomment the if below to hit the null pointer exception.\n    // This is such an unusual case (i.e. an empty index) that catching this concdition here is probably OK.\n    // This came to light in the very artifical case of indexing a single doc to Cloud.\n    int totalHits = 0;\n    FixedBitSet[] sets = null;\n    if (req.getContext().get(\"totalHits\") != null) {\n      totalHits = ((Integer)req.getContext().get(\"totalHits\")).intValue();\n      sets = (FixedBitSet[]) req.getContext().get(\"export\");\n      if (sets == null) {\n        exception = new IOException(new SyntaxError(\"xport RankQuery is required for xsort: rq={!xport}\"));\n      }\n    }\n    SolrParams params = req.getParams();\n    String fl = params.get(\"fl\");\n\n    String[] fields = null;\n\n    if(fl == null) {\n      exception = new IOException(new SyntaxError(\"export field list (fl) must be specified.\"));\n    } else  {\n      fields = fl.split(\",\");\n\n      for(int i=0;i<fields.length; i++) {\n\n        fields[i] = fields[i].trim();\n\n        if(fields[i].equals(\"score\")) {\n          exception =  new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"));\n          break;\n        }\n      }\n    }\n\n    FieldWriter[] fieldWriters = null;\n\n    try {\n      fieldWriters = getFieldWriters(fields, req.getSearcher());\n    } catch (Exception e) {\n      exception = e;\n    }\n\n\n    if(exception != null) {\n      writeException(exception, writer, true);\n      return;\n    }\n\n    writer.write(\"{\\\"responseHeader\\\": {\\\"status\\\": 0}, \\\"response\\\":{\\\"numFound\\\":\"+totalHits+\", \\\"docs\\\":[\");\n\n\n    //Write the data.\n    List<LeafReaderContext> leaves = req.getSearcher().getTopReaderContext().leaves();\n    SortDoc sortDoc = getSortDoc(req.getSearcher(), sort.getSort());\n    int count = 0;\n    int queueSize = 30000;\n    SortQueue queue = new SortQueue(queueSize, sortDoc);\n    SortDoc[] outDocs = new SortDoc[queueSize];\n\n    boolean commaNeeded = false;\n    while(count < totalHits) {\n      //long begin = System.nanoTime();\n      queue.reset();\n      SortDoc top = queue.top();\n      for(int i=0; i<leaves.size(); i++) {\n        sortDoc.setNextReader(leaves.get(i));\n        DocIdSetIterator it = new BitSetIterator(sets[i], 0); // cost is not useful here\n        int docId = -1;\n        while((docId = it.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          sortDoc.setValues(docId);\n          if(top.lessThan(sortDoc)) {\n            top.setValues(sortDoc);\n            top = queue.updateTop();\n          }\n        }\n      }\n\n      int outDocsIndex = -1;\n\n      for(int i=0; i<queueSize; i++) {\n        SortDoc s = queue.pop();\n        if(s.docId > -1) {\n          outDocs[++outDocsIndex] = s;\n        }\n      }\n\n     //long end = System.nanoTime();\n\n      count += (outDocsIndex+1);\n\n      try {\n        for(int i=outDocsIndex; i>=0; --i) {\n          SortDoc s = outDocs[i];\n          if(commaNeeded){writer.write(',');}\n          writer.write('{');\n          writeDoc(s, leaves, fieldWriters, sets, writer);\n          writer.write('}');\n          commaNeeded = true;\n          s.reset();\n        }\n      } catch(Throwable e) {\n        Throwable ex = e;\n        e.printStackTrace();\n        while(ex != null) {\n          String m = ex.getMessage();\n          if(m != null && m.contains(\"Broken pipe\")) {\n            throw new IgnoreException();\n          }\n          ex = ex.getCause();\n        }\n\n        if(e instanceof IOException) {\n          throw ((IOException)e);\n        } else {\n          throw new IOException(e);\n        }\n      }\n    }\n\n    //System.out.println(\"Sort Time 2:\"+Long.toString(total/1000000));\n    writer.write(\"]}}\");\n    writer.flush();\n  }\n\n","sourceOld":"  public void write(Writer writer, SolrQueryRequest req, SolrQueryResponse res) throws IOException {\n    Exception e1 = res.getException();\n    if(e1 != null) {\n      if(!(e1 instanceof IgnoreException)) {\n        writeException(e1, writer, false);\n      }\n      return;\n    }\n\n    SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n    SortSpec sortSpec = info.getResponseBuilder().getSortSpec();\n    Exception exception = null;\n\n    if(sortSpec == null) {\n      exception = new IOException(new SyntaxError(\"No sort criteria was provided.\"));\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Sort sort = searcher.weightSort(sortSpec.getSort());\n\n    if(sort == null) {\n      exception = new IOException(new SyntaxError(\"No sort criteria was provided.\"));\n    }\n\n    if(sort != null && sort.needsScores()) {\n      exception = new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"));\n    }\n\n    FixedBitSet[] sets = (FixedBitSet[])req.getContext().get(\"export\");\n    Integer th = (Integer)req.getContext().get(\"totalHits\");\n\n    if(sets == null) {\n      exception = new IOException(new SyntaxError(\"xport RankQuery is required for xsort: rq={!xport}\"));\n    }\n\n    int totalHits = th.intValue();\n    SolrParams params = req.getParams();\n    String fl = params.get(\"fl\");\n\n    String[] fields = null;\n\n    if(fl == null) {\n      exception = new IOException(new SyntaxError(\"export field list (fl) must be specified.\"));\n    } else  {\n      fields = fl.split(\",\");\n\n      for(int i=0;i<fields.length; i++) {\n\n        fields[i] = fields[i].trim();\n\n        if(fields[i].equals(\"score\")) {\n          exception =  new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"));\n          break;\n        }\n      }\n    }\n\n    FieldWriter[] fieldWriters = null;\n\n    try {\n      fieldWriters = getFieldWriters(fields, req.getSearcher());\n    }catch(Exception e) {\n      exception = e;\n    }\n\n\n    if(exception != null) {\n      writeException(exception, writer, true);\n      return;\n    }\n\n    writer.write(\"{\\\"responseHeader\\\": {\\\"status\\\": 0}, \\\"response\\\":{\\\"numFound\\\":\"+totalHits+\", \\\"docs\\\":[\");\n\n\n    //Write the data.\n    List<LeafReaderContext> leaves = req.getSearcher().getTopReaderContext().leaves();\n    SortDoc sortDoc = getSortDoc(req.getSearcher(), sort.getSort());\n    int count = 0;\n    int queueSize = 30000;\n    SortQueue queue = new SortQueue(queueSize, sortDoc);\n    SortDoc[] outDocs = new SortDoc[queueSize];\n\n    boolean commaNeeded = false;\n    while(count < totalHits) {\n      //long begin = System.nanoTime();\n      queue.reset();\n      SortDoc top = queue.top();\n      for(int i=0; i<leaves.size(); i++) {\n        sortDoc.setNextReader(leaves.get(i));\n        DocIdSetIterator it = new BitSetIterator(sets[i], 0); // cost is not useful here\n        int docId = -1;\n        while((docId = it.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          sortDoc.setValues(docId);\n          if(top.lessThan(sortDoc)) {\n            top.setValues(sortDoc);\n            top = queue.updateTop();\n          }\n        }\n      }\n\n      int outDocsIndex = -1;\n\n      for(int i=0; i<queueSize; i++) {\n        SortDoc s = queue.pop();\n        if(s.docId > -1) {\n          outDocs[++outDocsIndex] = s;\n        }\n      }\n\n     //long end = System.nanoTime();\n\n      count += (outDocsIndex+1);\n\n      try {\n        for(int i=outDocsIndex; i>=0; --i) {\n          SortDoc s = outDocs[i];\n          if(commaNeeded){writer.write(',');}\n          writer.write('{');\n          writeDoc(s, leaves, fieldWriters, sets, writer);\n          writer.write('}');\n          commaNeeded = true;\n          s.reset();\n        }\n      } catch(Throwable e) {\n        Throwable ex = e;\n        e.printStackTrace();\n        while(ex != null) {\n          String m = ex.getMessage();\n          if(m != null && m.contains(\"Broken pipe\")) {\n            throw new IgnoreException();\n          }\n          ex = ex.getCause();\n        }\n\n        if(e instanceof IOException) {\n          throw ((IOException)e);\n        } else {\n          throw new IOException(e);\n        }\n      }\n    }\n\n    //System.out.println(\"Sort Time 2:\"+Long.toString(total/1000000));\n    writer.write(\"]}}\");\n    writer.flush();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"24e98791f8207d0adf6998892a9e9eeec5db0f40","date":1477795641,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/response/SortingResponseWriter#write(Writer,SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/SortingResponseWriter#write(Writer,SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  public void write(Writer writer, SolrQueryRequest req, SolrQueryResponse res) throws IOException {\n    Exception e1 = res.getException();\n    if(e1 != null) {\n      if(!(e1 instanceof IgnoreException)) {\n        writeException(e1, writer, false);\n      }\n      return;\n    }\n\n    SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n    SortSpec sortSpec = info.getResponseBuilder().getSortSpec();\n\n    if(sortSpec == null) {\n      writeException((new IOException(new SyntaxError(\"No sort criteria was provided.\"))), writer, true);\n      return;\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Sort sort = searcher.weightSort(sortSpec.getSort());\n\n    if(sort == null) {\n      writeException((new IOException(new SyntaxError(\"No sort criteria was provided.\"))), writer, true);\n      return;\n    }\n\n    if(sort != null && sort.needsScores()) {\n      writeException((new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"))), writer, true);\n      return;\n    }\n\n    // There is a bailout in SolrIndexSearcher.getDocListNC when there are _no_ docs in the index at all.\n    // if (lastDocRequested <= 0) {\n    // That causes the totalHits and export entries in the context to _not_ get set.\n    // The only time that really matters is when we search against an _empty_ set. That's too obscure\n    // a condition to handle as part of this patch, if someone wants to pursue it it can be reproduced with:\n    // ant test  -Dtestcase=StreamingTest -Dtests.method=testAllValidExportTypes -Dtests.seed=10F13879D0D1D6AD -Dtests.slow=true -Dtests.locale=es-PA -Dtests.timezone=America/Bahia_Banderas -Dtests.asserts=true -Dtests.file.encoding=ISO-8859-1\n    // You'll have to uncomment the if below to hit the null pointer exception.\n    // This is such an unusual case (i.e. an empty index) that catching this concdition here is probably OK.\n    // This came to light in the very artifical case of indexing a single doc to Cloud.\n    int totalHits = 0;\n    FixedBitSet[] sets = null;\n    if (req.getContext().get(\"totalHits\") != null) {\n      totalHits = ((Integer)req.getContext().get(\"totalHits\")).intValue();\n      sets = (FixedBitSet[]) req.getContext().get(\"export\");\n      if (sets == null) {\n        writeException((new IOException(new SyntaxError(\"xport RankQuery is required for xsort: rq={!xport}\"))), writer, true);\n        return;\n      }\n    }\n    SolrParams params = req.getParams();\n    String fl = params.get(\"fl\");\n\n    String[] fields = null;\n\n    if(fl == null) {\n      writeException((new IOException(new SyntaxError(\"export field list (fl) must be specified.\"))), writer, true);\n      return;\n    } else  {\n      fields = fl.split(\",\");\n\n      for(int i=0;i<fields.length; i++) {\n\n        fields[i] = fields[i].trim();\n\n        if(fields[i].equals(\"score\")) {\n          writeException((new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"))), writer, true);\n          return;\n        }\n      }\n    }\n\n    FieldWriter[] fieldWriters = null;\n\n    try {\n      fieldWriters = getFieldWriters(fields, req.getSearcher());\n    } catch (Exception e) {\n      writeException(e, writer, true);\n      return;\n    }\n\n    writer.write(\"{\\\"responseHeader\\\": {\\\"status\\\": 0}, \\\"response\\\":{\\\"numFound\\\":\"+totalHits+\", \\\"docs\\\":[\");\n\n\n    //Write the data.\n    List<LeafReaderContext> leaves = req.getSearcher().getTopReaderContext().leaves();\n    SortDoc sortDoc = getSortDoc(req.getSearcher(), sort.getSort());\n    int count = 0;\n    int queueSize = 30000;\n    SortQueue queue = new SortQueue(queueSize, sortDoc);\n    SortDoc[] outDocs = new SortDoc[queueSize];\n\n    boolean commaNeeded = false;\n    while(count < totalHits) {\n      //long begin = System.nanoTime();\n      queue.reset();\n      SortDoc top = queue.top();\n      for(int i=0; i<leaves.size(); i++) {\n        sortDoc.setNextReader(leaves.get(i));\n        DocIdSetIterator it = new BitSetIterator(sets[i], 0); // cost is not useful here\n        int docId = -1;\n        while((docId = it.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          sortDoc.setValues(docId);\n          if(top.lessThan(sortDoc)) {\n            top.setValues(sortDoc);\n            top = queue.updateTop();\n          }\n        }\n      }\n\n      int outDocsIndex = -1;\n\n      for(int i=0; i<queueSize; i++) {\n        SortDoc s = queue.pop();\n        if(s.docId > -1) {\n          outDocs[++outDocsIndex] = s;\n        }\n      }\n\n     //long end = System.nanoTime();\n\n      count += (outDocsIndex+1);\n\n      try {\n        for(int i=outDocsIndex; i>=0; --i) {\n          SortDoc s = outDocs[i];\n          if(commaNeeded){writer.write(',');}\n          writer.write('{');\n          writeDoc(s, leaves, fieldWriters, sets, writer);\n          writer.write('}');\n          commaNeeded = true;\n          s.reset();\n        }\n      } catch(Throwable e) {\n        Throwable ex = e;\n        e.printStackTrace();\n        while(ex != null) {\n          String m = ex.getMessage();\n          if(m != null && m.contains(\"Broken pipe\")) {\n            throw new IgnoreException();\n          }\n          ex = ex.getCause();\n        }\n\n        if(e instanceof IOException) {\n          throw ((IOException)e);\n        } else {\n          throw new IOException(e);\n        }\n      }\n    }\n\n    //System.out.println(\"Sort Time 2:\"+Long.toString(total/1000000));\n    writer.write(\"]}}\");\n    writer.flush();\n  }\n\n","sourceOld":"  public void write(Writer writer, SolrQueryRequest req, SolrQueryResponse res) throws IOException {\n    Exception e1 = res.getException();\n    if(e1 != null) {\n      if(!(e1 instanceof IgnoreException)) {\n        writeException(e1, writer, false);\n      }\n      return;\n    }\n\n    SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n    SortSpec sortSpec = info.getResponseBuilder().getSortSpec();\n    Exception exception = null;\n\n    if(sortSpec == null) {\n      exception = new IOException(new SyntaxError(\"No sort criteria was provided.\"));\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Sort sort = searcher.weightSort(sortSpec.getSort());\n\n    if(sort == null) {\n      exception = new IOException(new SyntaxError(\"No sort criteria was provided.\"));\n    }\n\n    if(sort != null && sort.needsScores()) {\n      exception = new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"));\n    }\n\n    // There is a bailout in SolrIndexSearcher.getDocListNC when there are _no_ docs in the index at all.\n    // if (lastDocRequested <= 0) {\n    // That causes the totalHits and export entries in the context to _not_ get set.\n    // The only time that really matters is when we search against an _empty_ set. That's too obscure\n    // a condition to handle as part of this patch, if someone wants to pursue it it can be reproduced with:\n    // ant test  -Dtestcase=StreamingTest -Dtests.method=testAllValidExportTypes -Dtests.seed=10F13879D0D1D6AD -Dtests.slow=true -Dtests.locale=es-PA -Dtests.timezone=America/Bahia_Banderas -Dtests.asserts=true -Dtests.file.encoding=ISO-8859-1\n    // You'll have to uncomment the if below to hit the null pointer exception.\n    // This is such an unusual case (i.e. an empty index) that catching this concdition here is probably OK.\n    // This came to light in the very artifical case of indexing a single doc to Cloud.\n    int totalHits = 0;\n    FixedBitSet[] sets = null;\n    if (req.getContext().get(\"totalHits\") != null) {\n      totalHits = ((Integer)req.getContext().get(\"totalHits\")).intValue();\n      sets = (FixedBitSet[]) req.getContext().get(\"export\");\n      if (sets == null) {\n        exception = new IOException(new SyntaxError(\"xport RankQuery is required for xsort: rq={!xport}\"));\n      }\n    }\n    SolrParams params = req.getParams();\n    String fl = params.get(\"fl\");\n\n    String[] fields = null;\n\n    if(fl == null) {\n      exception = new IOException(new SyntaxError(\"export field list (fl) must be specified.\"));\n    } else  {\n      fields = fl.split(\",\");\n\n      for(int i=0;i<fields.length; i++) {\n\n        fields[i] = fields[i].trim();\n\n        if(fields[i].equals(\"score\")) {\n          exception =  new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"));\n          break;\n        }\n      }\n    }\n\n    FieldWriter[] fieldWriters = null;\n\n    try {\n      fieldWriters = getFieldWriters(fields, req.getSearcher());\n    } catch (Exception e) {\n      exception = e;\n    }\n\n\n    if(exception != null) {\n      writeException(exception, writer, true);\n      return;\n    }\n\n    writer.write(\"{\\\"responseHeader\\\": {\\\"status\\\": 0}, \\\"response\\\":{\\\"numFound\\\":\"+totalHits+\", \\\"docs\\\":[\");\n\n\n    //Write the data.\n    List<LeafReaderContext> leaves = req.getSearcher().getTopReaderContext().leaves();\n    SortDoc sortDoc = getSortDoc(req.getSearcher(), sort.getSort());\n    int count = 0;\n    int queueSize = 30000;\n    SortQueue queue = new SortQueue(queueSize, sortDoc);\n    SortDoc[] outDocs = new SortDoc[queueSize];\n\n    boolean commaNeeded = false;\n    while(count < totalHits) {\n      //long begin = System.nanoTime();\n      queue.reset();\n      SortDoc top = queue.top();\n      for(int i=0; i<leaves.size(); i++) {\n        sortDoc.setNextReader(leaves.get(i));\n        DocIdSetIterator it = new BitSetIterator(sets[i], 0); // cost is not useful here\n        int docId = -1;\n        while((docId = it.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          sortDoc.setValues(docId);\n          if(top.lessThan(sortDoc)) {\n            top.setValues(sortDoc);\n            top = queue.updateTop();\n          }\n        }\n      }\n\n      int outDocsIndex = -1;\n\n      for(int i=0; i<queueSize; i++) {\n        SortDoc s = queue.pop();\n        if(s.docId > -1) {\n          outDocs[++outDocsIndex] = s;\n        }\n      }\n\n     //long end = System.nanoTime();\n\n      count += (outDocsIndex+1);\n\n      try {\n        for(int i=outDocsIndex; i>=0; --i) {\n          SortDoc s = outDocs[i];\n          if(commaNeeded){writer.write(',');}\n          writer.write('{');\n          writeDoc(s, leaves, fieldWriters, sets, writer);\n          writer.write('}');\n          commaNeeded = true;\n          s.reset();\n        }\n      } catch(Throwable e) {\n        Throwable ex = e;\n        e.printStackTrace();\n        while(ex != null) {\n          String m = ex.getMessage();\n          if(m != null && m.contains(\"Broken pipe\")) {\n            throw new IgnoreException();\n          }\n          ex = ex.getCause();\n        }\n\n        if(e instanceof IOException) {\n          throw ((IOException)e);\n        } else {\n          throw new IOException(e);\n        }\n      }\n    }\n\n    //System.out.println(\"Sort Time 2:\"+Long.toString(total/1000000));\n    writer.write(\"]}}\");\n    writer.flush();\n  }\n\n","bugFix":["8da9a71da64ce12a97dcfcdd912893aeb1fa2981","d12ee9465d37a9eedeee8a630aa7551b013cd4e4","901b27c7f633ab98e138aafb0b9c3ba22aac6b28","a55bf71f91aeded06b44ad1abea6666ea168b697","7f1f5e4b31ec44927335e2ad6eebc4c1f8c0abf5"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"320888923ec13b91f53082558f01f4c9960dd226","date":1477926871,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/response/SortingResponseWriter#write(Writer,SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/SortingResponseWriter#write(Writer,SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  public void write(Writer writer, SolrQueryRequest req, SolrQueryResponse res) throws IOException {\n    Exception e1 = res.getException();\n    if(e1 != null) {\n      if(!(e1 instanceof IgnoreException)) {\n        writeException(e1, writer, false);\n      }\n      return;\n    }\n\n    SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n    SortSpec sortSpec = info.getResponseBuilder().getSortSpec();\n\n    if(sortSpec == null) {\n      writeException((new IOException(new SyntaxError(\"No sort criteria was provided.\"))), writer, true);\n      return;\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Sort sort = searcher.weightSort(sortSpec.getSort());\n\n    if(sort == null) {\n      writeException((new IOException(new SyntaxError(\"No sort criteria was provided.\"))), writer, true);\n      return;\n    }\n\n    if(sort != null && sort.needsScores()) {\n      writeException((new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"))), writer, true);\n      return;\n    }\n\n    // There is a bailout in SolrIndexSearcher.getDocListNC when there are _no_ docs in the index at all.\n    // if (lastDocRequested <= 0) {\n    // That causes the totalHits and export entries in the context to _not_ get set.\n    // The only time that really matters is when we search against an _empty_ set. That's too obscure\n    // a condition to handle as part of this patch, if someone wants to pursue it it can be reproduced with:\n    // ant test  -Dtestcase=StreamingTest -Dtests.method=testAllValidExportTypes -Dtests.seed=10F13879D0D1D6AD -Dtests.slow=true -Dtests.locale=es-PA -Dtests.timezone=America/Bahia_Banderas -Dtests.asserts=true -Dtests.file.encoding=ISO-8859-1\n    // You'll have to uncomment the if below to hit the null pointer exception.\n    // This is such an unusual case (i.e. an empty index) that catching this concdition here is probably OK.\n    // This came to light in the very artifical case of indexing a single doc to Cloud.\n    int totalHits = 0;\n    FixedBitSet[] sets = null;\n    if (req.getContext().get(\"totalHits\") != null) {\n      totalHits = ((Integer)req.getContext().get(\"totalHits\")).intValue();\n      sets = (FixedBitSet[]) req.getContext().get(\"export\");\n      if (sets == null) {\n        writeException((new IOException(new SyntaxError(\"xport RankQuery is required for xsort: rq={!xport}\"))), writer, true);\n        return;\n      }\n    }\n    SolrParams params = req.getParams();\n    String fl = params.get(\"fl\");\n\n    String[] fields = null;\n\n    if(fl == null) {\n      writeException((new IOException(new SyntaxError(\"export field list (fl) must be specified.\"))), writer, true);\n      return;\n    } else  {\n      fields = fl.split(\",\");\n\n      for(int i=0;i<fields.length; i++) {\n\n        fields[i] = fields[i].trim();\n\n        if(fields[i].equals(\"score\")) {\n          writeException((new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"))), writer, true);\n          return;\n        }\n      }\n    }\n\n    FieldWriter[] fieldWriters = null;\n\n    try {\n      fieldWriters = getFieldWriters(fields, req.getSearcher());\n    } catch (Exception e) {\n      writeException(e, writer, true);\n      return;\n    }\n\n    writer.write(\"{\\\"responseHeader\\\": {\\\"status\\\": 0}, \\\"response\\\":{\\\"numFound\\\":\"+totalHits+\", \\\"docs\\\":[\");\n\n\n    //Write the data.\n    List<LeafReaderContext> leaves = req.getSearcher().getTopReaderContext().leaves();\n    SortDoc sortDoc = getSortDoc(req.getSearcher(), sort.getSort());\n    int count = 0;\n    int queueSize = 30000;\n    SortQueue queue = new SortQueue(queueSize, sortDoc);\n    SortDoc[] outDocs = new SortDoc[queueSize];\n\n    boolean commaNeeded = false;\n    while(count < totalHits) {\n      //long begin = System.nanoTime();\n      queue.reset();\n      SortDoc top = queue.top();\n      for(int i=0; i<leaves.size(); i++) {\n        sortDoc.setNextReader(leaves.get(i));\n        DocIdSetIterator it = new BitSetIterator(sets[i], 0); // cost is not useful here\n        int docId = -1;\n        while((docId = it.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          sortDoc.setValues(docId);\n          if(top.lessThan(sortDoc)) {\n            top.setValues(sortDoc);\n            top = queue.updateTop();\n          }\n        }\n      }\n\n      int outDocsIndex = -1;\n\n      for(int i=0; i<queueSize; i++) {\n        SortDoc s = queue.pop();\n        if(s.docId > -1) {\n          outDocs[++outDocsIndex] = s;\n        }\n      }\n\n     //long end = System.nanoTime();\n\n      count += (outDocsIndex+1);\n\n      try {\n        for(int i=outDocsIndex; i>=0; --i) {\n          SortDoc s = outDocs[i];\n          if(commaNeeded){writer.write(',');}\n          writer.write('{');\n          writeDoc(s, leaves, fieldWriters, sets, writer);\n          writer.write('}');\n          commaNeeded = true;\n          s.reset();\n        }\n      } catch(Throwable e) {\n        Throwable ex = e;\n        e.printStackTrace();\n        while(ex != null) {\n          String m = ex.getMessage();\n          if(m != null && m.contains(\"Broken pipe\")) {\n            throw new IgnoreException();\n          }\n          ex = ex.getCause();\n        }\n\n        if(e instanceof IOException) {\n          throw ((IOException)e);\n        } else {\n          throw new IOException(e);\n        }\n      }\n    }\n\n    //System.out.println(\"Sort Time 2:\"+Long.toString(total/1000000));\n    writer.write(\"]}}\");\n    writer.flush();\n  }\n\n","sourceOld":"  public void write(Writer writer, SolrQueryRequest req, SolrQueryResponse res) throws IOException {\n    Exception e1 = res.getException();\n    if(e1 != null) {\n      if(!(e1 instanceof IgnoreException)) {\n        writeException(e1, writer, false);\n      }\n      return;\n    }\n\n    SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n    SortSpec sortSpec = info.getResponseBuilder().getSortSpec();\n    Exception exception = null;\n\n    if(sortSpec == null) {\n      exception = new IOException(new SyntaxError(\"No sort criteria was provided.\"));\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Sort sort = searcher.weightSort(sortSpec.getSort());\n\n    if(sort == null) {\n      exception = new IOException(new SyntaxError(\"No sort criteria was provided.\"));\n    }\n\n    if(sort != null && sort.needsScores()) {\n      exception = new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"));\n    }\n\n    // There is a bailout in SolrIndexSearcher.getDocListNC when there are _no_ docs in the index at all.\n    // if (lastDocRequested <= 0) {\n    // That causes the totalHits and export entries in the context to _not_ get set.\n    // The only time that really matters is when we search against an _empty_ set. That's too obscure\n    // a condition to handle as part of this patch, if someone wants to pursue it it can be reproduced with:\n    // ant test  -Dtestcase=StreamingTest -Dtests.method=testAllValidExportTypes -Dtests.seed=10F13879D0D1D6AD -Dtests.slow=true -Dtests.locale=es-PA -Dtests.timezone=America/Bahia_Banderas -Dtests.asserts=true -Dtests.file.encoding=ISO-8859-1\n    // You'll have to uncomment the if below to hit the null pointer exception.\n    // This is such an unusual case (i.e. an empty index) that catching this concdition here is probably OK.\n    // This came to light in the very artifical case of indexing a single doc to Cloud.\n    int totalHits = 0;\n    FixedBitSet[] sets = null;\n    if (req.getContext().get(\"totalHits\") != null) {\n      totalHits = ((Integer)req.getContext().get(\"totalHits\")).intValue();\n      sets = (FixedBitSet[]) req.getContext().get(\"export\");\n      if (sets == null) {\n        exception = new IOException(new SyntaxError(\"xport RankQuery is required for xsort: rq={!xport}\"));\n      }\n    }\n    SolrParams params = req.getParams();\n    String fl = params.get(\"fl\");\n\n    String[] fields = null;\n\n    if(fl == null) {\n      exception = new IOException(new SyntaxError(\"export field list (fl) must be specified.\"));\n    } else  {\n      fields = fl.split(\",\");\n\n      for(int i=0;i<fields.length; i++) {\n\n        fields[i] = fields[i].trim();\n\n        if(fields[i].equals(\"score\")) {\n          exception =  new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"));\n          break;\n        }\n      }\n    }\n\n    FieldWriter[] fieldWriters = null;\n\n    try {\n      fieldWriters = getFieldWriters(fields, req.getSearcher());\n    } catch (Exception e) {\n      exception = e;\n    }\n\n\n    if(exception != null) {\n      writeException(exception, writer, true);\n      return;\n    }\n\n    writer.write(\"{\\\"responseHeader\\\": {\\\"status\\\": 0}, \\\"response\\\":{\\\"numFound\\\":\"+totalHits+\", \\\"docs\\\":[\");\n\n\n    //Write the data.\n    List<LeafReaderContext> leaves = req.getSearcher().getTopReaderContext().leaves();\n    SortDoc sortDoc = getSortDoc(req.getSearcher(), sort.getSort());\n    int count = 0;\n    int queueSize = 30000;\n    SortQueue queue = new SortQueue(queueSize, sortDoc);\n    SortDoc[] outDocs = new SortDoc[queueSize];\n\n    boolean commaNeeded = false;\n    while(count < totalHits) {\n      //long begin = System.nanoTime();\n      queue.reset();\n      SortDoc top = queue.top();\n      for(int i=0; i<leaves.size(); i++) {\n        sortDoc.setNextReader(leaves.get(i));\n        DocIdSetIterator it = new BitSetIterator(sets[i], 0); // cost is not useful here\n        int docId = -1;\n        while((docId = it.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          sortDoc.setValues(docId);\n          if(top.lessThan(sortDoc)) {\n            top.setValues(sortDoc);\n            top = queue.updateTop();\n          }\n        }\n      }\n\n      int outDocsIndex = -1;\n\n      for(int i=0; i<queueSize; i++) {\n        SortDoc s = queue.pop();\n        if(s.docId > -1) {\n          outDocs[++outDocsIndex] = s;\n        }\n      }\n\n     //long end = System.nanoTime();\n\n      count += (outDocsIndex+1);\n\n      try {\n        for(int i=outDocsIndex; i>=0; --i) {\n          SortDoc s = outDocs[i];\n          if(commaNeeded){writer.write(',');}\n          writer.write('{');\n          writeDoc(s, leaves, fieldWriters, sets, writer);\n          writer.write('}');\n          commaNeeded = true;\n          s.reset();\n        }\n      } catch(Throwable e) {\n        Throwable ex = e;\n        e.printStackTrace();\n        while(ex != null) {\n          String m = ex.getMessage();\n          if(m != null && m.contains(\"Broken pipe\")) {\n            throw new IgnoreException();\n          }\n          ex = ex.getCause();\n        }\n\n        if(e instanceof IOException) {\n          throw ((IOException)e);\n        } else {\n          throw new IOException(e);\n        }\n      }\n    }\n\n    //System.out.println(\"Sort Time 2:\"+Long.toString(total/1000000));\n    writer.write(\"]}}\");\n    writer.flush();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"50f05d6b69cfaabd51b5d26cba4e3122f51fff83","date":1478603228,"type":5,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SortingResponseWriter[ExportWriter]#write(Writer,SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/SortingResponseWriter#write(Writer,SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  public void write(Writer writer, SolrQueryRequest req, SolrQueryResponse res) throws IOException {\n    Exception e1 = res.getException();\n    if(e1 != null) {\n      if(!(e1 instanceof IgnoreException)) {\n        writeException(e1, writer, false);\n      }\n      return;\n    }\n\n    SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n    SortSpec sortSpec = info.getResponseBuilder().getSortSpec();\n\n    if(sortSpec == null) {\n      writeException((new IOException(new SyntaxError(\"No sort criteria was provided.\"))), writer, true);\n      return;\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Sort sort = searcher.weightSort(sortSpec.getSort());\n\n    if(sort == null) {\n      writeException((new IOException(new SyntaxError(\"No sort criteria was provided.\"))), writer, true);\n      return;\n    }\n\n    if(sort != null && sort.needsScores()) {\n      writeException((new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"))), writer, true);\n      return;\n    }\n\n    // There is a bailout in SolrIndexSearcher.getDocListNC when there are _no_ docs in the index at all.\n    // if (lastDocRequested <= 0) {\n    // That causes the totalHits and export entries in the context to _not_ get set.\n    // The only time that really matters is when we search against an _empty_ set. That's too obscure\n    // a condition to handle as part of this patch, if someone wants to pursue it it can be reproduced with:\n    // ant test  -Dtestcase=StreamingTest -Dtests.method=testAllValidExportTypes -Dtests.seed=10F13879D0D1D6AD -Dtests.slow=true -Dtests.locale=es-PA -Dtests.timezone=America/Bahia_Banderas -Dtests.asserts=true -Dtests.file.encoding=ISO-8859-1\n    // You'll have to uncomment the if below to hit the null pointer exception.\n    // This is such an unusual case (i.e. an empty index) that catching this concdition here is probably OK.\n    // This came to light in the very artifical case of indexing a single doc to Cloud.\n    int totalHits = 0;\n    FixedBitSet[] sets = null;\n    if (req.getContext().get(\"totalHits\") != null) {\n      totalHits = ((Integer)req.getContext().get(\"totalHits\")).intValue();\n      sets = (FixedBitSet[]) req.getContext().get(\"export\");\n      if (sets == null) {\n        writeException((new IOException(new SyntaxError(\"xport RankQuery is required for xsort: rq={!xport}\"))), writer, true);\n        return;\n      }\n    }\n    SolrParams params = req.getParams();\n    String fl = params.get(\"fl\");\n\n    String[] fields = null;\n\n    if(fl == null) {\n      writeException((new IOException(new SyntaxError(\"export field list (fl) must be specified.\"))), writer, true);\n      return;\n    } else  {\n      fields = fl.split(\",\");\n\n      for(int i=0;i<fields.length; i++) {\n\n        fields[i] = fields[i].trim();\n\n        if(fields[i].equals(\"score\")) {\n          writeException((new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"))), writer, true);\n          return;\n        }\n      }\n    }\n\n    FieldWriter[] fieldWriters = null;\n\n    try {\n      fieldWriters = getFieldWriters(fields, req.getSearcher());\n    } catch (Exception e) {\n      writeException(e, writer, true);\n      return;\n    }\n\n    writer.write(\"{\\\"responseHeader\\\": {\\\"status\\\": 0}, \\\"response\\\":{\\\"numFound\\\":\"+totalHits+\", \\\"docs\\\":[\");\n\n\n    //Write the data.\n    List<LeafReaderContext> leaves = req.getSearcher().getTopReaderContext().leaves();\n    SortDoc sortDoc = getSortDoc(req.getSearcher(), sort.getSort());\n    int count = 0;\n    int queueSize = 30000;\n    SortQueue queue = new SortQueue(queueSize, sortDoc);\n    SortDoc[] outDocs = new SortDoc[queueSize];\n\n    boolean commaNeeded = false;\n    while(count < totalHits) {\n      //long begin = System.nanoTime();\n      queue.reset();\n      SortDoc top = queue.top();\n      for(int i=0; i<leaves.size(); i++) {\n        sortDoc.setNextReader(leaves.get(i));\n        DocIdSetIterator it = new BitSetIterator(sets[i], 0); // cost is not useful here\n        int docId = -1;\n        while((docId = it.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          sortDoc.setValues(docId);\n          if(top.lessThan(sortDoc)) {\n            top.setValues(sortDoc);\n            top = queue.updateTop();\n          }\n        }\n      }\n\n      int outDocsIndex = -1;\n\n      for(int i=0; i<queueSize; i++) {\n        SortDoc s = queue.pop();\n        if(s.docId > -1) {\n          outDocs[++outDocsIndex] = s;\n        }\n      }\n\n     //long end = System.nanoTime();\n\n      count += (outDocsIndex+1);\n\n      try {\n        for(int i=outDocsIndex; i>=0; --i) {\n          SortDoc s = outDocs[i];\n          if(commaNeeded){writer.write(',');}\n          writer.write('{');\n          writeDoc(s, leaves, fieldWriters, sets, writer);\n          writer.write('}');\n          commaNeeded = true;\n          s.reset();\n        }\n      } catch(Throwable e) {\n        Throwable ex = e;\n        e.printStackTrace();\n        while(ex != null) {\n          String m = ex.getMessage();\n          if(m != null && m.contains(\"Broken pipe\")) {\n            throw new IgnoreException();\n          }\n          ex = ex.getCause();\n        }\n\n        if(e instanceof IOException) {\n          throw ((IOException)e);\n        } else {\n          throw new IOException(e);\n        }\n      }\n    }\n\n    //System.out.println(\"Sort Time 2:\"+Long.toString(total/1000000));\n    writer.write(\"]}}\");\n    writer.flush();\n  }\n\n","sourceOld":"  public void write(Writer writer, SolrQueryRequest req, SolrQueryResponse res) throws IOException {\n    Exception e1 = res.getException();\n    if(e1 != null) {\n      if(!(e1 instanceof IgnoreException)) {\n        writeException(e1, writer, false);\n      }\n      return;\n    }\n\n    SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n    SortSpec sortSpec = info.getResponseBuilder().getSortSpec();\n\n    if(sortSpec == null) {\n      writeException((new IOException(new SyntaxError(\"No sort criteria was provided.\"))), writer, true);\n      return;\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Sort sort = searcher.weightSort(sortSpec.getSort());\n\n    if(sort == null) {\n      writeException((new IOException(new SyntaxError(\"No sort criteria was provided.\"))), writer, true);\n      return;\n    }\n\n    if(sort != null && sort.needsScores()) {\n      writeException((new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"))), writer, true);\n      return;\n    }\n\n    // There is a bailout in SolrIndexSearcher.getDocListNC when there are _no_ docs in the index at all.\n    // if (lastDocRequested <= 0) {\n    // That causes the totalHits and export entries in the context to _not_ get set.\n    // The only time that really matters is when we search against an _empty_ set. That's too obscure\n    // a condition to handle as part of this patch, if someone wants to pursue it it can be reproduced with:\n    // ant test  -Dtestcase=StreamingTest -Dtests.method=testAllValidExportTypes -Dtests.seed=10F13879D0D1D6AD -Dtests.slow=true -Dtests.locale=es-PA -Dtests.timezone=America/Bahia_Banderas -Dtests.asserts=true -Dtests.file.encoding=ISO-8859-1\n    // You'll have to uncomment the if below to hit the null pointer exception.\n    // This is such an unusual case (i.e. an empty index) that catching this concdition here is probably OK.\n    // This came to light in the very artifical case of indexing a single doc to Cloud.\n    int totalHits = 0;\n    FixedBitSet[] sets = null;\n    if (req.getContext().get(\"totalHits\") != null) {\n      totalHits = ((Integer)req.getContext().get(\"totalHits\")).intValue();\n      sets = (FixedBitSet[]) req.getContext().get(\"export\");\n      if (sets == null) {\n        writeException((new IOException(new SyntaxError(\"xport RankQuery is required for xsort: rq={!xport}\"))), writer, true);\n        return;\n      }\n    }\n    SolrParams params = req.getParams();\n    String fl = params.get(\"fl\");\n\n    String[] fields = null;\n\n    if(fl == null) {\n      writeException((new IOException(new SyntaxError(\"export field list (fl) must be specified.\"))), writer, true);\n      return;\n    } else  {\n      fields = fl.split(\",\");\n\n      for(int i=0;i<fields.length; i++) {\n\n        fields[i] = fields[i].trim();\n\n        if(fields[i].equals(\"score\")) {\n          writeException((new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"))), writer, true);\n          return;\n        }\n      }\n    }\n\n    FieldWriter[] fieldWriters = null;\n\n    try {\n      fieldWriters = getFieldWriters(fields, req.getSearcher());\n    } catch (Exception e) {\n      writeException(e, writer, true);\n      return;\n    }\n\n    writer.write(\"{\\\"responseHeader\\\": {\\\"status\\\": 0}, \\\"response\\\":{\\\"numFound\\\":\"+totalHits+\", \\\"docs\\\":[\");\n\n\n    //Write the data.\n    List<LeafReaderContext> leaves = req.getSearcher().getTopReaderContext().leaves();\n    SortDoc sortDoc = getSortDoc(req.getSearcher(), sort.getSort());\n    int count = 0;\n    int queueSize = 30000;\n    SortQueue queue = new SortQueue(queueSize, sortDoc);\n    SortDoc[] outDocs = new SortDoc[queueSize];\n\n    boolean commaNeeded = false;\n    while(count < totalHits) {\n      //long begin = System.nanoTime();\n      queue.reset();\n      SortDoc top = queue.top();\n      for(int i=0; i<leaves.size(); i++) {\n        sortDoc.setNextReader(leaves.get(i));\n        DocIdSetIterator it = new BitSetIterator(sets[i], 0); // cost is not useful here\n        int docId = -1;\n        while((docId = it.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          sortDoc.setValues(docId);\n          if(top.lessThan(sortDoc)) {\n            top.setValues(sortDoc);\n            top = queue.updateTop();\n          }\n        }\n      }\n\n      int outDocsIndex = -1;\n\n      for(int i=0; i<queueSize; i++) {\n        SortDoc s = queue.pop();\n        if(s.docId > -1) {\n          outDocs[++outDocsIndex] = s;\n        }\n      }\n\n     //long end = System.nanoTime();\n\n      count += (outDocsIndex+1);\n\n      try {\n        for(int i=outDocsIndex; i>=0; --i) {\n          SortDoc s = outDocs[i];\n          if(commaNeeded){writer.write(',');}\n          writer.write('{');\n          writeDoc(s, leaves, fieldWriters, sets, writer);\n          writer.write('}');\n          commaNeeded = true;\n          s.reset();\n        }\n      } catch(Throwable e) {\n        Throwable ex = e;\n        e.printStackTrace();\n        while(ex != null) {\n          String m = ex.getMessage();\n          if(m != null && m.contains(\"Broken pipe\")) {\n            throw new IgnoreException();\n          }\n          ex = ex.getCause();\n        }\n\n        if(e instanceof IOException) {\n          throw ((IOException)e);\n        } else {\n          throw new IOException(e);\n        }\n      }\n    }\n\n    //System.out.println(\"Sort Time 2:\"+Long.toString(total/1000000));\n    writer.write(\"]}}\");\n    writer.flush();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"199dfa410f1fdbfd3294106b04096cce5ed34b21","date":1478812506,"type":5,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/ExportWriter#write(OutputStream).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/SortingResponseWriter#write(Writer,SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  public void write(OutputStream os) throws IOException {\n    respWriter = new OutputStreamWriter(os, StandardCharsets.UTF_8);\n    writer = JSONResponseWriter.getPushWriter(respWriter, req, res);\n    Exception exception = res.getException();\n    if (exception != null) {\n      if (!(exception instanceof IgnoreException)) {\n        writeException(exception, writer, false);\n      }\n      return;\n    }\n\n    SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n    SortSpec sortSpec = info.getResponseBuilder().getSortSpec();\n\n    if(sortSpec == null) {\n      writeException((new IOException(new SyntaxError(\"No sort criteria was provided.\"))), writer, true);\n      return;\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Sort sort = searcher.weightSort(sortSpec.getSort());\n\n    if(sort == null) {\n      writeException((new IOException(new SyntaxError(\"No sort criteria was provided.\"))), writer, true);\n      return;\n    }\n\n    if(sort != null && sort.needsScores()) {\n      writeException((new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"))), writer, true);\n      return;\n    }\n\n    // There is a bailout in SolrIndexSearcher.getDocListNC when there are _no_ docs in the index at all.\n    // if (lastDocRequested <= 0) {\n    // That causes the totalHits and export entries in the context to _not_ get set.\n    // The only time that really matters is when we search against an _empty_ set. That's too obscure\n    // a condition to handle as part of this patch, if someone wants to pursue it it can be reproduced with:\n    // ant test  -Dtestcase=StreamingTest -Dtests.method=testAllValidExportTypes -Dtests.seed=10F13879D0D1D6AD -Dtests.slow=true -Dtests.locale=es-PA -Dtests.timezone=America/Bahia_Banderas -Dtests.asserts=true -Dtests.file.encoding=ISO-8859-1\n    // You'll have to uncomment the if below to hit the null pointer exception.\n    // This is such an unusual case (i.e. an empty index) that catching this concdition here is probably OK.\n    // This came to light in the very artifical case of indexing a single doc to Cloud.\n    if (req.getContext().get(\"totalHits\") != null) {\n      totalHits = ((Integer)req.getContext().get(\"totalHits\")).intValue();\n      sets = (FixedBitSet[]) req.getContext().get(\"export\");\n      if (sets == null) {\n        writeException((new IOException(new SyntaxError(\"xport RankQuery is required for xsort: rq={!xport}\"))), writer, true);\n        return;\n      }\n    }\n    SolrParams params = req.getParams();\n    String fl = params.get(\"fl\");\n\n    String[] fields = null;\n\n    if(fl == null) {\n      writeException((new IOException(new SyntaxError(\"export field list (fl) must be specified.\"))), writer, true);\n      return;\n    } else  {\n      fields = fl.split(\",\");\n\n      for(int i=0;i<fields.length; i++) {\n\n        fields[i] = fields[i].trim();\n\n        if(fields[i].equals(\"score\")) {\n          writeException((new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"))), writer, true);\n          return;\n        }\n      }\n    }\n\n    try {\n      fieldWriters = getFieldWriters(fields, req.getSearcher());\n    } catch (Exception e) {\n      writeException(e, writer, true);\n      return;\n    }\n\n    writer.writeMap(m -> {\n      m.put(\"responseHeader\", singletonMap(\"status\", 0));\n      m.put(\"response\", (MapWriter) mw -> {\n        mw.put(\"numFound\", totalHits);\n        mw.put(\"docs\", (IteratorWriter) iw -> writeDocs(req, iw, sort));\n      });\n    });\n\n  }\n\n","sourceOld":"  public void write(Writer writer, SolrQueryRequest req, SolrQueryResponse res) throws IOException {\n    Exception e1 = res.getException();\n    if(e1 != null) {\n      if(!(e1 instanceof IgnoreException)) {\n        writeException(e1, writer, false);\n      }\n      return;\n    }\n\n    SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n    SortSpec sortSpec = info.getResponseBuilder().getSortSpec();\n\n    if(sortSpec == null) {\n      writeException((new IOException(new SyntaxError(\"No sort criteria was provided.\"))), writer, true);\n      return;\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Sort sort = searcher.weightSort(sortSpec.getSort());\n\n    if(sort == null) {\n      writeException((new IOException(new SyntaxError(\"No sort criteria was provided.\"))), writer, true);\n      return;\n    }\n\n    if(sort != null && sort.needsScores()) {\n      writeException((new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"))), writer, true);\n      return;\n    }\n\n    // There is a bailout in SolrIndexSearcher.getDocListNC when there are _no_ docs in the index at all.\n    // if (lastDocRequested <= 0) {\n    // That causes the totalHits and export entries in the context to _not_ get set.\n    // The only time that really matters is when we search against an _empty_ set. That's too obscure\n    // a condition to handle as part of this patch, if someone wants to pursue it it can be reproduced with:\n    // ant test  -Dtestcase=StreamingTest -Dtests.method=testAllValidExportTypes -Dtests.seed=10F13879D0D1D6AD -Dtests.slow=true -Dtests.locale=es-PA -Dtests.timezone=America/Bahia_Banderas -Dtests.asserts=true -Dtests.file.encoding=ISO-8859-1\n    // You'll have to uncomment the if below to hit the null pointer exception.\n    // This is such an unusual case (i.e. an empty index) that catching this concdition here is probably OK.\n    // This came to light in the very artifical case of indexing a single doc to Cloud.\n    int totalHits = 0;\n    FixedBitSet[] sets = null;\n    if (req.getContext().get(\"totalHits\") != null) {\n      totalHits = ((Integer)req.getContext().get(\"totalHits\")).intValue();\n      sets = (FixedBitSet[]) req.getContext().get(\"export\");\n      if (sets == null) {\n        writeException((new IOException(new SyntaxError(\"xport RankQuery is required for xsort: rq={!xport}\"))), writer, true);\n        return;\n      }\n    }\n    SolrParams params = req.getParams();\n    String fl = params.get(\"fl\");\n\n    String[] fields = null;\n\n    if(fl == null) {\n      writeException((new IOException(new SyntaxError(\"export field list (fl) must be specified.\"))), writer, true);\n      return;\n    } else  {\n      fields = fl.split(\",\");\n\n      for(int i=0;i<fields.length; i++) {\n\n        fields[i] = fields[i].trim();\n\n        if(fields[i].equals(\"score\")) {\n          writeException((new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"))), writer, true);\n          return;\n        }\n      }\n    }\n\n    FieldWriter[] fieldWriters = null;\n\n    try {\n      fieldWriters = getFieldWriters(fields, req.getSearcher());\n    } catch (Exception e) {\n      writeException(e, writer, true);\n      return;\n    }\n\n    writer.write(\"{\\\"responseHeader\\\": {\\\"status\\\": 0}, \\\"response\\\":{\\\"numFound\\\":\"+totalHits+\", \\\"docs\\\":[\");\n\n\n    //Write the data.\n    List<LeafReaderContext> leaves = req.getSearcher().getTopReaderContext().leaves();\n    SortDoc sortDoc = getSortDoc(req.getSearcher(), sort.getSort());\n    int count = 0;\n    int queueSize = 30000;\n    SortQueue queue = new SortQueue(queueSize, sortDoc);\n    SortDoc[] outDocs = new SortDoc[queueSize];\n\n    boolean commaNeeded = false;\n    while(count < totalHits) {\n      //long begin = System.nanoTime();\n      queue.reset();\n      SortDoc top = queue.top();\n      for(int i=0; i<leaves.size(); i++) {\n        sortDoc.setNextReader(leaves.get(i));\n        DocIdSetIterator it = new BitSetIterator(sets[i], 0); // cost is not useful here\n        int docId = -1;\n        while((docId = it.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          sortDoc.setValues(docId);\n          if(top.lessThan(sortDoc)) {\n            top.setValues(sortDoc);\n            top = queue.updateTop();\n          }\n        }\n      }\n\n      int outDocsIndex = -1;\n\n      for(int i=0; i<queueSize; i++) {\n        SortDoc s = queue.pop();\n        if(s.docId > -1) {\n          outDocs[++outDocsIndex] = s;\n        }\n      }\n\n     //long end = System.nanoTime();\n\n      count += (outDocsIndex+1);\n\n      try {\n        for(int i=outDocsIndex; i>=0; --i) {\n          SortDoc s = outDocs[i];\n          if(commaNeeded){writer.write(',');}\n          writer.write('{');\n          writeDoc(s, leaves, fieldWriters, sets, writer);\n          writer.write('}');\n          commaNeeded = true;\n          s.reset();\n        }\n      } catch(Throwable e) {\n        Throwable ex = e;\n        e.printStackTrace();\n        while(ex != null) {\n          String m = ex.getMessage();\n          if(m != null && m.contains(\"Broken pipe\")) {\n            throw new IgnoreException();\n          }\n          ex = ex.getCause();\n        }\n\n        if(e instanceof IOException) {\n          throw ((IOException)e);\n        } else {\n          throw new IOException(e);\n        }\n      }\n    }\n\n    //System.out.println(\"Sort Time 2:\"+Long.toString(total/1000000));\n    writer.write(\"]}}\");\n    writer.flush();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"199dfa410f1fdbfd3294106b04096cce5ed34b21","date":1478812506,"type":6,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/ExportWriter#writeDocs(SolrQueryRequest,IteratorWriter.ItemWriter,Sort).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/SortingResponseWriter#write(Writer,SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  protected void writeDocs(SolrQueryRequest req, IteratorWriter.ItemWriter writer, Sort sort) throws IOException {\n    //Write the data.\n    List<LeafReaderContext> leaves = req.getSearcher().getTopReaderContext().leaves();\n    SortDoc sortDoc = getSortDoc(req.getSearcher(), sort.getSort());\n    int count = 0;\n    int queueSize = 30000;\n    SortQueue queue = new SortQueue(queueSize, sortDoc);\n    SortDoc[] outDocs = new SortDoc[queueSize];\n\n    while(count < totalHits) {\n      //long begin = System.nanoTime();\n      queue.reset();\n      SortDoc top = queue.top();\n      for(int i=0; i<leaves.size(); i++) {\n        sortDoc.setNextReader(leaves.get(i));\n        DocIdSetIterator it = new BitSetIterator(sets[i], 0); // cost is not useful here\n        int docId = -1;\n        while((docId = it.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          sortDoc.setValues(docId);\n          if(top.lessThan(sortDoc)) {\n            top.setValues(sortDoc);\n            top = queue.updateTop();\n          }\n        }\n      }\n\n      int outDocsIndex = -1;\n\n      for(int i=0; i<queueSize; i++) {\n        SortDoc s = queue.pop();\n        if(s.docId > -1) {\n          outDocs[++outDocsIndex] = s;\n        }\n      }\n\n      //long end = System.nanoTime();\n\n      count += (outDocsIndex+1);\n\n      try {\n        for(int i=outDocsIndex; i>=0; --i) {\n          SortDoc s = outDocs[i];\n          writer.add((MapWriter) ew -> {\n            writeDoc(s, leaves, ew);\n            s.reset();\n          });\n        }\n      } catch(Throwable e) {\n        Throwable ex = e;\n        e.printStackTrace();\n        while(ex != null) {\n          String m = ex.getMessage();\n          if(m != null && m.contains(\"Broken pipe\")) {\n            throw new IgnoreException();\n          }\n          ex = ex.getCause();\n        }\n\n        if(e instanceof IOException) {\n          throw ((IOException)e);\n        } else {\n          throw new IOException(e);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void write(Writer writer, SolrQueryRequest req, SolrQueryResponse res) throws IOException {\n    Exception e1 = res.getException();\n    if(e1 != null) {\n      if(!(e1 instanceof IgnoreException)) {\n        writeException(e1, writer, false);\n      }\n      return;\n    }\n\n    SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n    SortSpec sortSpec = info.getResponseBuilder().getSortSpec();\n\n    if(sortSpec == null) {\n      writeException((new IOException(new SyntaxError(\"No sort criteria was provided.\"))), writer, true);\n      return;\n    }\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Sort sort = searcher.weightSort(sortSpec.getSort());\n\n    if(sort == null) {\n      writeException((new IOException(new SyntaxError(\"No sort criteria was provided.\"))), writer, true);\n      return;\n    }\n\n    if(sort != null && sort.needsScores()) {\n      writeException((new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"))), writer, true);\n      return;\n    }\n\n    // There is a bailout in SolrIndexSearcher.getDocListNC when there are _no_ docs in the index at all.\n    // if (lastDocRequested <= 0) {\n    // That causes the totalHits and export entries in the context to _not_ get set.\n    // The only time that really matters is when we search against an _empty_ set. That's too obscure\n    // a condition to handle as part of this patch, if someone wants to pursue it it can be reproduced with:\n    // ant test  -Dtestcase=StreamingTest -Dtests.method=testAllValidExportTypes -Dtests.seed=10F13879D0D1D6AD -Dtests.slow=true -Dtests.locale=es-PA -Dtests.timezone=America/Bahia_Banderas -Dtests.asserts=true -Dtests.file.encoding=ISO-8859-1\n    // You'll have to uncomment the if below to hit the null pointer exception.\n    // This is such an unusual case (i.e. an empty index) that catching this concdition here is probably OK.\n    // This came to light in the very artifical case of indexing a single doc to Cloud.\n    int totalHits = 0;\n    FixedBitSet[] sets = null;\n    if (req.getContext().get(\"totalHits\") != null) {\n      totalHits = ((Integer)req.getContext().get(\"totalHits\")).intValue();\n      sets = (FixedBitSet[]) req.getContext().get(\"export\");\n      if (sets == null) {\n        writeException((new IOException(new SyntaxError(\"xport RankQuery is required for xsort: rq={!xport}\"))), writer, true);\n        return;\n      }\n    }\n    SolrParams params = req.getParams();\n    String fl = params.get(\"fl\");\n\n    String[] fields = null;\n\n    if(fl == null) {\n      writeException((new IOException(new SyntaxError(\"export field list (fl) must be specified.\"))), writer, true);\n      return;\n    } else  {\n      fields = fl.split(\",\");\n\n      for(int i=0;i<fields.length; i++) {\n\n        fields[i] = fields[i].trim();\n\n        if(fields[i].equals(\"score\")) {\n          writeException((new IOException(new SyntaxError(\"Scoring is not currently supported with xsort.\"))), writer, true);\n          return;\n        }\n      }\n    }\n\n    FieldWriter[] fieldWriters = null;\n\n    try {\n      fieldWriters = getFieldWriters(fields, req.getSearcher());\n    } catch (Exception e) {\n      writeException(e, writer, true);\n      return;\n    }\n\n    writer.write(\"{\\\"responseHeader\\\": {\\\"status\\\": 0}, \\\"response\\\":{\\\"numFound\\\":\"+totalHits+\", \\\"docs\\\":[\");\n\n\n    //Write the data.\n    List<LeafReaderContext> leaves = req.getSearcher().getTopReaderContext().leaves();\n    SortDoc sortDoc = getSortDoc(req.getSearcher(), sort.getSort());\n    int count = 0;\n    int queueSize = 30000;\n    SortQueue queue = new SortQueue(queueSize, sortDoc);\n    SortDoc[] outDocs = new SortDoc[queueSize];\n\n    boolean commaNeeded = false;\n    while(count < totalHits) {\n      //long begin = System.nanoTime();\n      queue.reset();\n      SortDoc top = queue.top();\n      for(int i=0; i<leaves.size(); i++) {\n        sortDoc.setNextReader(leaves.get(i));\n        DocIdSetIterator it = new BitSetIterator(sets[i], 0); // cost is not useful here\n        int docId = -1;\n        while((docId = it.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          sortDoc.setValues(docId);\n          if(top.lessThan(sortDoc)) {\n            top.setValues(sortDoc);\n            top = queue.updateTop();\n          }\n        }\n      }\n\n      int outDocsIndex = -1;\n\n      for(int i=0; i<queueSize; i++) {\n        SortDoc s = queue.pop();\n        if(s.docId > -1) {\n          outDocs[++outDocsIndex] = s;\n        }\n      }\n\n     //long end = System.nanoTime();\n\n      count += (outDocsIndex+1);\n\n      try {\n        for(int i=outDocsIndex; i>=0; --i) {\n          SortDoc s = outDocs[i];\n          if(commaNeeded){writer.write(',');}\n          writer.write('{');\n          writeDoc(s, leaves, fieldWriters, sets, writer);\n          writer.write('}');\n          commaNeeded = true;\n          s.reset();\n        }\n      } catch(Throwable e) {\n        Throwable ex = e;\n        e.printStackTrace();\n        while(ex != null) {\n          String m = ex.getMessage();\n          if(m != null && m.contains(\"Broken pipe\")) {\n            throw new IgnoreException();\n          }\n          ex = ex.getCause();\n        }\n\n        if(e instanceof IOException) {\n          throw ((IOException)e);\n        } else {\n          throw new IOException(e);\n        }\n      }\n    }\n\n    //System.out.println(\"Sort Time 2:\"+Long.toString(total/1000000));\n    writer.write(\"]}}\");\n    writer.flush();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"87e99c34422d54f9b012110d0d3c0406fba05085":["901b27c7f633ab98e138aafb0b9c3ba22aac6b28"],"901b27c7f633ab98e138aafb0b9c3ba22aac6b28":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7f1f5e4b31ec44927335e2ad6eebc4c1f8c0abf5":["a027750b86452a8dcd054ac993d54b203dae9102"],"24e98791f8207d0adf6998892a9e9eeec5db0f40":["7f1f5e4b31ec44927335e2ad6eebc4c1f8c0abf5"],"199dfa410f1fdbfd3294106b04096cce5ed34b21":["320888923ec13b91f53082558f01f4c9960dd226","50f05d6b69cfaabd51b5d26cba4e3122f51fff83"],"320888923ec13b91f53082558f01f4c9960dd226":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","24e98791f8207d0adf6998892a9e9eeec5db0f40"],"26d51e4b5ed27629c3d8933c24bc8741b4e04412":["0abcec02c9851c46c70a75bd42fb6e4d5348ac9e"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["cefbebfd2697abbd58b1da2de54fee000fee5ac8"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a027750b86452a8dcd054ac993d54b203dae9102","7f1f5e4b31ec44927335e2ad6eebc4c1f8c0abf5"],"50f05d6b69cfaabd51b5d26cba4e3122f51fff83":["24e98791f8207d0adf6998892a9e9eeec5db0f40"],"a55bf71f91aeded06b44ad1abea6666ea168b697":["26d51e4b5ed27629c3d8933c24bc8741b4e04412"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d12ee9465d37a9eedeee8a630aa7551b013cd4e4":["8da9a71da64ce12a97dcfcdd912893aeb1fa2981"],"80c55596a764e2d397e982828e75fcac5ce430a0":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"8da9a71da64ce12a97dcfcdd912893aeb1fa2981":["a55bf71f91aeded06b44ad1abea6666ea168b697"],"a027750b86452a8dcd054ac993d54b203dae9102":["d12ee9465d37a9eedeee8a630aa7551b013cd4e4"],"0abcec02c9851c46c70a75bd42fb6e4d5348ac9e":["80c55596a764e2d397e982828e75fcac5ce430a0"],"cefbebfd2697abbd58b1da2de54fee000fee5ac8":["87e99c34422d54f9b012110d0d3c0406fba05085"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["50f05d6b69cfaabd51b5d26cba4e3122f51fff83"]},"commit2Childs":{"87e99c34422d54f9b012110d0d3c0406fba05085":["cefbebfd2697abbd58b1da2de54fee000fee5ac8"],"901b27c7f633ab98e138aafb0b9c3ba22aac6b28":["87e99c34422d54f9b012110d0d3c0406fba05085"],"7f1f5e4b31ec44927335e2ad6eebc4c1f8c0abf5":["24e98791f8207d0adf6998892a9e9eeec5db0f40","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"24e98791f8207d0adf6998892a9e9eeec5db0f40":["320888923ec13b91f53082558f01f4c9960dd226","50f05d6b69cfaabd51b5d26cba4e3122f51fff83"],"199dfa410f1fdbfd3294106b04096cce5ed34b21":[],"320888923ec13b91f53082558f01f4c9960dd226":["199dfa410f1fdbfd3294106b04096cce5ed34b21"],"26d51e4b5ed27629c3d8933c24bc8741b4e04412":["a55bf71f91aeded06b44ad1abea6666ea168b697"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["320888923ec13b91f53082558f01f4c9960dd226"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["80c55596a764e2d397e982828e75fcac5ce430a0"],"50f05d6b69cfaabd51b5d26cba4e3122f51fff83":["199dfa410f1fdbfd3294106b04096cce5ed34b21","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a55bf71f91aeded06b44ad1abea6666ea168b697":["8da9a71da64ce12a97dcfcdd912893aeb1fa2981"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["901b27c7f633ab98e138aafb0b9c3ba22aac6b28"],"d12ee9465d37a9eedeee8a630aa7551b013cd4e4":["a027750b86452a8dcd054ac993d54b203dae9102"],"80c55596a764e2d397e982828e75fcac5ce430a0":["0abcec02c9851c46c70a75bd42fb6e4d5348ac9e"],"8da9a71da64ce12a97dcfcdd912893aeb1fa2981":["d12ee9465d37a9eedeee8a630aa7551b013cd4e4"],"a027750b86452a8dcd054ac993d54b203dae9102":["7f1f5e4b31ec44927335e2ad6eebc4c1f8c0abf5","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"0abcec02c9851c46c70a75bd42fb6e4d5348ac9e":["26d51e4b5ed27629c3d8933c24bc8741b4e04412"],"cefbebfd2697abbd58b1da2de54fee000fee5ac8":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["199dfa410f1fdbfd3294106b04096cce5ed34b21","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}