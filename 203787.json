{"path":"solr/core/src/java/org/apache/solr/request/DocValuesFacets#accumMulti(int[],int,SortedSetDocValues,DocIdSetIterator,int,OrdinalMap).mjava","commits":[{"id":"a9cc184ce59bfe09f739d9aaa34fdb28ddc738c3","date":1361894345,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/DocValuesFacets#accumMulti(int[],int,SortedSetDocValues,DocIdSetIterator,int,OrdinalMap).mjava","pathOld":"/dev/null","sourceNew":"  /** accumulates per-segment multi-valued facet counts, mapping to global ordinal space */\n  static void accumMulti(int counts[], int startTermIndex, SortedSetDocValues si, DocIdSetIterator disi, int subIndex, OrdinalMap map) throws IOException {\n    int doc;\n    while ((doc = disi.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n      si.setDocument(doc);\n      // strange do-while to collect the missing count (first ord is NO_MORE_ORDS)\n      int term = (int) si.nextOrd();\n      if (term < 0) {\n        if (startTermIndex == -1) {\n          counts[0]++; // missing count\n        }\n        continue;\n      }\n      \n      do {\n        if (map != null) {\n          term = (int) map.getGlobalOrd(subIndex, term);\n        }\n        int arrIdx = term-startTermIndex;\n        if (arrIdx>=0 && arrIdx<counts.length) counts[arrIdx]++;\n      } while ((term = (int) si.nextOrd()) >= 0);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7bde94df914e38596e2ce6907c04bcca8925e19","date":1385775146,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/DocValuesFacets#accumMulti(int[],int,SortedSetDocValues,DocIdSetIterator,int,OrdinalMap).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/DocValuesFacets#accumMulti(int[],int,SortedSetDocValues,DocIdSetIterator,int,OrdinalMap).mjava","sourceNew":"  /** accumulates per-segment multi-valued facet counts */\n  static void accumMulti(int counts[], int startTermIndex, SortedSetDocValues si, DocIdSetIterator disi, int subIndex, OrdinalMap map) throws IOException {\n    if (startTermIndex == -1 && (map == null || si.getValueCount() < disi.cost()*10)) {\n      // no prefixing, not too many unique values wrt matching docs (lucene/facets heuristic): \n      //   collect separately per-segment, then map to global ords\n      accumMultiSeg(counts, si, disi, subIndex, map);\n    } else {\n      // otherwise: do collect+map on the fly\n      accumMultiGeneric(counts, startTermIndex, si, disi, subIndex, map);\n    }\n  }\n\n","sourceOld":"  /** accumulates per-segment multi-valued facet counts, mapping to global ordinal space */\n  static void accumMulti(int counts[], int startTermIndex, SortedSetDocValues si, DocIdSetIterator disi, int subIndex, OrdinalMap map) throws IOException {\n    int doc;\n    while ((doc = disi.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n      si.setDocument(doc);\n      // strange do-while to collect the missing count (first ord is NO_MORE_ORDS)\n      int term = (int) si.nextOrd();\n      if (term < 0) {\n        if (startTermIndex == -1) {\n          counts[0]++; // missing count\n        }\n        continue;\n      }\n      \n      do {\n        if (map != null) {\n          term = (int) map.getGlobalOrd(subIndex, term);\n        }\n        int arrIdx = term-startTermIndex;\n        if (arrIdx>=0 && arrIdx<counts.length) counts[arrIdx]++;\n      } while ((term = (int) si.nextOrd()) >= 0);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/DocValuesFacets#accumMulti(int[],int,SortedSetDocValues,DocIdSetIterator,int,OrdinalMap).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/DocValuesFacets#accumMulti(int[],int,SortedSetDocValues,DocIdSetIterator,int,OrdinalMap).mjava","sourceNew":"  /** accumulates per-segment multi-valued facet counts */\n  static void accumMulti(int counts[], int startTermIndex, SortedSetDocValues si, DocIdSetIterator disi, int subIndex, OrdinalMap map) throws IOException {\n    if (startTermIndex == -1 && (map == null || si.getValueCount() < disi.cost()*10)) {\n      // no prefixing, not too many unique values wrt matching docs (lucene/facets heuristic): \n      //   collect separately per-segment, then map to global ords\n      accumMultiSeg(counts, si, disi, subIndex, map);\n    } else {\n      // otherwise: do collect+map on the fly\n      accumMultiGeneric(counts, startTermIndex, si, disi, subIndex, map);\n    }\n  }\n\n","sourceOld":"  /** accumulates per-segment multi-valued facet counts, mapping to global ordinal space */\n  static void accumMulti(int counts[], int startTermIndex, SortedSetDocValues si, DocIdSetIterator disi, int subIndex, OrdinalMap map) throws IOException {\n    int doc;\n    while ((doc = disi.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n      si.setDocument(doc);\n      // strange do-while to collect the missing count (first ord is NO_MORE_ORDS)\n      int term = (int) si.nextOrd();\n      if (term < 0) {\n        if (startTermIndex == -1) {\n          counts[0]++; // missing count\n        }\n        continue;\n      }\n      \n      do {\n        if (map != null) {\n          term = (int) map.getGlobalOrd(subIndex, term);\n        }\n        int arrIdx = term-startTermIndex;\n        if (arrIdx>=0 && arrIdx<counts.length) counts[arrIdx]++;\n      } while ((term = (int) si.nextOrd()) >= 0);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a9cc184ce59bfe09f739d9aaa34fdb28ddc738c3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["a9cc184ce59bfe09f739d9aaa34fdb28ddc738c3","c7bde94df914e38596e2ce6907c04bcca8925e19"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c7bde94df914e38596e2ce6907c04bcca8925e19"],"c7bde94df914e38596e2ce6907c04bcca8925e19":["a9cc184ce59bfe09f739d9aaa34fdb28ddc738c3"]},"commit2Childs":{"a9cc184ce59bfe09f739d9aaa34fdb28ddc738c3":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","c7bde94df914e38596e2ce6907c04bcca8925e19"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a9cc184ce59bfe09f739d9aaa34fdb28ddc738c3"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"c7bde94df914e38596e2ce6907c04bcca8925e19":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}