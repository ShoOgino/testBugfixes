{"path":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#corruptFiles(Collection[String]).mjava","commits":[{"id":"0d49a158012a8ff48f328a4558e4bfcffbaed16f","date":1453677440,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#corruptFiles(Collection[String]).mjava","pathOld":"/dev/null","sourceNew":"  public synchronized void corruptFiles(Collection<String> files) {\n    // Must make a copy because we change the incoming unsyncedFiles\n    // when we create temp files, delete, etc., below:\n    for(String name : new ArrayList<>(files)) {\n      int damage = randomState.nextInt(6);\n      String action = null;\n\n      switch(damage) {\n\n      case 0:\n        action = \"deleted\";\n        try {\n          deleteFile(name, true);\n        } catch (IOException ioe) {\n          // ignore\n        }\n        break;\n\n      case 1:\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length;\n        try {\n          length = fileLength(name);\n        } catch (IOException ioe) {\n          // Ignore\n          continue;\n        }\n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n          while(upto < length) {\n            final int limit = (int) Math.min(length-upto, zeroes.length);\n            out.writeBytes(zeroes, 0, limit);\n            upto += limit;\n          }\n        } catch (IOException ioe) {\n          // ignore\n        }\n        break;\n\n      case 2:\n        {\n          action = \"partially truncated\";\n          // Partially Truncate the file:\n\n          // First, make temp file and copy only half this\n          // file over:\n          String tempFileName = null;\n          try (IndexOutput tempOut = in.createTempOutput(\"name\", \"mdw_corrupt\", LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState))) {\n              tempFileName = tempOut.getName();\n              tempOut.copyBytes(ii, ii.length()/2);\n            } catch (IOException ioe) {\n            // ignore\n          }\n\n          try {\n            // Delete original and copy bytes back:\n            deleteFile(name, true);\n          } catch (IOException ioe) {\n            // ignore\n          }\n\n          try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState))) {\n              out.copyBytes(ii, ii.length());\n            } catch (IOException ioe) {\n            // ignore\n          }\n          try {\n            deleteFile(tempFileName, true);\n          } catch (IOException ioe) {\n            // ignore\n          }\n        }\n        break;\n      \n      case 3:\n        // The file survived intact:\n        action = \"didn't change\";\n        break;\n\n      case 4:\n        // Corrupt one bit randomly in the file:\n\n        {\n\n          String tempFileName = null;\n          try (IndexOutput tempOut = in.createTempOutput(\"name\", \"mdw_corrupt\", LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState))) {\n              tempFileName = tempOut.getName();\n              if (ii.length() > 0) {\n                // Copy first part unchanged:\n                long byteToCorrupt = (long) (randomState.nextDouble() * ii.length());\n                if (byteToCorrupt > 0) {\n                  tempOut.copyBytes(ii, byteToCorrupt);\n                }\n\n                // Randomly flip one bit from this byte:\n                byte b = ii.readByte();\n                int bitToFlip = randomState.nextInt(8);\n                b = (byte) (b ^ (1 << bitToFlip));\n                tempOut.writeByte(b);\n\n                action = \"flip bit \" + bitToFlip + \" of byte \" + byteToCorrupt + \" out of \" + ii.length() + \" bytes\";\n\n                // Copy last part unchanged:\n                long bytesLeft = ii.length() - byteToCorrupt - 1;\n                if (bytesLeft > 0) {\n                  tempOut.copyBytes(ii, bytesLeft);\n                }\n              } else {\n                action = \"didn't change\";\n              }\n            } catch (IOException ioe) {\n            // ignore\n          }\n\n          try {\n            // Delete original and copy bytes back:\n            deleteFile(name, true);\n          } catch (IOException ioe) {\n            // ignore\n          }\n\n          try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState))) {\n              out.copyBytes(ii, ii.length());\n            } catch (IOException ioe) {\n            // ignore\n          }\n          try {\n            deleteFile(tempFileName, true);\n          } catch (IOException ioe) {\n            // ignore\n          }\n        }\n        break;\n        \n      case 5:\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        try {\n          deleteFile(name, true);\n        } catch (IOException ioe) {\n          // ignore\n        }\n\n        try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n        } catch (IOException ioe) {\n          // ignore\n        }\n        break;\n\n      default:\n        throw new AssertionError();\n      }\n\n      if (true || LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["682c45d7adb379abe89faeb95e5c4ba4e693393e","e2b17cf57d8de6b9abb848ee5f3848a631c539ca"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1e6acbaae7af722f17204ceccf0f7db5753eccf3","date":1454775255,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#corruptFiles(Collection[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#corruptFiles(Collection[String]).mjava","sourceNew":"  public synchronized void corruptFiles(Collection<String> files) throws IOException {\n    // Must make a copy because we change the incoming unsyncedFiles\n    // when we create temp files, delete, etc., below:\n    for(String name : new ArrayList<>(files)) {\n      int damage = randomState.nextInt(6);\n      String action = null;\n\n      switch(damage) {\n\n      case 0:\n        action = \"deleted\";\n        deleteFile(name);\n        break;\n\n      case 1:\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length;\n        try {\n          length = fileLength(name);\n        } catch (IOException ioe) {\n          // Ignore\n          continue;\n        }\n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n          while(upto < length) {\n            final int limit = (int) Math.min(length-upto, zeroes.length);\n            out.writeBytes(zeroes, 0, limit);\n            upto += limit;\n          }\n        } catch (IOException ioe) {\n          // ignore\n        }\n        break;\n\n      case 2:\n        {\n          action = \"partially truncated\";\n          // Partially Truncate the file:\n\n          // First, make temp file and copy only half this\n          // file over:\n          String tempFileName = null;\n          try (IndexOutput tempOut = in.createTempOutput(\"name\", \"mdw_corrupt\", LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState))) {\n              tempFileName = tempOut.getName();\n              tempOut.copyBytes(ii, ii.length()/2);\n            } catch (IOException ioe) {\n            // ignore\n          }\n\n          // Delete original and copy bytes back:\n          deleteFile(name);\n\n          try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState))) {\n              out.copyBytes(ii, ii.length());\n            } catch (IOException ioe) {\n            // ignore\n          }\n          deleteFile(tempFileName);\n        }\n        break;\n      \n      case 3:\n        // The file survived intact:\n        action = \"didn't change\";\n        break;\n\n      case 4:\n        // Corrupt one bit randomly in the file:\n\n        {\n\n          String tempFileName = null;\n          try (IndexOutput tempOut = in.createTempOutput(\"name\", \"mdw_corrupt\", LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState))) {\n              tempFileName = tempOut.getName();\n              if (ii.length() > 0) {\n                // Copy first part unchanged:\n                long byteToCorrupt = (long) (randomState.nextDouble() * ii.length());\n                if (byteToCorrupt > 0) {\n                  tempOut.copyBytes(ii, byteToCorrupt);\n                }\n\n                // Randomly flip one bit from this byte:\n                byte b = ii.readByte();\n                int bitToFlip = randomState.nextInt(8);\n                b = (byte) (b ^ (1 << bitToFlip));\n                tempOut.writeByte(b);\n\n                action = \"flip bit \" + bitToFlip + \" of byte \" + byteToCorrupt + \" out of \" + ii.length() + \" bytes\";\n\n                // Copy last part unchanged:\n                long bytesLeft = ii.length() - byteToCorrupt - 1;\n                if (bytesLeft > 0) {\n                  tempOut.copyBytes(ii, bytesLeft);\n                }\n              } else {\n                action = \"didn't change\";\n              }\n            } catch (IOException ioe) {\n            // ignore\n          }\n\n          // Delete original and copy bytes back:\n          deleteFile(name);\n\n          try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState))) {\n              out.copyBytes(ii, ii.length());\n            } catch (IOException ioe) {\n            // ignore\n          }\n\n          deleteFile(tempFileName);\n        }\n        break;\n        \n      case 5:\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        deleteFile(name);\n\n        try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n        } catch (IOException ioe) {\n          // ignore\n        }\n        break;\n\n      default:\n        throw new AssertionError();\n      }\n\n      if (true || LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n  }\n\n","sourceOld":"  public synchronized void corruptFiles(Collection<String> files) {\n    // Must make a copy because we change the incoming unsyncedFiles\n    // when we create temp files, delete, etc., below:\n    for(String name : new ArrayList<>(files)) {\n      int damage = randomState.nextInt(6);\n      String action = null;\n\n      switch(damage) {\n\n      case 0:\n        action = \"deleted\";\n        try {\n          deleteFile(name, true);\n        } catch (IOException ioe) {\n          // ignore\n        }\n        break;\n\n      case 1:\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length;\n        try {\n          length = fileLength(name);\n        } catch (IOException ioe) {\n          // Ignore\n          continue;\n        }\n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n          while(upto < length) {\n            final int limit = (int) Math.min(length-upto, zeroes.length);\n            out.writeBytes(zeroes, 0, limit);\n            upto += limit;\n          }\n        } catch (IOException ioe) {\n          // ignore\n        }\n        break;\n\n      case 2:\n        {\n          action = \"partially truncated\";\n          // Partially Truncate the file:\n\n          // First, make temp file and copy only half this\n          // file over:\n          String tempFileName = null;\n          try (IndexOutput tempOut = in.createTempOutput(\"name\", \"mdw_corrupt\", LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState))) {\n              tempFileName = tempOut.getName();\n              tempOut.copyBytes(ii, ii.length()/2);\n            } catch (IOException ioe) {\n            // ignore\n          }\n\n          try {\n            // Delete original and copy bytes back:\n            deleteFile(name, true);\n          } catch (IOException ioe) {\n            // ignore\n          }\n\n          try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState))) {\n              out.copyBytes(ii, ii.length());\n            } catch (IOException ioe) {\n            // ignore\n          }\n          try {\n            deleteFile(tempFileName, true);\n          } catch (IOException ioe) {\n            // ignore\n          }\n        }\n        break;\n      \n      case 3:\n        // The file survived intact:\n        action = \"didn't change\";\n        break;\n\n      case 4:\n        // Corrupt one bit randomly in the file:\n\n        {\n\n          String tempFileName = null;\n          try (IndexOutput tempOut = in.createTempOutput(\"name\", \"mdw_corrupt\", LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState))) {\n              tempFileName = tempOut.getName();\n              if (ii.length() > 0) {\n                // Copy first part unchanged:\n                long byteToCorrupt = (long) (randomState.nextDouble() * ii.length());\n                if (byteToCorrupt > 0) {\n                  tempOut.copyBytes(ii, byteToCorrupt);\n                }\n\n                // Randomly flip one bit from this byte:\n                byte b = ii.readByte();\n                int bitToFlip = randomState.nextInt(8);\n                b = (byte) (b ^ (1 << bitToFlip));\n                tempOut.writeByte(b);\n\n                action = \"flip bit \" + bitToFlip + \" of byte \" + byteToCorrupt + \" out of \" + ii.length() + \" bytes\";\n\n                // Copy last part unchanged:\n                long bytesLeft = ii.length() - byteToCorrupt - 1;\n                if (bytesLeft > 0) {\n                  tempOut.copyBytes(ii, bytesLeft);\n                }\n              } else {\n                action = \"didn't change\";\n              }\n            } catch (IOException ioe) {\n            // ignore\n          }\n\n          try {\n            // Delete original and copy bytes back:\n            deleteFile(name, true);\n          } catch (IOException ioe) {\n            // ignore\n          }\n\n          try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState))) {\n              out.copyBytes(ii, ii.length());\n            } catch (IOException ioe) {\n            // ignore\n          }\n          try {\n            deleteFile(tempFileName, true);\n          } catch (IOException ioe) {\n            // ignore\n          }\n        }\n        break;\n        \n      case 5:\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        try {\n          deleteFile(name, true);\n        } catch (IOException ioe) {\n          // ignore\n        }\n\n        try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n        } catch (IOException ioe) {\n          // ignore\n        }\n        break;\n\n      default:\n        throw new AssertionError();\n      }\n\n      if (true || LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["e2b17cf57d8de6b9abb848ee5f3848a631c539ca"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"698fd91cb8c785a590bd5c01480b332c10deb757","date":1455013336,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#corruptFiles(Collection[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#corruptFiles(Collection[String]).mjava","sourceNew":"  public synchronized void corruptFiles(Collection<String> files) throws IOException {\n    // Must make a copy because we change the incoming unsyncedFiles\n    // when we create temp files, delete, etc., below:\n    for(String name : new ArrayList<>(files)) {\n      int damage = randomState.nextInt(6);\n      String action = null;\n\n      switch(damage) {\n\n      case 0:\n        action = \"deleted\";\n        deleteFile(name);\n        break;\n\n      case 1:\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length;\n        try {\n          length = fileLength(name);\n        } catch (IOException ioe) {\n          // Ignore\n          continue;\n        }\n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n          while(upto < length) {\n            final int limit = (int) Math.min(length-upto, zeroes.length);\n            out.writeBytes(zeroes, 0, limit);\n            upto += limit;\n          }\n        } catch (IOException ioe) {\n          // ignore\n        }\n        break;\n\n      case 2:\n        {\n          action = \"partially truncated\";\n          // Partially Truncate the file:\n\n          // First, make temp file and copy only half this\n          // file over:\n          String tempFileName = null;\n          try (IndexOutput tempOut = in.createTempOutput(\"name\", \"mdw_corrupt\", LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState))) {\n              tempFileName = tempOut.getName();\n              tempOut.copyBytes(ii, ii.length()/2);\n            } catch (IOException ioe) {\n            // ignore\n          }\n\n          // Delete original and copy bytes back:\n          deleteFile(name);\n\n          try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState))) {\n              out.copyBytes(ii, ii.length());\n            } catch (IOException ioe) {\n            // ignore\n          }\n          deleteFile(tempFileName);\n        }\n        break;\n      \n      case 3:\n        // The file survived intact:\n        action = \"didn't change\";\n        break;\n\n      case 4:\n        // Corrupt one bit randomly in the file:\n\n        {\n\n          String tempFileName = null;\n          try (IndexOutput tempOut = in.createTempOutput(\"name\", \"mdw_corrupt\", LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState))) {\n              tempFileName = tempOut.getName();\n              if (ii.length() > 0) {\n                // Copy first part unchanged:\n                long byteToCorrupt = (long) (randomState.nextDouble() * ii.length());\n                if (byteToCorrupt > 0) {\n                  tempOut.copyBytes(ii, byteToCorrupt);\n                }\n\n                // Randomly flip one bit from this byte:\n                byte b = ii.readByte();\n                int bitToFlip = randomState.nextInt(8);\n                b = (byte) (b ^ (1 << bitToFlip));\n                tempOut.writeByte(b);\n\n                action = \"flip bit \" + bitToFlip + \" of byte \" + byteToCorrupt + \" out of \" + ii.length() + \" bytes\";\n\n                // Copy last part unchanged:\n                long bytesLeft = ii.length() - byteToCorrupt - 1;\n                if (bytesLeft > 0) {\n                  tempOut.copyBytes(ii, bytesLeft);\n                }\n              } else {\n                action = \"didn't change\";\n              }\n            } catch (IOException ioe) {\n            // ignore\n          }\n\n          // Delete original and copy bytes back:\n          deleteFile(name);\n\n          try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState))) {\n              out.copyBytes(ii, ii.length());\n            } catch (IOException ioe) {\n            // ignore\n          }\n\n          deleteFile(tempFileName);\n        }\n        break;\n        \n      case 5:\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        deleteFile(name);\n\n        try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n        } catch (IOException ioe) {\n          // ignore\n        }\n        break;\n\n      default:\n        throw new AssertionError();\n      }\n\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n  }\n\n","sourceOld":"  public synchronized void corruptFiles(Collection<String> files) throws IOException {\n    // Must make a copy because we change the incoming unsyncedFiles\n    // when we create temp files, delete, etc., below:\n    for(String name : new ArrayList<>(files)) {\n      int damage = randomState.nextInt(6);\n      String action = null;\n\n      switch(damage) {\n\n      case 0:\n        action = \"deleted\";\n        deleteFile(name);\n        break;\n\n      case 1:\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length;\n        try {\n          length = fileLength(name);\n        } catch (IOException ioe) {\n          // Ignore\n          continue;\n        }\n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n          while(upto < length) {\n            final int limit = (int) Math.min(length-upto, zeroes.length);\n            out.writeBytes(zeroes, 0, limit);\n            upto += limit;\n          }\n        } catch (IOException ioe) {\n          // ignore\n        }\n        break;\n\n      case 2:\n        {\n          action = \"partially truncated\";\n          // Partially Truncate the file:\n\n          // First, make temp file and copy only half this\n          // file over:\n          String tempFileName = null;\n          try (IndexOutput tempOut = in.createTempOutput(\"name\", \"mdw_corrupt\", LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState))) {\n              tempFileName = tempOut.getName();\n              tempOut.copyBytes(ii, ii.length()/2);\n            } catch (IOException ioe) {\n            // ignore\n          }\n\n          // Delete original and copy bytes back:\n          deleteFile(name);\n\n          try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState))) {\n              out.copyBytes(ii, ii.length());\n            } catch (IOException ioe) {\n            // ignore\n          }\n          deleteFile(tempFileName);\n        }\n        break;\n      \n      case 3:\n        // The file survived intact:\n        action = \"didn't change\";\n        break;\n\n      case 4:\n        // Corrupt one bit randomly in the file:\n\n        {\n\n          String tempFileName = null;\n          try (IndexOutput tempOut = in.createTempOutput(\"name\", \"mdw_corrupt\", LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState))) {\n              tempFileName = tempOut.getName();\n              if (ii.length() > 0) {\n                // Copy first part unchanged:\n                long byteToCorrupt = (long) (randomState.nextDouble() * ii.length());\n                if (byteToCorrupt > 0) {\n                  tempOut.copyBytes(ii, byteToCorrupt);\n                }\n\n                // Randomly flip one bit from this byte:\n                byte b = ii.readByte();\n                int bitToFlip = randomState.nextInt(8);\n                b = (byte) (b ^ (1 << bitToFlip));\n                tempOut.writeByte(b);\n\n                action = \"flip bit \" + bitToFlip + \" of byte \" + byteToCorrupt + \" out of \" + ii.length() + \" bytes\";\n\n                // Copy last part unchanged:\n                long bytesLeft = ii.length() - byteToCorrupt - 1;\n                if (bytesLeft > 0) {\n                  tempOut.copyBytes(ii, bytesLeft);\n                }\n              } else {\n                action = \"didn't change\";\n              }\n            } catch (IOException ioe) {\n            // ignore\n          }\n\n          // Delete original and copy bytes back:\n          deleteFile(name);\n\n          try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState))) {\n              out.copyBytes(ii, ii.length());\n            } catch (IOException ioe) {\n            // ignore\n          }\n\n          deleteFile(tempFileName);\n        }\n        break;\n        \n      case 5:\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        deleteFile(name);\n\n        try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n        } catch (IOException ioe) {\n          // ignore\n        }\n        break;\n\n      default:\n        throw new AssertionError();\n      }\n\n      if (true || LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["e2b17cf57d8de6b9abb848ee5f3848a631c539ca"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"68496c2200e559fb7802f7575427b7a482659afb","date":1455207618,"type":0,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#corruptFiles(Collection[String]).mjava","pathOld":"/dev/null","sourceNew":"  public synchronized void corruptFiles(Collection<String> files) throws IOException {\n    // Must make a copy because we change the incoming unsyncedFiles\n    // when we create temp files, delete, etc., below:\n    for(String name : new ArrayList<>(files)) {\n      int damage = randomState.nextInt(6);\n      String action = null;\n\n      switch(damage) {\n\n      case 0:\n        action = \"deleted\";\n        deleteFile(name);\n        break;\n\n      case 1:\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length;\n        try {\n          length = fileLength(name);\n        } catch (IOException ioe) {\n          // Ignore\n          continue;\n        }\n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n          while(upto < length) {\n            final int limit = (int) Math.min(length-upto, zeroes.length);\n            out.writeBytes(zeroes, 0, limit);\n            upto += limit;\n          }\n        } catch (IOException ioe) {\n          // ignore\n        }\n        break;\n\n      case 2:\n        {\n          action = \"partially truncated\";\n          // Partially Truncate the file:\n\n          // First, make temp file and copy only half this\n          // file over:\n          String tempFileName = null;\n          try (IndexOutput tempOut = in.createTempOutput(\"name\", \"mdw_corrupt\", LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState))) {\n              tempFileName = tempOut.getName();\n              tempOut.copyBytes(ii, ii.length()/2);\n            } catch (IOException ioe) {\n            // ignore\n          }\n\n          // Delete original and copy bytes back:\n          deleteFile(name);\n\n          try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState))) {\n              out.copyBytes(ii, ii.length());\n            } catch (IOException ioe) {\n            // ignore\n          }\n          deleteFile(tempFileName);\n        }\n        break;\n      \n      case 3:\n        // The file survived intact:\n        action = \"didn't change\";\n        break;\n\n      case 4:\n        // Corrupt one bit randomly in the file:\n\n        {\n\n          String tempFileName = null;\n          try (IndexOutput tempOut = in.createTempOutput(\"name\", \"mdw_corrupt\", LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState))) {\n              tempFileName = tempOut.getName();\n              if (ii.length() > 0) {\n                // Copy first part unchanged:\n                long byteToCorrupt = (long) (randomState.nextDouble() * ii.length());\n                if (byteToCorrupt > 0) {\n                  tempOut.copyBytes(ii, byteToCorrupt);\n                }\n\n                // Randomly flip one bit from this byte:\n                byte b = ii.readByte();\n                int bitToFlip = randomState.nextInt(8);\n                b = (byte) (b ^ (1 << bitToFlip));\n                tempOut.writeByte(b);\n\n                action = \"flip bit \" + bitToFlip + \" of byte \" + byteToCorrupt + \" out of \" + ii.length() + \" bytes\";\n\n                // Copy last part unchanged:\n                long bytesLeft = ii.length() - byteToCorrupt - 1;\n                if (bytesLeft > 0) {\n                  tempOut.copyBytes(ii, bytesLeft);\n                }\n              } else {\n                action = \"didn't change\";\n              }\n            } catch (IOException ioe) {\n            // ignore\n          }\n\n          // Delete original and copy bytes back:\n          deleteFile(name);\n\n          try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState))) {\n              out.copyBytes(ii, ii.length());\n            } catch (IOException ioe) {\n            // ignore\n          }\n\n          deleteFile(tempFileName);\n        }\n        break;\n        \n      case 5:\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        deleteFile(name);\n\n        try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n        } catch (IOException ioe) {\n          // ignore\n        }\n        break;\n\n      default:\n        throw new AssertionError();\n      }\n\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9873c86642e5c4fecb3e4e365155322ca547da7f","date":1456069232,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#corruptFiles(Collection[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#corruptFiles(Collection[String]).mjava","sourceNew":"  public synchronized void corruptFiles(Collection<String> files) throws IOException {\n    // Must make a copy because we change the incoming unsyncedFiles\n    // when we create temp files, delete, etc., below:\n    for(String name : new ArrayList<>(files)) {\n      int damage = randomState.nextInt(6);\n      String action = null;\n\n      switch(damage) {\n\n      case 0:\n        action = \"deleted\";\n        deleteFile(name);\n        break;\n\n      case 1:\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length;\n        try {\n          length = fileLength(name);\n        } catch (IOException ioe) {\n          // Ignore\n          continue;\n        }\n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n          while(upto < length) {\n            final int limit = (int) Math.min(length-upto, zeroes.length);\n            out.writeBytes(zeroes, 0, limit);\n            upto += limit;\n          }\n        } catch (IOException ioe) {\n          // ignore\n        }\n        break;\n\n      case 2:\n        {\n          action = \"partially truncated\";\n          // Partially Truncate the file:\n\n          // First, make temp file and copy only half this\n          // file over:\n          String tempFileName = null;\n          try (IndexOutput tempOut = in.createTempOutput(\"name\", \"mdw_corrupt\", LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState))) {\n              tempFileName = tempOut.getName();\n              tempOut.copyBytes(ii, ii.length()/2);\n            } catch (IOException ioe) {\n            // ignore\n          }\n\n          // Delete original and copy bytes back:\n          deleteFile(name);\n\n          try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState))) {\n              out.copyBytes(ii, ii.length());\n            } catch (IOException ioe) {\n            // ignore\n          }\n          deleteFile(tempFileName);\n        }\n        break;\n      \n      case 3:\n        // The file survived intact:\n        action = \"didn't change\";\n        break;\n\n      case 4:\n        // Corrupt one bit randomly in the file:\n\n        {\n\n          String tempFileName = null;\n          try (IndexOutput tempOut = in.createTempOutput(\"name\", \"mdw_corrupt\", LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState))) {\n              tempFileName = tempOut.getName();\n              if (ii.length() > 0) {\n                // Copy first part unchanged:\n                long byteToCorrupt = (long) (randomState.nextDouble() * ii.length());\n                if (byteToCorrupt > 0) {\n                  tempOut.copyBytes(ii, byteToCorrupt);\n                }\n\n                // Randomly flip one bit from this byte:\n                byte b = ii.readByte();\n                int bitToFlip = randomState.nextInt(8);\n                b = (byte) (b ^ (1 << bitToFlip));\n                tempOut.writeByte(b);\n\n                action = \"flip bit \" + bitToFlip + \" of byte \" + byteToCorrupt + \" out of \" + ii.length() + \" bytes\";\n\n                // Copy last part unchanged:\n                long bytesLeft = ii.length() - byteToCorrupt - 1;\n                if (bytesLeft > 0) {\n                  tempOut.copyBytes(ii, bytesLeft);\n                }\n              } else {\n                action = \"didn't change\";\n              }\n            } catch (IOException ioe) {\n            // ignore\n          }\n\n          // Delete original and copy bytes back:\n          deleteFile(name);\n\n          try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState))) {\n              out.copyBytes(ii, ii.length());\n            } catch (IOException ioe) {\n            // ignore\n          }\n\n          deleteFile(tempFileName);\n        }\n        break;\n        \n      case 5:\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        deleteFile(name);\n\n        try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n          out.getFilePointer(); // just fake access to prevent compiler warning\n        } catch (IOException ioe) {\n          // ignore\n        }\n        break;\n\n      default:\n        throw new AssertionError();\n      }\n\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n  }\n\n","sourceOld":"  public synchronized void corruptFiles(Collection<String> files) throws IOException {\n    // Must make a copy because we change the incoming unsyncedFiles\n    // when we create temp files, delete, etc., below:\n    for(String name : new ArrayList<>(files)) {\n      int damage = randomState.nextInt(6);\n      String action = null;\n\n      switch(damage) {\n\n      case 0:\n        action = \"deleted\";\n        deleteFile(name);\n        break;\n\n      case 1:\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length;\n        try {\n          length = fileLength(name);\n        } catch (IOException ioe) {\n          // Ignore\n          continue;\n        }\n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n          while(upto < length) {\n            final int limit = (int) Math.min(length-upto, zeroes.length);\n            out.writeBytes(zeroes, 0, limit);\n            upto += limit;\n          }\n        } catch (IOException ioe) {\n          // ignore\n        }\n        break;\n\n      case 2:\n        {\n          action = \"partially truncated\";\n          // Partially Truncate the file:\n\n          // First, make temp file and copy only half this\n          // file over:\n          String tempFileName = null;\n          try (IndexOutput tempOut = in.createTempOutput(\"name\", \"mdw_corrupt\", LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState))) {\n              tempFileName = tempOut.getName();\n              tempOut.copyBytes(ii, ii.length()/2);\n            } catch (IOException ioe) {\n            // ignore\n          }\n\n          // Delete original and copy bytes back:\n          deleteFile(name);\n\n          try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState))) {\n              out.copyBytes(ii, ii.length());\n            } catch (IOException ioe) {\n            // ignore\n          }\n          deleteFile(tempFileName);\n        }\n        break;\n      \n      case 3:\n        // The file survived intact:\n        action = \"didn't change\";\n        break;\n\n      case 4:\n        // Corrupt one bit randomly in the file:\n\n        {\n\n          String tempFileName = null;\n          try (IndexOutput tempOut = in.createTempOutput(\"name\", \"mdw_corrupt\", LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState))) {\n              tempFileName = tempOut.getName();\n              if (ii.length() > 0) {\n                // Copy first part unchanged:\n                long byteToCorrupt = (long) (randomState.nextDouble() * ii.length());\n                if (byteToCorrupt > 0) {\n                  tempOut.copyBytes(ii, byteToCorrupt);\n                }\n\n                // Randomly flip one bit from this byte:\n                byte b = ii.readByte();\n                int bitToFlip = randomState.nextInt(8);\n                b = (byte) (b ^ (1 << bitToFlip));\n                tempOut.writeByte(b);\n\n                action = \"flip bit \" + bitToFlip + \" of byte \" + byteToCorrupt + \" out of \" + ii.length() + \" bytes\";\n\n                // Copy last part unchanged:\n                long bytesLeft = ii.length() - byteToCorrupt - 1;\n                if (bytesLeft > 0) {\n                  tempOut.copyBytes(ii, bytesLeft);\n                }\n              } else {\n                action = \"didn't change\";\n              }\n            } catch (IOException ioe) {\n            // ignore\n          }\n\n          // Delete original and copy bytes back:\n          deleteFile(name);\n\n          try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState))) {\n              out.copyBytes(ii, ii.length());\n            } catch (IOException ioe) {\n            // ignore\n          }\n\n          deleteFile(tempFileName);\n        }\n        break;\n        \n      case 5:\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        deleteFile(name);\n\n        try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n        } catch (IOException ioe) {\n          // ignore\n        }\n        break;\n\n      default:\n        throw new AssertionError();\n      }\n\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["e2b17cf57d8de6b9abb848ee5f3848a631c539ca"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"65fb6afbec59932f75dd371af329cb075d49844a","date":1456099903,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#corruptFiles(Collection[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#corruptFiles(Collection[String]).mjava","sourceNew":"  public synchronized void corruptFiles(Collection<String> files) throws IOException {\n    // Must make a copy because we change the incoming unsyncedFiles\n    // when we create temp files, delete, etc., below:\n    for(String name : new ArrayList<>(files)) {\n      int damage = randomState.nextInt(6);\n      String action = null;\n\n      switch(damage) {\n\n      case 0:\n        action = \"deleted\";\n        deleteFile(name);\n        break;\n\n      case 1:\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length;\n        try {\n          length = fileLength(name);\n        } catch (IOException ioe) {\n          // Ignore\n          continue;\n        }\n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n          while(upto < length) {\n            final int limit = (int) Math.min(length-upto, zeroes.length);\n            out.writeBytes(zeroes, 0, limit);\n            upto += limit;\n          }\n        } catch (IOException ioe) {\n          // ignore\n        }\n        break;\n\n      case 2:\n        {\n          action = \"partially truncated\";\n          // Partially Truncate the file:\n\n          // First, make temp file and copy only half this\n          // file over:\n          String tempFileName = null;\n          try (IndexOutput tempOut = in.createTempOutput(\"name\", \"mdw_corrupt\", LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState))) {\n              tempFileName = tempOut.getName();\n              tempOut.copyBytes(ii, ii.length()/2);\n            } catch (IOException ioe) {\n            // ignore\n          }\n\n          // Delete original and copy bytes back:\n          deleteFile(name);\n\n          try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState))) {\n              out.copyBytes(ii, ii.length());\n            } catch (IOException ioe) {\n            // ignore\n          }\n          deleteFile(tempFileName);\n        }\n        break;\n      \n      case 3:\n        // The file survived intact:\n        action = \"didn't change\";\n        break;\n\n      case 4:\n        // Corrupt one bit randomly in the file:\n\n        {\n\n          String tempFileName = null;\n          try (IndexOutput tempOut = in.createTempOutput(\"name\", \"mdw_corrupt\", LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState))) {\n              tempFileName = tempOut.getName();\n              if (ii.length() > 0) {\n                // Copy first part unchanged:\n                long byteToCorrupt = (long) (randomState.nextDouble() * ii.length());\n                if (byteToCorrupt > 0) {\n                  tempOut.copyBytes(ii, byteToCorrupt);\n                }\n\n                // Randomly flip one bit from this byte:\n                byte b = ii.readByte();\n                int bitToFlip = randomState.nextInt(8);\n                b = (byte) (b ^ (1 << bitToFlip));\n                tempOut.writeByte(b);\n\n                action = \"flip bit \" + bitToFlip + \" of byte \" + byteToCorrupt + \" out of \" + ii.length() + \" bytes\";\n\n                // Copy last part unchanged:\n                long bytesLeft = ii.length() - byteToCorrupt - 1;\n                if (bytesLeft > 0) {\n                  tempOut.copyBytes(ii, bytesLeft);\n                }\n              } else {\n                action = \"didn't change\";\n              }\n            } catch (IOException ioe) {\n            // ignore\n          }\n\n          // Delete original and copy bytes back:\n          deleteFile(name);\n\n          try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState))) {\n              out.copyBytes(ii, ii.length());\n            } catch (IOException ioe) {\n            // ignore\n          }\n\n          deleteFile(tempFileName);\n        }\n        break;\n        \n      case 5:\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        deleteFile(name);\n\n        try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n          out.getFilePointer(); // just fake access to prevent compiler warning\n        } catch (IOException ioe) {\n          // ignore\n        }\n        break;\n\n      default:\n        throw new AssertionError();\n      }\n\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n  }\n\n","sourceOld":"  public synchronized void corruptFiles(Collection<String> files) throws IOException {\n    // Must make a copy because we change the incoming unsyncedFiles\n    // when we create temp files, delete, etc., below:\n    for(String name : new ArrayList<>(files)) {\n      int damage = randomState.nextInt(6);\n      String action = null;\n\n      switch(damage) {\n\n      case 0:\n        action = \"deleted\";\n        deleteFile(name);\n        break;\n\n      case 1:\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length;\n        try {\n          length = fileLength(name);\n        } catch (IOException ioe) {\n          // Ignore\n          continue;\n        }\n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n          while(upto < length) {\n            final int limit = (int) Math.min(length-upto, zeroes.length);\n            out.writeBytes(zeroes, 0, limit);\n            upto += limit;\n          }\n        } catch (IOException ioe) {\n          // ignore\n        }\n        break;\n\n      case 2:\n        {\n          action = \"partially truncated\";\n          // Partially Truncate the file:\n\n          // First, make temp file and copy only half this\n          // file over:\n          String tempFileName = null;\n          try (IndexOutput tempOut = in.createTempOutput(\"name\", \"mdw_corrupt\", LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState))) {\n              tempFileName = tempOut.getName();\n              tempOut.copyBytes(ii, ii.length()/2);\n            } catch (IOException ioe) {\n            // ignore\n          }\n\n          // Delete original and copy bytes back:\n          deleteFile(name);\n\n          try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState))) {\n              out.copyBytes(ii, ii.length());\n            } catch (IOException ioe) {\n            // ignore\n          }\n          deleteFile(tempFileName);\n        }\n        break;\n      \n      case 3:\n        // The file survived intact:\n        action = \"didn't change\";\n        break;\n\n      case 4:\n        // Corrupt one bit randomly in the file:\n\n        {\n\n          String tempFileName = null;\n          try (IndexOutput tempOut = in.createTempOutput(\"name\", \"mdw_corrupt\", LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState))) {\n              tempFileName = tempOut.getName();\n              if (ii.length() > 0) {\n                // Copy first part unchanged:\n                long byteToCorrupt = (long) (randomState.nextDouble() * ii.length());\n                if (byteToCorrupt > 0) {\n                  tempOut.copyBytes(ii, byteToCorrupt);\n                }\n\n                // Randomly flip one bit from this byte:\n                byte b = ii.readByte();\n                int bitToFlip = randomState.nextInt(8);\n                b = (byte) (b ^ (1 << bitToFlip));\n                tempOut.writeByte(b);\n\n                action = \"flip bit \" + bitToFlip + \" of byte \" + byteToCorrupt + \" out of \" + ii.length() + \" bytes\";\n\n                // Copy last part unchanged:\n                long bytesLeft = ii.length() - byteToCorrupt - 1;\n                if (bytesLeft > 0) {\n                  tempOut.copyBytes(ii, bytesLeft);\n                }\n              } else {\n                action = \"didn't change\";\n              }\n            } catch (IOException ioe) {\n            // ignore\n          }\n\n          // Delete original and copy bytes back:\n          deleteFile(name);\n\n          try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState))) {\n              out.copyBytes(ii, ii.length());\n            } catch (IOException ioe) {\n            // ignore\n          }\n\n          deleteFile(tempFileName);\n        }\n        break;\n        \n      case 5:\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        deleteFile(name);\n\n        try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n        } catch (IOException ioe) {\n          // ignore\n        }\n        break;\n\n      default:\n        throw new AssertionError();\n      }\n\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"682c45d7adb379abe89faeb95e5c4ba4e693393e","date":1457517373,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#corruptFiles(Collection[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#corruptFiles(Collection[String]).mjava","sourceNew":"  public synchronized void corruptFiles(Collection<String> files) throws IOException {\n    // Must make a copy because we change the incoming unsyncedFiles\n    // when we create temp files, delete, etc., below:\n    final List<String> filesToCorrupt = new ArrayList<>(files);\n    // sort the files otherwise we have reproducibility issues\n    // across JVMs if the incoming collection is a hashSet etc.\n    CollectionUtil.timSort(filesToCorrupt);\n    for(String name : filesToCorrupt) {\n      int damage = randomState.nextInt(6);\n      String action = null;\n\n      switch(damage) {\n\n      case 0:\n        action = \"deleted\";\n        deleteFile(name);\n        break;\n\n      case 1:\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length;\n        try {\n          length = fileLength(name);\n        } catch (IOException ioe) {\n          // Ignore\n          continue;\n        }\n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n          while(upto < length) {\n            final int limit = (int) Math.min(length-upto, zeroes.length);\n            out.writeBytes(zeroes, 0, limit);\n            upto += limit;\n          }\n        } catch (IOException ioe) {\n          // ignore\n        }\n        break;\n\n      case 2:\n        {\n          action = \"partially truncated\";\n          // Partially Truncate the file:\n\n          // First, make temp file and copy only half this\n          // file over:\n          String tempFileName = null;\n          try (IndexOutput tempOut = in.createTempOutput(\"name\", \"mdw_corrupt\", LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState))) {\n              tempFileName = tempOut.getName();\n              tempOut.copyBytes(ii, ii.length()/2);\n            } catch (IOException ioe) {\n            // ignore\n          }\n\n          // Delete original and copy bytes back:\n          deleteFile(name);\n\n          try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState))) {\n              out.copyBytes(ii, ii.length());\n            } catch (IOException ioe) {\n            // ignore\n          }\n          deleteFile(tempFileName);\n        }\n        break;\n      \n      case 3:\n        // The file survived intact:\n        action = \"didn't change\";\n        break;\n\n      case 4:\n        // Corrupt one bit randomly in the file:\n\n        {\n\n          String tempFileName = null;\n          try (IndexOutput tempOut = in.createTempOutput(\"name\", \"mdw_corrupt\", LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState))) {\n              tempFileName = tempOut.getName();\n              if (ii.length() > 0) {\n                // Copy first part unchanged:\n                long byteToCorrupt = (long) (randomState.nextDouble() * ii.length());\n                if (byteToCorrupt > 0) {\n                  tempOut.copyBytes(ii, byteToCorrupt);\n                }\n\n                // Randomly flip one bit from this byte:\n                byte b = ii.readByte();\n                int bitToFlip = randomState.nextInt(8);\n                b = (byte) (b ^ (1 << bitToFlip));\n                tempOut.writeByte(b);\n\n                action = \"flip bit \" + bitToFlip + \" of byte \" + byteToCorrupt + \" out of \" + ii.length() + \" bytes\";\n\n                // Copy last part unchanged:\n                long bytesLeft = ii.length() - byteToCorrupt - 1;\n                if (bytesLeft > 0) {\n                  tempOut.copyBytes(ii, bytesLeft);\n                }\n              } else {\n                action = \"didn't change\";\n              }\n            } catch (IOException ioe) {\n            // ignore\n          }\n\n          // Delete original and copy bytes back:\n          deleteFile(name);\n\n          try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState))) {\n              out.copyBytes(ii, ii.length());\n            } catch (IOException ioe) {\n            // ignore\n          }\n\n          deleteFile(tempFileName);\n        }\n        break;\n        \n      case 5:\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        deleteFile(name);\n\n        try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n          out.getFilePointer(); // just fake access to prevent compiler warning\n        } catch (IOException ioe) {\n          // ignore\n        }\n        break;\n\n      default:\n        throw new AssertionError();\n      }\n\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n  }\n\n","sourceOld":"  public synchronized void corruptFiles(Collection<String> files) throws IOException {\n    // Must make a copy because we change the incoming unsyncedFiles\n    // when we create temp files, delete, etc., below:\n    for(String name : new ArrayList<>(files)) {\n      int damage = randomState.nextInt(6);\n      String action = null;\n\n      switch(damage) {\n\n      case 0:\n        action = \"deleted\";\n        deleteFile(name);\n        break;\n\n      case 1:\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length;\n        try {\n          length = fileLength(name);\n        } catch (IOException ioe) {\n          // Ignore\n          continue;\n        }\n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n          while(upto < length) {\n            final int limit = (int) Math.min(length-upto, zeroes.length);\n            out.writeBytes(zeroes, 0, limit);\n            upto += limit;\n          }\n        } catch (IOException ioe) {\n          // ignore\n        }\n        break;\n\n      case 2:\n        {\n          action = \"partially truncated\";\n          // Partially Truncate the file:\n\n          // First, make temp file and copy only half this\n          // file over:\n          String tempFileName = null;\n          try (IndexOutput tempOut = in.createTempOutput(\"name\", \"mdw_corrupt\", LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState))) {\n              tempFileName = tempOut.getName();\n              tempOut.copyBytes(ii, ii.length()/2);\n            } catch (IOException ioe) {\n            // ignore\n          }\n\n          // Delete original and copy bytes back:\n          deleteFile(name);\n\n          try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState))) {\n              out.copyBytes(ii, ii.length());\n            } catch (IOException ioe) {\n            // ignore\n          }\n          deleteFile(tempFileName);\n        }\n        break;\n      \n      case 3:\n        // The file survived intact:\n        action = \"didn't change\";\n        break;\n\n      case 4:\n        // Corrupt one bit randomly in the file:\n\n        {\n\n          String tempFileName = null;\n          try (IndexOutput tempOut = in.createTempOutput(\"name\", \"mdw_corrupt\", LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState))) {\n              tempFileName = tempOut.getName();\n              if (ii.length() > 0) {\n                // Copy first part unchanged:\n                long byteToCorrupt = (long) (randomState.nextDouble() * ii.length());\n                if (byteToCorrupt > 0) {\n                  tempOut.copyBytes(ii, byteToCorrupt);\n                }\n\n                // Randomly flip one bit from this byte:\n                byte b = ii.readByte();\n                int bitToFlip = randomState.nextInt(8);\n                b = (byte) (b ^ (1 << bitToFlip));\n                tempOut.writeByte(b);\n\n                action = \"flip bit \" + bitToFlip + \" of byte \" + byteToCorrupt + \" out of \" + ii.length() + \" bytes\";\n\n                // Copy last part unchanged:\n                long bytesLeft = ii.length() - byteToCorrupt - 1;\n                if (bytesLeft > 0) {\n                  tempOut.copyBytes(ii, bytesLeft);\n                }\n              } else {\n                action = \"didn't change\";\n              }\n            } catch (IOException ioe) {\n            // ignore\n          }\n\n          // Delete original and copy bytes back:\n          deleteFile(name);\n\n          try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState))) {\n              out.copyBytes(ii, ii.length());\n            } catch (IOException ioe) {\n            // ignore\n          }\n\n          deleteFile(tempFileName);\n        }\n        break;\n        \n      case 5:\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        deleteFile(name);\n\n        try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n          out.getFilePointer(); // just fake access to prevent compiler warning\n        } catch (IOException ioe) {\n          // ignore\n        }\n        break;\n\n      default:\n        throw new AssertionError();\n      }\n\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n  }\n\n","bugFix":["0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"bugIntro":["e2b17cf57d8de6b9abb848ee5f3848a631c539ca"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fcea6cce9ade9e5e9c2c9ae2482a924c13c7f7c8","date":1466428664,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#corruptFiles(Collection[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#corruptFiles(Collection[String]).mjava","sourceNew":"  public synchronized void corruptFiles(Collection<String> files) throws IOException {\n    // Must make a copy because we change the incoming unsyncedFiles\n    // when we create temp files, delete, etc., below:\n    final List<String> filesToCorrupt = new ArrayList<>(files);\n    // sort the files otherwise we have reproducibility issues\n    // across JVMs if the incoming collection is a hashSet etc.\n    CollectionUtil.timSort(filesToCorrupt);\n    for(String name : filesToCorrupt) {\n      int damage = randomState.nextInt(6);\n      if (alwaysCorrupt && damage == 3) {\n        damage = 4;\n      }\n      String action = null;\n\n      switch(damage) {\n\n      case 0:\n        action = \"deleted\";\n        deleteFile(name);\n        break;\n\n      case 1:\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length;\n        try {\n          length = fileLength(name);\n        } catch (IOException ioe) {\n          throw new RuntimeException(\"hit unexpected IOException while trying to corrupt file \" + name, ioe);\n        }\n\n        // Delete original and write zeros back:\n        deleteFile(name);\n        \n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n          while(upto < length) {\n            final int limit = (int) Math.min(length-upto, zeroes.length);\n            out.writeBytes(zeroes, 0, limit);\n            upto += limit;\n          }\n        } catch (IOException ioe) {\n          throw new RuntimeException(\"hit unexpected IOException while trying to corrupt file \" + name, ioe);\n        }\n        break;\n\n      case 2:\n        {\n          action = \"partially truncated\";\n          // Partially Truncate the file:\n\n          // First, make temp file and copy only half this\n          // file over:\n          String tempFileName = null;\n          try (IndexOutput tempOut = in.createTempOutput(\"name\", \"mdw_corrupt\", LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState))) {\n              tempFileName = tempOut.getName();\n              tempOut.copyBytes(ii, ii.length()/2);\n          } catch (IOException ioe) {\n            throw new RuntimeException(\"hit unexpected IOException while trying to corrupt file \" + name, ioe);\n          }\n\n          // Delete original and copy bytes back:\n          deleteFile(name);\n\n          try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState))) {\n              out.copyBytes(ii, ii.length());\n          } catch (IOException ioe) {\n            throw new RuntimeException(\"hit unexpected IOException while trying to corrupt file \" + name, ioe);\n          }\n          deleteFile(tempFileName);\n        }\n        break;\n      \n      case 3:\n        // The file survived intact:\n        action = \"didn't change\";\n        break;\n\n      case 4:\n        // Corrupt one bit randomly in the file:\n\n        {\n\n          String tempFileName = null;\n          try (IndexOutput tempOut = in.createTempOutput(\"name\", \"mdw_corrupt\", LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState))) {\n            tempFileName = tempOut.getName();\n            if (ii.length() > 0) {\n              // Copy first part unchanged:\n              long byteToCorrupt = (long) (randomState.nextDouble() * ii.length());\n              if (byteToCorrupt > 0) {\n                tempOut.copyBytes(ii, byteToCorrupt);\n              }\n\n              // Randomly flip one bit from this byte:\n              byte b = ii.readByte();\n              int bitToFlip = randomState.nextInt(8);\n              b = (byte) (b ^ (1 << bitToFlip));\n              tempOut.writeByte(b);\n\n              action = \"flip bit \" + bitToFlip + \" of byte \" + byteToCorrupt + \" out of \" + ii.length() + \" bytes\";\n\n              // Copy last part unchanged:\n              long bytesLeft = ii.length() - byteToCorrupt - 1;\n              if (bytesLeft > 0) {\n                tempOut.copyBytes(ii, bytesLeft);\n              }\n            } else {\n              action = \"didn't change\";\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(\"hit unexpected IOException while trying to corrupt file \" + name, ioe);\n          }\n\n          // Delete original and copy bytes back:\n          deleteFile(name);\n\n          try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState))) {\n            out.copyBytes(ii, ii.length());\n          } catch (IOException ioe) {\n            throw new RuntimeException(\"hit unexpected IOException while trying to corrupt file \" + name, ioe);\n          }\n\n          deleteFile(tempFileName);\n        }\n        break;\n        \n      case 5:\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        deleteFile(name);\n\n        try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n          out.getFilePointer(); // just fake access to prevent compiler warning\n        } catch (IOException ioe) {\n          throw new RuntimeException(\"hit unexpected IOException while trying to corrupt file \" + name, ioe);\n        }\n        break;\n\n      default:\n        throw new AssertionError();\n      }\n\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n  }\n\n","sourceOld":"  public synchronized void corruptFiles(Collection<String> files) throws IOException {\n    // Must make a copy because we change the incoming unsyncedFiles\n    // when we create temp files, delete, etc., below:\n    final List<String> filesToCorrupt = new ArrayList<>(files);\n    // sort the files otherwise we have reproducibility issues\n    // across JVMs if the incoming collection is a hashSet etc.\n    CollectionUtil.timSort(filesToCorrupt);\n    for(String name : filesToCorrupt) {\n      int damage = randomState.nextInt(6);\n      String action = null;\n\n      switch(damage) {\n\n      case 0:\n        action = \"deleted\";\n        deleteFile(name);\n        break;\n\n      case 1:\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length;\n        try {\n          length = fileLength(name);\n        } catch (IOException ioe) {\n          // Ignore\n          continue;\n        }\n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n          while(upto < length) {\n            final int limit = (int) Math.min(length-upto, zeroes.length);\n            out.writeBytes(zeroes, 0, limit);\n            upto += limit;\n          }\n        } catch (IOException ioe) {\n          // ignore\n        }\n        break;\n\n      case 2:\n        {\n          action = \"partially truncated\";\n          // Partially Truncate the file:\n\n          // First, make temp file and copy only half this\n          // file over:\n          String tempFileName = null;\n          try (IndexOutput tempOut = in.createTempOutput(\"name\", \"mdw_corrupt\", LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState))) {\n              tempFileName = tempOut.getName();\n              tempOut.copyBytes(ii, ii.length()/2);\n            } catch (IOException ioe) {\n            // ignore\n          }\n\n          // Delete original and copy bytes back:\n          deleteFile(name);\n\n          try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState))) {\n              out.copyBytes(ii, ii.length());\n            } catch (IOException ioe) {\n            // ignore\n          }\n          deleteFile(tempFileName);\n        }\n        break;\n      \n      case 3:\n        // The file survived intact:\n        action = \"didn't change\";\n        break;\n\n      case 4:\n        // Corrupt one bit randomly in the file:\n\n        {\n\n          String tempFileName = null;\n          try (IndexOutput tempOut = in.createTempOutput(\"name\", \"mdw_corrupt\", LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState))) {\n              tempFileName = tempOut.getName();\n              if (ii.length() > 0) {\n                // Copy first part unchanged:\n                long byteToCorrupt = (long) (randomState.nextDouble() * ii.length());\n                if (byteToCorrupt > 0) {\n                  tempOut.copyBytes(ii, byteToCorrupt);\n                }\n\n                // Randomly flip one bit from this byte:\n                byte b = ii.readByte();\n                int bitToFlip = randomState.nextInt(8);\n                b = (byte) (b ^ (1 << bitToFlip));\n                tempOut.writeByte(b);\n\n                action = \"flip bit \" + bitToFlip + \" of byte \" + byteToCorrupt + \" out of \" + ii.length() + \" bytes\";\n\n                // Copy last part unchanged:\n                long bytesLeft = ii.length() - byteToCorrupt - 1;\n                if (bytesLeft > 0) {\n                  tempOut.copyBytes(ii, bytesLeft);\n                }\n              } else {\n                action = \"didn't change\";\n              }\n            } catch (IOException ioe) {\n            // ignore\n          }\n\n          // Delete original and copy bytes back:\n          deleteFile(name);\n\n          try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState))) {\n              out.copyBytes(ii, ii.length());\n            } catch (IOException ioe) {\n            // ignore\n          }\n\n          deleteFile(tempFileName);\n        }\n        break;\n        \n      case 5:\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        deleteFile(name);\n\n        try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n          out.getFilePointer(); // just fake access to prevent compiler warning\n        } catch (IOException ioe) {\n          // ignore\n        }\n        break;\n\n      default:\n        throw new AssertionError();\n      }\n\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["e2b17cf57d8de6b9abb848ee5f3848a631c539ca"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6aaba221b22442bdf0ef28770c25fe259dfb3f55","date":1466496193,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#corruptFiles(Collection[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#corruptFiles(Collection[String]).mjava","sourceNew":"  public synchronized void corruptFiles(Collection<String> files) throws IOException {\n    // Must make a copy because we change the incoming unsyncedFiles\n    // when we create temp files, delete, etc., below:\n    final List<String> filesToCorrupt = new ArrayList<>(files);\n    // sort the files otherwise we have reproducibility issues\n    // across JVMs if the incoming collection is a hashSet etc.\n    CollectionUtil.timSort(filesToCorrupt);\n    for(String name : filesToCorrupt) {\n      int damage = randomState.nextInt(6);\n      if (alwaysCorrupt && damage == 3) {\n        damage = 4;\n      }\n      String action = null;\n\n      switch(damage) {\n\n      case 0:\n        action = \"deleted\";\n        deleteFile(name);\n        break;\n\n      case 1:\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length;\n        try {\n          length = fileLength(name);\n        } catch (IOException ioe) {\n          throw new RuntimeException(\"hit unexpected IOException while trying to corrupt file \" + name, ioe);\n        }\n\n        // Delete original and write zeros back:\n        deleteFile(name);\n        \n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n          while(upto < length) {\n            final int limit = (int) Math.min(length-upto, zeroes.length);\n            out.writeBytes(zeroes, 0, limit);\n            upto += limit;\n          }\n        } catch (IOException ioe) {\n          throw new RuntimeException(\"hit unexpected IOException while trying to corrupt file \" + name, ioe);\n        }\n        break;\n\n      case 2:\n        {\n          action = \"partially truncated\";\n          // Partially Truncate the file:\n\n          // First, make temp file and copy only half this\n          // file over:\n          String tempFileName = null;\n          try (IndexOutput tempOut = in.createTempOutput(\"name\", \"mdw_corrupt\", LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState))) {\n              tempFileName = tempOut.getName();\n              tempOut.copyBytes(ii, ii.length()/2);\n          } catch (IOException ioe) {\n            throw new RuntimeException(\"hit unexpected IOException while trying to corrupt file \" + name, ioe);\n          }\n\n          // Delete original and copy bytes back:\n          deleteFile(name);\n\n          try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState))) {\n              out.copyBytes(ii, ii.length());\n          } catch (IOException ioe) {\n            throw new RuntimeException(\"hit unexpected IOException while trying to corrupt file \" + name, ioe);\n          }\n          deleteFile(tempFileName);\n        }\n        break;\n      \n      case 3:\n        // The file survived intact:\n        action = \"didn't change\";\n        break;\n\n      case 4:\n        // Corrupt one bit randomly in the file:\n\n        {\n\n          String tempFileName = null;\n          try (IndexOutput tempOut = in.createTempOutput(\"name\", \"mdw_corrupt\", LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState))) {\n            tempFileName = tempOut.getName();\n            if (ii.length() > 0) {\n              // Copy first part unchanged:\n              long byteToCorrupt = (long) (randomState.nextDouble() * ii.length());\n              if (byteToCorrupt > 0) {\n                tempOut.copyBytes(ii, byteToCorrupt);\n              }\n\n              // Randomly flip one bit from this byte:\n              byte b = ii.readByte();\n              int bitToFlip = randomState.nextInt(8);\n              b = (byte) (b ^ (1 << bitToFlip));\n              tempOut.writeByte(b);\n\n              action = \"flip bit \" + bitToFlip + \" of byte \" + byteToCorrupt + \" out of \" + ii.length() + \" bytes\";\n\n              // Copy last part unchanged:\n              long bytesLeft = ii.length() - byteToCorrupt - 1;\n              if (bytesLeft > 0) {\n                tempOut.copyBytes(ii, bytesLeft);\n              }\n            } else {\n              action = \"didn't change\";\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(\"hit unexpected IOException while trying to corrupt file \" + name, ioe);\n          }\n\n          // Delete original and copy bytes back:\n          deleteFile(name);\n\n          try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState))) {\n            out.copyBytes(ii, ii.length());\n          } catch (IOException ioe) {\n            throw new RuntimeException(\"hit unexpected IOException while trying to corrupt file \" + name, ioe);\n          }\n\n          deleteFile(tempFileName);\n        }\n        break;\n        \n      case 5:\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        deleteFile(name);\n\n        try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n          out.getFilePointer(); // just fake access to prevent compiler warning\n        } catch (IOException ioe) {\n          throw new RuntimeException(\"hit unexpected IOException while trying to corrupt file \" + name, ioe);\n        }\n        break;\n\n      default:\n        throw new AssertionError();\n      }\n\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n  }\n\n","sourceOld":"  public synchronized void corruptFiles(Collection<String> files) throws IOException {\n    // Must make a copy because we change the incoming unsyncedFiles\n    // when we create temp files, delete, etc., below:\n    final List<String> filesToCorrupt = new ArrayList<>(files);\n    // sort the files otherwise we have reproducibility issues\n    // across JVMs if the incoming collection is a hashSet etc.\n    CollectionUtil.timSort(filesToCorrupt);\n    for(String name : filesToCorrupt) {\n      int damage = randomState.nextInt(6);\n      String action = null;\n\n      switch(damage) {\n\n      case 0:\n        action = \"deleted\";\n        deleteFile(name);\n        break;\n\n      case 1:\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length;\n        try {\n          length = fileLength(name);\n        } catch (IOException ioe) {\n          // Ignore\n          continue;\n        }\n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n          while(upto < length) {\n            final int limit = (int) Math.min(length-upto, zeroes.length);\n            out.writeBytes(zeroes, 0, limit);\n            upto += limit;\n          }\n        } catch (IOException ioe) {\n          // ignore\n        }\n        break;\n\n      case 2:\n        {\n          action = \"partially truncated\";\n          // Partially Truncate the file:\n\n          // First, make temp file and copy only half this\n          // file over:\n          String tempFileName = null;\n          try (IndexOutput tempOut = in.createTempOutput(\"name\", \"mdw_corrupt\", LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState))) {\n              tempFileName = tempOut.getName();\n              tempOut.copyBytes(ii, ii.length()/2);\n            } catch (IOException ioe) {\n            // ignore\n          }\n\n          // Delete original and copy bytes back:\n          deleteFile(name);\n\n          try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState))) {\n              out.copyBytes(ii, ii.length());\n            } catch (IOException ioe) {\n            // ignore\n          }\n          deleteFile(tempFileName);\n        }\n        break;\n      \n      case 3:\n        // The file survived intact:\n        action = \"didn't change\";\n        break;\n\n      case 4:\n        // Corrupt one bit randomly in the file:\n\n        {\n\n          String tempFileName = null;\n          try (IndexOutput tempOut = in.createTempOutput(\"name\", \"mdw_corrupt\", LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState))) {\n              tempFileName = tempOut.getName();\n              if (ii.length() > 0) {\n                // Copy first part unchanged:\n                long byteToCorrupt = (long) (randomState.nextDouble() * ii.length());\n                if (byteToCorrupt > 0) {\n                  tempOut.copyBytes(ii, byteToCorrupt);\n                }\n\n                // Randomly flip one bit from this byte:\n                byte b = ii.readByte();\n                int bitToFlip = randomState.nextInt(8);\n                b = (byte) (b ^ (1 << bitToFlip));\n                tempOut.writeByte(b);\n\n                action = \"flip bit \" + bitToFlip + \" of byte \" + byteToCorrupt + \" out of \" + ii.length() + \" bytes\";\n\n                // Copy last part unchanged:\n                long bytesLeft = ii.length() - byteToCorrupt - 1;\n                if (bytesLeft > 0) {\n                  tempOut.copyBytes(ii, bytesLeft);\n                }\n              } else {\n                action = \"didn't change\";\n              }\n            } catch (IOException ioe) {\n            // ignore\n          }\n\n          // Delete original and copy bytes back:\n          deleteFile(name);\n\n          try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState))) {\n              out.copyBytes(ii, ii.length());\n            } catch (IOException ioe) {\n            // ignore\n          }\n\n          deleteFile(tempFileName);\n        }\n        break;\n        \n      case 5:\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        deleteFile(name);\n\n        try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n          out.getFilePointer(); // just fake access to prevent compiler warning\n        } catch (IOException ioe) {\n          // ignore\n        }\n        break;\n\n      default:\n        throw new AssertionError();\n      }\n\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e2b17cf57d8de6b9abb848ee5f3848a631c539ca","date":1466499034,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#corruptFiles(Collection[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#corruptFiles(Collection[String]).mjava","sourceNew":"  public synchronized void corruptFiles(Collection<String> files) throws IOException {\n    boolean disabled = TestUtil.disableVirusChecker(in);\n    try {\n      _corruptFiles(files);\n    } finally {\n      if (disabled) {\n        TestUtil.enableVirusChecker(in);\n      }\n    }\n  }\n\n","sourceOld":"  public synchronized void corruptFiles(Collection<String> files) throws IOException {\n    // Must make a copy because we change the incoming unsyncedFiles\n    // when we create temp files, delete, etc., below:\n    final List<String> filesToCorrupt = new ArrayList<>(files);\n    // sort the files otherwise we have reproducibility issues\n    // across JVMs if the incoming collection is a hashSet etc.\n    CollectionUtil.timSort(filesToCorrupt);\n    for(String name : filesToCorrupt) {\n      int damage = randomState.nextInt(6);\n      if (alwaysCorrupt && damage == 3) {\n        damage = 4;\n      }\n      String action = null;\n\n      switch(damage) {\n\n      case 0:\n        action = \"deleted\";\n        deleteFile(name);\n        break;\n\n      case 1:\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length;\n        try {\n          length = fileLength(name);\n        } catch (IOException ioe) {\n          throw new RuntimeException(\"hit unexpected IOException while trying to corrupt file \" + name, ioe);\n        }\n\n        // Delete original and write zeros back:\n        deleteFile(name);\n        \n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n          while(upto < length) {\n            final int limit = (int) Math.min(length-upto, zeroes.length);\n            out.writeBytes(zeroes, 0, limit);\n            upto += limit;\n          }\n        } catch (IOException ioe) {\n          throw new RuntimeException(\"hit unexpected IOException while trying to corrupt file \" + name, ioe);\n        }\n        break;\n\n      case 2:\n        {\n          action = \"partially truncated\";\n          // Partially Truncate the file:\n\n          // First, make temp file and copy only half this\n          // file over:\n          String tempFileName = null;\n          try (IndexOutput tempOut = in.createTempOutput(\"name\", \"mdw_corrupt\", LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState))) {\n              tempFileName = tempOut.getName();\n              tempOut.copyBytes(ii, ii.length()/2);\n          } catch (IOException ioe) {\n            throw new RuntimeException(\"hit unexpected IOException while trying to corrupt file \" + name, ioe);\n          }\n\n          // Delete original and copy bytes back:\n          deleteFile(name);\n\n          try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState))) {\n              out.copyBytes(ii, ii.length());\n          } catch (IOException ioe) {\n            throw new RuntimeException(\"hit unexpected IOException while trying to corrupt file \" + name, ioe);\n          }\n          deleteFile(tempFileName);\n        }\n        break;\n      \n      case 3:\n        // The file survived intact:\n        action = \"didn't change\";\n        break;\n\n      case 4:\n        // Corrupt one bit randomly in the file:\n\n        {\n\n          String tempFileName = null;\n          try (IndexOutput tempOut = in.createTempOutput(\"name\", \"mdw_corrupt\", LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState))) {\n            tempFileName = tempOut.getName();\n            if (ii.length() > 0) {\n              // Copy first part unchanged:\n              long byteToCorrupt = (long) (randomState.nextDouble() * ii.length());\n              if (byteToCorrupt > 0) {\n                tempOut.copyBytes(ii, byteToCorrupt);\n              }\n\n              // Randomly flip one bit from this byte:\n              byte b = ii.readByte();\n              int bitToFlip = randomState.nextInt(8);\n              b = (byte) (b ^ (1 << bitToFlip));\n              tempOut.writeByte(b);\n\n              action = \"flip bit \" + bitToFlip + \" of byte \" + byteToCorrupt + \" out of \" + ii.length() + \" bytes\";\n\n              // Copy last part unchanged:\n              long bytesLeft = ii.length() - byteToCorrupt - 1;\n              if (bytesLeft > 0) {\n                tempOut.copyBytes(ii, bytesLeft);\n              }\n            } else {\n              action = \"didn't change\";\n            }\n          } catch (IOException ioe) {\n            throw new RuntimeException(\"hit unexpected IOException while trying to corrupt file \" + name, ioe);\n          }\n\n          // Delete original and copy bytes back:\n          deleteFile(name);\n\n          try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState))) {\n            out.copyBytes(ii, ii.length());\n          } catch (IOException ioe) {\n            throw new RuntimeException(\"hit unexpected IOException while trying to corrupt file \" + name, ioe);\n          }\n\n          deleteFile(tempFileName);\n        }\n        break;\n        \n      case 5:\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        deleteFile(name);\n\n        try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n          out.getFilePointer(); // just fake access to prevent compiler warning\n        } catch (IOException ioe) {\n          throw new RuntimeException(\"hit unexpected IOException while trying to corrupt file \" + name, ioe);\n        }\n        break;\n\n      default:\n        throw new AssertionError();\n      }\n\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n  }\n\n","bugFix":["fcea6cce9ade9e5e9c2c9ae2482a924c13c7f7c8","1e6acbaae7af722f17204ceccf0f7db5753eccf3","698fd91cb8c785a590bd5c01480b332c10deb757","682c45d7adb379abe89faeb95e5c4ba4e693393e","9873c86642e5c4fecb3e4e365155322ca547da7f","0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#corruptFiles(Collection[String]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#corruptFiles(Collection[String]).mjava","sourceNew":"  public synchronized void corruptFiles(Collection<String> files) throws IOException {\n    boolean disabled = TestUtil.disableVirusChecker(in);\n    try {\n      _corruptFiles(files);\n    } finally {\n      if (disabled) {\n        TestUtil.enableVirusChecker(in);\n      }\n    }\n  }\n\n","sourceOld":"  public synchronized void corruptFiles(Collection<String> files) throws IOException {\n    // Must make a copy because we change the incoming unsyncedFiles\n    // when we create temp files, delete, etc., below:\n    final List<String> filesToCorrupt = new ArrayList<>(files);\n    // sort the files otherwise we have reproducibility issues\n    // across JVMs if the incoming collection is a hashSet etc.\n    CollectionUtil.timSort(filesToCorrupt);\n    for(String name : filesToCorrupt) {\n      int damage = randomState.nextInt(6);\n      String action = null;\n\n      switch(damage) {\n\n      case 0:\n        action = \"deleted\";\n        deleteFile(name);\n        break;\n\n      case 1:\n        action = \"zeroed\";\n        // Zero out file entirely\n        long length;\n        try {\n          length = fileLength(name);\n        } catch (IOException ioe) {\n          // Ignore\n          continue;\n        }\n        byte[] zeroes = new byte[256];\n        long upto = 0;\n        try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n          while(upto < length) {\n            final int limit = (int) Math.min(length-upto, zeroes.length);\n            out.writeBytes(zeroes, 0, limit);\n            upto += limit;\n          }\n        } catch (IOException ioe) {\n          // ignore\n        }\n        break;\n\n      case 2:\n        {\n          action = \"partially truncated\";\n          // Partially Truncate the file:\n\n          // First, make temp file and copy only half this\n          // file over:\n          String tempFileName = null;\n          try (IndexOutput tempOut = in.createTempOutput(\"name\", \"mdw_corrupt\", LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState))) {\n              tempFileName = tempOut.getName();\n              tempOut.copyBytes(ii, ii.length()/2);\n            } catch (IOException ioe) {\n            // ignore\n          }\n\n          // Delete original and copy bytes back:\n          deleteFile(name);\n\n          try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState))) {\n              out.copyBytes(ii, ii.length());\n            } catch (IOException ioe) {\n            // ignore\n          }\n          deleteFile(tempFileName);\n        }\n        break;\n      \n      case 3:\n        // The file survived intact:\n        action = \"didn't change\";\n        break;\n\n      case 4:\n        // Corrupt one bit randomly in the file:\n\n        {\n\n          String tempFileName = null;\n          try (IndexOutput tempOut = in.createTempOutput(\"name\", \"mdw_corrupt\", LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState))) {\n              tempFileName = tempOut.getName();\n              if (ii.length() > 0) {\n                // Copy first part unchanged:\n                long byteToCorrupt = (long) (randomState.nextDouble() * ii.length());\n                if (byteToCorrupt > 0) {\n                  tempOut.copyBytes(ii, byteToCorrupt);\n                }\n\n                // Randomly flip one bit from this byte:\n                byte b = ii.readByte();\n                int bitToFlip = randomState.nextInt(8);\n                b = (byte) (b ^ (1 << bitToFlip));\n                tempOut.writeByte(b);\n\n                action = \"flip bit \" + bitToFlip + \" of byte \" + byteToCorrupt + \" out of \" + ii.length() + \" bytes\";\n\n                // Copy last part unchanged:\n                long bytesLeft = ii.length() - byteToCorrupt - 1;\n                if (bytesLeft > 0) {\n                  tempOut.copyBytes(ii, bytesLeft);\n                }\n              } else {\n                action = \"didn't change\";\n              }\n            } catch (IOException ioe) {\n            // ignore\n          }\n\n          // Delete original and copy bytes back:\n          deleteFile(name);\n\n          try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));\n               IndexInput ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState))) {\n              out.copyBytes(ii, ii.length());\n            } catch (IOException ioe) {\n            // ignore\n          }\n\n          deleteFile(tempFileName);\n        }\n        break;\n        \n      case 5:\n        action = \"fully truncated\";\n        // Totally truncate the file to zero bytes\n        deleteFile(name);\n\n        try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {\n          out.getFilePointer(); // just fake access to prevent compiler warning\n        } catch (IOException ioe) {\n          // ignore\n        }\n        break;\n\n      default:\n        throw new AssertionError();\n      }\n\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: \" + action + \" unsynced file: \" + name);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"fcea6cce9ade9e5e9c2c9ae2482a924c13c7f7c8":["682c45d7adb379abe89faeb95e5c4ba4e693393e"],"682c45d7adb379abe89faeb95e5c4ba4e693393e":["65fb6afbec59932f75dd371af329cb075d49844a"],"698fd91cb8c785a590bd5c01480b332c10deb757":["1e6acbaae7af722f17204ceccf0f7db5753eccf3"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":["0d49a158012a8ff48f328a4558e4bfcffbaed16f","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["682c45d7adb379abe89faeb95e5c4ba4e693393e","e2b17cf57d8de6b9abb848ee5f3848a631c539ca"],"6aaba221b22442bdf0ef28770c25fe259dfb3f55":["682c45d7adb379abe89faeb95e5c4ba4e693393e","fcea6cce9ade9e5e9c2c9ae2482a924c13c7f7c8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e2b17cf57d8de6b9abb848ee5f3848a631c539ca":["6aaba221b22442bdf0ef28770c25fe259dfb3f55"],"68496c2200e559fb7802f7575427b7a482659afb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","698fd91cb8c785a590bd5c01480b332c10deb757"],"65fb6afbec59932f75dd371af329cb075d49844a":["68496c2200e559fb7802f7575427b7a482659afb","9873c86642e5c4fecb3e4e365155322ca547da7f"],"9873c86642e5c4fecb3e4e365155322ca547da7f":["68496c2200e559fb7802f7575427b7a482659afb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e2b17cf57d8de6b9abb848ee5f3848a631c539ca"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"fcea6cce9ade9e5e9c2c9ae2482a924c13c7f7c8":["6aaba221b22442bdf0ef28770c25fe259dfb3f55"],"682c45d7adb379abe89faeb95e5c4ba4e693393e":["fcea6cce9ade9e5e9c2c9ae2482a924c13c7f7c8","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","6aaba221b22442bdf0ef28770c25fe259dfb3f55"],"698fd91cb8c785a590bd5c01480b332c10deb757":["68496c2200e559fb7802f7575427b7a482659afb"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":["698fd91cb8c785a590bd5c01480b332c10deb757"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"6aaba221b22442bdf0ef28770c25fe259dfb3f55":["e2b17cf57d8de6b9abb848ee5f3848a631c539ca"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","68496c2200e559fb7802f7575427b7a482659afb","0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"e2b17cf57d8de6b9abb848ee5f3848a631c539ca":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"68496c2200e559fb7802f7575427b7a482659afb":["65fb6afbec59932f75dd371af329cb075d49844a","9873c86642e5c4fecb3e4e365155322ca547da7f"],"65fb6afbec59932f75dd371af329cb075d49844a":["682c45d7adb379abe89faeb95e5c4ba4e693393e"],"9873c86642e5c4fecb3e4e365155322ca547da7f":["65fb6afbec59932f75dd371af329cb075d49844a"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["1e6acbaae7af722f17204ceccf0f7db5753eccf3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}