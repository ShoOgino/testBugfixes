{"path":"src/java/org/apache/solr/handler/component/SimpleStats[StatsComponent]#getFieldCacheStats(String,String[]).mjava","commits":[{"id":"758a0ba5e213f4d1fc89087ae6e4678f7879e450","date":1224361193,"type":0,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/SimpleStats[StatsComponent]#getFieldCacheStats(String,String[]).mjava","pathOld":"/dev/null","sourceNew":"  public NamedList getFieldCacheStats(String fieldName, String[] facet ) {\n    FieldType ft = searcher.getSchema().getFieldType(fieldName);\n    if( ft.isTokenized() || ft.isMultiValued() ) {\n      throw new SolrException( ErrorCode.BAD_REQUEST, \n          \"Stats are valid for single valued numeric values.  not: \"+fieldName + \"[\"+ft+\"]\" );\n    }\n\n    FieldCache.StringIndex si = null;\n    try {\n      si = FieldCache.DEFAULT.getStringIndex(searcher.getReader(), fieldName);\n    } \n    catch (IOException e) {\n      throw new RuntimeException( \"failed to open field cache for: \"+fieldName, e );\n    }\n    FieldFacetStats all = new FieldFacetStats( \"all\", si, ft );\n    if ( all.nTerms <= 0 || docs.size() <= 0 ) return null;\n    StatsValues allstats = new StatsValues();\n\n    // don't worry about faceting if the no documents match...\n    int i=0;\n    final FieldFacetStats[] finfo = new FieldFacetStats[facet.length];\n    for( String f : facet ) {\n      ft = searcher.getSchema().getFieldType(f);\n      if( ft.isTokenized() || ft.isMultiValued() ) {\n        throw new SolrException( ErrorCode.BAD_REQUEST, \n            \"Stats can only facet on single valued fields, not: \"+f + \"[\"+ft+\"]\" );\n      }\n      try {\n        si = FieldCache.DEFAULT.getStringIndex(searcher.getReader(), f);\n      } \n      catch (IOException e) {\n        throw new RuntimeException( \"failed to open field cache for: \"+f, e );\n      }\n      finfo[i++] = new FieldFacetStats( f, si, ft );\n    }\n    \n    \n    DocIterator iter = docs.iterator();\n    while (iter.hasNext()) {\n      int docID = iter.nextDoc();\n      String raw = all.getTermText(docID);\n      Double v = null;\n      if( raw != null ) {\n        v = Double.parseDouble( all.ft.indexedToReadable(raw) );\n        allstats.accumulate( v );\n      }\n      else {\n        allstats.missing++;\n      }\n      \n      // now check the facets\n      for( FieldFacetStats f : finfo ) {\n        f.facet(docID, v);\n      }\n    }\n    \n    // Find things that require a 2nd pass\n    if( params.getFieldBool(fieldName, StatsParams.STATS_TWOPASS, false) ) {\n      if( allstats.count > 1 ) { // must be 2 or more...\n        iter = docs.iterator();\n        boolean isEven = ( allstats.count % 2) == 0;\n        int medianIndex = (int) Math.ceil( allstats.count/2.0 );\n        for ( i=0; iter.hasNext(); ) {\n          String raw = all.getTermText(iter.nextDoc());\n          if( raw != null ) {\n            if( ++i == medianIndex ) {\n              double val0 = Double.parseDouble(  all.ft.indexedToReadable(raw) );\n              if( isEven ) {\n                do {\n                  raw = all.getTermText(iter.nextDoc());\n                } while( raw == null );\n                double val1 = Double.parseDouble(  all.ft.indexedToReadable(raw) );\n                allstats.median = (val0+val1)/2.0;\n              }\n              else {\n                allstats.median = val0;\n              }\n              break;\n            }\n          }\n        }\n      } // get median\n    }\n    \n    if( finfo.length > 0 ) {\n      allstats.facets = new HashMap<String, Map<String,StatsValues>>();\n      for( FieldFacetStats f : finfo ) {\n        allstats.facets.put( f.name, f.facetStatsValues );\n      }\n    }\n    return allstats.getStatsValues();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"465d12ead875b4472c72492947b22b7669403ea7","date":1229624043,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/SimpleStats[StatsComponent]#getFieldCacheStats(String,String[]).mjava","pathOld":"src/java/org/apache/solr/handler/component/SimpleStats[StatsComponent]#getFieldCacheStats(String,String[]).mjava","sourceNew":"  public NamedList getFieldCacheStats(String fieldName, String[] facet ) {\n    FieldType ft = searcher.getSchema().getFieldType(fieldName);\n    if( ft.isTokenized() || ft.isMultiValued() ) {\n      throw new SolrException( ErrorCode.BAD_REQUEST, \n          \"Stats are valid for single valued numeric values.  not: \"+fieldName + \"[\"+ft+\"]\" );\n    }\n\n    FieldCache.StringIndex si = null;\n    try {\n      si = FieldCache.DEFAULT.getStringIndex(searcher.getReader(), fieldName);\n    } \n    catch (IOException e) {\n      throw new RuntimeException( \"failed to open field cache for: \"+fieldName, e );\n    }\n    FieldFacetStats all = new FieldFacetStats( \"all\", si, ft );\n    if ( all.nTerms <= 0 || docs.size() <= 0 ) return null;\n    StatsValues allstats = new StatsValues();\n\n    // don't worry about faceting if the no documents match...\n    int i=0;\n    final FieldFacetStats[] finfo = new FieldFacetStats[facet.length];\n    for( String f : facet ) {\n      ft = searcher.getSchema().getFieldType(f);\n      if( ft.isTokenized() || ft.isMultiValued() ) {\n        throw new SolrException( ErrorCode.BAD_REQUEST, \n            \"Stats can only facet on single valued fields, not: \"+f + \"[\"+ft+\"]\" );\n      }\n      try {\n        si = FieldCache.DEFAULT.getStringIndex(searcher.getReader(), f);\n      } \n      catch (IOException e) {\n        throw new RuntimeException( \"failed to open field cache for: \"+f, e );\n      }\n      finfo[i++] = new FieldFacetStats( f, si, ft );\n    }\n    \n    \n    DocIterator iter = docs.iterator();\n    while (iter.hasNext()) {\n      int docID = iter.nextDoc();\n      String raw = all.getTermText(docID);\n      Double v = null;\n      if( raw != null ) {\n        v = Double.parseDouble( all.ft.indexedToReadable(raw) );\n        allstats.accumulate( v );\n      }\n      else {\n        allstats.missing++;\n      }\n      \n      // now check the facets\n      for( FieldFacetStats f : finfo ) {\n        f.facet(docID, v);\n      }\n    }\n    \n    if( finfo.length > 0 ) {\n      allstats.facets = new HashMap<String, Map<String,StatsValues>>();\n      for( FieldFacetStats f : finfo ) {\n        allstats.facets.put( f.name, f.facetStatsValues );\n      }\n    }\n    return allstats.getStatsValues();\n  }\n\n","sourceOld":"  public NamedList getFieldCacheStats(String fieldName, String[] facet ) {\n    FieldType ft = searcher.getSchema().getFieldType(fieldName);\n    if( ft.isTokenized() || ft.isMultiValued() ) {\n      throw new SolrException( ErrorCode.BAD_REQUEST, \n          \"Stats are valid for single valued numeric values.  not: \"+fieldName + \"[\"+ft+\"]\" );\n    }\n\n    FieldCache.StringIndex si = null;\n    try {\n      si = FieldCache.DEFAULT.getStringIndex(searcher.getReader(), fieldName);\n    } \n    catch (IOException e) {\n      throw new RuntimeException( \"failed to open field cache for: \"+fieldName, e );\n    }\n    FieldFacetStats all = new FieldFacetStats( \"all\", si, ft );\n    if ( all.nTerms <= 0 || docs.size() <= 0 ) return null;\n    StatsValues allstats = new StatsValues();\n\n    // don't worry about faceting if the no documents match...\n    int i=0;\n    final FieldFacetStats[] finfo = new FieldFacetStats[facet.length];\n    for( String f : facet ) {\n      ft = searcher.getSchema().getFieldType(f);\n      if( ft.isTokenized() || ft.isMultiValued() ) {\n        throw new SolrException( ErrorCode.BAD_REQUEST, \n            \"Stats can only facet on single valued fields, not: \"+f + \"[\"+ft+\"]\" );\n      }\n      try {\n        si = FieldCache.DEFAULT.getStringIndex(searcher.getReader(), f);\n      } \n      catch (IOException e) {\n        throw new RuntimeException( \"failed to open field cache for: \"+f, e );\n      }\n      finfo[i++] = new FieldFacetStats( f, si, ft );\n    }\n    \n    \n    DocIterator iter = docs.iterator();\n    while (iter.hasNext()) {\n      int docID = iter.nextDoc();\n      String raw = all.getTermText(docID);\n      Double v = null;\n      if( raw != null ) {\n        v = Double.parseDouble( all.ft.indexedToReadable(raw) );\n        allstats.accumulate( v );\n      }\n      else {\n        allstats.missing++;\n      }\n      \n      // now check the facets\n      for( FieldFacetStats f : finfo ) {\n        f.facet(docID, v);\n      }\n    }\n    \n    // Find things that require a 2nd pass\n    if( params.getFieldBool(fieldName, StatsParams.STATS_TWOPASS, false) ) {\n      if( allstats.count > 1 ) { // must be 2 or more...\n        iter = docs.iterator();\n        boolean isEven = ( allstats.count % 2) == 0;\n        int medianIndex = (int) Math.ceil( allstats.count/2.0 );\n        for ( i=0; iter.hasNext(); ) {\n          String raw = all.getTermText(iter.nextDoc());\n          if( raw != null ) {\n            if( ++i == medianIndex ) {\n              double val0 = Double.parseDouble(  all.ft.indexedToReadable(raw) );\n              if( isEven ) {\n                do {\n                  raw = all.getTermText(iter.nextDoc());\n                } while( raw == null );\n                double val1 = Double.parseDouble(  all.ft.indexedToReadable(raw) );\n                allstats.median = (val0+val1)/2.0;\n              }\n              else {\n                allstats.median = val0;\n              }\n              break;\n            }\n          }\n        }\n      } // get median\n    }\n    \n    if( finfo.length > 0 ) {\n      allstats.facets = new HashMap<String, Map<String,StatsValues>>();\n      for( FieldFacetStats f : finfo ) {\n        allstats.facets.put( f.name, f.facetStatsValues );\n      }\n    }\n    return allstats.getStatsValues();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"861fa37cce2d9d3f8978bbb767e87a91d41ed4a8","date":1252682465,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/SimpleStats[StatsComponent]#getFieldCacheStats(String,String[]).mjava","pathOld":"src/java/org/apache/solr/handler/component/SimpleStats[StatsComponent]#getFieldCacheStats(String,String[]).mjava","sourceNew":"  public NamedList getFieldCacheStats(String fieldName, String[] facet ) {\n    FieldType ft = searcher.getSchema().getFieldType(fieldName);\n\n    FieldCache.StringIndex si = null;\n    try {\n      si = FieldCache.DEFAULT.getStringIndex(searcher.getReader(), fieldName);\n    } \n    catch (IOException e) {\n      throw new RuntimeException( \"failed to open field cache for: \"+fieldName, e );\n    }\n    FieldFacetStats all = new FieldFacetStats( \"all\", si, ft, 0 );\n    if ( all.nTerms <= 0 || docs.size() <= 0 ) return null;\n    StatsValues allstats = new StatsValues();\n\n    // don't worry about faceting if the no documents match...\n    int i=0;\n    final FieldFacetStats[] finfo = new FieldFacetStats[facet.length];\n    for( String f : facet ) {\n      ft = searcher.getSchema().getFieldType(f);\n      try {\n        si = FieldCache.DEFAULT.getStringIndex(searcher.getReader(), f);\n      } \n      catch (IOException e) {\n        throw new RuntimeException( \"failed to open field cache for: \"+f, e );\n      }\n      finfo[i++] = new FieldFacetStats( f, si, ft, 0 );\n    }\n    \n    \n    DocIterator iter = docs.iterator();\n    while (iter.hasNext()) {\n      int docID = iter.nextDoc();\n      String raw = all.getTermText(docID);\n      Double v = null;\n      if( raw != null ) {\n        v = Double.parseDouble( all.ft.indexedToReadable(raw) );\n        allstats.accumulate( v );\n      }\n      else {\n        allstats.missing++;\n      }\n      \n      // now check the facets\n      for( FieldFacetStats f : finfo ) {\n        f.facet(docID, v);\n      }\n    }\n    \n    if( finfo.length > 0 ) {\n      allstats.facets = new HashMap<String, Map<String,StatsValues>>();\n      for( FieldFacetStats f : finfo ) {\n        allstats.facets.put( f.name, f.facetStatsValues );\n      }\n    }\n    return allstats.getStatsValues();\n  }\n\n","sourceOld":"  public NamedList getFieldCacheStats(String fieldName, String[] facet ) {\n    FieldType ft = searcher.getSchema().getFieldType(fieldName);\n    if( ft.isTokenized() || ft.isMultiValued() ) {\n      throw new SolrException( ErrorCode.BAD_REQUEST, \n          \"Stats are valid for single valued numeric values.  not: \"+fieldName + \"[\"+ft+\"]\" );\n    }\n\n    FieldCache.StringIndex si = null;\n    try {\n      si = FieldCache.DEFAULT.getStringIndex(searcher.getReader(), fieldName);\n    } \n    catch (IOException e) {\n      throw new RuntimeException( \"failed to open field cache for: \"+fieldName, e );\n    }\n    FieldFacetStats all = new FieldFacetStats( \"all\", si, ft );\n    if ( all.nTerms <= 0 || docs.size() <= 0 ) return null;\n    StatsValues allstats = new StatsValues();\n\n    // don't worry about faceting if the no documents match...\n    int i=0;\n    final FieldFacetStats[] finfo = new FieldFacetStats[facet.length];\n    for( String f : facet ) {\n      ft = searcher.getSchema().getFieldType(f);\n      if( ft.isTokenized() || ft.isMultiValued() ) {\n        throw new SolrException( ErrorCode.BAD_REQUEST, \n            \"Stats can only facet on single valued fields, not: \"+f + \"[\"+ft+\"]\" );\n      }\n      try {\n        si = FieldCache.DEFAULT.getStringIndex(searcher.getReader(), f);\n      } \n      catch (IOException e) {\n        throw new RuntimeException( \"failed to open field cache for: \"+f, e );\n      }\n      finfo[i++] = new FieldFacetStats( f, si, ft );\n    }\n    \n    \n    DocIterator iter = docs.iterator();\n    while (iter.hasNext()) {\n      int docID = iter.nextDoc();\n      String raw = all.getTermText(docID);\n      Double v = null;\n      if( raw != null ) {\n        v = Double.parseDouble( all.ft.indexedToReadable(raw) );\n        allstats.accumulate( v );\n      }\n      else {\n        allstats.missing++;\n      }\n      \n      // now check the facets\n      for( FieldFacetStats f : finfo ) {\n        f.facet(docID, v);\n      }\n    }\n    \n    if( finfo.length > 0 ) {\n      allstats.facets = new HashMap<String, Map<String,StatsValues>>();\n      for( FieldFacetStats f : finfo ) {\n        allstats.facets.put( f.name, f.facetStatsValues );\n      }\n    }\n    return allstats.getStatsValues();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c1c2dfb6aa7b4d342a493c0982be96b76f595add","date":1252705594,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/SimpleStats[StatsComponent]#getFieldCacheStats(String,String[]).mjava","pathOld":"src/java/org/apache/solr/handler/component/SimpleStats[StatsComponent]#getFieldCacheStats(String,String[]).mjava","sourceNew":"  public NamedList getFieldCacheStats(String fieldName, String[] facet ) {\n    FieldType ft = searcher.getSchema().getFieldType(fieldName);\n\n    FieldCache.StringIndex si = null;\n    try {\n      si = FieldCache.DEFAULT.getStringIndex(searcher.getReader(), fieldName);\n    } \n    catch (IOException e) {\n      throw new RuntimeException( \"failed to open field cache for: \"+fieldName, e );\n    }\n    FieldFacetStats all = new FieldFacetStats( \"all\", si, ft, 0 );\n    StatsValues allstats = new StatsValues();\n    if ( all.nTerms <= 0 || docs.size() <= 0 ) return allstats.getStatsValues();\n\n    // don't worry about faceting if the no documents match...\n    int i=0;\n    final FieldFacetStats[] finfo = new FieldFacetStats[facet.length];\n    for( String f : facet ) {\n      ft = searcher.getSchema().getFieldType(f);\n      try {\n        si = FieldCache.DEFAULT.getStringIndex(searcher.getReader(), f);\n      } \n      catch (IOException e) {\n        throw new RuntimeException( \"failed to open field cache for: \"+f, e );\n      }\n      finfo[i++] = new FieldFacetStats( f, si, ft, 0 );\n    }\n    \n    \n    DocIterator iter = docs.iterator();\n    while (iter.hasNext()) {\n      int docID = iter.nextDoc();\n      String raw = all.getTermText(docID);\n      Double v = null;\n      if( raw != null ) {\n        v = Double.parseDouble( all.ft.indexedToReadable(raw) );\n        allstats.accumulate( v );\n      }\n      else {\n        allstats.missing++;\n      }\n      \n      // now check the facets\n      for( FieldFacetStats f : finfo ) {\n        f.facet(docID, v);\n      }\n    }\n    \n    if( finfo.length > 0 ) {\n      allstats.facets = new HashMap<String, Map<String,StatsValues>>();\n      for( FieldFacetStats f : finfo ) {\n        allstats.facets.put( f.name, f.facetStatsValues );\n      }\n    }\n    return allstats.getStatsValues();\n  }\n\n","sourceOld":"  public NamedList getFieldCacheStats(String fieldName, String[] facet ) {\n    FieldType ft = searcher.getSchema().getFieldType(fieldName);\n\n    FieldCache.StringIndex si = null;\n    try {\n      si = FieldCache.DEFAULT.getStringIndex(searcher.getReader(), fieldName);\n    } \n    catch (IOException e) {\n      throw new RuntimeException( \"failed to open field cache for: \"+fieldName, e );\n    }\n    FieldFacetStats all = new FieldFacetStats( \"all\", si, ft, 0 );\n    if ( all.nTerms <= 0 || docs.size() <= 0 ) return null;\n    StatsValues allstats = new StatsValues();\n\n    // don't worry about faceting if the no documents match...\n    int i=0;\n    final FieldFacetStats[] finfo = new FieldFacetStats[facet.length];\n    for( String f : facet ) {\n      ft = searcher.getSchema().getFieldType(f);\n      try {\n        si = FieldCache.DEFAULT.getStringIndex(searcher.getReader(), f);\n      } \n      catch (IOException e) {\n        throw new RuntimeException( \"failed to open field cache for: \"+f, e );\n      }\n      finfo[i++] = new FieldFacetStats( f, si, ft, 0 );\n    }\n    \n    \n    DocIterator iter = docs.iterator();\n    while (iter.hasNext()) {\n      int docID = iter.nextDoc();\n      String raw = all.getTermText(docID);\n      Double v = null;\n      if( raw != null ) {\n        v = Double.parseDouble( all.ft.indexedToReadable(raw) );\n        allstats.accumulate( v );\n      }\n      else {\n        allstats.missing++;\n      }\n      \n      // now check the facets\n      for( FieldFacetStats f : finfo ) {\n        f.facet(docID, v);\n      }\n    }\n    \n    if( finfo.length > 0 ) {\n      allstats.facets = new HashMap<String, Map<String,StatsValues>>();\n      for( FieldFacetStats f : finfo ) {\n        allstats.facets.put( f.name, f.facetStatsValues );\n      }\n    }\n    return allstats.getStatsValues();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/SimpleStats[StatsComponent]#getFieldCacheStats(String,String[]).mjava","pathOld":"src/java/org/apache/solr/handler/component/SimpleStats[StatsComponent]#getFieldCacheStats(String,String[]).mjava","sourceNew":"  public NamedList getFieldCacheStats(String fieldName, String[] facet ) {\n    FieldType ft = searcher.getSchema().getFieldType(fieldName);\n\n    FieldCache.StringIndex si = null;\n    try {\n      si = FieldCache.DEFAULT.getStringIndex(searcher.getReader(), fieldName);\n    } \n    catch (IOException e) {\n      throw new RuntimeException( \"failed to open field cache for: \"+fieldName, e );\n    }\n    FieldFacetStats all = new FieldFacetStats( \"all\", si, ft, 0 );\n    StatsValues allstats = new StatsValues();\n    if ( all.nTerms <= 0 || docs.size() <= 0 ) return allstats.getStatsValues();\n\n    // don't worry about faceting if the no documents match...\n    int i=0;\n    final FieldFacetStats[] finfo = new FieldFacetStats[facet.length];\n    for( String f : facet ) {\n      ft = searcher.getSchema().getFieldType(f);\n      try {\n        si = FieldCache.DEFAULT.getStringIndex(searcher.getReader(), f);\n      } \n      catch (IOException e) {\n        throw new RuntimeException( \"failed to open field cache for: \"+f, e );\n      }\n      finfo[i++] = new FieldFacetStats( f, si, ft, 0 );\n    }\n    \n    \n    DocIterator iter = docs.iterator();\n    while (iter.hasNext()) {\n      int docID = iter.nextDoc();\n      String raw = all.getTermText(docID);\n      Double v = null;\n      if( raw != null ) {\n        v = Double.parseDouble( all.ft.indexedToReadable(raw) );\n        allstats.accumulate( v );\n      }\n      else {\n        allstats.missing++;\n      }\n      \n      // now check the facets\n      for( FieldFacetStats f : finfo ) {\n        f.facet(docID, v);\n      }\n    }\n    \n    if( finfo.length > 0 ) {\n      allstats.facets = new HashMap<String, Map<String,StatsValues>>();\n      for( FieldFacetStats f : finfo ) {\n        allstats.facets.put( f.name, f.facetStatsValues );\n      }\n    }\n    return allstats.getStatsValues();\n  }\n\n","sourceOld":"  public NamedList getFieldCacheStats(String fieldName, String[] facet ) {\n    FieldType ft = searcher.getSchema().getFieldType(fieldName);\n\n    FieldCache.StringIndex si = null;\n    try {\n      si = FieldCache.DEFAULT.getStringIndex(searcher.getReader(), fieldName);\n    } \n    catch (IOException e) {\n      throw new RuntimeException( \"failed to open field cache for: \"+fieldName, e );\n    }\n    FieldFacetStats all = new FieldFacetStats( \"all\", si, ft, 0 );\n    StatsValues allstats = new StatsValues();\n    if ( all.nTerms <= 0 || docs.size() <= 0 ) return allstats.getStatsValues();\n\n    // don't worry about faceting if the no documents match...\n    int i=0;\n    final FieldFacetStats[] finfo = new FieldFacetStats[facet.length];\n    for( String f : facet ) {\n      ft = searcher.getSchema().getFieldType(f);\n      try {\n        si = FieldCache.DEFAULT.getStringIndex(searcher.getReader(), f);\n      } \n      catch (IOException e) {\n        throw new RuntimeException( \"failed to open field cache for: \"+f, e );\n      }\n      finfo[i++] = new FieldFacetStats( f, si, ft, 0 );\n    }\n    \n    \n    DocIterator iter = docs.iterator();\n    while (iter.hasNext()) {\n      int docID = iter.nextDoc();\n      String raw = all.getTermText(docID);\n      Double v = null;\n      if( raw != null ) {\n        v = Double.parseDouble( all.ft.indexedToReadable(raw) );\n        allstats.accumulate( v );\n      }\n      else {\n        allstats.missing++;\n      }\n      \n      // now check the facets\n      for( FieldFacetStats f : finfo ) {\n        f.facet(docID, v);\n      }\n    }\n    \n    if( finfo.length > 0 ) {\n      allstats.facets = new HashMap<String, Map<String,StatsValues>>();\n      for( FieldFacetStats f : finfo ) {\n        allstats.facets.put( f.name, f.facetStatsValues );\n      }\n    }\n    return allstats.getStatsValues();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c1c2dfb6aa7b4d342a493c0982be96b76f595add":["861fa37cce2d9d3f8978bbb767e87a91d41ed4a8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"758a0ba5e213f4d1fc89087ae6e4678f7879e450":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"ad94625fb8d088209f46650c8097196fec67f00c":["c1c2dfb6aa7b4d342a493c0982be96b76f595add"],"465d12ead875b4472c72492947b22b7669403ea7":["758a0ba5e213f4d1fc89087ae6e4678f7879e450"],"861fa37cce2d9d3f8978bbb767e87a91d41ed4a8":["465d12ead875b4472c72492947b22b7669403ea7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"c1c2dfb6aa7b4d342a493c0982be96b76f595add":["ad94625fb8d088209f46650c8097196fec67f00c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["758a0ba5e213f4d1fc89087ae6e4678f7879e450"],"758a0ba5e213f4d1fc89087ae6e4678f7879e450":["465d12ead875b4472c72492947b22b7669403ea7"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"465d12ead875b4472c72492947b22b7669403ea7":["861fa37cce2d9d3f8978bbb767e87a91d41ed4a8"],"861fa37cce2d9d3f8978bbb767e87a91d41ed4a8":["c1c2dfb6aa7b4d342a493c0982be96b76f595add"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"pathCommit":null}