{"path":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillSidewaysScorer#doBaseAdvanceScoring(Collector,DocsEnum[][],Collector[]).mjava","commits":[{"id":"5b1ac4be5e40d7bda6ec0f850c933a95ca0642fd","date":1361836936,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillSidewaysScorer#doBaseAdvanceScoring(Collector,DocsEnum[][],Collector[]).mjava","pathOld":"/dev/null","sourceNew":"  /** Used when base query is highly constraining vs the\n   *  drilldowns; in this case we just .next() on base and\n   *  .advance() on the dims. */\n  private void doBaseAdvanceScoring(Collector collector, DocsEnum[][] docsEnums, Collector[] sidewaysCollectors) throws IOException {\n    //if (DEBUG) {\n    //  System.out.println(\"  doBaseAdvanceScoring\");\n    //}\n    int docID = baseScorer.docID();\n\n    final int numDims = dims.length;\n\n    nextDoc: while (docID != NO_MORE_DOCS) {\n      int failedDim = -1;\n      for(int dim=0;dim<numDims;dim++) {\n        // TODO: should we sort this 2nd dimension of\n        // docsEnums from most frequent to least?\n        boolean found = false;\n        for(DocsEnum docsEnum : docsEnums[dim]) {\n          if (docsEnum == null) {\n            continue;\n          }\n          if (docsEnum.docID() < docID) {\n            docsEnum.advance(docID);\n          }\n          if (docsEnum.docID() == docID) {\n            found = true;\n            break;\n          }\n        }\n        if (!found) {\n          if (failedDim != -1) {\n            // More than one dim fails on this document, so\n            // it's neither a hit nor a near-miss; move to\n            // next doc:\n            docID = baseScorer.nextDoc();\n            continue nextDoc;\n          } else {\n            failedDim = dim;\n          }\n        }\n      }\n\n      collectDocID = docID;\n\n      // TODO: we could score on demand instead since we are\n      // daat here:\n      collectScore = baseScorer.score();\n\n      if (failedDim == -1) {\n        collectHit(collector, sidewaysCollectors);\n      } else {\n        collectNearMiss(sidewaysCollectors, failedDim);\n      }\n\n      docID = baseScorer.nextDoc();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d33e19a97046248623a7591aeaa6547233fd15e2","date":1385424777,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillSidewaysScorer#doBaseAdvanceScoring(Collector,DocsEnum[][],Collector[]).mjava","sourceNew":null,"sourceOld":"  /** Used when base query is highly constraining vs the\n   *  drilldowns; in this case we just .next() on base and\n   *  .advance() on the dims. */\n  private void doBaseAdvanceScoring(Collector collector, DocsEnum[][] docsEnums, Collector[] sidewaysCollectors) throws IOException {\n    //if (DEBUG) {\n    //  System.out.println(\"  doBaseAdvanceScoring\");\n    //}\n    int docID = baseScorer.docID();\n\n    final int numDims = dims.length;\n\n    nextDoc: while (docID != NO_MORE_DOCS) {\n      int failedDim = -1;\n      for(int dim=0;dim<numDims;dim++) {\n        // TODO: should we sort this 2nd dimension of\n        // docsEnums from most frequent to least?\n        boolean found = false;\n        for(DocsEnum docsEnum : docsEnums[dim]) {\n          if (docsEnum == null) {\n            continue;\n          }\n          if (docsEnum.docID() < docID) {\n            docsEnum.advance(docID);\n          }\n          if (docsEnum.docID() == docID) {\n            found = true;\n            break;\n          }\n        }\n        if (!found) {\n          if (failedDim != -1) {\n            // More than one dim fails on this document, so\n            // it's neither a hit nor a near-miss; move to\n            // next doc:\n            docID = baseScorer.nextDoc();\n            continue nextDoc;\n          } else {\n            failedDim = dim;\n          }\n        }\n      }\n\n      collectDocID = docID;\n\n      // TODO: we could score on demand instead since we are\n      // daat here:\n      collectScore = baseScorer.score();\n\n      if (failedDim == -1) {\n        collectHit(collector, sidewaysCollectors);\n      } else {\n        collectNearMiss(sidewaysCollectors, failedDim);\n      }\n\n      docID = baseScorer.nextDoc();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cc728b07df73b197e6d940d27f9b08b63918f13","date":1388834348,"type":5,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillSidewaysScorer#doBaseAdvanceScoring(Collector,DocsEnum[][],Collector[]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/search/DrillSidewaysScorer#doBaseAdvanceScoring(Collector,DocsEnum[][],Collector[]).mjava","sourceNew":"  /** Used when base query is highly constraining vs the\n   *  drilldowns; in this case we just .next() on base and\n   *  .advance() on the dims. */\n  private void doBaseAdvanceScoring(Collector collector, DocsEnum[][] docsEnums, Collector[] sidewaysCollectors) throws IOException {\n    //if (DEBUG) {\n    //  System.out.println(\"  doBaseAdvanceScoring\");\n    //}\n    int docID = baseScorer.docID();\n\n    final int numDims = dims.length;\n\n    nextDoc: while (docID != NO_MORE_DOCS) {\n      int failedDim = -1;\n      for(int dim=0;dim<numDims;dim++) {\n        // TODO: should we sort this 2nd dimension of\n        // docsEnums from most frequent to least?\n        boolean found = false;\n        for(DocsEnum docsEnum : docsEnums[dim]) {\n          if (docsEnum == null) {\n            continue;\n          }\n          if (docsEnum.docID() < docID) {\n            docsEnum.advance(docID);\n          }\n          if (docsEnum.docID() == docID) {\n            found = true;\n            break;\n          }\n        }\n        if (!found) {\n          if (failedDim != -1) {\n            // More than one dim fails on this document, so\n            // it's neither a hit nor a near-miss; move to\n            // next doc:\n            docID = baseScorer.nextDoc();\n            continue nextDoc;\n          } else {\n            failedDim = dim;\n          }\n        }\n      }\n\n      collectDocID = docID;\n\n      // TODO: we could score on demand instead since we are\n      // daat here:\n      collectScore = baseScorer.score();\n\n      if (failedDim == -1) {\n        collectHit(collector, sidewaysCollectors);\n      } else {\n        collectNearMiss(sidewaysCollectors, failedDim);\n      }\n\n      docID = baseScorer.nextDoc();\n    }\n  }\n\n","sourceOld":"  /** Used when base query is highly constraining vs the\n   *  drilldowns; in this case we just .next() on base and\n   *  .advance() on the dims. */\n  private void doBaseAdvanceScoring(Collector collector, DocsEnum[][] docsEnums, Collector[] sidewaysCollectors) throws IOException {\n    //if (DEBUG) {\n    //  System.out.println(\"  doBaseAdvanceScoring\");\n    //}\n    int docID = baseScorer.docID();\n\n    final int numDims = dims.length;\n\n    nextDoc: while (docID != NO_MORE_DOCS) {\n      int failedDim = -1;\n      for(int dim=0;dim<numDims;dim++) {\n        // TODO: should we sort this 2nd dimension of\n        // docsEnums from most frequent to least?\n        boolean found = false;\n        for(DocsEnum docsEnum : docsEnums[dim]) {\n          if (docsEnum == null) {\n            continue;\n          }\n          if (docsEnum.docID() < docID) {\n            docsEnum.advance(docID);\n          }\n          if (docsEnum.docID() == docID) {\n            found = true;\n            break;\n          }\n        }\n        if (!found) {\n          if (failedDim != -1) {\n            // More than one dim fails on this document, so\n            // it's neither a hit nor a near-miss; move to\n            // next doc:\n            docID = baseScorer.nextDoc();\n            continue nextDoc;\n          } else {\n            failedDim = dim;\n          }\n        }\n      }\n\n      collectDocID = docID;\n\n      // TODO: we could score on demand instead since we are\n      // daat here:\n      collectScore = baseScorer.score();\n\n      if (failedDim == -1) {\n        collectHit(collector, sidewaysCollectors);\n      } else {\n        collectNearMiss(sidewaysCollectors, failedDim);\n      }\n\n      docID = baseScorer.nextDoc();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5b1ac4be5e40d7bda6ec0f850c933a95ca0642fd":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d33e19a97046248623a7591aeaa6547233fd15e2":["5b1ac4be5e40d7bda6ec0f850c933a95ca0642fd"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cc728b07df73b197e6d940d27f9b08b63918f13":["5b1ac4be5e40d7bda6ec0f850c933a95ca0642fd","d33e19a97046248623a7591aeaa6547233fd15e2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3cc728b07df73b197e6d940d27f9b08b63918f13"]},"commit2Childs":{"5b1ac4be5e40d7bda6ec0f850c933a95ca0642fd":["d33e19a97046248623a7591aeaa6547233fd15e2","3cc728b07df73b197e6d940d27f9b08b63918f13"],"d33e19a97046248623a7591aeaa6547233fd15e2":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5b1ac4be5e40d7bda6ec0f850c933a95ca0642fd"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}