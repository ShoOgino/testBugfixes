{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#CloudSolrClient(Collection[String],String,HttpClient,LBHttpSolrClient,LBHttpSolrClient.Builder,boolean,boolean,ClusterStateProvider).mjava","commits":[{"id":"3eaeb36333664e8cb92108ef03f68a7b90beb759","date":1480015298,"type":1,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#CloudSolrClient(Collection[String],String,HttpClient,LBHttpSolrClient,LBHttpSolrClient.Builder,boolean,boolean,ClusterStateProvider).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#CloudSolrClient(Collection[String],String,HttpClient,LBHttpSolrClient,LBHttpSolrClient.Builder,boolean,boolean).mjava","sourceNew":"  /**\n   * Create a new client object that connects to Zookeeper and is always aware\n   * of the SolrCloud state. If there is a fully redundant Zookeeper quorum and\n   * SolrCloud has enough replicas for every shard in a collection, there is no\n   * single point of failure. Updates will be sent to shard leaders by default.\n   *\n   * @param zkHosts\n   *          A Java Collection (List, Set, etc) of HOST:PORT strings, one for\n   *          each host in the zookeeper ensemble. Note that with certain\n   *          Collection types like HashSet, the order of hosts in the final\n   *          connect string may not be in the same order you added them.\n   * @param chroot\n   *          A chroot value for zookeeper, starting with a forward slash. If no\n   *          chroot is required, use null.\n   * @param httpClient\n   *          the {@link HttpClient} instance to be used for all requests. The provided httpClient should use a\n   *          multi-threaded connection manager.  If null, a default HttpClient will be used.\n   * @param lbSolrClient\n   *          LBHttpSolrClient instance for requests.  If null, a default LBHttpSolrClient will be used.\n   * @param lbHttpSolrClientBuilder\n   *          LBHttpSolrClient builder to construct the LBHttpSolrClient. If null, a default builder will be used.\n   * @param updatesToLeaders\n   *          If true, sends updates to shard leaders.\n   * @param directUpdatesToLeadersOnly\n   *          If true, sends direct updates to shard leaders only.\n   */\n  private CloudSolrClient(Collection<String> zkHosts,\n                          String chroot,\n                          HttpClient httpClient,\n                          LBHttpSolrClient lbSolrClient,\n                          LBHttpSolrClient.Builder lbHttpSolrClientBuilder,\n                          boolean updatesToLeaders,\n                          boolean directUpdatesToLeadersOnly,\n                          ClusterStateProvider stateProvider\n\n  ) {\n    if (stateProvider == null) {\n      this.stateProvider = new ZkClientClusterStateProvider(zkHosts, chroot);\n    } else {\n      this.stateProvider = stateProvider;\n    }\n    this.clientIsInternal = httpClient == null;\n    this.shutdownLBHttpSolrServer = lbSolrClient == null;\n    if(lbHttpSolrClientBuilder != null) lbSolrClient = lbHttpSolrClientBuilder.build();\n    if(lbSolrClient != null) httpClient = lbSolrClient.getHttpClient();\n    this.myClient = httpClient == null ? HttpClientUtil.createClient(null) : httpClient;\n    if (lbSolrClient == null) lbSolrClient = createLBHttpSolrClient(myClient);\n    this.lbClient = lbSolrClient;\n    this.updatesToLeaders = updatesToLeaders;\n    this.directUpdatesToLeadersOnly = directUpdatesToLeadersOnly;\n  }\n\n","sourceOld":"  /**\n   * Create a new client object that connects to Zookeeper and is always aware\n   * of the SolrCloud state. If there is a fully redundant Zookeeper quorum and\n   * SolrCloud has enough replicas for every shard in a collection, there is no\n   * single point of failure. Updates will be sent to shard leaders by default.\n   *\n   * @param zkHosts\n   *          A Java Collection (List, Set, etc) of HOST:PORT strings, one for\n   *          each host in the zookeeper ensemble. Note that with certain\n   *          Collection types like HashSet, the order of hosts in the final\n   *          connect string may not be in the same order you added them.\n   * @param chroot\n   *          A chroot value for zookeeper, starting with a forward slash. If no\n   *          chroot is required, use null.\n   * @param httpClient\n   *          the {@link HttpClient} instance to be used for all requests. The provided httpClient should use a\n   *          multi-threaded connection manager.  If null, a default HttpClient will be used.\n   * @param lbSolrClient\n   *          LBHttpSolrClient instance for requests.  If null, a default LBHttpSolrClient will be used.\n   * @param lbHttpSolrClientBuilder\n   *          LBHttpSolrClient builder to construct the LBHttpSolrClient. If null, a default builder will be used.\n   * @param updatesToLeaders\n   *          If true, sends updates to shard leaders.\n   * @param directUpdatesToLeadersOnly\n   *          If true, sends direct updates to shard leaders only.\n   */\n  private CloudSolrClient(Collection<String> zkHosts,\n                          String chroot,\n                          HttpClient httpClient,\n                          LBHttpSolrClient lbSolrClient,\n                          LBHttpSolrClient.Builder lbHttpSolrClientBuilder,\n                          boolean updatesToLeaders,\n                          boolean directUpdatesToLeadersOnly) {\n    this.zkHost = buildZkHostString(zkHosts, chroot);\n    this.clientIsInternal = httpClient == null;\n    this.shutdownLBHttpSolrServer = lbSolrClient == null;\n    if(lbHttpSolrClientBuilder != null) lbSolrClient = lbHttpSolrClientBuilder.build();\n    if(lbSolrClient != null) httpClient = lbSolrClient.getHttpClient();\n    this.myClient = httpClient == null ? HttpClientUtil.createClient(null) : httpClient;\n    if (lbSolrClient == null) lbSolrClient = createLBHttpSolrClient(myClient);\n    this.lbClient = lbSolrClient;\n    this.updatesToLeaders = updatesToLeaders;\n    this.directUpdatesToLeadersOnly = directUpdatesToLeadersOnly;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"727bb765ff2542275f6d31f67be18d7104bae148","date":1480353976,"type":1,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#CloudSolrClient(Collection[String],String,HttpClient,LBHttpSolrClient,LBHttpSolrClient.Builder,boolean,boolean,ClusterStateProvider).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#CloudSolrClient(Collection[String],String,HttpClient,LBHttpSolrClient,LBHttpSolrClient.Builder,boolean,boolean).mjava","sourceNew":"  /**\n   * Create a new client object that connects to Zookeeper and is always aware\n   * of the SolrCloud state. If there is a fully redundant Zookeeper quorum and\n   * SolrCloud has enough replicas for every shard in a collection, there is no\n   * single point of failure. Updates will be sent to shard leaders by default.\n   *\n   * @param zkHosts\n   *          A Java Collection (List, Set, etc) of HOST:PORT strings, one for\n   *          each host in the zookeeper ensemble. Note that with certain\n   *          Collection types like HashSet, the order of hosts in the final\n   *          connect string may not be in the same order you added them.\n   * @param chroot\n   *          A chroot value for zookeeper, starting with a forward slash. If no\n   *          chroot is required, use null.\n   * @param httpClient\n   *          the {@link HttpClient} instance to be used for all requests. The provided httpClient should use a\n   *          multi-threaded connection manager.  If null, a default HttpClient will be used.\n   * @param lbSolrClient\n   *          LBHttpSolrClient instance for requests.  If null, a default LBHttpSolrClient will be used.\n   * @param lbHttpSolrClientBuilder\n   *          LBHttpSolrClient builder to construct the LBHttpSolrClient. If null, a default builder will be used.\n   * @param updatesToLeaders\n   *          If true, sends updates to shard leaders.\n   * @param directUpdatesToLeadersOnly\n   *          If true, sends direct updates to shard leaders only.\n   */\n  private CloudSolrClient(Collection<String> zkHosts,\n                          String chroot,\n                          HttpClient httpClient,\n                          LBHttpSolrClient lbSolrClient,\n                          LBHttpSolrClient.Builder lbHttpSolrClientBuilder,\n                          boolean updatesToLeaders,\n                          boolean directUpdatesToLeadersOnly,\n                          ClusterStateProvider stateProvider\n\n  ) {\n    if (stateProvider == null) {\n      this.stateProvider = new ZkClientClusterStateProvider(zkHosts, chroot);\n    } else {\n      this.stateProvider = stateProvider;\n    }\n    this.clientIsInternal = httpClient == null;\n    this.shutdownLBHttpSolrServer = lbSolrClient == null;\n    if(lbHttpSolrClientBuilder != null) lbSolrClient = lbHttpSolrClientBuilder.build();\n    if(lbSolrClient != null) httpClient = lbSolrClient.getHttpClient();\n    this.myClient = httpClient == null ? HttpClientUtil.createClient(null) : httpClient;\n    if (lbSolrClient == null) lbSolrClient = createLBHttpSolrClient(myClient);\n    this.lbClient = lbSolrClient;\n    this.updatesToLeaders = updatesToLeaders;\n    this.directUpdatesToLeadersOnly = directUpdatesToLeadersOnly;\n  }\n\n","sourceOld":"  /**\n   * Create a new client object that connects to Zookeeper and is always aware\n   * of the SolrCloud state. If there is a fully redundant Zookeeper quorum and\n   * SolrCloud has enough replicas for every shard in a collection, there is no\n   * single point of failure. Updates will be sent to shard leaders by default.\n   *\n   * @param zkHosts\n   *          A Java Collection (List, Set, etc) of HOST:PORT strings, one for\n   *          each host in the zookeeper ensemble. Note that with certain\n   *          Collection types like HashSet, the order of hosts in the final\n   *          connect string may not be in the same order you added them.\n   * @param chroot\n   *          A chroot value for zookeeper, starting with a forward slash. If no\n   *          chroot is required, use null.\n   * @param httpClient\n   *          the {@link HttpClient} instance to be used for all requests. The provided httpClient should use a\n   *          multi-threaded connection manager.  If null, a default HttpClient will be used.\n   * @param lbSolrClient\n   *          LBHttpSolrClient instance for requests.  If null, a default LBHttpSolrClient will be used.\n   * @param lbHttpSolrClientBuilder\n   *          LBHttpSolrClient builder to construct the LBHttpSolrClient. If null, a default builder will be used.\n   * @param updatesToLeaders\n   *          If true, sends updates to shard leaders.\n   * @param directUpdatesToLeadersOnly\n   *          If true, sends direct updates to shard leaders only.\n   */\n  private CloudSolrClient(Collection<String> zkHosts,\n                          String chroot,\n                          HttpClient httpClient,\n                          LBHttpSolrClient lbSolrClient,\n                          LBHttpSolrClient.Builder lbHttpSolrClientBuilder,\n                          boolean updatesToLeaders,\n                          boolean directUpdatesToLeadersOnly) {\n    this.zkHost = buildZkHostString(zkHosts, chroot);\n    this.clientIsInternal = httpClient == null;\n    this.shutdownLBHttpSolrServer = lbSolrClient == null;\n    if(lbHttpSolrClientBuilder != null) lbSolrClient = lbHttpSolrClientBuilder.build();\n    if(lbSolrClient != null) httpClient = lbSolrClient.getHttpClient();\n    this.myClient = httpClient == null ? HttpClientUtil.createClient(null) : httpClient;\n    if (lbSolrClient == null) lbSolrClient = createLBHttpSolrClient(myClient);\n    this.lbClient = lbSolrClient;\n    this.updatesToLeaders = updatesToLeaders;\n    this.directUpdatesToLeadersOnly = directUpdatesToLeadersOnly;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a64b273d51a6540272668680ece9f8b686ff0004","date":1492404078,"type":5,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#CloudSolrClient(Collection[String],String,List[String],HttpClient,LBHttpSolrClient,LBHttpSolrClient.Builder,boolean,boolean,ClusterStateProvider).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#CloudSolrClient(Collection[String],String,HttpClient,LBHttpSolrClient,LBHttpSolrClient.Builder,boolean,boolean,ClusterStateProvider).mjava","sourceNew":"  /**\n   * Create a new client object that connects to Zookeeper and is always aware\n   * of the SolrCloud state. If there is a fully redundant Zookeeper quorum and\n   * SolrCloud has enough replicas for every shard in a collection, there is no\n   * single point of failure. Updates will be sent to shard leaders by default.\n   *\n   * @param zkHosts\n   *          A Java Collection (List, Set, etc) of HOST:PORT strings, one for\n   *          each host in the zookeeper ensemble. Note that with certain\n   *          Collection types like HashSet, the order of hosts in the final\n   *          connect string may not be in the same order you added them.\n   *          Provide only one of solrUrls or zkHosts.\n   * @param chroot\n   *          A chroot value for zookeeper, starting with a forward slash. If no\n   *          chroot is required, use null.\n   * @param solrUrls\n   *          A list of Solr URLs to configure the underlying {@link HttpClusterStateProvider}, which will\n   *          use of the these URLs to fetch the list of live nodes for this Solr cluster. Provide only\n   *          one of solrUrls or zkHosts.\n   * @param httpClient\n   *          the {@link HttpClient} instance to be used for all requests. The provided httpClient should use a\n   *          multi-threaded connection manager.  If null, a default HttpClient will be used.\n   * @param lbSolrClient\n   *          LBHttpSolrClient instance for requests.  If null, a default LBHttpSolrClient will be used.\n   * @param lbHttpSolrClientBuilder\n   *          LBHttpSolrClient builder to construct the LBHttpSolrClient. If null, a default builder will be used.\n   * @param updatesToLeaders\n   *          If true, sends updates to shard leaders.\n   * @param directUpdatesToLeadersOnly\n   *          If true, sends direct updates to shard leaders only.\n   */\n  private CloudSolrClient(Collection<String> zkHosts,\n                          String chroot,\n                          List<String> solrUrls,\n                          HttpClient httpClient,\n                          LBHttpSolrClient lbSolrClient,\n                          LBHttpSolrClient.Builder lbHttpSolrClientBuilder,\n                          boolean updatesToLeaders,\n                          boolean directUpdatesToLeadersOnly,\n                          ClusterStateProvider stateProvider\n\n  ) {\n    if (stateProvider == null) {\n      if (zkHosts != null && solrUrls != null) {\n        throw new IllegalArgumentException(\"Both zkHost(s) & solrUrl(s) have been specified. Only specify one.\");\n      }\n      if (zkHosts != null) {\n        this.stateProvider = new ZkClientClusterStateProvider(zkHosts, chroot);\n      } else if (solrUrls != null && !solrUrls.isEmpty()) {\n        try {\n          this.stateProvider = new HttpClusterStateProvider(solrUrls, httpClient);\n        } catch (Exception e) {\n          throw new RuntimeException(\"Couldn't initialize a HttpClusterStateProvider (is/are the \"\n              + \"Solr server(s), \"  + solrUrls + \", down?)\", e);\n        }\n      } else {\n        throw new IllegalArgumentException(\"Both zkHosts and solrUrl cannot be null.\");\n      }\n    } else {\n      this.stateProvider = stateProvider;\n    }\n    this.clientIsInternal = httpClient == null;\n    this.shutdownLBHttpSolrServer = lbSolrClient == null;\n    if(lbHttpSolrClientBuilder != null) lbSolrClient = lbHttpSolrClientBuilder.build();\n    if(lbSolrClient != null) httpClient = lbSolrClient.getHttpClient();\n    this.myClient = httpClient == null ? HttpClientUtil.createClient(null) : httpClient;\n    if (lbSolrClient == null) lbSolrClient = createLBHttpSolrClient(myClient);\n    this.lbClient = lbSolrClient;\n    this.updatesToLeaders = updatesToLeaders;\n    this.directUpdatesToLeadersOnly = directUpdatesToLeadersOnly;\n  }\n\n","sourceOld":"  /**\n   * Create a new client object that connects to Zookeeper and is always aware\n   * of the SolrCloud state. If there is a fully redundant Zookeeper quorum and\n   * SolrCloud has enough replicas for every shard in a collection, there is no\n   * single point of failure. Updates will be sent to shard leaders by default.\n   *\n   * @param zkHosts\n   *          A Java Collection (List, Set, etc) of HOST:PORT strings, one for\n   *          each host in the zookeeper ensemble. Note that with certain\n   *          Collection types like HashSet, the order of hosts in the final\n   *          connect string may not be in the same order you added them.\n   * @param chroot\n   *          A chroot value for zookeeper, starting with a forward slash. If no\n   *          chroot is required, use null.\n   * @param httpClient\n   *          the {@link HttpClient} instance to be used for all requests. The provided httpClient should use a\n   *          multi-threaded connection manager.  If null, a default HttpClient will be used.\n   * @param lbSolrClient\n   *          LBHttpSolrClient instance for requests.  If null, a default LBHttpSolrClient will be used.\n   * @param lbHttpSolrClientBuilder\n   *          LBHttpSolrClient builder to construct the LBHttpSolrClient. If null, a default builder will be used.\n   * @param updatesToLeaders\n   *          If true, sends updates to shard leaders.\n   * @param directUpdatesToLeadersOnly\n   *          If true, sends direct updates to shard leaders only.\n   */\n  private CloudSolrClient(Collection<String> zkHosts,\n                          String chroot,\n                          HttpClient httpClient,\n                          LBHttpSolrClient lbSolrClient,\n                          LBHttpSolrClient.Builder lbHttpSolrClientBuilder,\n                          boolean updatesToLeaders,\n                          boolean directUpdatesToLeadersOnly,\n                          ClusterStateProvider stateProvider\n\n  ) {\n    if (stateProvider == null) {\n      this.stateProvider = new ZkClientClusterStateProvider(zkHosts, chroot);\n    } else {\n      this.stateProvider = stateProvider;\n    }\n    this.clientIsInternal = httpClient == null;\n    this.shutdownLBHttpSolrServer = lbSolrClient == null;\n    if(lbHttpSolrClientBuilder != null) lbSolrClient = lbHttpSolrClientBuilder.build();\n    if(lbSolrClient != null) httpClient = lbSolrClient.getHttpClient();\n    this.myClient = httpClient == null ? HttpClientUtil.createClient(null) : httpClient;\n    if (lbSolrClient == null) lbSolrClient = createLBHttpSolrClient(myClient);\n    this.lbClient = lbSolrClient;\n    this.updatesToLeaders = updatesToLeaders;\n    this.directUpdatesToLeadersOnly = directUpdatesToLeadersOnly;\n  }\n\n","bugFix":null,"bugIntro":["a94f5348e08612b1408bdaa533c56d77db63605e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":4,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#CloudSolrClient(Collection[String],String,HttpClient,LBHttpSolrClient,LBHttpSolrClient.Builder,boolean,boolean,ClusterStateProvider).mjava","sourceNew":null,"sourceOld":"  /**\n   * Create a new client object that connects to Zookeeper and is always aware\n   * of the SolrCloud state. If there is a fully redundant Zookeeper quorum and\n   * SolrCloud has enough replicas for every shard in a collection, there is no\n   * single point of failure. Updates will be sent to shard leaders by default.\n   *\n   * @param zkHosts\n   *          A Java Collection (List, Set, etc) of HOST:PORT strings, one for\n   *          each host in the zookeeper ensemble. Note that with certain\n   *          Collection types like HashSet, the order of hosts in the final\n   *          connect string may not be in the same order you added them.\n   * @param chroot\n   *          A chroot value for zookeeper, starting with a forward slash. If no\n   *          chroot is required, use null.\n   * @param httpClient\n   *          the {@link HttpClient} instance to be used for all requests. The provided httpClient should use a\n   *          multi-threaded connection manager.  If null, a default HttpClient will be used.\n   * @param lbSolrClient\n   *          LBHttpSolrClient instance for requests.  If null, a default LBHttpSolrClient will be used.\n   * @param lbHttpSolrClientBuilder\n   *          LBHttpSolrClient builder to construct the LBHttpSolrClient. If null, a default builder will be used.\n   * @param updatesToLeaders\n   *          If true, sends updates to shard leaders.\n   * @param directUpdatesToLeadersOnly\n   *          If true, sends direct updates to shard leaders only.\n   */\n  private CloudSolrClient(Collection<String> zkHosts,\n                          String chroot,\n                          HttpClient httpClient,\n                          LBHttpSolrClient lbSolrClient,\n                          LBHttpSolrClient.Builder lbHttpSolrClientBuilder,\n                          boolean updatesToLeaders,\n                          boolean directUpdatesToLeadersOnly,\n                          ClusterStateProvider stateProvider\n\n  ) {\n    if (stateProvider == null) {\n      this.stateProvider = new ZkClientClusterStateProvider(zkHosts, chroot);\n    } else {\n      this.stateProvider = stateProvider;\n    }\n    this.clientIsInternal = httpClient == null;\n    this.shutdownLBHttpSolrServer = lbSolrClient == null;\n    if(lbHttpSolrClientBuilder != null) lbSolrClient = lbHttpSolrClientBuilder.build();\n    if(lbSolrClient != null) httpClient = lbSolrClient.getHttpClient();\n    this.myClient = httpClient == null ? HttpClientUtil.createClient(null) : httpClient;\n    if (lbSolrClient == null) lbSolrClient = createLBHttpSolrClient(myClient);\n    this.lbClient = lbSolrClient;\n    this.updatesToLeaders = updatesToLeaders;\n    this.directUpdatesToLeadersOnly = directUpdatesToLeadersOnly;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["3eaeb36333664e8cb92108ef03f68a7b90beb759"],"727bb765ff2542275f6d31f67be18d7104bae148":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3eaeb36333664e8cb92108ef03f68a7b90beb759"],"a64b273d51a6540272668680ece9f8b686ff0004":["3eaeb36333664e8cb92108ef03f68a7b90beb759"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3eaeb36333664e8cb92108ef03f68a7b90beb759":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a64b273d51a6540272668680ece9f8b686ff0004"]},"commit2Childs":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":[],"727bb765ff2542275f6d31f67be18d7104bae148":[],"a64b273d51a6540272668680ece9f8b686ff0004":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["727bb765ff2542275f6d31f67be18d7104bae148","3eaeb36333664e8cb92108ef03f68a7b90beb759"],"3eaeb36333664e8cb92108ef03f68a7b90beb759":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","727bb765ff2542275f6d31f67be18d7104bae148","a64b273d51a6540272668680ece9f8b686ff0004"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","727bb765ff2542275f6d31f67be18d7104bae148","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}