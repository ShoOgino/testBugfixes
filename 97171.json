{"path":"lucene/src/java/org/apache/lucene/util/automaton/UTF32ToUTF8#convert(Automaton).mjava","commits":[{"id":"5acb0ee59cc50caf85402e92d148fdb2af61bc19","date":1272929037,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/util/automaton/UTF32ToUTF8#convert(Automaton).mjava","pathOld":"/dev/null","sourceNew":"  /** Converts an incoming utf32 automaton to an equivalent\n   *  utf8 one.  The incoming automaton need not be\n   *  deterministic.  Note that the returned automaton will\n   *  not in general be deterministic, so you must\n   *  determinize it if that's needed. */\n  public Automaton convert(Automaton utf32) {\n    if (utf32.isSingleton()) {\n      utf32 = utf32.cloneExpanded();\n    }\n\n    State[] map = new State[utf32.getNumberedStates().length];\n    List<State> pending = new ArrayList<State>();\n    State utf32State = utf32.getInitialState();\n    pending.add(utf32State);\n    Automaton utf8 = new Automaton();\n    utf8.setDeterministic(false);\n\n    State utf8State = utf8.getInitialState();\n\n    utf8States = new State[5];\n    utf8StateCount = 0;\n    utf8State.number = utf8StateCount;\n    utf8States[utf8StateCount] = utf8State;\n    utf8StateCount++;\n\n    utf8State.setAccept(utf32State.isAccept());\n\n    map[utf32State.number] = utf8State;\n    \n    while(pending.size() != 0) {\n      utf32State = pending.remove(pending.size()-1);\n      utf8State = map[utf32State.number];\n      for(int i=0;i<utf32State.numTransitions;i++) {\n        final Transition t = utf32State.transitionsArray[i];\n        final State destUTF32 = t.to;\n        State destUTF8 = map[destUTF32.number];\n        if (destUTF8 == null) {\n          destUTF8 = newUTF8State();\n          destUTF8.accept = destUTF32.accept;\n          map[destUTF32.number] = destUTF8;\n          pending.add(destUTF32);\n        }\n        convertOneEdge(utf8State, destUTF8, t.min, t.max);\n      }\n    }\n\n    utf8.setNumberedStates(utf8States, utf8StateCount);\n\n    return utf8;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/UTF32ToUTF8#convert(Automaton).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/UTF32ToUTF8#convert(Automaton).mjava","sourceNew":"  /** Converts an incoming utf32 automaton to an equivalent\n   *  utf8 one.  The incoming automaton need not be\n   *  deterministic.  Note that the returned automaton will\n   *  not in general be deterministic, so you must\n   *  determinize it if that's needed. */\n  public Automaton convert(Automaton utf32) {\n    if (utf32.isSingleton()) {\n      utf32 = utf32.cloneExpanded();\n    }\n\n    State[] map = new State[utf32.getNumberedStates().length];\n    List<State> pending = new ArrayList<State>();\n    State utf32State = utf32.getInitialState();\n    pending.add(utf32State);\n    Automaton utf8 = new Automaton();\n    utf8.setDeterministic(false);\n\n    State utf8State = utf8.getInitialState();\n\n    utf8States = new State[5];\n    utf8StateCount = 0;\n    utf8State.number = utf8StateCount;\n    utf8States[utf8StateCount] = utf8State;\n    utf8StateCount++;\n\n    utf8State.setAccept(utf32State.isAccept());\n\n    map[utf32State.number] = utf8State;\n    \n    while(pending.size() != 0) {\n      utf32State = pending.remove(pending.size()-1);\n      utf8State = map[utf32State.number];\n      for(int i=0;i<utf32State.numTransitions;i++) {\n        final Transition t = utf32State.transitionsArray[i];\n        final State destUTF32 = t.to;\n        State destUTF8 = map[destUTF32.number];\n        if (destUTF8 == null) {\n          destUTF8 = newUTF8State();\n          destUTF8.accept = destUTF32.accept;\n          map[destUTF32.number] = destUTF8;\n          pending.add(destUTF32);\n        }\n        convertOneEdge(utf8State, destUTF8, t.min, t.max);\n      }\n    }\n\n    utf8.setNumberedStates(utf8States, utf8StateCount);\n\n    return utf8;\n  }\n\n","sourceOld":"  /** Converts an incoming utf32 automaton to an equivalent\n   *  utf8 one.  The incoming automaton need not be\n   *  deterministic.  Note that the returned automaton will\n   *  not in general be deterministic, so you must\n   *  determinize it if that's needed. */\n  public Automaton convert(Automaton utf32) {\n    if (utf32.isSingleton()) {\n      utf32 = utf32.cloneExpanded();\n    }\n\n    State[] map = new State[utf32.getNumberedStates().length];\n    List<State> pending = new ArrayList<State>();\n    State utf32State = utf32.getInitialState();\n    pending.add(utf32State);\n    Automaton utf8 = new Automaton();\n    utf8.setDeterministic(false);\n\n    State utf8State = utf8.getInitialState();\n\n    utf8States = new State[5];\n    utf8StateCount = 0;\n    utf8State.number = utf8StateCount;\n    utf8States[utf8StateCount] = utf8State;\n    utf8StateCount++;\n\n    utf8State.setAccept(utf32State.isAccept());\n\n    map[utf32State.number] = utf8State;\n    \n    while(pending.size() != 0) {\n      utf32State = pending.remove(pending.size()-1);\n      utf8State = map[utf32State.number];\n      for(int i=0;i<utf32State.numTransitions;i++) {\n        final Transition t = utf32State.transitionsArray[i];\n        final State destUTF32 = t.to;\n        State destUTF8 = map[destUTF32.number];\n        if (destUTF8 == null) {\n          destUTF8 = newUTF8State();\n          destUTF8.accept = destUTF32.accept;\n          map[destUTF32.number] = destUTF8;\n          pending.add(destUTF32);\n        }\n        convertOneEdge(utf8State, destUTF8, t.min, t.max);\n      }\n    }\n\n    utf8.setNumberedStates(utf8States, utf8StateCount);\n\n    return utf8;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["5acb0ee59cc50caf85402e92d148fdb2af61bc19"],"5acb0ee59cc50caf85402e92d148fdb2af61bc19":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5acb0ee59cc50caf85402e92d148fdb2af61bc19":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5acb0ee59cc50caf85402e92d148fdb2af61bc19"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}