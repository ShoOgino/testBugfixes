{"path":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testShardParamVariations().mjava","commits":[{"id":"e14913df9327ed5dfa00075dc1ff09137dbdb896","date":1366997648,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testShardParamVariations().mjava","pathOld":"/dev/null","sourceNew":"  private void testShardParamVariations() throws Exception {\n    SolrQuery query = new SolrQuery(\"*:*\");\n    Map<String,Long> shardCounts = new HashMap<String,Long>();\n\n    for (String shard : shardToJetty.keySet()) {\n      // every client should give the same numDocs for this shard\n      // shffle the clients in a diff order for each shard\n      List<SolrServer> solrclients = new ArrayList<SolrServer>(this.clients);\n      Collections.shuffle(solrclients, random());\n      for (SolrServer client : solrclients) {\n        query.set(\"shards\", shard);\n        long numDocs = client.query(query).getResults().getNumFound();\n        assertTrue(\"numDocs < 0 for shard \"+shard+\" via \"+client,\n                   0 <= numDocs);\n        if (!shardCounts.containsKey(shard)) {\n          shardCounts.put(shard, numDocs);\n        }\n        assertEquals(\"inconsitent numDocs for shard \"+shard+\" via \"+client,\n                     shardCounts.get(shard).longValue(), numDocs);\n        \n        List<CloudJettyRunner> replicaJetties \n          = new ArrayList<CloudJettyRunner>(shardToJetty.get(shard));\n        Collections.shuffle(replicaJetties, random());\n\n        // each replica should also give the same numDocs\n        ArrayList<String> replicaAlts = new ArrayList<String>(replicaJetties.size() * 2);\n        for (CloudJettyRunner replicaJetty : shardToJetty.get(shard)) {\n          String replica = removeProtocol(replicaJetty.url);\n          query.set(\"shards\", replica);\n\n          // replicas already shuffled, use this in the alternative check below\n          if (0 == random().nextInt(3) || replicaAlts.size() < 2) {\n            replicaAlts.add(replica);\n          }\n\n          numDocs = client.query(query).getResults().getNumFound();\n          assertTrue(\"numDocs < 0 for replica \"+replica+\" via \"+client,\n                     0 <= numDocs);\n          assertEquals(\"inconsitent numDocs for shard \"+shard+\n                       \" in replica \"+replica+\" via \"+client,\n                       shardCounts.get(shard).longValue(), numDocs);\n        }\n\n        // any combination of replica alternatives should give same numDocs\n        String replicas = StringUtils.join(replicaAlts.toArray(), \"|\");\n        query.set(\"shards\", replicas);\n        numDocs = client.query(query).getResults().getNumFound();\n        assertTrue(\"numDocs < 0 for replicas \"+replicas+\" via \"+client,\n                   0 <= numDocs);\n          assertEquals(\"inconsitent numDocs for replicas \"+replicas+\n                       \" via \"+client,\n                       shardCounts.get(shard).longValue(), numDocs);\n      }\n    }\n\n    // sums of multiple shards should add up regardless of how we \n    // query those shards or which client we use\n    long randomShardCountsExpected = 0;\n    ArrayList<String> randomShards = new ArrayList<String>(shardCounts.size());\n    for (Map.Entry<String,Long> shardData : shardCounts.entrySet()) {\n      if (random().nextBoolean() || randomShards.size() < 2) {\n        String shard = shardData.getKey();\n        randomShardCountsExpected += shardData.getValue();\n        if (random().nextBoolean()) {\n          // use shard id\n          randomShards.add(shard);\n        } else {\n          // use some set explicit replicas\n          ArrayList<String> replicas = new ArrayList<String>(7);\n          for (CloudJettyRunner replicaJetty : shardToJetty.get(shard)) {\n            if (0 == random().nextInt(3) || 0 == replicas.size()) {\n              replicas.add(removeProtocol(replicaJetty.url));\n            }\n          }\n          Collections.shuffle(replicas, random());\n          randomShards.add(StringUtils.join(replicas, \"|\"));\n        }\n      }\n    }\n    String randShards = StringUtils.join(randomShards, \",\");\n    query.set(\"shards\", randShards);\n    for (SolrServer client : this.clients) {\n      assertEquals(\"numDocs for \"+randShards+\" via \"+client,\n                   randomShardCountsExpected, \n                   client.query(query).getResults().getNumFound());\n    }\n\n    // total num docs must match sum of every shard's numDocs\n    query = new SolrQuery(\"*:*\");\n    long totalShardNumDocs = 0;\n    for (Long c : shardCounts.values()) {\n      totalShardNumDocs += c;\n    }\n    for (SolrServer client : clients) {\n      assertEquals(\"sum of shard numDocs on client: \" + client, \n                   totalShardNumDocs,\n                   client.query(query).getResults().getNumFound());\n    }\n    assertTrue(\"total numDocs <= 0, WTF? Test is useless\",\n               0 < totalShardNumDocs);\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"57641b2e9dc6155be493cfb6ae9b8a9c8ceffa72","date":1391985588,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testShardParamVariations().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testShardParamVariations().mjava","sourceNew":"  private void testShardParamVariations() throws Exception {\n    SolrQuery query = new SolrQuery(\"*:*\");\n    Map<String,Long> shardCounts = new HashMap<String,Long>();\n\n    for (String shard : shardToJetty.keySet()) {\n      // every client should give the same numDocs for this shard\n      // shffle the clients in a diff order for each shard\n      List<SolrServer> solrclients = new ArrayList<SolrServer>(this.clients);\n      Collections.shuffle(solrclients, random());\n      for (SolrServer client : solrclients) {\n        query.set(\"shards\", shard);\n        long numDocs = client.query(query).getResults().getNumFound();\n        assertTrue(\"numDocs < 0 for shard \"+shard+\" via \"+client,\n                   0 <= numDocs);\n        if (!shardCounts.containsKey(shard)) {\n          shardCounts.put(shard, numDocs);\n        }\n        assertEquals(\"inconsitent numDocs for shard \"+shard+\" via \"+client,\n                     shardCounts.get(shard).longValue(), numDocs);\n        \n        List<CloudJettyRunner> replicaJetties \n          = new ArrayList<CloudJettyRunner>(shardToJetty.get(shard));\n        Collections.shuffle(replicaJetties, random());\n\n        // each replica should also give the same numDocs\n        ArrayList<String> replicaAlts = new ArrayList<String>(replicaJetties.size() * 2);\n        for (CloudJettyRunner replicaJetty : shardToJetty.get(shard)) {\n          String replica = replicaJetty.url;\n          query.set(\"shards\", replica);\n\n          // replicas already shuffled, use this in the alternative check below\n          if (0 == random().nextInt(3) || replicaAlts.size() < 2) {\n            replicaAlts.add(replica);\n          }\n\n          numDocs = client.query(query).getResults().getNumFound();\n          assertTrue(\"numDocs < 0 for replica \"+replica+\" via \"+client,\n                     0 <= numDocs);\n          assertEquals(\"inconsitent numDocs for shard \"+shard+\n                       \" in replica \"+replica+\" via \"+client,\n                       shardCounts.get(shard).longValue(), numDocs);\n        }\n\n        // any combination of replica alternatives should give same numDocs\n        String replicas = StringUtils.join(replicaAlts.toArray(), \"|\");\n        query.set(\"shards\", replicas);\n        numDocs = client.query(query).getResults().getNumFound();\n        assertTrue(\"numDocs < 0 for replicas \"+replicas+\" via \"+client,\n                   0 <= numDocs);\n          assertEquals(\"inconsitent numDocs for replicas \"+replicas+\n                       \" via \"+client,\n                       shardCounts.get(shard).longValue(), numDocs);\n      }\n    }\n\n    // sums of multiple shards should add up regardless of how we \n    // query those shards or which client we use\n    long randomShardCountsExpected = 0;\n    ArrayList<String> randomShards = new ArrayList<String>(shardCounts.size());\n    for (Map.Entry<String,Long> shardData : shardCounts.entrySet()) {\n      if (random().nextBoolean() || randomShards.size() < 2) {\n        String shard = shardData.getKey();\n        randomShardCountsExpected += shardData.getValue();\n        if (random().nextBoolean()) {\n          // use shard id\n          randomShards.add(shard);\n        } else {\n          // use some set explicit replicas\n          ArrayList<String> replicas = new ArrayList<String>(7);\n          for (CloudJettyRunner replicaJetty : shardToJetty.get(shard)) {\n            if (0 == random().nextInt(3) || 0 == replicas.size()) {\n              replicas.add(replicaJetty.url);\n            }\n          }\n          Collections.shuffle(replicas, random());\n          randomShards.add(StringUtils.join(replicas, \"|\"));\n        }\n      }\n    }\n    String randShards = StringUtils.join(randomShards, \",\");\n    query.set(\"shards\", randShards);\n    for (SolrServer client : this.clients) {\n      assertEquals(\"numDocs for \"+randShards+\" via \"+client,\n                   randomShardCountsExpected, \n                   client.query(query).getResults().getNumFound());\n    }\n\n    // total num docs must match sum of every shard's numDocs\n    query = new SolrQuery(\"*:*\");\n    long totalShardNumDocs = 0;\n    for (Long c : shardCounts.values()) {\n      totalShardNumDocs += c;\n    }\n    for (SolrServer client : clients) {\n      assertEquals(\"sum of shard numDocs on client: \" + client, \n                   totalShardNumDocs,\n                   client.query(query).getResults().getNumFound());\n    }\n    assertTrue(\"total numDocs <= 0, WTF? Test is useless\",\n               0 < totalShardNumDocs);\n\n  }\n\n","sourceOld":"  private void testShardParamVariations() throws Exception {\n    SolrQuery query = new SolrQuery(\"*:*\");\n    Map<String,Long> shardCounts = new HashMap<String,Long>();\n\n    for (String shard : shardToJetty.keySet()) {\n      // every client should give the same numDocs for this shard\n      // shffle the clients in a diff order for each shard\n      List<SolrServer> solrclients = new ArrayList<SolrServer>(this.clients);\n      Collections.shuffle(solrclients, random());\n      for (SolrServer client : solrclients) {\n        query.set(\"shards\", shard);\n        long numDocs = client.query(query).getResults().getNumFound();\n        assertTrue(\"numDocs < 0 for shard \"+shard+\" via \"+client,\n                   0 <= numDocs);\n        if (!shardCounts.containsKey(shard)) {\n          shardCounts.put(shard, numDocs);\n        }\n        assertEquals(\"inconsitent numDocs for shard \"+shard+\" via \"+client,\n                     shardCounts.get(shard).longValue(), numDocs);\n        \n        List<CloudJettyRunner> replicaJetties \n          = new ArrayList<CloudJettyRunner>(shardToJetty.get(shard));\n        Collections.shuffle(replicaJetties, random());\n\n        // each replica should also give the same numDocs\n        ArrayList<String> replicaAlts = new ArrayList<String>(replicaJetties.size() * 2);\n        for (CloudJettyRunner replicaJetty : shardToJetty.get(shard)) {\n          String replica = removeProtocol(replicaJetty.url);\n          query.set(\"shards\", replica);\n\n          // replicas already shuffled, use this in the alternative check below\n          if (0 == random().nextInt(3) || replicaAlts.size() < 2) {\n            replicaAlts.add(replica);\n          }\n\n          numDocs = client.query(query).getResults().getNumFound();\n          assertTrue(\"numDocs < 0 for replica \"+replica+\" via \"+client,\n                     0 <= numDocs);\n          assertEquals(\"inconsitent numDocs for shard \"+shard+\n                       \" in replica \"+replica+\" via \"+client,\n                       shardCounts.get(shard).longValue(), numDocs);\n        }\n\n        // any combination of replica alternatives should give same numDocs\n        String replicas = StringUtils.join(replicaAlts.toArray(), \"|\");\n        query.set(\"shards\", replicas);\n        numDocs = client.query(query).getResults().getNumFound();\n        assertTrue(\"numDocs < 0 for replicas \"+replicas+\" via \"+client,\n                   0 <= numDocs);\n          assertEquals(\"inconsitent numDocs for replicas \"+replicas+\n                       \" via \"+client,\n                       shardCounts.get(shard).longValue(), numDocs);\n      }\n    }\n\n    // sums of multiple shards should add up regardless of how we \n    // query those shards or which client we use\n    long randomShardCountsExpected = 0;\n    ArrayList<String> randomShards = new ArrayList<String>(shardCounts.size());\n    for (Map.Entry<String,Long> shardData : shardCounts.entrySet()) {\n      if (random().nextBoolean() || randomShards.size() < 2) {\n        String shard = shardData.getKey();\n        randomShardCountsExpected += shardData.getValue();\n        if (random().nextBoolean()) {\n          // use shard id\n          randomShards.add(shard);\n        } else {\n          // use some set explicit replicas\n          ArrayList<String> replicas = new ArrayList<String>(7);\n          for (CloudJettyRunner replicaJetty : shardToJetty.get(shard)) {\n            if (0 == random().nextInt(3) || 0 == replicas.size()) {\n              replicas.add(removeProtocol(replicaJetty.url));\n            }\n          }\n          Collections.shuffle(replicas, random());\n          randomShards.add(StringUtils.join(replicas, \"|\"));\n        }\n      }\n    }\n    String randShards = StringUtils.join(randomShards, \",\");\n    query.set(\"shards\", randShards);\n    for (SolrServer client : this.clients) {\n      assertEquals(\"numDocs for \"+randShards+\" via \"+client,\n                   randomShardCountsExpected, \n                   client.query(query).getResults().getNumFound());\n    }\n\n    // total num docs must match sum of every shard's numDocs\n    query = new SolrQuery(\"*:*\");\n    long totalShardNumDocs = 0;\n    for (Long c : shardCounts.values()) {\n      totalShardNumDocs += c;\n    }\n    for (SolrServer client : clients) {\n      assertEquals(\"sum of shard numDocs on client: \" + client, \n                   totalShardNumDocs,\n                   client.query(query).getResults().getNumFound());\n    }\n    assertTrue(\"total numDocs <= 0, WTF? Test is useless\",\n               0 < totalShardNumDocs);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testShardParamVariations().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testShardParamVariations().mjava","sourceNew":"  private void testShardParamVariations() throws Exception {\n    SolrQuery query = new SolrQuery(\"*:*\");\n    Map<String,Long> shardCounts = new HashMap<>();\n\n    for (String shard : shardToJetty.keySet()) {\n      // every client should give the same numDocs for this shard\n      // shffle the clients in a diff order for each shard\n      List<SolrServer> solrclients = new ArrayList<>(this.clients);\n      Collections.shuffle(solrclients, random());\n      for (SolrServer client : solrclients) {\n        query.set(\"shards\", shard);\n        long numDocs = client.query(query).getResults().getNumFound();\n        assertTrue(\"numDocs < 0 for shard \"+shard+\" via \"+client,\n                   0 <= numDocs);\n        if (!shardCounts.containsKey(shard)) {\n          shardCounts.put(shard, numDocs);\n        }\n        assertEquals(\"inconsitent numDocs for shard \"+shard+\" via \"+client,\n                     shardCounts.get(shard).longValue(), numDocs);\n        \n        List<CloudJettyRunner> replicaJetties \n          = new ArrayList<>(shardToJetty.get(shard));\n        Collections.shuffle(replicaJetties, random());\n\n        // each replica should also give the same numDocs\n        ArrayList<String> replicaAlts = new ArrayList<>(replicaJetties.size() * 2);\n        for (CloudJettyRunner replicaJetty : shardToJetty.get(shard)) {\n          String replica = replicaJetty.url;\n          query.set(\"shards\", replica);\n\n          // replicas already shuffled, use this in the alternative check below\n          if (0 == random().nextInt(3) || replicaAlts.size() < 2) {\n            replicaAlts.add(replica);\n          }\n\n          numDocs = client.query(query).getResults().getNumFound();\n          assertTrue(\"numDocs < 0 for replica \"+replica+\" via \"+client,\n                     0 <= numDocs);\n          assertEquals(\"inconsitent numDocs for shard \"+shard+\n                       \" in replica \"+replica+\" via \"+client,\n                       shardCounts.get(shard).longValue(), numDocs);\n        }\n\n        // any combination of replica alternatives should give same numDocs\n        String replicas = StringUtils.join(replicaAlts.toArray(), \"|\");\n        query.set(\"shards\", replicas);\n        numDocs = client.query(query).getResults().getNumFound();\n        assertTrue(\"numDocs < 0 for replicas \"+replicas+\" via \"+client,\n                   0 <= numDocs);\n          assertEquals(\"inconsitent numDocs for replicas \"+replicas+\n                       \" via \"+client,\n                       shardCounts.get(shard).longValue(), numDocs);\n      }\n    }\n\n    // sums of multiple shards should add up regardless of how we \n    // query those shards or which client we use\n    long randomShardCountsExpected = 0;\n    ArrayList<String> randomShards = new ArrayList<>(shardCounts.size());\n    for (Map.Entry<String,Long> shardData : shardCounts.entrySet()) {\n      if (random().nextBoolean() || randomShards.size() < 2) {\n        String shard = shardData.getKey();\n        randomShardCountsExpected += shardData.getValue();\n        if (random().nextBoolean()) {\n          // use shard id\n          randomShards.add(shard);\n        } else {\n          // use some set explicit replicas\n          ArrayList<String> replicas = new ArrayList<>(7);\n          for (CloudJettyRunner replicaJetty : shardToJetty.get(shard)) {\n            if (0 == random().nextInt(3) || 0 == replicas.size()) {\n              replicas.add(replicaJetty.url);\n            }\n          }\n          Collections.shuffle(replicas, random());\n          randomShards.add(StringUtils.join(replicas, \"|\"));\n        }\n      }\n    }\n    String randShards = StringUtils.join(randomShards, \",\");\n    query.set(\"shards\", randShards);\n    for (SolrServer client : this.clients) {\n      assertEquals(\"numDocs for \"+randShards+\" via \"+client,\n                   randomShardCountsExpected, \n                   client.query(query).getResults().getNumFound());\n    }\n\n    // total num docs must match sum of every shard's numDocs\n    query = new SolrQuery(\"*:*\");\n    long totalShardNumDocs = 0;\n    for (Long c : shardCounts.values()) {\n      totalShardNumDocs += c;\n    }\n    for (SolrServer client : clients) {\n      assertEquals(\"sum of shard numDocs on client: \" + client, \n                   totalShardNumDocs,\n                   client.query(query).getResults().getNumFound());\n    }\n    assertTrue(\"total numDocs <= 0, WTF? Test is useless\",\n               0 < totalShardNumDocs);\n\n  }\n\n","sourceOld":"  private void testShardParamVariations() throws Exception {\n    SolrQuery query = new SolrQuery(\"*:*\");\n    Map<String,Long> shardCounts = new HashMap<String,Long>();\n\n    for (String shard : shardToJetty.keySet()) {\n      // every client should give the same numDocs for this shard\n      // shffle the clients in a diff order for each shard\n      List<SolrServer> solrclients = new ArrayList<SolrServer>(this.clients);\n      Collections.shuffle(solrclients, random());\n      for (SolrServer client : solrclients) {\n        query.set(\"shards\", shard);\n        long numDocs = client.query(query).getResults().getNumFound();\n        assertTrue(\"numDocs < 0 for shard \"+shard+\" via \"+client,\n                   0 <= numDocs);\n        if (!shardCounts.containsKey(shard)) {\n          shardCounts.put(shard, numDocs);\n        }\n        assertEquals(\"inconsitent numDocs for shard \"+shard+\" via \"+client,\n                     shardCounts.get(shard).longValue(), numDocs);\n        \n        List<CloudJettyRunner> replicaJetties \n          = new ArrayList<CloudJettyRunner>(shardToJetty.get(shard));\n        Collections.shuffle(replicaJetties, random());\n\n        // each replica should also give the same numDocs\n        ArrayList<String> replicaAlts = new ArrayList<String>(replicaJetties.size() * 2);\n        for (CloudJettyRunner replicaJetty : shardToJetty.get(shard)) {\n          String replica = replicaJetty.url;\n          query.set(\"shards\", replica);\n\n          // replicas already shuffled, use this in the alternative check below\n          if (0 == random().nextInt(3) || replicaAlts.size() < 2) {\n            replicaAlts.add(replica);\n          }\n\n          numDocs = client.query(query).getResults().getNumFound();\n          assertTrue(\"numDocs < 0 for replica \"+replica+\" via \"+client,\n                     0 <= numDocs);\n          assertEquals(\"inconsitent numDocs for shard \"+shard+\n                       \" in replica \"+replica+\" via \"+client,\n                       shardCounts.get(shard).longValue(), numDocs);\n        }\n\n        // any combination of replica alternatives should give same numDocs\n        String replicas = StringUtils.join(replicaAlts.toArray(), \"|\");\n        query.set(\"shards\", replicas);\n        numDocs = client.query(query).getResults().getNumFound();\n        assertTrue(\"numDocs < 0 for replicas \"+replicas+\" via \"+client,\n                   0 <= numDocs);\n          assertEquals(\"inconsitent numDocs for replicas \"+replicas+\n                       \" via \"+client,\n                       shardCounts.get(shard).longValue(), numDocs);\n      }\n    }\n\n    // sums of multiple shards should add up regardless of how we \n    // query those shards or which client we use\n    long randomShardCountsExpected = 0;\n    ArrayList<String> randomShards = new ArrayList<String>(shardCounts.size());\n    for (Map.Entry<String,Long> shardData : shardCounts.entrySet()) {\n      if (random().nextBoolean() || randomShards.size() < 2) {\n        String shard = shardData.getKey();\n        randomShardCountsExpected += shardData.getValue();\n        if (random().nextBoolean()) {\n          // use shard id\n          randomShards.add(shard);\n        } else {\n          // use some set explicit replicas\n          ArrayList<String> replicas = new ArrayList<String>(7);\n          for (CloudJettyRunner replicaJetty : shardToJetty.get(shard)) {\n            if (0 == random().nextInt(3) || 0 == replicas.size()) {\n              replicas.add(replicaJetty.url);\n            }\n          }\n          Collections.shuffle(replicas, random());\n          randomShards.add(StringUtils.join(replicas, \"|\"));\n        }\n      }\n    }\n    String randShards = StringUtils.join(randomShards, \",\");\n    query.set(\"shards\", randShards);\n    for (SolrServer client : this.clients) {\n      assertEquals(\"numDocs for \"+randShards+\" via \"+client,\n                   randomShardCountsExpected, \n                   client.query(query).getResults().getNumFound());\n    }\n\n    // total num docs must match sum of every shard's numDocs\n    query = new SolrQuery(\"*:*\");\n    long totalShardNumDocs = 0;\n    for (Long c : shardCounts.values()) {\n      totalShardNumDocs += c;\n    }\n    for (SolrServer client : clients) {\n      assertEquals(\"sum of shard numDocs on client: \" + client, \n                   totalShardNumDocs,\n                   client.query(query).getResults().getNumFound());\n    }\n    assertTrue(\"total numDocs <= 0, WTF? Test is useless\",\n               0 < totalShardNumDocs);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bafca15d8e408346a67f4282ad1143b88023893b","date":1420034748,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testShardParamVariations().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testShardParamVariations().mjava","sourceNew":"  private void testShardParamVariations() throws Exception {\n    SolrQuery query = new SolrQuery(\"*:*\");\n    Map<String,Long> shardCounts = new HashMap<>();\n\n    for (String shard : shardToJetty.keySet()) {\n      // every client should give the same numDocs for this shard\n      // shffle the clients in a diff order for each shard\n      List<SolrClient> solrclients = new ArrayList<>(this.clients);\n      Collections.shuffle(solrclients, random());\n      for (SolrClient client : solrclients) {\n        query.set(\"shards\", shard);\n        long numDocs = client.query(query).getResults().getNumFound();\n        assertTrue(\"numDocs < 0 for shard \"+shard+\" via \"+client,\n                   0 <= numDocs);\n        if (!shardCounts.containsKey(shard)) {\n          shardCounts.put(shard, numDocs);\n        }\n        assertEquals(\"inconsitent numDocs for shard \"+shard+\" via \"+client,\n                     shardCounts.get(shard).longValue(), numDocs);\n        \n        List<CloudJettyRunner> replicaJetties \n          = new ArrayList<>(shardToJetty.get(shard));\n        Collections.shuffle(replicaJetties, random());\n\n        // each replica should also give the same numDocs\n        ArrayList<String> replicaAlts = new ArrayList<>(replicaJetties.size() * 2);\n        for (CloudJettyRunner replicaJetty : shardToJetty.get(shard)) {\n          String replica = replicaJetty.url;\n          query.set(\"shards\", replica);\n\n          // replicas already shuffled, use this in the alternative check below\n          if (0 == random().nextInt(3) || replicaAlts.size() < 2) {\n            replicaAlts.add(replica);\n          }\n\n          numDocs = client.query(query).getResults().getNumFound();\n          assertTrue(\"numDocs < 0 for replica \"+replica+\" via \"+client,\n                     0 <= numDocs);\n          assertEquals(\"inconsitent numDocs for shard \"+shard+\n                       \" in replica \"+replica+\" via \"+client,\n                       shardCounts.get(shard).longValue(), numDocs);\n        }\n\n        // any combination of replica alternatives should give same numDocs\n        String replicas = StringUtils.join(replicaAlts.toArray(), \"|\");\n        query.set(\"shards\", replicas);\n        numDocs = client.query(query).getResults().getNumFound();\n        assertTrue(\"numDocs < 0 for replicas \"+replicas+\" via \"+client,\n                   0 <= numDocs);\n          assertEquals(\"inconsitent numDocs for replicas \"+replicas+\n                       \" via \"+client,\n                       shardCounts.get(shard).longValue(), numDocs);\n      }\n    }\n\n    // sums of multiple shards should add up regardless of how we \n    // query those shards or which client we use\n    long randomShardCountsExpected = 0;\n    ArrayList<String> randomShards = new ArrayList<>(shardCounts.size());\n    for (Map.Entry<String,Long> shardData : shardCounts.entrySet()) {\n      if (random().nextBoolean() || randomShards.size() < 2) {\n        String shard = shardData.getKey();\n        randomShardCountsExpected += shardData.getValue();\n        if (random().nextBoolean()) {\n          // use shard id\n          randomShards.add(shard);\n        } else {\n          // use some set explicit replicas\n          ArrayList<String> replicas = new ArrayList<>(7);\n          for (CloudJettyRunner replicaJetty : shardToJetty.get(shard)) {\n            if (0 == random().nextInt(3) || 0 == replicas.size()) {\n              replicas.add(replicaJetty.url);\n            }\n          }\n          Collections.shuffle(replicas, random());\n          randomShards.add(StringUtils.join(replicas, \"|\"));\n        }\n      }\n    }\n    String randShards = StringUtils.join(randomShards, \",\");\n    query.set(\"shards\", randShards);\n    for (SolrClient client : this.clients) {\n      assertEquals(\"numDocs for \"+randShards+\" via \"+client,\n                   randomShardCountsExpected, \n                   client.query(query).getResults().getNumFound());\n    }\n\n    // total num docs must match sum of every shard's numDocs\n    query = new SolrQuery(\"*:*\");\n    long totalShardNumDocs = 0;\n    for (Long c : shardCounts.values()) {\n      totalShardNumDocs += c;\n    }\n    for (SolrClient client : clients) {\n      assertEquals(\"sum of shard numDocs on client: \" + client, \n                   totalShardNumDocs,\n                   client.query(query).getResults().getNumFound());\n    }\n    assertTrue(\"total numDocs <= 0, WTF? Test is useless\",\n               0 < totalShardNumDocs);\n\n  }\n\n","sourceOld":"  private void testShardParamVariations() throws Exception {\n    SolrQuery query = new SolrQuery(\"*:*\");\n    Map<String,Long> shardCounts = new HashMap<>();\n\n    for (String shard : shardToJetty.keySet()) {\n      // every client should give the same numDocs for this shard\n      // shffle the clients in a diff order for each shard\n      List<SolrServer> solrclients = new ArrayList<>(this.clients);\n      Collections.shuffle(solrclients, random());\n      for (SolrServer client : solrclients) {\n        query.set(\"shards\", shard);\n        long numDocs = client.query(query).getResults().getNumFound();\n        assertTrue(\"numDocs < 0 for shard \"+shard+\" via \"+client,\n                   0 <= numDocs);\n        if (!shardCounts.containsKey(shard)) {\n          shardCounts.put(shard, numDocs);\n        }\n        assertEquals(\"inconsitent numDocs for shard \"+shard+\" via \"+client,\n                     shardCounts.get(shard).longValue(), numDocs);\n        \n        List<CloudJettyRunner> replicaJetties \n          = new ArrayList<>(shardToJetty.get(shard));\n        Collections.shuffle(replicaJetties, random());\n\n        // each replica should also give the same numDocs\n        ArrayList<String> replicaAlts = new ArrayList<>(replicaJetties.size() * 2);\n        for (CloudJettyRunner replicaJetty : shardToJetty.get(shard)) {\n          String replica = replicaJetty.url;\n          query.set(\"shards\", replica);\n\n          // replicas already shuffled, use this in the alternative check below\n          if (0 == random().nextInt(3) || replicaAlts.size() < 2) {\n            replicaAlts.add(replica);\n          }\n\n          numDocs = client.query(query).getResults().getNumFound();\n          assertTrue(\"numDocs < 0 for replica \"+replica+\" via \"+client,\n                     0 <= numDocs);\n          assertEquals(\"inconsitent numDocs for shard \"+shard+\n                       \" in replica \"+replica+\" via \"+client,\n                       shardCounts.get(shard).longValue(), numDocs);\n        }\n\n        // any combination of replica alternatives should give same numDocs\n        String replicas = StringUtils.join(replicaAlts.toArray(), \"|\");\n        query.set(\"shards\", replicas);\n        numDocs = client.query(query).getResults().getNumFound();\n        assertTrue(\"numDocs < 0 for replicas \"+replicas+\" via \"+client,\n                   0 <= numDocs);\n          assertEquals(\"inconsitent numDocs for replicas \"+replicas+\n                       \" via \"+client,\n                       shardCounts.get(shard).longValue(), numDocs);\n      }\n    }\n\n    // sums of multiple shards should add up regardless of how we \n    // query those shards or which client we use\n    long randomShardCountsExpected = 0;\n    ArrayList<String> randomShards = new ArrayList<>(shardCounts.size());\n    for (Map.Entry<String,Long> shardData : shardCounts.entrySet()) {\n      if (random().nextBoolean() || randomShards.size() < 2) {\n        String shard = shardData.getKey();\n        randomShardCountsExpected += shardData.getValue();\n        if (random().nextBoolean()) {\n          // use shard id\n          randomShards.add(shard);\n        } else {\n          // use some set explicit replicas\n          ArrayList<String> replicas = new ArrayList<>(7);\n          for (CloudJettyRunner replicaJetty : shardToJetty.get(shard)) {\n            if (0 == random().nextInt(3) || 0 == replicas.size()) {\n              replicas.add(replicaJetty.url);\n            }\n          }\n          Collections.shuffle(replicas, random());\n          randomShards.add(StringUtils.join(replicas, \"|\"));\n        }\n      }\n    }\n    String randShards = StringUtils.join(randomShards, \",\");\n    query.set(\"shards\", randShards);\n    for (SolrServer client : this.clients) {\n      assertEquals(\"numDocs for \"+randShards+\" via \"+client,\n                   randomShardCountsExpected, \n                   client.query(query).getResults().getNumFound());\n    }\n\n    // total num docs must match sum of every shard's numDocs\n    query = new SolrQuery(\"*:*\");\n    long totalShardNumDocs = 0;\n    for (Long c : shardCounts.values()) {\n      totalShardNumDocs += c;\n    }\n    for (SolrServer client : clients) {\n      assertEquals(\"sum of shard numDocs on client: \" + client, \n                   totalShardNumDocs,\n                   client.query(query).getResults().getNumFound());\n    }\n    assertTrue(\"total numDocs <= 0, WTF? Test is useless\",\n               0 < totalShardNumDocs);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cb5af3afeddbb803fb785098176e6e177c34261b","date":1428905393,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testShardParamVariations().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testShardParamVariations().mjava","sourceNew":"  private void testShardParamVariations() throws Exception {\n    SolrQuery query = new SolrQuery(\"*:*\");\n    Map<String,Long> shardCounts = new HashMap<>();\n\n    for (String shard : shardToJetty.keySet()) {\n      // every client should give the same numDocs for this shard\n      // shffle the clients in a diff order for each shard\n      List<SolrClient> solrclients = new ArrayList<>(this.clients);\n      Collections.shuffle(solrclients, random());\n      for (SolrClient client : solrclients) {\n        query.set(\"shards\", shard);\n        long numDocs = client.query(query).getResults().getNumFound();\n        assertTrue(\"numDocs < 0 for shard \"+shard+\" via \"+client,\n                   0 <= numDocs);\n        if (!shardCounts.containsKey(shard)) {\n          shardCounts.put(shard, numDocs);\n        }\n        assertEquals(\"inconsitent numDocs for shard \"+shard+\" via \"+client,\n                     shardCounts.get(shard).longValue(), numDocs);\n        \n        List<CloudJettyRunner> replicaJetties \n          = new ArrayList<>(shardToJetty.get(shard));\n        Collections.shuffle(replicaJetties, random());\n\n        // each replica should also give the same numDocs\n        ArrayList<String> replicaAlts = new ArrayList<>(replicaJetties.size() * 2);\n        for (CloudJettyRunner replicaJetty : shardToJetty.get(shard)) {\n          String replica = replicaJetty.url;\n          query.set(\"shards\", replica);\n\n          // replicas already shuffled, use this in the alternative check below\n          if (0 == random().nextInt(3) || replicaAlts.size() < 2) {\n            replicaAlts.add(replica);\n          }\n\n          numDocs = client.query(query).getResults().getNumFound();\n          assertTrue(\"numDocs < 0 for replica \"+replica+\" via \"+client,\n                     0 <= numDocs);\n          assertEquals(\"inconsitent numDocs for shard \"+shard+\n                       \" in replica \"+replica+\" via \"+client,\n                       shardCounts.get(shard).longValue(), numDocs);\n        }\n\n        // any combination of replica alternatives should give same numDocs\n        String replicas = StringUtils.join(replicaAlts.toArray(), \"|\");\n        query.set(\"shards\", replicas);\n        numDocs = client.query(query).getResults().getNumFound();\n        assertTrue(\"numDocs < 0 for replicas \"+replicas+\" via \"+client,\n                   0 <= numDocs);\n          assertEquals(\"inconsitent numDocs for replicas \"+replicas+\n                       \" via \"+client,\n                       shardCounts.get(shard).longValue(), numDocs);\n      }\n    }\n\n    // sums of multiple shards should add up regardless of how we \n    // query those shards or which client we use\n    long randomShardCountsExpected = 0;\n    ArrayList<String> randomShards = new ArrayList<>(shardCounts.size());\n    for (Map.Entry<String,Long> shardData : shardCounts.entrySet()) {\n      if (random().nextBoolean() || randomShards.size() < 2) {\n        String shard = shardData.getKey();\n        randomShardCountsExpected += shardData.getValue();\n        if (random().nextBoolean()) {\n          // use shard id\n          randomShards.add(shard);\n        } else {\n          // use some set explicit replicas\n          ArrayList<String> replicas = new ArrayList<>(7);\n          for (CloudJettyRunner replicaJetty : shardToJetty.get(shard)) {\n            if (0 == random().nextInt(3) || 0 == replicas.size()) {\n              replicas.add(replicaJetty.url);\n            }\n          }\n          Collections.shuffle(replicas, random());\n          randomShards.add(StringUtils.join(replicas, \"|\"));\n        }\n      }\n    }\n    String randShards = StringUtils.join(randomShards, \",\");\n    query.set(\"shards\", randShards);\n    for (SolrClient client : this.clients) {\n      assertEquals(\"numDocs for \"+randShards+\" via \"+client,\n                   randomShardCountsExpected, \n                   client.query(query).getResults().getNumFound());\n    }\n\n    // total num docs must match sum of every shard's numDocs\n    query = new SolrQuery(\"*:*\");\n    long totalShardNumDocs = 0;\n    for (Long c : shardCounts.values()) {\n      totalShardNumDocs += c;\n    }\n    for (SolrClient client : clients) {\n      assertEquals(\"sum of shard numDocs on client: \" + client, \n                   totalShardNumDocs,\n                   client.query(query).getResults().getNumFound());\n    }\n    assertTrue(\"total numDocs <= 0, WTF? Test is useless\",\n        0 < totalShardNumDocs);\n\n  }\n\n","sourceOld":"  private void testShardParamVariations() throws Exception {\n    SolrQuery query = new SolrQuery(\"*:*\");\n    Map<String,Long> shardCounts = new HashMap<>();\n\n    for (String shard : shardToJetty.keySet()) {\n      // every client should give the same numDocs for this shard\n      // shffle the clients in a diff order for each shard\n      List<SolrClient> solrclients = new ArrayList<>(this.clients);\n      Collections.shuffle(solrclients, random());\n      for (SolrClient client : solrclients) {\n        query.set(\"shards\", shard);\n        long numDocs = client.query(query).getResults().getNumFound();\n        assertTrue(\"numDocs < 0 for shard \"+shard+\" via \"+client,\n                   0 <= numDocs);\n        if (!shardCounts.containsKey(shard)) {\n          shardCounts.put(shard, numDocs);\n        }\n        assertEquals(\"inconsitent numDocs for shard \"+shard+\" via \"+client,\n                     shardCounts.get(shard).longValue(), numDocs);\n        \n        List<CloudJettyRunner> replicaJetties \n          = new ArrayList<>(shardToJetty.get(shard));\n        Collections.shuffle(replicaJetties, random());\n\n        // each replica should also give the same numDocs\n        ArrayList<String> replicaAlts = new ArrayList<>(replicaJetties.size() * 2);\n        for (CloudJettyRunner replicaJetty : shardToJetty.get(shard)) {\n          String replica = replicaJetty.url;\n          query.set(\"shards\", replica);\n\n          // replicas already shuffled, use this in the alternative check below\n          if (0 == random().nextInt(3) || replicaAlts.size() < 2) {\n            replicaAlts.add(replica);\n          }\n\n          numDocs = client.query(query).getResults().getNumFound();\n          assertTrue(\"numDocs < 0 for replica \"+replica+\" via \"+client,\n                     0 <= numDocs);\n          assertEquals(\"inconsitent numDocs for shard \"+shard+\n                       \" in replica \"+replica+\" via \"+client,\n                       shardCounts.get(shard).longValue(), numDocs);\n        }\n\n        // any combination of replica alternatives should give same numDocs\n        String replicas = StringUtils.join(replicaAlts.toArray(), \"|\");\n        query.set(\"shards\", replicas);\n        numDocs = client.query(query).getResults().getNumFound();\n        assertTrue(\"numDocs < 0 for replicas \"+replicas+\" via \"+client,\n                   0 <= numDocs);\n          assertEquals(\"inconsitent numDocs for replicas \"+replicas+\n                       \" via \"+client,\n                       shardCounts.get(shard).longValue(), numDocs);\n      }\n    }\n\n    // sums of multiple shards should add up regardless of how we \n    // query those shards or which client we use\n    long randomShardCountsExpected = 0;\n    ArrayList<String> randomShards = new ArrayList<>(shardCounts.size());\n    for (Map.Entry<String,Long> shardData : shardCounts.entrySet()) {\n      if (random().nextBoolean() || randomShards.size() < 2) {\n        String shard = shardData.getKey();\n        randomShardCountsExpected += shardData.getValue();\n        if (random().nextBoolean()) {\n          // use shard id\n          randomShards.add(shard);\n        } else {\n          // use some set explicit replicas\n          ArrayList<String> replicas = new ArrayList<>(7);\n          for (CloudJettyRunner replicaJetty : shardToJetty.get(shard)) {\n            if (0 == random().nextInt(3) || 0 == replicas.size()) {\n              replicas.add(replicaJetty.url);\n            }\n          }\n          Collections.shuffle(replicas, random());\n          randomShards.add(StringUtils.join(replicas, \"|\"));\n        }\n      }\n    }\n    String randShards = StringUtils.join(randomShards, \",\");\n    query.set(\"shards\", randShards);\n    for (SolrClient client : this.clients) {\n      assertEquals(\"numDocs for \"+randShards+\" via \"+client,\n                   randomShardCountsExpected, \n                   client.query(query).getResults().getNumFound());\n    }\n\n    // total num docs must match sum of every shard's numDocs\n    query = new SolrQuery(\"*:*\");\n    long totalShardNumDocs = 0;\n    for (Long c : shardCounts.values()) {\n      totalShardNumDocs += c;\n    }\n    for (SolrClient client : clients) {\n      assertEquals(\"sum of shard numDocs on client: \" + client, \n                   totalShardNumDocs,\n                   client.query(query).getResults().getNumFound());\n    }\n    assertTrue(\"total numDocs <= 0, WTF? Test is useless\",\n               0 < totalShardNumDocs);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0ac6494315d04f68950d2f00f5436b4861bcd467","date":1553125039,"type":3,"author":"Kevin Risden","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testShardParamVariations().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testShardParamVariations().mjava","sourceNew":"  private void testShardParamVariations() throws Exception {\n    SolrQuery query = new SolrQuery(\"*:*\");\n    Map<String,Long> shardCounts = new HashMap<>();\n\n    for (String shard : shardToJetty.keySet()) {\n      // every client should give the same numDocs for this shard\n      // shffle the clients in a diff order for each shard\n      List<SolrClient> solrclients = new ArrayList<>(this.clients);\n      Collections.shuffle(solrclients, random());\n      for (SolrClient client : solrclients) {\n        query.set(\"shards\", shard);\n        long numDocs = client.query(query).getResults().getNumFound();\n        assertTrue(\"numDocs < 0 for shard \"+shard+\" via \"+client,\n                   0 <= numDocs);\n        if (!shardCounts.containsKey(shard)) {\n          shardCounts.put(shard, numDocs);\n        }\n        assertEquals(\"inconsitent numDocs for shard \"+shard+\" via \"+client,\n                     shardCounts.get(shard).longValue(), numDocs);\n        \n        List<CloudJettyRunner> replicaJetties \n          = new ArrayList<>(shardToJetty.get(shard));\n        Collections.shuffle(replicaJetties, random());\n\n        // each replica should also give the same numDocs\n        ArrayList<String> replicaAlts = new ArrayList<>(replicaJetties.size() * 2);\n        for (CloudJettyRunner replicaJetty : shardToJetty.get(shard)) {\n          String replica = replicaJetty.url;\n          query.set(\"shards\", replica);\n\n          // replicas already shuffled, use this in the alternative check below\n          if (0 == random().nextInt(3) || replicaAlts.size() < 2) {\n            replicaAlts.add(replica);\n          }\n\n          numDocs = client.query(query).getResults().getNumFound();\n          assertTrue(\"numDocs < 0 for replica \"+replica+\" via \"+client,\n                     0 <= numDocs);\n          assertEquals(\"inconsitent numDocs for shard \"+shard+\n                       \" in replica \"+replica+\" via \"+client,\n                       shardCounts.get(shard).longValue(), numDocs);\n        }\n\n        // any combination of replica alternatives should give same numDocs\n        String replicas = String.join(\"|\", replicaAlts);\n        query.set(\"shards\", replicas);\n        numDocs = client.query(query).getResults().getNumFound();\n        assertTrue(\"numDocs < 0 for replicas \"+replicas+\" via \"+client,\n                   0 <= numDocs);\n          assertEquals(\"inconsitent numDocs for replicas \"+replicas+\n                       \" via \"+client,\n                       shardCounts.get(shard).longValue(), numDocs);\n      }\n    }\n\n    // sums of multiple shards should add up regardless of how we \n    // query those shards or which client we use\n    long randomShardCountsExpected = 0;\n    ArrayList<String> randomShards = new ArrayList<>(shardCounts.size());\n    for (Map.Entry<String,Long> shardData : shardCounts.entrySet()) {\n      if (random().nextBoolean() || randomShards.size() < 2) {\n        String shard = shardData.getKey();\n        randomShardCountsExpected += shardData.getValue();\n        if (random().nextBoolean()) {\n          // use shard id\n          randomShards.add(shard);\n        } else {\n          // use some set explicit replicas\n          ArrayList<String> replicas = new ArrayList<>(7);\n          for (CloudJettyRunner replicaJetty : shardToJetty.get(shard)) {\n            if (0 == random().nextInt(3) || 0 == replicas.size()) {\n              replicas.add(replicaJetty.url);\n            }\n          }\n          Collections.shuffle(replicas, random());\n          randomShards.add(String.join(\"|\", replicas));\n        }\n      }\n    }\n    String randShards = String.join(\",\", randomShards);\n    query.set(\"shards\", randShards);\n    for (SolrClient client : this.clients) {\n      assertEquals(\"numDocs for \"+randShards+\" via \"+client,\n                   randomShardCountsExpected, \n                   client.query(query).getResults().getNumFound());\n    }\n\n    // total num docs must match sum of every shard's numDocs\n    query = new SolrQuery(\"*:*\");\n    long totalShardNumDocs = 0;\n    for (Long c : shardCounts.values()) {\n      totalShardNumDocs += c;\n    }\n    for (SolrClient client : clients) {\n      assertEquals(\"sum of shard numDocs on client: \" + client, \n                   totalShardNumDocs,\n                   client.query(query).getResults().getNumFound());\n    }\n    assertTrue(\"total numDocs <= 0, WTF? Test is useless\",\n        0 < totalShardNumDocs);\n\n  }\n\n","sourceOld":"  private void testShardParamVariations() throws Exception {\n    SolrQuery query = new SolrQuery(\"*:*\");\n    Map<String,Long> shardCounts = new HashMap<>();\n\n    for (String shard : shardToJetty.keySet()) {\n      // every client should give the same numDocs for this shard\n      // shffle the clients in a diff order for each shard\n      List<SolrClient> solrclients = new ArrayList<>(this.clients);\n      Collections.shuffle(solrclients, random());\n      for (SolrClient client : solrclients) {\n        query.set(\"shards\", shard);\n        long numDocs = client.query(query).getResults().getNumFound();\n        assertTrue(\"numDocs < 0 for shard \"+shard+\" via \"+client,\n                   0 <= numDocs);\n        if (!shardCounts.containsKey(shard)) {\n          shardCounts.put(shard, numDocs);\n        }\n        assertEquals(\"inconsitent numDocs for shard \"+shard+\" via \"+client,\n                     shardCounts.get(shard).longValue(), numDocs);\n        \n        List<CloudJettyRunner> replicaJetties \n          = new ArrayList<>(shardToJetty.get(shard));\n        Collections.shuffle(replicaJetties, random());\n\n        // each replica should also give the same numDocs\n        ArrayList<String> replicaAlts = new ArrayList<>(replicaJetties.size() * 2);\n        for (CloudJettyRunner replicaJetty : shardToJetty.get(shard)) {\n          String replica = replicaJetty.url;\n          query.set(\"shards\", replica);\n\n          // replicas already shuffled, use this in the alternative check below\n          if (0 == random().nextInt(3) || replicaAlts.size() < 2) {\n            replicaAlts.add(replica);\n          }\n\n          numDocs = client.query(query).getResults().getNumFound();\n          assertTrue(\"numDocs < 0 for replica \"+replica+\" via \"+client,\n                     0 <= numDocs);\n          assertEquals(\"inconsitent numDocs for shard \"+shard+\n                       \" in replica \"+replica+\" via \"+client,\n                       shardCounts.get(shard).longValue(), numDocs);\n        }\n\n        // any combination of replica alternatives should give same numDocs\n        String replicas = StringUtils.join(replicaAlts.toArray(), \"|\");\n        query.set(\"shards\", replicas);\n        numDocs = client.query(query).getResults().getNumFound();\n        assertTrue(\"numDocs < 0 for replicas \"+replicas+\" via \"+client,\n                   0 <= numDocs);\n          assertEquals(\"inconsitent numDocs for replicas \"+replicas+\n                       \" via \"+client,\n                       shardCounts.get(shard).longValue(), numDocs);\n      }\n    }\n\n    // sums of multiple shards should add up regardless of how we \n    // query those shards or which client we use\n    long randomShardCountsExpected = 0;\n    ArrayList<String> randomShards = new ArrayList<>(shardCounts.size());\n    for (Map.Entry<String,Long> shardData : shardCounts.entrySet()) {\n      if (random().nextBoolean() || randomShards.size() < 2) {\n        String shard = shardData.getKey();\n        randomShardCountsExpected += shardData.getValue();\n        if (random().nextBoolean()) {\n          // use shard id\n          randomShards.add(shard);\n        } else {\n          // use some set explicit replicas\n          ArrayList<String> replicas = new ArrayList<>(7);\n          for (CloudJettyRunner replicaJetty : shardToJetty.get(shard)) {\n            if (0 == random().nextInt(3) || 0 == replicas.size()) {\n              replicas.add(replicaJetty.url);\n            }\n          }\n          Collections.shuffle(replicas, random());\n          randomShards.add(StringUtils.join(replicas, \"|\"));\n        }\n      }\n    }\n    String randShards = StringUtils.join(randomShards, \",\");\n    query.set(\"shards\", randShards);\n    for (SolrClient client : this.clients) {\n      assertEquals(\"numDocs for \"+randShards+\" via \"+client,\n                   randomShardCountsExpected, \n                   client.query(query).getResults().getNumFound());\n    }\n\n    // total num docs must match sum of every shard's numDocs\n    query = new SolrQuery(\"*:*\");\n    long totalShardNumDocs = 0;\n    for (Long c : shardCounts.values()) {\n      totalShardNumDocs += c;\n    }\n    for (SolrClient client : clients) {\n      assertEquals(\"sum of shard numDocs on client: \" + client, \n                   totalShardNumDocs,\n                   client.query(query).getResults().getNumFound());\n    }\n    assertTrue(\"total numDocs <= 0, WTF? Test is useless\",\n        0 < totalShardNumDocs);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["57641b2e9dc6155be493cfb6ae9b8a9c8ceffa72"],"57641b2e9dc6155be493cfb6ae9b8a9c8ceffa72":["e14913df9327ed5dfa00075dc1ff09137dbdb896"],"0ac6494315d04f68950d2f00f5436b4861bcd467":["cb5af3afeddbb803fb785098176e6e177c34261b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e14913df9327ed5dfa00075dc1ff09137dbdb896":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"bafca15d8e408346a67f4282ad1143b88023893b":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"cb5af3afeddbb803fb785098176e6e177c34261b":["bafca15d8e408346a67f4282ad1143b88023893b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0ac6494315d04f68950d2f00f5436b4861bcd467"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["bafca15d8e408346a67f4282ad1143b88023893b"],"57641b2e9dc6155be493cfb6ae9b8a9c8ceffa72":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"0ac6494315d04f68950d2f00f5436b4861bcd467":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e14913df9327ed5dfa00075dc1ff09137dbdb896"],"e14913df9327ed5dfa00075dc1ff09137dbdb896":["57641b2e9dc6155be493cfb6ae9b8a9c8ceffa72"],"bafca15d8e408346a67f4282ad1143b88023893b":["cb5af3afeddbb803fb785098176e6e177c34261b"],"cb5af3afeddbb803fb785098176e6e177c34261b":["0ac6494315d04f68950d2f00f5436b4861bcd467"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}