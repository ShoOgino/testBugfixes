{"path":"lucene/src/java/org/apache/lucene/index/codecs/lucene40/values/SortedBytesMergeUtils#createOrdMapping(MergeState,SortedSourceSlice).mjava","commits":[{"id":"f9efc72acdea22f5285be0a808f8bba51bb8e367","date":1323217280,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/lucene40/values/SortedBytesMergeUtils#createOrdMapping(MergeState,SortedSourceSlice).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/values/SortedBytesMergeUtils#createOrdMapping(MergeState,SortedSourceSlice).mjava","sourceNew":"  /*\n   * In order to merge we need to map the ords used in each segment to the new\n   * global ords in the new segment. Additionally we need to drop values that\n   * are not referenced anymore due to deleted documents. This method walks all\n   * live documents and fetches their current ordinal. We store this ordinal per\n   * slice and (SortedSourceSlice#ordMapping) and remember the doc to ord\n   * mapping in docIDToRelativeOrd. After the merge SortedSourceSlice#ordMapping\n   * contains the new global ordinals for the relative index.\n   */\n  private static void createOrdMapping(MergeState mergeState,\n      SortedSourceSlice currentSlice) {\n    final int readerIdx = currentSlice.readerIdx;\n    final int[] currentDocMap = mergeState.docMaps[readerIdx];\n    final int docBase = currentSlice.docToOrdStart;\n    assert docBase == mergeState.docBase[readerIdx];\n    if (currentDocMap != null) { // we have deletes\n      for (int i = 0; i < currentDocMap.length; i++) {\n        final int doc = currentDocMap[i];\n        if (doc != -1) { // not deleted\n          final int ord = currentSlice.source.ord(i); // collect ords strictly\n                                                      // increasing\n          currentSlice.docIDToRelativeOrd[docBase + doc] = ord;\n          // use ord + 1 to identify unreferenced values (ie. == 0)\n          currentSlice.ordMapping[ord] = ord + 1;\n        }\n      }\n    } else { // no deletes\n      final IndexReaderAndLiveDocs indexReaderAndLiveDocs = mergeState.readers\n          .get(readerIdx);\n      final int numDocs = indexReaderAndLiveDocs.reader.numDocs();\n      assert indexReaderAndLiveDocs.liveDocs == null;\n      assert currentSlice.docToOrdEnd - currentSlice.docToOrdStart == numDocs;\n      for (int doc = 0; doc < numDocs; doc++) {\n        final int ord = currentSlice.source.ord(doc);\n        currentSlice.docIDToRelativeOrd[docBase + doc] = ord;\n        // use ord + 1 to identify unreferenced values (ie. == 0)\n        currentSlice.ordMapping[ord] = ord + 1;\n      }\n    }\n  }\n\n","sourceOld":"  /*\n   * In order to merge we need to map the ords used in each segment to the new\n   * global ords in the new segment. Additionally we need to drop values that\n   * are not referenced anymore due to deleted documents. This method walks all\n   * live documents and fetches their current ordinal. We store this ordinal per\n   * slice and (SortedSourceSlice#ordMapping) and remember the doc to ord\n   * mapping in docIDToRelativeOrd. After the merge SortedSourceSlice#ordMapping\n   * contains the new global ordinals for the relative index.\n   */\n  private static void createOrdMapping(MergeState mergeState,\n      SortedSourceSlice currentSlice) {\n    final int readerIdx = currentSlice.readerIdx;\n    final int[] currentDocMap = mergeState.docMaps[readerIdx];\n    final int docBase = currentSlice.docToOrdStart;\n    assert docBase == mergeState.docBase[readerIdx];\n    if (currentDocMap != null) { // we have deletes\n      for (int i = 0; i < currentDocMap.length; i++) {\n        final int doc = currentDocMap[i];\n        if (doc != -1) { // not deleted\n          final int ord = currentSlice.source.ord(i); // collect ords strictly\n                                                      // increasing\n          currentSlice.docIDToRelativeOrd[docBase + doc] = ord;\n          // use ord + 1 to identify unreferenced values (ie. == 0)\n          currentSlice.ordMapping[ord] = ord + 1;\n        }\n      }\n    } else { // no deletes\n      final IndexReaderAndLiveDocs indexReaderAndLiveDocs = mergeState.readers\n          .get(readerIdx);\n      final int numDocs = indexReaderAndLiveDocs.reader.numDocs();\n      assert indexReaderAndLiveDocs.liveDocs == null;\n      assert currentSlice.docToOrdEnd - currentSlice.docToOrdStart == numDocs;\n      for (int doc = 0; doc < numDocs; doc++) {\n        final int ord = currentSlice.source.ord(doc);\n        currentSlice.docIDToRelativeOrd[docBase + doc] = ord;\n        // use ord + 1 to identify unreferenced values (ie. == 0)\n        currentSlice.ordMapping[ord] = ord + 1;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1263e37167e93fb2e178a37536df562455e7a587","date":1323545884,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SortedBytesMergeUtils#createOrdMapping(MergeState,SortedSourceSlice).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/lucene40/values/SortedBytesMergeUtils#createOrdMapping(MergeState,SortedSourceSlice).mjava","sourceNew":"  /*\n   * In order to merge we need to map the ords used in each segment to the new\n   * global ords in the new segment. Additionally we need to drop values that\n   * are not referenced anymore due to deleted documents. This method walks all\n   * live documents and fetches their current ordinal. We store this ordinal per\n   * slice and (SortedSourceSlice#ordMapping) and remember the doc to ord\n   * mapping in docIDToRelativeOrd. After the merge SortedSourceSlice#ordMapping\n   * contains the new global ordinals for the relative index.\n   */\n  private static void createOrdMapping(MergeState mergeState,\n      SortedSourceSlice currentSlice) {\n    final int readerIdx = currentSlice.readerIdx;\n    final int[] currentDocMap = mergeState.docMaps[readerIdx];\n    final int docBase = currentSlice.docToOrdStart;\n    assert docBase == mergeState.docBase[readerIdx];\n    if (currentDocMap != null) { // we have deletes\n      for (int i = 0; i < currentDocMap.length; i++) {\n        final int doc = currentDocMap[i];\n        if (doc != -1) { // not deleted\n          final int ord = currentSlice.source.ord(i); // collect ords strictly\n                                                      // increasing\n          currentSlice.docIDToRelativeOrd[docBase + doc] = ord;\n          // use ord + 1 to identify unreferenced values (ie. == 0)\n          currentSlice.ordMapping[ord] = ord + 1;\n        }\n      }\n    } else { // no deletes\n      final IndexReaderAndLiveDocs indexReaderAndLiveDocs = mergeState.readers\n          .get(readerIdx);\n      final int numDocs = indexReaderAndLiveDocs.reader.numDocs();\n      assert indexReaderAndLiveDocs.liveDocs == null;\n      assert currentSlice.docToOrdEnd - currentSlice.docToOrdStart == numDocs;\n      for (int doc = 0; doc < numDocs; doc++) {\n        final int ord = currentSlice.source.ord(doc);\n        currentSlice.docIDToRelativeOrd[docBase + doc] = ord;\n        // use ord + 1 to identify unreferenced values (ie. == 0)\n        currentSlice.ordMapping[ord] = ord + 1;\n      }\n    }\n  }\n\n","sourceOld":"  /*\n   * In order to merge we need to map the ords used in each segment to the new\n   * global ords in the new segment. Additionally we need to drop values that\n   * are not referenced anymore due to deleted documents. This method walks all\n   * live documents and fetches their current ordinal. We store this ordinal per\n   * slice and (SortedSourceSlice#ordMapping) and remember the doc to ord\n   * mapping in docIDToRelativeOrd. After the merge SortedSourceSlice#ordMapping\n   * contains the new global ordinals for the relative index.\n   */\n  private static void createOrdMapping(MergeState mergeState,\n      SortedSourceSlice currentSlice) {\n    final int readerIdx = currentSlice.readerIdx;\n    final int[] currentDocMap = mergeState.docMaps[readerIdx];\n    final int docBase = currentSlice.docToOrdStart;\n    assert docBase == mergeState.docBase[readerIdx];\n    if (currentDocMap != null) { // we have deletes\n      for (int i = 0; i < currentDocMap.length; i++) {\n        final int doc = currentDocMap[i];\n        if (doc != -1) { // not deleted\n          final int ord = currentSlice.source.ord(i); // collect ords strictly\n                                                      // increasing\n          currentSlice.docIDToRelativeOrd[docBase + doc] = ord;\n          // use ord + 1 to identify unreferenced values (ie. == 0)\n          currentSlice.ordMapping[ord] = ord + 1;\n        }\n      }\n    } else { // no deletes\n      final IndexReaderAndLiveDocs indexReaderAndLiveDocs = mergeState.readers\n          .get(readerIdx);\n      final int numDocs = indexReaderAndLiveDocs.reader.numDocs();\n      assert indexReaderAndLiveDocs.liveDocs == null;\n      assert currentSlice.docToOrdEnd - currentSlice.docToOrdStart == numDocs;\n      for (int doc = 0; doc < numDocs; doc++) {\n        final int ord = currentSlice.source.ord(doc);\n        currentSlice.docIDToRelativeOrd[docBase + doc] = ord;\n        // use ord + 1 to identify unreferenced values (ie. == 0)\n        currentSlice.ordMapping[ord] = ord + 1;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1263e37167e93fb2e178a37536df562455e7a587":["f9efc72acdea22f5285be0a808f8bba51bb8e367"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f9efc72acdea22f5285be0a808f8bba51bb8e367":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"1263e37167e93fb2e178a37536df562455e7a587":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f9efc72acdea22f5285be0a808f8bba51bb8e367","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f9efc72acdea22f5285be0a808f8bba51bb8e367":["1263e37167e93fb2e178a37536df562455e7a587"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["1263e37167e93fb2e178a37536df562455e7a587","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}