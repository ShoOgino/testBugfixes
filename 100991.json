{"path":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","commits":[{"id":"c1bb50752d43a65ef1b623eabdb8e865983d3cd6","date":1304257984,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","pathOld":"/dev/null","sourceNew":"  /** create a new searcher over the reader.\n   * This searcher might randomly use threads.\n   * if <code>maybeWrap</code> is true, this searcher might wrap the reader\n   * with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n    if (random.nextBoolean()) {\n      if (maybeWrap && random.nextBoolean()) {\n        return new IndexSearcher(new SlowMultiReaderWrapper(r));\n      } else {\n        return new IndexSearcher(r);\n      }\n    } else {\n      int threads = 0;\n      final ExecutorService ex = (random.nextBoolean()) ? null \n          : Executors.newFixedThreadPool(threads = _TestUtil.nextInt(random, 1, 8), \n                      new NamedThreadFactory(\"LuceneTestCase\"));\n      if (ex != null && VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n      }\n      return new IndexSearcher(r.getTopReaderContext(), ex) {\n        @Override\n        public void close() throws IOException {\n          super.close();\n          if (ex != null) {\n            ex.shutdown();\n            try {\n              ex.awaitTermination(1000, TimeUnit.MILLISECONDS);\n            } catch (InterruptedException e) {\n              e.printStackTrace();\n            }\n          }\n        }\n      };\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b3e06be49006ecac364d39d12b9c9f74882f9b9f","date":1304289513,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","sourceNew":"  /** create a new searcher over the reader.\n   * This searcher might randomly use threads.\n   * if <code>maybeWrap</code> is true, this searcher might wrap the reader\n   * with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n    if (random.nextBoolean()) {\n      if (maybeWrap && random.nextBoolean()) {\n        return new IndexSearcher(new SlowMultiReaderWrapper(r));\n      } else {\n        return new IndexSearcher(r);\n      }\n    } else {\n      int threads = 0;\n      final ExecutorService ex = (random.nextBoolean()) ? null\n          : Executors.newFixedThreadPool(threads = _TestUtil.nextInt(random, 1, 8),\n                      new NamedThreadFactory(\"LuceneTestCase\"));\n      if (ex != null && VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n      }\n      return new IndexSearcher(r.getTopReaderContext(), ex) {\n        @Override\n        public void close() throws IOException {\n          super.close();\n          if (ex != null) {\n            ex.shutdown();\n            try {\n              ex.awaitTermination(1000, TimeUnit.MILLISECONDS);\n            } catch (InterruptedException e) {\n              e.printStackTrace();\n            }\n          }\n        }\n      };\n    }\n  }\n\n","sourceOld":"  /** create a new searcher over the reader.\n   * This searcher might randomly use threads.\n   * if <code>maybeWrap</code> is true, this searcher might wrap the reader\n   * with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n    if (random.nextBoolean()) {\n      if (maybeWrap && random.nextBoolean()) {\n        return new IndexSearcher(new SlowMultiReaderWrapper(r));\n      } else {\n        return new IndexSearcher(r);\n      }\n    } else {\n      int threads = 0;\n      final ExecutorService ex = (random.nextBoolean()) ? null \n          : Executors.newFixedThreadPool(threads = _TestUtil.nextInt(random, 1, 8), \n                      new NamedThreadFactory(\"LuceneTestCase\"));\n      if (ex != null && VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n      }\n      return new IndexSearcher(r.getTopReaderContext(), ex) {\n        @Override\n        public void close() throws IOException {\n          super.close();\n          if (ex != null) {\n            ex.shutdown();\n            try {\n              ex.awaitTermination(1000, TimeUnit.MILLISECONDS);\n            } catch (InterruptedException e) {\n              e.printStackTrace();\n            }\n          }\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"135621f3a0670a9394eb563224a3b76cc4dddc0f","date":1304344257,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","pathOld":"/dev/null","sourceNew":"  /** create a new searcher over the reader.\n   * This searcher might randomly use threads.\n   * if <code>maybeWrap</code> is true, this searcher might wrap the reader\n   * with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n    if (random.nextBoolean()) {\n      if (maybeWrap && random.nextBoolean()) {\n        return new IndexSearcher(new SlowMultiReaderWrapper(r));\n      } else {\n        return new IndexSearcher(r);\n      }\n    } else {\n      int threads = 0;\n      final ExecutorService ex = (random.nextBoolean()) ? null\n          : Executors.newFixedThreadPool(threads = _TestUtil.nextInt(random, 1, 8),\n                      new NamedThreadFactory(\"LuceneTestCase\"));\n      if (ex != null && VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n      }\n      return new IndexSearcher(r.getTopReaderContext(), ex) {\n        @Override\n        public void close() throws IOException {\n          super.close();\n          if (ex != null) {\n            ex.shutdown();\n            try {\n              ex.awaitTermination(1000, TimeUnit.MILLISECONDS);\n            } catch (InterruptedException e) {\n              e.printStackTrace();\n            }\n          }\n        }\n      };\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9d3c12b2df00ba96fed86d45277197bc4d09f084","date":1306080516,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","sourceNew":"  /** create a new searcher over the reader.\n   * This searcher might randomly use threads.\n   * if <code>maybeWrap</code> is true, this searcher might wrap the reader\n   * with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n\n    if (random.nextBoolean()) {\n      if (maybeWrap && random.nextBoolean()) {\n        return new IndexSearcher(new SlowMultiReaderWrapper(r));\n      } else {\n        return new IndexSearcher(r);\n      }\n    } else {\n      int threads = 0;\n      final ExecutorService ex = (random.nextBoolean()) ? null\n          : Executors.newFixedThreadPool(threads = _TestUtil.nextInt(random, 1, 8),\n                      new NamedThreadFactory(\"LuceneTestCase\"));\n      if (ex != null && VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n      }\n      return new IndexSearcher(r.getTopReaderContext(), ex) {\n        @Override\n        public void close() throws IOException {\n          super.close();\n          if (ex != null) {\n            ex.shutdown();\n            try {\n              ex.awaitTermination(1000, TimeUnit.MILLISECONDS);\n            } catch (InterruptedException e) {\n              e.printStackTrace();\n            }\n          }\n        }\n      };\n    }\n  }\n\n","sourceOld":"  /** create a new searcher over the reader.\n   * This searcher might randomly use threads.\n   * if <code>maybeWrap</code> is true, this searcher might wrap the reader\n   * with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n    if (random.nextBoolean()) {\n      if (maybeWrap && random.nextBoolean()) {\n        return new IndexSearcher(new SlowMultiReaderWrapper(r));\n      } else {\n        return new IndexSearcher(r);\n      }\n    } else {\n      int threads = 0;\n      final ExecutorService ex = (random.nextBoolean()) ? null\n          : Executors.newFixedThreadPool(threads = _TestUtil.nextInt(random, 1, 8),\n                      new NamedThreadFactory(\"LuceneTestCase\"));\n      if (ex != null && VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n      }\n      return new IndexSearcher(r.getTopReaderContext(), ex) {\n        @Override\n        public void close() throws IOException {\n          super.close();\n          if (ex != null) {\n            ex.shutdown();\n            try {\n              ex.awaitTermination(1000, TimeUnit.MILLISECONDS);\n            } catch (InterruptedException e) {\n              e.printStackTrace();\n            }\n          }\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3776dccca01c11e7046323cfad46a3b4a471233","date":1306100719,"type":0,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","pathOld":"/dev/null","sourceNew":"  /** create a new searcher over the reader.\n   * This searcher might randomly use threads.\n   * if <code>maybeWrap</code> is true, this searcher might wrap the reader\n   * with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n\n    if (random.nextBoolean()) {\n      if (maybeWrap && random.nextBoolean()) {\n        return new IndexSearcher(new SlowMultiReaderWrapper(r));\n      } else {\n        return new IndexSearcher(r);\n      }\n    } else {\n      int threads = 0;\n      final ExecutorService ex = (random.nextBoolean()) ? null\n          : Executors.newFixedThreadPool(threads = _TestUtil.nextInt(random, 1, 8),\n                      new NamedThreadFactory(\"LuceneTestCase\"));\n      if (ex != null && VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n      }\n      return new IndexSearcher(r.getTopReaderContext(), ex) {\n        @Override\n        public void close() throws IOException {\n          super.close();\n          if (ex != null) {\n            ex.shutdown();\n            try {\n              ex.awaitTermination(1000, TimeUnit.MILLISECONDS);\n            } catch (InterruptedException e) {\n              e.printStackTrace();\n            }\n          }\n        }\n      };\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5c698c0cb88bac4bcd36a1b1001a0c6a2163ea2a","date":1306150983,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","sourceNew":"  /** create a new searcher over the reader.\n   * This searcher might randomly use threads.\n   * if <code>maybeWrap</code> is true, this searcher might wrap the reader\n   * with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n\n    if (random.nextBoolean()) {\n      if (maybeWrap && random.nextBoolean()) {\n        return new IndexSearcher(new SlowMultiReaderWrapper(r));\n      } else {\n        return new IndexSearcher(r);\n      }\n    } else {\n      int threads = 0;\n      final ExecutorService ex = (random.nextBoolean()) ? null\n          : Executors.newFixedThreadPool(threads = _TestUtil.nextInt(random, 1, 8),\n                      new NamedThreadFactory(\"LuceneTestCase\"));\n      if (ex != null && VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n      }\n      return new IndexSearcher(r.getTopReaderContext(), ex) {\n        @Override\n        public void close() throws IOException {\n          super.close();\n          if (ex != null) {\n            ex.shutdown();\n            try {\n              ex.awaitTermination(1000, TimeUnit.MILLISECONDS);\n            } catch (InterruptedException e) {\n              e.printStackTrace();\n            }\n          }\n        }\n      };\n    }\n  }\n\n","sourceOld":"  /** create a new searcher over the reader.\n   * This searcher might randomly use threads.\n   * if <code>maybeWrap</code> is true, this searcher might wrap the reader\n   * with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n    if (random.nextBoolean()) {\n      if (maybeWrap && random.nextBoolean()) {\n        return new IndexSearcher(new SlowMultiReaderWrapper(r));\n      } else {\n        return new IndexSearcher(r);\n      }\n    } else {\n      int threads = 0;\n      final ExecutorService ex = (random.nextBoolean()) ? null\n          : Executors.newFixedThreadPool(threads = _TestUtil.nextInt(random, 1, 8),\n                      new NamedThreadFactory(\"LuceneTestCase\"));\n      if (ex != null && VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n      }\n      return new IndexSearcher(r.getTopReaderContext(), ex) {\n        @Override\n        public void close() throws IOException {\n          super.close();\n          if (ex != null) {\n            ex.shutdown();\n            try {\n              ex.awaitTermination(1000, TimeUnit.MILLISECONDS);\n            } catch (InterruptedException e) {\n              e.printStackTrace();\n            }\n          }\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ff6fd241dc6610f7f81b62e3ba4cedf105939623","date":1307331653,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","sourceNew":"  /** create a new searcher over the reader.\n   * This searcher might randomly use threads.\n   * if <code>maybeWrap</code> is true, this searcher might wrap the reader\n   * with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n\n    if (random.nextBoolean()) {\n      if (maybeWrap && random.nextInt(20) == 0) {\n        return new IndexSearcher(new SlowMultiReaderWrapper(r));\n      } else {\n        return new IndexSearcher(r);\n      }\n    } else {\n      int threads = 0;\n      final ExecutorService ex = (random.nextBoolean()) ? null\n          : Executors.newFixedThreadPool(threads = _TestUtil.nextInt(random, 1, 8),\n                      new NamedThreadFactory(\"LuceneTestCase\"));\n      if (ex != null && VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n      }\n      return new IndexSearcher(r.getTopReaderContext(), ex) {\n        @Override\n        public void close() throws IOException {\n          super.close();\n          if (ex != null) {\n            ex.shutdown();\n            try {\n              ex.awaitTermination(1000, TimeUnit.MILLISECONDS);\n            } catch (InterruptedException e) {\n              e.printStackTrace();\n            }\n          }\n        }\n      };\n    }\n  }\n\n","sourceOld":"  /** create a new searcher over the reader.\n   * This searcher might randomly use threads.\n   * if <code>maybeWrap</code> is true, this searcher might wrap the reader\n   * with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n\n    if (random.nextBoolean()) {\n      if (maybeWrap && random.nextBoolean()) {\n        return new IndexSearcher(new SlowMultiReaderWrapper(r));\n      } else {\n        return new IndexSearcher(r);\n      }\n    } else {\n      int threads = 0;\n      final ExecutorService ex = (random.nextBoolean()) ? null\n          : Executors.newFixedThreadPool(threads = _TestUtil.nextInt(random, 1, 8),\n                      new NamedThreadFactory(\"LuceneTestCase\"));\n      if (ex != null && VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n      }\n      return new IndexSearcher(r.getTopReaderContext(), ex) {\n        @Override\n        public void close() throws IOException {\n          super.close();\n          if (ex != null) {\n            ex.shutdown();\n            try {\n              ex.awaitTermination(1000, TimeUnit.MILLISECONDS);\n            } catch (InterruptedException e) {\n              e.printStackTrace();\n            }\n          }\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"79c2cb24929f2649a8875fb629086171f914d5ce","date":1307332717,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","sourceNew":"  /** create a new searcher over the reader.\n   * This searcher might randomly use threads.\n   * if <code>maybeWrap</code> is true, this searcher might wrap the reader\n   * with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n\n    if (random.nextBoolean()) {\n      if (maybeWrap && random.nextInt(20) == 0) {\n        return new IndexSearcher(new SlowMultiReaderWrapper(r));\n      } else {\n        return new IndexSearcher(r);\n      }\n    } else {\n      int threads = 0;\n      final ExecutorService ex = (random.nextBoolean()) ? null\n          : Executors.newFixedThreadPool(threads = _TestUtil.nextInt(random, 1, 8),\n                      new NamedThreadFactory(\"LuceneTestCase\"));\n      if (ex != null && VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n      }\n      return new IndexSearcher(r.getTopReaderContext(), ex) {\n        @Override\n        public void close() throws IOException {\n          super.close();\n          if (ex != null) {\n            ex.shutdown();\n            try {\n              ex.awaitTermination(1000, TimeUnit.MILLISECONDS);\n            } catch (InterruptedException e) {\n              e.printStackTrace();\n            }\n          }\n        }\n      };\n    }\n  }\n\n","sourceOld":"  /** create a new searcher over the reader.\n   * This searcher might randomly use threads.\n   * if <code>maybeWrap</code> is true, this searcher might wrap the reader\n   * with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n\n    if (random.nextBoolean()) {\n      if (maybeWrap && random.nextBoolean()) {\n        return new IndexSearcher(new SlowMultiReaderWrapper(r));\n      } else {\n        return new IndexSearcher(r);\n      }\n    } else {\n      int threads = 0;\n      final ExecutorService ex = (random.nextBoolean()) ? null\n          : Executors.newFixedThreadPool(threads = _TestUtil.nextInt(random, 1, 8),\n                      new NamedThreadFactory(\"LuceneTestCase\"));\n      if (ex != null && VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n      }\n      return new IndexSearcher(r.getTopReaderContext(), ex) {\n        @Override\n        public void close() throws IOException {\n          super.close();\n          if (ex != null) {\n            ex.shutdown();\n            try {\n              ex.awaitTermination(1000, TimeUnit.MILLISECONDS);\n            } catch (InterruptedException e) {\n              e.printStackTrace();\n            }\n          }\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0762b640e0d0d12b6edb96db68986e13145c3484","date":1307575932,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","sourceNew":"  /** create a new searcher over the reader.\n   * This searcher might randomly use threads.\n   * if <code>maybeWrap</code> is true, this searcher might wrap the reader\n   * with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n\n    if (random.nextBoolean()) {\n      if (maybeWrap && rarely()) {\n        return new IndexSearcher(new SlowMultiReaderWrapper(r));\n      } else {\n        return new IndexSearcher(r);\n      }\n    } else {\n      int threads = 0;\n      final ExecutorService ex = (random.nextBoolean()) ? null\n          : Executors.newFixedThreadPool(threads = _TestUtil.nextInt(random, 1, 8),\n                      new NamedThreadFactory(\"LuceneTestCase\"));\n      if (ex != null && VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n      }\n      return new IndexSearcher(r.getTopReaderContext(), ex) {\n        @Override\n        public void close() throws IOException {\n          super.close();\n          if (ex != null) {\n            ex.shutdown();\n            try {\n              ex.awaitTermination(1000, TimeUnit.MILLISECONDS);\n            } catch (InterruptedException e) {\n              e.printStackTrace();\n            }\n          }\n        }\n      };\n    }\n  }\n\n","sourceOld":"  /** create a new searcher over the reader.\n   * This searcher might randomly use threads.\n   * if <code>maybeWrap</code> is true, this searcher might wrap the reader\n   * with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n\n    if (random.nextBoolean()) {\n      if (maybeWrap && random.nextInt(20) == 0) {\n        return new IndexSearcher(new SlowMultiReaderWrapper(r));\n      } else {\n        return new IndexSearcher(r);\n      }\n    } else {\n      int threads = 0;\n      final ExecutorService ex = (random.nextBoolean()) ? null\n          : Executors.newFixedThreadPool(threads = _TestUtil.nextInt(random, 1, 8),\n                      new NamedThreadFactory(\"LuceneTestCase\"));\n      if (ex != null && VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n      }\n      return new IndexSearcher(r.getTopReaderContext(), ex) {\n        @Override\n        public void close() throws IOException {\n          super.close();\n          if (ex != null) {\n            ex.shutdown();\n            try {\n              ex.awaitTermination(1000, TimeUnit.MILLISECONDS);\n            } catch (InterruptedException e) {\n              e.printStackTrace();\n            }\n          }\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"77cf4379b2824f6ea34b091c495d6e95c38ff9e2","date":1307610475,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","sourceNew":"  /** create a new searcher over the reader.\n   * This searcher might randomly use threads.\n   * if <code>maybeWrap</code> is true, this searcher might wrap the reader\n   * with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n\n    if (random.nextBoolean()) {\n      if (maybeWrap && rarely()) {\n        return new IndexSearcher(new SlowMultiReaderWrapper(r));\n      } else {\n        return new IndexSearcher(r);\n      }\n    } else {\n      int threads = 0;\n      final ExecutorService ex = (random.nextBoolean()) ? null\n          : Executors.newFixedThreadPool(threads = _TestUtil.nextInt(random, 1, 8),\n                      new NamedThreadFactory(\"LuceneTestCase\"));\n      if (ex != null && VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n      }\n      return new IndexSearcher(r.getTopReaderContext(), ex) {\n        @Override\n        public void close() throws IOException {\n          super.close();\n          if (ex != null) {\n            ex.shutdown();\n            try {\n              ex.awaitTermination(1000, TimeUnit.MILLISECONDS);\n            } catch (InterruptedException e) {\n              e.printStackTrace();\n            }\n          }\n        }\n      };\n    }\n  }\n\n","sourceOld":"  /** create a new searcher over the reader.\n   * This searcher might randomly use threads.\n   * if <code>maybeWrap</code> is true, this searcher might wrap the reader\n   * with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n\n    if (random.nextBoolean()) {\n      if (maybeWrap && random.nextBoolean()) {\n        return new IndexSearcher(new SlowMultiReaderWrapper(r));\n      } else {\n        return new IndexSearcher(r);\n      }\n    } else {\n      int threads = 0;\n      final ExecutorService ex = (random.nextBoolean()) ? null\n          : Executors.newFixedThreadPool(threads = _TestUtil.nextInt(random, 1, 8),\n                      new NamedThreadFactory(\"LuceneTestCase\"));\n      if (ex != null && VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n      }\n      return new IndexSearcher(r.getTopReaderContext(), ex) {\n        @Override\n        public void close() throws IOException {\n          super.close();\n          if (ex != null) {\n            ex.shutdown();\n            try {\n              ex.awaitTermination(1000, TimeUnit.MILLISECONDS);\n            } catch (InterruptedException e) {\n              e.printStackTrace();\n            }\n          }\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","date":1307729864,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","sourceNew":"  /** create a new searcher over the reader.\n   * This searcher might randomly use threads.\n   * if <code>maybeWrap</code> is true, this searcher might wrap the reader\n   * with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n\n    if (random.nextBoolean()) {\n      if (maybeWrap && rarely()) {\n        return new IndexSearcher(new SlowMultiReaderWrapper(r));\n      } else {\n        return new IndexSearcher(r);\n      }\n    } else {\n      int threads = 0;\n      final ExecutorService ex = (random.nextBoolean()) ? null\n          : Executors.newFixedThreadPool(threads = _TestUtil.nextInt(random, 1, 8),\n                      new NamedThreadFactory(\"LuceneTestCase\"));\n      if (ex != null && VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n      }\n      return new IndexSearcher(r.getTopReaderContext(), ex) {\n        @Override\n        public void close() throws IOException {\n          super.close();\n          if (ex != null) {\n            ex.shutdown();\n            try {\n              ex.awaitTermination(1000, TimeUnit.MILLISECONDS);\n            } catch (InterruptedException e) {\n              e.printStackTrace();\n            }\n          }\n        }\n      };\n    }\n  }\n\n","sourceOld":"  /** create a new searcher over the reader.\n   * This searcher might randomly use threads.\n   * if <code>maybeWrap</code> is true, this searcher might wrap the reader\n   * with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n\n    if (random.nextBoolean()) {\n      if (maybeWrap && random.nextInt(20) == 0) {\n        return new IndexSearcher(new SlowMultiReaderWrapper(r));\n      } else {\n        return new IndexSearcher(r);\n      }\n    } else {\n      int threads = 0;\n      final ExecutorService ex = (random.nextBoolean()) ? null\n          : Executors.newFixedThreadPool(threads = _TestUtil.nextInt(random, 1, 8),\n                      new NamedThreadFactory(\"LuceneTestCase\"));\n      if (ex != null && VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n      }\n      return new IndexSearcher(r.getTopReaderContext(), ex) {\n        @Override\n        public void close() throws IOException {\n          super.close();\n          if (ex != null) {\n            ex.shutdown();\n            try {\n              ex.awaitTermination(1000, TimeUnit.MILLISECONDS);\n            } catch (InterruptedException e) {\n              e.printStackTrace();\n            }\n          }\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6f7fee42303a18cc146043c96f66491311b345d9","date":1308246904,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","sourceNew":"  /** create a new searcher over the reader.\n   * This searcher might randomly use threads.\n   * if <code>maybeWrap</code> is true, this searcher might wrap the reader\n   * with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n    if (random.nextBoolean()) {\n      if (maybeWrap && rarely()) {\n        r = new SlowMultiReaderWrapper(r);\n      }\n      return random.nextBoolean() ? new AssertingIndexSearcher(r) : new AssertingIndexSearcher(r.getTopReaderContext());\n    } else {\n      int threads = 0;\n      final ExecutorService ex = (random.nextBoolean()) ? null\n          : Executors.newFixedThreadPool(threads = _TestUtil.nextInt(random, 1, 8),\n                      new NamedThreadFactory(\"LuceneTestCase\"));\n      if (ex != null && VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n      }\n      return random.nextBoolean() ? \n        new AssertingIndexSearcher(r, ex) {\n          @Override\n          public void close() throws IOException {\n            super.close();\n            shutdownExecutorService(ex);\n          }\n        } : new AssertingIndexSearcher(r.getTopReaderContext(), ex) {\n          @Override\n          public void close() throws IOException {\n            super.close();\n            shutdownExecutorService(ex);\n          }\n        };\n    }\n  }\n\n","sourceOld":"  /** create a new searcher over the reader.\n   * This searcher might randomly use threads.\n   * if <code>maybeWrap</code> is true, this searcher might wrap the reader\n   * with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n\n    if (random.nextBoolean()) {\n      if (maybeWrap && rarely()) {\n        return new IndexSearcher(new SlowMultiReaderWrapper(r));\n      } else {\n        return new IndexSearcher(r);\n      }\n    } else {\n      int threads = 0;\n      final ExecutorService ex = (random.nextBoolean()) ? null\n          : Executors.newFixedThreadPool(threads = _TestUtil.nextInt(random, 1, 8),\n                      new NamedThreadFactory(\"LuceneTestCase\"));\n      if (ex != null && VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n      }\n      return new IndexSearcher(r.getTopReaderContext(), ex) {\n        @Override\n        public void close() throws IOException {\n          super.close();\n          if (ex != null) {\n            ex.shutdown();\n            try {\n              ex.awaitTermination(1000, TimeUnit.MILLISECONDS);\n            } catch (InterruptedException e) {\n              e.printStackTrace();\n            }\n          }\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a2903ea38ae3e636b93a08c52a5e37ae939cf6b","date":1308291005,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","sourceNew":"  /** create a new searcher over the reader.\n   * This searcher might randomly use threads.\n   * if <code>maybeWrap</code> is true, this searcher might wrap the reader\n   * with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n    if (random.nextBoolean()) {\n      if (maybeWrap && rarely()) {\n        r = new SlowMultiReaderWrapper(r);\n      }\n      return random.nextBoolean() ? new AssertingIndexSearcher(r) : new AssertingIndexSearcher(r.getTopReaderContext());\n    } else {\n      int threads = 0;\n      final ExecutorService ex = (random.nextBoolean()) ? null\n          : Executors.newFixedThreadPool(threads = _TestUtil.nextInt(random, 1, 8),\n                      new NamedThreadFactory(\"LuceneTestCase\"));\n      if (ex != null && VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n      }\n      return random.nextBoolean() ? \n        new AssertingIndexSearcher(r, ex) {\n          @Override\n          public void close() throws IOException {\n            super.close();\n            shutdownExecutorService(ex);\n          }\n        } : new AssertingIndexSearcher(r.getTopReaderContext(), ex) {\n          @Override\n          public void close() throws IOException {\n            super.close();\n            shutdownExecutorService(ex);\n          }\n        };\n    }\n  }\n\n","sourceOld":"  /** create a new searcher over the reader.\n   * This searcher might randomly use threads.\n   * if <code>maybeWrap</code> is true, this searcher might wrap the reader\n   * with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n\n    if (random.nextBoolean()) {\n      if (maybeWrap && rarely()) {\n        return new IndexSearcher(new SlowMultiReaderWrapper(r));\n      } else {\n        return new IndexSearcher(r);\n      }\n    } else {\n      int threads = 0;\n      final ExecutorService ex = (random.nextBoolean()) ? null\n          : Executors.newFixedThreadPool(threads = _TestUtil.nextInt(random, 1, 8),\n                      new NamedThreadFactory(\"LuceneTestCase\"));\n      if (ex != null && VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n      }\n      return new IndexSearcher(r.getTopReaderContext(), ex) {\n        @Override\n        public void close() throws IOException {\n          super.close();\n          if (ex != null) {\n            ex.shutdown();\n            try {\n              ex.awaitTermination(1000, TimeUnit.MILLISECONDS);\n            } catch (InterruptedException e) {\n              e.printStackTrace();\n            }\n          }\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"60e3b31201fd9bb5d73884faa5a38c63ea9239f2","date":1315756041,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","sourceNew":"  /** create a new searcher over the reader.\n   * This searcher might randomly use threads.\n   * if <code>maybeWrap</code> is true, this searcher might wrap the reader\n   * with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n    if (random.nextBoolean()) {\n      if (maybeWrap && rarely()) {\n        r = new SlowMultiReaderWrapper(r);\n      }\n      IndexSearcher ret = random.nextBoolean() ? new AssertingIndexSearcher(r) : new AssertingIndexSearcher(r.getTopReaderContext());\n      ret.setSimilarityProvider(similarityProvider);\n      return ret;\n    } else {\n      int threads = 0;\n      final ExecutorService ex = (random.nextBoolean()) ? null\n          : Executors.newFixedThreadPool(threads = _TestUtil.nextInt(random, 1, 8),\n                      new NamedThreadFactory(\"LuceneTestCase\"));\n      if (ex != null && VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n      }\n      IndexSearcher ret = random.nextBoolean() ? \n        new AssertingIndexSearcher(r, ex) {\n          @Override\n          public void close() throws IOException {\n            super.close();\n            shutdownExecutorService(ex);\n          }\n        } : new AssertingIndexSearcher(r.getTopReaderContext(), ex) {\n          @Override\n          public void close() throws IOException {\n            super.close();\n            shutdownExecutorService(ex);\n          }\n        };\n      ret.setSimilarityProvider(similarityProvider);\n      return ret;\n    }\n  }\n\n","sourceOld":"  /** create a new searcher over the reader.\n   * This searcher might randomly use threads.\n   * if <code>maybeWrap</code> is true, this searcher might wrap the reader\n   * with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n    if (random.nextBoolean()) {\n      if (maybeWrap && rarely()) {\n        r = new SlowMultiReaderWrapper(r);\n      }\n      return random.nextBoolean() ? new AssertingIndexSearcher(r) : new AssertingIndexSearcher(r.getTopReaderContext());\n    } else {\n      int threads = 0;\n      final ExecutorService ex = (random.nextBoolean()) ? null\n          : Executors.newFixedThreadPool(threads = _TestUtil.nextInt(random, 1, 8),\n                      new NamedThreadFactory(\"LuceneTestCase\"));\n      if (ex != null && VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n      }\n      return random.nextBoolean() ? \n        new AssertingIndexSearcher(r, ex) {\n          @Override\n          public void close() throws IOException {\n            super.close();\n            shutdownExecutorService(ex);\n          }\n        } : new AssertingIndexSearcher(r.getTopReaderContext(), ex) {\n          @Override\n          public void close() throws IOException {\n            super.close();\n            shutdownExecutorService(ex);\n          }\n        };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6620df8541b174097b1133a4fc370adb2e570524","date":1319544675,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","sourceNew":"  /** create a new searcher over the reader.\n   * This searcher might randomly use threads.\n   * if <code>maybeWrap</code> is true, this searcher might wrap the reader\n   * with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n    if (random.nextBoolean()) {\n      if (maybeWrap && rarely()) {\n        r = new SlowMultiReaderWrapper(r);\n      }\n      IndexSearcher ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getTopReaderContext());\n      ret.setSimilarityProvider(similarityProvider);\n      return ret;\n    } else {\n      int threads = 0;\n      final ExecutorService ex = (random.nextBoolean()) ? null\n          : Executors.newFixedThreadPool(threads = _TestUtil.nextInt(random, 1, 8),\n                      new NamedThreadFactory(\"LuceneTestCase\"));\n      if (ex != null && VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n      }\n      IndexSearcher ret = random.nextBoolean() ? \n        new AssertingIndexSearcher(random, r, ex) {\n          @Override\n          public void close() throws IOException {\n            super.close();\n            shutdownExecutorService(ex);\n          }\n        } : new AssertingIndexSearcher(random, r.getTopReaderContext(), ex) {\n          @Override\n          public void close() throws IOException {\n            super.close();\n            shutdownExecutorService(ex);\n          }\n        };\n      ret.setSimilarityProvider(similarityProvider);\n      return ret;\n    }\n  }\n\n","sourceOld":"  /** create a new searcher over the reader.\n   * This searcher might randomly use threads.\n   * if <code>maybeWrap</code> is true, this searcher might wrap the reader\n   * with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n    if (random.nextBoolean()) {\n      if (maybeWrap && rarely()) {\n        r = new SlowMultiReaderWrapper(r);\n      }\n      IndexSearcher ret = random.nextBoolean() ? new AssertingIndexSearcher(r) : new AssertingIndexSearcher(r.getTopReaderContext());\n      ret.setSimilarityProvider(similarityProvider);\n      return ret;\n    } else {\n      int threads = 0;\n      final ExecutorService ex = (random.nextBoolean()) ? null\n          : Executors.newFixedThreadPool(threads = _TestUtil.nextInt(random, 1, 8),\n                      new NamedThreadFactory(\"LuceneTestCase\"));\n      if (ex != null && VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n      }\n      IndexSearcher ret = random.nextBoolean() ? \n        new AssertingIndexSearcher(r, ex) {\n          @Override\n          public void close() throws IOException {\n            super.close();\n            shutdownExecutorService(ex);\n          }\n        } : new AssertingIndexSearcher(r.getTopReaderContext(), ex) {\n          @Override\n          public void close() throws IOException {\n            super.close();\n            shutdownExecutorService(ex);\n          }\n        };\n      ret.setSimilarityProvider(similarityProvider);\n      return ret;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b91922b55d15444d554721b352861d028eb8278","date":1320421415,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test-framework/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","sourceNew":"  /** create a new searcher over the reader.\n   * This searcher might randomly use threads.\n   * if <code>maybeWrap</code> is true, this searcher might wrap the reader\n   * with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n    if (random.nextBoolean()) {\n      if (maybeWrap && rarely()) {\n        r = new SlowMultiReaderWrapper(r);\n      }\n      IndexSearcher ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getTopReaderContext());\n      ret.setSimilarityProvider(similarityProvider);\n      return ret;\n    } else {\n      int threads = 0;\n      final ExecutorService ex = (random.nextBoolean()) ? null\n          : Executors.newFixedThreadPool(threads = _TestUtil.nextInt(random, 1, 8),\n                      new NamedThreadFactory(\"LuceneTestCase\"));\n      if (ex != null && VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n      }\n      IndexSearcher ret = random.nextBoolean() ? \n        new AssertingIndexSearcher(random, r, ex) {\n          @Override\n          public void close() throws IOException {\n            super.close();\n            shutdownExecutorService(ex);\n          }\n        } : new AssertingIndexSearcher(random, r.getTopReaderContext(), ex) {\n          @Override\n          public void close() throws IOException {\n            super.close();\n            shutdownExecutorService(ex);\n          }\n        };\n      ret.setSimilarityProvider(similarityProvider);\n      return ret;\n    }\n  }\n\n","sourceOld":"  /** create a new searcher over the reader.\n   * This searcher might randomly use threads.\n   * if <code>maybeWrap</code> is true, this searcher might wrap the reader\n   * with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n    if (random.nextBoolean()) {\n      if (maybeWrap && rarely()) {\n        r = new SlowMultiReaderWrapper(r);\n      }\n      IndexSearcher ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getTopReaderContext());\n      ret.setSimilarityProvider(similarityProvider);\n      return ret;\n    } else {\n      int threads = 0;\n      final ExecutorService ex = (random.nextBoolean()) ? null\n          : Executors.newFixedThreadPool(threads = _TestUtil.nextInt(random, 1, 8),\n                      new NamedThreadFactory(\"LuceneTestCase\"));\n      if (ex != null && VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n      }\n      IndexSearcher ret = random.nextBoolean() ? \n        new AssertingIndexSearcher(random, r, ex) {\n          @Override\n          public void close() throws IOException {\n            super.close();\n            shutdownExecutorService(ex);\n          }\n        } : new AssertingIndexSearcher(random, r.getTopReaderContext(), ex) {\n          @Override\n          public void close() throws IOException {\n            super.close();\n            shutdownExecutorService(ex);\n          }\n        };\n      ret.setSimilarityProvider(similarityProvider);\n      return ret;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655":["79c2cb24929f2649a8875fb629086171f914d5ce","0762b640e0d0d12b6edb96db68986e13145c3484"],"ff6fd241dc6610f7f81b62e3ba4cedf105939623":["9d3c12b2df00ba96fed86d45277197bc4d09f084"],"5c698c0cb88bac4bcd36a1b1001a0c6a2163ea2a":["135621f3a0670a9394eb563224a3b76cc4dddc0f","9d3c12b2df00ba96fed86d45277197bc4d09f084"],"6620df8541b174097b1133a4fc370adb2e570524":["60e3b31201fd9bb5d73884faa5a38c63ea9239f2"],"0762b640e0d0d12b6edb96db68986e13145c3484":["ff6fd241dc6610f7f81b62e3ba4cedf105939623"],"9d3c12b2df00ba96fed86d45277197bc4d09f084":["b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"60e3b31201fd9bb5d73884faa5a38c63ea9239f2":["6f7fee42303a18cc146043c96f66491311b345d9"],"b3e06be49006ecac364d39d12b9c9f74882f9b9f":["c1bb50752d43a65ef1b623eabdb8e865983d3cd6","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c1bb50752d43a65ef1b623eabdb8e865983d3cd6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0a2903ea38ae3e636b93a08c52a5e37ae939cf6b":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","6f7fee42303a18cc146043c96f66491311b345d9"],"7b91922b55d15444d554721b352861d028eb8278":["6620df8541b174097b1133a4fc370adb2e570524"],"6f7fee42303a18cc146043c96f66491311b345d9":["0762b640e0d0d12b6edb96db68986e13145c3484"],"79c2cb24929f2649a8875fb629086171f914d5ce":["a3776dccca01c11e7046323cfad46a3b4a471233","ff6fd241dc6610f7f81b62e3ba4cedf105939623"],"a3776dccca01c11e7046323cfad46a3b4a471233":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","9d3c12b2df00ba96fed86d45277197bc4d09f084"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"77cf4379b2824f6ea34b091c495d6e95c38ff9e2":["5c698c0cb88bac4bcd36a1b1001a0c6a2163ea2a","0762b640e0d0d12b6edb96db68986e13145c3484"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7b91922b55d15444d554721b352861d028eb8278"]},"commit2Childs":{"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655":["0a2903ea38ae3e636b93a08c52a5e37ae939cf6b"],"ff6fd241dc6610f7f81b62e3ba4cedf105939623":["0762b640e0d0d12b6edb96db68986e13145c3484","79c2cb24929f2649a8875fb629086171f914d5ce"],"5c698c0cb88bac4bcd36a1b1001a0c6a2163ea2a":["77cf4379b2824f6ea34b091c495d6e95c38ff9e2"],"6620df8541b174097b1133a4fc370adb2e570524":["7b91922b55d15444d554721b352861d028eb8278"],"0762b640e0d0d12b6edb96db68986e13145c3484":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","6f7fee42303a18cc146043c96f66491311b345d9","77cf4379b2824f6ea34b091c495d6e95c38ff9e2"],"9d3c12b2df00ba96fed86d45277197bc4d09f084":["ff6fd241dc6610f7f81b62e3ba4cedf105939623","5c698c0cb88bac4bcd36a1b1001a0c6a2163ea2a","a3776dccca01c11e7046323cfad46a3b4a471233"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":["5c698c0cb88bac4bcd36a1b1001a0c6a2163ea2a"],"60e3b31201fd9bb5d73884faa5a38c63ea9239f2":["6620df8541b174097b1133a4fc370adb2e570524"],"b3e06be49006ecac364d39d12b9c9f74882f9b9f":["9d3c12b2df00ba96fed86d45277197bc4d09f084","135621f3a0670a9394eb563224a3b76cc4dddc0f"],"c1bb50752d43a65ef1b623eabdb8e865983d3cd6":["b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"0a2903ea38ae3e636b93a08c52a5e37ae939cf6b":[],"6f7fee42303a18cc146043c96f66491311b345d9":["60e3b31201fd9bb5d73884faa5a38c63ea9239f2","0a2903ea38ae3e636b93a08c52a5e37ae939cf6b"],"7b91922b55d15444d554721b352861d028eb8278":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"79c2cb24929f2649a8875fb629086171f914d5ce":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655"],"a3776dccca01c11e7046323cfad46a3b4a471233":["79c2cb24929f2649a8875fb629086171f914d5ce"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["135621f3a0670a9394eb563224a3b76cc4dddc0f","b3e06be49006ecac364d39d12b9c9f74882f9b9f","c1bb50752d43a65ef1b623eabdb8e865983d3cd6","a3776dccca01c11e7046323cfad46a3b4a471233"],"77cf4379b2824f6ea34b091c495d6e95c38ff9e2":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["0a2903ea38ae3e636b93a08c52a5e37ae939cf6b","77cf4379b2824f6ea34b091c495d6e95c38ff9e2","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}