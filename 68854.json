{"path":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#findLargestNonPendingWriter().mjava","commits":[{"id":"ad4be95c403f45330d2a078afc9b6fab4515c8ce","date":1512064647,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#findLargestNonPendingWriter().mjava","pathOld":"/dev/null","sourceNew":"  ThreadState findLargestNonPendingWriter() {\n    ThreadState maxRamUsingThreadState = null;\n    long maxRamSoFar = 0;\n    Iterator<ThreadState> activePerThreadsIterator = allActiveThreadStates();\n    int count = 0;\n    while (activePerThreadsIterator.hasNext()) {\n      ThreadState next = activePerThreadsIterator.next();\n      if (!next.flushPending) {\n        final long nextRam = next.bytesUsed;\n        if (nextRam > 0 && next.dwpt.getNumDocsInRAM() > 0) {\n          if (infoStream.isEnabled(\"FP\")) {\n            infoStream.message(\"FP\", \"thread state has \" + nextRam + \" bytes; docInRAM=\" + next.dwpt.getNumDocsInRAM());\n          }\n          count++;\n          if (nextRam > maxRamSoFar) {\n            maxRamSoFar = nextRam;\n            maxRamUsingThreadState = next;\n          }\n        }\n      }\n    }\n    if (infoStream.isEnabled(\"FP\")) {\n      infoStream.message(\"FP\", count + \" in-use non-flushing threads states\");\n    }\n    return maxRamUsingThreadState;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["dd3df3a341270867c206c9cc74eb53d27d0f47bb"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1aad05eeff7818b0833c02ac6b743aa72054963b","date":1512093122,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#findLargestNonPendingWriter().mjava","pathOld":"/dev/null","sourceNew":"  ThreadState findLargestNonPendingWriter() {\n    ThreadState maxRamUsingThreadState = null;\n    long maxRamSoFar = 0;\n    Iterator<ThreadState> activePerThreadsIterator = allActiveThreadStates();\n    int count = 0;\n    while (activePerThreadsIterator.hasNext()) {\n      ThreadState next = activePerThreadsIterator.next();\n      if (!next.flushPending) {\n        final long nextRam = next.bytesUsed;\n        if (nextRam > 0 && next.dwpt.getNumDocsInRAM() > 0) {\n          if (infoStream.isEnabled(\"FP\")) {\n            infoStream.message(\"FP\", \"thread state has \" + nextRam + \" bytes; docInRAM=\" + next.dwpt.getNumDocsInRAM());\n          }\n          count++;\n          if (nextRam > maxRamSoFar) {\n            maxRamSoFar = nextRam;\n            maxRamUsingThreadState = next;\n          }\n        }\n      }\n    }\n    if (infoStream.isEnabled(\"FP\")) {\n      infoStream.message(\"FP\", count + \" in-use non-flushing threads states\");\n    }\n    return maxRamUsingThreadState;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"dd3df3a341270867c206c9cc74eb53d27d0f47bb","date":1512999962,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#findLargestNonPendingWriter().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#findLargestNonPendingWriter().mjava","sourceNew":"  synchronized ThreadState findLargestNonPendingWriter() {\n    ThreadState maxRamUsingThreadState = null;\n    long maxRamSoFar = 0;\n    Iterator<ThreadState> activePerThreadsIterator = allActiveThreadStates();\n    int count = 0;\n    while (activePerThreadsIterator.hasNext()) {\n      ThreadState next = activePerThreadsIterator.next();\n      if (!next.flushPending) {\n        final long nextRam = next.bytesUsed;\n        if (nextRam > 0 && next.dwpt.getNumDocsInRAM() > 0) {\n          if (infoStream.isEnabled(\"FP\")) {\n            infoStream.message(\"FP\", \"thread state has \" + nextRam + \" bytes; docInRAM=\" + next.dwpt.getNumDocsInRAM());\n          }\n          count++;\n          if (nextRam > maxRamSoFar) {\n            maxRamSoFar = nextRam;\n            maxRamUsingThreadState = next;\n          }\n        }\n      }\n    }\n    if (infoStream.isEnabled(\"FP\")) {\n      infoStream.message(\"FP\", count + \" in-use non-flushing threads states\");\n    }\n    return maxRamUsingThreadState;\n  }\n\n","sourceOld":"  ThreadState findLargestNonPendingWriter() {\n    ThreadState maxRamUsingThreadState = null;\n    long maxRamSoFar = 0;\n    Iterator<ThreadState> activePerThreadsIterator = allActiveThreadStates();\n    int count = 0;\n    while (activePerThreadsIterator.hasNext()) {\n      ThreadState next = activePerThreadsIterator.next();\n      if (!next.flushPending) {\n        final long nextRam = next.bytesUsed;\n        if (nextRam > 0 && next.dwpt.getNumDocsInRAM() > 0) {\n          if (infoStream.isEnabled(\"FP\")) {\n            infoStream.message(\"FP\", \"thread state has \" + nextRam + \" bytes; docInRAM=\" + next.dwpt.getNumDocsInRAM());\n          }\n          count++;\n          if (nextRam > maxRamSoFar) {\n            maxRamSoFar = nextRam;\n            maxRamUsingThreadState = next;\n          }\n        }\n      }\n    }\n    if (infoStream.isEnabled(\"FP\")) {\n      infoStream.message(\"FP\", count + \" in-use non-flushing threads states\");\n    }\n    return maxRamUsingThreadState;\n  }\n\n","bugFix":["ad4be95c403f45330d2a078afc9b6fab4515c8ce"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"927e6deec13723e5fd6fb8f1e0457e8597dae15e","date":1513167013,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#findLargestNonPendingWriter().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#findLargestNonPendingWriter().mjava","sourceNew":"  synchronized ThreadState findLargestNonPendingWriter() {\n    ThreadState maxRamUsingThreadState = null;\n    long maxRamSoFar = 0;\n    Iterator<ThreadState> activePerThreadsIterator = allActiveThreadStates();\n    int count = 0;\n    while (activePerThreadsIterator.hasNext()) {\n      ThreadState next = activePerThreadsIterator.next();\n      if (!next.flushPending) {\n        final long nextRam = next.bytesUsed;\n        if (nextRam > 0 && next.dwpt.getNumDocsInRAM() > 0) {\n          if (infoStream.isEnabled(\"FP\")) {\n            infoStream.message(\"FP\", \"thread state has \" + nextRam + \" bytes; docInRAM=\" + next.dwpt.getNumDocsInRAM());\n          }\n          count++;\n          if (nextRam > maxRamSoFar) {\n            maxRamSoFar = nextRam;\n            maxRamUsingThreadState = next;\n          }\n        }\n      }\n    }\n    if (infoStream.isEnabled(\"FP\")) {\n      infoStream.message(\"FP\", count + \" in-use non-flushing threads states\");\n    }\n    return maxRamUsingThreadState;\n  }\n\n","sourceOld":"  ThreadState findLargestNonPendingWriter() {\n    ThreadState maxRamUsingThreadState = null;\n    long maxRamSoFar = 0;\n    Iterator<ThreadState> activePerThreadsIterator = allActiveThreadStates();\n    int count = 0;\n    while (activePerThreadsIterator.hasNext()) {\n      ThreadState next = activePerThreadsIterator.next();\n      if (!next.flushPending) {\n        final long nextRam = next.bytesUsed;\n        if (nextRam > 0 && next.dwpt.getNumDocsInRAM() > 0) {\n          if (infoStream.isEnabled(\"FP\")) {\n            infoStream.message(\"FP\", \"thread state has \" + nextRam + \" bytes; docInRAM=\" + next.dwpt.getNumDocsInRAM());\n          }\n          count++;\n          if (nextRam > maxRamSoFar) {\n            maxRamSoFar = nextRam;\n            maxRamUsingThreadState = next;\n          }\n        }\n      }\n    }\n    if (infoStream.isEnabled(\"FP\")) {\n      infoStream.message(\"FP\", count + \" in-use non-flushing threads states\");\n    }\n    return maxRamUsingThreadState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"264935965977b4a9e2f3920420647072c9c49176","date":1586600626,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#findLargestNonPendingWriter().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#findLargestNonPendingWriter().mjava","sourceNew":"  synchronized DocumentsWriterPerThread findLargestNonPendingWriter() {\n    DocumentsWriterPerThread maxRamUsingWriter = null;\n    long maxRamSoFar = 0;\n    int count = 0;\n    for (DocumentsWriterPerThread next : perThreadPool) {\n      if (next.isFlushPending() == false && next.getNumDocsInRAM() > 0) {\n        final long nextRam = next.bytesUsed();\n        if (infoStream.isEnabled(\"FP\")) {\n          infoStream.message(\"FP\", \"thread state has \" + nextRam + \" bytes; docInRAM=\" + next.getNumDocsInRAM());\n        }\n        count++;\n        if (nextRam > maxRamSoFar) {\n          maxRamSoFar = nextRam;\n          maxRamUsingWriter = next;\n        }\n      }\n    }\n    if (infoStream.isEnabled(\"FP\")) {\n      infoStream.message(\"FP\", count + \" in-use non-flushing threads states\");\n    }\n    return maxRamUsingWriter;\n  }\n\n","sourceOld":"  synchronized ThreadState findLargestNonPendingWriter() {\n    ThreadState maxRamUsingThreadState = null;\n    long maxRamSoFar = 0;\n    Iterator<ThreadState> activePerThreadsIterator = allActiveThreadStates();\n    int count = 0;\n    while (activePerThreadsIterator.hasNext()) {\n      ThreadState next = activePerThreadsIterator.next();\n      if (!next.flushPending) {\n        final long nextRam = next.bytesUsed;\n        if (nextRam > 0 && next.dwpt.getNumDocsInRAM() > 0) {\n          if (infoStream.isEnabled(\"FP\")) {\n            infoStream.message(\"FP\", \"thread state has \" + nextRam + \" bytes; docInRAM=\" + next.dwpt.getNumDocsInRAM());\n          }\n          count++;\n          if (nextRam > maxRamSoFar) {\n            maxRamSoFar = nextRam;\n            maxRamUsingThreadState = next;\n          }\n        }\n      }\n    }\n    if (infoStream.isEnabled(\"FP\")) {\n      infoStream.message(\"FP\", count + \" in-use non-flushing threads states\");\n    }\n    return maxRamUsingThreadState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6926606ec5e0dd8d4ec79166d39a3b4ddb862bf4","date":1599581893,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#findLargestNonPendingWriter().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#findLargestNonPendingWriter().mjava","sourceNew":"  synchronized DocumentsWriterPerThread findLargestNonPendingWriter() {\n    DocumentsWriterPerThread maxRamUsingWriter = null;\n    long maxRamSoFar = 0;\n    int count = 0;\n    for (DocumentsWriterPerThread next : perThreadPool) {\n      if (next.isFlushPending() == false && next.getNumDocsInRAM() > 0) {\n        final long nextRam = next.ramBytesUsed();\n        if (infoStream.isEnabled(\"FP\")) {\n          infoStream.message(\"FP\", \"thread state has \" + nextRam + \" bytes; docInRAM=\" + next.getNumDocsInRAM());\n        }\n        count++;\n        if (nextRam > maxRamSoFar) {\n          maxRamSoFar = nextRam;\n          maxRamUsingWriter = next;\n        }\n      }\n    }\n    if (infoStream.isEnabled(\"FP\")) {\n      infoStream.message(\"FP\", count + \" in-use non-flushing threads states\");\n    }\n    return maxRamUsingWriter;\n  }\n\n","sourceOld":"  synchronized DocumentsWriterPerThread findLargestNonPendingWriter() {\n    DocumentsWriterPerThread maxRamUsingWriter = null;\n    long maxRamSoFar = 0;\n    int count = 0;\n    for (DocumentsWriterPerThread next : perThreadPool) {\n      if (next.isFlushPending() == false && next.getNumDocsInRAM() > 0) {\n        final long nextRam = next.bytesUsed();\n        if (infoStream.isEnabled(\"FP\")) {\n          infoStream.message(\"FP\", \"thread state has \" + nextRam + \" bytes; docInRAM=\" + next.getNumDocsInRAM());\n        }\n        count++;\n        if (nextRam > maxRamSoFar) {\n          maxRamSoFar = nextRam;\n          maxRamUsingWriter = next;\n        }\n      }\n    }\n    if (infoStream.isEnabled(\"FP\")) {\n      infoStream.message(\"FP\", count + \" in-use non-flushing threads states\");\n    }\n    return maxRamUsingWriter;\n  }\n\n","bugFix":null,"bugIntro":["3a1e047b18d79d7214c04b78dfa1c3e14f639425"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3a1e047b18d79d7214c04b78dfa1c3e14f639425","date":1600444745,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#findLargestNonPendingWriter().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#findLargestNonPendingWriter().mjava","sourceNew":"  synchronized DocumentsWriterPerThread findLargestNonPendingWriter() {\n    DocumentsWriterPerThread maxRamUsingWriter = null;\n    long maxRamSoFar = 0;\n    int count = 0;\n    for (DocumentsWriterPerThread next : perThreadPool) {\n      if (next.isFlushPending() == false && next.getNumDocsInRAM() > 0) {\n        final long nextRam = next.getLastCommittedBytesUsed();\n        if (infoStream.isEnabled(\"FP\")) {\n          infoStream.message(\"FP\", \"thread state has \" + nextRam + \" bytes; docInRAM=\" + next.getNumDocsInRAM());\n        }\n        count++;\n        if (nextRam > maxRamSoFar) {\n          maxRamSoFar = nextRam;\n          maxRamUsingWriter = next;\n        }\n      }\n    }\n    if (infoStream.isEnabled(\"FP\")) {\n      infoStream.message(\"FP\", count + \" in-use non-flushing threads states\");\n    }\n    return maxRamUsingWriter;\n  }\n\n","sourceOld":"  synchronized DocumentsWriterPerThread findLargestNonPendingWriter() {\n    DocumentsWriterPerThread maxRamUsingWriter = null;\n    long maxRamSoFar = 0;\n    int count = 0;\n    for (DocumentsWriterPerThread next : perThreadPool) {\n      if (next.isFlushPending() == false && next.getNumDocsInRAM() > 0) {\n        final long nextRam = next.ramBytesUsed();\n        if (infoStream.isEnabled(\"FP\")) {\n          infoStream.message(\"FP\", \"thread state has \" + nextRam + \" bytes; docInRAM=\" + next.getNumDocsInRAM());\n        }\n        count++;\n        if (nextRam > maxRamSoFar) {\n          maxRamSoFar = nextRam;\n          maxRamUsingWriter = next;\n        }\n      }\n    }\n    if (infoStream.isEnabled(\"FP\")) {\n      infoStream.message(\"FP\", count + \" in-use non-flushing threads states\");\n    }\n    return maxRamUsingWriter;\n  }\n\n","bugFix":["6926606ec5e0dd8d4ec79166d39a3b4ddb862bf4"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6926606ec5e0dd8d4ec79166d39a3b4ddb862bf4":["264935965977b4a9e2f3920420647072c9c49176"],"264935965977b4a9e2f3920420647072c9c49176":["927e6deec13723e5fd6fb8f1e0457e8597dae15e"],"1aad05eeff7818b0833c02ac6b743aa72054963b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ad4be95c403f45330d2a078afc9b6fab4515c8ce"],"dd3df3a341270867c206c9cc74eb53d27d0f47bb":["1aad05eeff7818b0833c02ac6b743aa72054963b"],"3a1e047b18d79d7214c04b78dfa1c3e14f639425":["6926606ec5e0dd8d4ec79166d39a3b4ddb862bf4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ad4be95c403f45330d2a078afc9b6fab4515c8ce":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"927e6deec13723e5fd6fb8f1e0457e8597dae15e":["1aad05eeff7818b0833c02ac6b743aa72054963b","dd3df3a341270867c206c9cc74eb53d27d0f47bb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a1e047b18d79d7214c04b78dfa1c3e14f639425"]},"commit2Childs":{"6926606ec5e0dd8d4ec79166d39a3b4ddb862bf4":["3a1e047b18d79d7214c04b78dfa1c3e14f639425"],"264935965977b4a9e2f3920420647072c9c49176":["6926606ec5e0dd8d4ec79166d39a3b4ddb862bf4"],"1aad05eeff7818b0833c02ac6b743aa72054963b":["dd3df3a341270867c206c9cc74eb53d27d0f47bb","927e6deec13723e5fd6fb8f1e0457e8597dae15e"],"dd3df3a341270867c206c9cc74eb53d27d0f47bb":["927e6deec13723e5fd6fb8f1e0457e8597dae15e"],"3a1e047b18d79d7214c04b78dfa1c3e14f639425":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1aad05eeff7818b0833c02ac6b743aa72054963b","ad4be95c403f45330d2a078afc9b6fab4515c8ce"],"ad4be95c403f45330d2a078afc9b6fab4515c8ce":["1aad05eeff7818b0833c02ac6b743aa72054963b"],"927e6deec13723e5fd6fb8f1e0457e8597dae15e":["264935965977b4a9e2f3920420647072c9c49176"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}