{"path":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#analyzeGraphBoolean(String,TokenStream,BooleanClause.Occur).mjava","commits":[{"id":"7e0d75d7d3cda2b33e79d0eb0e716169cebec4db","date":1486463279,"type":0,"author":"Jim Ferenczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#analyzeGraphBoolean(String,TokenStream,BooleanClause.Occur).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Creates a boolean query from a graph token stream. The articulation points of the graph are visited in order and the queries\n   * created at each point are merged in the returned boolean query.\n   */\n  protected Query analyzeGraphBoolean(String field, TokenStream source, BooleanClause.Occur operator) throws IOException {\n    source.reset();\n    GraphTokenStreamFiniteStrings graph = new GraphTokenStreamFiniteStrings(source);\n    BooleanQuery.Builder builder = new BooleanQuery.Builder();\n    int[] articulationPoints = graph.articulationPoints();\n    int lastState = 0;\n    for (int i = 0; i <= articulationPoints.length; i++) {\n      int start = lastState;\n      int end = -1;\n      if (i < articulationPoints.length) {\n        end = articulationPoints[i];\n      }\n      lastState = end;\n      final Query queryPos;\n      if (graph.hasSidePath(start)) {\n        List<Query> queries = new ArrayList<> ();\n        Iterator<TokenStream> it = graph.getFiniteStrings(start, end);\n        while (it.hasNext()) {\n          TokenStream ts = it.next();\n          // This is a synonym path so all terms are mandatory (MUST).\n          Query q = createFieldQuery(ts, BooleanClause.Occur.MUST, field, getAutoGenerateMultiTermSynonymsPhraseQuery(), 0);\n          if (q != null) {\n            queries.add(q);\n          }\n        }\n        if (queries.size() > 0) {\n          queryPos = newGraphSynonymQuery(queries.toArray(new Query[queries.size()]));\n        } else {\n          queryPos = null;\n        }\n      } else {\n        Term[] terms = graph.getTerms(field, start);\n        assert terms.length > 0;\n        if (terms.length == 1) {\n          queryPos = newTermQuery(terms[0]);\n        } else {\n          queryPos = newSynonymQuery(terms);\n        }\n      }\n      if (queryPos != null) {\n        builder.add(queryPos, operator);\n      }\n    }\n    BooleanQuery bq =  builder.build();\n    if (bq.clauses().size() == 1) {\n      return bq.clauses().get(0).getQuery();\n    }\n    return bq;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["8d5f9da379ac10a8ebcbf30e00314c561652932b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6d44a067741cef02c3637ee610da1e8d6d30632e","date":1489762401,"type":3,"author":"Jim Ferenczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#analyzeGraphBoolean(String,TokenStream,BooleanClause.Occur).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#analyzeGraphBoolean(String,TokenStream,BooleanClause.Occur).mjava","sourceNew":"  /**\n   * Creates a boolean query from a graph token stream. The articulation points of the graph are visited in order and the queries\n   * created at each point are merged in the returned boolean query.\n   */\n  protected Query analyzeGraphBoolean(String field, TokenStream source, BooleanClause.Occur operator) throws IOException {\n    source.reset();\n    GraphTokenStreamFiniteStrings graph = new GraphTokenStreamFiniteStrings(source);\n    BooleanQuery.Builder builder = new BooleanQuery.Builder();\n    int[] articulationPoints = graph.articulationPoints();\n    int lastState = 0;\n    for (int i = 0; i <= articulationPoints.length; i++) {\n      int start = lastState;\n      int end = -1;\n      if (i < articulationPoints.length) {\n        end = articulationPoints[i];\n      }\n      lastState = end;\n      final Query queryPos;\n      if (graph.hasSidePath(start)) {\n        final Iterator<TokenStream> it = graph.getFiniteStrings(start, end);\n        Iterator<Query> queries = new Iterator<Query>() {\n          @Override\n          public boolean hasNext() {\n            return it.hasNext();\n          }\n\n          @Override\n          public Query next() {\n            TokenStream ts = it.next();\n            return createFieldQuery(ts, BooleanClause.Occur.MUST, field, getAutoGenerateMultiTermSynonymsPhraseQuery(), 0);\n          }\n        };\n        queryPos = newGraphSynonymQuery(queries);\n      } else {\n        Term[] terms = graph.getTerms(field, start);\n        assert terms.length > 0;\n        if (terms.length == 1) {\n          queryPos = newTermQuery(terms[0]);\n        } else {\n          queryPos = newSynonymQuery(terms);\n        }\n      }\n      if (queryPos != null) {\n        builder.add(queryPos, operator);\n      }\n    }\n    BooleanQuery bq =  builder.build();\n    if (bq.clauses().size() == 1) {\n      return bq.clauses().get(0).getQuery();\n    }\n    return bq;\n  }\n\n","sourceOld":"  /**\n   * Creates a boolean query from a graph token stream. The articulation points of the graph are visited in order and the queries\n   * created at each point are merged in the returned boolean query.\n   */\n  protected Query analyzeGraphBoolean(String field, TokenStream source, BooleanClause.Occur operator) throws IOException {\n    source.reset();\n    GraphTokenStreamFiniteStrings graph = new GraphTokenStreamFiniteStrings(source);\n    BooleanQuery.Builder builder = new BooleanQuery.Builder();\n    int[] articulationPoints = graph.articulationPoints();\n    int lastState = 0;\n    for (int i = 0; i <= articulationPoints.length; i++) {\n      int start = lastState;\n      int end = -1;\n      if (i < articulationPoints.length) {\n        end = articulationPoints[i];\n      }\n      lastState = end;\n      final Query queryPos;\n      if (graph.hasSidePath(start)) {\n        List<Query> queries = new ArrayList<> ();\n        Iterator<TokenStream> it = graph.getFiniteStrings(start, end);\n        while (it.hasNext()) {\n          TokenStream ts = it.next();\n          // This is a synonym path so all terms are mandatory (MUST).\n          Query q = createFieldQuery(ts, BooleanClause.Occur.MUST, field, getAutoGenerateMultiTermSynonymsPhraseQuery(), 0);\n          if (q != null) {\n            queries.add(q);\n          }\n        }\n        if (queries.size() > 0) {\n          queryPos = newGraphSynonymQuery(queries.toArray(new Query[queries.size()]));\n        } else {\n          queryPos = null;\n        }\n      } else {\n        Term[] terms = graph.getTerms(field, start);\n        assert terms.length > 0;\n        if (terms.length == 1) {\n          queryPos = newTermQuery(terms[0]);\n        } else {\n          queryPos = newSynonymQuery(terms);\n        }\n      }\n      if (queryPos != null) {\n        builder.add(queryPos, operator);\n      }\n    }\n    BooleanQuery bq =  builder.build();\n    if (bq.clauses().size() == 1) {\n      return bq.clauses().get(0).getQuery();\n    }\n    return bq;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5b2e16c9b5fb24bd926f6d6cfcf14967f0f1c52b","date":1490280010,"type":3,"author":"Jim Ferenczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#analyzeGraphBoolean(String,TokenStream,BooleanClause.Occur).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#analyzeGraphBoolean(String,TokenStream,BooleanClause.Occur).mjava","sourceNew":"  /**\n   * Creates a boolean query from a graph token stream. The articulation points of the graph are visited in order and the queries\n   * created at each point are merged in the returned boolean query.\n   */\n  protected Query analyzeGraphBoolean(String field, TokenStream source, BooleanClause.Occur operator) throws IOException {\n    source.reset();\n    GraphTokenStreamFiniteStrings graph = new GraphTokenStreamFiniteStrings(source);\n    BooleanQuery.Builder builder = new BooleanQuery.Builder();\n    int[] articulationPoints = graph.articulationPoints();\n    int lastState = 0;\n    for (int i = 0; i <= articulationPoints.length; i++) {\n      int start = lastState;\n      int end = -1;\n      if (i < articulationPoints.length) {\n        end = articulationPoints[i];\n      }\n      lastState = end;\n      final Query queryPos;\n      if (graph.hasSidePath(start)) {\n        final Iterator<TokenStream> it = graph.getFiniteStrings(start, end);\n        Iterator<Query> queries = new Iterator<Query>() {\n          @Override\n          public boolean hasNext() {\n            return it.hasNext();\n          }\n\n          @Override\n          public Query next() {\n            TokenStream ts = it.next();\n            return createFieldQuery(ts, BooleanClause.Occur.MUST, field, getAutoGenerateMultiTermSynonymsPhraseQuery(), 0);\n          }\n        };\n        queryPos = newGraphSynonymQuery(queries);\n      } else {\n        Term[] terms = graph.getTerms(field, start);\n        assert terms.length > 0;\n        if (terms.length == 1) {\n          queryPos = newTermQuery(terms[0]);\n        } else {\n          queryPos = newSynonymQuery(terms);\n        }\n      }\n      if (queryPos != null) {\n        builder.add(queryPos, operator);\n      }\n    }\n    BooleanQuery bq =  builder.build();\n    if (bq.clauses().size() == 1) {\n      return bq.clauses().get(0).getQuery();\n    }\n    return bq;\n  }\n\n","sourceOld":"  /**\n   * Creates a boolean query from a graph token stream. The articulation points of the graph are visited in order and the queries\n   * created at each point are merged in the returned boolean query.\n   */\n  protected Query analyzeGraphBoolean(String field, TokenStream source, BooleanClause.Occur operator) throws IOException {\n    source.reset();\n    GraphTokenStreamFiniteStrings graph = new GraphTokenStreamFiniteStrings(source);\n    BooleanQuery.Builder builder = new BooleanQuery.Builder();\n    int[] articulationPoints = graph.articulationPoints();\n    int lastState = 0;\n    for (int i = 0; i <= articulationPoints.length; i++) {\n      int start = lastState;\n      int end = -1;\n      if (i < articulationPoints.length) {\n        end = articulationPoints[i];\n      }\n      lastState = end;\n      final Query queryPos;\n      if (graph.hasSidePath(start)) {\n        List<Query> queries = new ArrayList<> ();\n        Iterator<TokenStream> it = graph.getFiniteStrings(start, end);\n        while (it.hasNext()) {\n          TokenStream ts = it.next();\n          // This is a synonym path so all terms are mandatory (MUST).\n          Query q = createFieldQuery(ts, BooleanClause.Occur.MUST, field, getAutoGenerateMultiTermSynonymsPhraseQuery(), 0);\n          if (q != null) {\n            queries.add(q);\n          }\n        }\n        if (queries.size() > 0) {\n          queryPos = newGraphSynonymQuery(queries.toArray(new Query[queries.size()]));\n        } else {\n          queryPos = null;\n        }\n      } else {\n        Term[] terms = graph.getTerms(field, start);\n        assert terms.length > 0;\n        if (terms.length == 1) {\n          queryPos = newTermQuery(terms[0]);\n        } else {\n          queryPos = newSynonymQuery(terms);\n        }\n      }\n      if (queryPos != null) {\n        builder.add(queryPos, operator);\n      }\n    }\n    BooleanQuery bq =  builder.build();\n    if (bq.clauses().size() == 1) {\n      return bq.clauses().get(0).getQuery();\n    }\n    return bq;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8d5f9da379ac10a8ebcbf30e00314c561652932b","date":1497616966,"type":3,"author":"Jim Ferenczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#analyzeGraphBoolean(String,TokenStream,BooleanClause.Occur).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#analyzeGraphBoolean(String,TokenStream,BooleanClause.Occur).mjava","sourceNew":"  /**\n   * Creates a boolean query from a graph token stream. The articulation points of the graph are visited in order and the queries\n   * created at each point are merged in the returned boolean query.\n   */\n  protected Query analyzeGraphBoolean(String field, TokenStream source, BooleanClause.Occur operator) throws IOException {\n    source.reset();\n    GraphTokenStreamFiniteStrings graph = new GraphTokenStreamFiniteStrings(source);\n    BooleanQuery.Builder builder = new BooleanQuery.Builder();\n    int[] articulationPoints = graph.articulationPoints();\n    int lastState = 0;\n    for (int i = 0; i <= articulationPoints.length; i++) {\n      int start = lastState;\n      int end = -1;\n      if (i < articulationPoints.length) {\n        end = articulationPoints[i];\n      }\n      lastState = end;\n      final Query queryPos;\n      if (graph.hasSidePath(start)) {\n        final Iterator<TokenStream> it = graph.getFiniteStrings(start, end);\n        Iterator<Query> queries = new Iterator<Query>() {\n          @Override\n          public boolean hasNext() {\n            return it.hasNext();\n          }\n\n          @Override\n          public Query next() {\n            TokenStream ts = it.next();\n            return createFieldQuery(ts, BooleanClause.Occur.MUST, field, getAutoGenerateMultiTermSynonymsPhraseQuery(), 0);\n          }\n        };\n        queryPos = newGraphSynonymQuery(queries);\n      } else {\n        Term[] terms = graph.getTerms(field, start);\n        assert terms.length > 0;\n        if (terms.length == 1) {\n          queryPos = newTermQuery(terms[0]);\n        } else {\n          queryPos = newSynonymQuery(terms);\n        }\n      }\n      if (queryPos != null) {\n        builder.add(queryPos, operator);\n      }\n    }\n    return builder.build();\n  }\n\n","sourceOld":"  /**\n   * Creates a boolean query from a graph token stream. The articulation points of the graph are visited in order and the queries\n   * created at each point are merged in the returned boolean query.\n   */\n  protected Query analyzeGraphBoolean(String field, TokenStream source, BooleanClause.Occur operator) throws IOException {\n    source.reset();\n    GraphTokenStreamFiniteStrings graph = new GraphTokenStreamFiniteStrings(source);\n    BooleanQuery.Builder builder = new BooleanQuery.Builder();\n    int[] articulationPoints = graph.articulationPoints();\n    int lastState = 0;\n    for (int i = 0; i <= articulationPoints.length; i++) {\n      int start = lastState;\n      int end = -1;\n      if (i < articulationPoints.length) {\n        end = articulationPoints[i];\n      }\n      lastState = end;\n      final Query queryPos;\n      if (graph.hasSidePath(start)) {\n        final Iterator<TokenStream> it = graph.getFiniteStrings(start, end);\n        Iterator<Query> queries = new Iterator<Query>() {\n          @Override\n          public boolean hasNext() {\n            return it.hasNext();\n          }\n\n          @Override\n          public Query next() {\n            TokenStream ts = it.next();\n            return createFieldQuery(ts, BooleanClause.Occur.MUST, field, getAutoGenerateMultiTermSynonymsPhraseQuery(), 0);\n          }\n        };\n        queryPos = newGraphSynonymQuery(queries);\n      } else {\n        Term[] terms = graph.getTerms(field, start);\n        assert terms.length > 0;\n        if (terms.length == 1) {\n          queryPos = newTermQuery(terms[0]);\n        } else {\n          queryPos = newSynonymQuery(terms);\n        }\n      }\n      if (queryPos != null) {\n        builder.add(queryPos, operator);\n      }\n    }\n    BooleanQuery bq =  builder.build();\n    if (bq.clauses().size() == 1) {\n      return bq.clauses().get(0).getQuery();\n    }\n    return bq;\n  }\n\n","bugFix":["7e0d75d7d3cda2b33e79d0eb0e716169cebec4db"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","date":1498028748,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#analyzeGraphBoolean(String,TokenStream,BooleanClause.Occur).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#analyzeGraphBoolean(String,TokenStream,BooleanClause.Occur).mjava","sourceNew":"  /**\n   * Creates a boolean query from a graph token stream. The articulation points of the graph are visited in order and the queries\n   * created at each point are merged in the returned boolean query.\n   */\n  protected Query analyzeGraphBoolean(String field, TokenStream source, BooleanClause.Occur operator) throws IOException {\n    source.reset();\n    GraphTokenStreamFiniteStrings graph = new GraphTokenStreamFiniteStrings(source);\n    BooleanQuery.Builder builder = new BooleanQuery.Builder();\n    int[] articulationPoints = graph.articulationPoints();\n    int lastState = 0;\n    for (int i = 0; i <= articulationPoints.length; i++) {\n      int start = lastState;\n      int end = -1;\n      if (i < articulationPoints.length) {\n        end = articulationPoints[i];\n      }\n      lastState = end;\n      final Query queryPos;\n      if (graph.hasSidePath(start)) {\n        final Iterator<TokenStream> it = graph.getFiniteStrings(start, end);\n        Iterator<Query> queries = new Iterator<Query>() {\n          @Override\n          public boolean hasNext() {\n            return it.hasNext();\n          }\n\n          @Override\n          public Query next() {\n            TokenStream ts = it.next();\n            return createFieldQuery(ts, BooleanClause.Occur.MUST, field, getAutoGenerateMultiTermSynonymsPhraseQuery(), 0);\n          }\n        };\n        queryPos = newGraphSynonymQuery(queries);\n      } else {\n        Term[] terms = graph.getTerms(field, start);\n        assert terms.length > 0;\n        if (terms.length == 1) {\n          queryPos = newTermQuery(terms[0]);\n        } else {\n          queryPos = newSynonymQuery(terms);\n        }\n      }\n      if (queryPos != null) {\n        builder.add(queryPos, operator);\n      }\n    }\n    return builder.build();\n  }\n\n","sourceOld":"  /**\n   * Creates a boolean query from a graph token stream. The articulation points of the graph are visited in order and the queries\n   * created at each point are merged in the returned boolean query.\n   */\n  protected Query analyzeGraphBoolean(String field, TokenStream source, BooleanClause.Occur operator) throws IOException {\n    source.reset();\n    GraphTokenStreamFiniteStrings graph = new GraphTokenStreamFiniteStrings(source);\n    BooleanQuery.Builder builder = new BooleanQuery.Builder();\n    int[] articulationPoints = graph.articulationPoints();\n    int lastState = 0;\n    for (int i = 0; i <= articulationPoints.length; i++) {\n      int start = lastState;\n      int end = -1;\n      if (i < articulationPoints.length) {\n        end = articulationPoints[i];\n      }\n      lastState = end;\n      final Query queryPos;\n      if (graph.hasSidePath(start)) {\n        final Iterator<TokenStream> it = graph.getFiniteStrings(start, end);\n        Iterator<Query> queries = new Iterator<Query>() {\n          @Override\n          public boolean hasNext() {\n            return it.hasNext();\n          }\n\n          @Override\n          public Query next() {\n            TokenStream ts = it.next();\n            return createFieldQuery(ts, BooleanClause.Occur.MUST, field, getAutoGenerateMultiTermSynonymsPhraseQuery(), 0);\n          }\n        };\n        queryPos = newGraphSynonymQuery(queries);\n      } else {\n        Term[] terms = graph.getTerms(field, start);\n        assert terms.length > 0;\n        if (terms.length == 1) {\n          queryPos = newTermQuery(terms[0]);\n        } else {\n          queryPos = newSynonymQuery(terms);\n        }\n      }\n      if (queryPos != null) {\n        builder.add(queryPos, operator);\n      }\n    }\n    BooleanQuery bq =  builder.build();\n    if (bq.clauses().size() == 1) {\n      return bq.clauses().get(0).getQuery();\n    }\n    return bq;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#analyzeGraphBoolean(String,TokenStream,BooleanClause.Occur).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#analyzeGraphBoolean(String,TokenStream,BooleanClause.Occur).mjava","sourceNew":"  /**\n   * Creates a boolean query from a graph token stream. The articulation points of the graph are visited in order and the queries\n   * created at each point are merged in the returned boolean query.\n   */\n  protected Query analyzeGraphBoolean(String field, TokenStream source, BooleanClause.Occur operator) throws IOException {\n    source.reset();\n    GraphTokenStreamFiniteStrings graph = new GraphTokenStreamFiniteStrings(source);\n    BooleanQuery.Builder builder = new BooleanQuery.Builder();\n    int[] articulationPoints = graph.articulationPoints();\n    int lastState = 0;\n    for (int i = 0; i <= articulationPoints.length; i++) {\n      int start = lastState;\n      int end = -1;\n      if (i < articulationPoints.length) {\n        end = articulationPoints[i];\n      }\n      lastState = end;\n      final Query queryPos;\n      if (graph.hasSidePath(start)) {\n        final Iterator<TokenStream> it = graph.getFiniteStrings(start, end);\n        Iterator<Query> queries = new Iterator<Query>() {\n          @Override\n          public boolean hasNext() {\n            return it.hasNext();\n          }\n\n          @Override\n          public Query next() {\n            TokenStream ts = it.next();\n            return createFieldQuery(ts, BooleanClause.Occur.MUST, field, getAutoGenerateMultiTermSynonymsPhraseQuery(), 0);\n          }\n        };\n        queryPos = newGraphSynonymQuery(queries);\n      } else {\n        Term[] terms = graph.getTerms(field, start);\n        assert terms.length > 0;\n        if (terms.length == 1) {\n          queryPos = newTermQuery(terms[0]);\n        } else {\n          queryPos = newSynonymQuery(terms);\n        }\n      }\n      if (queryPos != null) {\n        builder.add(queryPos, operator);\n      }\n    }\n    return builder.build();\n  }\n\n","sourceOld":"  /**\n   * Creates a boolean query from a graph token stream. The articulation points of the graph are visited in order and the queries\n   * created at each point are merged in the returned boolean query.\n   */\n  protected Query analyzeGraphBoolean(String field, TokenStream source, BooleanClause.Occur operator) throws IOException {\n    source.reset();\n    GraphTokenStreamFiniteStrings graph = new GraphTokenStreamFiniteStrings(source);\n    BooleanQuery.Builder builder = new BooleanQuery.Builder();\n    int[] articulationPoints = graph.articulationPoints();\n    int lastState = 0;\n    for (int i = 0; i <= articulationPoints.length; i++) {\n      int start = lastState;\n      int end = -1;\n      if (i < articulationPoints.length) {\n        end = articulationPoints[i];\n      }\n      lastState = end;\n      final Query queryPos;\n      if (graph.hasSidePath(start)) {\n        final Iterator<TokenStream> it = graph.getFiniteStrings(start, end);\n        Iterator<Query> queries = new Iterator<Query>() {\n          @Override\n          public boolean hasNext() {\n            return it.hasNext();\n          }\n\n          @Override\n          public Query next() {\n            TokenStream ts = it.next();\n            return createFieldQuery(ts, BooleanClause.Occur.MUST, field, getAutoGenerateMultiTermSynonymsPhraseQuery(), 0);\n          }\n        };\n        queryPos = newGraphSynonymQuery(queries);\n      } else {\n        Term[] terms = graph.getTerms(field, start);\n        assert terms.length > 0;\n        if (terms.length == 1) {\n          queryPos = newTermQuery(terms[0]);\n        } else {\n          queryPos = newSynonymQuery(terms);\n        }\n      }\n      if (queryPos != null) {\n        builder.add(queryPos, operator);\n      }\n    }\n    BooleanQuery bq =  builder.build();\n    if (bq.clauses().size() == 1) {\n      return bq.clauses().get(0).getQuery();\n    }\n    return bq;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3ac99c5ad157ae4ccdb201f140463a90f12f07b3","date":1582540181,"type":3,"author":"Alessandro Benedetti","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#analyzeGraphBoolean(String,TokenStream,BooleanClause.Occur).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/QueryBuilder#analyzeGraphBoolean(String,TokenStream,BooleanClause.Occur).mjava","sourceNew":"  /**\n   * Creates a boolean query from a graph token stream. The articulation points of the graph are visited in order and the queries\n   * created at each point are merged in the returned boolean query.\n   */\n  protected Query analyzeGraphBoolean(String field, TokenStream source, BooleanClause.Occur operator) throws IOException {\n    source.reset();\n    GraphTokenStreamFiniteStrings graph = new GraphTokenStreamFiniteStrings(source);\n    BooleanQuery.Builder builder = new BooleanQuery.Builder();\n    int[] articulationPoints = graph.articulationPoints();\n    int lastState = 0;\n    for (int i = 0; i <= articulationPoints.length; i++) {\n      int start = lastState;\n      int end = -1;\n      if (i < articulationPoints.length) {\n        end = articulationPoints[i];\n      }\n      lastState = end;\n      final Query positionalQuery;\n      if (graph.hasSidePath(start)) {\n        final Iterator<TokenStream> sidePathsIterator = graph.getFiniteStrings(start, end);\n        Iterator<Query> queries = new Iterator<Query>() {\n          @Override\n          public boolean hasNext() {\n            return sidePathsIterator.hasNext();\n          }\n\n          @Override\n          public Query next() {\n            TokenStream sidePath = sidePathsIterator.next();\n            return createFieldQuery(sidePath, BooleanClause.Occur.MUST, field, getAutoGenerateMultiTermSynonymsPhraseQuery(), 0);\n          }\n        };\n        positionalQuery = newGraphSynonymQuery(queries);\n      } else {\n        List<AttributeSource> attributes = graph.getTerms(start);\n        TermAndBoost[] terms = attributes.stream()\n                .map(s -> {\n                  TermToBytesRefAttribute t = s.addAttribute(TermToBytesRefAttribute.class);\n                  BoostAttribute b = s.addAttribute(BoostAttribute.class);\n                  return new TermAndBoost(new Term(field, t.getBytesRef()), b.getBoost());\n                })\n                .toArray(TermAndBoost[]::new);\n        assert terms.length > 0;\n        if (terms.length == 1) {\n          positionalQuery = newTermQuery(terms[0].term, terms[0].boost);\n        } else {\n          positionalQuery = newSynonymQuery(terms);\n        }\n      }\n      if (positionalQuery != null) {\n        builder.add(positionalQuery, operator);\n      }\n    }\n    return builder.build();\n  }\n\n","sourceOld":"  /**\n   * Creates a boolean query from a graph token stream. The articulation points of the graph are visited in order and the queries\n   * created at each point are merged in the returned boolean query.\n   */\n  protected Query analyzeGraphBoolean(String field, TokenStream source, BooleanClause.Occur operator) throws IOException {\n    source.reset();\n    GraphTokenStreamFiniteStrings graph = new GraphTokenStreamFiniteStrings(source);\n    BooleanQuery.Builder builder = new BooleanQuery.Builder();\n    int[] articulationPoints = graph.articulationPoints();\n    int lastState = 0;\n    for (int i = 0; i <= articulationPoints.length; i++) {\n      int start = lastState;\n      int end = -1;\n      if (i < articulationPoints.length) {\n        end = articulationPoints[i];\n      }\n      lastState = end;\n      final Query queryPos;\n      if (graph.hasSidePath(start)) {\n        final Iterator<TokenStream> it = graph.getFiniteStrings(start, end);\n        Iterator<Query> queries = new Iterator<Query>() {\n          @Override\n          public boolean hasNext() {\n            return it.hasNext();\n          }\n\n          @Override\n          public Query next() {\n            TokenStream ts = it.next();\n            return createFieldQuery(ts, BooleanClause.Occur.MUST, field, getAutoGenerateMultiTermSynonymsPhraseQuery(), 0);\n          }\n        };\n        queryPos = newGraphSynonymQuery(queries);\n      } else {\n        Term[] terms = graph.getTerms(field, start);\n        assert terms.length > 0;\n        if (terms.length == 1) {\n          queryPos = newTermQuery(terms[0]);\n        } else {\n          queryPos = newSynonymQuery(terms);\n        }\n      }\n      if (queryPos != null) {\n        builder.add(queryPos, operator);\n      }\n    }\n    return builder.build();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3ac99c5ad157ae4ccdb201f140463a90f12f07b3":["28288370235ed02234a64753cdbf0c6ec096304a"],"8d5f9da379ac10a8ebcbf30e00314c561652932b":["6d44a067741cef02c3637ee610da1e8d6d30632e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5b2e16c9b5fb24bd926f6d6cfcf14967f0f1c52b":["7e0d75d7d3cda2b33e79d0eb0e716169cebec4db"],"6d44a067741cef02c3637ee610da1e8d6d30632e":["7e0d75d7d3cda2b33e79d0eb0e716169cebec4db"],"28288370235ed02234a64753cdbf0c6ec096304a":["6d44a067741cef02c3637ee610da1e8d6d30632e","8d5f9da379ac10a8ebcbf30e00314c561652932b"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["5b2e16c9b5fb24bd926f6d6cfcf14967f0f1c52b","8d5f9da379ac10a8ebcbf30e00314c561652932b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3ac99c5ad157ae4ccdb201f140463a90f12f07b3"],"7e0d75d7d3cda2b33e79d0eb0e716169cebec4db":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"3ac99c5ad157ae4ccdb201f140463a90f12f07b3":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"8d5f9da379ac10a8ebcbf30e00314c561652932b":["28288370235ed02234a64753cdbf0c6ec096304a","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7e0d75d7d3cda2b33e79d0eb0e716169cebec4db"],"5b2e16c9b5fb24bd926f6d6cfcf14967f0f1c52b":["2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"6d44a067741cef02c3637ee610da1e8d6d30632e":["8d5f9da379ac10a8ebcbf30e00314c561652932b","28288370235ed02234a64753cdbf0c6ec096304a"],"28288370235ed02234a64753cdbf0c6ec096304a":["3ac99c5ad157ae4ccdb201f140463a90f12f07b3"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":[],"7e0d75d7d3cda2b33e79d0eb0e716169cebec4db":["5b2e16c9b5fb24bd926f6d6cfcf14967f0f1c52b","6d44a067741cef02c3637ee610da1e8d6d30632e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}