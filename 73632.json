{"path":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#moveLargestFieldLast(Document).mjava","commits":[{"id":"24686226124dab7a26bcb1ed0653aa7fa4a18c9e","date":1489713728,"type":0,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#moveLargestFieldLast(Document).mjava","pathOld":"/dev/null","sourceNew":"  /** Move the largest stored field last, because Lucene can avoid loading that one if it's not needed. */\n  private static void moveLargestFieldLast(Document doc) {\n    String largestField = null;\n    int largestFieldLen = -1;\n    boolean largestIsLast = true;\n    for (IndexableField field : doc) {\n      if (!field.fieldType().stored()) {\n        continue;\n      }\n      if (largestIsLast && !field.name().equals(largestField)) {\n        largestIsLast = false;\n      }\n      if (field.numericValue() != null) { // just ignore these as non-competitive (avoid toString'ing their number)\n        continue;\n      }\n      String strVal = field.stringValue();\n      if (strVal != null) {\n        if (strVal.length() > largestFieldLen) {\n          largestField = field.name();\n          largestFieldLen = strVal.length();\n          largestIsLast = true;\n        }\n      } else {\n        BytesRef bytesRef = field.binaryValue();\n        if (bytesRef != null && bytesRef.length > largestFieldLen) {\n          largestField = field.name();\n          largestFieldLen = bytesRef.length;\n          largestIsLast = true;\n        }\n      }\n    }\n    if (!largestIsLast && largestField != null && largestFieldLen > MIN_LENGTH_TO_MOVE_LAST) { // only bother if the value isn't tiny\n      LinkedList<IndexableField> addToEnd = new LinkedList<>();\n      Iterator<IndexableField> iterator = doc.iterator();\n      while (iterator.hasNext()) {\n        IndexableField field = iterator.next();\n        if (field.name().equals(largestField)) {\n          addToEnd.add(field);\n          iterator.remove(); // Document may not have \"remove\" but it's iterator allows mutation\n        }\n      }\n      for (IndexableField field : addToEnd) {\n        doc.add(field);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c4359f613ec1bd44a86b91e052b90aadb3804b51","date":1490280010,"type":0,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#moveLargestFieldLast(Document).mjava","pathOld":"/dev/null","sourceNew":"  /** Move the largest stored field last, because Lucene can avoid loading that one if it's not needed. */\n  private static void moveLargestFieldLast(Document doc) {\n    String largestField = null;\n    int largestFieldLen = -1;\n    boolean largestIsLast = true;\n    for (IndexableField field : doc) {\n      if (!field.fieldType().stored()) {\n        continue;\n      }\n      if (largestIsLast && !field.name().equals(largestField)) {\n        largestIsLast = false;\n      }\n      if (field.numericValue() != null) { // just ignore these as non-competitive (avoid toString'ing their number)\n        continue;\n      }\n      String strVal = field.stringValue();\n      if (strVal != null) {\n        if (strVal.length() > largestFieldLen) {\n          largestField = field.name();\n          largestFieldLen = strVal.length();\n          largestIsLast = true;\n        }\n      } else {\n        BytesRef bytesRef = field.binaryValue();\n        if (bytesRef != null && bytesRef.length > largestFieldLen) {\n          largestField = field.name();\n          largestFieldLen = bytesRef.length;\n          largestIsLast = true;\n        }\n      }\n    }\n    if (!largestIsLast && largestField != null && largestFieldLen > MIN_LENGTH_TO_MOVE_LAST) { // only bother if the value isn't tiny\n      LinkedList<IndexableField> addToEnd = new LinkedList<>();\n      Iterator<IndexableField> iterator = doc.iterator();\n      while (iterator.hasNext()) {\n        IndexableField field = iterator.next();\n        if (field.name().equals(largestField)) {\n          addToEnd.add(field);\n          iterator.remove(); // Document may not have \"remove\" but it's iterator allows mutation\n        }\n      }\n      for (IndexableField field : addToEnd) {\n        doc.add(field);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c4359f613ec1bd44a86b91e052b90aadb3804b51":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["24686226124dab7a26bcb1ed0653aa7fa4a18c9e"],"24686226124dab7a26bcb1ed0653aa7fa4a18c9e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c4359f613ec1bd44a86b91e052b90aadb3804b51","24686226124dab7a26bcb1ed0653aa7fa4a18c9e"],"c4359f613ec1bd44a86b91e052b90aadb3804b51":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"24686226124dab7a26bcb1ed0653aa7fa4a18c9e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["c4359f613ec1bd44a86b91e052b90aadb3804b51","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}