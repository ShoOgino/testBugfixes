{"path":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonGrid#LatLonGrid(int,int,int,int,LatLonTree[]).mjava","commits":[{"id":"bc0f1175d994495cbd5763445c91c22f543d8687","date":1461352263,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonGrid#LatLonGrid(int,int,int,int,LatLonTree[]).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonGrid#LatLonGrid(int,int,int,int,Polygon...).mjava","sourceNew":"  LatLonGrid(int minLat, int maxLat, int minLon, int maxLon, LatLonTree[] tree) {\n    this.minLat = minLat;\n    this.maxLat = maxLat;\n    this.minLon = minLon;\n    this.maxLon = maxLon;\n    this.tree = tree;\n    if (minLon > maxLon) {\n      // maybe make 2 grids if you want this? \n      throw new IllegalArgumentException(\"Grid cannot cross the dateline\");\n    }\n    if (minLat > maxLat) {\n      throw new IllegalArgumentException(\"bogus grid\");\n    }\n    long latitudeRange = maxLat - (long) minLat;\n    long longitudeRange = maxLon - (long) minLon;\n\n    // if the range is too small, we can't divide it up in our grid nicely.\n    // in this case of a tiny polygon, we just make an empty grid instead of complicating/slowing down code.\n    final long minRange = (GRID_SIZE - 1) * (GRID_SIZE - 1);\n    if (latitudeRange < minRange || longitudeRange < minRange) {\n      latPerCell = lonPerCell = Long.MAX_VALUE;\n    } else {\n      // we spill over the edge of the bounding box in each direction a bit,\n      // but it prevents edge case bugs.\n      latPerCell = latitudeRange / (GRID_SIZE - 1);\n      lonPerCell = longitudeRange / (GRID_SIZE - 1);\n      fill(0, GRID_SIZE, 0, GRID_SIZE);\n    }\n  }\n\n","sourceOld":"  LatLonGrid(int minLat, int maxLat, int minLon, int maxLon, Polygon... polygons) {\n    this.minLat = minLat;\n    this.maxLat = maxLat;\n    this.minLon = minLon;\n    this.maxLon = maxLon;\n    this.tree = LatLonTree.build(polygons);\n    if (minLon > maxLon) {\n      // maybe make 2 grids if you want this? \n      throw new IllegalArgumentException(\"Grid cannot cross the dateline\");\n    }\n    if (minLat > maxLat) {\n      throw new IllegalArgumentException(\"bogus grid\");\n    }\n    long latitudeRange = maxLat - (long) minLat;\n    long longitudeRange = maxLon - (long) minLon;\n\n    // if the range is too small, we can't divide it up in our grid nicely.\n    // in this case of a tiny polygon, we just make an empty grid instead of complicating/slowing down code.\n    final long minRange = (GRID_SIZE - 1) * (GRID_SIZE - 1);\n    if (latitudeRange < minRange || longitudeRange < minRange) {\n      latPerCell = lonPerCell = Long.MAX_VALUE;\n    } else {\n      // we spill over the edge of the bounding box in each direction a bit,\n      // but it prevents edge case bugs.\n      latPerCell = latitudeRange / (GRID_SIZE - 1);\n      lonPerCell = longitudeRange / (GRID_SIZE - 1);\n      fill(0, GRID_SIZE, 0, GRID_SIZE);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"925fce43f3bac029d912b9b7de03c789e258a333","date":1461612714,"type":4,"author":"Robert Muir","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonGrid#LatLonGrid(int,int,int,int,LatLonTree[]).mjava","sourceNew":null,"sourceOld":"  LatLonGrid(int minLat, int maxLat, int minLon, int maxLon, LatLonTree[] tree) {\n    this.minLat = minLat;\n    this.maxLat = maxLat;\n    this.minLon = minLon;\n    this.maxLon = maxLon;\n    this.tree = tree;\n    if (minLon > maxLon) {\n      // maybe make 2 grids if you want this? \n      throw new IllegalArgumentException(\"Grid cannot cross the dateline\");\n    }\n    if (minLat > maxLat) {\n      throw new IllegalArgumentException(\"bogus grid\");\n    }\n    long latitudeRange = maxLat - (long) minLat;\n    long longitudeRange = maxLon - (long) minLon;\n\n    // if the range is too small, we can't divide it up in our grid nicely.\n    // in this case of a tiny polygon, we just make an empty grid instead of complicating/slowing down code.\n    final long minRange = (GRID_SIZE - 1) * (GRID_SIZE - 1);\n    if (latitudeRange < minRange || longitudeRange < minRange) {\n      latPerCell = lonPerCell = Long.MAX_VALUE;\n    } else {\n      // we spill over the edge of the bounding box in each direction a bit,\n      // but it prevents edge case bugs.\n      latPerCell = latitudeRange / (GRID_SIZE - 1);\n      lonPerCell = longitudeRange / (GRID_SIZE - 1);\n      fill(0, GRID_SIZE, 0, GRID_SIZE);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"bc0f1175d994495cbd5763445c91c22f543d8687":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"925fce43f3bac029d912b9b7de03c789e258a333":["bc0f1175d994495cbd5763445c91c22f543d8687"]},"commit2Childs":{"bc0f1175d994495cbd5763445c91c22f543d8687":["925fce43f3bac029d912b9b7de03c789e258a333"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["bc0f1175d994495cbd5763445c91c22f543d8687","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"925fce43f3bac029d912b9b7de03c789e258a333":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","925fce43f3bac029d912b9b7de03c789e258a333"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}