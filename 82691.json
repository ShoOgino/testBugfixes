{"path":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testBooleanScorerMax().mjava","commits":[{"id":"60755ef433d2d56d15e4738c8095f50fd02ddc20","date":1347723768,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testBooleanScorerMax().mjava","pathOld":"/dev/null","sourceNew":"  public void testBooleanScorerMax() throws IOException {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir);\n\n    int docCount = atLeast(10000);\n\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"a\", TextField.TYPE_NOT_STORED));\n      riw.addDocument(doc);\n    }\n\n    riw.forceMerge(1);\n    IndexReader r = riw.getReader();\n    riw.close();\n\n    IndexSearcher s = newSearcher(r);\n    BooleanQuery bq = new BooleanQuery();\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n\n    Weight w = s.createNormalizedWeight(bq);\n\n    assertEquals(1, s.getIndexReader().leaves().size());\n    Scorer scorer = w.scorer(s.getIndexReader().leaves().get(0), false, true, null);\n\n    final FixedBitSet hits = new FixedBitSet(docCount);\n    final AtomicInteger end = new AtomicInteger();\n    Collector c = new Collector() {\n        @Override\n        public void setNextReader(AtomicReaderContext sub) {\n        }\n\n        @Override\n        public void collect(int doc) {\n          assertTrue(\"collected doc=\" + doc + \" beyond max=\" + end, doc < end.intValue());\n          hits.set(doc);\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) {\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n      };\n\n    while (end.intValue() < docCount) {\n      final int inc = _TestUtil.nextInt(random(), 1, 1000);\n      end.getAndAdd(inc);\n      scorer.score(c, end.intValue(), -1);\n    }\n\n    assertEquals(docCount, hits.cardinality());\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4b53a9a930ee01857178a1b512fbab24642f3fa8","date":1354471097,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testBooleanScorerMax().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testBooleanScorerMax().mjava","sourceNew":"  public void testBooleanScorerMax() throws IOException {\n    Directory dir = newDirectory();\n    // nocommit remove SMS:\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMergeScheduler(new SerialMergeScheduler()));\n\n    int docCount = atLeast(10000);\n\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"a\", TextField.TYPE_NOT_STORED));\n      riw.addDocument(doc);\n    }\n\n    riw.forceMerge(1);\n    IndexReader r = riw.getReader();\n    riw.close();\n\n    IndexSearcher s = newSearcher(r);\n    BooleanQuery bq = new BooleanQuery();\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n\n    Weight w = s.createNormalizedWeight(bq);\n\n    assertEquals(1, s.getIndexReader().leaves().size());\n    Scorer scorer = w.scorer(s.getIndexReader().leaves().get(0), false, true, null);\n\n    final FixedBitSet hits = new FixedBitSet(docCount);\n    final AtomicInteger end = new AtomicInteger();\n    Collector c = new Collector() {\n        @Override\n        public void setNextReader(AtomicReaderContext sub) {\n        }\n\n        @Override\n        public void collect(int doc) {\n          assertTrue(\"collected doc=\" + doc + \" beyond max=\" + end, doc < end.intValue());\n          hits.set(doc);\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) {\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n      };\n\n    while (end.intValue() < docCount) {\n      final int inc = _TestUtil.nextInt(random(), 1, 1000);\n      end.getAndAdd(inc);\n      scorer.score(c, end.intValue(), -1);\n    }\n\n    assertEquals(docCount, hits.cardinality());\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testBooleanScorerMax() throws IOException {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir);\n\n    int docCount = atLeast(10000);\n\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"a\", TextField.TYPE_NOT_STORED));\n      riw.addDocument(doc);\n    }\n\n    riw.forceMerge(1);\n    IndexReader r = riw.getReader();\n    riw.close();\n\n    IndexSearcher s = newSearcher(r);\n    BooleanQuery bq = new BooleanQuery();\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n\n    Weight w = s.createNormalizedWeight(bq);\n\n    assertEquals(1, s.getIndexReader().leaves().size());\n    Scorer scorer = w.scorer(s.getIndexReader().leaves().get(0), false, true, null);\n\n    final FixedBitSet hits = new FixedBitSet(docCount);\n    final AtomicInteger end = new AtomicInteger();\n    Collector c = new Collector() {\n        @Override\n        public void setNextReader(AtomicReaderContext sub) {\n        }\n\n        @Override\n        public void collect(int doc) {\n          assertTrue(\"collected doc=\" + doc + \" beyond max=\" + end, doc < end.intValue());\n          hits.set(doc);\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) {\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n      };\n\n    while (end.intValue() < docCount) {\n      final int inc = _TestUtil.nextInt(random(), 1, 1000);\n      end.getAndAdd(inc);\n      scorer.score(c, end.intValue(), -1);\n    }\n\n    assertEquals(docCount, hits.cardinality());\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"47b9e6cdfa7e1fc15944550d1007780d96b4dcb6","date":1358785685,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testBooleanScorerMax().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testBooleanScorerMax().mjava","sourceNew":"  public void testBooleanScorerMax() throws IOException {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n\n    int docCount = atLeast(10000);\n\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"a\", TextField.TYPE_NOT_STORED));\n      riw.addDocument(doc);\n    }\n\n    riw.forceMerge(1);\n    IndexReader r = riw.getReader();\n    riw.close();\n\n    IndexSearcher s = newSearcher(r);\n    BooleanQuery bq = new BooleanQuery();\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n\n    Weight w = s.createNormalizedWeight(bq);\n\n    assertEquals(1, s.getIndexReader().leaves().size());\n    Scorer scorer = w.scorer(s.getIndexReader().leaves().get(0), false, true, null);\n\n    final FixedBitSet hits = new FixedBitSet(docCount);\n    final AtomicInteger end = new AtomicInteger();\n    Collector c = new Collector() {\n        @Override\n        public void setNextReader(AtomicReaderContext sub) {\n        }\n\n        @Override\n        public void collect(int doc) {\n          assertTrue(\"collected doc=\" + doc + \" beyond max=\" + end, doc < end.intValue());\n          hits.set(doc);\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) {\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n      };\n\n    while (end.intValue() < docCount) {\n      final int inc = _TestUtil.nextInt(random(), 1, 1000);\n      end.getAndAdd(inc);\n      scorer.score(c, end.intValue(), -1);\n    }\n\n    assertEquals(docCount, hits.cardinality());\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testBooleanScorerMax() throws IOException {\n    Directory dir = newDirectory();\n    // nocommit remove SMS:\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMergeScheduler(new SerialMergeScheduler()));\n\n    int docCount = atLeast(10000);\n\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"a\", TextField.TYPE_NOT_STORED));\n      riw.addDocument(doc);\n    }\n\n    riw.forceMerge(1);\n    IndexReader r = riw.getReader();\n    riw.close();\n\n    IndexSearcher s = newSearcher(r);\n    BooleanQuery bq = new BooleanQuery();\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n\n    Weight w = s.createNormalizedWeight(bq);\n\n    assertEquals(1, s.getIndexReader().leaves().size());\n    Scorer scorer = w.scorer(s.getIndexReader().leaves().get(0), false, true, null);\n\n    final FixedBitSet hits = new FixedBitSet(docCount);\n    final AtomicInteger end = new AtomicInteger();\n    Collector c = new Collector() {\n        @Override\n        public void setNextReader(AtomicReaderContext sub) {\n        }\n\n        @Override\n        public void collect(int doc) {\n          assertTrue(\"collected doc=\" + doc + \" beyond max=\" + end, doc < end.intValue());\n          hits.set(doc);\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) {\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n      };\n\n    while (end.intValue() < docCount) {\n      final int inc = _TestUtil.nextInt(random(), 1, 1000);\n      end.getAndAdd(inc);\n      scorer.score(c, end.intValue(), -1);\n    }\n\n    assertEquals(docCount, hits.cardinality());\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testBooleanScorerMax().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testBooleanScorerMax().mjava","sourceNew":"  public void testBooleanScorerMax() throws IOException {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n\n    int docCount = atLeast(10000);\n\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"a\", TextField.TYPE_NOT_STORED));\n      riw.addDocument(doc);\n    }\n\n    riw.forceMerge(1);\n    IndexReader r = riw.getReader();\n    riw.close();\n\n    IndexSearcher s = newSearcher(r);\n    BooleanQuery bq = new BooleanQuery();\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n\n    Weight w = s.createNormalizedWeight(bq);\n\n    assertEquals(1, s.getIndexReader().leaves().size());\n    Scorer scorer = w.scorer(s.getIndexReader().leaves().get(0), false, true, null);\n\n    final FixedBitSet hits = new FixedBitSet(docCount);\n    final AtomicInteger end = new AtomicInteger();\n    Collector c = new Collector() {\n        @Override\n        public void setNextReader(AtomicReaderContext sub) {\n        }\n\n        @Override\n        public void collect(int doc) {\n          assertTrue(\"collected doc=\" + doc + \" beyond max=\" + end, doc < end.intValue());\n          hits.set(doc);\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) {\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n      };\n\n    while (end.intValue() < docCount) {\n      final int inc = _TestUtil.nextInt(random(), 1, 1000);\n      end.getAndAdd(inc);\n      scorer.score(c, end.intValue(), -1);\n    }\n\n    assertEquals(docCount, hits.cardinality());\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testBooleanScorerMax() throws IOException {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir);\n\n    int docCount = atLeast(10000);\n\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"a\", TextField.TYPE_NOT_STORED));\n      riw.addDocument(doc);\n    }\n\n    riw.forceMerge(1);\n    IndexReader r = riw.getReader();\n    riw.close();\n\n    IndexSearcher s = newSearcher(r);\n    BooleanQuery bq = new BooleanQuery();\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n\n    Weight w = s.createNormalizedWeight(bq);\n\n    assertEquals(1, s.getIndexReader().leaves().size());\n    Scorer scorer = w.scorer(s.getIndexReader().leaves().get(0), false, true, null);\n\n    final FixedBitSet hits = new FixedBitSet(docCount);\n    final AtomicInteger end = new AtomicInteger();\n    Collector c = new Collector() {\n        @Override\n        public void setNextReader(AtomicReaderContext sub) {\n        }\n\n        @Override\n        public void collect(int doc) {\n          assertTrue(\"collected doc=\" + doc + \" beyond max=\" + end, doc < end.intValue());\n          hits.set(doc);\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) {\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n      };\n\n    while (end.intValue() < docCount) {\n      final int inc = _TestUtil.nextInt(random(), 1, 1000);\n      end.getAndAdd(inc);\n      scorer.score(c, end.intValue(), -1);\n    }\n\n    assertEquals(docCount, hits.cardinality());\n    r.close();\n    dir.close();\n  }\n\n","bugFix":["60755ef433d2d56d15e4738c8095f50fd02ddc20"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testBooleanScorerMax().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testBooleanScorerMax().mjava","sourceNew":"  public void testBooleanScorerMax() throws IOException {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n\n    int docCount = atLeast(10000);\n\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"a\", TextField.TYPE_NOT_STORED));\n      riw.addDocument(doc);\n    }\n\n    riw.forceMerge(1);\n    IndexReader r = riw.getReader();\n    riw.close();\n\n    IndexSearcher s = newSearcher(r);\n    BooleanQuery bq = new BooleanQuery();\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n\n    Weight w = s.createNormalizedWeight(bq);\n\n    assertEquals(1, s.getIndexReader().leaves().size());\n    Scorer scorer = w.scorer(s.getIndexReader().leaves().get(0), false, true, null);\n\n    final FixedBitSet hits = new FixedBitSet(docCount);\n    final AtomicInteger end = new AtomicInteger();\n    Collector c = new Collector() {\n        @Override\n        public void setNextReader(AtomicReaderContext sub) {\n        }\n\n        @Override\n        public void collect(int doc) {\n          assertTrue(\"collected doc=\" + doc + \" beyond max=\" + end, doc < end.intValue());\n          hits.set(doc);\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) {\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n      };\n\n    while (end.intValue() < docCount) {\n      final int inc = TestUtil.nextInt(random(), 1, 1000);\n      end.getAndAdd(inc);\n      scorer.score(c, end.intValue(), -1);\n    }\n\n    assertEquals(docCount, hits.cardinality());\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testBooleanScorerMax() throws IOException {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n\n    int docCount = atLeast(10000);\n\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"a\", TextField.TYPE_NOT_STORED));\n      riw.addDocument(doc);\n    }\n\n    riw.forceMerge(1);\n    IndexReader r = riw.getReader();\n    riw.close();\n\n    IndexSearcher s = newSearcher(r);\n    BooleanQuery bq = new BooleanQuery();\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n\n    Weight w = s.createNormalizedWeight(bq);\n\n    assertEquals(1, s.getIndexReader().leaves().size());\n    Scorer scorer = w.scorer(s.getIndexReader().leaves().get(0), false, true, null);\n\n    final FixedBitSet hits = new FixedBitSet(docCount);\n    final AtomicInteger end = new AtomicInteger();\n    Collector c = new Collector() {\n        @Override\n        public void setNextReader(AtomicReaderContext sub) {\n        }\n\n        @Override\n        public void collect(int doc) {\n          assertTrue(\"collected doc=\" + doc + \" beyond max=\" + end, doc < end.intValue());\n          hits.set(doc);\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) {\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n      };\n\n    while (end.intValue() < docCount) {\n      final int inc = _TestUtil.nextInt(random(), 1, 1000);\n      end.getAndAdd(inc);\n      scorer.score(c, end.intValue(), -1);\n    }\n\n    assertEquals(docCount, hits.cardinality());\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2e18c86f811939bfa8cd24046c96ed026f2e9b34","date":1393893071,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testBooleanScorerMax().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testBooleanScorerMax().mjava","sourceNew":"  public void testBooleanScorerMax() throws IOException {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n\n    int docCount = atLeast(10000);\n\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"a\", TextField.TYPE_NOT_STORED));\n      riw.addDocument(doc);\n    }\n\n    riw.forceMerge(1);\n    IndexReader r = riw.getReader();\n    riw.close();\n\n    IndexSearcher s = newSearcher(r);\n    BooleanQuery bq = new BooleanQuery();\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n\n    Weight w = s.createNormalizedWeight(bq);\n\n    assertEquals(1, s.getIndexReader().leaves().size());\n    TopScorer scorer = w.topScorer(s.getIndexReader().leaves().get(0), false, null);\n\n    final FixedBitSet hits = new FixedBitSet(docCount);\n    final AtomicInteger end = new AtomicInteger();\n    Collector c = new Collector() {\n        @Override\n        public void setNextReader(AtomicReaderContext sub) {\n        }\n\n        @Override\n        public void collect(int doc) {\n          assertTrue(\"collected doc=\" + doc + \" beyond max=\" + end, doc < end.intValue());\n          hits.set(doc);\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) {\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n      };\n\n    while (end.intValue() < docCount) {\n      final int inc = TestUtil.nextInt(random(), 1, 1000);\n      end.getAndAdd(inc);\n      scorer.score(c, end.intValue());\n    }\n\n    assertEquals(docCount, hits.cardinality());\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testBooleanScorerMax() throws IOException {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n\n    int docCount = atLeast(10000);\n\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"a\", TextField.TYPE_NOT_STORED));\n      riw.addDocument(doc);\n    }\n\n    riw.forceMerge(1);\n    IndexReader r = riw.getReader();\n    riw.close();\n\n    IndexSearcher s = newSearcher(r);\n    BooleanQuery bq = new BooleanQuery();\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n\n    Weight w = s.createNormalizedWeight(bq);\n\n    assertEquals(1, s.getIndexReader().leaves().size());\n    Scorer scorer = w.scorer(s.getIndexReader().leaves().get(0), false, true, null);\n\n    final FixedBitSet hits = new FixedBitSet(docCount);\n    final AtomicInteger end = new AtomicInteger();\n    Collector c = new Collector() {\n        @Override\n        public void setNextReader(AtomicReaderContext sub) {\n        }\n\n        @Override\n        public void collect(int doc) {\n          assertTrue(\"collected doc=\" + doc + \" beyond max=\" + end, doc < end.intValue());\n          hits.set(doc);\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) {\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n      };\n\n    while (end.intValue() < docCount) {\n      final int inc = TestUtil.nextInt(random(), 1, 1000);\n      end.getAndAdd(inc);\n      scorer.score(c, end.intValue(), -1);\n    }\n\n    assertEquals(docCount, hits.cardinality());\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a5794e5c995c57444b154b01a9f3c837cd530a77","date":1394190201,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testBooleanScorerMax().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testBooleanScorerMax().mjava","sourceNew":"  public void testBooleanScorerMax() throws IOException {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n\n    int docCount = atLeast(10000);\n\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"a\", TextField.TYPE_NOT_STORED));\n      riw.addDocument(doc);\n    }\n\n    riw.forceMerge(1);\n    IndexReader r = riw.getReader();\n    riw.close();\n\n    IndexSearcher s = newSearcher(r);\n    BooleanQuery bq = new BooleanQuery();\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n\n    Weight w = s.createNormalizedWeight(bq);\n\n    assertEquals(1, s.getIndexReader().leaves().size());\n    BulkScorer scorer = w.bulkScorer(s.getIndexReader().leaves().get(0), false, null);\n\n    final FixedBitSet hits = new FixedBitSet(docCount);\n    final AtomicInteger end = new AtomicInteger();\n    Collector c = new Collector() {\n        @Override\n        public void setNextReader(AtomicReaderContext sub) {\n        }\n\n        @Override\n        public void collect(int doc) {\n          assertTrue(\"collected doc=\" + doc + \" beyond max=\" + end, doc < end.intValue());\n          hits.set(doc);\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) {\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n      };\n\n    while (end.intValue() < docCount) {\n      final int inc = TestUtil.nextInt(random(), 1, 1000);\n      end.getAndAdd(inc);\n      scorer.score(c, end.intValue());\n    }\n\n    assertEquals(docCount, hits.cardinality());\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testBooleanScorerMax() throws IOException {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n\n    int docCount = atLeast(10000);\n\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"a\", TextField.TYPE_NOT_STORED));\n      riw.addDocument(doc);\n    }\n\n    riw.forceMerge(1);\n    IndexReader r = riw.getReader();\n    riw.close();\n\n    IndexSearcher s = newSearcher(r);\n    BooleanQuery bq = new BooleanQuery();\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n\n    Weight w = s.createNormalizedWeight(bq);\n\n    assertEquals(1, s.getIndexReader().leaves().size());\n    TopScorer scorer = w.topScorer(s.getIndexReader().leaves().get(0), false, null);\n\n    final FixedBitSet hits = new FixedBitSet(docCount);\n    final AtomicInteger end = new AtomicInteger();\n    Collector c = new Collector() {\n        @Override\n        public void setNextReader(AtomicReaderContext sub) {\n        }\n\n        @Override\n        public void collect(int doc) {\n          assertTrue(\"collected doc=\" + doc + \" beyond max=\" + end, doc < end.intValue());\n          hits.set(doc);\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) {\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n      };\n\n    while (end.intValue() < docCount) {\n      final int inc = TestUtil.nextInt(random(), 1, 1000);\n      end.getAndAdd(inc);\n      scorer.score(c, end.intValue());\n    }\n\n    assertEquals(docCount, hits.cardinality());\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"acf00221f44c5f08ccea014f2492b53af15ecd66","date":1394568293,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testBooleanScorerMax().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testBooleanScorerMax().mjava","sourceNew":"  public void testBooleanScorerMax() throws IOException {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n\n    int docCount = atLeast(10000);\n\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"a\", TextField.TYPE_NOT_STORED));\n      riw.addDocument(doc);\n    }\n\n    riw.forceMerge(1);\n    IndexReader r = riw.getReader();\n    riw.close();\n\n    IndexSearcher s = newSearcher(r);\n    BooleanQuery bq = new BooleanQuery();\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n\n    Weight w = s.createNormalizedWeight(bq);\n\n    assertEquals(1, s.getIndexReader().leaves().size());\n    BulkScorer scorer = w.bulkScorer(s.getIndexReader().leaves().get(0), false, null);\n\n    final FixedBitSet hits = new FixedBitSet(docCount);\n    final AtomicInteger end = new AtomicInteger();\n    Collector c = new Collector() {\n        @Override\n        public void setNextReader(AtomicReaderContext sub) {\n        }\n\n        @Override\n        public void collect(int doc) {\n          assertTrue(\"collected doc=\" + doc + \" beyond max=\" + end, doc < end.intValue());\n          hits.set(doc);\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) {\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n      };\n\n    while (end.intValue() < docCount) {\n      final int inc = TestUtil.nextInt(random(), 1, 1000);\n      end.getAndAdd(inc);\n      scorer.score(c, end.intValue());\n    }\n\n    assertEquals(docCount, hits.cardinality());\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testBooleanScorerMax() throws IOException {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n\n    int docCount = atLeast(10000);\n\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"a\", TextField.TYPE_NOT_STORED));\n      riw.addDocument(doc);\n    }\n\n    riw.forceMerge(1);\n    IndexReader r = riw.getReader();\n    riw.close();\n\n    IndexSearcher s = newSearcher(r);\n    BooleanQuery bq = new BooleanQuery();\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n\n    Weight w = s.createNormalizedWeight(bq);\n\n    assertEquals(1, s.getIndexReader().leaves().size());\n    Scorer scorer = w.scorer(s.getIndexReader().leaves().get(0), false, true, null);\n\n    final FixedBitSet hits = new FixedBitSet(docCount);\n    final AtomicInteger end = new AtomicInteger();\n    Collector c = new Collector() {\n        @Override\n        public void setNextReader(AtomicReaderContext sub) {\n        }\n\n        @Override\n        public void collect(int doc) {\n          assertTrue(\"collected doc=\" + doc + \" beyond max=\" + end, doc < end.intValue());\n          hits.set(doc);\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) {\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n      };\n\n    while (end.intValue() < docCount) {\n      final int inc = TestUtil.nextInt(random(), 1, 1000);\n      end.getAndAdd(inc);\n      scorer.score(c, end.intValue(), -1);\n    }\n\n    assertEquals(docCount, hits.cardinality());\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae73da626f97850c922c42736f808d0378e165f0","date":1396625460,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testBooleanScorerMax().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testBooleanScorerMax().mjava","sourceNew":"  public void testBooleanScorerMax() throws IOException {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n\n    int docCount = atLeast(10000);\n\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"a\", TextField.TYPE_NOT_STORED));\n      riw.addDocument(doc);\n    }\n\n    riw.forceMerge(1);\n    IndexReader r = riw.getReader();\n    riw.close();\n\n    IndexSearcher s = newSearcher(r);\n    BooleanQuery bq = new BooleanQuery();\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n\n    Weight w = s.createNormalizedWeight(bq);\n\n    assertEquals(1, s.getIndexReader().leaves().size());\n    BulkScorer scorer = w.bulkScorer(s.getIndexReader().leaves().get(0), false, null);\n\n    final FixedBitSet hits = new FixedBitSet(docCount);\n    final AtomicInteger end = new AtomicInteger();\n    LeafCollector c = new SimpleCollector() {\n\n        @Override\n        public void collect(int doc) {\n          assertTrue(\"collected doc=\" + doc + \" beyond max=\" + end, doc < end.intValue());\n          hits.set(doc);\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n      };\n\n    while (end.intValue() < docCount) {\n      final int inc = TestUtil.nextInt(random(), 1, 1000);\n      end.getAndAdd(inc);\n      scorer.score(c, end.intValue());\n    }\n\n    assertEquals(docCount, hits.cardinality());\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testBooleanScorerMax() throws IOException {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n\n    int docCount = atLeast(10000);\n\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"a\", TextField.TYPE_NOT_STORED));\n      riw.addDocument(doc);\n    }\n\n    riw.forceMerge(1);\n    IndexReader r = riw.getReader();\n    riw.close();\n\n    IndexSearcher s = newSearcher(r);\n    BooleanQuery bq = new BooleanQuery();\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n\n    Weight w = s.createNormalizedWeight(bq);\n\n    assertEquals(1, s.getIndexReader().leaves().size());\n    BulkScorer scorer = w.bulkScorer(s.getIndexReader().leaves().get(0), false, null);\n\n    final FixedBitSet hits = new FixedBitSet(docCount);\n    final AtomicInteger end = new AtomicInteger();\n    Collector c = new Collector() {\n        @Override\n        public void setNextReader(AtomicReaderContext sub) {\n        }\n\n        @Override\n        public void collect(int doc) {\n          assertTrue(\"collected doc=\" + doc + \" beyond max=\" + end, doc < end.intValue());\n          hits.set(doc);\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) {\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n      };\n\n    while (end.intValue() < docCount) {\n      final int inc = TestUtil.nextInt(random(), 1, 1000);\n      end.getAndAdd(inc);\n      scorer.score(c, end.intValue());\n    }\n\n    assertEquals(docCount, hits.cardinality());\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"15e323346eac5e4685c0a9f2df85eb96b4239bbb","date":1396688577,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testBooleanScorerMax().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testBooleanScorerMax().mjava","sourceNew":"  public void testBooleanScorerMax() throws IOException {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n\n    int docCount = atLeast(10000);\n\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"a\", TextField.TYPE_NOT_STORED));\n      riw.addDocument(doc);\n    }\n\n    riw.forceMerge(1);\n    IndexReader r = riw.getReader();\n    riw.close();\n\n    IndexSearcher s = newSearcher(r);\n    BooleanQuery bq = new BooleanQuery();\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n\n    Weight w = s.createNormalizedWeight(bq);\n\n    assertEquals(1, s.getIndexReader().leaves().size());\n    BulkScorer scorer = w.bulkScorer(s.getIndexReader().leaves().get(0), false, null);\n\n    final FixedBitSet hits = new FixedBitSet(docCount);\n    final AtomicInteger end = new AtomicInteger();\n    LeafCollector c = new SimpleCollector() {\n\n        @Override\n        public void collect(int doc) {\n          assertTrue(\"collected doc=\" + doc + \" beyond max=\" + end, doc < end.intValue());\n          hits.set(doc);\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n      };\n\n    while (end.intValue() < docCount) {\n      final int inc = TestUtil.nextInt(random(), 1, 1000);\n      end.getAndAdd(inc);\n      scorer.score(c, end.intValue());\n    }\n\n    assertEquals(docCount, hits.cardinality());\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testBooleanScorerMax() throws IOException {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n\n    int docCount = atLeast(10000);\n\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"a\", TextField.TYPE_NOT_STORED));\n      riw.addDocument(doc);\n    }\n\n    riw.forceMerge(1);\n    IndexReader r = riw.getReader();\n    riw.close();\n\n    IndexSearcher s = newSearcher(r);\n    BooleanQuery bq = new BooleanQuery();\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n\n    Weight w = s.createNormalizedWeight(bq);\n\n    assertEquals(1, s.getIndexReader().leaves().size());\n    BulkScorer scorer = w.bulkScorer(s.getIndexReader().leaves().get(0), false, null);\n\n    final FixedBitSet hits = new FixedBitSet(docCount);\n    final AtomicInteger end = new AtomicInteger();\n    Collector c = new Collector() {\n        @Override\n        public void setNextReader(AtomicReaderContext sub) {\n        }\n\n        @Override\n        public void collect(int doc) {\n          assertTrue(\"collected doc=\" + doc + \" beyond max=\" + end, doc < end.intValue());\n          hits.set(doc);\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) {\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n      };\n\n    while (end.intValue() < docCount) {\n      final int inc = TestUtil.nextInt(random(), 1, 1000);\n      end.getAndAdd(inc);\n      scorer.score(c, end.intValue());\n    }\n\n    assertEquals(docCount, hits.cardinality());\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae14298f4eec6d5faee6a149f88ba57d14a6f21a","date":1396971290,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testBooleanScorerMax().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testBooleanScorerMax().mjava","sourceNew":"  public void testBooleanScorerMax() throws IOException {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n\n    int docCount = atLeast(10000);\n\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"a\", TextField.TYPE_NOT_STORED));\n      riw.addDocument(doc);\n    }\n\n    riw.forceMerge(1);\n    IndexReader r = riw.getReader();\n    riw.shutdown();\n\n    IndexSearcher s = newSearcher(r);\n    BooleanQuery bq = new BooleanQuery();\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n\n    Weight w = s.createNormalizedWeight(bq);\n\n    assertEquals(1, s.getIndexReader().leaves().size());\n    BulkScorer scorer = w.bulkScorer(s.getIndexReader().leaves().get(0), false, null);\n\n    final FixedBitSet hits = new FixedBitSet(docCount);\n    final AtomicInteger end = new AtomicInteger();\n    LeafCollector c = new SimpleCollector() {\n\n        @Override\n        public void collect(int doc) {\n          assertTrue(\"collected doc=\" + doc + \" beyond max=\" + end, doc < end.intValue());\n          hits.set(doc);\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n      };\n\n    while (end.intValue() < docCount) {\n      final int inc = TestUtil.nextInt(random(), 1, 1000);\n      end.getAndAdd(inc);\n      scorer.score(c, end.intValue());\n    }\n\n    assertEquals(docCount, hits.cardinality());\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testBooleanScorerMax() throws IOException {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n\n    int docCount = atLeast(10000);\n\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"a\", TextField.TYPE_NOT_STORED));\n      riw.addDocument(doc);\n    }\n\n    riw.forceMerge(1);\n    IndexReader r = riw.getReader();\n    riw.close();\n\n    IndexSearcher s = newSearcher(r);\n    BooleanQuery bq = new BooleanQuery();\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n\n    Weight w = s.createNormalizedWeight(bq);\n\n    assertEquals(1, s.getIndexReader().leaves().size());\n    BulkScorer scorer = w.bulkScorer(s.getIndexReader().leaves().get(0), false, null);\n\n    final FixedBitSet hits = new FixedBitSet(docCount);\n    final AtomicInteger end = new AtomicInteger();\n    LeafCollector c = new SimpleCollector() {\n\n        @Override\n        public void collect(int doc) {\n          assertTrue(\"collected doc=\" + doc + \" beyond max=\" + end, doc < end.intValue());\n          hits.set(doc);\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n      };\n\n    while (end.intValue() < docCount) {\n      final int inc = TestUtil.nextInt(random(), 1, 1000);\n      end.getAndAdd(inc);\n      scorer.score(c, end.intValue());\n    }\n\n    assertEquals(docCount, hits.cardinality());\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e","date":1406737224,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testBooleanScorerMax().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testBooleanScorerMax().mjava","sourceNew":"  public void testBooleanScorerMax() throws IOException {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, newIndexWriterConfig(new MockAnalyzer(random())));\n\n    int docCount = atLeast(10000);\n\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"a\", TextField.TYPE_NOT_STORED));\n      riw.addDocument(doc);\n    }\n\n    riw.forceMerge(1);\n    IndexReader r = riw.getReader();\n    riw.shutdown();\n\n    IndexSearcher s = newSearcher(r);\n    BooleanQuery bq = new BooleanQuery();\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n\n    Weight w = s.createNormalizedWeight(bq);\n\n    assertEquals(1, s.getIndexReader().leaves().size());\n    BulkScorer scorer = w.bulkScorer(s.getIndexReader().leaves().get(0), false, null);\n\n    final FixedBitSet hits = new FixedBitSet(docCount);\n    final AtomicInteger end = new AtomicInteger();\n    LeafCollector c = new SimpleCollector() {\n\n        @Override\n        public void collect(int doc) {\n          assertTrue(\"collected doc=\" + doc + \" beyond max=\" + end, doc < end.intValue());\n          hits.set(doc);\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n      };\n\n    while (end.intValue() < docCount) {\n      final int inc = TestUtil.nextInt(random(), 1, 1000);\n      end.getAndAdd(inc);\n      scorer.score(c, end.intValue());\n    }\n\n    assertEquals(docCount, hits.cardinality());\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testBooleanScorerMax() throws IOException {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n\n    int docCount = atLeast(10000);\n\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"a\", TextField.TYPE_NOT_STORED));\n      riw.addDocument(doc);\n    }\n\n    riw.forceMerge(1);\n    IndexReader r = riw.getReader();\n    riw.shutdown();\n\n    IndexSearcher s = newSearcher(r);\n    BooleanQuery bq = new BooleanQuery();\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n\n    Weight w = s.createNormalizedWeight(bq);\n\n    assertEquals(1, s.getIndexReader().leaves().size());\n    BulkScorer scorer = w.bulkScorer(s.getIndexReader().leaves().get(0), false, null);\n\n    final FixedBitSet hits = new FixedBitSet(docCount);\n    final AtomicInteger end = new AtomicInteger();\n    LeafCollector c = new SimpleCollector() {\n\n        @Override\n        public void collect(int doc) {\n          assertTrue(\"collected doc=\" + doc + \" beyond max=\" + end, doc < end.intValue());\n          hits.set(doc);\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n      };\n\n    while (end.intValue() < docCount) {\n      final int inc = TestUtil.nextInt(random(), 1, 1000);\n      end.getAndAdd(inc);\n      scorer.score(c, end.intValue());\n    }\n\n    assertEquals(docCount, hits.cardinality());\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0ef034a4f10871667ae75181537775ddcf8ade4","date":1407610475,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testBooleanScorerMax().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testBooleanScorerMax().mjava","sourceNew":"  public void testBooleanScorerMax() throws IOException {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, newIndexWriterConfig(new MockAnalyzer(random())));\n\n    int docCount = atLeast(10000);\n\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"a\", TextField.TYPE_NOT_STORED));\n      riw.addDocument(doc);\n    }\n\n    riw.forceMerge(1);\n    IndexReader r = riw.getReader();\n    riw.close();\n\n    IndexSearcher s = newSearcher(r);\n    BooleanQuery bq = new BooleanQuery();\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n\n    Weight w = s.createNormalizedWeight(bq);\n\n    assertEquals(1, s.getIndexReader().leaves().size());\n    BulkScorer scorer = w.bulkScorer(s.getIndexReader().leaves().get(0), false, null);\n\n    final FixedBitSet hits = new FixedBitSet(docCount);\n    final AtomicInteger end = new AtomicInteger();\n    LeafCollector c = new SimpleCollector() {\n\n        @Override\n        public void collect(int doc) {\n          assertTrue(\"collected doc=\" + doc + \" beyond max=\" + end, doc < end.intValue());\n          hits.set(doc);\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n      };\n\n    while (end.intValue() < docCount) {\n      final int inc = TestUtil.nextInt(random(), 1, 1000);\n      end.getAndAdd(inc);\n      scorer.score(c, end.intValue());\n    }\n\n    assertEquals(docCount, hits.cardinality());\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testBooleanScorerMax() throws IOException {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, newIndexWriterConfig(new MockAnalyzer(random())));\n\n    int docCount = atLeast(10000);\n\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"a\", TextField.TYPE_NOT_STORED));\n      riw.addDocument(doc);\n    }\n\n    riw.forceMerge(1);\n    IndexReader r = riw.getReader();\n    riw.shutdown();\n\n    IndexSearcher s = newSearcher(r);\n    BooleanQuery bq = new BooleanQuery();\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n\n    Weight w = s.createNormalizedWeight(bq);\n\n    assertEquals(1, s.getIndexReader().leaves().size());\n    BulkScorer scorer = w.bulkScorer(s.getIndexReader().leaves().get(0), false, null);\n\n    final FixedBitSet hits = new FixedBitSet(docCount);\n    final AtomicInteger end = new AtomicInteger();\n    LeafCollector c = new SimpleCollector() {\n\n        @Override\n        public void collect(int doc) {\n          assertTrue(\"collected doc=\" + doc + \" beyond max=\" + end, doc < end.intValue());\n          hits.set(doc);\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n      };\n\n    while (end.intValue() < docCount) {\n      final int inc = TestUtil.nextInt(random(), 1, 1000);\n      end.getAndAdd(inc);\n      scorer.score(c, end.intValue());\n    }\n\n    assertEquals(docCount, hits.cardinality());\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f","date":1421314520,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testBooleanScorerMax().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testBooleanScorerMax().mjava","sourceNew":"  public void testBooleanScorerMax() throws IOException {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, newIndexWriterConfig(new MockAnalyzer(random())));\n\n    int docCount = atLeast(10000);\n\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"a\", TextField.TYPE_NOT_STORED));\n      riw.addDocument(doc);\n    }\n\n    riw.forceMerge(1);\n    IndexReader r = riw.getReader();\n    riw.close();\n\n    IndexSearcher s = newSearcher(r);\n    BooleanQuery bq = new BooleanQuery();\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n\n    Weight w = s.createNormalizedWeight(bq);\n\n    assertEquals(1, s.getIndexReader().leaves().size());\n    BulkScorer scorer = w.bulkScorer(s.getIndexReader().leaves().get(0), null);\n\n    final FixedBitSet hits = new FixedBitSet(docCount);\n    final AtomicInteger end = new AtomicInteger();\n    LeafCollector c = new SimpleCollector() {\n\n        @Override\n        public void collect(int doc) {\n          assertTrue(\"collected doc=\" + doc + \" beyond max=\" + end, doc < end.intValue());\n          hits.set(doc);\n        }\n      };\n\n    while (end.intValue() < docCount) {\n      final int inc = TestUtil.nextInt(random(), 1, 1000);\n      end.getAndAdd(inc);\n      scorer.score(c, end.intValue());\n    }\n\n    assertEquals(docCount, hits.cardinality());\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testBooleanScorerMax() throws IOException {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, newIndexWriterConfig(new MockAnalyzer(random())));\n\n    int docCount = atLeast(10000);\n\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"a\", TextField.TYPE_NOT_STORED));\n      riw.addDocument(doc);\n    }\n\n    riw.forceMerge(1);\n    IndexReader r = riw.getReader();\n    riw.close();\n\n    IndexSearcher s = newSearcher(r);\n    BooleanQuery bq = new BooleanQuery();\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n\n    Weight w = s.createNormalizedWeight(bq);\n\n    assertEquals(1, s.getIndexReader().leaves().size());\n    BulkScorer scorer = w.bulkScorer(s.getIndexReader().leaves().get(0), false, null);\n\n    final FixedBitSet hits = new FixedBitSet(docCount);\n    final AtomicInteger end = new AtomicInteger();\n    LeafCollector c = new SimpleCollector() {\n\n        @Override\n        public void collect(int doc) {\n          assertTrue(\"collected doc=\" + doc + \" beyond max=\" + end, doc < end.intValue());\n          hits.set(doc);\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n      };\n\n    while (end.intValue() < docCount) {\n      final int inc = TestUtil.nextInt(random(), 1, 1000);\n      end.getAndAdd(inc);\n      scorer.score(c, end.intValue());\n    }\n\n    assertEquals(docCount, hits.cardinality());\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":["781239fc84d36be12b84e4d3e2618f5f07a182e3"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e166cc9c5f45f78a8dd02332b5ac100221063fd8","date":1421678965,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testBooleanScorerMax().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testBooleanScorerMax().mjava","sourceNew":"  public void testBooleanScorerMax() throws IOException {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, newIndexWriterConfig(new MockAnalyzer(random())));\n\n    int docCount = atLeast(10000);\n\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"a\", TextField.TYPE_NOT_STORED));\n      riw.addDocument(doc);\n    }\n\n    riw.forceMerge(1);\n    IndexReader r = riw.getReader();\n    riw.close();\n\n    IndexSearcher s = newSearcher(r);\n    BooleanQuery bq = new BooleanQuery();\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n\n    Weight w = s.createNormalizedWeight(bq);\n\n    assertEquals(1, s.getIndexReader().leaves().size());\n    BulkScorer scorer = w.bulkScorer(s.getIndexReader().leaves().get(0), null);\n\n    final FixedBitSet hits = new FixedBitSet(docCount);\n    final AtomicInteger end = new AtomicInteger();\n    LeafCollector c = new SimpleCollector() {\n\n        @Override\n        public void collect(int doc) {\n          assertTrue(\"collected doc=\" + doc + \" beyond max=\" + end, doc < end.intValue());\n          hits.set(doc);\n        }\n      };\n\n    while (end.intValue() < docCount) {\n      final int min = end.intValue();\n      final int inc = TestUtil.nextInt(random(), 1, 1000);\n      final int max = end.addAndGet(inc);\n      scorer.score(c, min, max);\n    }\n\n    assertEquals(docCount, hits.cardinality());\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testBooleanScorerMax() throws IOException {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, newIndexWriterConfig(new MockAnalyzer(random())));\n\n    int docCount = atLeast(10000);\n\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"a\", TextField.TYPE_NOT_STORED));\n      riw.addDocument(doc);\n    }\n\n    riw.forceMerge(1);\n    IndexReader r = riw.getReader();\n    riw.close();\n\n    IndexSearcher s = newSearcher(r);\n    BooleanQuery bq = new BooleanQuery();\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n\n    Weight w = s.createNormalizedWeight(bq);\n\n    assertEquals(1, s.getIndexReader().leaves().size());\n    BulkScorer scorer = w.bulkScorer(s.getIndexReader().leaves().get(0), null);\n\n    final FixedBitSet hits = new FixedBitSet(docCount);\n    final AtomicInteger end = new AtomicInteger();\n    LeafCollector c = new SimpleCollector() {\n\n        @Override\n        public void collect(int doc) {\n          assertTrue(\"collected doc=\" + doc + \" beyond max=\" + end, doc < end.intValue());\n          hits.set(doc);\n        }\n      };\n\n    while (end.intValue() < docCount) {\n      final int inc = TestUtil.nextInt(random(), 1, 1000);\n      end.getAndAdd(inc);\n      scorer.score(c, end.intValue());\n    }\n\n    assertEquals(docCount, hits.cardinality());\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"781239fc84d36be12b84e4d3e2618f5f07a182e3","date":1423139668,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testBooleanScorerMax().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testBooleanScorerMax().mjava","sourceNew":"  public void testBooleanScorerMax() throws IOException {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, newIndexWriterConfig(new MockAnalyzer(random())));\n\n    int docCount = atLeast(10000);\n\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"a\", TextField.TYPE_NOT_STORED));\n      riw.addDocument(doc);\n    }\n\n    riw.forceMerge(1);\n    IndexReader r = riw.getReader();\n    riw.close();\n\n    IndexSearcher s = newSearcher(r);\n    BooleanQuery bq = new BooleanQuery();\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n\n    Weight w = s.createNormalizedWeight(bq);\n\n    assertEquals(1, s.getIndexReader().leaves().size());\n    BulkScorer scorer = w.bulkScorer(s.getIndexReader().leaves().get(0), null, true);\n\n    final FixedBitSet hits = new FixedBitSet(docCount);\n    final AtomicInteger end = new AtomicInteger();\n    LeafCollector c = new SimpleCollector() {\n\n        @Override\n        public void collect(int doc) {\n          assertTrue(\"collected doc=\" + doc + \" beyond max=\" + end, doc < end.intValue());\n          hits.set(doc);\n        }\n        \n        @Override\n        public boolean needsScores() {\n          return false;\n        }\n      };\n\n    while (end.intValue() < docCount) {\n      final int min = end.intValue();\n      final int inc = TestUtil.nextInt(random(), 1, 1000);\n      final int max = end.addAndGet(inc);\n      scorer.score(c, min, max);\n    }\n\n    assertEquals(docCount, hits.cardinality());\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testBooleanScorerMax() throws IOException {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, newIndexWriterConfig(new MockAnalyzer(random())));\n\n    int docCount = atLeast(10000);\n\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"a\", TextField.TYPE_NOT_STORED));\n      riw.addDocument(doc);\n    }\n\n    riw.forceMerge(1);\n    IndexReader r = riw.getReader();\n    riw.close();\n\n    IndexSearcher s = newSearcher(r);\n    BooleanQuery bq = new BooleanQuery();\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n\n    Weight w = s.createNormalizedWeight(bq);\n\n    assertEquals(1, s.getIndexReader().leaves().size());\n    BulkScorer scorer = w.bulkScorer(s.getIndexReader().leaves().get(0), null);\n\n    final FixedBitSet hits = new FixedBitSet(docCount);\n    final AtomicInteger end = new AtomicInteger();\n    LeafCollector c = new SimpleCollector() {\n\n        @Override\n        public void collect(int doc) {\n          assertTrue(\"collected doc=\" + doc + \" beyond max=\" + end, doc < end.intValue());\n          hits.set(doc);\n        }\n      };\n\n    while (end.intValue() < docCount) {\n      final int min = end.intValue();\n      final int inc = TestUtil.nextInt(random(), 1, 1000);\n      final int max = end.addAndGet(inc);\n      scorer.score(c, min, max);\n    }\n\n    assertEquals(docCount, hits.cardinality());\n    r.close();\n    dir.close();\n  }\n\n","bugFix":["f582f18c13d4852b01d4fe0a0196432c5c6f2b7f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fb17639909a369c1e64866842e5c213440acc17e","date":1423238093,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testBooleanScorerMax().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testBooleanScorerMax().mjava","sourceNew":"  public void testBooleanScorerMax() throws IOException {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, newIndexWriterConfig(new MockAnalyzer(random())));\n\n    int docCount = atLeast(10000);\n\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"a\", TextField.TYPE_NOT_STORED));\n      riw.addDocument(doc);\n    }\n\n    riw.forceMerge(1);\n    IndexReader r = riw.getReader();\n    riw.close();\n\n    IndexSearcher s = newSearcher(r);\n    BooleanQuery bq = new BooleanQuery();\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n\n    Weight w = s.createNormalizedWeight(bq, true);\n\n    assertEquals(1, s.getIndexReader().leaves().size());\n    BulkScorer scorer = w.bulkScorer(s.getIndexReader().leaves().get(0), null);\n\n    final FixedBitSet hits = new FixedBitSet(docCount);\n    final AtomicInteger end = new AtomicInteger();\n    LeafCollector c = new SimpleCollector() {\n\n        @Override\n        public void collect(int doc) {\n          assertTrue(\"collected doc=\" + doc + \" beyond max=\" + end, doc < end.intValue());\n          hits.set(doc);\n        }\n        \n        @Override\n        public boolean needsScores() {\n          return false;\n        }\n      };\n\n    while (end.intValue() < docCount) {\n      final int min = end.intValue();\n      final int inc = TestUtil.nextInt(random(), 1, 1000);\n      final int max = end.addAndGet(inc);\n      scorer.score(c, min, max);\n    }\n\n    assertEquals(docCount, hits.cardinality());\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testBooleanScorerMax() throws IOException {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, newIndexWriterConfig(new MockAnalyzer(random())));\n\n    int docCount = atLeast(10000);\n\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"a\", TextField.TYPE_NOT_STORED));\n      riw.addDocument(doc);\n    }\n\n    riw.forceMerge(1);\n    IndexReader r = riw.getReader();\n    riw.close();\n\n    IndexSearcher s = newSearcher(r);\n    BooleanQuery bq = new BooleanQuery();\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n\n    Weight w = s.createNormalizedWeight(bq);\n\n    assertEquals(1, s.getIndexReader().leaves().size());\n    BulkScorer scorer = w.bulkScorer(s.getIndexReader().leaves().get(0), null, true);\n\n    final FixedBitSet hits = new FixedBitSet(docCount);\n    final AtomicInteger end = new AtomicInteger();\n    LeafCollector c = new SimpleCollector() {\n\n        @Override\n        public void collect(int doc) {\n          assertTrue(\"collected doc=\" + doc + \" beyond max=\" + end, doc < end.intValue());\n          hits.set(doc);\n        }\n        \n        @Override\n        public boolean needsScores() {\n          return false;\n        }\n      };\n\n    while (end.intValue() < docCount) {\n      final int min = end.intValue();\n      final int inc = TestUtil.nextInt(random(), 1, 1000);\n      final int max = end.addAndGet(inc);\n      scorer.score(c, min, max);\n    }\n\n    assertEquals(docCount, hits.cardinality());\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"954e59be3da8dc1b046646ad7af4b466852009d3","date":1423482367,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testBooleanScorerMax().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testBooleanScorerMax().mjava","sourceNew":"  public void testBooleanScorerMax() throws IOException {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, newIndexWriterConfig(new MockAnalyzer(random())));\n\n    int docCount = atLeast(10000);\n\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"a\", TextField.TYPE_NOT_STORED));\n      riw.addDocument(doc);\n    }\n\n    riw.forceMerge(1);\n    IndexReader r = riw.getReader();\n    riw.close();\n\n    IndexSearcher s = newSearcher(r);\n    BooleanQuery bq = new BooleanQuery();\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n\n    Weight w = s.createNormalizedWeight(bq, PostingsEnum.FLAG_FREQS);\n\n    assertEquals(1, s.getIndexReader().leaves().size());\n    BulkScorer scorer = w.bulkScorer(s.getIndexReader().leaves().get(0), null);\n\n    final FixedBitSet hits = new FixedBitSet(docCount);\n    final AtomicInteger end = new AtomicInteger();\n    LeafCollector c = new SimpleCollector() {\n\n        @Override\n        public void collect(int doc) {\n          assertTrue(\"collected doc=\" + doc + \" beyond max=\" + end, doc < end.intValue());\n          hits.set(doc);\n        }\n        \n        @Override\n        public boolean needsScores() {\n          return false;\n        }\n      };\n\n    while (end.intValue() < docCount) {\n      final int min = end.intValue();\n      final int inc = TestUtil.nextInt(random(), 1, 1000);\n      final int max = end.addAndGet(inc);\n      scorer.score(c, min, max);\n    }\n\n    assertEquals(docCount, hits.cardinality());\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testBooleanScorerMax() throws IOException {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, newIndexWriterConfig(new MockAnalyzer(random())));\n\n    int docCount = atLeast(10000);\n\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"a\", TextField.TYPE_NOT_STORED));\n      riw.addDocument(doc);\n    }\n\n    riw.forceMerge(1);\n    IndexReader r = riw.getReader();\n    riw.close();\n\n    IndexSearcher s = newSearcher(r);\n    BooleanQuery bq = new BooleanQuery();\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n\n    Weight w = s.createNormalizedWeight(bq, true);\n\n    assertEquals(1, s.getIndexReader().leaves().size());\n    BulkScorer scorer = w.bulkScorer(s.getIndexReader().leaves().get(0), null);\n\n    final FixedBitSet hits = new FixedBitSet(docCount);\n    final AtomicInteger end = new AtomicInteger();\n    LeafCollector c = new SimpleCollector() {\n\n        @Override\n        public void collect(int doc) {\n          assertTrue(\"collected doc=\" + doc + \" beyond max=\" + end, doc < end.intValue());\n          hits.set(doc);\n        }\n        \n        @Override\n        public boolean needsScores() {\n          return false;\n        }\n      };\n\n    while (end.intValue() < docCount) {\n      final int min = end.intValue();\n      final int inc = TestUtil.nextInt(random(), 1, 1000);\n      final int max = end.addAndGet(inc);\n      scorer.score(c, min, max);\n    }\n\n    assertEquals(docCount, hits.cardinality());\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6a47d642ab24da1a811adce4bda9cc52c520ca13","date":1423483323,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testBooleanScorerMax().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testBooleanScorerMax().mjava","sourceNew":"  public void testBooleanScorerMax() throws IOException {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, newIndexWriterConfig(new MockAnalyzer(random())));\n\n    int docCount = atLeast(10000);\n\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"a\", TextField.TYPE_NOT_STORED));\n      riw.addDocument(doc);\n    }\n\n    riw.forceMerge(1);\n    IndexReader r = riw.getReader();\n    riw.close();\n\n    IndexSearcher s = newSearcher(r);\n    BooleanQuery bq = new BooleanQuery();\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n\n    Weight w = s.createNormalizedWeight(bq, true);\n\n    assertEquals(1, s.getIndexReader().leaves().size());\n    BulkScorer scorer = w.bulkScorer(s.getIndexReader().leaves().get(0), null);\n\n    final FixedBitSet hits = new FixedBitSet(docCount);\n    final AtomicInteger end = new AtomicInteger();\n    LeafCollector c = new SimpleCollector() {\n\n        @Override\n        public void collect(int doc) {\n          assertTrue(\"collected doc=\" + doc + \" beyond max=\" + end, doc < end.intValue());\n          hits.set(doc);\n        }\n        \n        @Override\n        public boolean needsScores() {\n          return false;\n        }\n      };\n\n    while (end.intValue() < docCount) {\n      final int min = end.intValue();\n      final int inc = TestUtil.nextInt(random(), 1, 1000);\n      final int max = end.addAndGet(inc);\n      scorer.score(c, min, max);\n    }\n\n    assertEquals(docCount, hits.cardinality());\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testBooleanScorerMax() throws IOException {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, newIndexWriterConfig(new MockAnalyzer(random())));\n\n    int docCount = atLeast(10000);\n\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"a\", TextField.TYPE_NOT_STORED));\n      riw.addDocument(doc);\n    }\n\n    riw.forceMerge(1);\n    IndexReader r = riw.getReader();\n    riw.close();\n\n    IndexSearcher s = newSearcher(r);\n    BooleanQuery bq = new BooleanQuery();\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n\n    Weight w = s.createNormalizedWeight(bq, PostingsEnum.FLAG_FREQS);\n\n    assertEquals(1, s.getIndexReader().leaves().size());\n    BulkScorer scorer = w.bulkScorer(s.getIndexReader().leaves().get(0), null);\n\n    final FixedBitSet hits = new FixedBitSet(docCount);\n    final AtomicInteger end = new AtomicInteger();\n    LeafCollector c = new SimpleCollector() {\n\n        @Override\n        public void collect(int doc) {\n          assertTrue(\"collected doc=\" + doc + \" beyond max=\" + end, doc < end.intValue());\n          hits.set(doc);\n        }\n        \n        @Override\n        public boolean needsScores() {\n          return false;\n        }\n      };\n\n    while (end.intValue() < docCount) {\n      final int min = end.intValue();\n      final int inc = TestUtil.nextInt(random(), 1, 1000);\n      final int max = end.addAndGet(inc);\n      scorer.score(c, min, max);\n    }\n\n    assertEquals(docCount, hits.cardinality());\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f68d01cf19df971dcdcb05e30247f4ad7ec9747","date":1434611645,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testBooleanScorerMax().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testBooleanScorerMax().mjava","sourceNew":"  public void testBooleanScorerMax() throws IOException {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, newIndexWriterConfig(new MockAnalyzer(random())));\n\n    int docCount = atLeast(10000);\n\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"a\", TextField.TYPE_NOT_STORED));\n      riw.addDocument(doc);\n    }\n\n    riw.forceMerge(1);\n    IndexReader r = riw.getReader();\n    riw.close();\n\n    IndexSearcher s = newSearcher(r);\n    BooleanQuery.Builder bq = new BooleanQuery.Builder();\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n\n    Weight w = s.createNormalizedWeight(bq.build(), true);\n\n    assertEquals(1, s.getIndexReader().leaves().size());\n    BulkScorer scorer = w.bulkScorer(s.getIndexReader().leaves().get(0), null);\n\n    final FixedBitSet hits = new FixedBitSet(docCount);\n    final AtomicInteger end = new AtomicInteger();\n    LeafCollector c = new SimpleCollector() {\n\n        @Override\n        public void collect(int doc) {\n          assertTrue(\"collected doc=\" + doc + \" beyond max=\" + end, doc < end.intValue());\n          hits.set(doc);\n        }\n        \n        @Override\n        public boolean needsScores() {\n          return false;\n        }\n      };\n\n    while (end.intValue() < docCount) {\n      final int min = end.intValue();\n      final int inc = TestUtil.nextInt(random(), 1, 1000);\n      final int max = end.addAndGet(inc);\n      scorer.score(c, min, max);\n    }\n\n    assertEquals(docCount, hits.cardinality());\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testBooleanScorerMax() throws IOException {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, newIndexWriterConfig(new MockAnalyzer(random())));\n\n    int docCount = atLeast(10000);\n\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"a\", TextField.TYPE_NOT_STORED));\n      riw.addDocument(doc);\n    }\n\n    riw.forceMerge(1);\n    IndexReader r = riw.getReader();\n    riw.close();\n\n    IndexSearcher s = newSearcher(r);\n    BooleanQuery bq = new BooleanQuery();\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n\n    Weight w = s.createNormalizedWeight(bq, true);\n\n    assertEquals(1, s.getIndexReader().leaves().size());\n    BulkScorer scorer = w.bulkScorer(s.getIndexReader().leaves().get(0), null);\n\n    final FixedBitSet hits = new FixedBitSet(docCount);\n    final AtomicInteger end = new AtomicInteger();\n    LeafCollector c = new SimpleCollector() {\n\n        @Override\n        public void collect(int doc) {\n          assertTrue(\"collected doc=\" + doc + \" beyond max=\" + end, doc < end.intValue());\n          hits.set(doc);\n        }\n        \n        @Override\n        public boolean needsScores() {\n          return false;\n        }\n      };\n\n    while (end.intValue() < docCount) {\n      final int min = end.intValue();\n      final int inc = TestUtil.nextInt(random(), 1, 1000);\n      final int max = end.addAndGet(inc);\n      scorer.score(c, min, max);\n    }\n\n    assertEquals(docCount, hits.cardinality());\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f4464508ee83288c8c4585b533f9faaa93aa314","date":1435240759,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testBooleanScorerMax().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testBooleanScorerMax().mjava","sourceNew":"  public void testBooleanScorerMax() throws IOException {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, newIndexWriterConfig(new MockAnalyzer(random())));\n\n    int docCount = atLeast(10000);\n\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"a\", TextField.TYPE_NOT_STORED));\n      riw.addDocument(doc);\n    }\n\n    riw.forceMerge(1);\n    IndexReader r = riw.getReader();\n    riw.close();\n\n    IndexSearcher s = newSearcher(r);\n    BooleanQuery.Builder bq = new BooleanQuery.Builder();\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n\n    Weight w = s.createNormalizedWeight(bq.build(), true);\n\n    assertEquals(1, s.getIndexReader().leaves().size());\n    BulkScorer scorer = w.bulkScorer(s.getIndexReader().leaves().get(0));\n\n    final FixedBitSet hits = new FixedBitSet(docCount);\n    final AtomicInteger end = new AtomicInteger();\n    LeafCollector c = new SimpleCollector() {\n\n        @Override\n        public void collect(int doc) {\n          assertTrue(\"collected doc=\" + doc + \" beyond max=\" + end, doc < end.intValue());\n          hits.set(doc);\n        }\n        \n        @Override\n        public boolean needsScores() {\n          return false;\n        }\n      };\n\n    while (end.intValue() < docCount) {\n      final int min = end.intValue();\n      final int inc = TestUtil.nextInt(random(), 1, 1000);\n      final int max = end.addAndGet(inc);\n      scorer.score(c, null, min, max);\n    }\n\n    assertEquals(docCount, hits.cardinality());\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testBooleanScorerMax() throws IOException {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, newIndexWriterConfig(new MockAnalyzer(random())));\n\n    int docCount = atLeast(10000);\n\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"a\", TextField.TYPE_NOT_STORED));\n      riw.addDocument(doc);\n    }\n\n    riw.forceMerge(1);\n    IndexReader r = riw.getReader();\n    riw.close();\n\n    IndexSearcher s = newSearcher(r);\n    BooleanQuery.Builder bq = new BooleanQuery.Builder();\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n\n    Weight w = s.createNormalizedWeight(bq.build(), true);\n\n    assertEquals(1, s.getIndexReader().leaves().size());\n    BulkScorer scorer = w.bulkScorer(s.getIndexReader().leaves().get(0), null);\n\n    final FixedBitSet hits = new FixedBitSet(docCount);\n    final AtomicInteger end = new AtomicInteger();\n    LeafCollector c = new SimpleCollector() {\n\n        @Override\n        public void collect(int doc) {\n          assertTrue(\"collected doc=\" + doc + \" beyond max=\" + end, doc < end.intValue());\n          hits.set(doc);\n        }\n        \n        @Override\n        public boolean needsScores() {\n          return false;\n        }\n      };\n\n    while (end.intValue() < docCount) {\n      final int min = end.intValue();\n      final int inc = TestUtil.nextInt(random(), 1, 1000);\n      final int max = end.addAndGet(inc);\n      scorer.score(c, min, max);\n    }\n\n    assertEquals(docCount, hits.cardinality());\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9fc47cb7b4346802411bb432f501ed0673d7119e","date":1512640179,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testBooleanScorerMax().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testBooleanScorerMax().mjava","sourceNew":"  public void testBooleanScorerMax() throws IOException {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, newIndexWriterConfig(new MockAnalyzer(random())));\n\n    int docCount = atLeast(10000);\n\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"a\", TextField.TYPE_NOT_STORED));\n      riw.addDocument(doc);\n    }\n\n    riw.forceMerge(1);\n    IndexReader r = riw.getReader();\n    riw.close();\n\n    IndexSearcher s = newSearcher(r);\n    BooleanQuery.Builder bq = new BooleanQuery.Builder();\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n\n    Weight w = s.createNormalizedWeight(bq.build(), ScoreMode.COMPLETE);\n\n    assertEquals(1, s.getIndexReader().leaves().size());\n    BulkScorer scorer = w.bulkScorer(s.getIndexReader().leaves().get(0));\n\n    final FixedBitSet hits = new FixedBitSet(docCount);\n    final AtomicInteger end = new AtomicInteger();\n    LeafCollector c = new SimpleCollector() {\n\n        @Override\n        public void collect(int doc) {\n          assertTrue(\"collected doc=\" + doc + \" beyond max=\" + end, doc < end.intValue());\n          hits.set(doc);\n        }\n        \n        @Override\n        public ScoreMode scoreMode() {\n          return ScoreMode.COMPLETE_NO_SCORES;\n        }\n      };\n\n    while (end.intValue() < docCount) {\n      final int min = end.intValue();\n      final int inc = TestUtil.nextInt(random(), 1, 1000);\n      final int max = end.addAndGet(inc);\n      scorer.score(c, null, min, max);\n    }\n\n    assertEquals(docCount, hits.cardinality());\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testBooleanScorerMax() throws IOException {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, newIndexWriterConfig(new MockAnalyzer(random())));\n\n    int docCount = atLeast(10000);\n\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"a\", TextField.TYPE_NOT_STORED));\n      riw.addDocument(doc);\n    }\n\n    riw.forceMerge(1);\n    IndexReader r = riw.getReader();\n    riw.close();\n\n    IndexSearcher s = newSearcher(r);\n    BooleanQuery.Builder bq = new BooleanQuery.Builder();\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n\n    Weight w = s.createNormalizedWeight(bq.build(), true);\n\n    assertEquals(1, s.getIndexReader().leaves().size());\n    BulkScorer scorer = w.bulkScorer(s.getIndexReader().leaves().get(0));\n\n    final FixedBitSet hits = new FixedBitSet(docCount);\n    final AtomicInteger end = new AtomicInteger();\n    LeafCollector c = new SimpleCollector() {\n\n        @Override\n        public void collect(int doc) {\n          assertTrue(\"collected doc=\" + doc + \" beyond max=\" + end, doc < end.intValue());\n          hits.set(doc);\n        }\n        \n        @Override\n        public boolean needsScores() {\n          return false;\n        }\n      };\n\n    while (end.intValue() < docCount) {\n      final int min = end.intValue();\n      final int inc = TestUtil.nextInt(random(), 1, 1000);\n      final int max = end.addAndGet(inc);\n      scorer.score(c, null, min, max);\n    }\n\n    assertEquals(docCount, hits.cardinality());\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"417142ff08fda9cf0b72d5133e63097a166c6458","date":1512729693,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testBooleanScorerMax().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testBooleanScorerMax().mjava","sourceNew":"  public void testBooleanScorerMax() throws IOException {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, newIndexWriterConfig(new MockAnalyzer(random())));\n\n    int docCount = atLeast(10000);\n\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"a\", TextField.TYPE_NOT_STORED));\n      riw.addDocument(doc);\n    }\n\n    riw.forceMerge(1);\n    IndexReader r = riw.getReader();\n    riw.close();\n\n    IndexSearcher s = newSearcher(r);\n    BooleanQuery.Builder bq = new BooleanQuery.Builder();\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n\n    Weight w = s.createNormalizedWeight(bq.build(), ScoreMode.COMPLETE);\n\n    assertEquals(1, s.getIndexReader().leaves().size());\n    BulkScorer scorer = w.bulkScorer(s.getIndexReader().leaves().get(0));\n\n    final FixedBitSet hits = new FixedBitSet(docCount);\n    final AtomicInteger end = new AtomicInteger();\n    LeafCollector c = new SimpleCollector() {\n\n        @Override\n        public void collect(int doc) {\n          assertTrue(\"collected doc=\" + doc + \" beyond max=\" + end, doc < end.intValue());\n          hits.set(doc);\n        }\n        \n        @Override\n        public ScoreMode scoreMode() {\n          return ScoreMode.COMPLETE_NO_SCORES;\n        }\n      };\n\n    while (end.intValue() < docCount) {\n      final int min = end.intValue();\n      final int inc = TestUtil.nextInt(random(), 1, 1000);\n      final int max = end.addAndGet(inc);\n      scorer.score(c, null, min, max);\n    }\n\n    assertEquals(docCount, hits.cardinality());\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testBooleanScorerMax() throws IOException {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, newIndexWriterConfig(new MockAnalyzer(random())));\n\n    int docCount = atLeast(10000);\n\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"a\", TextField.TYPE_NOT_STORED));\n      riw.addDocument(doc);\n    }\n\n    riw.forceMerge(1);\n    IndexReader r = riw.getReader();\n    riw.close();\n\n    IndexSearcher s = newSearcher(r);\n    BooleanQuery.Builder bq = new BooleanQuery.Builder();\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n\n    Weight w = s.createNormalizedWeight(bq.build(), true);\n\n    assertEquals(1, s.getIndexReader().leaves().size());\n    BulkScorer scorer = w.bulkScorer(s.getIndexReader().leaves().get(0));\n\n    final FixedBitSet hits = new FixedBitSet(docCount);\n    final AtomicInteger end = new AtomicInteger();\n    LeafCollector c = new SimpleCollector() {\n\n        @Override\n        public void collect(int doc) {\n          assertTrue(\"collected doc=\" + doc + \" beyond max=\" + end, doc < end.intValue());\n          hits.set(doc);\n        }\n        \n        @Override\n        public boolean needsScores() {\n          return false;\n        }\n      };\n\n    while (end.intValue() < docCount) {\n      final int min = end.intValue();\n      final int inc = TestUtil.nextInt(random(), 1, 1000);\n      final int max = end.addAndGet(inc);\n      scorer.score(c, null, min, max);\n    }\n\n    assertEquals(docCount, hits.cardinality());\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"475584d5e08a22ad3fc7babefe006d77bc744567","date":1523282824,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testBooleanScorerMax().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testBooleanScorerMax().mjava","sourceNew":"  public void testBooleanScorerMax() throws IOException {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, newIndexWriterConfig(new MockAnalyzer(random())));\n\n    int docCount = atLeast(10000);\n\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"a\", TextField.TYPE_NOT_STORED));\n      riw.addDocument(doc);\n    }\n\n    riw.forceMerge(1);\n    IndexReader r = riw.getReader();\n    riw.close();\n\n    IndexSearcher s = newSearcher(r);\n    BooleanQuery.Builder bq = new BooleanQuery.Builder();\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n\n    Weight w = s.createWeight(s.rewrite(bq.build()), ScoreMode.COMPLETE, 1);\n\n    assertEquals(1, s.getIndexReader().leaves().size());\n    BulkScorer scorer = w.bulkScorer(s.getIndexReader().leaves().get(0));\n\n    final FixedBitSet hits = new FixedBitSet(docCount);\n    final AtomicInteger end = new AtomicInteger();\n    LeafCollector c = new SimpleCollector() {\n\n        @Override\n        public void collect(int doc) {\n          assertTrue(\"collected doc=\" + doc + \" beyond max=\" + end, doc < end.intValue());\n          hits.set(doc);\n        }\n        \n        @Override\n        public ScoreMode scoreMode() {\n          return ScoreMode.COMPLETE_NO_SCORES;\n        }\n      };\n\n    while (end.intValue() < docCount) {\n      final int min = end.intValue();\n      final int inc = TestUtil.nextInt(random(), 1, 1000);\n      final int max = end.addAndGet(inc);\n      scorer.score(c, null, min, max);\n    }\n\n    assertEquals(docCount, hits.cardinality());\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testBooleanScorerMax() throws IOException {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, newIndexWriterConfig(new MockAnalyzer(random())));\n\n    int docCount = atLeast(10000);\n\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"a\", TextField.TYPE_NOT_STORED));\n      riw.addDocument(doc);\n    }\n\n    riw.forceMerge(1);\n    IndexReader r = riw.getReader();\n    riw.close();\n\n    IndexSearcher s = newSearcher(r);\n    BooleanQuery.Builder bq = new BooleanQuery.Builder();\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n\n    Weight w = s.createNormalizedWeight(bq.build(), ScoreMode.COMPLETE);\n\n    assertEquals(1, s.getIndexReader().leaves().size());\n    BulkScorer scorer = w.bulkScorer(s.getIndexReader().leaves().get(0));\n\n    final FixedBitSet hits = new FixedBitSet(docCount);\n    final AtomicInteger end = new AtomicInteger();\n    LeafCollector c = new SimpleCollector() {\n\n        @Override\n        public void collect(int doc) {\n          assertTrue(\"collected doc=\" + doc + \" beyond max=\" + end, doc < end.intValue());\n          hits.set(doc);\n        }\n        \n        @Override\n        public ScoreMode scoreMode() {\n          return ScoreMode.COMPLETE_NO_SCORES;\n        }\n      };\n\n    while (end.intValue() < docCount) {\n      final int min = end.intValue();\n      final int inc = TestUtil.nextInt(random(), 1, 1000);\n      final int max = end.addAndGet(inc);\n      scorer.score(c, null, min, max);\n    }\n\n    assertEquals(docCount, hits.cardinality());\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d58e44159788900f4a2113b84463dc3fbbf80f20","date":1523319203,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testBooleanScorerMax().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestBooleanOr#testBooleanScorerMax().mjava","sourceNew":"  public void testBooleanScorerMax() throws IOException {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, newIndexWriterConfig(new MockAnalyzer(random())));\n\n    int docCount = atLeast(10000);\n\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"a\", TextField.TYPE_NOT_STORED));\n      riw.addDocument(doc);\n    }\n\n    riw.forceMerge(1);\n    IndexReader r = riw.getReader();\n    riw.close();\n\n    IndexSearcher s = newSearcher(r);\n    BooleanQuery.Builder bq = new BooleanQuery.Builder();\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n\n    Weight w = s.createWeight(s.rewrite(bq.build()), ScoreMode.COMPLETE, 1);\n\n    assertEquals(1, s.getIndexReader().leaves().size());\n    BulkScorer scorer = w.bulkScorer(s.getIndexReader().leaves().get(0));\n\n    final FixedBitSet hits = new FixedBitSet(docCount);\n    final AtomicInteger end = new AtomicInteger();\n    LeafCollector c = new SimpleCollector() {\n\n        @Override\n        public void collect(int doc) {\n          assertTrue(\"collected doc=\" + doc + \" beyond max=\" + end, doc < end.intValue());\n          hits.set(doc);\n        }\n        \n        @Override\n        public ScoreMode scoreMode() {\n          return ScoreMode.COMPLETE_NO_SCORES;\n        }\n      };\n\n    while (end.intValue() < docCount) {\n      final int min = end.intValue();\n      final int inc = TestUtil.nextInt(random(), 1, 1000);\n      final int max = end.addAndGet(inc);\n      scorer.score(c, null, min, max);\n    }\n\n    assertEquals(docCount, hits.cardinality());\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testBooleanScorerMax() throws IOException {\n    Directory dir = newDirectory();\n    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, newIndexWriterConfig(new MockAnalyzer(random())));\n\n    int docCount = atLeast(10000);\n\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(newField(\"field\", \"a\", TextField.TYPE_NOT_STORED));\n      riw.addDocument(doc);\n    }\n\n    riw.forceMerge(1);\n    IndexReader r = riw.getReader();\n    riw.close();\n\n    IndexSearcher s = newSearcher(r);\n    BooleanQuery.Builder bq = new BooleanQuery.Builder();\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n    bq.add(new TermQuery(new Term(\"field\", \"a\")), BooleanClause.Occur.SHOULD);\n\n    Weight w = s.createNormalizedWeight(bq.build(), ScoreMode.COMPLETE);\n\n    assertEquals(1, s.getIndexReader().leaves().size());\n    BulkScorer scorer = w.bulkScorer(s.getIndexReader().leaves().get(0));\n\n    final FixedBitSet hits = new FixedBitSet(docCount);\n    final AtomicInteger end = new AtomicInteger();\n    LeafCollector c = new SimpleCollector() {\n\n        @Override\n        public void collect(int doc) {\n          assertTrue(\"collected doc=\" + doc + \" beyond max=\" + end, doc < end.intValue());\n          hits.set(doc);\n        }\n        \n        @Override\n        public ScoreMode scoreMode() {\n          return ScoreMode.COMPLETE_NO_SCORES;\n        }\n      };\n\n    while (end.intValue() < docCount) {\n      final int min = end.intValue();\n      final int inc = TestUtil.nextInt(random(), 1, 1000);\n      final int max = end.addAndGet(inc);\n      scorer.score(c, null, min, max);\n    }\n\n    assertEquals(docCount, hits.cardinality());\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6a47d642ab24da1a811adce4bda9cc52c520ca13":["954e59be3da8dc1b046646ad7af4b466852009d3"],"fb17639909a369c1e64866842e5c213440acc17e":["781239fc84d36be12b84e4d3e2618f5f07a182e3"],"475584d5e08a22ad3fc7babefe006d77bc744567":["417142ff08fda9cf0b72d5133e63097a166c6458"],"60755ef433d2d56d15e4738c8095f50fd02ddc20":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["6a47d642ab24da1a811adce4bda9cc52c520ca13"],"d58e44159788900f4a2113b84463dc3fbbf80f20":["417142ff08fda9cf0b72d5133e63097a166c6458","475584d5e08a22ad3fc7babefe006d77bc744567"],"e166cc9c5f45f78a8dd02332b5ac100221063fd8":["f582f18c13d4852b01d4fe0a0196432c5c6f2b7f"],"15e323346eac5e4685c0a9f2df85eb96b4239bbb":["acf00221f44c5f08ccea014f2492b53af15ecd66","ae73da626f97850c922c42736f808d0378e165f0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["ae73da626f97850c922c42736f808d0378e165f0"],"9fc47cb7b4346802411bb432f501ed0673d7119e":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"47b9e6cdfa7e1fc15944550d1007780d96b4dcb6":["4b53a9a930ee01857178a1b512fbab24642f3fa8"],"2e18c86f811939bfa8cd24046c96ed026f2e9b34":["6613659748fe4411a7dcf85266e55db1f95f7315"],"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"781239fc84d36be12b84e4d3e2618f5f07a182e3":["e166cc9c5f45f78a8dd02332b5ac100221063fd8"],"6613659748fe4411a7dcf85266e55db1f95f7315":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"4b53a9a930ee01857178a1b512fbab24642f3fa8":["60755ef433d2d56d15e4738c8095f50fd02ddc20"],"954e59be3da8dc1b046646ad7af4b466852009d3":["fb17639909a369c1e64866842e5c213440acc17e"],"417142ff08fda9cf0b72d5133e63097a166c6458":["0f4464508ee83288c8c4585b533f9faaa93aa314","9fc47cb7b4346802411bb432f501ed0673d7119e"],"0f4464508ee83288c8c4585b533f9faaa93aa314":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["60755ef433d2d56d15e4738c8095f50fd02ddc20","47b9e6cdfa7e1fc15944550d1007780d96b4dcb6"],"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["54a6bea0b991120a99ad0e2f72ae853fd5ecae0e"],"ae73da626f97850c922c42736f808d0378e165f0":["acf00221f44c5f08ccea014f2492b53af15ecd66"],"a5794e5c995c57444b154b01a9f3c837cd530a77":["2e18c86f811939bfa8cd24046c96ed026f2e9b34"],"acf00221f44c5f08ccea014f2492b53af15ecd66":["6613659748fe4411a7dcf85266e55db1f95f7315","a5794e5c995c57444b154b01a9f3c837cd530a77"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d58e44159788900f4a2113b84463dc3fbbf80f20"]},"commit2Childs":{"6a47d642ab24da1a811adce4bda9cc52c520ca13":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747"],"fb17639909a369c1e64866842e5c213440acc17e":["954e59be3da8dc1b046646ad7af4b466852009d3"],"475584d5e08a22ad3fc7babefe006d77bc744567":["d58e44159788900f4a2113b84463dc3fbbf80f20"],"60755ef433d2d56d15e4738c8095f50fd02ddc20":["4b53a9a930ee01857178a1b512fbab24642f3fa8","d4d69c535930b5cce125cff868d40f6373dc27d4"],"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"d58e44159788900f4a2113b84463dc3fbbf80f20":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e166cc9c5f45f78a8dd02332b5ac100221063fd8":["781239fc84d36be12b84e4d3e2618f5f07a182e3"],"15e323346eac5e4685c0a9f2df85eb96b4239bbb":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["60755ef433d2d56d15e4738c8095f50fd02ddc20"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["54a6bea0b991120a99ad0e2f72ae853fd5ecae0e"],"9fc47cb7b4346802411bb432f501ed0673d7119e":["417142ff08fda9cf0b72d5133e63097a166c6458"],"47b9e6cdfa7e1fc15944550d1007780d96b4dcb6":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"2e18c86f811939bfa8cd24046c96ed026f2e9b34":["a5794e5c995c57444b154b01a9f3c837cd530a77"],"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"781239fc84d36be12b84e4d3e2618f5f07a182e3":["fb17639909a369c1e64866842e5c213440acc17e"],"6613659748fe4411a7dcf85266e55db1f95f7315":["2e18c86f811939bfa8cd24046c96ed026f2e9b34","acf00221f44c5f08ccea014f2492b53af15ecd66"],"4b53a9a930ee01857178a1b512fbab24642f3fa8":["47b9e6cdfa7e1fc15944550d1007780d96b4dcb6"],"954e59be3da8dc1b046646ad7af4b466852009d3":["6a47d642ab24da1a811adce4bda9cc52c520ca13"],"417142ff08fda9cf0b72d5133e63097a166c6458":["475584d5e08a22ad3fc7babefe006d77bc744567","d58e44159788900f4a2113b84463dc3fbbf80f20"],"0f4464508ee83288c8c4585b533f9faaa93aa314":["9fc47cb7b4346802411bb432f501ed0673d7119e","417142ff08fda9cf0b72d5133e63097a166c6458"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["6613659748fe4411a7dcf85266e55db1f95f7315"],"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f":["e166cc9c5f45f78a8dd02332b5ac100221063fd8"],"ae73da626f97850c922c42736f808d0378e165f0":["15e323346eac5e4685c0a9f2df85eb96b4239bbb","ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["f582f18c13d4852b01d4fe0a0196432c5c6f2b7f"],"a5794e5c995c57444b154b01a9f3c837cd530a77":["acf00221f44c5f08ccea014f2492b53af15ecd66"],"acf00221f44c5f08ccea014f2492b53af15ecd66":["15e323346eac5e4685c0a9f2df85eb96b4239bbb","ae73da626f97850c922c42736f808d0378e165f0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["15e323346eac5e4685c0a9f2df85eb96b4239bbb","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}