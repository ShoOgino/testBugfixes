{"path":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery#rewrite(IndexReader).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery#rewrite(IndexReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/BooleanQuery#rewrite(IndexReader).mjava","sourceNew":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if (minNrShouldMatch == 0 && clauses.size() == 1) {                    // optimize 1-clause queries\n      BooleanClause c = clauses.get(0);\n      if (!c.isProhibited()) {\t\t\t  // just return clause\n\n        Query query = c.getQuery().rewrite(reader);    // rewrite first\n\n        if (getBoost() != 1.0f) {                 // incorporate boost\n          if (query == c.getQuery()) {                   // if rewrite was no-op\n            query = (Query)query.clone();         // then clone before boost\n          }\n          // Since the BooleanQuery only has 1 clause, the BooleanQuery will be\n          // written out. Therefore the rewritten Query's boost must incorporate both\n          // the clause's boost, and the boost of the BooleanQuery itself\n          query.setBoost(getBoost() * query.getBoost());\n        }\n\n        return query;\n      }\n    }\n\n    BooleanQuery clone = null;                    // recursively rewrite\n    for (int i = 0 ; i < clauses.size(); i++) {\n      BooleanClause c = clauses.get(i);\n      Query query = c.getQuery().rewrite(reader);\n      if (query != c.getQuery()) {                     // clause rewrote: must clone\n        if (clone == null) {\n          // The BooleanQuery clone is lazily initialized so only initialize\n          // it if a rewritten clause differs from the original clause (and hasn't been\n          // initialized already).  If nothing differs, the clone isn't needlessly created\n          clone = (BooleanQuery)this.clone();\n        }\n        clone.clauses.set(i, new BooleanClause(query, c.getOccur()));\n      }\n    }\n    if (clone != null) {\n      return clone;                               // some clauses rewrote\n    } else\n      return this;                                // no clauses rewrote\n  }\n\n","sourceOld":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if (minNrShouldMatch == 0 && clauses.size() == 1) {                    // optimize 1-clause queries\n      BooleanClause c = clauses.get(0);\n      if (!c.isProhibited()) {\t\t\t  // just return clause\n\n        Query query = c.getQuery().rewrite(reader);    // rewrite first\n\n        if (getBoost() != 1.0f) {                 // incorporate boost\n          if (query == c.getQuery()) {                   // if rewrite was no-op\n            query = (Query)query.clone();         // then clone before boost\n          }\n          // Since the BooleanQuery only has 1 clause, the BooleanQuery will be\n          // written out. Therefore the rewritten Query's boost must incorporate both\n          // the clause's boost, and the boost of the BooleanQuery itself\n          query.setBoost(getBoost() * query.getBoost());\n        }\n\n        return query;\n      }\n    }\n\n    BooleanQuery clone = null;                    // recursively rewrite\n    for (int i = 0 ; i < clauses.size(); i++) {\n      BooleanClause c = clauses.get(i);\n      Query query = c.getQuery().rewrite(reader);\n      if (query != c.getQuery()) {                     // clause rewrote: must clone\n        if (clone == null) {\n          // The BooleanQuery clone is lazily initialized so only initialize\n          // it if a rewritten clause differs from the original clause (and hasn't been\n          // initialized already).  If nothing differs, the clone isn't needlessly created\n          clone = (BooleanQuery)this.clone();\n        }\n        clone.clauses.set(i, new BooleanClause(query, c.getOccur()));\n      }\n    }\n    if (clone != null) {\n      return clone;                               // some clauses rewrote\n    } else\n      return this;                                // no clauses rewrote\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f5bf508bfc98425280b4bb708ab724f718705c9d","date":1332973345,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery#rewrite(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery#rewrite(IndexReader).mjava","sourceNew":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if (minNrShouldMatch == 0 && clauses.size() == 1) {                    // optimize 1-clause queries\n      BooleanClause c = clauses.get(0);\n      if (!c.isProhibited()) {\t\t\t  // just return clause\n\n        Query query = c.getQuery().rewrite(reader);    // rewrite first\n\n        if (getBoost() != 1.0f) {                 // incorporate boost\n          if (query == c.getQuery()) {                   // if rewrite was no-op\n            query = (Query)query.clone();         // then clone before boost\n          }\n          // Since the BooleanQuery only has 1 clause, the BooleanQuery will be\n          // written out. Therefore the rewritten Query's boost must incorporate both\n          // the clause's boost, and the boost of the BooleanQuery itself\n          query.setBoost(getBoost() * query.getBoost());\n        }\n\n        return query;\n      }\n    }\n\n    BooleanQuery clone = null;                    // recursively rewrite\n    for (int i = 0 ; i < clauses.size(); i++) {\n      BooleanClause c = clauses.get(i);\n      Query query = c.getQuery().rewrite(reader);\n      if (query != c.getQuery()) {                     // clause rewrote: must clone\n        if (clone == null) {\n          // The BooleanQuery clone is lazily initialized so only initialize\n          // it if a rewritten clause differs from the original clause (and hasn't been\n          // initialized already).  If nothing differs, the clone isn't needlessly created\n          clone = this.clone();\n        }\n        clone.clauses.set(i, new BooleanClause(query, c.getOccur()));\n      }\n    }\n    if (clone != null) {\n      return clone;                               // some clauses rewrote\n    } else\n      return this;                                // no clauses rewrote\n  }\n\n","sourceOld":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if (minNrShouldMatch == 0 && clauses.size() == 1) {                    // optimize 1-clause queries\n      BooleanClause c = clauses.get(0);\n      if (!c.isProhibited()) {\t\t\t  // just return clause\n\n        Query query = c.getQuery().rewrite(reader);    // rewrite first\n\n        if (getBoost() != 1.0f) {                 // incorporate boost\n          if (query == c.getQuery()) {                   // if rewrite was no-op\n            query = (Query)query.clone();         // then clone before boost\n          }\n          // Since the BooleanQuery only has 1 clause, the BooleanQuery will be\n          // written out. Therefore the rewritten Query's boost must incorporate both\n          // the clause's boost, and the boost of the BooleanQuery itself\n          query.setBoost(getBoost() * query.getBoost());\n        }\n\n        return query;\n      }\n    }\n\n    BooleanQuery clone = null;                    // recursively rewrite\n    for (int i = 0 ; i < clauses.size(); i++) {\n      BooleanClause c = clauses.get(i);\n      Query query = c.getQuery().rewrite(reader);\n      if (query != c.getQuery()) {                     // clause rewrote: must clone\n        if (clone == null) {\n          // The BooleanQuery clone is lazily initialized so only initialize\n          // it if a rewritten clause differs from the original clause (and hasn't been\n          // initialized already).  If nothing differs, the clone isn't needlessly created\n          clone = (BooleanQuery)this.clone();\n        }\n        clone.clauses.set(i, new BooleanClause(query, c.getOccur()));\n      }\n    }\n    if (clone != null) {\n      return clone;                               // some clauses rewrote\n    } else\n      return this;                                // no clauses rewrote\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"399d5903979ca52514d2bc7e3a362e1c45885c94","date":1333042474,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery#rewrite(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery#rewrite(IndexReader).mjava","sourceNew":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if (minNrShouldMatch == 0 && clauses.size() == 1) {                    // optimize 1-clause queries\n      BooleanClause c = clauses.get(0);\n      if (!c.isProhibited()) {\t\t\t  // just return clause\n\n        Query query = c.getQuery().rewrite(reader);    // rewrite first\n\n        if (getBoost() != 1.0f) {                 // incorporate boost\n          if (query == c.getQuery()) {                   // if rewrite was no-op\n            query = query.clone();         // then clone before boost\n          }\n          // Since the BooleanQuery only has 1 clause, the BooleanQuery will be\n          // written out. Therefore the rewritten Query's boost must incorporate both\n          // the clause's boost, and the boost of the BooleanQuery itself\n          query.setBoost(getBoost() * query.getBoost());\n        }\n\n        return query;\n      }\n    }\n\n    BooleanQuery clone = null;                    // recursively rewrite\n    for (int i = 0 ; i < clauses.size(); i++) {\n      BooleanClause c = clauses.get(i);\n      Query query = c.getQuery().rewrite(reader);\n      if (query != c.getQuery()) {                     // clause rewrote: must clone\n        if (clone == null) {\n          // The BooleanQuery clone is lazily initialized so only initialize\n          // it if a rewritten clause differs from the original clause (and hasn't been\n          // initialized already).  If nothing differs, the clone isn't needlessly created\n          clone = this.clone();\n        }\n        clone.clauses.set(i, new BooleanClause(query, c.getOccur()));\n      }\n    }\n    if (clone != null) {\n      return clone;                               // some clauses rewrote\n    } else\n      return this;                                // no clauses rewrote\n  }\n\n","sourceOld":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if (minNrShouldMatch == 0 && clauses.size() == 1) {                    // optimize 1-clause queries\n      BooleanClause c = clauses.get(0);\n      if (!c.isProhibited()) {\t\t\t  // just return clause\n\n        Query query = c.getQuery().rewrite(reader);    // rewrite first\n\n        if (getBoost() != 1.0f) {                 // incorporate boost\n          if (query == c.getQuery()) {                   // if rewrite was no-op\n            query = (Query)query.clone();         // then clone before boost\n          }\n          // Since the BooleanQuery only has 1 clause, the BooleanQuery will be\n          // written out. Therefore the rewritten Query's boost must incorporate both\n          // the clause's boost, and the boost of the BooleanQuery itself\n          query.setBoost(getBoost() * query.getBoost());\n        }\n\n        return query;\n      }\n    }\n\n    BooleanQuery clone = null;                    // recursively rewrite\n    for (int i = 0 ; i < clauses.size(); i++) {\n      BooleanClause c = clauses.get(i);\n      Query query = c.getQuery().rewrite(reader);\n      if (query != c.getQuery()) {                     // clause rewrote: must clone\n        if (clone == null) {\n          // The BooleanQuery clone is lazily initialized so only initialize\n          // it if a rewritten clause differs from the original clause (and hasn't been\n          // initialized already).  If nothing differs, the clone isn't needlessly created\n          clone = this.clone();\n        }\n        clone.clauses.set(i, new BooleanClause(query, c.getOccur()));\n      }\n    }\n    if (clone != null) {\n      return clone;                               // some clauses rewrote\n    } else\n      return this;                                // no clauses rewrote\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4093b270ba337f9c25a4c0e6cb2ae2c07f697376","date":1347897716,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery#rewrite(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery#rewrite(IndexReader).mjava","sourceNew":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if (minNrShouldMatch == 0 && clauses.size() == 1) {                    // optimize 1-clause queries\n      BooleanClause c = clauses.get(0);\n      if (!c.isProhibited()) {  // just return clause\n\n        Query query = c.getQuery().rewrite(reader);    // rewrite first\n\n        if (getBoost() != 1.0f) {                 // incorporate boost\n          if (query == c.getQuery()) {                   // if rewrite was no-op\n            query = query.clone();         // then clone before boost\n          }\n          // Since the BooleanQuery only has 1 clause, the BooleanQuery will be\n          // written out. Therefore the rewritten Query's boost must incorporate both\n          // the clause's boost, and the boost of the BooleanQuery itself\n          query.setBoost(getBoost() * query.getBoost());\n        }\n\n        return query;\n      }\n    }\n\n    BooleanQuery clone = null;                    // recursively rewrite\n    for (int i = 0 ; i < clauses.size(); i++) {\n      BooleanClause c = clauses.get(i);\n      Query query = c.getQuery().rewrite(reader);\n      if (query != c.getQuery()) {                     // clause rewrote: must clone\n        if (clone == null) {\n          // The BooleanQuery clone is lazily initialized so only initialize\n          // it if a rewritten clause differs from the original clause (and hasn't been\n          // initialized already).  If nothing differs, the clone isn't needlessly created\n          clone = this.clone();\n        }\n        clone.clauses.set(i, new BooleanClause(query, c.getOccur()));\n      }\n    }\n    if (clone != null) {\n      return clone;                               // some clauses rewrote\n    } else\n      return this;                                // no clauses rewrote\n  }\n\n","sourceOld":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if (minNrShouldMatch == 0 && clauses.size() == 1) {                    // optimize 1-clause queries\n      BooleanClause c = clauses.get(0);\n      if (!c.isProhibited()) {\t\t\t  // just return clause\n\n        Query query = c.getQuery().rewrite(reader);    // rewrite first\n\n        if (getBoost() != 1.0f) {                 // incorporate boost\n          if (query == c.getQuery()) {                   // if rewrite was no-op\n            query = query.clone();         // then clone before boost\n          }\n          // Since the BooleanQuery only has 1 clause, the BooleanQuery will be\n          // written out. Therefore the rewritten Query's boost must incorporate both\n          // the clause's boost, and the boost of the BooleanQuery itself\n          query.setBoost(getBoost() * query.getBoost());\n        }\n\n        return query;\n      }\n    }\n\n    BooleanQuery clone = null;                    // recursively rewrite\n    for (int i = 0 ; i < clauses.size(); i++) {\n      BooleanClause c = clauses.get(i);\n      Query query = c.getQuery().rewrite(reader);\n      if (query != c.getQuery()) {                     // clause rewrote: must clone\n        if (clone == null) {\n          // The BooleanQuery clone is lazily initialized so only initialize\n          // it if a rewritten clause differs from the original clause (and hasn't been\n          // initialized already).  If nothing differs, the clone isn't needlessly created\n          clone = this.clone();\n        }\n        clone.clauses.set(i, new BooleanClause(query, c.getOccur()));\n      }\n    }\n    if (clone != null) {\n      return clone;                               // some clauses rewrote\n    } else\n      return this;                                // no clauses rewrote\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad158e4c28c7c33b7d3fd5c187a183d014d1f6ea","date":1390928346,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery#rewrite(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery#rewrite(IndexReader).mjava","sourceNew":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if (minNrShouldMatch == 0 && clauses.size() == 1) {                    // optimize 1-clause queries\n      BooleanClause c = clauses.get(0);\n      if (!c.isProhibited()) {  // just return clause\n\n        Query query = c.getQuery().rewrite(reader);    // rewrite first\n\n        if (getBoost() != 1.0f) {                 // incorporate boost\n          if (query == c.getQuery()) {                   // if rewrite was no-op\n            query = query.clone();         // then clone before boost\n          }\n          // Since the BooleanQuery only has 1 clause, the BooleanQuery will be\n          // written out. Therefore the rewritten Query's boost must incorporate both\n          // the clause's boost, and the boost of the BooleanQuery itself\n          query.setBoost(getBoost() * query.getBoost());\n        }\n\n        return query;\n      }\n    }\n\n    BooleanQuery clone = null;                    // recursively rewrite\n    for (int i = 0 ; i < clauses.size(); i++) {\n      BooleanClause c = clauses.get(i);\n      Query query = c.getQuery().rewrite(reader);\n      if (query != c.getQuery()) {                     // clause rewrote: must clone\n        if (clone == null) {\n          // The BooleanQuery clone is lazily initialized so only initialize\n          // it if a rewritten clause differs from the original clause (and hasn't been\n          // initialized already).  If nothing differs, the clone isn't needlessly created\n          clone = this.clone();\n        }\n        clone.clauses.set(i, new BooleanClause(query, c.getOccur()));\n      }\n    }\n    if (clone != null) {\n      return clone;                               // some clauses rewrote\n    } else {\n      return this;                                // no clauses rewrote\n    }\n  }\n\n","sourceOld":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if (minNrShouldMatch == 0 && clauses.size() == 1) {                    // optimize 1-clause queries\n      BooleanClause c = clauses.get(0);\n      if (!c.isProhibited()) {  // just return clause\n\n        Query query = c.getQuery().rewrite(reader);    // rewrite first\n\n        if (getBoost() != 1.0f) {                 // incorporate boost\n          if (query == c.getQuery()) {                   // if rewrite was no-op\n            query = query.clone();         // then clone before boost\n          }\n          // Since the BooleanQuery only has 1 clause, the BooleanQuery will be\n          // written out. Therefore the rewritten Query's boost must incorporate both\n          // the clause's boost, and the boost of the BooleanQuery itself\n          query.setBoost(getBoost() * query.getBoost());\n        }\n\n        return query;\n      }\n    }\n\n    BooleanQuery clone = null;                    // recursively rewrite\n    for (int i = 0 ; i < clauses.size(); i++) {\n      BooleanClause c = clauses.get(i);\n      Query query = c.getQuery().rewrite(reader);\n      if (query != c.getQuery()) {                     // clause rewrote: must clone\n        if (clone == null) {\n          // The BooleanQuery clone is lazily initialized so only initialize\n          // it if a rewritten clause differs from the original clause (and hasn't been\n          // initialized already).  If nothing differs, the clone isn't needlessly created\n          clone = this.clone();\n        }\n        clone.clauses.set(i, new BooleanClause(query, c.getOccur()));\n      }\n    }\n    if (clone != null) {\n      return clone;                               // some clauses rewrote\n    } else\n      return this;                                // no clauses rewrote\n  }\n\n","bugFix":["a4795bed31609723b0b9408337a91aad89d33ee5"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"25f698887111a682424e759ba36083180899a1fd","date":1423588899,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery#rewrite(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery#rewrite(IndexReader).mjava","sourceNew":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if (minNrShouldMatch == 0 && clauses.size() == 1) {                    // optimize 1-clause queries\n      BooleanClause c = clauses.get(0);\n      if (!c.isProhibited()) {  // just return clause\n\n        Query query = c.getQuery().rewrite(reader);    // rewrite first\n\n        if (c.isScoring()) {\n          if (getBoost() != 1.0f) {                 // incorporate boost\n            if (query == c.getQuery()) {                   // if rewrite was no-op\n              query = query.clone();         // then clone before boost\n            }\n            // Since the BooleanQuery only has 1 clause, the BooleanQuery will be\n            // written out. Therefore the rewritten Query's boost must incorporate both\n            // the clause's boost, and the boost of the BooleanQuery itself\n            query.setBoost(getBoost() * query.getBoost());\n          }\n        } else {\n          // our single clause is a filter\n          if (query.getBoost() != 0f) {\n            query = query.clone();\n            query.setBoost(0);\n          }\n        }\n\n        return query;\n      }\n    }\n\n    BooleanQuery clone = null;                    // recursively rewrite\n    for (int i = 0 ; i < clauses.size(); i++) {\n      BooleanClause c = clauses.get(i);\n      Query query = c.getQuery().rewrite(reader);\n      if (query != c.getQuery()) {                     // clause rewrote: must clone\n        if (clone == null) {\n          // The BooleanQuery clone is lazily initialized so only initialize\n          // it if a rewritten clause differs from the original clause (and hasn't been\n          // initialized already).  If nothing differs, the clone isn't needlessly created\n          clone = this.clone();\n        }\n        clone.clauses.set(i, new BooleanClause(query, c.getOccur()));\n      }\n    }\n    if (clone != null) {\n      return clone;                               // some clauses rewrote\n    } else {\n      return this;                                // no clauses rewrote\n    }\n  }\n\n","sourceOld":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if (minNrShouldMatch == 0 && clauses.size() == 1) {                    // optimize 1-clause queries\n      BooleanClause c = clauses.get(0);\n      if (!c.isProhibited()) {  // just return clause\n\n        Query query = c.getQuery().rewrite(reader);    // rewrite first\n\n        if (getBoost() != 1.0f) {                 // incorporate boost\n          if (query == c.getQuery()) {                   // if rewrite was no-op\n            query = query.clone();         // then clone before boost\n          }\n          // Since the BooleanQuery only has 1 clause, the BooleanQuery will be\n          // written out. Therefore the rewritten Query's boost must incorporate both\n          // the clause's boost, and the boost of the BooleanQuery itself\n          query.setBoost(getBoost() * query.getBoost());\n        }\n\n        return query;\n      }\n    }\n\n    BooleanQuery clone = null;                    // recursively rewrite\n    for (int i = 0 ; i < clauses.size(); i++) {\n      BooleanClause c = clauses.get(i);\n      Query query = c.getQuery().rewrite(reader);\n      if (query != c.getQuery()) {                     // clause rewrote: must clone\n        if (clone == null) {\n          // The BooleanQuery clone is lazily initialized so only initialize\n          // it if a rewritten clause differs from the original clause (and hasn't been\n          // initialized already).  If nothing differs, the clone isn't needlessly created\n          clone = this.clone();\n        }\n        clone.clauses.set(i, new BooleanClause(query, c.getOccur()));\n      }\n    }\n    if (clone != null) {\n      return clone;                               // some clauses rewrote\n    } else {\n      return this;                                // no clauses rewrote\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0ab7a7b7d9840c6df78aaf2d36b9e8765da1069c","date":1433506692,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery#rewrite(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery#rewrite(IndexReader).mjava","sourceNew":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if (minNrShouldMatch == 0 && clauses.size() == 1) {                    // optimize 1-clause queries\n      BooleanClause c = clauses.get(0);\n      if (!c.isProhibited()) {  // just return clause\n\n        Query query = c.getQuery().rewrite(reader);    // rewrite first\n\n        if (c.isScoring()) {\n          if (getBoost() != 1.0f) {                 // incorporate boost\n            if (query == c.getQuery()) {                   // if rewrite was no-op\n              query = query.clone();         // then clone before boost\n            }\n            // Since the BooleanQuery only has 1 clause, the BooleanQuery will be\n            // written out. Therefore the rewritten Query's boost must incorporate both\n            // the clause's boost, and the boost of the BooleanQuery itself\n            query.setBoost(getBoost() * query.getBoost());\n          }\n        } else {\n          // our single clause is a filter\n          query = new ConstantScoreQuery(query);\n          query.setBoost(0);\n        }\n\n        return query;\n      }\n    }\n\n    BooleanQuery clone = null;                    // recursively rewrite\n    for (int i = 0 ; i < clauses.size(); i++) {\n      BooleanClause c = clauses.get(i);\n      Query query = c.getQuery().rewrite(reader);\n      if (query != c.getQuery()) {                     // clause rewrote: must clone\n        if (clone == null) {\n          // The BooleanQuery clone is lazily initialized so only initialize\n          // it if a rewritten clause differs from the original clause (and hasn't been\n          // initialized already).  If nothing differs, the clone isn't needlessly created\n          clone = this.clone();\n        }\n        clone.clauses.set(i, new BooleanClause(query, c.getOccur()));\n      }\n    }\n    if (clone != null) {\n      return clone;                               // some clauses rewrote\n    } else {\n      return this;                                // no clauses rewrote\n    }\n  }\n\n","sourceOld":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if (minNrShouldMatch == 0 && clauses.size() == 1) {                    // optimize 1-clause queries\n      BooleanClause c = clauses.get(0);\n      if (!c.isProhibited()) {  // just return clause\n\n        Query query = c.getQuery().rewrite(reader);    // rewrite first\n\n        if (c.isScoring()) {\n          if (getBoost() != 1.0f) {                 // incorporate boost\n            if (query == c.getQuery()) {                   // if rewrite was no-op\n              query = query.clone();         // then clone before boost\n            }\n            // Since the BooleanQuery only has 1 clause, the BooleanQuery will be\n            // written out. Therefore the rewritten Query's boost must incorporate both\n            // the clause's boost, and the boost of the BooleanQuery itself\n            query.setBoost(getBoost() * query.getBoost());\n          }\n        } else {\n          // our single clause is a filter\n          if (query.getBoost() != 0f) {\n            query = query.clone();\n            query.setBoost(0);\n          }\n        }\n\n        return query;\n      }\n    }\n\n    BooleanQuery clone = null;                    // recursively rewrite\n    for (int i = 0 ; i < clauses.size(); i++) {\n      BooleanClause c = clauses.get(i);\n      Query query = c.getQuery().rewrite(reader);\n      if (query != c.getQuery()) {                     // clause rewrote: must clone\n        if (clone == null) {\n          // The BooleanQuery clone is lazily initialized so only initialize\n          // it if a rewritten clause differs from the original clause (and hasn't been\n          // initialized already).  If nothing differs, the clone isn't needlessly created\n          clone = this.clone();\n        }\n        clone.clauses.set(i, new BooleanClause(query, c.getOccur()));\n      }\n    }\n    if (clone != null) {\n      return clone;                               // some clauses rewrote\n    } else {\n      return this;                                // no clauses rewrote\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f68d01cf19df971dcdcb05e30247f4ad7ec9747","date":1434611645,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery#rewrite(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery#rewrite(IndexReader).mjava","sourceNew":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if (minimumNumberShouldMatch == 0 && clauses.size() == 1) {// optimize 1-clause queries\n      BooleanClause c = clauses.get(0);\n      if (!c.isProhibited()) {  // just return clause\n\n        Query query = c.getQuery().rewrite(reader);    // rewrite first\n\n        if (c.isScoring()) {\n          if (getBoost() != 1.0f) {                 // incorporate boost\n            if (query == c.getQuery()) {                   // if rewrite was no-op\n              query = query.clone();         // then clone before boost\n            }\n            // Since the BooleanQuery only has 1 clause, the BooleanQuery will be\n            // written out. Therefore the rewritten Query's boost must incorporate both\n            // the clause's boost, and the boost of the BooleanQuery itself\n            query.setBoost(getBoost() * query.getBoost());\n          }\n        } else {\n          // our single clause is a filter\n          query = new ConstantScoreQuery(query);\n          query.setBoost(0);\n        }\n\n        return query;\n      }\n    }\n\n    BooleanQuery.Builder builder = new BooleanQuery.Builder();\n    builder.setDisableCoord(isCoordDisabled());\n    builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n    boolean actuallyRewritten = false;\n    for (BooleanClause clause : this) {\n      Query query = clause.getQuery();\n      Query rewritten = query.rewrite(reader);\n      if (rewritten != query) {\n        actuallyRewritten = true;\n      }\n      builder.add(rewritten, clause.getOccur());\n    }\n    if (actuallyRewritten) {\n      BooleanQuery rewritten = builder.build();\n      rewritten.setBoost(getBoost());\n      return rewritten;\n    }\n    return super.rewrite(reader);\n  }\n\n","sourceOld":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if (minNrShouldMatch == 0 && clauses.size() == 1) {                    // optimize 1-clause queries\n      BooleanClause c = clauses.get(0);\n      if (!c.isProhibited()) {  // just return clause\n\n        Query query = c.getQuery().rewrite(reader);    // rewrite first\n\n        if (c.isScoring()) {\n          if (getBoost() != 1.0f) {                 // incorporate boost\n            if (query == c.getQuery()) {                   // if rewrite was no-op\n              query = query.clone();         // then clone before boost\n            }\n            // Since the BooleanQuery only has 1 clause, the BooleanQuery will be\n            // written out. Therefore the rewritten Query's boost must incorporate both\n            // the clause's boost, and the boost of the BooleanQuery itself\n            query.setBoost(getBoost() * query.getBoost());\n          }\n        } else {\n          // our single clause is a filter\n          query = new ConstantScoreQuery(query);\n          query.setBoost(0);\n        }\n\n        return query;\n      }\n    }\n\n    BooleanQuery clone = null;                    // recursively rewrite\n    for (int i = 0 ; i < clauses.size(); i++) {\n      BooleanClause c = clauses.get(i);\n      Query query = c.getQuery().rewrite(reader);\n      if (query != c.getQuery()) {                     // clause rewrote: must clone\n        if (clone == null) {\n          // The BooleanQuery clone is lazily initialized so only initialize\n          // it if a rewritten clause differs from the original clause (and hasn't been\n          // initialized already).  If nothing differs, the clone isn't needlessly created\n          clone = this.clone();\n        }\n        clone.clauses.set(i, new BooleanClause(query, c.getOccur()));\n      }\n    }\n    if (clone != null) {\n      return clone;                               // some clauses rewrote\n    } else {\n      return this;                                // no clauses rewrote\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2dfdf766e55e943d942055d7de53c7ad6bc45283","date":1441632886,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery#rewrite(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery#rewrite(IndexReader).mjava","sourceNew":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if (minimumNumberShouldMatch == 0 && clauses.size() == 1) {// optimize 1-clause queries\n      BooleanClause c = clauses.get(0);\n      if (!c.isProhibited()) {  // just return clause\n\n        Query query = c.getQuery();\n\n        if (c.isScoring() == false) {\n          // our single clause is a filter, so we need to disable scoring\n          query = new BoostQuery(new ConstantScoreQuery(query), 0);\n        }\n\n        return query;\n      }\n    }\n\n    BooleanQuery.Builder builder = new BooleanQuery.Builder();\n    builder.setDisableCoord(isCoordDisabled());\n    builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n    boolean actuallyRewritten = false;\n    for (BooleanClause clause : this) {\n      Query query = clause.getQuery();\n      Query rewritten = query.rewrite(reader);\n      if (rewritten != query) {\n        actuallyRewritten = true;\n      }\n      builder.add(rewritten, clause.getOccur());\n    }\n    if (actuallyRewritten) {\n      return builder.build();\n    }\n    return super.rewrite(reader);\n  }\n\n","sourceOld":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if (minimumNumberShouldMatch == 0 && clauses.size() == 1) {// optimize 1-clause queries\n      BooleanClause c = clauses.get(0);\n      if (!c.isProhibited()) {  // just return clause\n\n        Query query = c.getQuery().rewrite(reader);    // rewrite first\n\n        if (c.isScoring()) {\n          if (getBoost() != 1.0f) {                 // incorporate boost\n            if (query == c.getQuery()) {                   // if rewrite was no-op\n              query = query.clone();         // then clone before boost\n            }\n            // Since the BooleanQuery only has 1 clause, the BooleanQuery will be\n            // written out. Therefore the rewritten Query's boost must incorporate both\n            // the clause's boost, and the boost of the BooleanQuery itself\n            query.setBoost(getBoost() * query.getBoost());\n          }\n        } else {\n          // our single clause is a filter\n          query = new ConstantScoreQuery(query);\n          query.setBoost(0);\n        }\n\n        return query;\n      }\n    }\n\n    BooleanQuery.Builder builder = new BooleanQuery.Builder();\n    builder.setDisableCoord(isCoordDisabled());\n    builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n    boolean actuallyRewritten = false;\n    for (BooleanClause clause : this) {\n      Query query = clause.getQuery();\n      Query rewritten = query.rewrite(reader);\n      if (rewritten != query) {\n        actuallyRewritten = true;\n      }\n      builder.add(rewritten, clause.getOccur());\n    }\n    if (actuallyRewritten) {\n      BooleanQuery rewritten = builder.build();\n      rewritten.setBoost(getBoost());\n      return rewritten;\n    }\n    return super.rewrite(reader);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"59a0f907db1bc6eb97b13f9c1ef2191d14b5e632","date":1449148233,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery#rewrite(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery#rewrite(IndexReader).mjava","sourceNew":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    // optimize 1-clause queries\n    if (clauses.size() == 1) {\n      BooleanClause c = clauses.get(0);\n      Query query = c.getQuery();\n      if (minimumNumberShouldMatch == 1 && c.getOccur() == Occur.SHOULD) {\n        return query;\n      } else if (minimumNumberShouldMatch == 0) {\n        switch (c.getOccur()) {\n          case SHOULD:\n          case MUST:\n            return query;\n          case FILTER:\n            // no scoring clauses, so return a score of 0\n            return new BoostQuery(new ConstantScoreQuery(query), 0);\n          case MUST_NOT:\n            // no positive clauses\n            return new MatchNoDocsQuery();\n          default:\n            throw new AssertionError();\n        }\n      }\n    }\n\n    // recursively rewrite\n    {\n      BooleanQuery.Builder builder = new BooleanQuery.Builder();\n      builder.setDisableCoord(isCoordDisabled());\n      builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n      boolean actuallyRewritten = false;\n      for (BooleanClause clause : this) {\n        Query query = clause.getQuery();\n        Query rewritten = query.rewrite(reader);\n        if (rewritten != query) {\n          actuallyRewritten = true;\n        }\n        builder.add(rewritten, clause.getOccur());\n      }\n      if (actuallyRewritten) {\n        return builder.build();\n      }\n    }\n\n    // remove duplicate FILTER and MUST_NOT clauses\n    {\n      int clauseCount = 0;\n      for (Collection<Query> queries : clauseSets.values()) {\n        clauseCount += queries.size();\n      }\n      if (clauseCount != clauses.size()) {\n        // since clauseSets implicitly deduplicates FILTER and MUST_NOT\n        // clauses, this means there were duplicates\n        BooleanQuery.Builder rewritten = new BooleanQuery.Builder();\n        rewritten.setDisableCoord(disableCoord);\n        rewritten.setMinimumNumberShouldMatch(minimumNumberShouldMatch);\n        for (Map.Entry<Occur, Collection<Query>> entry : clauseSets.entrySet()) {\n          final Occur occur = entry.getKey();\n          for (Query query : entry.getValue()) {\n            rewritten.add(query, occur);\n          }\n        }\n        return rewritten.build();\n      }\n    }\n\n    // remove FILTER clauses that are also MUST clauses\n    // or that match all documents\n    if (clauseSets.get(Occur.MUST).size() > 0 && clauseSets.get(Occur.FILTER).size() > 0) {\n      final Set<Query> filters = new HashSet<Query>(clauseSets.get(Occur.FILTER));\n      boolean modified = filters.remove(new MatchAllDocsQuery());\n      modified |= filters.removeAll(clauseSets.get(Occur.MUST));\n      if (modified) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder();\n        builder.setDisableCoord(isCoordDisabled());\n        builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n        for (BooleanClause clause : clauses) {\n          if (clause.getOccur() != Occur.FILTER) {\n            builder.add(clause);\n          }\n        }\n        for (Query filter : filters) {\n          builder.add(filter, Occur.FILTER);\n        }\n        return builder.build();\n      }\n    }\n\n    // Rewrite queries whose single scoring clause is a MUST clause on a\n    // MatchAllDocsQuery to a ConstantScoreQuery\n    {\n      final Collection<Query> musts = clauseSets.get(Occur.MUST);\n      final Collection<Query> filters = clauseSets.get(Occur.FILTER);\n      if (musts.size() == 1\n          && filters.size() > 0) {\n        Query must = musts.iterator().next();\n        float boost = 1f;\n        if (must instanceof BoostQuery) {\n          BoostQuery boostQuery = (BoostQuery) must;\n          must = boostQuery.getQuery();\n          boost = boostQuery.getBoost();\n        }\n        if (must.getClass() == MatchAllDocsQuery.class) {\n          // our single scoring clause matches everything: rewrite to a CSQ on the filter\n          // ignore SHOULD clause for now\n          BooleanQuery.Builder builder = new BooleanQuery.Builder();\n          for (BooleanClause clause : clauses) {\n            switch (clause.getOccur()) {\n              case FILTER:\n              case MUST_NOT:\n                builder.add(clause);\n                break;\n              default:\n                // ignore\n                break;\n            }\n          }\n          Query rewritten = builder.build();\n          rewritten = new ConstantScoreQuery(rewritten);\n          if (boost != 1f) {\n            rewritten = new BoostQuery(rewritten, boost);\n          }\n\n          // now add back the SHOULD clauses\n          builder = new BooleanQuery.Builder()\n            .setDisableCoord(isCoordDisabled())\n            .setMinimumNumberShouldMatch(getMinimumNumberShouldMatch())\n            .add(rewritten, Occur.MUST);\n          for (Query query : clauseSets.get(Occur.SHOULD)) {\n            builder.add(query, Occur.SHOULD);\n          }\n          rewritten = builder.build();\n          return rewritten;\n        }\n      }\n    }\n\n    return super.rewrite(reader);\n  }\n\n","sourceOld":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if (minimumNumberShouldMatch == 0 && clauses.size() == 1) {// optimize 1-clause queries\n      BooleanClause c = clauses.get(0);\n      if (!c.isProhibited()) {  // just return clause\n\n        Query query = c.getQuery();\n\n        if (c.isScoring() == false) {\n          // our single clause is a filter, so we need to disable scoring\n          query = new BoostQuery(new ConstantScoreQuery(query), 0);\n        }\n\n        return query;\n      }\n    }\n\n    BooleanQuery.Builder builder = new BooleanQuery.Builder();\n    builder.setDisableCoord(isCoordDisabled());\n    builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n    boolean actuallyRewritten = false;\n    for (BooleanClause clause : this) {\n      Query query = clause.getQuery();\n      Query rewritten = query.rewrite(reader);\n      if (rewritten != query) {\n        actuallyRewritten = true;\n      }\n      builder.add(rewritten, clause.getOccur());\n    }\n    if (actuallyRewritten) {\n      return builder.build();\n    }\n    return super.rewrite(reader);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d8b3f2faaf05547a6ed4e2769b664522af9514b3","date":1466522779,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery#rewrite(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery#rewrite(IndexReader).mjava","sourceNew":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if (clauses.size() == 0) {\n      return new MatchNoDocsQuery();\n    }\n    \n    // optimize 1-clause queries\n    if (clauses.size() == 1) {\n      BooleanClause c = clauses.get(0);\n      Query query = c.getQuery();\n      if (minimumNumberShouldMatch == 1 && c.getOccur() == Occur.SHOULD) {\n        return query;\n      } else if (minimumNumberShouldMatch == 0) {\n        switch (c.getOccur()) {\n          case SHOULD:\n          case MUST:\n            return query;\n          case FILTER:\n            // no scoring clauses, so return a score of 0\n            return new BoostQuery(new ConstantScoreQuery(query), 0);\n          case MUST_NOT:\n            // no positive clauses\n            return new MatchNoDocsQuery();\n          default:\n            throw new AssertionError();\n        }\n      }\n    }\n\n    // recursively rewrite\n    {\n      BooleanQuery.Builder builder = new BooleanQuery.Builder();\n      builder.setDisableCoord(isCoordDisabled());\n      builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n      boolean actuallyRewritten = false;\n      for (BooleanClause clause : this) {\n        Query query = clause.getQuery();\n        Query rewritten = query.rewrite(reader);\n        if (rewritten != query) {\n          actuallyRewritten = true;\n        }\n        builder.add(rewritten, clause.getOccur());\n      }\n      if (actuallyRewritten) {\n        return builder.build();\n      }\n    }\n\n    // remove duplicate FILTER and MUST_NOT clauses\n    {\n      int clauseCount = 0;\n      for (Collection<Query> queries : clauseSets.values()) {\n        clauseCount += queries.size();\n      }\n      if (clauseCount != clauses.size()) {\n        // since clauseSets implicitly deduplicates FILTER and MUST_NOT\n        // clauses, this means there were duplicates\n        BooleanQuery.Builder rewritten = new BooleanQuery.Builder();\n        rewritten.setDisableCoord(disableCoord);\n        rewritten.setMinimumNumberShouldMatch(minimumNumberShouldMatch);\n        for (Map.Entry<Occur, Collection<Query>> entry : clauseSets.entrySet()) {\n          final Occur occur = entry.getKey();\n          for (Query query : entry.getValue()) {\n            rewritten.add(query, occur);\n          }\n        }\n        return rewritten.build();\n      }\n    }\n\n    // remove FILTER clauses that are also MUST clauses\n    // or that match all documents\n    if (clauseSets.get(Occur.MUST).size() > 0 && clauseSets.get(Occur.FILTER).size() > 0) {\n      final Set<Query> filters = new HashSet<Query>(clauseSets.get(Occur.FILTER));\n      boolean modified = filters.remove(new MatchAllDocsQuery());\n      modified |= filters.removeAll(clauseSets.get(Occur.MUST));\n      if (modified) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder();\n        builder.setDisableCoord(isCoordDisabled());\n        builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n        for (BooleanClause clause : clauses) {\n          if (clause.getOccur() != Occur.FILTER) {\n            builder.add(clause);\n          }\n        }\n        for (Query filter : filters) {\n          builder.add(filter, Occur.FILTER);\n        }\n        return builder.build();\n      }\n    }\n\n    // Rewrite queries whose single scoring clause is a MUST clause on a\n    // MatchAllDocsQuery to a ConstantScoreQuery\n    {\n      final Collection<Query> musts = clauseSets.get(Occur.MUST);\n      final Collection<Query> filters = clauseSets.get(Occur.FILTER);\n      if (musts.size() == 1\n          && filters.size() > 0) {\n        Query must = musts.iterator().next();\n        float boost = 1f;\n        if (must instanceof BoostQuery) {\n          BoostQuery boostQuery = (BoostQuery) must;\n          must = boostQuery.getQuery();\n          boost = boostQuery.getBoost();\n        }\n        if (must.getClass() == MatchAllDocsQuery.class) {\n          // our single scoring clause matches everything: rewrite to a CSQ on the filter\n          // ignore SHOULD clause for now\n          BooleanQuery.Builder builder = new BooleanQuery.Builder();\n          for (BooleanClause clause : clauses) {\n            switch (clause.getOccur()) {\n              case FILTER:\n              case MUST_NOT:\n                builder.add(clause);\n                break;\n              default:\n                // ignore\n                break;\n            }\n          }\n          Query rewritten = builder.build();\n          rewritten = new ConstantScoreQuery(rewritten);\n          if (boost != 1f) {\n            rewritten = new BoostQuery(rewritten, boost);\n          }\n\n          // now add back the SHOULD clauses\n          builder = new BooleanQuery.Builder()\n            .setDisableCoord(isCoordDisabled())\n            .setMinimumNumberShouldMatch(getMinimumNumberShouldMatch())\n            .add(rewritten, Occur.MUST);\n          for (Query query : clauseSets.get(Occur.SHOULD)) {\n            builder.add(query, Occur.SHOULD);\n          }\n          rewritten = builder.build();\n          return rewritten;\n        }\n      }\n    }\n\n    return super.rewrite(reader);\n  }\n\n","sourceOld":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    // optimize 1-clause queries\n    if (clauses.size() == 1) {\n      BooleanClause c = clauses.get(0);\n      Query query = c.getQuery();\n      if (minimumNumberShouldMatch == 1 && c.getOccur() == Occur.SHOULD) {\n        return query;\n      } else if (minimumNumberShouldMatch == 0) {\n        switch (c.getOccur()) {\n          case SHOULD:\n          case MUST:\n            return query;\n          case FILTER:\n            // no scoring clauses, so return a score of 0\n            return new BoostQuery(new ConstantScoreQuery(query), 0);\n          case MUST_NOT:\n            // no positive clauses\n            return new MatchNoDocsQuery();\n          default:\n            throw new AssertionError();\n        }\n      }\n    }\n\n    // recursively rewrite\n    {\n      BooleanQuery.Builder builder = new BooleanQuery.Builder();\n      builder.setDisableCoord(isCoordDisabled());\n      builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n      boolean actuallyRewritten = false;\n      for (BooleanClause clause : this) {\n        Query query = clause.getQuery();\n        Query rewritten = query.rewrite(reader);\n        if (rewritten != query) {\n          actuallyRewritten = true;\n        }\n        builder.add(rewritten, clause.getOccur());\n      }\n      if (actuallyRewritten) {\n        return builder.build();\n      }\n    }\n\n    // remove duplicate FILTER and MUST_NOT clauses\n    {\n      int clauseCount = 0;\n      for (Collection<Query> queries : clauseSets.values()) {\n        clauseCount += queries.size();\n      }\n      if (clauseCount != clauses.size()) {\n        // since clauseSets implicitly deduplicates FILTER and MUST_NOT\n        // clauses, this means there were duplicates\n        BooleanQuery.Builder rewritten = new BooleanQuery.Builder();\n        rewritten.setDisableCoord(disableCoord);\n        rewritten.setMinimumNumberShouldMatch(minimumNumberShouldMatch);\n        for (Map.Entry<Occur, Collection<Query>> entry : clauseSets.entrySet()) {\n          final Occur occur = entry.getKey();\n          for (Query query : entry.getValue()) {\n            rewritten.add(query, occur);\n          }\n        }\n        return rewritten.build();\n      }\n    }\n\n    // remove FILTER clauses that are also MUST clauses\n    // or that match all documents\n    if (clauseSets.get(Occur.MUST).size() > 0 && clauseSets.get(Occur.FILTER).size() > 0) {\n      final Set<Query> filters = new HashSet<Query>(clauseSets.get(Occur.FILTER));\n      boolean modified = filters.remove(new MatchAllDocsQuery());\n      modified |= filters.removeAll(clauseSets.get(Occur.MUST));\n      if (modified) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder();\n        builder.setDisableCoord(isCoordDisabled());\n        builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n        for (BooleanClause clause : clauses) {\n          if (clause.getOccur() != Occur.FILTER) {\n            builder.add(clause);\n          }\n        }\n        for (Query filter : filters) {\n          builder.add(filter, Occur.FILTER);\n        }\n        return builder.build();\n      }\n    }\n\n    // Rewrite queries whose single scoring clause is a MUST clause on a\n    // MatchAllDocsQuery to a ConstantScoreQuery\n    {\n      final Collection<Query> musts = clauseSets.get(Occur.MUST);\n      final Collection<Query> filters = clauseSets.get(Occur.FILTER);\n      if (musts.size() == 1\n          && filters.size() > 0) {\n        Query must = musts.iterator().next();\n        float boost = 1f;\n        if (must instanceof BoostQuery) {\n          BoostQuery boostQuery = (BoostQuery) must;\n          must = boostQuery.getQuery();\n          boost = boostQuery.getBoost();\n        }\n        if (must.getClass() == MatchAllDocsQuery.class) {\n          // our single scoring clause matches everything: rewrite to a CSQ on the filter\n          // ignore SHOULD clause for now\n          BooleanQuery.Builder builder = new BooleanQuery.Builder();\n          for (BooleanClause clause : clauses) {\n            switch (clause.getOccur()) {\n              case FILTER:\n              case MUST_NOT:\n                builder.add(clause);\n                break;\n              default:\n                // ignore\n                break;\n            }\n          }\n          Query rewritten = builder.build();\n          rewritten = new ConstantScoreQuery(rewritten);\n          if (boost != 1f) {\n            rewritten = new BoostQuery(rewritten, boost);\n          }\n\n          // now add back the SHOULD clauses\n          builder = new BooleanQuery.Builder()\n            .setDisableCoord(isCoordDisabled())\n            .setMinimumNumberShouldMatch(getMinimumNumberShouldMatch())\n            .add(rewritten, Occur.MUST);\n          for (Query query : clauseSets.get(Occur.SHOULD)) {\n            builder.add(query, Occur.SHOULD);\n          }\n          rewritten = builder.build();\n          return rewritten;\n        }\n      }\n    }\n\n    return super.rewrite(reader);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c8a0e442f7b61f811680273b25da95994a724466","date":1467878549,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery#rewrite(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery#rewrite(IndexReader).mjava","sourceNew":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if (clauses.size() == 0) {\n      return new MatchNoDocsQuery();\n    }\n    \n    // optimize 1-clause queries\n    if (clauses.size() == 1) {\n      BooleanClause c = clauses.get(0);\n      Query query = c.getQuery();\n      if (minimumNumberShouldMatch == 1 && c.getOccur() == Occur.SHOULD) {\n        return query;\n      } else if (minimumNumberShouldMatch == 0) {\n        switch (c.getOccur()) {\n          case SHOULD:\n          case MUST:\n            return query;\n          case FILTER:\n            // no scoring clauses, so return a score of 0\n            return new BoostQuery(new ConstantScoreQuery(query), 0);\n          case MUST_NOT:\n            // no positive clauses\n            return new MatchNoDocsQuery();\n          default:\n            throw new AssertionError();\n        }\n      }\n    }\n\n    // recursively rewrite\n    {\n      BooleanQuery.Builder builder = new BooleanQuery.Builder();\n      builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n      boolean actuallyRewritten = false;\n      for (BooleanClause clause : this) {\n        Query query = clause.getQuery();\n        Query rewritten = query.rewrite(reader);\n        if (rewritten != query) {\n          actuallyRewritten = true;\n        }\n        builder.add(rewritten, clause.getOccur());\n      }\n      if (actuallyRewritten) {\n        return builder.build();\n      }\n    }\n\n    // remove duplicate FILTER and MUST_NOT clauses\n    {\n      int clauseCount = 0;\n      for (Collection<Query> queries : clauseSets.values()) {\n        clauseCount += queries.size();\n      }\n      if (clauseCount != clauses.size()) {\n        // since clauseSets implicitly deduplicates FILTER and MUST_NOT\n        // clauses, this means there were duplicates\n        BooleanQuery.Builder rewritten = new BooleanQuery.Builder();\n        rewritten.setMinimumNumberShouldMatch(minimumNumberShouldMatch);\n        for (Map.Entry<Occur, Collection<Query>> entry : clauseSets.entrySet()) {\n          final Occur occur = entry.getKey();\n          for (Query query : entry.getValue()) {\n            rewritten.add(query, occur);\n          }\n        }\n        return rewritten.build();\n      }\n    }\n\n    // remove FILTER clauses that are also MUST clauses\n    // or that match all documents\n    if (clauseSets.get(Occur.MUST).size() > 0 && clauseSets.get(Occur.FILTER).size() > 0) {\n      final Set<Query> filters = new HashSet<Query>(clauseSets.get(Occur.FILTER));\n      boolean modified = filters.remove(new MatchAllDocsQuery());\n      modified |= filters.removeAll(clauseSets.get(Occur.MUST));\n      if (modified) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder();\n        builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n        for (BooleanClause clause : clauses) {\n          if (clause.getOccur() != Occur.FILTER) {\n            builder.add(clause);\n          }\n        }\n        for (Query filter : filters) {\n          builder.add(filter, Occur.FILTER);\n        }\n        return builder.build();\n      }\n    }\n\n    // Rewrite queries whose single scoring clause is a MUST clause on a\n    // MatchAllDocsQuery to a ConstantScoreQuery\n    {\n      final Collection<Query> musts = clauseSets.get(Occur.MUST);\n      final Collection<Query> filters = clauseSets.get(Occur.FILTER);\n      if (musts.size() == 1\n          && filters.size() > 0) {\n        Query must = musts.iterator().next();\n        float boost = 1f;\n        if (must instanceof BoostQuery) {\n          BoostQuery boostQuery = (BoostQuery) must;\n          must = boostQuery.getQuery();\n          boost = boostQuery.getBoost();\n        }\n        if (must.getClass() == MatchAllDocsQuery.class) {\n          // our single scoring clause matches everything: rewrite to a CSQ on the filter\n          // ignore SHOULD clause for now\n          BooleanQuery.Builder builder = new BooleanQuery.Builder();\n          for (BooleanClause clause : clauses) {\n            switch (clause.getOccur()) {\n              case FILTER:\n              case MUST_NOT:\n                builder.add(clause);\n                break;\n              default:\n                // ignore\n                break;\n            }\n          }\n          Query rewritten = builder.build();\n          rewritten = new ConstantScoreQuery(rewritten);\n          if (boost != 1f) {\n            rewritten = new BoostQuery(rewritten, boost);\n          }\n\n          // now add back the SHOULD clauses\n          builder = new BooleanQuery.Builder()\n            .setMinimumNumberShouldMatch(getMinimumNumberShouldMatch())\n            .add(rewritten, Occur.MUST);\n          for (Query query : clauseSets.get(Occur.SHOULD)) {\n            builder.add(query, Occur.SHOULD);\n          }\n          rewritten = builder.build();\n          return rewritten;\n        }\n      }\n    }\n\n    return super.rewrite(reader);\n  }\n\n","sourceOld":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if (clauses.size() == 0) {\n      return new MatchNoDocsQuery();\n    }\n    \n    // optimize 1-clause queries\n    if (clauses.size() == 1) {\n      BooleanClause c = clauses.get(0);\n      Query query = c.getQuery();\n      if (minimumNumberShouldMatch == 1 && c.getOccur() == Occur.SHOULD) {\n        return query;\n      } else if (minimumNumberShouldMatch == 0) {\n        switch (c.getOccur()) {\n          case SHOULD:\n          case MUST:\n            return query;\n          case FILTER:\n            // no scoring clauses, so return a score of 0\n            return new BoostQuery(new ConstantScoreQuery(query), 0);\n          case MUST_NOT:\n            // no positive clauses\n            return new MatchNoDocsQuery();\n          default:\n            throw new AssertionError();\n        }\n      }\n    }\n\n    // recursively rewrite\n    {\n      BooleanQuery.Builder builder = new BooleanQuery.Builder();\n      builder.setDisableCoord(isCoordDisabled());\n      builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n      boolean actuallyRewritten = false;\n      for (BooleanClause clause : this) {\n        Query query = clause.getQuery();\n        Query rewritten = query.rewrite(reader);\n        if (rewritten != query) {\n          actuallyRewritten = true;\n        }\n        builder.add(rewritten, clause.getOccur());\n      }\n      if (actuallyRewritten) {\n        return builder.build();\n      }\n    }\n\n    // remove duplicate FILTER and MUST_NOT clauses\n    {\n      int clauseCount = 0;\n      for (Collection<Query> queries : clauseSets.values()) {\n        clauseCount += queries.size();\n      }\n      if (clauseCount != clauses.size()) {\n        // since clauseSets implicitly deduplicates FILTER and MUST_NOT\n        // clauses, this means there were duplicates\n        BooleanQuery.Builder rewritten = new BooleanQuery.Builder();\n        rewritten.setDisableCoord(disableCoord);\n        rewritten.setMinimumNumberShouldMatch(minimumNumberShouldMatch);\n        for (Map.Entry<Occur, Collection<Query>> entry : clauseSets.entrySet()) {\n          final Occur occur = entry.getKey();\n          for (Query query : entry.getValue()) {\n            rewritten.add(query, occur);\n          }\n        }\n        return rewritten.build();\n      }\n    }\n\n    // remove FILTER clauses that are also MUST clauses\n    // or that match all documents\n    if (clauseSets.get(Occur.MUST).size() > 0 && clauseSets.get(Occur.FILTER).size() > 0) {\n      final Set<Query> filters = new HashSet<Query>(clauseSets.get(Occur.FILTER));\n      boolean modified = filters.remove(new MatchAllDocsQuery());\n      modified |= filters.removeAll(clauseSets.get(Occur.MUST));\n      if (modified) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder();\n        builder.setDisableCoord(isCoordDisabled());\n        builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n        for (BooleanClause clause : clauses) {\n          if (clause.getOccur() != Occur.FILTER) {\n            builder.add(clause);\n          }\n        }\n        for (Query filter : filters) {\n          builder.add(filter, Occur.FILTER);\n        }\n        return builder.build();\n      }\n    }\n\n    // Rewrite queries whose single scoring clause is a MUST clause on a\n    // MatchAllDocsQuery to a ConstantScoreQuery\n    {\n      final Collection<Query> musts = clauseSets.get(Occur.MUST);\n      final Collection<Query> filters = clauseSets.get(Occur.FILTER);\n      if (musts.size() == 1\n          && filters.size() > 0) {\n        Query must = musts.iterator().next();\n        float boost = 1f;\n        if (must instanceof BoostQuery) {\n          BoostQuery boostQuery = (BoostQuery) must;\n          must = boostQuery.getQuery();\n          boost = boostQuery.getBoost();\n        }\n        if (must.getClass() == MatchAllDocsQuery.class) {\n          // our single scoring clause matches everything: rewrite to a CSQ on the filter\n          // ignore SHOULD clause for now\n          BooleanQuery.Builder builder = new BooleanQuery.Builder();\n          for (BooleanClause clause : clauses) {\n            switch (clause.getOccur()) {\n              case FILTER:\n              case MUST_NOT:\n                builder.add(clause);\n                break;\n              default:\n                // ignore\n                break;\n            }\n          }\n          Query rewritten = builder.build();\n          rewritten = new ConstantScoreQuery(rewritten);\n          if (boost != 1f) {\n            rewritten = new BoostQuery(rewritten, boost);\n          }\n\n          // now add back the SHOULD clauses\n          builder = new BooleanQuery.Builder()\n            .setDisableCoord(isCoordDisabled())\n            .setMinimumNumberShouldMatch(getMinimumNumberShouldMatch())\n            .add(rewritten, Occur.MUST);\n          for (Query query : clauseSets.get(Occur.SHOULD)) {\n            builder.add(query, Occur.SHOULD);\n          }\n          rewritten = builder.build();\n          return rewritten;\n        }\n      }\n    }\n\n    return super.rewrite(reader);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4778b794a897685e2f6c62caa1ac04983d1e69f","date":1467997674,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery#rewrite(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery#rewrite(IndexReader).mjava","sourceNew":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if (clauses.size() == 0) {\n      return new MatchNoDocsQuery(\"empty BooleanQuery\");\n    }\n    \n    // optimize 1-clause queries\n    if (clauses.size() == 1) {\n      BooleanClause c = clauses.get(0);\n      Query query = c.getQuery();\n      if (minimumNumberShouldMatch == 1 && c.getOccur() == Occur.SHOULD) {\n        return query;\n      } else if (minimumNumberShouldMatch == 0) {\n        switch (c.getOccur()) {\n          case SHOULD:\n          case MUST:\n            return query;\n          case FILTER:\n            // no scoring clauses, so return a score of 0\n            return new BoostQuery(new ConstantScoreQuery(query), 0);\n          case MUST_NOT:\n            // no positive clauses\n            return new MatchNoDocsQuery(\"pure negative BooleanQuery\");\n          default:\n            throw new AssertionError();\n        }\n      }\n    }\n\n    // recursively rewrite\n    {\n      BooleanQuery.Builder builder = new BooleanQuery.Builder();\n      builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n      boolean actuallyRewritten = false;\n      for (BooleanClause clause : this) {\n        Query query = clause.getQuery();\n        Query rewritten = query.rewrite(reader);\n        if (rewritten != query) {\n          actuallyRewritten = true;\n        }\n        builder.add(rewritten, clause.getOccur());\n      }\n      if (actuallyRewritten) {\n        return builder.build();\n      }\n    }\n\n    // remove duplicate FILTER and MUST_NOT clauses\n    {\n      int clauseCount = 0;\n      for (Collection<Query> queries : clauseSets.values()) {\n        clauseCount += queries.size();\n      }\n      if (clauseCount != clauses.size()) {\n        // since clauseSets implicitly deduplicates FILTER and MUST_NOT\n        // clauses, this means there were duplicates\n        BooleanQuery.Builder rewritten = new BooleanQuery.Builder();\n        rewritten.setMinimumNumberShouldMatch(minimumNumberShouldMatch);\n        for (Map.Entry<Occur, Collection<Query>> entry : clauseSets.entrySet()) {\n          final Occur occur = entry.getKey();\n          for (Query query : entry.getValue()) {\n            rewritten.add(query, occur);\n          }\n        }\n        return rewritten.build();\n      }\n    }\n\n    // remove FILTER clauses that are also MUST clauses\n    // or that match all documents\n    if (clauseSets.get(Occur.MUST).size() > 0 && clauseSets.get(Occur.FILTER).size() > 0) {\n      final Set<Query> filters = new HashSet<Query>(clauseSets.get(Occur.FILTER));\n      boolean modified = filters.remove(new MatchAllDocsQuery());\n      modified |= filters.removeAll(clauseSets.get(Occur.MUST));\n      if (modified) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder();\n        builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n        for (BooleanClause clause : clauses) {\n          if (clause.getOccur() != Occur.FILTER) {\n            builder.add(clause);\n          }\n        }\n        for (Query filter : filters) {\n          builder.add(filter, Occur.FILTER);\n        }\n        return builder.build();\n      }\n    }\n\n    // Rewrite queries whose single scoring clause is a MUST clause on a\n    // MatchAllDocsQuery to a ConstantScoreQuery\n    {\n      final Collection<Query> musts = clauseSets.get(Occur.MUST);\n      final Collection<Query> filters = clauseSets.get(Occur.FILTER);\n      if (musts.size() == 1\n          && filters.size() > 0) {\n        Query must = musts.iterator().next();\n        float boost = 1f;\n        if (must instanceof BoostQuery) {\n          BoostQuery boostQuery = (BoostQuery) must;\n          must = boostQuery.getQuery();\n          boost = boostQuery.getBoost();\n        }\n        if (must.getClass() == MatchAllDocsQuery.class) {\n          // our single scoring clause matches everything: rewrite to a CSQ on the filter\n          // ignore SHOULD clause for now\n          BooleanQuery.Builder builder = new BooleanQuery.Builder();\n          for (BooleanClause clause : clauses) {\n            switch (clause.getOccur()) {\n              case FILTER:\n              case MUST_NOT:\n                builder.add(clause);\n                break;\n              default:\n                // ignore\n                break;\n            }\n          }\n          Query rewritten = builder.build();\n          rewritten = new ConstantScoreQuery(rewritten);\n          if (boost != 1f) {\n            rewritten = new BoostQuery(rewritten, boost);\n          }\n\n          // now add back the SHOULD clauses\n          builder = new BooleanQuery.Builder()\n            .setMinimumNumberShouldMatch(getMinimumNumberShouldMatch())\n            .add(rewritten, Occur.MUST);\n          for (Query query : clauseSets.get(Occur.SHOULD)) {\n            builder.add(query, Occur.SHOULD);\n          }\n          rewritten = builder.build();\n          return rewritten;\n        }\n      }\n    }\n\n    return super.rewrite(reader);\n  }\n\n","sourceOld":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if (clauses.size() == 0) {\n      return new MatchNoDocsQuery();\n    }\n    \n    // optimize 1-clause queries\n    if (clauses.size() == 1) {\n      BooleanClause c = clauses.get(0);\n      Query query = c.getQuery();\n      if (minimumNumberShouldMatch == 1 && c.getOccur() == Occur.SHOULD) {\n        return query;\n      } else if (minimumNumberShouldMatch == 0) {\n        switch (c.getOccur()) {\n          case SHOULD:\n          case MUST:\n            return query;\n          case FILTER:\n            // no scoring clauses, so return a score of 0\n            return new BoostQuery(new ConstantScoreQuery(query), 0);\n          case MUST_NOT:\n            // no positive clauses\n            return new MatchNoDocsQuery();\n          default:\n            throw new AssertionError();\n        }\n      }\n    }\n\n    // recursively rewrite\n    {\n      BooleanQuery.Builder builder = new BooleanQuery.Builder();\n      builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n      boolean actuallyRewritten = false;\n      for (BooleanClause clause : this) {\n        Query query = clause.getQuery();\n        Query rewritten = query.rewrite(reader);\n        if (rewritten != query) {\n          actuallyRewritten = true;\n        }\n        builder.add(rewritten, clause.getOccur());\n      }\n      if (actuallyRewritten) {\n        return builder.build();\n      }\n    }\n\n    // remove duplicate FILTER and MUST_NOT clauses\n    {\n      int clauseCount = 0;\n      for (Collection<Query> queries : clauseSets.values()) {\n        clauseCount += queries.size();\n      }\n      if (clauseCount != clauses.size()) {\n        // since clauseSets implicitly deduplicates FILTER and MUST_NOT\n        // clauses, this means there were duplicates\n        BooleanQuery.Builder rewritten = new BooleanQuery.Builder();\n        rewritten.setMinimumNumberShouldMatch(minimumNumberShouldMatch);\n        for (Map.Entry<Occur, Collection<Query>> entry : clauseSets.entrySet()) {\n          final Occur occur = entry.getKey();\n          for (Query query : entry.getValue()) {\n            rewritten.add(query, occur);\n          }\n        }\n        return rewritten.build();\n      }\n    }\n\n    // remove FILTER clauses that are also MUST clauses\n    // or that match all documents\n    if (clauseSets.get(Occur.MUST).size() > 0 && clauseSets.get(Occur.FILTER).size() > 0) {\n      final Set<Query> filters = new HashSet<Query>(clauseSets.get(Occur.FILTER));\n      boolean modified = filters.remove(new MatchAllDocsQuery());\n      modified |= filters.removeAll(clauseSets.get(Occur.MUST));\n      if (modified) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder();\n        builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n        for (BooleanClause clause : clauses) {\n          if (clause.getOccur() != Occur.FILTER) {\n            builder.add(clause);\n          }\n        }\n        for (Query filter : filters) {\n          builder.add(filter, Occur.FILTER);\n        }\n        return builder.build();\n      }\n    }\n\n    // Rewrite queries whose single scoring clause is a MUST clause on a\n    // MatchAllDocsQuery to a ConstantScoreQuery\n    {\n      final Collection<Query> musts = clauseSets.get(Occur.MUST);\n      final Collection<Query> filters = clauseSets.get(Occur.FILTER);\n      if (musts.size() == 1\n          && filters.size() > 0) {\n        Query must = musts.iterator().next();\n        float boost = 1f;\n        if (must instanceof BoostQuery) {\n          BoostQuery boostQuery = (BoostQuery) must;\n          must = boostQuery.getQuery();\n          boost = boostQuery.getBoost();\n        }\n        if (must.getClass() == MatchAllDocsQuery.class) {\n          // our single scoring clause matches everything: rewrite to a CSQ on the filter\n          // ignore SHOULD clause for now\n          BooleanQuery.Builder builder = new BooleanQuery.Builder();\n          for (BooleanClause clause : clauses) {\n            switch (clause.getOccur()) {\n              case FILTER:\n              case MUST_NOT:\n                builder.add(clause);\n                break;\n              default:\n                // ignore\n                break;\n            }\n          }\n          Query rewritten = builder.build();\n          rewritten = new ConstantScoreQuery(rewritten);\n          if (boost != 1f) {\n            rewritten = new BoostQuery(rewritten, boost);\n          }\n\n          // now add back the SHOULD clauses\n          builder = new BooleanQuery.Builder()\n            .setMinimumNumberShouldMatch(getMinimumNumberShouldMatch())\n            .add(rewritten, Occur.MUST);\n          for (Query query : clauseSets.get(Occur.SHOULD)) {\n            builder.add(query, Occur.SHOULD);\n          }\n          rewritten = builder.build();\n          return rewritten;\n        }\n      }\n    }\n\n    return super.rewrite(reader);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f3386f642cc92d1c5f226b8207f420c0b03aaefd","date":1472132930,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery#rewrite(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery#rewrite(IndexReader).mjava","sourceNew":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if (clauses.size() == 0) {\n      return new MatchNoDocsQuery(\"empty BooleanQuery\");\n    }\n    \n    // optimize 1-clause queries\n    if (clauses.size() == 1) {\n      BooleanClause c = clauses.get(0);\n      Query query = c.getQuery();\n      if (minimumNumberShouldMatch == 1 && c.getOccur() == Occur.SHOULD) {\n        return query;\n      } else if (minimumNumberShouldMatch == 0) {\n        switch (c.getOccur()) {\n          case SHOULD:\n          case MUST:\n            return query;\n          case FILTER:\n            // no scoring clauses, so return a score of 0\n            return new BoostQuery(new ConstantScoreQuery(query), 0);\n          case MUST_NOT:\n            // no positive clauses\n            return new MatchNoDocsQuery(\"pure negative BooleanQuery\");\n          default:\n            throw new AssertionError();\n        }\n      }\n    }\n\n    // recursively rewrite\n    {\n      BooleanQuery.Builder builder = new BooleanQuery.Builder();\n      builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n      boolean actuallyRewritten = false;\n      for (BooleanClause clause : this) {\n        Query query = clause.getQuery();\n        Query rewritten = query.rewrite(reader);\n        if (rewritten != query) {\n          actuallyRewritten = true;\n        }\n        builder.add(rewritten, clause.getOccur());\n      }\n      if (actuallyRewritten) {\n        return builder.build();\n      }\n    }\n\n    // remove duplicate FILTER and MUST_NOT clauses\n    {\n      int clauseCount = 0;\n      for (Collection<Query> queries : clauseSets.values()) {\n        clauseCount += queries.size();\n      }\n      if (clauseCount != clauses.size()) {\n        // since clauseSets implicitly deduplicates FILTER and MUST_NOT\n        // clauses, this means there were duplicates\n        BooleanQuery.Builder rewritten = new BooleanQuery.Builder();\n        rewritten.setMinimumNumberShouldMatch(minimumNumberShouldMatch);\n        for (Map.Entry<Occur, Collection<Query>> entry : clauseSets.entrySet()) {\n          final Occur occur = entry.getKey();\n          for (Query query : entry.getValue()) {\n            rewritten.add(query, occur);\n          }\n        }\n        return rewritten.build();\n      }\n    }\n\n    // Check whether some clauses are both required and excluded\n    if (clauseSets.get(Occur.MUST_NOT).size() > 0) {\n      final Set<Query> reqAndExclQueries = new HashSet<Query>(clauseSets.get(Occur.FILTER));\n      reqAndExclQueries.addAll(clauseSets.get(Occur.MUST));\n      reqAndExclQueries.retainAll(clauseSets.get(Occur.MUST_NOT));\n\n      if (reqAndExclQueries.isEmpty() == false) {\n        return new MatchNoDocsQuery(\"FILTER or MUST clause also in MUST_NOT\");\n      }\n    }\n\n    // remove FILTER clauses that are also MUST clauses\n    // or that match all documents\n    if (clauseSets.get(Occur.MUST).size() > 0 && clauseSets.get(Occur.FILTER).size() > 0) {\n      final Set<Query> filters = new HashSet<Query>(clauseSets.get(Occur.FILTER));\n      boolean modified = filters.remove(new MatchAllDocsQuery());\n      modified |= filters.removeAll(clauseSets.get(Occur.MUST));\n      if (modified) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder();\n        builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n        for (BooleanClause clause : clauses) {\n          if (clause.getOccur() != Occur.FILTER) {\n            builder.add(clause);\n          }\n        }\n        for (Query filter : filters) {\n          builder.add(filter, Occur.FILTER);\n        }\n        return builder.build();\n      }\n    }\n\n    // convert FILTER clauses that are also SHOULD clauses to MUST clauses\n    if (clauseSets.get(Occur.SHOULD).size() > 0 && clauseSets.get(Occur.FILTER).size() > 0) {\n      final Collection<Query> filters = clauseSets.get(Occur.FILTER);\n      final Collection<Query> shoulds = clauseSets.get(Occur.SHOULD);\n\n      Set<Query> intersection = new HashSet<>(filters);\n      intersection.retainAll(shoulds);\n\n      if (intersection.isEmpty() == false) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder();\n        int minShouldMatch = getMinimumNumberShouldMatch();\n\n        for (BooleanClause clause : clauses) {\n          if (intersection.contains(clause.getQuery())) {\n            if (clause.getOccur() == Occur.SHOULD) {\n              builder.add(new BooleanClause(clause.getQuery(), Occur.MUST));\n              minShouldMatch--;\n            }\n          } else {\n            builder.add(clause);\n          }\n        }\n\n        builder.setMinimumNumberShouldMatch(Math.max(0, minShouldMatch));\n        return builder.build();\n      }\n    }\n\n\n    // Rewrite queries whose single scoring clause is a MUST clause on a\n    // MatchAllDocsQuery to a ConstantScoreQuery\n    {\n      final Collection<Query> musts = clauseSets.get(Occur.MUST);\n      final Collection<Query> filters = clauseSets.get(Occur.FILTER);\n      if (musts.size() == 1\n          && filters.size() > 0) {\n        Query must = musts.iterator().next();\n        float boost = 1f;\n        if (must instanceof BoostQuery) {\n          BoostQuery boostQuery = (BoostQuery) must;\n          must = boostQuery.getQuery();\n          boost = boostQuery.getBoost();\n        }\n        if (must.getClass() == MatchAllDocsQuery.class) {\n          // our single scoring clause matches everything: rewrite to a CSQ on the filter\n          // ignore SHOULD clause for now\n          BooleanQuery.Builder builder = new BooleanQuery.Builder();\n          for (BooleanClause clause : clauses) {\n            switch (clause.getOccur()) {\n              case FILTER:\n              case MUST_NOT:\n                builder.add(clause);\n                break;\n              default:\n                // ignore\n                break;\n            }\n          }\n          Query rewritten = builder.build();\n          rewritten = new ConstantScoreQuery(rewritten);\n          if (boost != 1f) {\n            rewritten = new BoostQuery(rewritten, boost);\n          }\n\n          // now add back the SHOULD clauses\n          builder = new BooleanQuery.Builder()\n            .setMinimumNumberShouldMatch(getMinimumNumberShouldMatch())\n            .add(rewritten, Occur.MUST);\n          for (Query query : clauseSets.get(Occur.SHOULD)) {\n            builder.add(query, Occur.SHOULD);\n          }\n          rewritten = builder.build();\n          return rewritten;\n        }\n      }\n    }\n\n    return super.rewrite(reader);\n  }\n\n","sourceOld":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if (clauses.size() == 0) {\n      return new MatchNoDocsQuery(\"empty BooleanQuery\");\n    }\n    \n    // optimize 1-clause queries\n    if (clauses.size() == 1) {\n      BooleanClause c = clauses.get(0);\n      Query query = c.getQuery();\n      if (minimumNumberShouldMatch == 1 && c.getOccur() == Occur.SHOULD) {\n        return query;\n      } else if (minimumNumberShouldMatch == 0) {\n        switch (c.getOccur()) {\n          case SHOULD:\n          case MUST:\n            return query;\n          case FILTER:\n            // no scoring clauses, so return a score of 0\n            return new BoostQuery(new ConstantScoreQuery(query), 0);\n          case MUST_NOT:\n            // no positive clauses\n            return new MatchNoDocsQuery(\"pure negative BooleanQuery\");\n          default:\n            throw new AssertionError();\n        }\n      }\n    }\n\n    // recursively rewrite\n    {\n      BooleanQuery.Builder builder = new BooleanQuery.Builder();\n      builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n      boolean actuallyRewritten = false;\n      for (BooleanClause clause : this) {\n        Query query = clause.getQuery();\n        Query rewritten = query.rewrite(reader);\n        if (rewritten != query) {\n          actuallyRewritten = true;\n        }\n        builder.add(rewritten, clause.getOccur());\n      }\n      if (actuallyRewritten) {\n        return builder.build();\n      }\n    }\n\n    // remove duplicate FILTER and MUST_NOT clauses\n    {\n      int clauseCount = 0;\n      for (Collection<Query> queries : clauseSets.values()) {\n        clauseCount += queries.size();\n      }\n      if (clauseCount != clauses.size()) {\n        // since clauseSets implicitly deduplicates FILTER and MUST_NOT\n        // clauses, this means there were duplicates\n        BooleanQuery.Builder rewritten = new BooleanQuery.Builder();\n        rewritten.setMinimumNumberShouldMatch(minimumNumberShouldMatch);\n        for (Map.Entry<Occur, Collection<Query>> entry : clauseSets.entrySet()) {\n          final Occur occur = entry.getKey();\n          for (Query query : entry.getValue()) {\n            rewritten.add(query, occur);\n          }\n        }\n        return rewritten.build();\n      }\n    }\n\n    // remove FILTER clauses that are also MUST clauses\n    // or that match all documents\n    if (clauseSets.get(Occur.MUST).size() > 0 && clauseSets.get(Occur.FILTER).size() > 0) {\n      final Set<Query> filters = new HashSet<Query>(clauseSets.get(Occur.FILTER));\n      boolean modified = filters.remove(new MatchAllDocsQuery());\n      modified |= filters.removeAll(clauseSets.get(Occur.MUST));\n      if (modified) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder();\n        builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n        for (BooleanClause clause : clauses) {\n          if (clause.getOccur() != Occur.FILTER) {\n            builder.add(clause);\n          }\n        }\n        for (Query filter : filters) {\n          builder.add(filter, Occur.FILTER);\n        }\n        return builder.build();\n      }\n    }\n\n    // Rewrite queries whose single scoring clause is a MUST clause on a\n    // MatchAllDocsQuery to a ConstantScoreQuery\n    {\n      final Collection<Query> musts = clauseSets.get(Occur.MUST);\n      final Collection<Query> filters = clauseSets.get(Occur.FILTER);\n      if (musts.size() == 1\n          && filters.size() > 0) {\n        Query must = musts.iterator().next();\n        float boost = 1f;\n        if (must instanceof BoostQuery) {\n          BoostQuery boostQuery = (BoostQuery) must;\n          must = boostQuery.getQuery();\n          boost = boostQuery.getBoost();\n        }\n        if (must.getClass() == MatchAllDocsQuery.class) {\n          // our single scoring clause matches everything: rewrite to a CSQ on the filter\n          // ignore SHOULD clause for now\n          BooleanQuery.Builder builder = new BooleanQuery.Builder();\n          for (BooleanClause clause : clauses) {\n            switch (clause.getOccur()) {\n              case FILTER:\n              case MUST_NOT:\n                builder.add(clause);\n                break;\n              default:\n                // ignore\n                break;\n            }\n          }\n          Query rewritten = builder.build();\n          rewritten = new ConstantScoreQuery(rewritten);\n          if (boost != 1f) {\n            rewritten = new BoostQuery(rewritten, boost);\n          }\n\n          // now add back the SHOULD clauses\n          builder = new BooleanQuery.Builder()\n            .setMinimumNumberShouldMatch(getMinimumNumberShouldMatch())\n            .add(rewritten, Occur.MUST);\n          for (Query query : clauseSets.get(Occur.SHOULD)) {\n            builder.add(query, Occur.SHOULD);\n          }\n          rewritten = builder.build();\n          return rewritten;\n        }\n      }\n    }\n\n    return super.rewrite(reader);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a","date":1472163016,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery#rewrite(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery#rewrite(IndexReader).mjava","sourceNew":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if (clauses.size() == 0) {\n      return new MatchNoDocsQuery(\"empty BooleanQuery\");\n    }\n    \n    // optimize 1-clause queries\n    if (clauses.size() == 1) {\n      BooleanClause c = clauses.get(0);\n      Query query = c.getQuery();\n      if (minimumNumberShouldMatch == 1 && c.getOccur() == Occur.SHOULD) {\n        return query;\n      } else if (minimumNumberShouldMatch == 0) {\n        switch (c.getOccur()) {\n          case SHOULD:\n          case MUST:\n            return query;\n          case FILTER:\n            // no scoring clauses, so return a score of 0\n            return new BoostQuery(new ConstantScoreQuery(query), 0);\n          case MUST_NOT:\n            // no positive clauses\n            return new MatchNoDocsQuery(\"pure negative BooleanQuery\");\n          default:\n            throw new AssertionError();\n        }\n      }\n    }\n\n    // recursively rewrite\n    {\n      BooleanQuery.Builder builder = new BooleanQuery.Builder();\n      builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n      boolean actuallyRewritten = false;\n      for (BooleanClause clause : this) {\n        Query query = clause.getQuery();\n        Query rewritten = query.rewrite(reader);\n        if (rewritten != query) {\n          actuallyRewritten = true;\n        }\n        builder.add(rewritten, clause.getOccur());\n      }\n      if (actuallyRewritten) {\n        return builder.build();\n      }\n    }\n\n    // remove duplicate FILTER and MUST_NOT clauses\n    {\n      int clauseCount = 0;\n      for (Collection<Query> queries : clauseSets.values()) {\n        clauseCount += queries.size();\n      }\n      if (clauseCount != clauses.size()) {\n        // since clauseSets implicitly deduplicates FILTER and MUST_NOT\n        // clauses, this means there were duplicates\n        BooleanQuery.Builder rewritten = new BooleanQuery.Builder();\n        rewritten.setMinimumNumberShouldMatch(minimumNumberShouldMatch);\n        for (Map.Entry<Occur, Collection<Query>> entry : clauseSets.entrySet()) {\n          final Occur occur = entry.getKey();\n          for (Query query : entry.getValue()) {\n            rewritten.add(query, occur);\n          }\n        }\n        return rewritten.build();\n      }\n    }\n\n    // Check whether some clauses are both required and excluded\n    if (clauseSets.get(Occur.MUST_NOT).size() > 0) {\n      final Set<Query> reqAndExclQueries = new HashSet<Query>(clauseSets.get(Occur.FILTER));\n      reqAndExclQueries.addAll(clauseSets.get(Occur.MUST));\n      reqAndExclQueries.retainAll(clauseSets.get(Occur.MUST_NOT));\n\n      if (reqAndExclQueries.isEmpty() == false) {\n        return new MatchNoDocsQuery(\"FILTER or MUST clause also in MUST_NOT\");\n      }\n    }\n\n    // remove FILTER clauses that are also MUST clauses\n    // or that match all documents\n    if (clauseSets.get(Occur.MUST).size() > 0 && clauseSets.get(Occur.FILTER).size() > 0) {\n      final Set<Query> filters = new HashSet<Query>(clauseSets.get(Occur.FILTER));\n      boolean modified = filters.remove(new MatchAllDocsQuery());\n      modified |= filters.removeAll(clauseSets.get(Occur.MUST));\n      if (modified) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder();\n        builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n        for (BooleanClause clause : clauses) {\n          if (clause.getOccur() != Occur.FILTER) {\n            builder.add(clause);\n          }\n        }\n        for (Query filter : filters) {\n          builder.add(filter, Occur.FILTER);\n        }\n        return builder.build();\n      }\n    }\n\n    // convert FILTER clauses that are also SHOULD clauses to MUST clauses\n    if (clauseSets.get(Occur.SHOULD).size() > 0 && clauseSets.get(Occur.FILTER).size() > 0) {\n      final Collection<Query> filters = clauseSets.get(Occur.FILTER);\n      final Collection<Query> shoulds = clauseSets.get(Occur.SHOULD);\n\n      Set<Query> intersection = new HashSet<>(filters);\n      intersection.retainAll(shoulds);\n\n      if (intersection.isEmpty() == false) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder();\n        int minShouldMatch = getMinimumNumberShouldMatch();\n\n        for (BooleanClause clause : clauses) {\n          if (intersection.contains(clause.getQuery())) {\n            if (clause.getOccur() == Occur.SHOULD) {\n              builder.add(new BooleanClause(clause.getQuery(), Occur.MUST));\n              minShouldMatch--;\n            }\n          } else {\n            builder.add(clause);\n          }\n        }\n\n        builder.setMinimumNumberShouldMatch(Math.max(0, minShouldMatch));\n        return builder.build();\n      }\n    }\n\n\n    // Rewrite queries whose single scoring clause is a MUST clause on a\n    // MatchAllDocsQuery to a ConstantScoreQuery\n    {\n      final Collection<Query> musts = clauseSets.get(Occur.MUST);\n      final Collection<Query> filters = clauseSets.get(Occur.FILTER);\n      if (musts.size() == 1\n          && filters.size() > 0) {\n        Query must = musts.iterator().next();\n        float boost = 1f;\n        if (must instanceof BoostQuery) {\n          BoostQuery boostQuery = (BoostQuery) must;\n          must = boostQuery.getQuery();\n          boost = boostQuery.getBoost();\n        }\n        if (must.getClass() == MatchAllDocsQuery.class) {\n          // our single scoring clause matches everything: rewrite to a CSQ on the filter\n          // ignore SHOULD clause for now\n          BooleanQuery.Builder builder = new BooleanQuery.Builder();\n          for (BooleanClause clause : clauses) {\n            switch (clause.getOccur()) {\n              case FILTER:\n              case MUST_NOT:\n                builder.add(clause);\n                break;\n              default:\n                // ignore\n                break;\n            }\n          }\n          Query rewritten = builder.build();\n          rewritten = new ConstantScoreQuery(rewritten);\n          if (boost != 1f) {\n            rewritten = new BoostQuery(rewritten, boost);\n          }\n\n          // now add back the SHOULD clauses\n          builder = new BooleanQuery.Builder()\n            .setMinimumNumberShouldMatch(getMinimumNumberShouldMatch())\n            .add(rewritten, Occur.MUST);\n          for (Query query : clauseSets.get(Occur.SHOULD)) {\n            builder.add(query, Occur.SHOULD);\n          }\n          rewritten = builder.build();\n          return rewritten;\n        }\n      }\n    }\n\n    return super.rewrite(reader);\n  }\n\n","sourceOld":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if (clauses.size() == 0) {\n      return new MatchNoDocsQuery(\"empty BooleanQuery\");\n    }\n    \n    // optimize 1-clause queries\n    if (clauses.size() == 1) {\n      BooleanClause c = clauses.get(0);\n      Query query = c.getQuery();\n      if (minimumNumberShouldMatch == 1 && c.getOccur() == Occur.SHOULD) {\n        return query;\n      } else if (minimumNumberShouldMatch == 0) {\n        switch (c.getOccur()) {\n          case SHOULD:\n          case MUST:\n            return query;\n          case FILTER:\n            // no scoring clauses, so return a score of 0\n            return new BoostQuery(new ConstantScoreQuery(query), 0);\n          case MUST_NOT:\n            // no positive clauses\n            return new MatchNoDocsQuery(\"pure negative BooleanQuery\");\n          default:\n            throw new AssertionError();\n        }\n      }\n    }\n\n    // recursively rewrite\n    {\n      BooleanQuery.Builder builder = new BooleanQuery.Builder();\n      builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n      boolean actuallyRewritten = false;\n      for (BooleanClause clause : this) {\n        Query query = clause.getQuery();\n        Query rewritten = query.rewrite(reader);\n        if (rewritten != query) {\n          actuallyRewritten = true;\n        }\n        builder.add(rewritten, clause.getOccur());\n      }\n      if (actuallyRewritten) {\n        return builder.build();\n      }\n    }\n\n    // remove duplicate FILTER and MUST_NOT clauses\n    {\n      int clauseCount = 0;\n      for (Collection<Query> queries : clauseSets.values()) {\n        clauseCount += queries.size();\n      }\n      if (clauseCount != clauses.size()) {\n        // since clauseSets implicitly deduplicates FILTER and MUST_NOT\n        // clauses, this means there were duplicates\n        BooleanQuery.Builder rewritten = new BooleanQuery.Builder();\n        rewritten.setMinimumNumberShouldMatch(minimumNumberShouldMatch);\n        for (Map.Entry<Occur, Collection<Query>> entry : clauseSets.entrySet()) {\n          final Occur occur = entry.getKey();\n          for (Query query : entry.getValue()) {\n            rewritten.add(query, occur);\n          }\n        }\n        return rewritten.build();\n      }\n    }\n\n    // remove FILTER clauses that are also MUST clauses\n    // or that match all documents\n    if (clauseSets.get(Occur.MUST).size() > 0 && clauseSets.get(Occur.FILTER).size() > 0) {\n      final Set<Query> filters = new HashSet<Query>(clauseSets.get(Occur.FILTER));\n      boolean modified = filters.remove(new MatchAllDocsQuery());\n      modified |= filters.removeAll(clauseSets.get(Occur.MUST));\n      if (modified) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder();\n        builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n        for (BooleanClause clause : clauses) {\n          if (clause.getOccur() != Occur.FILTER) {\n            builder.add(clause);\n          }\n        }\n        for (Query filter : filters) {\n          builder.add(filter, Occur.FILTER);\n        }\n        return builder.build();\n      }\n    }\n\n    // Rewrite queries whose single scoring clause is a MUST clause on a\n    // MatchAllDocsQuery to a ConstantScoreQuery\n    {\n      final Collection<Query> musts = clauseSets.get(Occur.MUST);\n      final Collection<Query> filters = clauseSets.get(Occur.FILTER);\n      if (musts.size() == 1\n          && filters.size() > 0) {\n        Query must = musts.iterator().next();\n        float boost = 1f;\n        if (must instanceof BoostQuery) {\n          BoostQuery boostQuery = (BoostQuery) must;\n          must = boostQuery.getQuery();\n          boost = boostQuery.getBoost();\n        }\n        if (must.getClass() == MatchAllDocsQuery.class) {\n          // our single scoring clause matches everything: rewrite to a CSQ on the filter\n          // ignore SHOULD clause for now\n          BooleanQuery.Builder builder = new BooleanQuery.Builder();\n          for (BooleanClause clause : clauses) {\n            switch (clause.getOccur()) {\n              case FILTER:\n              case MUST_NOT:\n                builder.add(clause);\n                break;\n              default:\n                // ignore\n                break;\n            }\n          }\n          Query rewritten = builder.build();\n          rewritten = new ConstantScoreQuery(rewritten);\n          if (boost != 1f) {\n            rewritten = new BoostQuery(rewritten, boost);\n          }\n\n          // now add back the SHOULD clauses\n          builder = new BooleanQuery.Builder()\n            .setMinimumNumberShouldMatch(getMinimumNumberShouldMatch())\n            .add(rewritten, Occur.MUST);\n          for (Query query : clauseSets.get(Occur.SHOULD)) {\n            builder.add(query, Occur.SHOULD);\n          }\n          rewritten = builder.build();\n          return rewritten;\n        }\n      }\n    }\n\n    return super.rewrite(reader);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"60fd173dead1b592384cfdd316dd645e39cac051","date":1472196529,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery#rewrite(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery#rewrite(IndexReader).mjava","sourceNew":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if (clauses.size() == 0) {\n      return new MatchNoDocsQuery(\"empty BooleanQuery\");\n    }\n    \n    // optimize 1-clause queries\n    if (clauses.size() == 1) {\n      BooleanClause c = clauses.get(0);\n      Query query = c.getQuery();\n      if (minimumNumberShouldMatch == 1 && c.getOccur() == Occur.SHOULD) {\n        return query;\n      } else if (minimumNumberShouldMatch == 0) {\n        switch (c.getOccur()) {\n          case SHOULD:\n          case MUST:\n            return query;\n          case FILTER:\n            // no scoring clauses, so return a score of 0\n            return new BoostQuery(new ConstantScoreQuery(query), 0);\n          case MUST_NOT:\n            // no positive clauses\n            return new MatchNoDocsQuery(\"pure negative BooleanQuery\");\n          default:\n            throw new AssertionError();\n        }\n      }\n    }\n\n    // recursively rewrite\n    {\n      BooleanQuery.Builder builder = new BooleanQuery.Builder();\n      builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n      boolean actuallyRewritten = false;\n      for (BooleanClause clause : this) {\n        Query query = clause.getQuery();\n        Query rewritten = query.rewrite(reader);\n        if (rewritten != query) {\n          actuallyRewritten = true;\n        }\n        builder.add(rewritten, clause.getOccur());\n      }\n      if (actuallyRewritten) {\n        return builder.build();\n      }\n    }\n\n    // remove duplicate FILTER and MUST_NOT clauses\n    {\n      int clauseCount = 0;\n      for (Collection<Query> queries : clauseSets.values()) {\n        clauseCount += queries.size();\n      }\n      if (clauseCount != clauses.size()) {\n        // since clauseSets implicitly deduplicates FILTER and MUST_NOT\n        // clauses, this means there were duplicates\n        BooleanQuery.Builder rewritten = new BooleanQuery.Builder();\n        rewritten.setMinimumNumberShouldMatch(minimumNumberShouldMatch);\n        for (Map.Entry<Occur, Collection<Query>> entry : clauseSets.entrySet()) {\n          final Occur occur = entry.getKey();\n          for (Query query : entry.getValue()) {\n            rewritten.add(query, occur);\n          }\n        }\n        return rewritten.build();\n      }\n    }\n\n    // Check whether some clauses are both required and excluded\n    final Collection<Query> mustNotClauses = clauseSets.get(Occur.MUST_NOT);\n    if (!mustNotClauses.isEmpty()) {\n      final Predicate<Query> p = clauseSets.get(Occur.MUST)::contains;\n      if (mustNotClauses.stream().anyMatch(p.or(clauseSets.get(Occur.FILTER)::contains))) {\n        return new MatchNoDocsQuery(\"FILTER or MUST clause also in MUST_NOT\");\n      }\n      if (mustNotClauses.contains(new MatchAllDocsQuery())) {\n        return new MatchNoDocsQuery(\"MUST_NOT clause is MatchAllDocsQuery\");\n      }\n    }\n\n    // remove FILTER clauses that are also MUST clauses\n    // or that match all documents\n    if (clauseSets.get(Occur.MUST).size() > 0 && clauseSets.get(Occur.FILTER).size() > 0) {\n      final Set<Query> filters = new HashSet<Query>(clauseSets.get(Occur.FILTER));\n      boolean modified = filters.remove(new MatchAllDocsQuery());\n      modified |= filters.removeAll(clauseSets.get(Occur.MUST));\n      if (modified) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder();\n        builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n        for (BooleanClause clause : clauses) {\n          if (clause.getOccur() != Occur.FILTER) {\n            builder.add(clause);\n          }\n        }\n        for (Query filter : filters) {\n          builder.add(filter, Occur.FILTER);\n        }\n        return builder.build();\n      }\n    }\n\n    // convert FILTER clauses that are also SHOULD clauses to MUST clauses\n    if (clauseSets.get(Occur.SHOULD).size() > 0 && clauseSets.get(Occur.FILTER).size() > 0) {\n      final Collection<Query> filters = clauseSets.get(Occur.FILTER);\n      final Collection<Query> shoulds = clauseSets.get(Occur.SHOULD);\n\n      Set<Query> intersection = new HashSet<>(filters);\n      intersection.retainAll(shoulds);\n\n      if (intersection.isEmpty() == false) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder();\n        int minShouldMatch = getMinimumNumberShouldMatch();\n\n        for (BooleanClause clause : clauses) {\n          if (intersection.contains(clause.getQuery())) {\n            if (clause.getOccur() == Occur.SHOULD) {\n              builder.add(new BooleanClause(clause.getQuery(), Occur.MUST));\n              minShouldMatch--;\n            }\n          } else {\n            builder.add(clause);\n          }\n        }\n\n        builder.setMinimumNumberShouldMatch(Math.max(0, minShouldMatch));\n        return builder.build();\n      }\n    }\n\n\n    // Rewrite queries whose single scoring clause is a MUST clause on a\n    // MatchAllDocsQuery to a ConstantScoreQuery\n    {\n      final Collection<Query> musts = clauseSets.get(Occur.MUST);\n      final Collection<Query> filters = clauseSets.get(Occur.FILTER);\n      if (musts.size() == 1\n          && filters.size() > 0) {\n        Query must = musts.iterator().next();\n        float boost = 1f;\n        if (must instanceof BoostQuery) {\n          BoostQuery boostQuery = (BoostQuery) must;\n          must = boostQuery.getQuery();\n          boost = boostQuery.getBoost();\n        }\n        if (must.getClass() == MatchAllDocsQuery.class) {\n          // our single scoring clause matches everything: rewrite to a CSQ on the filter\n          // ignore SHOULD clause for now\n          BooleanQuery.Builder builder = new BooleanQuery.Builder();\n          for (BooleanClause clause : clauses) {\n            switch (clause.getOccur()) {\n              case FILTER:\n              case MUST_NOT:\n                builder.add(clause);\n                break;\n              default:\n                // ignore\n                break;\n            }\n          }\n          Query rewritten = builder.build();\n          rewritten = new ConstantScoreQuery(rewritten);\n          if (boost != 1f) {\n            rewritten = new BoostQuery(rewritten, boost);\n          }\n\n          // now add back the SHOULD clauses\n          builder = new BooleanQuery.Builder()\n            .setMinimumNumberShouldMatch(getMinimumNumberShouldMatch())\n            .add(rewritten, Occur.MUST);\n          for (Query query : clauseSets.get(Occur.SHOULD)) {\n            builder.add(query, Occur.SHOULD);\n          }\n          rewritten = builder.build();\n          return rewritten;\n        }\n      }\n    }\n\n    return super.rewrite(reader);\n  }\n\n","sourceOld":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if (clauses.size() == 0) {\n      return new MatchNoDocsQuery(\"empty BooleanQuery\");\n    }\n    \n    // optimize 1-clause queries\n    if (clauses.size() == 1) {\n      BooleanClause c = clauses.get(0);\n      Query query = c.getQuery();\n      if (minimumNumberShouldMatch == 1 && c.getOccur() == Occur.SHOULD) {\n        return query;\n      } else if (minimumNumberShouldMatch == 0) {\n        switch (c.getOccur()) {\n          case SHOULD:\n          case MUST:\n            return query;\n          case FILTER:\n            // no scoring clauses, so return a score of 0\n            return new BoostQuery(new ConstantScoreQuery(query), 0);\n          case MUST_NOT:\n            // no positive clauses\n            return new MatchNoDocsQuery(\"pure negative BooleanQuery\");\n          default:\n            throw new AssertionError();\n        }\n      }\n    }\n\n    // recursively rewrite\n    {\n      BooleanQuery.Builder builder = new BooleanQuery.Builder();\n      builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n      boolean actuallyRewritten = false;\n      for (BooleanClause clause : this) {\n        Query query = clause.getQuery();\n        Query rewritten = query.rewrite(reader);\n        if (rewritten != query) {\n          actuallyRewritten = true;\n        }\n        builder.add(rewritten, clause.getOccur());\n      }\n      if (actuallyRewritten) {\n        return builder.build();\n      }\n    }\n\n    // remove duplicate FILTER and MUST_NOT clauses\n    {\n      int clauseCount = 0;\n      for (Collection<Query> queries : clauseSets.values()) {\n        clauseCount += queries.size();\n      }\n      if (clauseCount != clauses.size()) {\n        // since clauseSets implicitly deduplicates FILTER and MUST_NOT\n        // clauses, this means there were duplicates\n        BooleanQuery.Builder rewritten = new BooleanQuery.Builder();\n        rewritten.setMinimumNumberShouldMatch(minimumNumberShouldMatch);\n        for (Map.Entry<Occur, Collection<Query>> entry : clauseSets.entrySet()) {\n          final Occur occur = entry.getKey();\n          for (Query query : entry.getValue()) {\n            rewritten.add(query, occur);\n          }\n        }\n        return rewritten.build();\n      }\n    }\n\n    // Check whether some clauses are both required and excluded\n    if (clauseSets.get(Occur.MUST_NOT).size() > 0) {\n      final Set<Query> reqAndExclQueries = new HashSet<Query>(clauseSets.get(Occur.FILTER));\n      reqAndExclQueries.addAll(clauseSets.get(Occur.MUST));\n      reqAndExclQueries.retainAll(clauseSets.get(Occur.MUST_NOT));\n\n      if (reqAndExclQueries.isEmpty() == false) {\n        return new MatchNoDocsQuery(\"FILTER or MUST clause also in MUST_NOT\");\n      }\n    }\n\n    // remove FILTER clauses that are also MUST clauses\n    // or that match all documents\n    if (clauseSets.get(Occur.MUST).size() > 0 && clauseSets.get(Occur.FILTER).size() > 0) {\n      final Set<Query> filters = new HashSet<Query>(clauseSets.get(Occur.FILTER));\n      boolean modified = filters.remove(new MatchAllDocsQuery());\n      modified |= filters.removeAll(clauseSets.get(Occur.MUST));\n      if (modified) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder();\n        builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n        for (BooleanClause clause : clauses) {\n          if (clause.getOccur() != Occur.FILTER) {\n            builder.add(clause);\n          }\n        }\n        for (Query filter : filters) {\n          builder.add(filter, Occur.FILTER);\n        }\n        return builder.build();\n      }\n    }\n\n    // convert FILTER clauses that are also SHOULD clauses to MUST clauses\n    if (clauseSets.get(Occur.SHOULD).size() > 0 && clauseSets.get(Occur.FILTER).size() > 0) {\n      final Collection<Query> filters = clauseSets.get(Occur.FILTER);\n      final Collection<Query> shoulds = clauseSets.get(Occur.SHOULD);\n\n      Set<Query> intersection = new HashSet<>(filters);\n      intersection.retainAll(shoulds);\n\n      if (intersection.isEmpty() == false) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder();\n        int minShouldMatch = getMinimumNumberShouldMatch();\n\n        for (BooleanClause clause : clauses) {\n          if (intersection.contains(clause.getQuery())) {\n            if (clause.getOccur() == Occur.SHOULD) {\n              builder.add(new BooleanClause(clause.getQuery(), Occur.MUST));\n              minShouldMatch--;\n            }\n          } else {\n            builder.add(clause);\n          }\n        }\n\n        builder.setMinimumNumberShouldMatch(Math.max(0, minShouldMatch));\n        return builder.build();\n      }\n    }\n\n\n    // Rewrite queries whose single scoring clause is a MUST clause on a\n    // MatchAllDocsQuery to a ConstantScoreQuery\n    {\n      final Collection<Query> musts = clauseSets.get(Occur.MUST);\n      final Collection<Query> filters = clauseSets.get(Occur.FILTER);\n      if (musts.size() == 1\n          && filters.size() > 0) {\n        Query must = musts.iterator().next();\n        float boost = 1f;\n        if (must instanceof BoostQuery) {\n          BoostQuery boostQuery = (BoostQuery) must;\n          must = boostQuery.getQuery();\n          boost = boostQuery.getBoost();\n        }\n        if (must.getClass() == MatchAllDocsQuery.class) {\n          // our single scoring clause matches everything: rewrite to a CSQ on the filter\n          // ignore SHOULD clause for now\n          BooleanQuery.Builder builder = new BooleanQuery.Builder();\n          for (BooleanClause clause : clauses) {\n            switch (clause.getOccur()) {\n              case FILTER:\n              case MUST_NOT:\n                builder.add(clause);\n                break;\n              default:\n                // ignore\n                break;\n            }\n          }\n          Query rewritten = builder.build();\n          rewritten = new ConstantScoreQuery(rewritten);\n          if (boost != 1f) {\n            rewritten = new BoostQuery(rewritten, boost);\n          }\n\n          // now add back the SHOULD clauses\n          builder = new BooleanQuery.Builder()\n            .setMinimumNumberShouldMatch(getMinimumNumberShouldMatch())\n            .add(rewritten, Occur.MUST);\n          for (Query query : clauseSets.get(Occur.SHOULD)) {\n            builder.add(query, Occur.SHOULD);\n          }\n          rewritten = builder.build();\n          return rewritten;\n        }\n      }\n    }\n\n    return super.rewrite(reader);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery#rewrite(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery#rewrite(IndexReader).mjava","sourceNew":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if (clauses.size() == 0) {\n      return new MatchNoDocsQuery(\"empty BooleanQuery\");\n    }\n    \n    // optimize 1-clause queries\n    if (clauses.size() == 1) {\n      BooleanClause c = clauses.get(0);\n      Query query = c.getQuery();\n      if (minimumNumberShouldMatch == 1 && c.getOccur() == Occur.SHOULD) {\n        return query;\n      } else if (minimumNumberShouldMatch == 0) {\n        switch (c.getOccur()) {\n          case SHOULD:\n          case MUST:\n            return query;\n          case FILTER:\n            // no scoring clauses, so return a score of 0\n            return new BoostQuery(new ConstantScoreQuery(query), 0);\n          case MUST_NOT:\n            // no positive clauses\n            return new MatchNoDocsQuery(\"pure negative BooleanQuery\");\n          default:\n            throw new AssertionError();\n        }\n      }\n    }\n\n    // recursively rewrite\n    {\n      BooleanQuery.Builder builder = new BooleanQuery.Builder();\n      builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n      boolean actuallyRewritten = false;\n      for (BooleanClause clause : this) {\n        Query query = clause.getQuery();\n        Query rewritten = query.rewrite(reader);\n        if (rewritten != query) {\n          actuallyRewritten = true;\n        }\n        builder.add(rewritten, clause.getOccur());\n      }\n      if (actuallyRewritten) {\n        return builder.build();\n      }\n    }\n\n    // remove duplicate FILTER and MUST_NOT clauses\n    {\n      int clauseCount = 0;\n      for (Collection<Query> queries : clauseSets.values()) {\n        clauseCount += queries.size();\n      }\n      if (clauseCount != clauses.size()) {\n        // since clauseSets implicitly deduplicates FILTER and MUST_NOT\n        // clauses, this means there were duplicates\n        BooleanQuery.Builder rewritten = new BooleanQuery.Builder();\n        rewritten.setMinimumNumberShouldMatch(minimumNumberShouldMatch);\n        for (Map.Entry<Occur, Collection<Query>> entry : clauseSets.entrySet()) {\n          final Occur occur = entry.getKey();\n          for (Query query : entry.getValue()) {\n            rewritten.add(query, occur);\n          }\n        }\n        return rewritten.build();\n      }\n    }\n\n    // Check whether some clauses are both required and excluded\n    final Collection<Query> mustNotClauses = clauseSets.get(Occur.MUST_NOT);\n    if (!mustNotClauses.isEmpty()) {\n      final Predicate<Query> p = clauseSets.get(Occur.MUST)::contains;\n      if (mustNotClauses.stream().anyMatch(p.or(clauseSets.get(Occur.FILTER)::contains))) {\n        return new MatchNoDocsQuery(\"FILTER or MUST clause also in MUST_NOT\");\n      }\n      if (mustNotClauses.contains(new MatchAllDocsQuery())) {\n        return new MatchNoDocsQuery(\"MUST_NOT clause is MatchAllDocsQuery\");\n      }\n    }\n\n    // remove FILTER clauses that are also MUST clauses\n    // or that match all documents\n    if (clauseSets.get(Occur.MUST).size() > 0 && clauseSets.get(Occur.FILTER).size() > 0) {\n      final Set<Query> filters = new HashSet<Query>(clauseSets.get(Occur.FILTER));\n      boolean modified = filters.remove(new MatchAllDocsQuery());\n      modified |= filters.removeAll(clauseSets.get(Occur.MUST));\n      if (modified) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder();\n        builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n        for (BooleanClause clause : clauses) {\n          if (clause.getOccur() != Occur.FILTER) {\n            builder.add(clause);\n          }\n        }\n        for (Query filter : filters) {\n          builder.add(filter, Occur.FILTER);\n        }\n        return builder.build();\n      }\n    }\n\n    // convert FILTER clauses that are also SHOULD clauses to MUST clauses\n    if (clauseSets.get(Occur.SHOULD).size() > 0 && clauseSets.get(Occur.FILTER).size() > 0) {\n      final Collection<Query> filters = clauseSets.get(Occur.FILTER);\n      final Collection<Query> shoulds = clauseSets.get(Occur.SHOULD);\n\n      Set<Query> intersection = new HashSet<>(filters);\n      intersection.retainAll(shoulds);\n\n      if (intersection.isEmpty() == false) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder();\n        int minShouldMatch = getMinimumNumberShouldMatch();\n\n        for (BooleanClause clause : clauses) {\n          if (intersection.contains(clause.getQuery())) {\n            if (clause.getOccur() == Occur.SHOULD) {\n              builder.add(new BooleanClause(clause.getQuery(), Occur.MUST));\n              minShouldMatch--;\n            }\n          } else {\n            builder.add(clause);\n          }\n        }\n\n        builder.setMinimumNumberShouldMatch(Math.max(0, minShouldMatch));\n        return builder.build();\n      }\n    }\n\n\n    // Rewrite queries whose single scoring clause is a MUST clause on a\n    // MatchAllDocsQuery to a ConstantScoreQuery\n    {\n      final Collection<Query> musts = clauseSets.get(Occur.MUST);\n      final Collection<Query> filters = clauseSets.get(Occur.FILTER);\n      if (musts.size() == 1\n          && filters.size() > 0) {\n        Query must = musts.iterator().next();\n        float boost = 1f;\n        if (must instanceof BoostQuery) {\n          BoostQuery boostQuery = (BoostQuery) must;\n          must = boostQuery.getQuery();\n          boost = boostQuery.getBoost();\n        }\n        if (must.getClass() == MatchAllDocsQuery.class) {\n          // our single scoring clause matches everything: rewrite to a CSQ on the filter\n          // ignore SHOULD clause for now\n          BooleanQuery.Builder builder = new BooleanQuery.Builder();\n          for (BooleanClause clause : clauses) {\n            switch (clause.getOccur()) {\n              case FILTER:\n              case MUST_NOT:\n                builder.add(clause);\n                break;\n              default:\n                // ignore\n                break;\n            }\n          }\n          Query rewritten = builder.build();\n          rewritten = new ConstantScoreQuery(rewritten);\n          if (boost != 1f) {\n            rewritten = new BoostQuery(rewritten, boost);\n          }\n\n          // now add back the SHOULD clauses\n          builder = new BooleanQuery.Builder()\n            .setMinimumNumberShouldMatch(getMinimumNumberShouldMatch())\n            .add(rewritten, Occur.MUST);\n          for (Query query : clauseSets.get(Occur.SHOULD)) {\n            builder.add(query, Occur.SHOULD);\n          }\n          rewritten = builder.build();\n          return rewritten;\n        }\n      }\n    }\n\n    return super.rewrite(reader);\n  }\n\n","sourceOld":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if (clauses.size() == 0) {\n      return new MatchNoDocsQuery(\"empty BooleanQuery\");\n    }\n    \n    // optimize 1-clause queries\n    if (clauses.size() == 1) {\n      BooleanClause c = clauses.get(0);\n      Query query = c.getQuery();\n      if (minimumNumberShouldMatch == 1 && c.getOccur() == Occur.SHOULD) {\n        return query;\n      } else if (minimumNumberShouldMatch == 0) {\n        switch (c.getOccur()) {\n          case SHOULD:\n          case MUST:\n            return query;\n          case FILTER:\n            // no scoring clauses, so return a score of 0\n            return new BoostQuery(new ConstantScoreQuery(query), 0);\n          case MUST_NOT:\n            // no positive clauses\n            return new MatchNoDocsQuery(\"pure negative BooleanQuery\");\n          default:\n            throw new AssertionError();\n        }\n      }\n    }\n\n    // recursively rewrite\n    {\n      BooleanQuery.Builder builder = new BooleanQuery.Builder();\n      builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n      boolean actuallyRewritten = false;\n      for (BooleanClause clause : this) {\n        Query query = clause.getQuery();\n        Query rewritten = query.rewrite(reader);\n        if (rewritten != query) {\n          actuallyRewritten = true;\n        }\n        builder.add(rewritten, clause.getOccur());\n      }\n      if (actuallyRewritten) {\n        return builder.build();\n      }\n    }\n\n    // remove duplicate FILTER and MUST_NOT clauses\n    {\n      int clauseCount = 0;\n      for (Collection<Query> queries : clauseSets.values()) {\n        clauseCount += queries.size();\n      }\n      if (clauseCount != clauses.size()) {\n        // since clauseSets implicitly deduplicates FILTER and MUST_NOT\n        // clauses, this means there were duplicates\n        BooleanQuery.Builder rewritten = new BooleanQuery.Builder();\n        rewritten.setMinimumNumberShouldMatch(minimumNumberShouldMatch);\n        for (Map.Entry<Occur, Collection<Query>> entry : clauseSets.entrySet()) {\n          final Occur occur = entry.getKey();\n          for (Query query : entry.getValue()) {\n            rewritten.add(query, occur);\n          }\n        }\n        return rewritten.build();\n      }\n    }\n\n    // Check whether some clauses are both required and excluded\n    if (clauseSets.get(Occur.MUST_NOT).size() > 0) {\n      final Set<Query> reqAndExclQueries = new HashSet<Query>(clauseSets.get(Occur.FILTER));\n      reqAndExclQueries.addAll(clauseSets.get(Occur.MUST));\n      reqAndExclQueries.retainAll(clauseSets.get(Occur.MUST_NOT));\n\n      if (reqAndExclQueries.isEmpty() == false) {\n        return new MatchNoDocsQuery(\"FILTER or MUST clause also in MUST_NOT\");\n      }\n    }\n\n    // remove FILTER clauses that are also MUST clauses\n    // or that match all documents\n    if (clauseSets.get(Occur.MUST).size() > 0 && clauseSets.get(Occur.FILTER).size() > 0) {\n      final Set<Query> filters = new HashSet<Query>(clauseSets.get(Occur.FILTER));\n      boolean modified = filters.remove(new MatchAllDocsQuery());\n      modified |= filters.removeAll(clauseSets.get(Occur.MUST));\n      if (modified) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder();\n        builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n        for (BooleanClause clause : clauses) {\n          if (clause.getOccur() != Occur.FILTER) {\n            builder.add(clause);\n          }\n        }\n        for (Query filter : filters) {\n          builder.add(filter, Occur.FILTER);\n        }\n        return builder.build();\n      }\n    }\n\n    // convert FILTER clauses that are also SHOULD clauses to MUST clauses\n    if (clauseSets.get(Occur.SHOULD).size() > 0 && clauseSets.get(Occur.FILTER).size() > 0) {\n      final Collection<Query> filters = clauseSets.get(Occur.FILTER);\n      final Collection<Query> shoulds = clauseSets.get(Occur.SHOULD);\n\n      Set<Query> intersection = new HashSet<>(filters);\n      intersection.retainAll(shoulds);\n\n      if (intersection.isEmpty() == false) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder();\n        int minShouldMatch = getMinimumNumberShouldMatch();\n\n        for (BooleanClause clause : clauses) {\n          if (intersection.contains(clause.getQuery())) {\n            if (clause.getOccur() == Occur.SHOULD) {\n              builder.add(new BooleanClause(clause.getQuery(), Occur.MUST));\n              minShouldMatch--;\n            }\n          } else {\n            builder.add(clause);\n          }\n        }\n\n        builder.setMinimumNumberShouldMatch(Math.max(0, minShouldMatch));\n        return builder.build();\n      }\n    }\n\n\n    // Rewrite queries whose single scoring clause is a MUST clause on a\n    // MatchAllDocsQuery to a ConstantScoreQuery\n    {\n      final Collection<Query> musts = clauseSets.get(Occur.MUST);\n      final Collection<Query> filters = clauseSets.get(Occur.FILTER);\n      if (musts.size() == 1\n          && filters.size() > 0) {\n        Query must = musts.iterator().next();\n        float boost = 1f;\n        if (must instanceof BoostQuery) {\n          BoostQuery boostQuery = (BoostQuery) must;\n          must = boostQuery.getQuery();\n          boost = boostQuery.getBoost();\n        }\n        if (must.getClass() == MatchAllDocsQuery.class) {\n          // our single scoring clause matches everything: rewrite to a CSQ on the filter\n          // ignore SHOULD clause for now\n          BooleanQuery.Builder builder = new BooleanQuery.Builder();\n          for (BooleanClause clause : clauses) {\n            switch (clause.getOccur()) {\n              case FILTER:\n              case MUST_NOT:\n                builder.add(clause);\n                break;\n              default:\n                // ignore\n                break;\n            }\n          }\n          Query rewritten = builder.build();\n          rewritten = new ConstantScoreQuery(rewritten);\n          if (boost != 1f) {\n            rewritten = new BoostQuery(rewritten, boost);\n          }\n\n          // now add back the SHOULD clauses\n          builder = new BooleanQuery.Builder()\n            .setMinimumNumberShouldMatch(getMinimumNumberShouldMatch())\n            .add(rewritten, Occur.MUST);\n          for (Query query : clauseSets.get(Occur.SHOULD)) {\n            builder.add(query, Occur.SHOULD);\n          }\n          rewritten = builder.build();\n          return rewritten;\n        }\n      }\n    }\n\n    return super.rewrite(reader);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery#rewrite(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery#rewrite(IndexReader).mjava","sourceNew":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if (clauses.size() == 0) {\n      return new MatchNoDocsQuery(\"empty BooleanQuery\");\n    }\n    \n    // optimize 1-clause queries\n    if (clauses.size() == 1) {\n      BooleanClause c = clauses.get(0);\n      Query query = c.getQuery();\n      if (minimumNumberShouldMatch == 1 && c.getOccur() == Occur.SHOULD) {\n        return query;\n      } else if (minimumNumberShouldMatch == 0) {\n        switch (c.getOccur()) {\n          case SHOULD:\n          case MUST:\n            return query;\n          case FILTER:\n            // no scoring clauses, so return a score of 0\n            return new BoostQuery(new ConstantScoreQuery(query), 0);\n          case MUST_NOT:\n            // no positive clauses\n            return new MatchNoDocsQuery(\"pure negative BooleanQuery\");\n          default:\n            throw new AssertionError();\n        }\n      }\n    }\n\n    // recursively rewrite\n    {\n      BooleanQuery.Builder builder = new BooleanQuery.Builder();\n      builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n      boolean actuallyRewritten = false;\n      for (BooleanClause clause : this) {\n        Query query = clause.getQuery();\n        Query rewritten = query.rewrite(reader);\n        if (rewritten != query) {\n          actuallyRewritten = true;\n        }\n        builder.add(rewritten, clause.getOccur());\n      }\n      if (actuallyRewritten) {\n        return builder.build();\n      }\n    }\n\n    // remove duplicate FILTER and MUST_NOT clauses\n    {\n      int clauseCount = 0;\n      for (Collection<Query> queries : clauseSets.values()) {\n        clauseCount += queries.size();\n      }\n      if (clauseCount != clauses.size()) {\n        // since clauseSets implicitly deduplicates FILTER and MUST_NOT\n        // clauses, this means there were duplicates\n        BooleanQuery.Builder rewritten = new BooleanQuery.Builder();\n        rewritten.setMinimumNumberShouldMatch(minimumNumberShouldMatch);\n        for (Map.Entry<Occur, Collection<Query>> entry : clauseSets.entrySet()) {\n          final Occur occur = entry.getKey();\n          for (Query query : entry.getValue()) {\n            rewritten.add(query, occur);\n          }\n        }\n        return rewritten.build();\n      }\n    }\n\n    // Check whether some clauses are both required and excluded\n    final Collection<Query> mustNotClauses = clauseSets.get(Occur.MUST_NOT);\n    if (!mustNotClauses.isEmpty()) {\n      final Predicate<Query> p = clauseSets.get(Occur.MUST)::contains;\n      if (mustNotClauses.stream().anyMatch(p.or(clauseSets.get(Occur.FILTER)::contains))) {\n        return new MatchNoDocsQuery(\"FILTER or MUST clause also in MUST_NOT\");\n      }\n      if (mustNotClauses.contains(new MatchAllDocsQuery())) {\n        return new MatchNoDocsQuery(\"MUST_NOT clause is MatchAllDocsQuery\");\n      }\n    }\n\n    // remove FILTER clauses that are also MUST clauses\n    // or that match all documents\n    if (clauseSets.get(Occur.MUST).size() > 0 && clauseSets.get(Occur.FILTER).size() > 0) {\n      final Set<Query> filters = new HashSet<Query>(clauseSets.get(Occur.FILTER));\n      boolean modified = filters.remove(new MatchAllDocsQuery());\n      modified |= filters.removeAll(clauseSets.get(Occur.MUST));\n      if (modified) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder();\n        builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n        for (BooleanClause clause : clauses) {\n          if (clause.getOccur() != Occur.FILTER) {\n            builder.add(clause);\n          }\n        }\n        for (Query filter : filters) {\n          builder.add(filter, Occur.FILTER);\n        }\n        return builder.build();\n      }\n    }\n\n    // convert FILTER clauses that are also SHOULD clauses to MUST clauses\n    if (clauseSets.get(Occur.SHOULD).size() > 0 && clauseSets.get(Occur.FILTER).size() > 0) {\n      final Collection<Query> filters = clauseSets.get(Occur.FILTER);\n      final Collection<Query> shoulds = clauseSets.get(Occur.SHOULD);\n\n      Set<Query> intersection = new HashSet<>(filters);\n      intersection.retainAll(shoulds);\n\n      if (intersection.isEmpty() == false) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder();\n        int minShouldMatch = getMinimumNumberShouldMatch();\n\n        for (BooleanClause clause : clauses) {\n          if (intersection.contains(clause.getQuery())) {\n            if (clause.getOccur() == Occur.SHOULD) {\n              builder.add(new BooleanClause(clause.getQuery(), Occur.MUST));\n              minShouldMatch--;\n            }\n          } else {\n            builder.add(clause);\n          }\n        }\n\n        builder.setMinimumNumberShouldMatch(Math.max(0, minShouldMatch));\n        return builder.build();\n      }\n    }\n\n\n    // Rewrite queries whose single scoring clause is a MUST clause on a\n    // MatchAllDocsQuery to a ConstantScoreQuery\n    {\n      final Collection<Query> musts = clauseSets.get(Occur.MUST);\n      final Collection<Query> filters = clauseSets.get(Occur.FILTER);\n      if (musts.size() == 1\n          && filters.size() > 0) {\n        Query must = musts.iterator().next();\n        float boost = 1f;\n        if (must instanceof BoostQuery) {\n          BoostQuery boostQuery = (BoostQuery) must;\n          must = boostQuery.getQuery();\n          boost = boostQuery.getBoost();\n        }\n        if (must.getClass() == MatchAllDocsQuery.class) {\n          // our single scoring clause matches everything: rewrite to a CSQ on the filter\n          // ignore SHOULD clause for now\n          BooleanQuery.Builder builder = new BooleanQuery.Builder();\n          for (BooleanClause clause : clauses) {\n            switch (clause.getOccur()) {\n              case FILTER:\n              case MUST_NOT:\n                builder.add(clause);\n                break;\n              default:\n                // ignore\n                break;\n            }\n          }\n          Query rewritten = builder.build();\n          rewritten = new ConstantScoreQuery(rewritten);\n          if (boost != 1f) {\n            rewritten = new BoostQuery(rewritten, boost);\n          }\n\n          // now add back the SHOULD clauses\n          builder = new BooleanQuery.Builder()\n            .setMinimumNumberShouldMatch(getMinimumNumberShouldMatch())\n            .add(rewritten, Occur.MUST);\n          for (Query query : clauseSets.get(Occur.SHOULD)) {\n            builder.add(query, Occur.SHOULD);\n          }\n          rewritten = builder.build();\n          return rewritten;\n        }\n      }\n    }\n\n    return super.rewrite(reader);\n  }\n\n","sourceOld":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    // optimize 1-clause queries\n    if (clauses.size() == 1) {\n      BooleanClause c = clauses.get(0);\n      Query query = c.getQuery();\n      if (minimumNumberShouldMatch == 1 && c.getOccur() == Occur.SHOULD) {\n        return query;\n      } else if (minimumNumberShouldMatch == 0) {\n        switch (c.getOccur()) {\n          case SHOULD:\n          case MUST:\n            return query;\n          case FILTER:\n            // no scoring clauses, so return a score of 0\n            return new BoostQuery(new ConstantScoreQuery(query), 0);\n          case MUST_NOT:\n            // no positive clauses\n            return new MatchNoDocsQuery();\n          default:\n            throw new AssertionError();\n        }\n      }\n    }\n\n    // recursively rewrite\n    {\n      BooleanQuery.Builder builder = new BooleanQuery.Builder();\n      builder.setDisableCoord(isCoordDisabled());\n      builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n      boolean actuallyRewritten = false;\n      for (BooleanClause clause : this) {\n        Query query = clause.getQuery();\n        Query rewritten = query.rewrite(reader);\n        if (rewritten != query) {\n          actuallyRewritten = true;\n        }\n        builder.add(rewritten, clause.getOccur());\n      }\n      if (actuallyRewritten) {\n        return builder.build();\n      }\n    }\n\n    // remove duplicate FILTER and MUST_NOT clauses\n    {\n      int clauseCount = 0;\n      for (Collection<Query> queries : clauseSets.values()) {\n        clauseCount += queries.size();\n      }\n      if (clauseCount != clauses.size()) {\n        // since clauseSets implicitly deduplicates FILTER and MUST_NOT\n        // clauses, this means there were duplicates\n        BooleanQuery.Builder rewritten = new BooleanQuery.Builder();\n        rewritten.setDisableCoord(disableCoord);\n        rewritten.setMinimumNumberShouldMatch(minimumNumberShouldMatch);\n        for (Map.Entry<Occur, Collection<Query>> entry : clauseSets.entrySet()) {\n          final Occur occur = entry.getKey();\n          for (Query query : entry.getValue()) {\n            rewritten.add(query, occur);\n          }\n        }\n        return rewritten.build();\n      }\n    }\n\n    // remove FILTER clauses that are also MUST clauses\n    // or that match all documents\n    if (clauseSets.get(Occur.MUST).size() > 0 && clauseSets.get(Occur.FILTER).size() > 0) {\n      final Set<Query> filters = new HashSet<Query>(clauseSets.get(Occur.FILTER));\n      boolean modified = filters.remove(new MatchAllDocsQuery());\n      modified |= filters.removeAll(clauseSets.get(Occur.MUST));\n      if (modified) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder();\n        builder.setDisableCoord(isCoordDisabled());\n        builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n        for (BooleanClause clause : clauses) {\n          if (clause.getOccur() != Occur.FILTER) {\n            builder.add(clause);\n          }\n        }\n        for (Query filter : filters) {\n          builder.add(filter, Occur.FILTER);\n        }\n        return builder.build();\n      }\n    }\n\n    // Rewrite queries whose single scoring clause is a MUST clause on a\n    // MatchAllDocsQuery to a ConstantScoreQuery\n    {\n      final Collection<Query> musts = clauseSets.get(Occur.MUST);\n      final Collection<Query> filters = clauseSets.get(Occur.FILTER);\n      if (musts.size() == 1\n          && filters.size() > 0) {\n        Query must = musts.iterator().next();\n        float boost = 1f;\n        if (must instanceof BoostQuery) {\n          BoostQuery boostQuery = (BoostQuery) must;\n          must = boostQuery.getQuery();\n          boost = boostQuery.getBoost();\n        }\n        if (must.getClass() == MatchAllDocsQuery.class) {\n          // our single scoring clause matches everything: rewrite to a CSQ on the filter\n          // ignore SHOULD clause for now\n          BooleanQuery.Builder builder = new BooleanQuery.Builder();\n          for (BooleanClause clause : clauses) {\n            switch (clause.getOccur()) {\n              case FILTER:\n              case MUST_NOT:\n                builder.add(clause);\n                break;\n              default:\n                // ignore\n                break;\n            }\n          }\n          Query rewritten = builder.build();\n          rewritten = new ConstantScoreQuery(rewritten);\n          if (boost != 1f) {\n            rewritten = new BoostQuery(rewritten, boost);\n          }\n\n          // now add back the SHOULD clauses\n          builder = new BooleanQuery.Builder()\n            .setDisableCoord(isCoordDisabled())\n            .setMinimumNumberShouldMatch(getMinimumNumberShouldMatch())\n            .add(rewritten, Occur.MUST);\n          for (Query query : clauseSets.get(Occur.SHOULD)) {\n            builder.add(query, Occur.SHOULD);\n          }\n          rewritten = builder.build();\n          return rewritten;\n        }\n      }\n    }\n\n    return super.rewrite(reader);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"33b0cbce3d060cc2547083fc6559e6080ec5ca23","date":1503308288,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery#rewrite(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery#rewrite(IndexReader).mjava","sourceNew":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if (clauses.size() == 0) {\n      return new MatchNoDocsQuery(\"empty BooleanQuery\");\n    }\n    \n    // optimize 1-clause queries\n    if (clauses.size() == 1) {\n      BooleanClause c = clauses.get(0);\n      Query query = c.getQuery();\n      if (minimumNumberShouldMatch == 1 && c.getOccur() == Occur.SHOULD) {\n        return query;\n      } else if (minimumNumberShouldMatch == 0) {\n        switch (c.getOccur()) {\n          case SHOULD:\n          case MUST:\n            return query;\n          case FILTER:\n            // no scoring clauses, so return a score of 0\n            return new BoostQuery(new ConstantScoreQuery(query), 0);\n          case MUST_NOT:\n            // no positive clauses\n            return new MatchNoDocsQuery(\"pure negative BooleanQuery\");\n          default:\n            throw new AssertionError();\n        }\n      }\n    }\n\n    // recursively rewrite\n    {\n      BooleanQuery.Builder builder = new BooleanQuery.Builder();\n      builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n      boolean actuallyRewritten = false;\n      for (BooleanClause clause : this) {\n        Query query = clause.getQuery();\n        Query rewritten = query.rewrite(reader);\n        if (rewritten != query) {\n          actuallyRewritten = true;\n        }\n        builder.add(rewritten, clause.getOccur());\n      }\n      if (actuallyRewritten) {\n        return builder.build();\n      }\n    }\n\n    // remove duplicate FILTER and MUST_NOT clauses\n    {\n      int clauseCount = 0;\n      for (Collection<Query> queries : clauseSets.values()) {\n        clauseCount += queries.size();\n      }\n      if (clauseCount != clauses.size()) {\n        // since clauseSets implicitly deduplicates FILTER and MUST_NOT\n        // clauses, this means there were duplicates\n        BooleanQuery.Builder rewritten = new BooleanQuery.Builder();\n        rewritten.setMinimumNumberShouldMatch(minimumNumberShouldMatch);\n        for (Map.Entry<Occur, Collection<Query>> entry : clauseSets.entrySet()) {\n          final Occur occur = entry.getKey();\n          for (Query query : entry.getValue()) {\n            rewritten.add(query, occur);\n          }\n        }\n        return rewritten.build();\n      }\n    }\n\n    // Check whether some clauses are both required and excluded\n    final Collection<Query> mustNotClauses = clauseSets.get(Occur.MUST_NOT);\n    if (!mustNotClauses.isEmpty()) {\n      final Predicate<Query> p = clauseSets.get(Occur.MUST)::contains;\n      if (mustNotClauses.stream().anyMatch(p.or(clauseSets.get(Occur.FILTER)::contains))) {\n        return new MatchNoDocsQuery(\"FILTER or MUST clause also in MUST_NOT\");\n      }\n      if (mustNotClauses.contains(new MatchAllDocsQuery())) {\n        return new MatchNoDocsQuery(\"MUST_NOT clause is MatchAllDocsQuery\");\n      }\n    }\n\n    // remove FILTER clauses that are also MUST clauses\n    // or that match all documents\n    if (clauseSets.get(Occur.MUST).size() > 0 && clauseSets.get(Occur.FILTER).size() > 0) {\n      final Set<Query> filters = new HashSet<Query>(clauseSets.get(Occur.FILTER));\n      boolean modified = filters.remove(new MatchAllDocsQuery());\n      modified |= filters.removeAll(clauseSets.get(Occur.MUST));\n      if (modified) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder();\n        builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n        for (BooleanClause clause : clauses) {\n          if (clause.getOccur() != Occur.FILTER) {\n            builder.add(clause);\n          }\n        }\n        for (Query filter : filters) {\n          builder.add(filter, Occur.FILTER);\n        }\n        return builder.build();\n      }\n    }\n\n    // convert FILTER clauses that are also SHOULD clauses to MUST clauses\n    if (clauseSets.get(Occur.SHOULD).size() > 0 && clauseSets.get(Occur.FILTER).size() > 0) {\n      final Collection<Query> filters = clauseSets.get(Occur.FILTER);\n      final Collection<Query> shoulds = clauseSets.get(Occur.SHOULD);\n\n      Set<Query> intersection = new HashSet<>(filters);\n      intersection.retainAll(shoulds);\n\n      if (intersection.isEmpty() == false) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder();\n        int minShouldMatch = getMinimumNumberShouldMatch();\n\n        for (BooleanClause clause : clauses) {\n          if (intersection.contains(clause.getQuery())) {\n            if (clause.getOccur() == Occur.SHOULD) {\n              builder.add(new BooleanClause(clause.getQuery(), Occur.MUST));\n              minShouldMatch--;\n            }\n          } else {\n            builder.add(clause);\n          }\n        }\n\n        builder.setMinimumNumberShouldMatch(Math.max(0, minShouldMatch));\n        return builder.build();\n      }\n    }\n\n    // Deduplicate SHOULD clauses by summing up their boosts\n    if (clauseSets.get(Occur.SHOULD).size() > 0 && minimumNumberShouldMatch <= 1) {\n      Map<Query, Double> shouldClauses = new HashMap<>();\n      for (Query query : clauseSets.get(Occur.SHOULD)) {\n        double boost = 1;\n        while (query instanceof BoostQuery) {\n          BoostQuery bq = (BoostQuery) query;\n          boost *= bq.getBoost();\n          query = bq.getQuery();\n        }\n        shouldClauses.put(query, shouldClauses.getOrDefault(query, 0d) + boost);\n      }\n      if (shouldClauses.size() != clauseSets.get(Occur.SHOULD).size()) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder()\n            .setMinimumNumberShouldMatch(minimumNumberShouldMatch);\n        for (Map.Entry<Query,Double> entry : shouldClauses.entrySet()) {\n          Query query = entry.getKey();\n          float boost = entry.getValue().floatValue();\n          if (boost != 1f) {\n            query = new BoostQuery(query, boost);\n          }\n          builder.add(query, Occur.SHOULD);\n        }\n        for (BooleanClause clause : clauses) {\n          if (clause.getOccur() != Occur.SHOULD) {\n            builder.add(clause);\n          }\n        }\n        return builder.build();\n      }\n    }\n\n    // Deduplicate MUST clauses by summing up their boosts\n    if (clauseSets.get(Occur.MUST).size() > 0) {\n      Map<Query, Double> mustClauses = new HashMap<>();\n      for (Query query : clauseSets.get(Occur.MUST)) {\n        double boost = 1;\n        while (query instanceof BoostQuery) {\n          BoostQuery bq = (BoostQuery) query;\n          boost *= bq.getBoost();\n          query = bq.getQuery();\n        }\n        mustClauses.put(query, mustClauses.getOrDefault(query, 0d) + boost);\n      }\n      if (mustClauses.size() != clauseSets.get(Occur.MUST).size()) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder()\n            .setMinimumNumberShouldMatch(minimumNumberShouldMatch);\n        for (Map.Entry<Query,Double> entry : mustClauses.entrySet()) {\n          Query query = entry.getKey();\n          float boost = entry.getValue().floatValue();\n          if (boost != 1f) {\n            query = new BoostQuery(query, boost);\n          }\n          builder.add(query, Occur.MUST);\n        }\n        for (BooleanClause clause : clauses) {\n          if (clause.getOccur() != Occur.MUST) {\n            builder.add(clause);\n          }\n        }\n        return builder.build();\n      }\n    }\n\n    // Rewrite queries whose single scoring clause is a MUST clause on a\n    // MatchAllDocsQuery to a ConstantScoreQuery\n    {\n      final Collection<Query> musts = clauseSets.get(Occur.MUST);\n      final Collection<Query> filters = clauseSets.get(Occur.FILTER);\n      if (musts.size() == 1\n          && filters.size() > 0) {\n        Query must = musts.iterator().next();\n        float boost = 1f;\n        if (must instanceof BoostQuery) {\n          BoostQuery boostQuery = (BoostQuery) must;\n          must = boostQuery.getQuery();\n          boost = boostQuery.getBoost();\n        }\n        if (must.getClass() == MatchAllDocsQuery.class) {\n          // our single scoring clause matches everything: rewrite to a CSQ on the filter\n          // ignore SHOULD clause for now\n          BooleanQuery.Builder builder = new BooleanQuery.Builder();\n          for (BooleanClause clause : clauses) {\n            switch (clause.getOccur()) {\n              case FILTER:\n              case MUST_NOT:\n                builder.add(clause);\n                break;\n              default:\n                // ignore\n                break;\n            }\n          }\n          Query rewritten = builder.build();\n          rewritten = new ConstantScoreQuery(rewritten);\n          if (boost != 1f) {\n            rewritten = new BoostQuery(rewritten, boost);\n          }\n\n          // now add back the SHOULD clauses\n          builder = new BooleanQuery.Builder()\n            .setMinimumNumberShouldMatch(getMinimumNumberShouldMatch())\n            .add(rewritten, Occur.MUST);\n          for (Query query : clauseSets.get(Occur.SHOULD)) {\n            builder.add(query, Occur.SHOULD);\n          }\n          rewritten = builder.build();\n          return rewritten;\n        }\n      }\n    }\n\n    return super.rewrite(reader);\n  }\n\n","sourceOld":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if (clauses.size() == 0) {\n      return new MatchNoDocsQuery(\"empty BooleanQuery\");\n    }\n    \n    // optimize 1-clause queries\n    if (clauses.size() == 1) {\n      BooleanClause c = clauses.get(0);\n      Query query = c.getQuery();\n      if (minimumNumberShouldMatch == 1 && c.getOccur() == Occur.SHOULD) {\n        return query;\n      } else if (minimumNumberShouldMatch == 0) {\n        switch (c.getOccur()) {\n          case SHOULD:\n          case MUST:\n            return query;\n          case FILTER:\n            // no scoring clauses, so return a score of 0\n            return new BoostQuery(new ConstantScoreQuery(query), 0);\n          case MUST_NOT:\n            // no positive clauses\n            return new MatchNoDocsQuery(\"pure negative BooleanQuery\");\n          default:\n            throw new AssertionError();\n        }\n      }\n    }\n\n    // recursively rewrite\n    {\n      BooleanQuery.Builder builder = new BooleanQuery.Builder();\n      builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n      boolean actuallyRewritten = false;\n      for (BooleanClause clause : this) {\n        Query query = clause.getQuery();\n        Query rewritten = query.rewrite(reader);\n        if (rewritten != query) {\n          actuallyRewritten = true;\n        }\n        builder.add(rewritten, clause.getOccur());\n      }\n      if (actuallyRewritten) {\n        return builder.build();\n      }\n    }\n\n    // remove duplicate FILTER and MUST_NOT clauses\n    {\n      int clauseCount = 0;\n      for (Collection<Query> queries : clauseSets.values()) {\n        clauseCount += queries.size();\n      }\n      if (clauseCount != clauses.size()) {\n        // since clauseSets implicitly deduplicates FILTER and MUST_NOT\n        // clauses, this means there were duplicates\n        BooleanQuery.Builder rewritten = new BooleanQuery.Builder();\n        rewritten.setMinimumNumberShouldMatch(minimumNumberShouldMatch);\n        for (Map.Entry<Occur, Collection<Query>> entry : clauseSets.entrySet()) {\n          final Occur occur = entry.getKey();\n          for (Query query : entry.getValue()) {\n            rewritten.add(query, occur);\n          }\n        }\n        return rewritten.build();\n      }\n    }\n\n    // Check whether some clauses are both required and excluded\n    final Collection<Query> mustNotClauses = clauseSets.get(Occur.MUST_NOT);\n    if (!mustNotClauses.isEmpty()) {\n      final Predicate<Query> p = clauseSets.get(Occur.MUST)::contains;\n      if (mustNotClauses.stream().anyMatch(p.or(clauseSets.get(Occur.FILTER)::contains))) {\n        return new MatchNoDocsQuery(\"FILTER or MUST clause also in MUST_NOT\");\n      }\n      if (mustNotClauses.contains(new MatchAllDocsQuery())) {\n        return new MatchNoDocsQuery(\"MUST_NOT clause is MatchAllDocsQuery\");\n      }\n    }\n\n    // remove FILTER clauses that are also MUST clauses\n    // or that match all documents\n    if (clauseSets.get(Occur.MUST).size() > 0 && clauseSets.get(Occur.FILTER).size() > 0) {\n      final Set<Query> filters = new HashSet<Query>(clauseSets.get(Occur.FILTER));\n      boolean modified = filters.remove(new MatchAllDocsQuery());\n      modified |= filters.removeAll(clauseSets.get(Occur.MUST));\n      if (modified) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder();\n        builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n        for (BooleanClause clause : clauses) {\n          if (clause.getOccur() != Occur.FILTER) {\n            builder.add(clause);\n          }\n        }\n        for (Query filter : filters) {\n          builder.add(filter, Occur.FILTER);\n        }\n        return builder.build();\n      }\n    }\n\n    // convert FILTER clauses that are also SHOULD clauses to MUST clauses\n    if (clauseSets.get(Occur.SHOULD).size() > 0 && clauseSets.get(Occur.FILTER).size() > 0) {\n      final Collection<Query> filters = clauseSets.get(Occur.FILTER);\n      final Collection<Query> shoulds = clauseSets.get(Occur.SHOULD);\n\n      Set<Query> intersection = new HashSet<>(filters);\n      intersection.retainAll(shoulds);\n\n      if (intersection.isEmpty() == false) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder();\n        int minShouldMatch = getMinimumNumberShouldMatch();\n\n        for (BooleanClause clause : clauses) {\n          if (intersection.contains(clause.getQuery())) {\n            if (clause.getOccur() == Occur.SHOULD) {\n              builder.add(new BooleanClause(clause.getQuery(), Occur.MUST));\n              minShouldMatch--;\n            }\n          } else {\n            builder.add(clause);\n          }\n        }\n\n        builder.setMinimumNumberShouldMatch(Math.max(0, minShouldMatch));\n        return builder.build();\n      }\n    }\n\n\n    // Rewrite queries whose single scoring clause is a MUST clause on a\n    // MatchAllDocsQuery to a ConstantScoreQuery\n    {\n      final Collection<Query> musts = clauseSets.get(Occur.MUST);\n      final Collection<Query> filters = clauseSets.get(Occur.FILTER);\n      if (musts.size() == 1\n          && filters.size() > 0) {\n        Query must = musts.iterator().next();\n        float boost = 1f;\n        if (must instanceof BoostQuery) {\n          BoostQuery boostQuery = (BoostQuery) must;\n          must = boostQuery.getQuery();\n          boost = boostQuery.getBoost();\n        }\n        if (must.getClass() == MatchAllDocsQuery.class) {\n          // our single scoring clause matches everything: rewrite to a CSQ on the filter\n          // ignore SHOULD clause for now\n          BooleanQuery.Builder builder = new BooleanQuery.Builder();\n          for (BooleanClause clause : clauses) {\n            switch (clause.getOccur()) {\n              case FILTER:\n              case MUST_NOT:\n                builder.add(clause);\n                break;\n              default:\n                // ignore\n                break;\n            }\n          }\n          Query rewritten = builder.build();\n          rewritten = new ConstantScoreQuery(rewritten);\n          if (boost != 1f) {\n            rewritten = new BoostQuery(rewritten, boost);\n          }\n\n          // now add back the SHOULD clauses\n          builder = new BooleanQuery.Builder()\n            .setMinimumNumberShouldMatch(getMinimumNumberShouldMatch())\n            .add(rewritten, Occur.MUST);\n          for (Query query : clauseSets.get(Occur.SHOULD)) {\n            builder.add(query, Occur.SHOULD);\n          }\n          rewritten = builder.build();\n          return rewritten;\n        }\n      }\n    }\n\n    return super.rewrite(reader);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a8e4fbf51a35a1292b838d83f793794c274932a1","date":1503371298,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery#rewrite(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery#rewrite(IndexReader).mjava","sourceNew":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if (clauses.size() == 0) {\n      return new MatchNoDocsQuery(\"empty BooleanQuery\");\n    }\n    \n    // optimize 1-clause queries\n    if (clauses.size() == 1) {\n      BooleanClause c = clauses.get(0);\n      Query query = c.getQuery();\n      if (minimumNumberShouldMatch == 1 && c.getOccur() == Occur.SHOULD) {\n        return query;\n      } else if (minimumNumberShouldMatch == 0) {\n        switch (c.getOccur()) {\n          case SHOULD:\n          case MUST:\n            return query;\n          case FILTER:\n            // no scoring clauses, so return a score of 0\n            return new BoostQuery(new ConstantScoreQuery(query), 0);\n          case MUST_NOT:\n            // no positive clauses\n            return new MatchNoDocsQuery(\"pure negative BooleanQuery\");\n          default:\n            throw new AssertionError();\n        }\n      }\n    }\n\n    // recursively rewrite\n    {\n      BooleanQuery.Builder builder = new BooleanQuery.Builder();\n      builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n      boolean actuallyRewritten = false;\n      for (BooleanClause clause : this) {\n        Query query = clause.getQuery();\n        Query rewritten = query.rewrite(reader);\n        if (rewritten != query) {\n          actuallyRewritten = true;\n        }\n        builder.add(rewritten, clause.getOccur());\n      }\n      if (actuallyRewritten) {\n        return builder.build();\n      }\n    }\n\n    // remove duplicate FILTER and MUST_NOT clauses\n    {\n      int clauseCount = 0;\n      for (Collection<Query> queries : clauseSets.values()) {\n        clauseCount += queries.size();\n      }\n      if (clauseCount != clauses.size()) {\n        // since clauseSets implicitly deduplicates FILTER and MUST_NOT\n        // clauses, this means there were duplicates\n        BooleanQuery.Builder rewritten = new BooleanQuery.Builder();\n        rewritten.setMinimumNumberShouldMatch(minimumNumberShouldMatch);\n        for (Map.Entry<Occur, Collection<Query>> entry : clauseSets.entrySet()) {\n          final Occur occur = entry.getKey();\n          for (Query query : entry.getValue()) {\n            rewritten.add(query, occur);\n          }\n        }\n        return rewritten.build();\n      }\n    }\n\n    // Check whether some clauses are both required and excluded\n    final Collection<Query> mustNotClauses = clauseSets.get(Occur.MUST_NOT);\n    if (!mustNotClauses.isEmpty()) {\n      final Predicate<Query> p = clauseSets.get(Occur.MUST)::contains;\n      if (mustNotClauses.stream().anyMatch(p.or(clauseSets.get(Occur.FILTER)::contains))) {\n        return new MatchNoDocsQuery(\"FILTER or MUST clause also in MUST_NOT\");\n      }\n      if (mustNotClauses.contains(new MatchAllDocsQuery())) {\n        return new MatchNoDocsQuery(\"MUST_NOT clause is MatchAllDocsQuery\");\n      }\n    }\n\n    // remove FILTER clauses that are also MUST clauses\n    // or that match all documents\n    if (clauseSets.get(Occur.MUST).size() > 0 && clauseSets.get(Occur.FILTER).size() > 0) {\n      final Set<Query> filters = new HashSet<Query>(clauseSets.get(Occur.FILTER));\n      boolean modified = filters.remove(new MatchAllDocsQuery());\n      modified |= filters.removeAll(clauseSets.get(Occur.MUST));\n      if (modified) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder();\n        builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n        for (BooleanClause clause : clauses) {\n          if (clause.getOccur() != Occur.FILTER) {\n            builder.add(clause);\n          }\n        }\n        for (Query filter : filters) {\n          builder.add(filter, Occur.FILTER);\n        }\n        return builder.build();\n      }\n    }\n\n    // convert FILTER clauses that are also SHOULD clauses to MUST clauses\n    if (clauseSets.get(Occur.SHOULD).size() > 0 && clauseSets.get(Occur.FILTER).size() > 0) {\n      final Collection<Query> filters = clauseSets.get(Occur.FILTER);\n      final Collection<Query> shoulds = clauseSets.get(Occur.SHOULD);\n\n      Set<Query> intersection = new HashSet<>(filters);\n      intersection.retainAll(shoulds);\n\n      if (intersection.isEmpty() == false) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder();\n        int minShouldMatch = getMinimumNumberShouldMatch();\n\n        for (BooleanClause clause : clauses) {\n          if (intersection.contains(clause.getQuery())) {\n            if (clause.getOccur() == Occur.SHOULD) {\n              builder.add(new BooleanClause(clause.getQuery(), Occur.MUST));\n              minShouldMatch--;\n            }\n          } else {\n            builder.add(clause);\n          }\n        }\n\n        builder.setMinimumNumberShouldMatch(Math.max(0, minShouldMatch));\n        return builder.build();\n      }\n    }\n\n    // Deduplicate SHOULD clauses by summing up their boosts\n    if (clauseSets.get(Occur.SHOULD).size() > 0 && minimumNumberShouldMatch <= 1) {\n      Map<Query, Double> shouldClauses = new HashMap<>();\n      for (Query query : clauseSets.get(Occur.SHOULD)) {\n        double boost = 1;\n        while (query instanceof BoostQuery) {\n          BoostQuery bq = (BoostQuery) query;\n          boost *= bq.getBoost();\n          query = bq.getQuery();\n        }\n        shouldClauses.put(query, shouldClauses.getOrDefault(query, 0d) + boost);\n      }\n      if (shouldClauses.size() != clauseSets.get(Occur.SHOULD).size()) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder()\n            .setMinimumNumberShouldMatch(minimumNumberShouldMatch);\n        for (Map.Entry<Query,Double> entry : shouldClauses.entrySet()) {\n          Query query = entry.getKey();\n          float boost = entry.getValue().floatValue();\n          if (boost != 1f) {\n            query = new BoostQuery(query, boost);\n          }\n          builder.add(query, Occur.SHOULD);\n        }\n        for (BooleanClause clause : clauses) {\n          if (clause.getOccur() != Occur.SHOULD) {\n            builder.add(clause);\n          }\n        }\n        return builder.build();\n      }\n    }\n\n    // Deduplicate MUST clauses by summing up their boosts\n    if (clauseSets.get(Occur.MUST).size() > 0) {\n      Map<Query, Double> mustClauses = new HashMap<>();\n      for (Query query : clauseSets.get(Occur.MUST)) {\n        double boost = 1;\n        while (query instanceof BoostQuery) {\n          BoostQuery bq = (BoostQuery) query;\n          boost *= bq.getBoost();\n          query = bq.getQuery();\n        }\n        mustClauses.put(query, mustClauses.getOrDefault(query, 0d) + boost);\n      }\n      if (mustClauses.size() != clauseSets.get(Occur.MUST).size()) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder()\n            .setMinimumNumberShouldMatch(minimumNumberShouldMatch);\n        for (Map.Entry<Query,Double> entry : mustClauses.entrySet()) {\n          Query query = entry.getKey();\n          float boost = entry.getValue().floatValue();\n          if (boost != 1f) {\n            query = new BoostQuery(query, boost);\n          }\n          builder.add(query, Occur.MUST);\n        }\n        for (BooleanClause clause : clauses) {\n          if (clause.getOccur() != Occur.MUST) {\n            builder.add(clause);\n          }\n        }\n        return builder.build();\n      }\n    }\n\n    // Rewrite queries whose single scoring clause is a MUST clause on a\n    // MatchAllDocsQuery to a ConstantScoreQuery\n    {\n      final Collection<Query> musts = clauseSets.get(Occur.MUST);\n      final Collection<Query> filters = clauseSets.get(Occur.FILTER);\n      if (musts.size() == 1\n          && filters.size() > 0) {\n        Query must = musts.iterator().next();\n        float boost = 1f;\n        if (must instanceof BoostQuery) {\n          BoostQuery boostQuery = (BoostQuery) must;\n          must = boostQuery.getQuery();\n          boost = boostQuery.getBoost();\n        }\n        if (must.getClass() == MatchAllDocsQuery.class) {\n          // our single scoring clause matches everything: rewrite to a CSQ on the filter\n          // ignore SHOULD clause for now\n          BooleanQuery.Builder builder = new BooleanQuery.Builder();\n          for (BooleanClause clause : clauses) {\n            switch (clause.getOccur()) {\n              case FILTER:\n              case MUST_NOT:\n                builder.add(clause);\n                break;\n              default:\n                // ignore\n                break;\n            }\n          }\n          Query rewritten = builder.build();\n          rewritten = new ConstantScoreQuery(rewritten);\n          if (boost != 1f) {\n            rewritten = new BoostQuery(rewritten, boost);\n          }\n\n          // now add back the SHOULD clauses\n          builder = new BooleanQuery.Builder()\n            .setMinimumNumberShouldMatch(getMinimumNumberShouldMatch())\n            .add(rewritten, Occur.MUST);\n          for (Query query : clauseSets.get(Occur.SHOULD)) {\n            builder.add(query, Occur.SHOULD);\n          }\n          rewritten = builder.build();\n          return rewritten;\n        }\n      }\n    }\n\n    return super.rewrite(reader);\n  }\n\n","sourceOld":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if (clauses.size() == 0) {\n      return new MatchNoDocsQuery(\"empty BooleanQuery\");\n    }\n    \n    // optimize 1-clause queries\n    if (clauses.size() == 1) {\n      BooleanClause c = clauses.get(0);\n      Query query = c.getQuery();\n      if (minimumNumberShouldMatch == 1 && c.getOccur() == Occur.SHOULD) {\n        return query;\n      } else if (minimumNumberShouldMatch == 0) {\n        switch (c.getOccur()) {\n          case SHOULD:\n          case MUST:\n            return query;\n          case FILTER:\n            // no scoring clauses, so return a score of 0\n            return new BoostQuery(new ConstantScoreQuery(query), 0);\n          case MUST_NOT:\n            // no positive clauses\n            return new MatchNoDocsQuery(\"pure negative BooleanQuery\");\n          default:\n            throw new AssertionError();\n        }\n      }\n    }\n\n    // recursively rewrite\n    {\n      BooleanQuery.Builder builder = new BooleanQuery.Builder();\n      builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n      boolean actuallyRewritten = false;\n      for (BooleanClause clause : this) {\n        Query query = clause.getQuery();\n        Query rewritten = query.rewrite(reader);\n        if (rewritten != query) {\n          actuallyRewritten = true;\n        }\n        builder.add(rewritten, clause.getOccur());\n      }\n      if (actuallyRewritten) {\n        return builder.build();\n      }\n    }\n\n    // remove duplicate FILTER and MUST_NOT clauses\n    {\n      int clauseCount = 0;\n      for (Collection<Query> queries : clauseSets.values()) {\n        clauseCount += queries.size();\n      }\n      if (clauseCount != clauses.size()) {\n        // since clauseSets implicitly deduplicates FILTER and MUST_NOT\n        // clauses, this means there were duplicates\n        BooleanQuery.Builder rewritten = new BooleanQuery.Builder();\n        rewritten.setMinimumNumberShouldMatch(minimumNumberShouldMatch);\n        for (Map.Entry<Occur, Collection<Query>> entry : clauseSets.entrySet()) {\n          final Occur occur = entry.getKey();\n          for (Query query : entry.getValue()) {\n            rewritten.add(query, occur);\n          }\n        }\n        return rewritten.build();\n      }\n    }\n\n    // Check whether some clauses are both required and excluded\n    final Collection<Query> mustNotClauses = clauseSets.get(Occur.MUST_NOT);\n    if (!mustNotClauses.isEmpty()) {\n      final Predicate<Query> p = clauseSets.get(Occur.MUST)::contains;\n      if (mustNotClauses.stream().anyMatch(p.or(clauseSets.get(Occur.FILTER)::contains))) {\n        return new MatchNoDocsQuery(\"FILTER or MUST clause also in MUST_NOT\");\n      }\n      if (mustNotClauses.contains(new MatchAllDocsQuery())) {\n        return new MatchNoDocsQuery(\"MUST_NOT clause is MatchAllDocsQuery\");\n      }\n    }\n\n    // remove FILTER clauses that are also MUST clauses\n    // or that match all documents\n    if (clauseSets.get(Occur.MUST).size() > 0 && clauseSets.get(Occur.FILTER).size() > 0) {\n      final Set<Query> filters = new HashSet<Query>(clauseSets.get(Occur.FILTER));\n      boolean modified = filters.remove(new MatchAllDocsQuery());\n      modified |= filters.removeAll(clauseSets.get(Occur.MUST));\n      if (modified) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder();\n        builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n        for (BooleanClause clause : clauses) {\n          if (clause.getOccur() != Occur.FILTER) {\n            builder.add(clause);\n          }\n        }\n        for (Query filter : filters) {\n          builder.add(filter, Occur.FILTER);\n        }\n        return builder.build();\n      }\n    }\n\n    // convert FILTER clauses that are also SHOULD clauses to MUST clauses\n    if (clauseSets.get(Occur.SHOULD).size() > 0 && clauseSets.get(Occur.FILTER).size() > 0) {\n      final Collection<Query> filters = clauseSets.get(Occur.FILTER);\n      final Collection<Query> shoulds = clauseSets.get(Occur.SHOULD);\n\n      Set<Query> intersection = new HashSet<>(filters);\n      intersection.retainAll(shoulds);\n\n      if (intersection.isEmpty() == false) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder();\n        int minShouldMatch = getMinimumNumberShouldMatch();\n\n        for (BooleanClause clause : clauses) {\n          if (intersection.contains(clause.getQuery())) {\n            if (clause.getOccur() == Occur.SHOULD) {\n              builder.add(new BooleanClause(clause.getQuery(), Occur.MUST));\n              minShouldMatch--;\n            }\n          } else {\n            builder.add(clause);\n          }\n        }\n\n        builder.setMinimumNumberShouldMatch(Math.max(0, minShouldMatch));\n        return builder.build();\n      }\n    }\n\n\n    // Rewrite queries whose single scoring clause is a MUST clause on a\n    // MatchAllDocsQuery to a ConstantScoreQuery\n    {\n      final Collection<Query> musts = clauseSets.get(Occur.MUST);\n      final Collection<Query> filters = clauseSets.get(Occur.FILTER);\n      if (musts.size() == 1\n          && filters.size() > 0) {\n        Query must = musts.iterator().next();\n        float boost = 1f;\n        if (must instanceof BoostQuery) {\n          BoostQuery boostQuery = (BoostQuery) must;\n          must = boostQuery.getQuery();\n          boost = boostQuery.getBoost();\n        }\n        if (must.getClass() == MatchAllDocsQuery.class) {\n          // our single scoring clause matches everything: rewrite to a CSQ on the filter\n          // ignore SHOULD clause for now\n          BooleanQuery.Builder builder = new BooleanQuery.Builder();\n          for (BooleanClause clause : clauses) {\n            switch (clause.getOccur()) {\n              case FILTER:\n              case MUST_NOT:\n                builder.add(clause);\n                break;\n              default:\n                // ignore\n                break;\n            }\n          }\n          Query rewritten = builder.build();\n          rewritten = new ConstantScoreQuery(rewritten);\n          if (boost != 1f) {\n            rewritten = new BoostQuery(rewritten, boost);\n          }\n\n          // now add back the SHOULD clauses\n          builder = new BooleanQuery.Builder()\n            .setMinimumNumberShouldMatch(getMinimumNumberShouldMatch())\n            .add(rewritten, Occur.MUST);\n          for (Query query : clauseSets.get(Occur.SHOULD)) {\n            builder.add(query, Occur.SHOULD);\n          }\n          rewritten = builder.build();\n          return rewritten;\n        }\n      }\n    }\n\n    return super.rewrite(reader);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a7809d1d753b67f48b1a706e17034bf8b624ea3","date":1504366927,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery#rewrite(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery#rewrite(IndexReader).mjava","sourceNew":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if (clauses.size() == 0) {\n      return new MatchNoDocsQuery(\"empty BooleanQuery\");\n    }\n    \n    // optimize 1-clause queries\n    if (clauses.size() == 1) {\n      BooleanClause c = clauses.get(0);\n      Query query = c.getQuery();\n      if (minimumNumberShouldMatch == 1 && c.getOccur() == Occur.SHOULD) {\n        return query;\n      } else if (minimumNumberShouldMatch == 0) {\n        switch (c.getOccur()) {\n          case SHOULD:\n          case MUST:\n            return query;\n          case FILTER:\n            // no scoring clauses, so return a score of 0\n            return new BoostQuery(new ConstantScoreQuery(query), 0);\n          case MUST_NOT:\n            // no positive clauses\n            return new MatchNoDocsQuery(\"pure negative BooleanQuery\");\n          default:\n            throw new AssertionError();\n        }\n      }\n    }\n\n    // recursively rewrite\n    {\n      BooleanQuery.Builder builder = new BooleanQuery.Builder();\n      builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n      boolean actuallyRewritten = false;\n      for (BooleanClause clause : this) {\n        Query query = clause.getQuery();\n        Query rewritten = query.rewrite(reader);\n        if (rewritten != query) {\n          actuallyRewritten = true;\n        }\n        builder.add(rewritten, clause.getOccur());\n      }\n      if (actuallyRewritten) {\n        return builder.build();\n      }\n    }\n\n    // remove duplicate FILTER and MUST_NOT clauses\n    {\n      int clauseCount = 0;\n      for (Collection<Query> queries : clauseSets.values()) {\n        clauseCount += queries.size();\n      }\n      if (clauseCount != clauses.size()) {\n        // since clauseSets implicitly deduplicates FILTER and MUST_NOT\n        // clauses, this means there were duplicates\n        BooleanQuery.Builder rewritten = new BooleanQuery.Builder();\n        rewritten.setMinimumNumberShouldMatch(minimumNumberShouldMatch);\n        for (Map.Entry<Occur, Collection<Query>> entry : clauseSets.entrySet()) {\n          final Occur occur = entry.getKey();\n          for (Query query : entry.getValue()) {\n            rewritten.add(query, occur);\n          }\n        }\n        return rewritten.build();\n      }\n    }\n\n    // Check whether some clauses are both required and excluded\n    final Collection<Query> mustNotClauses = clauseSets.get(Occur.MUST_NOT);\n    if (!mustNotClauses.isEmpty()) {\n      final Predicate<Query> p = clauseSets.get(Occur.MUST)::contains;\n      if (mustNotClauses.stream().anyMatch(p.or(clauseSets.get(Occur.FILTER)::contains))) {\n        return new MatchNoDocsQuery(\"FILTER or MUST clause also in MUST_NOT\");\n      }\n      if (mustNotClauses.contains(new MatchAllDocsQuery())) {\n        return new MatchNoDocsQuery(\"MUST_NOT clause is MatchAllDocsQuery\");\n      }\n    }\n\n    // remove FILTER clauses that are also MUST clauses\n    // or that match all documents\n    if (clauseSets.get(Occur.MUST).size() > 0 && clauseSets.get(Occur.FILTER).size() > 0) {\n      final Set<Query> filters = new HashSet<Query>(clauseSets.get(Occur.FILTER));\n      boolean modified = filters.remove(new MatchAllDocsQuery());\n      modified |= filters.removeAll(clauseSets.get(Occur.MUST));\n      if (modified) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder();\n        builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n        for (BooleanClause clause : clauses) {\n          if (clause.getOccur() != Occur.FILTER) {\n            builder.add(clause);\n          }\n        }\n        for (Query filter : filters) {\n          builder.add(filter, Occur.FILTER);\n        }\n        return builder.build();\n      }\n    }\n\n    // convert FILTER clauses that are also SHOULD clauses to MUST clauses\n    if (clauseSets.get(Occur.SHOULD).size() > 0 && clauseSets.get(Occur.FILTER).size() > 0) {\n      final Collection<Query> filters = clauseSets.get(Occur.FILTER);\n      final Collection<Query> shoulds = clauseSets.get(Occur.SHOULD);\n\n      Set<Query> intersection = new HashSet<>(filters);\n      intersection.retainAll(shoulds);\n\n      if (intersection.isEmpty() == false) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder();\n        int minShouldMatch = getMinimumNumberShouldMatch();\n\n        for (BooleanClause clause : clauses) {\n          if (intersection.contains(clause.getQuery())) {\n            if (clause.getOccur() == Occur.SHOULD) {\n              builder.add(new BooleanClause(clause.getQuery(), Occur.MUST));\n              minShouldMatch--;\n            }\n          } else {\n            builder.add(clause);\n          }\n        }\n\n        builder.setMinimumNumberShouldMatch(Math.max(0, minShouldMatch));\n        return builder.build();\n      }\n    }\n\n    // Deduplicate SHOULD clauses by summing up their boosts\n    if (clauseSets.get(Occur.SHOULD).size() > 0 && minimumNumberShouldMatch <= 1) {\n      Map<Query, Double> shouldClauses = new HashMap<>();\n      for (Query query : clauseSets.get(Occur.SHOULD)) {\n        double boost = 1;\n        while (query instanceof BoostQuery) {\n          BoostQuery bq = (BoostQuery) query;\n          boost *= bq.getBoost();\n          query = bq.getQuery();\n        }\n        shouldClauses.put(query, shouldClauses.getOrDefault(query, 0d) + boost);\n      }\n      if (shouldClauses.size() != clauseSets.get(Occur.SHOULD).size()) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder()\n            .setMinimumNumberShouldMatch(minimumNumberShouldMatch);\n        for (Map.Entry<Query,Double> entry : shouldClauses.entrySet()) {\n          Query query = entry.getKey();\n          float boost = entry.getValue().floatValue();\n          if (boost != 1f) {\n            query = new BoostQuery(query, boost);\n          }\n          builder.add(query, Occur.SHOULD);\n        }\n        for (BooleanClause clause : clauses) {\n          if (clause.getOccur() != Occur.SHOULD) {\n            builder.add(clause);\n          }\n        }\n        return builder.build();\n      }\n    }\n\n    // Deduplicate MUST clauses by summing up their boosts\n    if (clauseSets.get(Occur.MUST).size() > 0) {\n      Map<Query, Double> mustClauses = new HashMap<>();\n      for (Query query : clauseSets.get(Occur.MUST)) {\n        double boost = 1;\n        while (query instanceof BoostQuery) {\n          BoostQuery bq = (BoostQuery) query;\n          boost *= bq.getBoost();\n          query = bq.getQuery();\n        }\n        mustClauses.put(query, mustClauses.getOrDefault(query, 0d) + boost);\n      }\n      if (mustClauses.size() != clauseSets.get(Occur.MUST).size()) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder()\n            .setMinimumNumberShouldMatch(minimumNumberShouldMatch);\n        for (Map.Entry<Query,Double> entry : mustClauses.entrySet()) {\n          Query query = entry.getKey();\n          float boost = entry.getValue().floatValue();\n          if (boost != 1f) {\n            query = new BoostQuery(query, boost);\n          }\n          builder.add(query, Occur.MUST);\n        }\n        for (BooleanClause clause : clauses) {\n          if (clause.getOccur() != Occur.MUST) {\n            builder.add(clause);\n          }\n        }\n        return builder.build();\n      }\n    }\n\n    // Rewrite queries whose single scoring clause is a MUST clause on a\n    // MatchAllDocsQuery to a ConstantScoreQuery\n    {\n      final Collection<Query> musts = clauseSets.get(Occur.MUST);\n      final Collection<Query> filters = clauseSets.get(Occur.FILTER);\n      if (musts.size() == 1\n          && filters.size() > 0) {\n        Query must = musts.iterator().next();\n        float boost = 1f;\n        if (must instanceof BoostQuery) {\n          BoostQuery boostQuery = (BoostQuery) must;\n          must = boostQuery.getQuery();\n          boost = boostQuery.getBoost();\n        }\n        if (must.getClass() == MatchAllDocsQuery.class) {\n          // our single scoring clause matches everything: rewrite to a CSQ on the filter\n          // ignore SHOULD clause for now\n          BooleanQuery.Builder builder = new BooleanQuery.Builder();\n          for (BooleanClause clause : clauses) {\n            switch (clause.getOccur()) {\n              case FILTER:\n              case MUST_NOT:\n                builder.add(clause);\n                break;\n              default:\n                // ignore\n                break;\n            }\n          }\n          Query rewritten = builder.build();\n          rewritten = new ConstantScoreQuery(rewritten);\n          if (boost != 1f) {\n            rewritten = new BoostQuery(rewritten, boost);\n          }\n\n          // now add back the SHOULD clauses\n          builder = new BooleanQuery.Builder()\n            .setMinimumNumberShouldMatch(getMinimumNumberShouldMatch())\n            .add(rewritten, Occur.MUST);\n          for (Query query : clauseSets.get(Occur.SHOULD)) {\n            builder.add(query, Occur.SHOULD);\n          }\n          rewritten = builder.build();\n          return rewritten;\n        }\n      }\n    }\n\n    return super.rewrite(reader);\n  }\n\n","sourceOld":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if (clauses.size() == 0) {\n      return new MatchNoDocsQuery(\"empty BooleanQuery\");\n    }\n    \n    // optimize 1-clause queries\n    if (clauses.size() == 1) {\n      BooleanClause c = clauses.get(0);\n      Query query = c.getQuery();\n      if (minimumNumberShouldMatch == 1 && c.getOccur() == Occur.SHOULD) {\n        return query;\n      } else if (minimumNumberShouldMatch == 0) {\n        switch (c.getOccur()) {\n          case SHOULD:\n          case MUST:\n            return query;\n          case FILTER:\n            // no scoring clauses, so return a score of 0\n            return new BoostQuery(new ConstantScoreQuery(query), 0);\n          case MUST_NOT:\n            // no positive clauses\n            return new MatchNoDocsQuery(\"pure negative BooleanQuery\");\n          default:\n            throw new AssertionError();\n        }\n      }\n    }\n\n    // recursively rewrite\n    {\n      BooleanQuery.Builder builder = new BooleanQuery.Builder();\n      builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n      boolean actuallyRewritten = false;\n      for (BooleanClause clause : this) {\n        Query query = clause.getQuery();\n        Query rewritten = query.rewrite(reader);\n        if (rewritten != query) {\n          actuallyRewritten = true;\n        }\n        builder.add(rewritten, clause.getOccur());\n      }\n      if (actuallyRewritten) {\n        return builder.build();\n      }\n    }\n\n    // remove duplicate FILTER and MUST_NOT clauses\n    {\n      int clauseCount = 0;\n      for (Collection<Query> queries : clauseSets.values()) {\n        clauseCount += queries.size();\n      }\n      if (clauseCount != clauses.size()) {\n        // since clauseSets implicitly deduplicates FILTER and MUST_NOT\n        // clauses, this means there were duplicates\n        BooleanQuery.Builder rewritten = new BooleanQuery.Builder();\n        rewritten.setMinimumNumberShouldMatch(minimumNumberShouldMatch);\n        for (Map.Entry<Occur, Collection<Query>> entry : clauseSets.entrySet()) {\n          final Occur occur = entry.getKey();\n          for (Query query : entry.getValue()) {\n            rewritten.add(query, occur);\n          }\n        }\n        return rewritten.build();\n      }\n    }\n\n    // Check whether some clauses are both required and excluded\n    final Collection<Query> mustNotClauses = clauseSets.get(Occur.MUST_NOT);\n    if (!mustNotClauses.isEmpty()) {\n      final Predicate<Query> p = clauseSets.get(Occur.MUST)::contains;\n      if (mustNotClauses.stream().anyMatch(p.or(clauseSets.get(Occur.FILTER)::contains))) {\n        return new MatchNoDocsQuery(\"FILTER or MUST clause also in MUST_NOT\");\n      }\n      if (mustNotClauses.contains(new MatchAllDocsQuery())) {\n        return new MatchNoDocsQuery(\"MUST_NOT clause is MatchAllDocsQuery\");\n      }\n    }\n\n    // remove FILTER clauses that are also MUST clauses\n    // or that match all documents\n    if (clauseSets.get(Occur.MUST).size() > 0 && clauseSets.get(Occur.FILTER).size() > 0) {\n      final Set<Query> filters = new HashSet<Query>(clauseSets.get(Occur.FILTER));\n      boolean modified = filters.remove(new MatchAllDocsQuery());\n      modified |= filters.removeAll(clauseSets.get(Occur.MUST));\n      if (modified) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder();\n        builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n        for (BooleanClause clause : clauses) {\n          if (clause.getOccur() != Occur.FILTER) {\n            builder.add(clause);\n          }\n        }\n        for (Query filter : filters) {\n          builder.add(filter, Occur.FILTER);\n        }\n        return builder.build();\n      }\n    }\n\n    // convert FILTER clauses that are also SHOULD clauses to MUST clauses\n    if (clauseSets.get(Occur.SHOULD).size() > 0 && clauseSets.get(Occur.FILTER).size() > 0) {\n      final Collection<Query> filters = clauseSets.get(Occur.FILTER);\n      final Collection<Query> shoulds = clauseSets.get(Occur.SHOULD);\n\n      Set<Query> intersection = new HashSet<>(filters);\n      intersection.retainAll(shoulds);\n\n      if (intersection.isEmpty() == false) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder();\n        int minShouldMatch = getMinimumNumberShouldMatch();\n\n        for (BooleanClause clause : clauses) {\n          if (intersection.contains(clause.getQuery())) {\n            if (clause.getOccur() == Occur.SHOULD) {\n              builder.add(new BooleanClause(clause.getQuery(), Occur.MUST));\n              minShouldMatch--;\n            }\n          } else {\n            builder.add(clause);\n          }\n        }\n\n        builder.setMinimumNumberShouldMatch(Math.max(0, minShouldMatch));\n        return builder.build();\n      }\n    }\n\n\n    // Rewrite queries whose single scoring clause is a MUST clause on a\n    // MatchAllDocsQuery to a ConstantScoreQuery\n    {\n      final Collection<Query> musts = clauseSets.get(Occur.MUST);\n      final Collection<Query> filters = clauseSets.get(Occur.FILTER);\n      if (musts.size() == 1\n          && filters.size() > 0) {\n        Query must = musts.iterator().next();\n        float boost = 1f;\n        if (must instanceof BoostQuery) {\n          BoostQuery boostQuery = (BoostQuery) must;\n          must = boostQuery.getQuery();\n          boost = boostQuery.getBoost();\n        }\n        if (must.getClass() == MatchAllDocsQuery.class) {\n          // our single scoring clause matches everything: rewrite to a CSQ on the filter\n          // ignore SHOULD clause for now\n          BooleanQuery.Builder builder = new BooleanQuery.Builder();\n          for (BooleanClause clause : clauses) {\n            switch (clause.getOccur()) {\n              case FILTER:\n              case MUST_NOT:\n                builder.add(clause);\n                break;\n              default:\n                // ignore\n                break;\n            }\n          }\n          Query rewritten = builder.build();\n          rewritten = new ConstantScoreQuery(rewritten);\n          if (boost != 1f) {\n            rewritten = new BoostQuery(rewritten, boost);\n          }\n\n          // now add back the SHOULD clauses\n          builder = new BooleanQuery.Builder()\n            .setMinimumNumberShouldMatch(getMinimumNumberShouldMatch())\n            .add(rewritten, Occur.MUST);\n          for (Query query : clauseSets.get(Occur.SHOULD)) {\n            builder.add(query, Occur.SHOULD);\n          }\n          rewritten = builder.build();\n          return rewritten;\n        }\n      }\n    }\n\n    return super.rewrite(reader);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a29d706f87429cdcfeb9131846f87d40087fd858","date":1555579490,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery#rewrite(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery#rewrite(IndexReader).mjava","sourceNew":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if (clauses.size() == 0) {\n      return new MatchNoDocsQuery(\"empty BooleanQuery\");\n    }\n    \n    // optimize 1-clause queries\n    if (clauses.size() == 1) {\n      BooleanClause c = clauses.get(0);\n      Query query = c.getQuery();\n      if (minimumNumberShouldMatch == 1 && c.getOccur() == Occur.SHOULD) {\n        return query;\n      } else if (minimumNumberShouldMatch == 0) {\n        switch (c.getOccur()) {\n          case SHOULD:\n          case MUST:\n            return query;\n          case FILTER:\n            // no scoring clauses, so return a score of 0\n            return new BoostQuery(new ConstantScoreQuery(query), 0);\n          case MUST_NOT:\n            // no positive clauses\n            return new MatchNoDocsQuery(\"pure negative BooleanQuery\");\n          default:\n            throw new AssertionError();\n        }\n      }\n    }\n\n    // recursively rewrite\n    {\n      BooleanQuery.Builder builder = new BooleanQuery.Builder();\n      builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n      boolean actuallyRewritten = false;\n      for (BooleanClause clause : this) {\n        Query query = clause.getQuery();\n        Query rewritten = query.rewrite(reader);\n        if (rewritten != query) {\n          // rewrite clause\n          actuallyRewritten = true;\n          builder.add(rewritten, clause.getOccur());\n        } else {\n          // leave as-is\n          builder.add(clause);\n        }\n      }\n      if (actuallyRewritten) {\n        return builder.build();\n      }\n    }\n\n    // remove duplicate FILTER and MUST_NOT clauses\n    {\n      int clauseCount = 0;\n      for (Collection<Query> queries : clauseSets.values()) {\n        clauseCount += queries.size();\n      }\n      if (clauseCount != clauses.size()) {\n        // since clauseSets implicitly deduplicates FILTER and MUST_NOT\n        // clauses, this means there were duplicates\n        BooleanQuery.Builder rewritten = new BooleanQuery.Builder();\n        rewritten.setMinimumNumberShouldMatch(minimumNumberShouldMatch);\n        for (Map.Entry<Occur, Collection<Query>> entry : clauseSets.entrySet()) {\n          final Occur occur = entry.getKey();\n          for (Query query : entry.getValue()) {\n            rewritten.add(query, occur);\n          }\n        }\n        return rewritten.build();\n      }\n    }\n\n    // Check whether some clauses are both required and excluded\n    final Collection<Query> mustNotClauses = clauseSets.get(Occur.MUST_NOT);\n    if (!mustNotClauses.isEmpty()) {\n      final Predicate<Query> p = clauseSets.get(Occur.MUST)::contains;\n      if (mustNotClauses.stream().anyMatch(p.or(clauseSets.get(Occur.FILTER)::contains))) {\n        return new MatchNoDocsQuery(\"FILTER or MUST clause also in MUST_NOT\");\n      }\n      if (mustNotClauses.contains(new MatchAllDocsQuery())) {\n        return new MatchNoDocsQuery(\"MUST_NOT clause is MatchAllDocsQuery\");\n      }\n    }\n\n    // remove FILTER clauses that are also MUST clauses\n    // or that match all documents\n    if (clauseSets.get(Occur.MUST).size() > 0 && clauseSets.get(Occur.FILTER).size() > 0) {\n      final Set<Query> filters = new HashSet<Query>(clauseSets.get(Occur.FILTER));\n      boolean modified = filters.remove(new MatchAllDocsQuery());\n      modified |= filters.removeAll(clauseSets.get(Occur.MUST));\n      if (modified) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder();\n        builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n        for (BooleanClause clause : clauses) {\n          if (clause.getOccur() != Occur.FILTER) {\n            builder.add(clause);\n          }\n        }\n        for (Query filter : filters) {\n          builder.add(filter, Occur.FILTER);\n        }\n        return builder.build();\n      }\n    }\n\n    // convert FILTER clauses that are also SHOULD clauses to MUST clauses\n    if (clauseSets.get(Occur.SHOULD).size() > 0 && clauseSets.get(Occur.FILTER).size() > 0) {\n      final Collection<Query> filters = clauseSets.get(Occur.FILTER);\n      final Collection<Query> shoulds = clauseSets.get(Occur.SHOULD);\n\n      Set<Query> intersection = new HashSet<>(filters);\n      intersection.retainAll(shoulds);\n\n      if (intersection.isEmpty() == false) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder();\n        int minShouldMatch = getMinimumNumberShouldMatch();\n\n        for (BooleanClause clause : clauses) {\n          if (intersection.contains(clause.getQuery())) {\n            if (clause.getOccur() == Occur.SHOULD) {\n              builder.add(new BooleanClause(clause.getQuery(), Occur.MUST));\n              minShouldMatch--;\n            }\n          } else {\n            builder.add(clause);\n          }\n        }\n\n        builder.setMinimumNumberShouldMatch(Math.max(0, minShouldMatch));\n        return builder.build();\n      }\n    }\n\n    // Deduplicate SHOULD clauses by summing up their boosts\n    if (clauseSets.get(Occur.SHOULD).size() > 0 && minimumNumberShouldMatch <= 1) {\n      Map<Query, Double> shouldClauses = new HashMap<>();\n      for (Query query : clauseSets.get(Occur.SHOULD)) {\n        double boost = 1;\n        while (query instanceof BoostQuery) {\n          BoostQuery bq = (BoostQuery) query;\n          boost *= bq.getBoost();\n          query = bq.getQuery();\n        }\n        shouldClauses.put(query, shouldClauses.getOrDefault(query, 0d) + boost);\n      }\n      if (shouldClauses.size() != clauseSets.get(Occur.SHOULD).size()) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder()\n            .setMinimumNumberShouldMatch(minimumNumberShouldMatch);\n        for (Map.Entry<Query,Double> entry : shouldClauses.entrySet()) {\n          Query query = entry.getKey();\n          float boost = entry.getValue().floatValue();\n          if (boost != 1f) {\n            query = new BoostQuery(query, boost);\n          }\n          builder.add(query, Occur.SHOULD);\n        }\n        for (BooleanClause clause : clauses) {\n          if (clause.getOccur() != Occur.SHOULD) {\n            builder.add(clause);\n          }\n        }\n        return builder.build();\n      }\n    }\n\n    // Deduplicate MUST clauses by summing up their boosts\n    if (clauseSets.get(Occur.MUST).size() > 0) {\n      Map<Query, Double> mustClauses = new HashMap<>();\n      for (Query query : clauseSets.get(Occur.MUST)) {\n        double boost = 1;\n        while (query instanceof BoostQuery) {\n          BoostQuery bq = (BoostQuery) query;\n          boost *= bq.getBoost();\n          query = bq.getQuery();\n        }\n        mustClauses.put(query, mustClauses.getOrDefault(query, 0d) + boost);\n      }\n      if (mustClauses.size() != clauseSets.get(Occur.MUST).size()) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder()\n            .setMinimumNumberShouldMatch(minimumNumberShouldMatch);\n        for (Map.Entry<Query,Double> entry : mustClauses.entrySet()) {\n          Query query = entry.getKey();\n          float boost = entry.getValue().floatValue();\n          if (boost != 1f) {\n            query = new BoostQuery(query, boost);\n          }\n          builder.add(query, Occur.MUST);\n        }\n        for (BooleanClause clause : clauses) {\n          if (clause.getOccur() != Occur.MUST) {\n            builder.add(clause);\n          }\n        }\n        return builder.build();\n      }\n    }\n\n    // Rewrite queries whose single scoring clause is a MUST clause on a\n    // MatchAllDocsQuery to a ConstantScoreQuery\n    {\n      final Collection<Query> musts = clauseSets.get(Occur.MUST);\n      final Collection<Query> filters = clauseSets.get(Occur.FILTER);\n      if (musts.size() == 1\n          && filters.size() > 0) {\n        Query must = musts.iterator().next();\n        float boost = 1f;\n        if (must instanceof BoostQuery) {\n          BoostQuery boostQuery = (BoostQuery) must;\n          must = boostQuery.getQuery();\n          boost = boostQuery.getBoost();\n        }\n        if (must.getClass() == MatchAllDocsQuery.class) {\n          // our single scoring clause matches everything: rewrite to a CSQ on the filter\n          // ignore SHOULD clause for now\n          BooleanQuery.Builder builder = new BooleanQuery.Builder();\n          for (BooleanClause clause : clauses) {\n            switch (clause.getOccur()) {\n              case FILTER:\n              case MUST_NOT:\n                builder.add(clause);\n                break;\n              default:\n                // ignore\n                break;\n            }\n          }\n          Query rewritten = builder.build();\n          rewritten = new ConstantScoreQuery(rewritten);\n          if (boost != 1f) {\n            rewritten = new BoostQuery(rewritten, boost);\n          }\n\n          // now add back the SHOULD clauses\n          builder = new BooleanQuery.Builder()\n            .setMinimumNumberShouldMatch(getMinimumNumberShouldMatch())\n            .add(rewritten, Occur.MUST);\n          for (Query query : clauseSets.get(Occur.SHOULD)) {\n            builder.add(query, Occur.SHOULD);\n          }\n          rewritten = builder.build();\n          return rewritten;\n        }\n      }\n    }\n\n    // Flatten nested disjunctions, this is important for block-max WAND to perform well\n    if (minimumNumberShouldMatch <= 1) {\n      BooleanQuery.Builder builder = new BooleanQuery.Builder();\n      builder.setMinimumNumberShouldMatch(minimumNumberShouldMatch);\n      boolean actuallyRewritten = false;\n      for (BooleanClause clause : clauses) {\n        if (clause.getOccur() == Occur.SHOULD && clause.getQuery() instanceof BooleanQuery) {\n          BooleanQuery innerQuery = (BooleanQuery) clause.getQuery();\n          if (innerQuery.isPureDisjunction()) {\n            actuallyRewritten = true;\n            for (BooleanClause innerClause : innerQuery.clauses()) {\n              builder.add(innerClause);\n            }\n          } else {\n            builder.add(clause);\n          }\n        } else {\n          builder.add(clause);\n        }\n      }\n      if (actuallyRewritten) {\n        return builder.build();\n      }\n    }\n\n    return super.rewrite(reader);\n  }\n\n","sourceOld":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if (clauses.size() == 0) {\n      return new MatchNoDocsQuery(\"empty BooleanQuery\");\n    }\n    \n    // optimize 1-clause queries\n    if (clauses.size() == 1) {\n      BooleanClause c = clauses.get(0);\n      Query query = c.getQuery();\n      if (minimumNumberShouldMatch == 1 && c.getOccur() == Occur.SHOULD) {\n        return query;\n      } else if (minimumNumberShouldMatch == 0) {\n        switch (c.getOccur()) {\n          case SHOULD:\n          case MUST:\n            return query;\n          case FILTER:\n            // no scoring clauses, so return a score of 0\n            return new BoostQuery(new ConstantScoreQuery(query), 0);\n          case MUST_NOT:\n            // no positive clauses\n            return new MatchNoDocsQuery(\"pure negative BooleanQuery\");\n          default:\n            throw new AssertionError();\n        }\n      }\n    }\n\n    // recursively rewrite\n    {\n      BooleanQuery.Builder builder = new BooleanQuery.Builder();\n      builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n      boolean actuallyRewritten = false;\n      for (BooleanClause clause : this) {\n        Query query = clause.getQuery();\n        Query rewritten = query.rewrite(reader);\n        if (rewritten != query) {\n          actuallyRewritten = true;\n        }\n        builder.add(rewritten, clause.getOccur());\n      }\n      if (actuallyRewritten) {\n        return builder.build();\n      }\n    }\n\n    // remove duplicate FILTER and MUST_NOT clauses\n    {\n      int clauseCount = 0;\n      for (Collection<Query> queries : clauseSets.values()) {\n        clauseCount += queries.size();\n      }\n      if (clauseCount != clauses.size()) {\n        // since clauseSets implicitly deduplicates FILTER and MUST_NOT\n        // clauses, this means there were duplicates\n        BooleanQuery.Builder rewritten = new BooleanQuery.Builder();\n        rewritten.setMinimumNumberShouldMatch(minimumNumberShouldMatch);\n        for (Map.Entry<Occur, Collection<Query>> entry : clauseSets.entrySet()) {\n          final Occur occur = entry.getKey();\n          for (Query query : entry.getValue()) {\n            rewritten.add(query, occur);\n          }\n        }\n        return rewritten.build();\n      }\n    }\n\n    // Check whether some clauses are both required and excluded\n    final Collection<Query> mustNotClauses = clauseSets.get(Occur.MUST_NOT);\n    if (!mustNotClauses.isEmpty()) {\n      final Predicate<Query> p = clauseSets.get(Occur.MUST)::contains;\n      if (mustNotClauses.stream().anyMatch(p.or(clauseSets.get(Occur.FILTER)::contains))) {\n        return new MatchNoDocsQuery(\"FILTER or MUST clause also in MUST_NOT\");\n      }\n      if (mustNotClauses.contains(new MatchAllDocsQuery())) {\n        return new MatchNoDocsQuery(\"MUST_NOT clause is MatchAllDocsQuery\");\n      }\n    }\n\n    // remove FILTER clauses that are also MUST clauses\n    // or that match all documents\n    if (clauseSets.get(Occur.MUST).size() > 0 && clauseSets.get(Occur.FILTER).size() > 0) {\n      final Set<Query> filters = new HashSet<Query>(clauseSets.get(Occur.FILTER));\n      boolean modified = filters.remove(new MatchAllDocsQuery());\n      modified |= filters.removeAll(clauseSets.get(Occur.MUST));\n      if (modified) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder();\n        builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n        for (BooleanClause clause : clauses) {\n          if (clause.getOccur() != Occur.FILTER) {\n            builder.add(clause);\n          }\n        }\n        for (Query filter : filters) {\n          builder.add(filter, Occur.FILTER);\n        }\n        return builder.build();\n      }\n    }\n\n    // convert FILTER clauses that are also SHOULD clauses to MUST clauses\n    if (clauseSets.get(Occur.SHOULD).size() > 0 && clauseSets.get(Occur.FILTER).size() > 0) {\n      final Collection<Query> filters = clauseSets.get(Occur.FILTER);\n      final Collection<Query> shoulds = clauseSets.get(Occur.SHOULD);\n\n      Set<Query> intersection = new HashSet<>(filters);\n      intersection.retainAll(shoulds);\n\n      if (intersection.isEmpty() == false) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder();\n        int minShouldMatch = getMinimumNumberShouldMatch();\n\n        for (BooleanClause clause : clauses) {\n          if (intersection.contains(clause.getQuery())) {\n            if (clause.getOccur() == Occur.SHOULD) {\n              builder.add(new BooleanClause(clause.getQuery(), Occur.MUST));\n              minShouldMatch--;\n            }\n          } else {\n            builder.add(clause);\n          }\n        }\n\n        builder.setMinimumNumberShouldMatch(Math.max(0, minShouldMatch));\n        return builder.build();\n      }\n    }\n\n    // Deduplicate SHOULD clauses by summing up their boosts\n    if (clauseSets.get(Occur.SHOULD).size() > 0 && minimumNumberShouldMatch <= 1) {\n      Map<Query, Double> shouldClauses = new HashMap<>();\n      for (Query query : clauseSets.get(Occur.SHOULD)) {\n        double boost = 1;\n        while (query instanceof BoostQuery) {\n          BoostQuery bq = (BoostQuery) query;\n          boost *= bq.getBoost();\n          query = bq.getQuery();\n        }\n        shouldClauses.put(query, shouldClauses.getOrDefault(query, 0d) + boost);\n      }\n      if (shouldClauses.size() != clauseSets.get(Occur.SHOULD).size()) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder()\n            .setMinimumNumberShouldMatch(minimumNumberShouldMatch);\n        for (Map.Entry<Query,Double> entry : shouldClauses.entrySet()) {\n          Query query = entry.getKey();\n          float boost = entry.getValue().floatValue();\n          if (boost != 1f) {\n            query = new BoostQuery(query, boost);\n          }\n          builder.add(query, Occur.SHOULD);\n        }\n        for (BooleanClause clause : clauses) {\n          if (clause.getOccur() != Occur.SHOULD) {\n            builder.add(clause);\n          }\n        }\n        return builder.build();\n      }\n    }\n\n    // Deduplicate MUST clauses by summing up their boosts\n    if (clauseSets.get(Occur.MUST).size() > 0) {\n      Map<Query, Double> mustClauses = new HashMap<>();\n      for (Query query : clauseSets.get(Occur.MUST)) {\n        double boost = 1;\n        while (query instanceof BoostQuery) {\n          BoostQuery bq = (BoostQuery) query;\n          boost *= bq.getBoost();\n          query = bq.getQuery();\n        }\n        mustClauses.put(query, mustClauses.getOrDefault(query, 0d) + boost);\n      }\n      if (mustClauses.size() != clauseSets.get(Occur.MUST).size()) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder()\n            .setMinimumNumberShouldMatch(minimumNumberShouldMatch);\n        for (Map.Entry<Query,Double> entry : mustClauses.entrySet()) {\n          Query query = entry.getKey();\n          float boost = entry.getValue().floatValue();\n          if (boost != 1f) {\n            query = new BoostQuery(query, boost);\n          }\n          builder.add(query, Occur.MUST);\n        }\n        for (BooleanClause clause : clauses) {\n          if (clause.getOccur() != Occur.MUST) {\n            builder.add(clause);\n          }\n        }\n        return builder.build();\n      }\n    }\n\n    // Rewrite queries whose single scoring clause is a MUST clause on a\n    // MatchAllDocsQuery to a ConstantScoreQuery\n    {\n      final Collection<Query> musts = clauseSets.get(Occur.MUST);\n      final Collection<Query> filters = clauseSets.get(Occur.FILTER);\n      if (musts.size() == 1\n          && filters.size() > 0) {\n        Query must = musts.iterator().next();\n        float boost = 1f;\n        if (must instanceof BoostQuery) {\n          BoostQuery boostQuery = (BoostQuery) must;\n          must = boostQuery.getQuery();\n          boost = boostQuery.getBoost();\n        }\n        if (must.getClass() == MatchAllDocsQuery.class) {\n          // our single scoring clause matches everything: rewrite to a CSQ on the filter\n          // ignore SHOULD clause for now\n          BooleanQuery.Builder builder = new BooleanQuery.Builder();\n          for (BooleanClause clause : clauses) {\n            switch (clause.getOccur()) {\n              case FILTER:\n              case MUST_NOT:\n                builder.add(clause);\n                break;\n              default:\n                // ignore\n                break;\n            }\n          }\n          Query rewritten = builder.build();\n          rewritten = new ConstantScoreQuery(rewritten);\n          if (boost != 1f) {\n            rewritten = new BoostQuery(rewritten, boost);\n          }\n\n          // now add back the SHOULD clauses\n          builder = new BooleanQuery.Builder()\n            .setMinimumNumberShouldMatch(getMinimumNumberShouldMatch())\n            .add(rewritten, Occur.MUST);\n          for (Query query : clauseSets.get(Occur.SHOULD)) {\n            builder.add(query, Occur.SHOULD);\n          }\n          rewritten = builder.build();\n          return rewritten;\n        }\n      }\n    }\n\n    return super.rewrite(reader);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"96754e492064a5eb18a950a6f9e6e30608e5f4e1","date":1596553690,"type":3,"author":"Julie Tibshirani","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery#rewrite(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BooleanQuery#rewrite(IndexReader).mjava","sourceNew":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if (clauses.size() == 0) {\n      return new MatchNoDocsQuery(\"empty BooleanQuery\");\n    }\n    \n    // optimize 1-clause queries\n    if (clauses.size() == 1) {\n      BooleanClause c = clauses.get(0);\n      Query query = c.getQuery();\n      if (minimumNumberShouldMatch == 1 && c.getOccur() == Occur.SHOULD) {\n        return query;\n      } else if (minimumNumberShouldMatch == 0) {\n        switch (c.getOccur()) {\n          case SHOULD:\n          case MUST:\n            return query;\n          case FILTER:\n            // no scoring clauses, so return a score of 0\n            return new BoostQuery(new ConstantScoreQuery(query), 0);\n          case MUST_NOT:\n            // no positive clauses\n            return new MatchNoDocsQuery(\"pure negative BooleanQuery\");\n          default:\n            throw new AssertionError();\n        }\n      }\n    }\n\n    // recursively rewrite\n    {\n      BooleanQuery.Builder builder = new BooleanQuery.Builder();\n      builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n      boolean actuallyRewritten = false;\n      for (BooleanClause clause : this) {\n        Query query = clause.getQuery();\n        Query rewritten = query.rewrite(reader);\n        if (rewritten != query) {\n          // rewrite clause\n          actuallyRewritten = true;\n          builder.add(rewritten, clause.getOccur());\n        } else {\n          // leave as-is\n          builder.add(clause);\n        }\n      }\n      if (actuallyRewritten) {\n        return builder.build();\n      }\n    }\n\n    // remove duplicate FILTER and MUST_NOT clauses\n    {\n      int clauseCount = 0;\n      for (Collection<Query> queries : clauseSets.values()) {\n        clauseCount += queries.size();\n      }\n      if (clauseCount != clauses.size()) {\n        // since clauseSets implicitly deduplicates FILTER and MUST_NOT\n        // clauses, this means there were duplicates\n        BooleanQuery.Builder rewritten = new BooleanQuery.Builder();\n        rewritten.setMinimumNumberShouldMatch(minimumNumberShouldMatch);\n        for (Map.Entry<Occur, Collection<Query>> entry : clauseSets.entrySet()) {\n          final Occur occur = entry.getKey();\n          for (Query query : entry.getValue()) {\n            rewritten.add(query, occur);\n          }\n        }\n        return rewritten.build();\n      }\n    }\n\n    // Check whether some clauses are both required and excluded\n    final Collection<Query> mustNotClauses = clauseSets.get(Occur.MUST_NOT);\n    if (!mustNotClauses.isEmpty()) {\n      final Predicate<Query> p = clauseSets.get(Occur.MUST)::contains;\n      if (mustNotClauses.stream().anyMatch(p.or(clauseSets.get(Occur.FILTER)::contains))) {\n        return new MatchNoDocsQuery(\"FILTER or MUST clause also in MUST_NOT\");\n      }\n      if (mustNotClauses.contains(new MatchAllDocsQuery())) {\n        return new MatchNoDocsQuery(\"MUST_NOT clause is MatchAllDocsQuery\");\n      }\n    }\n\n    // remove FILTER clauses that are also MUST clauses or that match all documents\n    if (clauseSets.get(Occur.FILTER).size() > 0) {\n      final Set<Query> filters = new HashSet<>(clauseSets.get(Occur.FILTER));\n      boolean modified = false;\n      if (filters.size() > 1 || clauseSets.get(Occur.MUST).isEmpty() == false) {\n        modified = filters.remove(new MatchAllDocsQuery());\n      }\n      modified |= filters.removeAll(clauseSets.get(Occur.MUST));\n      if (modified) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder();\n        builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n        for (BooleanClause clause : clauses) {\n          if (clause.getOccur() != Occur.FILTER) {\n            builder.add(clause);\n          }\n        }\n        for (Query filter : filters) {\n          builder.add(filter, Occur.FILTER);\n        }\n        return builder.build();\n      }\n    }\n\n    // convert FILTER clauses that are also SHOULD clauses to MUST clauses\n    if (clauseSets.get(Occur.SHOULD).size() > 0 && clauseSets.get(Occur.FILTER).size() > 0) {\n      final Collection<Query> filters = clauseSets.get(Occur.FILTER);\n      final Collection<Query> shoulds = clauseSets.get(Occur.SHOULD);\n\n      Set<Query> intersection = new HashSet<>(filters);\n      intersection.retainAll(shoulds);\n\n      if (intersection.isEmpty() == false) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder();\n        int minShouldMatch = getMinimumNumberShouldMatch();\n\n        for (BooleanClause clause : clauses) {\n          if (intersection.contains(clause.getQuery())) {\n            if (clause.getOccur() == Occur.SHOULD) {\n              builder.add(new BooleanClause(clause.getQuery(), Occur.MUST));\n              minShouldMatch--;\n            }\n          } else {\n            builder.add(clause);\n          }\n        }\n\n        builder.setMinimumNumberShouldMatch(Math.max(0, minShouldMatch));\n        return builder.build();\n      }\n    }\n\n    // Deduplicate SHOULD clauses by summing up their boosts\n    if (clauseSets.get(Occur.SHOULD).size() > 0 && minimumNumberShouldMatch <= 1) {\n      Map<Query, Double> shouldClauses = new HashMap<>();\n      for (Query query : clauseSets.get(Occur.SHOULD)) {\n        double boost = 1;\n        while (query instanceof BoostQuery) {\n          BoostQuery bq = (BoostQuery) query;\n          boost *= bq.getBoost();\n          query = bq.getQuery();\n        }\n        shouldClauses.put(query, shouldClauses.getOrDefault(query, 0d) + boost);\n      }\n      if (shouldClauses.size() != clauseSets.get(Occur.SHOULD).size()) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder()\n            .setMinimumNumberShouldMatch(minimumNumberShouldMatch);\n        for (Map.Entry<Query,Double> entry : shouldClauses.entrySet()) {\n          Query query = entry.getKey();\n          float boost = entry.getValue().floatValue();\n          if (boost != 1f) {\n            query = new BoostQuery(query, boost);\n          }\n          builder.add(query, Occur.SHOULD);\n        }\n        for (BooleanClause clause : clauses) {\n          if (clause.getOccur() != Occur.SHOULD) {\n            builder.add(clause);\n          }\n        }\n        return builder.build();\n      }\n    }\n\n    // Deduplicate MUST clauses by summing up their boosts\n    if (clauseSets.get(Occur.MUST).size() > 0) {\n      Map<Query, Double> mustClauses = new HashMap<>();\n      for (Query query : clauseSets.get(Occur.MUST)) {\n        double boost = 1;\n        while (query instanceof BoostQuery) {\n          BoostQuery bq = (BoostQuery) query;\n          boost *= bq.getBoost();\n          query = bq.getQuery();\n        }\n        mustClauses.put(query, mustClauses.getOrDefault(query, 0d) + boost);\n      }\n      if (mustClauses.size() != clauseSets.get(Occur.MUST).size()) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder()\n            .setMinimumNumberShouldMatch(minimumNumberShouldMatch);\n        for (Map.Entry<Query,Double> entry : mustClauses.entrySet()) {\n          Query query = entry.getKey();\n          float boost = entry.getValue().floatValue();\n          if (boost != 1f) {\n            query = new BoostQuery(query, boost);\n          }\n          builder.add(query, Occur.MUST);\n        }\n        for (BooleanClause clause : clauses) {\n          if (clause.getOccur() != Occur.MUST) {\n            builder.add(clause);\n          }\n        }\n        return builder.build();\n      }\n    }\n\n    // Rewrite queries whose single scoring clause is a MUST clause on a\n    // MatchAllDocsQuery to a ConstantScoreQuery\n    {\n      final Collection<Query> musts = clauseSets.get(Occur.MUST);\n      final Collection<Query> filters = clauseSets.get(Occur.FILTER);\n      if (musts.size() == 1\n          && filters.size() > 0) {\n        Query must = musts.iterator().next();\n        float boost = 1f;\n        if (must instanceof BoostQuery) {\n          BoostQuery boostQuery = (BoostQuery) must;\n          must = boostQuery.getQuery();\n          boost = boostQuery.getBoost();\n        }\n        if (must.getClass() == MatchAllDocsQuery.class) {\n          // our single scoring clause matches everything: rewrite to a CSQ on the filter\n          // ignore SHOULD clause for now\n          BooleanQuery.Builder builder = new BooleanQuery.Builder();\n          for (BooleanClause clause : clauses) {\n            switch (clause.getOccur()) {\n              case FILTER:\n              case MUST_NOT:\n                builder.add(clause);\n                break;\n              default:\n                // ignore\n                break;\n            }\n          }\n          Query rewritten = builder.build();\n          rewritten = new ConstantScoreQuery(rewritten);\n          if (boost != 1f) {\n            rewritten = new BoostQuery(rewritten, boost);\n          }\n\n          // now add back the SHOULD clauses\n          builder = new BooleanQuery.Builder()\n            .setMinimumNumberShouldMatch(getMinimumNumberShouldMatch())\n            .add(rewritten, Occur.MUST);\n          for (Query query : clauseSets.get(Occur.SHOULD)) {\n            builder.add(query, Occur.SHOULD);\n          }\n          rewritten = builder.build();\n          return rewritten;\n        }\n      }\n    }\n\n    // Flatten nested disjunctions, this is important for block-max WAND to perform well\n    if (minimumNumberShouldMatch <= 1) {\n      BooleanQuery.Builder builder = new BooleanQuery.Builder();\n      builder.setMinimumNumberShouldMatch(minimumNumberShouldMatch);\n      boolean actuallyRewritten = false;\n      for (BooleanClause clause : clauses) {\n        if (clause.getOccur() == Occur.SHOULD && clause.getQuery() instanceof BooleanQuery) {\n          BooleanQuery innerQuery = (BooleanQuery) clause.getQuery();\n          if (innerQuery.isPureDisjunction()) {\n            actuallyRewritten = true;\n            for (BooleanClause innerClause : innerQuery.clauses()) {\n              builder.add(innerClause);\n            }\n          } else {\n            builder.add(clause);\n          }\n        } else {\n          builder.add(clause);\n        }\n      }\n      if (actuallyRewritten) {\n        return builder.build();\n      }\n    }\n\n    return super.rewrite(reader);\n  }\n\n","sourceOld":"  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    if (clauses.size() == 0) {\n      return new MatchNoDocsQuery(\"empty BooleanQuery\");\n    }\n    \n    // optimize 1-clause queries\n    if (clauses.size() == 1) {\n      BooleanClause c = clauses.get(0);\n      Query query = c.getQuery();\n      if (minimumNumberShouldMatch == 1 && c.getOccur() == Occur.SHOULD) {\n        return query;\n      } else if (minimumNumberShouldMatch == 0) {\n        switch (c.getOccur()) {\n          case SHOULD:\n          case MUST:\n            return query;\n          case FILTER:\n            // no scoring clauses, so return a score of 0\n            return new BoostQuery(new ConstantScoreQuery(query), 0);\n          case MUST_NOT:\n            // no positive clauses\n            return new MatchNoDocsQuery(\"pure negative BooleanQuery\");\n          default:\n            throw new AssertionError();\n        }\n      }\n    }\n\n    // recursively rewrite\n    {\n      BooleanQuery.Builder builder = new BooleanQuery.Builder();\n      builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n      boolean actuallyRewritten = false;\n      for (BooleanClause clause : this) {\n        Query query = clause.getQuery();\n        Query rewritten = query.rewrite(reader);\n        if (rewritten != query) {\n          // rewrite clause\n          actuallyRewritten = true;\n          builder.add(rewritten, clause.getOccur());\n        } else {\n          // leave as-is\n          builder.add(clause);\n        }\n      }\n      if (actuallyRewritten) {\n        return builder.build();\n      }\n    }\n\n    // remove duplicate FILTER and MUST_NOT clauses\n    {\n      int clauseCount = 0;\n      for (Collection<Query> queries : clauseSets.values()) {\n        clauseCount += queries.size();\n      }\n      if (clauseCount != clauses.size()) {\n        // since clauseSets implicitly deduplicates FILTER and MUST_NOT\n        // clauses, this means there were duplicates\n        BooleanQuery.Builder rewritten = new BooleanQuery.Builder();\n        rewritten.setMinimumNumberShouldMatch(minimumNumberShouldMatch);\n        for (Map.Entry<Occur, Collection<Query>> entry : clauseSets.entrySet()) {\n          final Occur occur = entry.getKey();\n          for (Query query : entry.getValue()) {\n            rewritten.add(query, occur);\n          }\n        }\n        return rewritten.build();\n      }\n    }\n\n    // Check whether some clauses are both required and excluded\n    final Collection<Query> mustNotClauses = clauseSets.get(Occur.MUST_NOT);\n    if (!mustNotClauses.isEmpty()) {\n      final Predicate<Query> p = clauseSets.get(Occur.MUST)::contains;\n      if (mustNotClauses.stream().anyMatch(p.or(clauseSets.get(Occur.FILTER)::contains))) {\n        return new MatchNoDocsQuery(\"FILTER or MUST clause also in MUST_NOT\");\n      }\n      if (mustNotClauses.contains(new MatchAllDocsQuery())) {\n        return new MatchNoDocsQuery(\"MUST_NOT clause is MatchAllDocsQuery\");\n      }\n    }\n\n    // remove FILTER clauses that are also MUST clauses\n    // or that match all documents\n    if (clauseSets.get(Occur.MUST).size() > 0 && clauseSets.get(Occur.FILTER).size() > 0) {\n      final Set<Query> filters = new HashSet<Query>(clauseSets.get(Occur.FILTER));\n      boolean modified = filters.remove(new MatchAllDocsQuery());\n      modified |= filters.removeAll(clauseSets.get(Occur.MUST));\n      if (modified) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder();\n        builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());\n        for (BooleanClause clause : clauses) {\n          if (clause.getOccur() != Occur.FILTER) {\n            builder.add(clause);\n          }\n        }\n        for (Query filter : filters) {\n          builder.add(filter, Occur.FILTER);\n        }\n        return builder.build();\n      }\n    }\n\n    // convert FILTER clauses that are also SHOULD clauses to MUST clauses\n    if (clauseSets.get(Occur.SHOULD).size() > 0 && clauseSets.get(Occur.FILTER).size() > 0) {\n      final Collection<Query> filters = clauseSets.get(Occur.FILTER);\n      final Collection<Query> shoulds = clauseSets.get(Occur.SHOULD);\n\n      Set<Query> intersection = new HashSet<>(filters);\n      intersection.retainAll(shoulds);\n\n      if (intersection.isEmpty() == false) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder();\n        int minShouldMatch = getMinimumNumberShouldMatch();\n\n        for (BooleanClause clause : clauses) {\n          if (intersection.contains(clause.getQuery())) {\n            if (clause.getOccur() == Occur.SHOULD) {\n              builder.add(new BooleanClause(clause.getQuery(), Occur.MUST));\n              minShouldMatch--;\n            }\n          } else {\n            builder.add(clause);\n          }\n        }\n\n        builder.setMinimumNumberShouldMatch(Math.max(0, minShouldMatch));\n        return builder.build();\n      }\n    }\n\n    // Deduplicate SHOULD clauses by summing up their boosts\n    if (clauseSets.get(Occur.SHOULD).size() > 0 && minimumNumberShouldMatch <= 1) {\n      Map<Query, Double> shouldClauses = new HashMap<>();\n      for (Query query : clauseSets.get(Occur.SHOULD)) {\n        double boost = 1;\n        while (query instanceof BoostQuery) {\n          BoostQuery bq = (BoostQuery) query;\n          boost *= bq.getBoost();\n          query = bq.getQuery();\n        }\n        shouldClauses.put(query, shouldClauses.getOrDefault(query, 0d) + boost);\n      }\n      if (shouldClauses.size() != clauseSets.get(Occur.SHOULD).size()) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder()\n            .setMinimumNumberShouldMatch(minimumNumberShouldMatch);\n        for (Map.Entry<Query,Double> entry : shouldClauses.entrySet()) {\n          Query query = entry.getKey();\n          float boost = entry.getValue().floatValue();\n          if (boost != 1f) {\n            query = new BoostQuery(query, boost);\n          }\n          builder.add(query, Occur.SHOULD);\n        }\n        for (BooleanClause clause : clauses) {\n          if (clause.getOccur() != Occur.SHOULD) {\n            builder.add(clause);\n          }\n        }\n        return builder.build();\n      }\n    }\n\n    // Deduplicate MUST clauses by summing up their boosts\n    if (clauseSets.get(Occur.MUST).size() > 0) {\n      Map<Query, Double> mustClauses = new HashMap<>();\n      for (Query query : clauseSets.get(Occur.MUST)) {\n        double boost = 1;\n        while (query instanceof BoostQuery) {\n          BoostQuery bq = (BoostQuery) query;\n          boost *= bq.getBoost();\n          query = bq.getQuery();\n        }\n        mustClauses.put(query, mustClauses.getOrDefault(query, 0d) + boost);\n      }\n      if (mustClauses.size() != clauseSets.get(Occur.MUST).size()) {\n        BooleanQuery.Builder builder = new BooleanQuery.Builder()\n            .setMinimumNumberShouldMatch(minimumNumberShouldMatch);\n        for (Map.Entry<Query,Double> entry : mustClauses.entrySet()) {\n          Query query = entry.getKey();\n          float boost = entry.getValue().floatValue();\n          if (boost != 1f) {\n            query = new BoostQuery(query, boost);\n          }\n          builder.add(query, Occur.MUST);\n        }\n        for (BooleanClause clause : clauses) {\n          if (clause.getOccur() != Occur.MUST) {\n            builder.add(clause);\n          }\n        }\n        return builder.build();\n      }\n    }\n\n    // Rewrite queries whose single scoring clause is a MUST clause on a\n    // MatchAllDocsQuery to a ConstantScoreQuery\n    {\n      final Collection<Query> musts = clauseSets.get(Occur.MUST);\n      final Collection<Query> filters = clauseSets.get(Occur.FILTER);\n      if (musts.size() == 1\n          && filters.size() > 0) {\n        Query must = musts.iterator().next();\n        float boost = 1f;\n        if (must instanceof BoostQuery) {\n          BoostQuery boostQuery = (BoostQuery) must;\n          must = boostQuery.getQuery();\n          boost = boostQuery.getBoost();\n        }\n        if (must.getClass() == MatchAllDocsQuery.class) {\n          // our single scoring clause matches everything: rewrite to a CSQ on the filter\n          // ignore SHOULD clause for now\n          BooleanQuery.Builder builder = new BooleanQuery.Builder();\n          for (BooleanClause clause : clauses) {\n            switch (clause.getOccur()) {\n              case FILTER:\n              case MUST_NOT:\n                builder.add(clause);\n                break;\n              default:\n                // ignore\n                break;\n            }\n          }\n          Query rewritten = builder.build();\n          rewritten = new ConstantScoreQuery(rewritten);\n          if (boost != 1f) {\n            rewritten = new BoostQuery(rewritten, boost);\n          }\n\n          // now add back the SHOULD clauses\n          builder = new BooleanQuery.Builder()\n            .setMinimumNumberShouldMatch(getMinimumNumberShouldMatch())\n            .add(rewritten, Occur.MUST);\n          for (Query query : clauseSets.get(Occur.SHOULD)) {\n            builder.add(query, Occur.SHOULD);\n          }\n          rewritten = builder.build();\n          return rewritten;\n        }\n      }\n    }\n\n    // Flatten nested disjunctions, this is important for block-max WAND to perform well\n    if (minimumNumberShouldMatch <= 1) {\n      BooleanQuery.Builder builder = new BooleanQuery.Builder();\n      builder.setMinimumNumberShouldMatch(minimumNumberShouldMatch);\n      boolean actuallyRewritten = false;\n      for (BooleanClause clause : clauses) {\n        if (clause.getOccur() == Occur.SHOULD && clause.getQuery() instanceof BooleanQuery) {\n          BooleanQuery innerQuery = (BooleanQuery) clause.getQuery();\n          if (innerQuery.isPureDisjunction()) {\n            actuallyRewritten = true;\n            for (BooleanClause innerClause : innerQuery.clauses()) {\n              builder.add(innerClause);\n            }\n          } else {\n            builder.add(clause);\n          }\n        } else {\n          builder.add(clause);\n        }\n      }\n      if (actuallyRewritten) {\n        return builder.build();\n      }\n    }\n\n    return super.rewrite(reader);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"96754e492064a5eb18a950a6f9e6e30608e5f4e1":["a29d706f87429cdcfeb9131846f87d40087fd858"],"f3386f642cc92d1c5f226b8207f420c0b03aaefd":["f4778b794a897685e2f6c62caa1ac04983d1e69f"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ad158e4c28c7c33b7d3fd5c187a183d014d1f6ea":["4093b270ba337f9c25a4c0e6cb2ae2c07f697376"],"f5bf508bfc98425280b4bb708ab724f718705c9d":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"60fd173dead1b592384cfdd316dd645e39cac051":["e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a"],"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["0ab7a7b7d9840c6df78aaf2d36b9e8765da1069c"],"3a7809d1d753b67f48b1a706e17034bf8b624ea3":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","a8e4fbf51a35a1292b838d83f793794c274932a1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a","60fd173dead1b592384cfdd316dd645e39cac051"],"25f698887111a682424e759ba36083180899a1fd":["ad158e4c28c7c33b7d3fd5c187a183d014d1f6ea"],"e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a":["f4778b794a897685e2f6c62caa1ac04983d1e69f","f3386f642cc92d1c5f226b8207f420c0b03aaefd"],"a8e4fbf51a35a1292b838d83f793794c274932a1":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","33b0cbce3d060cc2547083fc6559e6080ec5ca23"],"59a0f907db1bc6eb97b13f9c1ef2191d14b5e632":["2dfdf766e55e943d942055d7de53c7ad6bc45283"],"a29d706f87429cdcfeb9131846f87d40087fd858":["a8e4fbf51a35a1292b838d83f793794c274932a1"],"2dfdf766e55e943d942055d7de53c7ad6bc45283":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747"],"399d5903979ca52514d2bc7e3a362e1c45885c94":["f5bf508bfc98425280b4bb708ab724f718705c9d"],"0ab7a7b7d9840c6df78aaf2d36b9e8765da1069c":["25f698887111a682424e759ba36083180899a1fd"],"f4778b794a897685e2f6c62caa1ac04983d1e69f":["c8a0e442f7b61f811680273b25da95994a724466"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["59a0f907db1bc6eb97b13f9c1ef2191d14b5e632","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"d8b3f2faaf05547a6ed4e2769b664522af9514b3":["59a0f907db1bc6eb97b13f9c1ef2191d14b5e632"],"c8a0e442f7b61f811680273b25da95994a724466":["d8b3f2faaf05547a6ed4e2769b664522af9514b3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["96754e492064a5eb18a950a6f9e6e30608e5f4e1"],"4093b270ba337f9c25a4c0e6cb2ae2c07f697376":["399d5903979ca52514d2bc7e3a362e1c45885c94"],"33b0cbce3d060cc2547083fc6559e6080ec5ca23":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"]},"commit2Childs":{"96754e492064a5eb18a950a6f9e6e30608e5f4e1":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f3386f642cc92d1c5f226b8207f420c0b03aaefd":["e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["f5bf508bfc98425280b4bb708ab724f718705c9d"],"ad158e4c28c7c33b7d3fd5c187a183d014d1f6ea":["25f698887111a682424e759ba36083180899a1fd"],"f5bf508bfc98425280b4bb708ab724f718705c9d":["399d5903979ca52514d2bc7e3a362e1c45885c94"],"60fd173dead1b592384cfdd316dd645e39cac051":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["2dfdf766e55e943d942055d7de53c7ad6bc45283"],"3a7809d1d753b67f48b1a706e17034bf8b624ea3":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["3a7809d1d753b67f48b1a706e17034bf8b624ea3","a8e4fbf51a35a1292b838d83f793794c274932a1","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","33b0cbce3d060cc2547083fc6559e6080ec5ca23"],"e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a":["60fd173dead1b592384cfdd316dd645e39cac051","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"25f698887111a682424e759ba36083180899a1fd":["0ab7a7b7d9840c6df78aaf2d36b9e8765da1069c"],"a8e4fbf51a35a1292b838d83f793794c274932a1":["3a7809d1d753b67f48b1a706e17034bf8b624ea3","a29d706f87429cdcfeb9131846f87d40087fd858"],"59a0f907db1bc6eb97b13f9c1ef2191d14b5e632":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","d8b3f2faaf05547a6ed4e2769b664522af9514b3"],"a29d706f87429cdcfeb9131846f87d40087fd858":["96754e492064a5eb18a950a6f9e6e30608e5f4e1"],"2dfdf766e55e943d942055d7de53c7ad6bc45283":["59a0f907db1bc6eb97b13f9c1ef2191d14b5e632"],"399d5903979ca52514d2bc7e3a362e1c45885c94":["4093b270ba337f9c25a4c0e6cb2ae2c07f697376"],"0ab7a7b7d9840c6df78aaf2d36b9e8765da1069c":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747"],"f4778b794a897685e2f6c62caa1ac04983d1e69f":["f3386f642cc92d1c5f226b8207f420c0b03aaefd","e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"d8b3f2faaf05547a6ed4e2769b664522af9514b3":["c8a0e442f7b61f811680273b25da95994a724466"],"c8a0e442f7b61f811680273b25da95994a724466":["f4778b794a897685e2f6c62caa1ac04983d1e69f"],"4093b270ba337f9c25a4c0e6cb2ae2c07f697376":["ad158e4c28c7c33b7d3fd5c187a183d014d1f6ea"],"33b0cbce3d060cc2547083fc6559e6080ec5ca23":["a8e4fbf51a35a1292b838d83f793794c274932a1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["3a7809d1d753b67f48b1a706e17034bf8b624ea3","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}