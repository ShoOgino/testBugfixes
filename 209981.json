{"path":"solr/contrib/analytics/src/java/org/apache/solr/analytics/ExpressionFactory#getParams(String,String,String[]).mjava","commits":[{"id":"c495edcca4d0bc51bf62d9be3527c87bf9b44ded","date":1498673617,"type":0,"author":"Dennis Gove","isMerge":false,"pathNew":"solr/contrib/analytics/src/java/org/apache/solr/analytics/ExpressionFactory#getParams(String,String,String[]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Parse a function expression string and break up the parameters of the function into separate strings.\n   * <p>\n   * The parsing replaces the variable length parameter, and lambda for-each's using the variable length parameter,\n   * with the parameter values in the returned parameter string.\n   * <p>\n   * Parsing breaks up parameters by commas (',') and ignores ',' inside of extra parens and quotes (both ' and \"), since these commas are either\n   * splitting up the parameters of nested functions or are apart of strings.\n   * <br>\n   * The only escaping that needs to be done is \" within a double quote string and ' within a single quote string and \\ within any string.\n   * For example\\:\n   * <ul>\n   * <li> {@code func(\"This is \\\" the \\\\ escaping ' example\")} will be treated as {@code func(This is \" the \\ escaping ' example)}\n   * <li> {@code func('This is \" the \\\\ escaping \\' example')} will be treated as {@code func(This is \" the \\ escaping ' example)}\n   * </ul>\n   * In string constants the \\ character is used to escape quotes, so it can never be used alone. in order to write a \\ you must write \\\\\n   * \n   * @param expression the function expression to parse\n   * @param varLengthParamName the name of the variable length parameter that is used in the expression, pass null if none is used.\n   * @param varLengthParamValues the values of the variable length parameter that are used in the expression, pass null if none are used.\n   * @return the parsed and split arguments to the function\n   * @throws SolrException if the expression has incorrect syntax.\n   */\n  private static String[] getParams(String expression, String varLengthParamName, String[] varLengthParamValues) throws SolrException {\n    Matcher m = functionParamsPattern.matcher(expression);\n    if (!m.matches()) {\n      return new String[0];\n    }\n    String paramsStr = m.group(1);\n    \n    ArrayList<String> paramsList = new ArrayList<String>();\n    StringBuilder param = new StringBuilder();\n    \n    // Variables to help while filling out the values of for-each lambda functions.\n    boolean inForEach = false;\n    int forEachStart = -1;\n    int forEachIter = -1;\n    int forEachLevel = -1;\n    \n    // The current level of nested parenthesis, 0 means the iteration is in no nested parentheses\n    int parenCount = 0;\n    // If the iteration is currently in a single-quote string constant\n    boolean singleQuoteOn = false;\n    // If the iteration is currently in a double-quote string constant\n    boolean doubleQuoteOn = false;\n    // If the iteration is currently in any kind of string constant\n    boolean quoteOn = false;\n    // Is the next character escaped.\n    boolean escaped = false;\n    \n    char[] chars = paramsStr.toCharArray();\n    \n    // Iterate through every character, building the params one at a time\n    for (int i = 0; i < chars.length; ++i) {\n      char c = chars[i];\n      \n      if (c == ' ' && !quoteOn) {\n        // Ignore white space that is not in string constants\n        continue;\n      } else if (c == ',' && parenCount == 0 && !quoteOn) {\n        // This signifies the end of one parameter and the start of another, since we are not in a nested parenthesis or a string constant\n        String paramStr = param.toString();\n        if (paramStr.length() == 0) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"Empty parameter in expression: \" + expression);\n        }\n        // check to see if the parameter is a variable length parameter\n        if (paramStr.equals(varLengthParamName)) {\n          // Add every variable length parameter value, since there are a variable amount\n          for (String paramName : varLengthParamValues) {\n            paramsList.add(paramName);\n          }\n        } else {\n          paramsList.add(paramStr);\n        }\n        \n        param.setLength(0);\n        continue;\n      } else if (c == ',' && !quoteOn && inForEach) {\n        // separate the for each parameters, so they can be replaced with the result of the for each\n        if (param.charAt(param.length()-1) == variableForEachParam && \n            (param.charAt(param.length()-2) == '(' || param.charAt(param.length()-2) == ',')) {\n          param.setLength(param.length()-1);\n          param.append(varLengthParamValues[forEachIter++]);\n        }\n      } else if (c == '\"' && !singleQuoteOn) {\n        // Deal with escaping, or ending string constants\n        if (doubleQuoteOn && !escaped) {\n          doubleQuoteOn = false;\n          quoteOn = false;\n        } else if (!quoteOn) {\n          doubleQuoteOn = true;\n          quoteOn = true;\n        } else {\n          // only happens if escaped is true\n          escaped = false;\n        }\n      }  else if (c== '\\'' && !doubleQuoteOn) {\n        // Deal with escaping, or ending string constants\n        if (singleQuoteOn && !escaped) {\n          singleQuoteOn = false;\n          quoteOn = false;\n        } else if (!singleQuoteOn) {\n          singleQuoteOn = true;\n          quoteOn = true;\n        } else {\n          // only happens if escaped is true\n          escaped = false;\n        }\n      } else if (c == '(' && !quoteOn) {\n        // Reached a further level of nested parentheses\n        parenCount++;\n      } else if (c == ')' && !quoteOn) {\n        // Returned from a level of nested parentheses\n        parenCount--;\n        if (parenCount < 0) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"The following expression has extra end parens: \" + param.toString());\n        }\n        if (inForEach) {\n          if (param.charAt(param.length()-1) == variableForEachParam && \n              (param.charAt(param.length()-2) == '(' || param.charAt(param.length()-2) == ',')) {\n            param.setLength(param.length()-1);\n            param.append(varLengthParamValues[forEachIter++]);\n          }\n          if (forEachLevel == parenCount) {\n            // at the end of the for-each start the parsing of the for-each again, with the next value of the variable length parameter\n            if (forEachIter == 0) {\n              throw new SolrException(ErrorCode.BAD_REQUEST,\"For each statement for variable '\" + varLengthParamName + \"' has no use of lambda variable \" + variableForEachParam);\n            } else if (forEachIter < varLengthParamValues.length) {\n              if (parenCount == 0) {\n                param.append(')');\n                paramsList.add(param.toString());\n                param.setLength(0);\n              } else {\n                param.append(')');\n                param.append(',');\n              }\n              i = forEachStart;\n              continue;\n            } else {\n              inForEach = false;\n            }\n          }\n        }\n      }\n      if (c == '\\\\') {\n        // Escaping or escaped backslash\n        if (!quoteOn) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"The following expression has escaped characters outside of quotation marks: \" + expression.toString());\n        }\n        if (escaped) {\n          escaped = false;\n        } else {\n          escaped = true;\n          if (parenCount == 0) {\n            continue;\n          }\n        }\n      } else if (escaped) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\"Invalid escape character '\" + c + \"' used in the following expression: \" + expression.toString());\n      }\n      if (c == variableForEachSep && !quoteOn && varLengthParamName != null) {\n        int varStart = param.length()-varLengthParamName.length();\n        if (param.subSequence(varStart, param.length()).equals(varLengthParamName)) {\n          inForEach = true;\n          forEachStart = i;\n          forEachIter = 0;\n          forEachLevel = parenCount;\n          param.setLength(varStart);\n          continue;\n        }\n        throw new SolrException(ErrorCode.BAD_REQUEST,\"For-each called on invalid parameter '\" + param.toString().trim());\n      }\n      param.append(c);\n    }\n    String paramStr = param.toString().trim();\n    if (paramStr.length() == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\"Empty parameter in expression: \" + expression);\n    }\n    if (parenCount > 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\"The following expression needs more end parens: \" + param.toString());\n    }\n    if (quoteOn) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\"Misplaced quotation marks in expression: \" + expression);\n    }\n    if (paramStr.equals(varLengthParamName)) {\n      for (String paramName : varLengthParamValues) {\n        paramsList.add(paramName);\n      }\n    } else {\n      paramsList.add(paramStr);\n    }\n    return paramsList.toArray(new String[paramsList.size()]);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"solr/contrib/analytics/src/java/org/apache/solr/analytics/ExpressionFactory#getParams(String,String,String[]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Parse a function expression string and break up the parameters of the function into separate strings.\n   * <p>\n   * The parsing replaces the variable length parameter, and lambda for-each's using the variable length parameter,\n   * with the parameter values in the returned parameter string.\n   * <p>\n   * Parsing breaks up parameters by commas (',') and ignores ',' inside of extra parens and quotes (both ' and \"), since these commas are either\n   * splitting up the parameters of nested functions or are apart of strings.\n   * <br>\n   * The only escaping that needs to be done is \" within a double quote string and ' within a single quote string and \\ within any string.\n   * For example\\:\n   * <ul>\n   * <li> {@code func(\"This is \\\" the \\\\ escaping ' example\")} will be treated as {@code func(This is \" the \\ escaping ' example)}\n   * <li> {@code func('This is \" the \\\\ escaping \\' example')} will be treated as {@code func(This is \" the \\ escaping ' example)}\n   * </ul>\n   * In string constants the \\ character is used to escape quotes, so it can never be used alone. in order to write a \\ you must write \\\\\n   * \n   * @param expression the function expression to parse\n   * @param varLengthParamName the name of the variable length parameter that is used in the expression, pass null if none is used.\n   * @param varLengthParamValues the values of the variable length parameter that are used in the expression, pass null if none are used.\n   * @return the parsed and split arguments to the function\n   * @throws SolrException if the expression has incorrect syntax.\n   */\n  private static String[] getParams(String expression, String varLengthParamName, String[] varLengthParamValues) throws SolrException {\n    Matcher m = functionParamsPattern.matcher(expression);\n    if (!m.matches()) {\n      return new String[0];\n    }\n    String paramsStr = m.group(1);\n    \n    ArrayList<String> paramsList = new ArrayList<String>();\n    StringBuilder param = new StringBuilder();\n    \n    // Variables to help while filling out the values of for-each lambda functions.\n    boolean inForEach = false;\n    int forEachStart = -1;\n    int forEachIter = -1;\n    int forEachLevel = -1;\n    \n    // The current level of nested parenthesis, 0 means the iteration is in no nested parentheses\n    int parenCount = 0;\n    // If the iteration is currently in a single-quote string constant\n    boolean singleQuoteOn = false;\n    // If the iteration is currently in a double-quote string constant\n    boolean doubleQuoteOn = false;\n    // If the iteration is currently in any kind of string constant\n    boolean quoteOn = false;\n    // Is the next character escaped.\n    boolean escaped = false;\n    \n    char[] chars = paramsStr.toCharArray();\n    \n    // Iterate through every character, building the params one at a time\n    for (int i = 0; i < chars.length; ++i) {\n      char c = chars[i];\n      \n      if (c == ' ' && !quoteOn) {\n        // Ignore white space that is not in string constants\n        continue;\n      } else if (c == ',' && parenCount == 0 && !quoteOn) {\n        // This signifies the end of one parameter and the start of another, since we are not in a nested parenthesis or a string constant\n        String paramStr = param.toString();\n        if (paramStr.length() == 0) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"Empty parameter in expression: \" + expression);\n        }\n        // check to see if the parameter is a variable length parameter\n        if (paramStr.equals(varLengthParamName)) {\n          // Add every variable length parameter value, since there are a variable amount\n          for (String paramName : varLengthParamValues) {\n            paramsList.add(paramName);\n          }\n        } else {\n          paramsList.add(paramStr);\n        }\n        \n        param.setLength(0);\n        continue;\n      } else if (c == ',' && !quoteOn && inForEach) {\n        // separate the for each parameters, so they can be replaced with the result of the for each\n        if (param.charAt(param.length()-1) == variableForEachParam && \n            (param.charAt(param.length()-2) == '(' || param.charAt(param.length()-2) == ',')) {\n          param.setLength(param.length()-1);\n          param.append(varLengthParamValues[forEachIter++]);\n        }\n      } else if (c == '\"' && !singleQuoteOn) {\n        // Deal with escaping, or ending string constants\n        if (doubleQuoteOn && !escaped) {\n          doubleQuoteOn = false;\n          quoteOn = false;\n        } else if (!quoteOn) {\n          doubleQuoteOn = true;\n          quoteOn = true;\n        } else {\n          // only happens if escaped is true\n          escaped = false;\n        }\n      }  else if (c== '\\'' && !doubleQuoteOn) {\n        // Deal with escaping, or ending string constants\n        if (singleQuoteOn && !escaped) {\n          singleQuoteOn = false;\n          quoteOn = false;\n        } else if (!singleQuoteOn) {\n          singleQuoteOn = true;\n          quoteOn = true;\n        } else {\n          // only happens if escaped is true\n          escaped = false;\n        }\n      } else if (c == '(' && !quoteOn) {\n        // Reached a further level of nested parentheses\n        parenCount++;\n      } else if (c == ')' && !quoteOn) {\n        // Returned from a level of nested parentheses\n        parenCount--;\n        if (parenCount < 0) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"The following expression has extra end parens: \" + param.toString());\n        }\n        if (inForEach) {\n          if (param.charAt(param.length()-1) == variableForEachParam && \n              (param.charAt(param.length()-2) == '(' || param.charAt(param.length()-2) == ',')) {\n            param.setLength(param.length()-1);\n            param.append(varLengthParamValues[forEachIter++]);\n          }\n          if (forEachLevel == parenCount) {\n            // at the end of the for-each start the parsing of the for-each again, with the next value of the variable length parameter\n            if (forEachIter == 0) {\n              throw new SolrException(ErrorCode.BAD_REQUEST,\"For each statement for variable '\" + varLengthParamName + \"' has no use of lambda variable \" + variableForEachParam);\n            } else if (forEachIter < varLengthParamValues.length) {\n              if (parenCount == 0) {\n                param.append(')');\n                paramsList.add(param.toString());\n                param.setLength(0);\n              } else {\n                param.append(')');\n                param.append(',');\n              }\n              i = forEachStart;\n              continue;\n            } else {\n              inForEach = false;\n            }\n          }\n        }\n      }\n      if (c == '\\\\') {\n        // Escaping or escaped backslash\n        if (!quoteOn) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"The following expression has escaped characters outside of quotation marks: \" + expression.toString());\n        }\n        if (escaped) {\n          escaped = false;\n        } else {\n          escaped = true;\n          if (parenCount == 0) {\n            continue;\n          }\n        }\n      } else if (escaped) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\"Invalid escape character '\" + c + \"' used in the following expression: \" + expression.toString());\n      }\n      if (c == variableForEachSep && !quoteOn && varLengthParamName != null) {\n        int varStart = param.length()-varLengthParamName.length();\n        if (param.subSequence(varStart, param.length()).equals(varLengthParamName)) {\n          inForEach = true;\n          forEachStart = i;\n          forEachIter = 0;\n          forEachLevel = parenCount;\n          param.setLength(varStart);\n          continue;\n        }\n        throw new SolrException(ErrorCode.BAD_REQUEST,\"For-each called on invalid parameter '\" + param.toString().trim());\n      }\n      param.append(c);\n    }\n    String paramStr = param.toString().trim();\n    if (paramStr.length() == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\"Empty parameter in expression: \" + expression);\n    }\n    if (parenCount > 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\"The following expression needs more end parens: \" + param.toString());\n    }\n    if (quoteOn) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\"Misplaced quotation marks in expression: \" + expression);\n    }\n    if (paramStr.equals(varLengthParamName)) {\n      for (String paramName : varLengthParamValues) {\n        paramsList.add(paramName);\n      }\n    } else {\n      paramsList.add(paramStr);\n    }\n    return paramsList.toArray(new String[paramsList.size()]);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"30c8e5574b55d57947e989443dfde611646530ee","date":1499131153,"type":0,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/contrib/analytics/src/java/org/apache/solr/analytics/ExpressionFactory#getParams(String,String,String[]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Parse a function expression string and break up the parameters of the function into separate strings.\n   * <p>\n   * The parsing replaces the variable length parameter, and lambda for-each's using the variable length parameter,\n   * with the parameter values in the returned parameter string.\n   * <p>\n   * Parsing breaks up parameters by commas (',') and ignores ',' inside of extra parens and quotes (both ' and \"), since these commas are either\n   * splitting up the parameters of nested functions or are apart of strings.\n   * <br>\n   * The only escaping that needs to be done is \" within a double quote string and ' within a single quote string and \\ within any string.\n   * For example\\:\n   * <ul>\n   * <li> {@code func(\"This is \\\" the \\\\ escaping ' example\")} will be treated as {@code func(This is \" the \\ escaping ' example)}\n   * <li> {@code func('This is \" the \\\\ escaping \\' example')} will be treated as {@code func(This is \" the \\ escaping ' example)}\n   * </ul>\n   * In string constants the \\ character is used to escape quotes, so it can never be used alone. in order to write a \\ you must write \\\\\n   * \n   * @param expression the function expression to parse\n   * @param varLengthParamName the name of the variable length parameter that is used in the expression, pass null if none is used.\n   * @param varLengthParamValues the values of the variable length parameter that are used in the expression, pass null if none are used.\n   * @return the parsed and split arguments to the function\n   * @throws SolrException if the expression has incorrect syntax.\n   */\n  private static String[] getParams(String expression, String varLengthParamName, String[] varLengthParamValues) throws SolrException {\n    Matcher m = functionParamsPattern.matcher(expression);\n    if (!m.matches()) {\n      return new String[0];\n    }\n    String paramsStr = m.group(1);\n    \n    ArrayList<String> paramsList = new ArrayList<String>();\n    StringBuilder param = new StringBuilder();\n    \n    // Variables to help while filling out the values of for-each lambda functions.\n    boolean inForEach = false;\n    int forEachStart = -1;\n    int forEachIter = -1;\n    int forEachLevel = -1;\n    \n    // The current level of nested parenthesis, 0 means the iteration is in no nested parentheses\n    int parenCount = 0;\n    // If the iteration is currently in a single-quote string constant\n    boolean singleQuoteOn = false;\n    // If the iteration is currently in a double-quote string constant\n    boolean doubleQuoteOn = false;\n    // If the iteration is currently in any kind of string constant\n    boolean quoteOn = false;\n    // Is the next character escaped.\n    boolean escaped = false;\n    \n    char[] chars = paramsStr.toCharArray();\n    \n    // Iterate through every character, building the params one at a time\n    for (int i = 0; i < chars.length; ++i) {\n      char c = chars[i];\n      \n      if (c == ' ' && !quoteOn) {\n        // Ignore white space that is not in string constants\n        continue;\n      } else if (c == ',' && parenCount == 0 && !quoteOn) {\n        // This signifies the end of one parameter and the start of another, since we are not in a nested parenthesis or a string constant\n        String paramStr = param.toString();\n        if (paramStr.length() == 0) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"Empty parameter in expression: \" + expression);\n        }\n        // check to see if the parameter is a variable length parameter\n        if (paramStr.equals(varLengthParamName)) {\n          // Add every variable length parameter value, since there are a variable amount\n          for (String paramName : varLengthParamValues) {\n            paramsList.add(paramName);\n          }\n        } else {\n          paramsList.add(paramStr);\n        }\n        \n        param.setLength(0);\n        continue;\n      } else if (c == ',' && !quoteOn && inForEach) {\n        // separate the for each parameters, so they can be replaced with the result of the for each\n        if (param.charAt(param.length()-1) == variableForEachParam && \n            (param.charAt(param.length()-2) == '(' || param.charAt(param.length()-2) == ',')) {\n          param.setLength(param.length()-1);\n          param.append(varLengthParamValues[forEachIter++]);\n        }\n      } else if (c == '\"' && !singleQuoteOn) {\n        // Deal with escaping, or ending string constants\n        if (doubleQuoteOn && !escaped) {\n          doubleQuoteOn = false;\n          quoteOn = false;\n        } else if (!quoteOn) {\n          doubleQuoteOn = true;\n          quoteOn = true;\n        } else {\n          // only happens if escaped is true\n          escaped = false;\n        }\n      }  else if (c== '\\'' && !doubleQuoteOn) {\n        // Deal with escaping, or ending string constants\n        if (singleQuoteOn && !escaped) {\n          singleQuoteOn = false;\n          quoteOn = false;\n        } else if (!singleQuoteOn) {\n          singleQuoteOn = true;\n          quoteOn = true;\n        } else {\n          // only happens if escaped is true\n          escaped = false;\n        }\n      } else if (c == '(' && !quoteOn) {\n        // Reached a further level of nested parentheses\n        parenCount++;\n      } else if (c == ')' && !quoteOn) {\n        // Returned from a level of nested parentheses\n        parenCount--;\n        if (parenCount < 0) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"The following expression has extra end parens: \" + param.toString());\n        }\n        if (inForEach) {\n          if (param.charAt(param.length()-1) == variableForEachParam && \n              (param.charAt(param.length()-2) == '(' || param.charAt(param.length()-2) == ',')) {\n            param.setLength(param.length()-1);\n            param.append(varLengthParamValues[forEachIter++]);\n          }\n          if (forEachLevel == parenCount) {\n            // at the end of the for-each start the parsing of the for-each again, with the next value of the variable length parameter\n            if (forEachIter == 0) {\n              throw new SolrException(ErrorCode.BAD_REQUEST,\"For each statement for variable '\" + varLengthParamName + \"' has no use of lambda variable \" + variableForEachParam);\n            } else if (forEachIter < varLengthParamValues.length) {\n              if (parenCount == 0) {\n                param.append(')');\n                paramsList.add(param.toString());\n                param.setLength(0);\n              } else {\n                param.append(')');\n                param.append(',');\n              }\n              i = forEachStart;\n              continue;\n            } else {\n              inForEach = false;\n            }\n          }\n        }\n      }\n      if (c == '\\\\') {\n        // Escaping or escaped backslash\n        if (!quoteOn) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"The following expression has escaped characters outside of quotation marks: \" + expression.toString());\n        }\n        if (escaped) {\n          escaped = false;\n        } else {\n          escaped = true;\n          if (parenCount == 0) {\n            continue;\n          }\n        }\n      } else if (escaped) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\"Invalid escape character '\" + c + \"' used in the following expression: \" + expression.toString());\n      }\n      if (c == variableForEachSep && !quoteOn && varLengthParamName != null) {\n        int varStart = param.length()-varLengthParamName.length();\n        if (param.subSequence(varStart, param.length()).equals(varLengthParamName)) {\n          inForEach = true;\n          forEachStart = i;\n          forEachIter = 0;\n          forEachLevel = parenCount;\n          param.setLength(varStart);\n          continue;\n        }\n        throw new SolrException(ErrorCode.BAD_REQUEST,\"For-each called on invalid parameter '\" + param.toString().trim());\n      }\n      param.append(c);\n    }\n    String paramStr = param.toString().trim();\n    if (paramStr.length() == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\"Empty parameter in expression: \" + expression);\n    }\n    if (parenCount > 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\"The following expression needs more end parens: \" + param.toString());\n    }\n    if (quoteOn) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\"Misplaced quotation marks in expression: \" + expression);\n    }\n    if (paramStr.equals(varLengthParamName)) {\n      for (String paramName : varLengthParamValues) {\n        paramsList.add(paramName);\n      }\n    } else {\n      paramsList.add(paramStr);\n    }\n    return paramsList.toArray(new String[paramsList.size()]);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e4e64b7199d2f2a17be7f3926c7532553910dce","date":1564342581,"type":3,"author":"Jason Gerlowski","isMerge":false,"pathNew":"solr/contrib/analytics/src/java/org/apache/solr/analytics/ExpressionFactory#getParams(String,String,String[]).mjava","pathOld":"solr/contrib/analytics/src/java/org/apache/solr/analytics/ExpressionFactory#getParams(String,String,String[]).mjava","sourceNew":"  /**\n   * Parse a function expression string and break up the parameters of the function into separate strings.\n   * <p>\n   * The parsing replaces the variable length parameter, and lambda for-each's using the variable length parameter,\n   * with the parameter values in the returned parameter string.\n   * <p>\n   * Parsing breaks up parameters by commas (',') and ignores ',' inside of extra parens and quotes (both ' and \"), since these commas are either\n   * splitting up the parameters of nested functions or are apart of strings.\n   * <br>\n   * The only escaping that needs to be done is \" within a double quote string and ' within a single quote string and \\ within any string.\n   * For example\\:\n   * <ul>\n   * <li> {@code func(\"This is \\\" the \\\\ escaping ' example\")} will be treated as {@code func(This is \" the \\ escaping ' example)}\n   * <li> {@code func('This is \" the \\\\ escaping \\' example')} will be treated as {@code func(This is \" the \\ escaping ' example)}\n   * </ul>\n   * In string constants the \\ character is used to escape quotes, so it can never be used alone. in order to write a \\ you must write \\\\\n   *\n   * @param expression the function expression to parse\n   * @param varLengthParamName the name of the variable length parameter that is used in the expression, pass null if none is used.\n   * @param varLengthParamValues the values of the variable length parameter that are used in the expression, pass null if none are used.\n   * @return the parsed and split arguments to the function\n   * @throws SolrException if the expression has incorrect syntax.\n   */\n  private static String[] getParams(String expression, String varLengthParamName, String[] varLengthParamValues) throws SolrException {\n    Matcher m = functionParamsPattern.matcher(expression);\n    if (!m.matches()) {\n      return new String[0];\n    }\n    String paramsStr = m.group(1);\n\n    ArrayList<String> paramsList = new ArrayList<String>();\n    StringBuilder param = new StringBuilder();\n\n    // Variables to help while filling out the values of for-each lambda functions.\n    boolean inForEach = false;\n    int forEachStart = -1;\n    int forEachIter = -1;\n    int forEachLevel = -1;\n\n    // The current level of nested parenthesis, 0 means the iteration is in no nested parentheses\n    int parenCount = 0;\n    // If the iteration is currently in a single-quote string constant\n    boolean singleQuoteOn = false;\n    // If the iteration is currently in a double-quote string constant\n    boolean doubleQuoteOn = false;\n    // If the iteration is currently in any kind of string constant\n    boolean quoteOn = false;\n    // Is the next character escaped.\n    boolean escaped = false;\n\n    char[] chars = paramsStr.toCharArray();\n\n    // Iterate through every character, building the params one at a time\n    for (int i = 0; i < chars.length; ++i) {\n      char c = chars[i];\n\n      if (c == ' ' && !quoteOn) {\n        // Ignore white space that is not in string constants\n        continue;\n      } else if (c == ',' && parenCount == 0 && !quoteOn) {\n        // This signifies the end of one parameter and the start of another, since we are not in a nested parenthesis or a string constant\n        String paramStr = param.toString();\n        if (paramStr.length() == 0) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"Empty parameter in expression: \" + expression);\n        }\n        // check to see if the parameter is a variable length parameter\n        if (paramStr.equals(varLengthParamName)) {\n          // Add every variable length parameter value, since there are a variable amount\n          for (String paramName : varLengthParamValues) {\n            paramsList.add(paramName);\n          }\n        } else {\n          paramsList.add(paramStr);\n        }\n\n        param.setLength(0);\n        continue;\n      } else if (c == ',' && !quoteOn && inForEach) {\n        // separate the for each parameters, so they can be replaced with the result of the for each\n        if (param.charAt(param.length()-1) == variableForEachParam &&\n            (param.charAt(param.length()-2) == '(' || param.charAt(param.length()-2) == ',')) {\n          param.setLength(param.length()-1);\n          param.append(varLengthParamValues[forEachIter++]);\n        }\n      } else if (c == '\"' && !singleQuoteOn) {\n        // Deal with escaping, or ending string constants\n        if (doubleQuoteOn && !escaped) {\n          doubleQuoteOn = false;\n          quoteOn = false;\n        } else if (!quoteOn) {\n          doubleQuoteOn = true;\n          quoteOn = true;\n        } else {\n          // only happens if escaped is true\n          escaped = false;\n        }\n      }  else if (c== '\\'' && !doubleQuoteOn) {\n        // Deal with escaping, or ending string constants\n        if (singleQuoteOn && !escaped) {\n          singleQuoteOn = false;\n          quoteOn = false;\n        } else if (!singleQuoteOn) {\n          singleQuoteOn = true;\n          quoteOn = true;\n        } else {\n          // only happens if escaped is true\n          escaped = false;\n        }\n      } else if (c == '(' && !quoteOn) {\n        // Reached a further level of nested parentheses\n        parenCount++;\n      } else if (c == ')' && !quoteOn) {\n        // Returned from a level of nested parentheses\n        parenCount--;\n        if (parenCount < 0) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"The following expression has extra end parens: \" + param.toString());\n        }\n        if (inForEach) {\n          if (param.charAt(param.length()-1) == variableForEachParam &&\n              (param.charAt(param.length()-2) == '(' || param.charAt(param.length()-2) == ',')) {\n            param.setLength(param.length()-1);\n            param.append(varLengthParamValues[forEachIter++]);\n          }\n          if (forEachLevel == parenCount) {\n            // at the end of the for-each start the parsing of the for-each again, with the next value of the variable length parameter\n            if (forEachIter == 0) {\n              throw new SolrException(ErrorCode.BAD_REQUEST,\"For each statement for variable '\" + varLengthParamName + \"' has no use of lambda variable \" + variableForEachParam);\n            } else if (forEachIter < varLengthParamValues.length) {\n              if (parenCount == 0) {\n                param.append(')');\n                paramsList.add(param.toString());\n                param.setLength(0);\n              } else {\n                param.append(')');\n                param.append(',');\n              }\n              i = forEachStart;\n              continue;\n            } else {\n              inForEach = false;\n            }\n          }\n        }\n      }\n      if (c == '\\\\') {\n        // Escaping or escaped backslash\n        if (!quoteOn) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"The following expression has escaped characters outside of quotation marks: \" + expression.toString());\n        }\n        if (escaped) {\n          escaped = false;\n        } else {\n          escaped = true;\n          if (parenCount == 0) {\n            continue;\n          }\n        }\n      } else if (escaped) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\"Invalid escape character '\" + c + \"' used in the following expression: \" + expression.toString());\n      }\n      if (c == variableForEachSep && !quoteOn && varLengthParamName != null) {\n        int varStart = param.length()-varLengthParamName.length();\n        if (param.subSequence(varStart, param.length()).equals(varLengthParamName)) {\n          inForEach = true;\n          forEachStart = i;\n          forEachIter = 0;\n          forEachLevel = parenCount;\n          param.setLength(varStart);\n          continue;\n        }\n        throw new SolrException(ErrorCode.BAD_REQUEST,\"For-each called on invalid parameter '\" + param.toString().trim());\n      }\n      param.append(c);\n    }\n    String paramStr = param.toString().trim();\n    if (paramStr.length() == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\"Empty parameter in expression: \" + expression);\n    }\n    if (parenCount > 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\"The following expression needs more end parens: \" + param.toString());\n    }\n    if (quoteOn) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\"Misplaced quotation marks in expression: \" + expression);\n    }\n    if (paramStr.equals(varLengthParamName)) {\n      for (String paramName : varLengthParamValues) {\n        paramsList.add(paramName);\n      }\n    } else {\n      paramsList.add(paramStr);\n    }\n    return paramsList.toArray(new String[paramsList.size()]);\n  }\n\n","sourceOld":"  /**\n   * Parse a function expression string and break up the parameters of the function into separate strings.\n   * <p>\n   * The parsing replaces the variable length parameter, and lambda for-each's using the variable length parameter,\n   * with the parameter values in the returned parameter string.\n   * <p>\n   * Parsing breaks up parameters by commas (',') and ignores ',' inside of extra parens and quotes (both ' and \"), since these commas are either\n   * splitting up the parameters of nested functions or are apart of strings.\n   * <br>\n   * The only escaping that needs to be done is \" within a double quote string and ' within a single quote string and \\ within any string.\n   * For example\\:\n   * <ul>\n   * <li> {@code func(\"This is \\\" the \\\\ escaping ' example\")} will be treated as {@code func(This is \" the \\ escaping ' example)}\n   * <li> {@code func('This is \" the \\\\ escaping \\' example')} will be treated as {@code func(This is \" the \\ escaping ' example)}\n   * </ul>\n   * In string constants the \\ character is used to escape quotes, so it can never be used alone. in order to write a \\ you must write \\\\\n   * \n   * @param expression the function expression to parse\n   * @param varLengthParamName the name of the variable length parameter that is used in the expression, pass null if none is used.\n   * @param varLengthParamValues the values of the variable length parameter that are used in the expression, pass null if none are used.\n   * @return the parsed and split arguments to the function\n   * @throws SolrException if the expression has incorrect syntax.\n   */\n  private static String[] getParams(String expression, String varLengthParamName, String[] varLengthParamValues) throws SolrException {\n    Matcher m = functionParamsPattern.matcher(expression);\n    if (!m.matches()) {\n      return new String[0];\n    }\n    String paramsStr = m.group(1);\n    \n    ArrayList<String> paramsList = new ArrayList<String>();\n    StringBuilder param = new StringBuilder();\n    \n    // Variables to help while filling out the values of for-each lambda functions.\n    boolean inForEach = false;\n    int forEachStart = -1;\n    int forEachIter = -1;\n    int forEachLevel = -1;\n    \n    // The current level of nested parenthesis, 0 means the iteration is in no nested parentheses\n    int parenCount = 0;\n    // If the iteration is currently in a single-quote string constant\n    boolean singleQuoteOn = false;\n    // If the iteration is currently in a double-quote string constant\n    boolean doubleQuoteOn = false;\n    // If the iteration is currently in any kind of string constant\n    boolean quoteOn = false;\n    // Is the next character escaped.\n    boolean escaped = false;\n    \n    char[] chars = paramsStr.toCharArray();\n    \n    // Iterate through every character, building the params one at a time\n    for (int i = 0; i < chars.length; ++i) {\n      char c = chars[i];\n      \n      if (c == ' ' && !quoteOn) {\n        // Ignore white space that is not in string constants\n        continue;\n      } else if (c == ',' && parenCount == 0 && !quoteOn) {\n        // This signifies the end of one parameter and the start of another, since we are not in a nested parenthesis or a string constant\n        String paramStr = param.toString();\n        if (paramStr.length() == 0) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"Empty parameter in expression: \" + expression);\n        }\n        // check to see if the parameter is a variable length parameter\n        if (paramStr.equals(varLengthParamName)) {\n          // Add every variable length parameter value, since there are a variable amount\n          for (String paramName : varLengthParamValues) {\n            paramsList.add(paramName);\n          }\n        } else {\n          paramsList.add(paramStr);\n        }\n        \n        param.setLength(0);\n        continue;\n      } else if (c == ',' && !quoteOn && inForEach) {\n        // separate the for each parameters, so they can be replaced with the result of the for each\n        if (param.charAt(param.length()-1) == variableForEachParam && \n            (param.charAt(param.length()-2) == '(' || param.charAt(param.length()-2) == ',')) {\n          param.setLength(param.length()-1);\n          param.append(varLengthParamValues[forEachIter++]);\n        }\n      } else if (c == '\"' && !singleQuoteOn) {\n        // Deal with escaping, or ending string constants\n        if (doubleQuoteOn && !escaped) {\n          doubleQuoteOn = false;\n          quoteOn = false;\n        } else if (!quoteOn) {\n          doubleQuoteOn = true;\n          quoteOn = true;\n        } else {\n          // only happens if escaped is true\n          escaped = false;\n        }\n      }  else if (c== '\\'' && !doubleQuoteOn) {\n        // Deal with escaping, or ending string constants\n        if (singleQuoteOn && !escaped) {\n          singleQuoteOn = false;\n          quoteOn = false;\n        } else if (!singleQuoteOn) {\n          singleQuoteOn = true;\n          quoteOn = true;\n        } else {\n          // only happens if escaped is true\n          escaped = false;\n        }\n      } else if (c == '(' && !quoteOn) {\n        // Reached a further level of nested parentheses\n        parenCount++;\n      } else if (c == ')' && !quoteOn) {\n        // Returned from a level of nested parentheses\n        parenCount--;\n        if (parenCount < 0) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"The following expression has extra end parens: \" + param.toString());\n        }\n        if (inForEach) {\n          if (param.charAt(param.length()-1) == variableForEachParam && \n              (param.charAt(param.length()-2) == '(' || param.charAt(param.length()-2) == ',')) {\n            param.setLength(param.length()-1);\n            param.append(varLengthParamValues[forEachIter++]);\n          }\n          if (forEachLevel == parenCount) {\n            // at the end of the for-each start the parsing of the for-each again, with the next value of the variable length parameter\n            if (forEachIter == 0) {\n              throw new SolrException(ErrorCode.BAD_REQUEST,\"For each statement for variable '\" + varLengthParamName + \"' has no use of lambda variable \" + variableForEachParam);\n            } else if (forEachIter < varLengthParamValues.length) {\n              if (parenCount == 0) {\n                param.append(')');\n                paramsList.add(param.toString());\n                param.setLength(0);\n              } else {\n                param.append(')');\n                param.append(',');\n              }\n              i = forEachStart;\n              continue;\n            } else {\n              inForEach = false;\n            }\n          }\n        }\n      }\n      if (c == '\\\\') {\n        // Escaping or escaped backslash\n        if (!quoteOn) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"The following expression has escaped characters outside of quotation marks: \" + expression.toString());\n        }\n        if (escaped) {\n          escaped = false;\n        } else {\n          escaped = true;\n          if (parenCount == 0) {\n            continue;\n          }\n        }\n      } else if (escaped) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\"Invalid escape character '\" + c + \"' used in the following expression: \" + expression.toString());\n      }\n      if (c == variableForEachSep && !quoteOn && varLengthParamName != null) {\n        int varStart = param.length()-varLengthParamName.length();\n        if (param.subSequence(varStart, param.length()).equals(varLengthParamName)) {\n          inForEach = true;\n          forEachStart = i;\n          forEachIter = 0;\n          forEachLevel = parenCount;\n          param.setLength(varStart);\n          continue;\n        }\n        throw new SolrException(ErrorCode.BAD_REQUEST,\"For-each called on invalid parameter '\" + param.toString().trim());\n      }\n      param.append(c);\n    }\n    String paramStr = param.toString().trim();\n    if (paramStr.length() == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\"Empty parameter in expression: \" + expression);\n    }\n    if (parenCount > 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\"The following expression needs more end parens: \" + param.toString());\n    }\n    if (quoteOn) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\"Misplaced quotation marks in expression: \" + expression);\n    }\n    if (paramStr.equals(varLengthParamName)) {\n      for (String paramName : varLengthParamValues) {\n        paramsList.add(paramName);\n      }\n    } else {\n      paramsList.add(paramStr);\n    }\n    return paramsList.toArray(new String[paramsList.size()]);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f8061ddd97f3352007d927dae445884a6f3d857b","date":1564988276,"type":3,"author":"Atri Sharma","isMerge":true,"pathNew":"solr/contrib/analytics/src/java/org/apache/solr/analytics/ExpressionFactory#getParams(String,String,String[]).mjava","pathOld":"solr/contrib/analytics/src/java/org/apache/solr/analytics/ExpressionFactory#getParams(String,String,String[]).mjava","sourceNew":"  /**\n   * Parse a function expression string and break up the parameters of the function into separate strings.\n   * <p>\n   * The parsing replaces the variable length parameter, and lambda for-each's using the variable length parameter,\n   * with the parameter values in the returned parameter string.\n   * <p>\n   * Parsing breaks up parameters by commas (',') and ignores ',' inside of extra parens and quotes (both ' and \"), since these commas are either\n   * splitting up the parameters of nested functions or are apart of strings.\n   * <br>\n   * The only escaping that needs to be done is \" within a double quote string and ' within a single quote string and \\ within any string.\n   * For example\\:\n   * <ul>\n   * <li> {@code func(\"This is \\\" the \\\\ escaping ' example\")} will be treated as {@code func(This is \" the \\ escaping ' example)}\n   * <li> {@code func('This is \" the \\\\ escaping \\' example')} will be treated as {@code func(This is \" the \\ escaping ' example)}\n   * </ul>\n   * In string constants the \\ character is used to escape quotes, so it can never be used alone. in order to write a \\ you must write \\\\\n   *\n   * @param expression the function expression to parse\n   * @param varLengthParamName the name of the variable length parameter that is used in the expression, pass null if none is used.\n   * @param varLengthParamValues the values of the variable length parameter that are used in the expression, pass null if none are used.\n   * @return the parsed and split arguments to the function\n   * @throws SolrException if the expression has incorrect syntax.\n   */\n  private static String[] getParams(String expression, String varLengthParamName, String[] varLengthParamValues) throws SolrException {\n    Matcher m = functionParamsPattern.matcher(expression);\n    if (!m.matches()) {\n      return new String[0];\n    }\n    String paramsStr = m.group(1);\n\n    ArrayList<String> paramsList = new ArrayList<String>();\n    StringBuilder param = new StringBuilder();\n\n    // Variables to help while filling out the values of for-each lambda functions.\n    boolean inForEach = false;\n    int forEachStart = -1;\n    int forEachIter = -1;\n    int forEachLevel = -1;\n\n    // The current level of nested parenthesis, 0 means the iteration is in no nested parentheses\n    int parenCount = 0;\n    // If the iteration is currently in a single-quote string constant\n    boolean singleQuoteOn = false;\n    // If the iteration is currently in a double-quote string constant\n    boolean doubleQuoteOn = false;\n    // If the iteration is currently in any kind of string constant\n    boolean quoteOn = false;\n    // Is the next character escaped.\n    boolean escaped = false;\n\n    char[] chars = paramsStr.toCharArray();\n\n    // Iterate through every character, building the params one at a time\n    for (int i = 0; i < chars.length; ++i) {\n      char c = chars[i];\n\n      if (c == ' ' && !quoteOn) {\n        // Ignore white space that is not in string constants\n        continue;\n      } else if (c == ',' && parenCount == 0 && !quoteOn) {\n        // This signifies the end of one parameter and the start of another, since we are not in a nested parenthesis or a string constant\n        String paramStr = param.toString();\n        if (paramStr.length() == 0) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"Empty parameter in expression: \" + expression);\n        }\n        // check to see if the parameter is a variable length parameter\n        if (paramStr.equals(varLengthParamName)) {\n          // Add every variable length parameter value, since there are a variable amount\n          for (String paramName : varLengthParamValues) {\n            paramsList.add(paramName);\n          }\n        } else {\n          paramsList.add(paramStr);\n        }\n\n        param.setLength(0);\n        continue;\n      } else if (c == ',' && !quoteOn && inForEach) {\n        // separate the for each parameters, so they can be replaced with the result of the for each\n        if (param.charAt(param.length()-1) == variableForEachParam &&\n            (param.charAt(param.length()-2) == '(' || param.charAt(param.length()-2) == ',')) {\n          param.setLength(param.length()-1);\n          param.append(varLengthParamValues[forEachIter++]);\n        }\n      } else if (c == '\"' && !singleQuoteOn) {\n        // Deal with escaping, or ending string constants\n        if (doubleQuoteOn && !escaped) {\n          doubleQuoteOn = false;\n          quoteOn = false;\n        } else if (!quoteOn) {\n          doubleQuoteOn = true;\n          quoteOn = true;\n        } else {\n          // only happens if escaped is true\n          escaped = false;\n        }\n      }  else if (c== '\\'' && !doubleQuoteOn) {\n        // Deal with escaping, or ending string constants\n        if (singleQuoteOn && !escaped) {\n          singleQuoteOn = false;\n          quoteOn = false;\n        } else if (!singleQuoteOn) {\n          singleQuoteOn = true;\n          quoteOn = true;\n        } else {\n          // only happens if escaped is true\n          escaped = false;\n        }\n      } else if (c == '(' && !quoteOn) {\n        // Reached a further level of nested parentheses\n        parenCount++;\n      } else if (c == ')' && !quoteOn) {\n        // Returned from a level of nested parentheses\n        parenCount--;\n        if (parenCount < 0) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"The following expression has extra end parens: \" + param.toString());\n        }\n        if (inForEach) {\n          if (param.charAt(param.length()-1) == variableForEachParam &&\n              (param.charAt(param.length()-2) == '(' || param.charAt(param.length()-2) == ',')) {\n            param.setLength(param.length()-1);\n            param.append(varLengthParamValues[forEachIter++]);\n          }\n          if (forEachLevel == parenCount) {\n            // at the end of the for-each start the parsing of the for-each again, with the next value of the variable length parameter\n            if (forEachIter == 0) {\n              throw new SolrException(ErrorCode.BAD_REQUEST,\"For each statement for variable '\" + varLengthParamName + \"' has no use of lambda variable \" + variableForEachParam);\n            } else if (forEachIter < varLengthParamValues.length) {\n              if (parenCount == 0) {\n                param.append(')');\n                paramsList.add(param.toString());\n                param.setLength(0);\n              } else {\n                param.append(')');\n                param.append(',');\n              }\n              i = forEachStart;\n              continue;\n            } else {\n              inForEach = false;\n            }\n          }\n        }\n      }\n      if (c == '\\\\') {\n        // Escaping or escaped backslash\n        if (!quoteOn) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"The following expression has escaped characters outside of quotation marks: \" + expression.toString());\n        }\n        if (escaped) {\n          escaped = false;\n        } else {\n          escaped = true;\n          if (parenCount == 0) {\n            continue;\n          }\n        }\n      } else if (escaped) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\"Invalid escape character '\" + c + \"' used in the following expression: \" + expression.toString());\n      }\n      if (c == variableForEachSep && !quoteOn && varLengthParamName != null) {\n        int varStart = param.length()-varLengthParamName.length();\n        if (param.subSequence(varStart, param.length()).equals(varLengthParamName)) {\n          inForEach = true;\n          forEachStart = i;\n          forEachIter = 0;\n          forEachLevel = parenCount;\n          param.setLength(varStart);\n          continue;\n        }\n        throw new SolrException(ErrorCode.BAD_REQUEST,\"For-each called on invalid parameter '\" + param.toString().trim());\n      }\n      param.append(c);\n    }\n    String paramStr = param.toString().trim();\n    if (paramStr.length() == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\"Empty parameter in expression: \" + expression);\n    }\n    if (parenCount > 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\"The following expression needs more end parens: \" + param.toString());\n    }\n    if (quoteOn) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\"Misplaced quotation marks in expression: \" + expression);\n    }\n    if (paramStr.equals(varLengthParamName)) {\n      for (String paramName : varLengthParamValues) {\n        paramsList.add(paramName);\n      }\n    } else {\n      paramsList.add(paramStr);\n    }\n    return paramsList.toArray(new String[paramsList.size()]);\n  }\n\n","sourceOld":"  /**\n   * Parse a function expression string and break up the parameters of the function into separate strings.\n   * <p>\n   * The parsing replaces the variable length parameter, and lambda for-each's using the variable length parameter,\n   * with the parameter values in the returned parameter string.\n   * <p>\n   * Parsing breaks up parameters by commas (',') and ignores ',' inside of extra parens and quotes (both ' and \"), since these commas are either\n   * splitting up the parameters of nested functions or are apart of strings.\n   * <br>\n   * The only escaping that needs to be done is \" within a double quote string and ' within a single quote string and \\ within any string.\n   * For example\\:\n   * <ul>\n   * <li> {@code func(\"This is \\\" the \\\\ escaping ' example\")} will be treated as {@code func(This is \" the \\ escaping ' example)}\n   * <li> {@code func('This is \" the \\\\ escaping \\' example')} will be treated as {@code func(This is \" the \\ escaping ' example)}\n   * </ul>\n   * In string constants the \\ character is used to escape quotes, so it can never be used alone. in order to write a \\ you must write \\\\\n   * \n   * @param expression the function expression to parse\n   * @param varLengthParamName the name of the variable length parameter that is used in the expression, pass null if none is used.\n   * @param varLengthParamValues the values of the variable length parameter that are used in the expression, pass null if none are used.\n   * @return the parsed and split arguments to the function\n   * @throws SolrException if the expression has incorrect syntax.\n   */\n  private static String[] getParams(String expression, String varLengthParamName, String[] varLengthParamValues) throws SolrException {\n    Matcher m = functionParamsPattern.matcher(expression);\n    if (!m.matches()) {\n      return new String[0];\n    }\n    String paramsStr = m.group(1);\n    \n    ArrayList<String> paramsList = new ArrayList<String>();\n    StringBuilder param = new StringBuilder();\n    \n    // Variables to help while filling out the values of for-each lambda functions.\n    boolean inForEach = false;\n    int forEachStart = -1;\n    int forEachIter = -1;\n    int forEachLevel = -1;\n    \n    // The current level of nested parenthesis, 0 means the iteration is in no nested parentheses\n    int parenCount = 0;\n    // If the iteration is currently in a single-quote string constant\n    boolean singleQuoteOn = false;\n    // If the iteration is currently in a double-quote string constant\n    boolean doubleQuoteOn = false;\n    // If the iteration is currently in any kind of string constant\n    boolean quoteOn = false;\n    // Is the next character escaped.\n    boolean escaped = false;\n    \n    char[] chars = paramsStr.toCharArray();\n    \n    // Iterate through every character, building the params one at a time\n    for (int i = 0; i < chars.length; ++i) {\n      char c = chars[i];\n      \n      if (c == ' ' && !quoteOn) {\n        // Ignore white space that is not in string constants\n        continue;\n      } else if (c == ',' && parenCount == 0 && !quoteOn) {\n        // This signifies the end of one parameter and the start of another, since we are not in a nested parenthesis or a string constant\n        String paramStr = param.toString();\n        if (paramStr.length() == 0) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"Empty parameter in expression: \" + expression);\n        }\n        // check to see if the parameter is a variable length parameter\n        if (paramStr.equals(varLengthParamName)) {\n          // Add every variable length parameter value, since there are a variable amount\n          for (String paramName : varLengthParamValues) {\n            paramsList.add(paramName);\n          }\n        } else {\n          paramsList.add(paramStr);\n        }\n        \n        param.setLength(0);\n        continue;\n      } else if (c == ',' && !quoteOn && inForEach) {\n        // separate the for each parameters, so they can be replaced with the result of the for each\n        if (param.charAt(param.length()-1) == variableForEachParam && \n            (param.charAt(param.length()-2) == '(' || param.charAt(param.length()-2) == ',')) {\n          param.setLength(param.length()-1);\n          param.append(varLengthParamValues[forEachIter++]);\n        }\n      } else if (c == '\"' && !singleQuoteOn) {\n        // Deal with escaping, or ending string constants\n        if (doubleQuoteOn && !escaped) {\n          doubleQuoteOn = false;\n          quoteOn = false;\n        } else if (!quoteOn) {\n          doubleQuoteOn = true;\n          quoteOn = true;\n        } else {\n          // only happens if escaped is true\n          escaped = false;\n        }\n      }  else if (c== '\\'' && !doubleQuoteOn) {\n        // Deal with escaping, or ending string constants\n        if (singleQuoteOn && !escaped) {\n          singleQuoteOn = false;\n          quoteOn = false;\n        } else if (!singleQuoteOn) {\n          singleQuoteOn = true;\n          quoteOn = true;\n        } else {\n          // only happens if escaped is true\n          escaped = false;\n        }\n      } else if (c == '(' && !quoteOn) {\n        // Reached a further level of nested parentheses\n        parenCount++;\n      } else if (c == ')' && !quoteOn) {\n        // Returned from a level of nested parentheses\n        parenCount--;\n        if (parenCount < 0) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"The following expression has extra end parens: \" + param.toString());\n        }\n        if (inForEach) {\n          if (param.charAt(param.length()-1) == variableForEachParam && \n              (param.charAt(param.length()-2) == '(' || param.charAt(param.length()-2) == ',')) {\n            param.setLength(param.length()-1);\n            param.append(varLengthParamValues[forEachIter++]);\n          }\n          if (forEachLevel == parenCount) {\n            // at the end of the for-each start the parsing of the for-each again, with the next value of the variable length parameter\n            if (forEachIter == 0) {\n              throw new SolrException(ErrorCode.BAD_REQUEST,\"For each statement for variable '\" + varLengthParamName + \"' has no use of lambda variable \" + variableForEachParam);\n            } else if (forEachIter < varLengthParamValues.length) {\n              if (parenCount == 0) {\n                param.append(')');\n                paramsList.add(param.toString());\n                param.setLength(0);\n              } else {\n                param.append(')');\n                param.append(',');\n              }\n              i = forEachStart;\n              continue;\n            } else {\n              inForEach = false;\n            }\n          }\n        }\n      }\n      if (c == '\\\\') {\n        // Escaping or escaped backslash\n        if (!quoteOn) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\"The following expression has escaped characters outside of quotation marks: \" + expression.toString());\n        }\n        if (escaped) {\n          escaped = false;\n        } else {\n          escaped = true;\n          if (parenCount == 0) {\n            continue;\n          }\n        }\n      } else if (escaped) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\"Invalid escape character '\" + c + \"' used in the following expression: \" + expression.toString());\n      }\n      if (c == variableForEachSep && !quoteOn && varLengthParamName != null) {\n        int varStart = param.length()-varLengthParamName.length();\n        if (param.subSequence(varStart, param.length()).equals(varLengthParamName)) {\n          inForEach = true;\n          forEachStart = i;\n          forEachIter = 0;\n          forEachLevel = parenCount;\n          param.setLength(varStart);\n          continue;\n        }\n        throw new SolrException(ErrorCode.BAD_REQUEST,\"For-each called on invalid parameter '\" + param.toString().trim());\n      }\n      param.append(c);\n    }\n    String paramStr = param.toString().trim();\n    if (paramStr.length() == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\"Empty parameter in expression: \" + expression);\n    }\n    if (parenCount > 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\"The following expression needs more end parens: \" + param.toString());\n    }\n    if (quoteOn) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\"Misplaced quotation marks in expression: \" + expression);\n    }\n    if (paramStr.equals(varLengthParamName)) {\n      for (String paramName : varLengthParamValues) {\n        paramsList.add(paramName);\n      }\n    } else {\n      paramsList.add(paramStr);\n    }\n    return paramsList.toArray(new String[paramsList.size()]);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1e4e64b7199d2f2a17be7f3926c7532553910dce":["28288370235ed02234a64753cdbf0c6ec096304a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"30c8e5574b55d57947e989443dfde611646530ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","28288370235ed02234a64753cdbf0c6ec096304a"],"c495edcca4d0bc51bf62d9be3527c87bf9b44ded":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"28288370235ed02234a64753cdbf0c6ec096304a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c495edcca4d0bc51bf62d9be3527c87bf9b44ded"],"f8061ddd97f3352007d927dae445884a6f3d857b":["28288370235ed02234a64753cdbf0c6ec096304a","1e4e64b7199d2f2a17be7f3926c7532553910dce"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1e4e64b7199d2f2a17be7f3926c7532553910dce"]},"commit2Childs":{"1e4e64b7199d2f2a17be7f3926c7532553910dce":["f8061ddd97f3352007d927dae445884a6f3d857b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["30c8e5574b55d57947e989443dfde611646530ee","c495edcca4d0bc51bf62d9be3527c87bf9b44ded","28288370235ed02234a64753cdbf0c6ec096304a"],"30c8e5574b55d57947e989443dfde611646530ee":[],"c495edcca4d0bc51bf62d9be3527c87bf9b44ded":["28288370235ed02234a64753cdbf0c6ec096304a"],"28288370235ed02234a64753cdbf0c6ec096304a":["1e4e64b7199d2f2a17be7f3926c7532553910dce","30c8e5574b55d57947e989443dfde611646530ee","f8061ddd97f3352007d927dae445884a6f3d857b"],"f8061ddd97f3352007d927dae445884a6f3d857b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["30c8e5574b55d57947e989443dfde611646530ee","f8061ddd97f3352007d927dae445884a6f3d857b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}