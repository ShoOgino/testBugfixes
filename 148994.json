{"path":"lucene/core/src/test/org/apache/lucene/codecs/lucene41/TestBlockPostingsFormat3#test().mjava","commits":[{"id":"cf8086c7e11dc41303ef1b8050bd355ddfaee76d","date":1350007219,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/lucene41/TestBlockPostingsFormat3#test().mjava","pathOld":"lucene/codecs/src/test/org/apache/lucene/codecs/block/TestBlockPostingsFormat3#test().mjava","sourceNew":"  // creates 6 fields with different options and does \"duels\" of fields against each other\n  public void test() throws Exception {\n    Directory dir = newDirectory();\n    Analyzer analyzer = new Analyzer(new Analyzer.PerFieldReuseStrategy()) {\n      @Override\n      protected TokenStreamComponents createComponents(String fieldName, Reader reader) {\n        Tokenizer tokenizer = new MockTokenizer(reader);\n        if (fieldName.contains(\"payloadsFixed\")) {\n          TokenFilter filter = new MockFixedLengthPayloadFilter(new Random(0), tokenizer, 1);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else if (fieldName.contains(\"payloadsVariable\")) {\n          TokenFilter filter = new MockVariableLengthPayloadFilter(new Random(0), tokenizer);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else {\n          return new TokenStreamComponents(tokenizer);\n        }\n      }\n    };\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer);\n    iwc.setCodec(new Lucene41Codec() {\n      @Override\n      public PostingsFormat getPostingsFormatForField(String field) {\n        return PostingsFormat.forName(\"Lucene41\");\n        // TODO: we could actually add more fields implemented with different PFs\n      }\n    });\n    RandomIndexWriter iw = new RandomIndexWriter(random(), dir, iwc);\n    Document doc = new Document();\n    FieldType bareType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn these on for a cross-check\n    bareType.setStoreTermVectors(true);\n    bareType.setStoreTermVectorPositions(true);\n    bareType.setStoreTermVectorOffsets(true);\n    bareType.setStoreTermVectorPayloads(true);\n    FieldType offsetsType = new FieldType(bareType);\n    offsetsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    Field field1 = new Field(\"field1bare\", \"\", bareType);\n    Field field2 = new Field(\"field2offsets\", \"\", offsetsType);\n    Field field3 = new Field(\"field3payloadsFixed\", \"\", bareType);\n    Field field4 = new Field(\"field4payloadsVariable\", \"\", bareType);\n    Field field5 = new Field(\"field5payloadsFixedOffsets\", \"\", offsetsType);\n    Field field6 = new Field(\"field6payloadsVariableOffsets\", \"\", offsetsType);\n    doc.add(field1);\n    doc.add(field2);\n    doc.add(field3);\n    doc.add(field4);\n    doc.add(field5);\n    doc.add(field6);\n    for (int i = 0; i < MAXDOC; i++) {\n      String stringValue = Integer.toString(i) + \" verycommon \" + English.intToEnglish(i).replace('-', ' ') + \" \" + _TestUtil.randomSimpleString(random());\n      field1.setStringValue(stringValue);\n      field2.setStringValue(stringValue);\n      field3.setStringValue(stringValue);\n      field4.setStringValue(stringValue);\n      field5.setStringValue(stringValue);\n      field6.setStringValue(stringValue);\n      iw.addDocument(doc);\n    }\n    iw.close();\n    verify(dir);\n    _TestUtil.checkIndex(dir); // for some extra coverage, checkIndex before we forceMerge\n    iwc.setOpenMode(OpenMode.APPEND);\n    IndexWriter iw2 = new IndexWriter(dir, iwc);\n    iw2.forceMerge(1);\n    iw2.close();\n    verify(dir);\n    dir.close();\n  }\n\n","sourceOld":"  // creates 6 fields with different options and does \"duels\" of fields against each other\n  public void test() throws Exception {\n    Directory dir = newDirectory();\n    Analyzer analyzer = new Analyzer(new Analyzer.PerFieldReuseStrategy()) {\n      @Override\n      protected TokenStreamComponents createComponents(String fieldName, Reader reader) {\n        Tokenizer tokenizer = new MockTokenizer(reader);\n        if (fieldName.contains(\"payloadsFixed\")) {\n          TokenFilter filter = new MockFixedLengthPayloadFilter(new Random(0), tokenizer, 1);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else if (fieldName.contains(\"payloadsVariable\")) {\n          TokenFilter filter = new MockVariableLengthPayloadFilter(new Random(0), tokenizer);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else {\n          return new TokenStreamComponents(tokenizer);\n        }\n      }\n    };\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer);\n    iwc.setCodec(new Lucene40Codec() {\n      @Override\n      public PostingsFormat getPostingsFormatForField(String field) {\n        return PostingsFormat.forName(\"Block\");\n        // TODO: we could actually add more fields implemented with different PFs\n      }\n    });\n    RandomIndexWriter iw = new RandomIndexWriter(random(), dir, iwc);\n    Document doc = new Document();\n    FieldType bareType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn these on for a cross-check\n    bareType.setStoreTermVectors(true);\n    bareType.setStoreTermVectorPositions(true);\n    bareType.setStoreTermVectorOffsets(true);\n    bareType.setStoreTermVectorPayloads(true);\n    FieldType offsetsType = new FieldType(bareType);\n    offsetsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    Field field1 = new Field(\"field1bare\", \"\", bareType);\n    Field field2 = new Field(\"field2offsets\", \"\", offsetsType);\n    Field field3 = new Field(\"field3payloadsFixed\", \"\", bareType);\n    Field field4 = new Field(\"field4payloadsVariable\", \"\", bareType);\n    Field field5 = new Field(\"field5payloadsFixedOffsets\", \"\", offsetsType);\n    Field field6 = new Field(\"field6payloadsVariableOffsets\", \"\", offsetsType);\n    doc.add(field1);\n    doc.add(field2);\n    doc.add(field3);\n    doc.add(field4);\n    doc.add(field5);\n    doc.add(field6);\n    for (int i = 0; i < MAXDOC; i++) {\n      String stringValue = Integer.toString(i) + \" verycommon \" + English.intToEnglish(i).replace('-', ' ') + \" \" + _TestUtil.randomSimpleString(random());\n      field1.setStringValue(stringValue);\n      field2.setStringValue(stringValue);\n      field3.setStringValue(stringValue);\n      field4.setStringValue(stringValue);\n      field5.setStringValue(stringValue);\n      field6.setStringValue(stringValue);\n      iw.addDocument(doc);\n    }\n    iw.close();\n    verify(dir);\n    _TestUtil.checkIndex(dir); // for some extra coverage, checkIndex before we forceMerge\n    iwc.setOpenMode(OpenMode.APPEND);\n    IndexWriter iw2 = new IndexWriter(dir, iwc);\n    iw2.forceMerge(1);\n    iw2.close();\n    verify(dir);\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7492bcb52be51e55d596134b95b2e53cc4ffb91","date":1350223278,"type":1,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/lucene41/TestBlockPostingsFormat3#test().mjava","pathOld":"lucene/codecs/src/test/org/apache/lucene/codecs/block/TestBlockPostingsFormat3#test().mjava","sourceNew":"  // creates 6 fields with different options and does \"duels\" of fields against each other\n  public void test() throws Exception {\n    Directory dir = newDirectory();\n    Analyzer analyzer = new Analyzer(new Analyzer.PerFieldReuseStrategy()) {\n      @Override\n      protected TokenStreamComponents createComponents(String fieldName, Reader reader) {\n        Tokenizer tokenizer = new MockTokenizer(reader);\n        if (fieldName.contains(\"payloadsFixed\")) {\n          TokenFilter filter = new MockFixedLengthPayloadFilter(new Random(0), tokenizer, 1);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else if (fieldName.contains(\"payloadsVariable\")) {\n          TokenFilter filter = new MockVariableLengthPayloadFilter(new Random(0), tokenizer);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else {\n          return new TokenStreamComponents(tokenizer);\n        }\n      }\n    };\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer);\n    iwc.setCodec(new Lucene41Codec() {\n      @Override\n      public PostingsFormat getPostingsFormatForField(String field) {\n        return PostingsFormat.forName(\"Lucene41\");\n        // TODO: we could actually add more fields implemented with different PFs\n      }\n    });\n    RandomIndexWriter iw = new RandomIndexWriter(random(), dir, iwc);\n    Document doc = new Document();\n    FieldType bareType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn these on for a cross-check\n    bareType.setStoreTermVectors(true);\n    bareType.setStoreTermVectorPositions(true);\n    bareType.setStoreTermVectorOffsets(true);\n    bareType.setStoreTermVectorPayloads(true);\n    FieldType offsetsType = new FieldType(bareType);\n    offsetsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    Field field1 = new Field(\"field1bare\", \"\", bareType);\n    Field field2 = new Field(\"field2offsets\", \"\", offsetsType);\n    Field field3 = new Field(\"field3payloadsFixed\", \"\", bareType);\n    Field field4 = new Field(\"field4payloadsVariable\", \"\", bareType);\n    Field field5 = new Field(\"field5payloadsFixedOffsets\", \"\", offsetsType);\n    Field field6 = new Field(\"field6payloadsVariableOffsets\", \"\", offsetsType);\n    doc.add(field1);\n    doc.add(field2);\n    doc.add(field3);\n    doc.add(field4);\n    doc.add(field5);\n    doc.add(field6);\n    for (int i = 0; i < MAXDOC; i++) {\n      String stringValue = Integer.toString(i) + \" verycommon \" + English.intToEnglish(i).replace('-', ' ') + \" \" + _TestUtil.randomSimpleString(random());\n      field1.setStringValue(stringValue);\n      field2.setStringValue(stringValue);\n      field3.setStringValue(stringValue);\n      field4.setStringValue(stringValue);\n      field5.setStringValue(stringValue);\n      field6.setStringValue(stringValue);\n      iw.addDocument(doc);\n    }\n    iw.close();\n    verify(dir);\n    _TestUtil.checkIndex(dir); // for some extra coverage, checkIndex before we forceMerge\n    iwc.setOpenMode(OpenMode.APPEND);\n    IndexWriter iw2 = new IndexWriter(dir, iwc);\n    iw2.forceMerge(1);\n    iw2.close();\n    verify(dir);\n    dir.close();\n  }\n\n","sourceOld":"  // creates 6 fields with different options and does \"duels\" of fields against each other\n  public void test() throws Exception {\n    Directory dir = newDirectory();\n    Analyzer analyzer = new Analyzer(new Analyzer.PerFieldReuseStrategy()) {\n      @Override\n      protected TokenStreamComponents createComponents(String fieldName, Reader reader) {\n        Tokenizer tokenizer = new MockTokenizer(reader);\n        if (fieldName.contains(\"payloadsFixed\")) {\n          TokenFilter filter = new MockFixedLengthPayloadFilter(new Random(0), tokenizer, 1);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else if (fieldName.contains(\"payloadsVariable\")) {\n          TokenFilter filter = new MockVariableLengthPayloadFilter(new Random(0), tokenizer);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else {\n          return new TokenStreamComponents(tokenizer);\n        }\n      }\n    };\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer);\n    iwc.setCodec(new Lucene40Codec() {\n      @Override\n      public PostingsFormat getPostingsFormatForField(String field) {\n        return PostingsFormat.forName(\"Block\");\n        // TODO: we could actually add more fields implemented with different PFs\n      }\n    });\n    RandomIndexWriter iw = new RandomIndexWriter(random(), dir, iwc);\n    Document doc = new Document();\n    FieldType bareType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn these on for a cross-check\n    bareType.setStoreTermVectors(true);\n    bareType.setStoreTermVectorPositions(true);\n    bareType.setStoreTermVectorOffsets(true);\n    bareType.setStoreTermVectorPayloads(true);\n    FieldType offsetsType = new FieldType(bareType);\n    offsetsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    Field field1 = new Field(\"field1bare\", \"\", bareType);\n    Field field2 = new Field(\"field2offsets\", \"\", offsetsType);\n    Field field3 = new Field(\"field3payloadsFixed\", \"\", bareType);\n    Field field4 = new Field(\"field4payloadsVariable\", \"\", bareType);\n    Field field5 = new Field(\"field5payloadsFixedOffsets\", \"\", offsetsType);\n    Field field6 = new Field(\"field6payloadsVariableOffsets\", \"\", offsetsType);\n    doc.add(field1);\n    doc.add(field2);\n    doc.add(field3);\n    doc.add(field4);\n    doc.add(field5);\n    doc.add(field6);\n    for (int i = 0; i < MAXDOC; i++) {\n      String stringValue = Integer.toString(i) + \" verycommon \" + English.intToEnglish(i).replace('-', ' ') + \" \" + _TestUtil.randomSimpleString(random());\n      field1.setStringValue(stringValue);\n      field2.setStringValue(stringValue);\n      field3.setStringValue(stringValue);\n      field4.setStringValue(stringValue);\n      field5.setStringValue(stringValue);\n      field6.setStringValue(stringValue);\n      iw.addDocument(doc);\n    }\n    iw.close();\n    verify(dir);\n    _TestUtil.checkIndex(dir); // for some extra coverage, checkIndex before we forceMerge\n    iwc.setOpenMode(OpenMode.APPEND);\n    IndexWriter iw2 = new IndexWriter(dir, iwc);\n    iw2.forceMerge(1);\n    iw2.close();\n    verify(dir);\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"db4fdbf3d262768eabc027cd8321edca0cd11fa8","date":1350574784,"type":1,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/lucene41/TestBlockPostingsFormat3#test().mjava","pathOld":"lucene/codecs/src/test/org/apache/lucene/codecs/block/TestBlockPostingsFormat3#test().mjava","sourceNew":"  // creates 6 fields with different options and does \"duels\" of fields against each other\n  public void test() throws Exception {\n    Directory dir = newDirectory();\n    Analyzer analyzer = new Analyzer(new Analyzer.PerFieldReuseStrategy()) {\n      @Override\n      protected TokenStreamComponents createComponents(String fieldName, Reader reader) {\n        Tokenizer tokenizer = new MockTokenizer(reader);\n        if (fieldName.contains(\"payloadsFixed\")) {\n          TokenFilter filter = new MockFixedLengthPayloadFilter(new Random(0), tokenizer, 1);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else if (fieldName.contains(\"payloadsVariable\")) {\n          TokenFilter filter = new MockVariableLengthPayloadFilter(new Random(0), tokenizer);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else {\n          return new TokenStreamComponents(tokenizer);\n        }\n      }\n    };\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer);\n    iwc.setCodec(new Lucene41Codec() {\n      @Override\n      public PostingsFormat getPostingsFormatForField(String field) {\n        return PostingsFormat.forName(\"Lucene41\");\n        // TODO: we could actually add more fields implemented with different PFs\n      }\n    });\n    RandomIndexWriter iw = new RandomIndexWriter(random(), dir, iwc);\n    Document doc = new Document();\n    FieldType bareType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn these on for a cross-check\n    bareType.setStoreTermVectors(true);\n    bareType.setStoreTermVectorPositions(true);\n    bareType.setStoreTermVectorOffsets(true);\n    bareType.setStoreTermVectorPayloads(true);\n    FieldType offsetsType = new FieldType(bareType);\n    offsetsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    Field field1 = new Field(\"field1bare\", \"\", bareType);\n    Field field2 = new Field(\"field2offsets\", \"\", offsetsType);\n    Field field3 = new Field(\"field3payloadsFixed\", \"\", bareType);\n    Field field4 = new Field(\"field4payloadsVariable\", \"\", bareType);\n    Field field5 = new Field(\"field5payloadsFixedOffsets\", \"\", offsetsType);\n    Field field6 = new Field(\"field6payloadsVariableOffsets\", \"\", offsetsType);\n    doc.add(field1);\n    doc.add(field2);\n    doc.add(field3);\n    doc.add(field4);\n    doc.add(field5);\n    doc.add(field6);\n    for (int i = 0; i < MAXDOC; i++) {\n      String stringValue = Integer.toString(i) + \" verycommon \" + English.intToEnglish(i).replace('-', ' ') + \" \" + _TestUtil.randomSimpleString(random());\n      field1.setStringValue(stringValue);\n      field2.setStringValue(stringValue);\n      field3.setStringValue(stringValue);\n      field4.setStringValue(stringValue);\n      field5.setStringValue(stringValue);\n      field6.setStringValue(stringValue);\n      iw.addDocument(doc);\n    }\n    iw.close();\n    verify(dir);\n    _TestUtil.checkIndex(dir); // for some extra coverage, checkIndex before we forceMerge\n    iwc.setOpenMode(OpenMode.APPEND);\n    IndexWriter iw2 = new IndexWriter(dir, iwc);\n    iw2.forceMerge(1);\n    iw2.close();\n    verify(dir);\n    dir.close();\n  }\n\n","sourceOld":"  // creates 6 fields with different options and does \"duels\" of fields against each other\n  public void test() throws Exception {\n    Directory dir = newDirectory();\n    Analyzer analyzer = new Analyzer(new Analyzer.PerFieldReuseStrategy()) {\n      @Override\n      protected TokenStreamComponents createComponents(String fieldName, Reader reader) {\n        Tokenizer tokenizer = new MockTokenizer(reader);\n        if (fieldName.contains(\"payloadsFixed\")) {\n          TokenFilter filter = new MockFixedLengthPayloadFilter(new Random(0), tokenizer, 1);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else if (fieldName.contains(\"payloadsVariable\")) {\n          TokenFilter filter = new MockVariableLengthPayloadFilter(new Random(0), tokenizer);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else {\n          return new TokenStreamComponents(tokenizer);\n        }\n      }\n    };\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer);\n    iwc.setCodec(new Lucene40Codec() {\n      @Override\n      public PostingsFormat getPostingsFormatForField(String field) {\n        return PostingsFormat.forName(\"Block\");\n        // TODO: we could actually add more fields implemented with different PFs\n      }\n    });\n    RandomIndexWriter iw = new RandomIndexWriter(random(), dir, iwc);\n    Document doc = new Document();\n    FieldType bareType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn these on for a cross-check\n    bareType.setStoreTermVectors(true);\n    bareType.setStoreTermVectorPositions(true);\n    bareType.setStoreTermVectorOffsets(true);\n    bareType.setStoreTermVectorPayloads(true);\n    FieldType offsetsType = new FieldType(bareType);\n    offsetsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    Field field1 = new Field(\"field1bare\", \"\", bareType);\n    Field field2 = new Field(\"field2offsets\", \"\", offsetsType);\n    Field field3 = new Field(\"field3payloadsFixed\", \"\", bareType);\n    Field field4 = new Field(\"field4payloadsVariable\", \"\", bareType);\n    Field field5 = new Field(\"field5payloadsFixedOffsets\", \"\", offsetsType);\n    Field field6 = new Field(\"field6payloadsVariableOffsets\", \"\", offsetsType);\n    doc.add(field1);\n    doc.add(field2);\n    doc.add(field3);\n    doc.add(field4);\n    doc.add(field5);\n    doc.add(field6);\n    for (int i = 0; i < MAXDOC; i++) {\n      String stringValue = Integer.toString(i) + \" verycommon \" + English.intToEnglish(i).replace('-', ' ') + \" \" + _TestUtil.randomSimpleString(random());\n      field1.setStringValue(stringValue);\n      field2.setStringValue(stringValue);\n      field3.setStringValue(stringValue);\n      field4.setStringValue(stringValue);\n      field5.setStringValue(stringValue);\n      field6.setStringValue(stringValue);\n      iw.addDocument(doc);\n    }\n    iw.close();\n    verify(dir);\n    _TestUtil.checkIndex(dir); // for some extra coverage, checkIndex before we forceMerge\n    iwc.setOpenMode(OpenMode.APPEND);\n    IndexWriter iw2 = new IndexWriter(dir, iwc);\n    iw2.forceMerge(1);\n    iw2.close();\n    verify(dir);\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2989b58779e186266a5d5ab0c6fc46096e68b848","date":1350919624,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/lucene41/TestBlockPostingsFormat3#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/lucene41/TestBlockPostingsFormat3#test().mjava","sourceNew":"  // creates 8 fields with different options and does \"duels\" of fields against each other\n  public void test() throws Exception {\n    Directory dir = newDirectory();\n    Analyzer analyzer = new Analyzer(new Analyzer.PerFieldReuseStrategy()) {\n      @Override\n      protected TokenStreamComponents createComponents(String fieldName, Reader reader) {\n        Tokenizer tokenizer = new MockTokenizer(reader);\n        if (fieldName.contains(\"payloadsFixed\")) {\n          TokenFilter filter = new MockFixedLengthPayloadFilter(new Random(0), tokenizer, 1);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else if (fieldName.contains(\"payloadsVariable\")) {\n          TokenFilter filter = new MockVariableLengthPayloadFilter(new Random(0), tokenizer);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else {\n          return new TokenStreamComponents(tokenizer);\n        }\n      }\n    };\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer);\n    iwc.setCodec(new Lucene41Codec()); \n    // TODO we could actually add more fields implemented with different PFs\n    // or, just put this test into the usual rotation?\n    RandomIndexWriter iw = new RandomIndexWriter(random(), dir, iwc);\n    Document doc = new Document();\n    FieldType docsOnlyType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsOnlyType.setStoreTermVectors(true);\n    docsOnlyType.setIndexOptions(IndexOptions.DOCS_ONLY);\n    \n    FieldType docsAndFreqsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsAndFreqsType.setStoreTermVectors(true);\n    docsAndFreqsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    \n    FieldType positionsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn these on for a cross-check\n    positionsType.setStoreTermVectors(true);\n    positionsType.setStoreTermVectorPositions(true);\n    positionsType.setStoreTermVectorOffsets(true);\n    positionsType.setStoreTermVectorPayloads(true);\n    FieldType offsetsType = new FieldType(positionsType);\n    offsetsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    Field field1 = new Field(\"field1docs\", \"\", docsOnlyType);\n    Field field2 = new Field(\"field2freqs\", \"\", docsAndFreqsType);\n    Field field3 = new Field(\"field3positions\", \"\", positionsType);\n    Field field4 = new Field(\"field4offsets\", \"\", offsetsType);\n    Field field5 = new Field(\"field5payloadsFixed\", \"\", positionsType);\n    Field field6 = new Field(\"field6payloadsVariable\", \"\", positionsType);\n    Field field7 = new Field(\"field7payloadsFixedOffsets\", \"\", offsetsType);\n    Field field8 = new Field(\"field8payloadsVariableOffsets\", \"\", offsetsType);\n    doc.add(field1);\n    doc.add(field2);\n    doc.add(field3);\n    doc.add(field4);\n    doc.add(field5);\n    doc.add(field6);\n    doc.add(field7);\n    doc.add(field8);\n    for (int i = 0; i < MAXDOC; i++) {\n      String stringValue = Integer.toString(i) + \" verycommon \" + English.intToEnglish(i).replace('-', ' ') + \" \" + _TestUtil.randomSimpleString(random());\n      field1.setStringValue(stringValue);\n      field2.setStringValue(stringValue);\n      field3.setStringValue(stringValue);\n      field4.setStringValue(stringValue);\n      field5.setStringValue(stringValue);\n      field6.setStringValue(stringValue);\n      field7.setStringValue(stringValue);\n      field8.setStringValue(stringValue);\n      iw.addDocument(doc);\n    }\n    iw.close();\n    verify(dir);\n    _TestUtil.checkIndex(dir); // for some extra coverage, checkIndex before we forceMerge\n    iwc.setOpenMode(OpenMode.APPEND);\n    IndexWriter iw2 = new IndexWriter(dir, iwc);\n    iw2.forceMerge(1);\n    iw2.close();\n    verify(dir);\n    dir.close();\n  }\n\n","sourceOld":"  // creates 6 fields with different options and does \"duels\" of fields against each other\n  public void test() throws Exception {\n    Directory dir = newDirectory();\n    Analyzer analyzer = new Analyzer(new Analyzer.PerFieldReuseStrategy()) {\n      @Override\n      protected TokenStreamComponents createComponents(String fieldName, Reader reader) {\n        Tokenizer tokenizer = new MockTokenizer(reader);\n        if (fieldName.contains(\"payloadsFixed\")) {\n          TokenFilter filter = new MockFixedLengthPayloadFilter(new Random(0), tokenizer, 1);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else if (fieldName.contains(\"payloadsVariable\")) {\n          TokenFilter filter = new MockVariableLengthPayloadFilter(new Random(0), tokenizer);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else {\n          return new TokenStreamComponents(tokenizer);\n        }\n      }\n    };\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer);\n    iwc.setCodec(new Lucene41Codec() {\n      @Override\n      public PostingsFormat getPostingsFormatForField(String field) {\n        return PostingsFormat.forName(\"Lucene41\");\n        // TODO: we could actually add more fields implemented with different PFs\n      }\n    });\n    RandomIndexWriter iw = new RandomIndexWriter(random(), dir, iwc);\n    Document doc = new Document();\n    FieldType bareType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn these on for a cross-check\n    bareType.setStoreTermVectors(true);\n    bareType.setStoreTermVectorPositions(true);\n    bareType.setStoreTermVectorOffsets(true);\n    bareType.setStoreTermVectorPayloads(true);\n    FieldType offsetsType = new FieldType(bareType);\n    offsetsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    Field field1 = new Field(\"field1bare\", \"\", bareType);\n    Field field2 = new Field(\"field2offsets\", \"\", offsetsType);\n    Field field3 = new Field(\"field3payloadsFixed\", \"\", bareType);\n    Field field4 = new Field(\"field4payloadsVariable\", \"\", bareType);\n    Field field5 = new Field(\"field5payloadsFixedOffsets\", \"\", offsetsType);\n    Field field6 = new Field(\"field6payloadsVariableOffsets\", \"\", offsetsType);\n    doc.add(field1);\n    doc.add(field2);\n    doc.add(field3);\n    doc.add(field4);\n    doc.add(field5);\n    doc.add(field6);\n    for (int i = 0; i < MAXDOC; i++) {\n      String stringValue = Integer.toString(i) + \" verycommon \" + English.intToEnglish(i).replace('-', ' ') + \" \" + _TestUtil.randomSimpleString(random());\n      field1.setStringValue(stringValue);\n      field2.setStringValue(stringValue);\n      field3.setStringValue(stringValue);\n      field4.setStringValue(stringValue);\n      field5.setStringValue(stringValue);\n      field6.setStringValue(stringValue);\n      iw.addDocument(doc);\n    }\n    iw.close();\n    verify(dir);\n    _TestUtil.checkIndex(dir); // for some extra coverage, checkIndex before we forceMerge\n    iwc.setOpenMode(OpenMode.APPEND);\n    IndexWriter iw2 = new IndexWriter(dir, iwc);\n    iw2.forceMerge(1);\n    iw2.close();\n    verify(dir);\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"62e52115b56781006682fd92c6938efaf174304d","date":1351014780,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/lucene41/TestBlockPostingsFormat3#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/lucene41/TestBlockPostingsFormat3#test().mjava","sourceNew":"  // creates 8 fields with different options and does \"duels\" of fields against each other\n  public void test() throws Exception {\n    Directory dir = newDirectory();\n    Analyzer analyzer = new Analyzer(new Analyzer.PerFieldReuseStrategy()) {\n      @Override\n      protected TokenStreamComponents createComponents(String fieldName, Reader reader) {\n        Tokenizer tokenizer = new MockTokenizer(reader);\n        if (fieldName.contains(\"payloadsFixed\")) {\n          TokenFilter filter = new MockFixedLengthPayloadFilter(new Random(0), tokenizer, 1);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else if (fieldName.contains(\"payloadsVariable\")) {\n          TokenFilter filter = new MockVariableLengthPayloadFilter(new Random(0), tokenizer);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else {\n          return new TokenStreamComponents(tokenizer);\n        }\n      }\n    };\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer);\n    iwc.setCodec(new Lucene41Codec()); \n    // TODO we could actually add more fields implemented with different PFs\n    // or, just put this test into the usual rotation?\n    RandomIndexWriter iw = new RandomIndexWriter(random(), dir, iwc);\n    Document doc = new Document();\n    FieldType docsOnlyType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsOnlyType.setStoreTermVectors(true);\n    docsOnlyType.setIndexOptions(IndexOptions.DOCS_ONLY);\n    \n    FieldType docsAndFreqsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsAndFreqsType.setStoreTermVectors(true);\n    docsAndFreqsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    \n    FieldType positionsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn these on for a cross-check\n    positionsType.setStoreTermVectors(true);\n    positionsType.setStoreTermVectorPositions(true);\n    positionsType.setStoreTermVectorOffsets(true);\n    positionsType.setStoreTermVectorPayloads(true);\n    FieldType offsetsType = new FieldType(positionsType);\n    offsetsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    Field field1 = new Field(\"field1docs\", \"\", docsOnlyType);\n    Field field2 = new Field(\"field2freqs\", \"\", docsAndFreqsType);\n    Field field3 = new Field(\"field3positions\", \"\", positionsType);\n    Field field4 = new Field(\"field4offsets\", \"\", offsetsType);\n    Field field5 = new Field(\"field5payloadsFixed\", \"\", positionsType);\n    Field field6 = new Field(\"field6payloadsVariable\", \"\", positionsType);\n    Field field7 = new Field(\"field7payloadsFixedOffsets\", \"\", offsetsType);\n    Field field8 = new Field(\"field8payloadsVariableOffsets\", \"\", offsetsType);\n    doc.add(field1);\n    doc.add(field2);\n    doc.add(field3);\n    doc.add(field4);\n    doc.add(field5);\n    doc.add(field6);\n    doc.add(field7);\n    doc.add(field8);\n    for (int i = 0; i < MAXDOC; i++) {\n      String stringValue = Integer.toString(i) + \" verycommon \" + English.intToEnglish(i).replace('-', ' ') + \" \" + _TestUtil.randomSimpleString(random());\n      field1.setStringValue(stringValue);\n      field2.setStringValue(stringValue);\n      field3.setStringValue(stringValue);\n      field4.setStringValue(stringValue);\n      field5.setStringValue(stringValue);\n      field6.setStringValue(stringValue);\n      field7.setStringValue(stringValue);\n      field8.setStringValue(stringValue);\n      iw.addDocument(doc);\n    }\n    iw.close();\n    verify(dir);\n    _TestUtil.checkIndex(dir); // for some extra coverage, checkIndex before we forceMerge\n    iwc.setOpenMode(OpenMode.APPEND);\n    IndexWriter iw2 = new IndexWriter(dir, iwc);\n    iw2.forceMerge(1);\n    iw2.close();\n    verify(dir);\n    dir.close();\n  }\n\n","sourceOld":"  // creates 6 fields with different options and does \"duels\" of fields against each other\n  public void test() throws Exception {\n    Directory dir = newDirectory();\n    Analyzer analyzer = new Analyzer(new Analyzer.PerFieldReuseStrategy()) {\n      @Override\n      protected TokenStreamComponents createComponents(String fieldName, Reader reader) {\n        Tokenizer tokenizer = new MockTokenizer(reader);\n        if (fieldName.contains(\"payloadsFixed\")) {\n          TokenFilter filter = new MockFixedLengthPayloadFilter(new Random(0), tokenizer, 1);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else if (fieldName.contains(\"payloadsVariable\")) {\n          TokenFilter filter = new MockVariableLengthPayloadFilter(new Random(0), tokenizer);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else {\n          return new TokenStreamComponents(tokenizer);\n        }\n      }\n    };\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer);\n    iwc.setCodec(new Lucene41Codec() {\n      @Override\n      public PostingsFormat getPostingsFormatForField(String field) {\n        return PostingsFormat.forName(\"Lucene41\");\n        // TODO: we could actually add more fields implemented with different PFs\n      }\n    });\n    RandomIndexWriter iw = new RandomIndexWriter(random(), dir, iwc);\n    Document doc = new Document();\n    FieldType bareType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn these on for a cross-check\n    bareType.setStoreTermVectors(true);\n    bareType.setStoreTermVectorPositions(true);\n    bareType.setStoreTermVectorOffsets(true);\n    bareType.setStoreTermVectorPayloads(true);\n    FieldType offsetsType = new FieldType(bareType);\n    offsetsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    Field field1 = new Field(\"field1bare\", \"\", bareType);\n    Field field2 = new Field(\"field2offsets\", \"\", offsetsType);\n    Field field3 = new Field(\"field3payloadsFixed\", \"\", bareType);\n    Field field4 = new Field(\"field4payloadsVariable\", \"\", bareType);\n    Field field5 = new Field(\"field5payloadsFixedOffsets\", \"\", offsetsType);\n    Field field6 = new Field(\"field6payloadsVariableOffsets\", \"\", offsetsType);\n    doc.add(field1);\n    doc.add(field2);\n    doc.add(field3);\n    doc.add(field4);\n    doc.add(field5);\n    doc.add(field6);\n    for (int i = 0; i < MAXDOC; i++) {\n      String stringValue = Integer.toString(i) + \" verycommon \" + English.intToEnglish(i).replace('-', ' ') + \" \" + _TestUtil.randomSimpleString(random());\n      field1.setStringValue(stringValue);\n      field2.setStringValue(stringValue);\n      field3.setStringValue(stringValue);\n      field4.setStringValue(stringValue);\n      field5.setStringValue(stringValue);\n      field6.setStringValue(stringValue);\n      iw.addDocument(doc);\n    }\n    iw.close();\n    verify(dir);\n    _TestUtil.checkIndex(dir); // for some extra coverage, checkIndex before we forceMerge\n    iwc.setOpenMode(OpenMode.APPEND);\n    IndexWriter iw2 = new IndexWriter(dir, iwc);\n    iw2.forceMerge(1);\n    iw2.close();\n    verify(dir);\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3fe3dfb6cc2d72874c6ebeee5cf8b6818434714e","date":1358793943,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/lucene41/TestBlockPostingsFormat3#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/lucene41/TestBlockPostingsFormat3#test().mjava","sourceNew":"  // creates 8 fields with different options and does \"duels\" of fields against each other\n  public void test() throws Exception {\n    Directory dir = newDirectory();\n    Analyzer analyzer = new Analyzer(new Analyzer.PerFieldReuseStrategy()) {\n      @Override\n      protected TokenStreamComponents createComponents(String fieldName, Reader reader) {\n        Tokenizer tokenizer = new MockTokenizer(reader);\n        if (fieldName.contains(\"payloadsFixed\")) {\n          TokenFilter filter = new MockFixedLengthPayloadFilter(new Random(0), tokenizer, 1);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else if (fieldName.contains(\"payloadsVariable\")) {\n          TokenFilter filter = new MockVariableLengthPayloadFilter(new Random(0), tokenizer);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else {\n          return new TokenStreamComponents(tokenizer);\n        }\n      }\n    };\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer);\n    iwc.setCodec(_TestUtil.alwaysPostingsFormat(new Lucene41PostingsFormat())); \n    // TODO we could actually add more fields implemented with different PFs\n    // or, just put this test into the usual rotation?\n    RandomIndexWriter iw = new RandomIndexWriter(random(), dir, iwc);\n    Document doc = new Document();\n    FieldType docsOnlyType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsOnlyType.setStoreTermVectors(true);\n    docsOnlyType.setIndexOptions(IndexOptions.DOCS_ONLY);\n    \n    FieldType docsAndFreqsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsAndFreqsType.setStoreTermVectors(true);\n    docsAndFreqsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    \n    FieldType positionsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn these on for a cross-check\n    positionsType.setStoreTermVectors(true);\n    positionsType.setStoreTermVectorPositions(true);\n    positionsType.setStoreTermVectorOffsets(true);\n    positionsType.setStoreTermVectorPayloads(true);\n    FieldType offsetsType = new FieldType(positionsType);\n    offsetsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    Field field1 = new Field(\"field1docs\", \"\", docsOnlyType);\n    Field field2 = new Field(\"field2freqs\", \"\", docsAndFreqsType);\n    Field field3 = new Field(\"field3positions\", \"\", positionsType);\n    Field field4 = new Field(\"field4offsets\", \"\", offsetsType);\n    Field field5 = new Field(\"field5payloadsFixed\", \"\", positionsType);\n    Field field6 = new Field(\"field6payloadsVariable\", \"\", positionsType);\n    Field field7 = new Field(\"field7payloadsFixedOffsets\", \"\", offsetsType);\n    Field field8 = new Field(\"field8payloadsVariableOffsets\", \"\", offsetsType);\n    doc.add(field1);\n    doc.add(field2);\n    doc.add(field3);\n    doc.add(field4);\n    doc.add(field5);\n    doc.add(field6);\n    doc.add(field7);\n    doc.add(field8);\n    for (int i = 0; i < MAXDOC; i++) {\n      String stringValue = Integer.toString(i) + \" verycommon \" + English.intToEnglish(i).replace('-', ' ') + \" \" + _TestUtil.randomSimpleString(random());\n      field1.setStringValue(stringValue);\n      field2.setStringValue(stringValue);\n      field3.setStringValue(stringValue);\n      field4.setStringValue(stringValue);\n      field5.setStringValue(stringValue);\n      field6.setStringValue(stringValue);\n      field7.setStringValue(stringValue);\n      field8.setStringValue(stringValue);\n      iw.addDocument(doc);\n    }\n    iw.close();\n    verify(dir);\n    _TestUtil.checkIndex(dir); // for some extra coverage, checkIndex before we forceMerge\n    iwc.setOpenMode(OpenMode.APPEND);\n    IndexWriter iw2 = new IndexWriter(dir, iwc);\n    iw2.forceMerge(1);\n    iw2.close();\n    verify(dir);\n    dir.close();\n  }\n\n","sourceOld":"  // creates 8 fields with different options and does \"duels\" of fields against each other\n  public void test() throws Exception {\n    Directory dir = newDirectory();\n    Analyzer analyzer = new Analyzer(new Analyzer.PerFieldReuseStrategy()) {\n      @Override\n      protected TokenStreamComponents createComponents(String fieldName, Reader reader) {\n        Tokenizer tokenizer = new MockTokenizer(reader);\n        if (fieldName.contains(\"payloadsFixed\")) {\n          TokenFilter filter = new MockFixedLengthPayloadFilter(new Random(0), tokenizer, 1);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else if (fieldName.contains(\"payloadsVariable\")) {\n          TokenFilter filter = new MockVariableLengthPayloadFilter(new Random(0), tokenizer);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else {\n          return new TokenStreamComponents(tokenizer);\n        }\n      }\n    };\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer);\n    iwc.setCodec(new Lucene41Codec()); \n    // TODO we could actually add more fields implemented with different PFs\n    // or, just put this test into the usual rotation?\n    RandomIndexWriter iw = new RandomIndexWriter(random(), dir, iwc);\n    Document doc = new Document();\n    FieldType docsOnlyType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsOnlyType.setStoreTermVectors(true);\n    docsOnlyType.setIndexOptions(IndexOptions.DOCS_ONLY);\n    \n    FieldType docsAndFreqsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsAndFreqsType.setStoreTermVectors(true);\n    docsAndFreqsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    \n    FieldType positionsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn these on for a cross-check\n    positionsType.setStoreTermVectors(true);\n    positionsType.setStoreTermVectorPositions(true);\n    positionsType.setStoreTermVectorOffsets(true);\n    positionsType.setStoreTermVectorPayloads(true);\n    FieldType offsetsType = new FieldType(positionsType);\n    offsetsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    Field field1 = new Field(\"field1docs\", \"\", docsOnlyType);\n    Field field2 = new Field(\"field2freqs\", \"\", docsAndFreqsType);\n    Field field3 = new Field(\"field3positions\", \"\", positionsType);\n    Field field4 = new Field(\"field4offsets\", \"\", offsetsType);\n    Field field5 = new Field(\"field5payloadsFixed\", \"\", positionsType);\n    Field field6 = new Field(\"field6payloadsVariable\", \"\", positionsType);\n    Field field7 = new Field(\"field7payloadsFixedOffsets\", \"\", offsetsType);\n    Field field8 = new Field(\"field8payloadsVariableOffsets\", \"\", offsetsType);\n    doc.add(field1);\n    doc.add(field2);\n    doc.add(field3);\n    doc.add(field4);\n    doc.add(field5);\n    doc.add(field6);\n    doc.add(field7);\n    doc.add(field8);\n    for (int i = 0; i < MAXDOC; i++) {\n      String stringValue = Integer.toString(i) + \" verycommon \" + English.intToEnglish(i).replace('-', ' ') + \" \" + _TestUtil.randomSimpleString(random());\n      field1.setStringValue(stringValue);\n      field2.setStringValue(stringValue);\n      field3.setStringValue(stringValue);\n      field4.setStringValue(stringValue);\n      field5.setStringValue(stringValue);\n      field6.setStringValue(stringValue);\n      field7.setStringValue(stringValue);\n      field8.setStringValue(stringValue);\n      iw.addDocument(doc);\n    }\n    iw.close();\n    verify(dir);\n    _TestUtil.checkIndex(dir); // for some extra coverage, checkIndex before we forceMerge\n    iwc.setOpenMode(OpenMode.APPEND);\n    IndexWriter iw2 = new IndexWriter(dir, iwc);\n    iw2.forceMerge(1);\n    iw2.close();\n    verify(dir);\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d33aeb9ed95127e3cb6b2abce6c4b0441e6c3633","date":1359743129,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/lucene41/TestBlockPostingsFormat3#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/lucene41/TestBlockPostingsFormat3#test().mjava","sourceNew":"  // creates 8 fields with different options and does \"duels\" of fields against each other\n  public void test() throws Exception {\n    Directory dir = newDirectory();\n    Analyzer analyzer = new Analyzer(new Analyzer.PerFieldReuseStrategy()) {\n      @Override\n      protected TokenStreamComponents createComponents(String fieldName, Reader reader) {\n        Tokenizer tokenizer = new MockTokenizer(reader);\n        if (fieldName.contains(\"payloadsFixed\")) {\n          TokenFilter filter = new MockFixedLengthPayloadFilter(new Random(0), tokenizer, 1);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else if (fieldName.contains(\"payloadsVariable\")) {\n          TokenFilter filter = new MockVariableLengthPayloadFilter(new Random(0), tokenizer);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else {\n          return new TokenStreamComponents(tokenizer);\n        }\n      }\n    };\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer);\n    iwc.setCodec(_TestUtil.alwaysPostingsFormat(new Lucene41PostingsFormat())); \n    // TODO we could actually add more fields implemented with different PFs\n    // or, just put this test into the usual rotation?\n    RandomIndexWriter iw = new RandomIndexWriter(random(), dir, iwc);\n    Document doc = new Document();\n    FieldType docsOnlyType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsOnlyType.setStoreTermVectors(true);\n    docsOnlyType.setIndexOptions(IndexOptions.DOCS_ONLY);\n    \n    FieldType docsAndFreqsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsAndFreqsType.setStoreTermVectors(true);\n    docsAndFreqsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    \n    FieldType positionsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn these on for a cross-check\n    positionsType.setStoreTermVectors(true);\n    positionsType.setStoreTermVectorPositions(true);\n    positionsType.setStoreTermVectorOffsets(true);\n    positionsType.setStoreTermVectorPayloads(true);\n    FieldType offsetsType = new FieldType(positionsType);\n    offsetsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    Field field1 = new Field(\"field1docs\", \"\", docsOnlyType);\n    Field field2 = new Field(\"field2freqs\", \"\", docsAndFreqsType);\n    Field field3 = new Field(\"field3positions\", \"\", positionsType);\n    Field field4 = new Field(\"field4offsets\", \"\", offsetsType);\n    Field field5 = new Field(\"field5payloadsFixed\", \"\", positionsType);\n    Field field6 = new Field(\"field6payloadsVariable\", \"\", positionsType);\n    Field field7 = new Field(\"field7payloadsFixedOffsets\", \"\", offsetsType);\n    Field field8 = new Field(\"field8payloadsVariableOffsets\", \"\", offsetsType);\n    doc.add(field1);\n    doc.add(field2);\n    doc.add(field3);\n    doc.add(field4);\n    doc.add(field5);\n    doc.add(field6);\n    doc.add(field7);\n    doc.add(field8);\n    for (int i = 0; i < MAXDOC; i++) {\n      String stringValue = Integer.toString(i) + \" verycommon \" + English.intToEnglish(i).replace('-', ' ') + \" \" + _TestUtil.randomSimpleString(random());\n      field1.setStringValue(stringValue);\n      field2.setStringValue(stringValue);\n      field3.setStringValue(stringValue);\n      field4.setStringValue(stringValue);\n      field5.setStringValue(stringValue);\n      field6.setStringValue(stringValue);\n      field7.setStringValue(stringValue);\n      field8.setStringValue(stringValue);\n      iw.addDocument(doc);\n    }\n    iw.close();\n    verify(dir);\n    _TestUtil.checkIndex(dir); // for some extra coverage, checkIndex before we forceMerge\n    iwc.setOpenMode(OpenMode.APPEND);\n    IndexWriter iw2 = new IndexWriter(dir, iwc);\n    iw2.forceMerge(1);\n    iw2.close();\n    verify(dir);\n    dir.close();\n  }\n\n","sourceOld":"  // creates 8 fields with different options and does \"duels\" of fields against each other\n  public void test() throws Exception {\n    Directory dir = newDirectory();\n    Analyzer analyzer = new Analyzer(new Analyzer.PerFieldReuseStrategy()) {\n      @Override\n      protected TokenStreamComponents createComponents(String fieldName, Reader reader) {\n        Tokenizer tokenizer = new MockTokenizer(reader);\n        if (fieldName.contains(\"payloadsFixed\")) {\n          TokenFilter filter = new MockFixedLengthPayloadFilter(new Random(0), tokenizer, 1);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else if (fieldName.contains(\"payloadsVariable\")) {\n          TokenFilter filter = new MockVariableLengthPayloadFilter(new Random(0), tokenizer);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else {\n          return new TokenStreamComponents(tokenizer);\n        }\n      }\n    };\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer);\n    iwc.setCodec(new Lucene41Codec()); \n    // TODO we could actually add more fields implemented with different PFs\n    // or, just put this test into the usual rotation?\n    RandomIndexWriter iw = new RandomIndexWriter(random(), dir, iwc);\n    Document doc = new Document();\n    FieldType docsOnlyType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsOnlyType.setStoreTermVectors(true);\n    docsOnlyType.setIndexOptions(IndexOptions.DOCS_ONLY);\n    \n    FieldType docsAndFreqsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsAndFreqsType.setStoreTermVectors(true);\n    docsAndFreqsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    \n    FieldType positionsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn these on for a cross-check\n    positionsType.setStoreTermVectors(true);\n    positionsType.setStoreTermVectorPositions(true);\n    positionsType.setStoreTermVectorOffsets(true);\n    positionsType.setStoreTermVectorPayloads(true);\n    FieldType offsetsType = new FieldType(positionsType);\n    offsetsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    Field field1 = new Field(\"field1docs\", \"\", docsOnlyType);\n    Field field2 = new Field(\"field2freqs\", \"\", docsAndFreqsType);\n    Field field3 = new Field(\"field3positions\", \"\", positionsType);\n    Field field4 = new Field(\"field4offsets\", \"\", offsetsType);\n    Field field5 = new Field(\"field5payloadsFixed\", \"\", positionsType);\n    Field field6 = new Field(\"field6payloadsVariable\", \"\", positionsType);\n    Field field7 = new Field(\"field7payloadsFixedOffsets\", \"\", offsetsType);\n    Field field8 = new Field(\"field8payloadsVariableOffsets\", \"\", offsetsType);\n    doc.add(field1);\n    doc.add(field2);\n    doc.add(field3);\n    doc.add(field4);\n    doc.add(field5);\n    doc.add(field6);\n    doc.add(field7);\n    doc.add(field8);\n    for (int i = 0; i < MAXDOC; i++) {\n      String stringValue = Integer.toString(i) + \" verycommon \" + English.intToEnglish(i).replace('-', ' ') + \" \" + _TestUtil.randomSimpleString(random());\n      field1.setStringValue(stringValue);\n      field2.setStringValue(stringValue);\n      field3.setStringValue(stringValue);\n      field4.setStringValue(stringValue);\n      field5.setStringValue(stringValue);\n      field6.setStringValue(stringValue);\n      field7.setStringValue(stringValue);\n      field8.setStringValue(stringValue);\n      iw.addDocument(doc);\n    }\n    iw.close();\n    verify(dir);\n    _TestUtil.checkIndex(dir); // for some extra coverage, checkIndex before we forceMerge\n    iwc.setOpenMode(OpenMode.APPEND);\n    IndexWriter iw2 = new IndexWriter(dir, iwc);\n    iw2.forceMerge(1);\n    iw2.close();\n    verify(dir);\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4ce24aa081e44190692bbebc8aead342ad7060e8","date":1374951664,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/lucene41/TestBlockPostingsFormat3#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/lucene41/TestBlockPostingsFormat3#test().mjava","sourceNew":"  // creates 8 fields with different options and does \"duels\" of fields against each other\n  public void test() throws Exception {\n    Directory dir = newDirectory();\n    Analyzer analyzer = new Analyzer(new Analyzer.PerFieldReuseStrategy()) {\n      @Override\n      protected TokenStreamComponents createComponents(String fieldName, Reader reader) {\n        Tokenizer tokenizer = new MockTokenizer(reader);\n        if (fieldName.contains(\"payloadsFixed\")) {\n          TokenFilter filter = new MockFixedLengthPayloadFilter(new Random(0), tokenizer, 1);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else if (fieldName.contains(\"payloadsVariable\")) {\n          TokenFilter filter = new MockVariableLengthPayloadFilter(new Random(0), tokenizer);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else {\n          return new TokenStreamComponents(tokenizer);\n        }\n      }\n    };\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer);\n    iwc.setCodec(_TestUtil.alwaysPostingsFormat(new Lucene41PostingsFormat())); \n    // TODO we could actually add more fields implemented with different PFs\n    // or, just put this test into the usual rotation?\n    RandomIndexWriter iw = new RandomIndexWriter(random(), dir, iwc.clone());\n    Document doc = new Document();\n    FieldType docsOnlyType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsOnlyType.setStoreTermVectors(true);\n    docsOnlyType.setIndexOptions(IndexOptions.DOCS_ONLY);\n    \n    FieldType docsAndFreqsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsAndFreqsType.setStoreTermVectors(true);\n    docsAndFreqsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    \n    FieldType positionsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn these on for a cross-check\n    positionsType.setStoreTermVectors(true);\n    positionsType.setStoreTermVectorPositions(true);\n    positionsType.setStoreTermVectorOffsets(true);\n    positionsType.setStoreTermVectorPayloads(true);\n    FieldType offsetsType = new FieldType(positionsType);\n    offsetsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    Field field1 = new Field(\"field1docs\", \"\", docsOnlyType);\n    Field field2 = new Field(\"field2freqs\", \"\", docsAndFreqsType);\n    Field field3 = new Field(\"field3positions\", \"\", positionsType);\n    Field field4 = new Field(\"field4offsets\", \"\", offsetsType);\n    Field field5 = new Field(\"field5payloadsFixed\", \"\", positionsType);\n    Field field6 = new Field(\"field6payloadsVariable\", \"\", positionsType);\n    Field field7 = new Field(\"field7payloadsFixedOffsets\", \"\", offsetsType);\n    Field field8 = new Field(\"field8payloadsVariableOffsets\", \"\", offsetsType);\n    doc.add(field1);\n    doc.add(field2);\n    doc.add(field3);\n    doc.add(field4);\n    doc.add(field5);\n    doc.add(field6);\n    doc.add(field7);\n    doc.add(field8);\n    for (int i = 0; i < MAXDOC; i++) {\n      String stringValue = Integer.toString(i) + \" verycommon \" + English.intToEnglish(i).replace('-', ' ') + \" \" + _TestUtil.randomSimpleString(random());\n      field1.setStringValue(stringValue);\n      field2.setStringValue(stringValue);\n      field3.setStringValue(stringValue);\n      field4.setStringValue(stringValue);\n      field5.setStringValue(stringValue);\n      field6.setStringValue(stringValue);\n      field7.setStringValue(stringValue);\n      field8.setStringValue(stringValue);\n      iw.addDocument(doc);\n    }\n    iw.close();\n    verify(dir);\n    _TestUtil.checkIndex(dir); // for some extra coverage, checkIndex before we forceMerge\n    iwc.setOpenMode(OpenMode.APPEND);\n    IndexWriter iw2 = new IndexWriter(dir, iwc.clone());\n    iw2.forceMerge(1);\n    iw2.close();\n    verify(dir);\n    dir.close();\n  }\n\n","sourceOld":"  // creates 8 fields with different options and does \"duels\" of fields against each other\n  public void test() throws Exception {\n    Directory dir = newDirectory();\n    Analyzer analyzer = new Analyzer(new Analyzer.PerFieldReuseStrategy()) {\n      @Override\n      protected TokenStreamComponents createComponents(String fieldName, Reader reader) {\n        Tokenizer tokenizer = new MockTokenizer(reader);\n        if (fieldName.contains(\"payloadsFixed\")) {\n          TokenFilter filter = new MockFixedLengthPayloadFilter(new Random(0), tokenizer, 1);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else if (fieldName.contains(\"payloadsVariable\")) {\n          TokenFilter filter = new MockVariableLengthPayloadFilter(new Random(0), tokenizer);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else {\n          return new TokenStreamComponents(tokenizer);\n        }\n      }\n    };\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer);\n    iwc.setCodec(_TestUtil.alwaysPostingsFormat(new Lucene41PostingsFormat())); \n    // TODO we could actually add more fields implemented with different PFs\n    // or, just put this test into the usual rotation?\n    RandomIndexWriter iw = new RandomIndexWriter(random(), dir, iwc);\n    Document doc = new Document();\n    FieldType docsOnlyType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsOnlyType.setStoreTermVectors(true);\n    docsOnlyType.setIndexOptions(IndexOptions.DOCS_ONLY);\n    \n    FieldType docsAndFreqsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsAndFreqsType.setStoreTermVectors(true);\n    docsAndFreqsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    \n    FieldType positionsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn these on for a cross-check\n    positionsType.setStoreTermVectors(true);\n    positionsType.setStoreTermVectorPositions(true);\n    positionsType.setStoreTermVectorOffsets(true);\n    positionsType.setStoreTermVectorPayloads(true);\n    FieldType offsetsType = new FieldType(positionsType);\n    offsetsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    Field field1 = new Field(\"field1docs\", \"\", docsOnlyType);\n    Field field2 = new Field(\"field2freqs\", \"\", docsAndFreqsType);\n    Field field3 = new Field(\"field3positions\", \"\", positionsType);\n    Field field4 = new Field(\"field4offsets\", \"\", offsetsType);\n    Field field5 = new Field(\"field5payloadsFixed\", \"\", positionsType);\n    Field field6 = new Field(\"field6payloadsVariable\", \"\", positionsType);\n    Field field7 = new Field(\"field7payloadsFixedOffsets\", \"\", offsetsType);\n    Field field8 = new Field(\"field8payloadsVariableOffsets\", \"\", offsetsType);\n    doc.add(field1);\n    doc.add(field2);\n    doc.add(field3);\n    doc.add(field4);\n    doc.add(field5);\n    doc.add(field6);\n    doc.add(field7);\n    doc.add(field8);\n    for (int i = 0; i < MAXDOC; i++) {\n      String stringValue = Integer.toString(i) + \" verycommon \" + English.intToEnglish(i).replace('-', ' ') + \" \" + _TestUtil.randomSimpleString(random());\n      field1.setStringValue(stringValue);\n      field2.setStringValue(stringValue);\n      field3.setStringValue(stringValue);\n      field4.setStringValue(stringValue);\n      field5.setStringValue(stringValue);\n      field6.setStringValue(stringValue);\n      field7.setStringValue(stringValue);\n      field8.setStringValue(stringValue);\n      iw.addDocument(doc);\n    }\n    iw.close();\n    verify(dir);\n    _TestUtil.checkIndex(dir); // for some extra coverage, checkIndex before we forceMerge\n    iwc.setOpenMode(OpenMode.APPEND);\n    IndexWriter iw2 = new IndexWriter(dir, iwc);\n    iw2.forceMerge(1);\n    iw2.close();\n    verify(dir);\n    dir.close();\n  }\n\n","bugFix":["746d604154f8744382434608bf4f14fd4892ae36"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","date":1376366778,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/lucene41/TestBlockPostingsFormat3#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/lucene41/TestBlockPostingsFormat3#test().mjava","sourceNew":"  // creates 8 fields with different options and does \"duels\" of fields against each other\n  public void test() throws Exception {\n    Directory dir = newDirectory();\n    Analyzer analyzer = new Analyzer(new Analyzer.PerFieldReuseStrategy()) {\n      @Override\n      protected TokenStreamComponents createComponents(String fieldName, Reader reader) {\n        Tokenizer tokenizer = new MockTokenizer(reader);\n        if (fieldName.contains(\"payloadsFixed\")) {\n          TokenFilter filter = new MockFixedLengthPayloadFilter(new Random(0), tokenizer, 1);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else if (fieldName.contains(\"payloadsVariable\")) {\n          TokenFilter filter = new MockVariableLengthPayloadFilter(new Random(0), tokenizer);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else {\n          return new TokenStreamComponents(tokenizer);\n        }\n      }\n    };\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer);\n    iwc.setCodec(_TestUtil.alwaysPostingsFormat(new Lucene41PostingsFormat())); \n    // TODO we could actually add more fields implemented with different PFs\n    // or, just put this test into the usual rotation?\n    RandomIndexWriter iw = new RandomIndexWriter(random(), dir, iwc.clone());\n    Document doc = new Document();\n    FieldType docsOnlyType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsOnlyType.setStoreTermVectors(true);\n    docsOnlyType.setIndexOptions(IndexOptions.DOCS_ONLY);\n    \n    FieldType docsAndFreqsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsAndFreqsType.setStoreTermVectors(true);\n    docsAndFreqsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    \n    FieldType positionsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn these on for a cross-check\n    positionsType.setStoreTermVectors(true);\n    positionsType.setStoreTermVectorPositions(true);\n    positionsType.setStoreTermVectorOffsets(true);\n    positionsType.setStoreTermVectorPayloads(true);\n    FieldType offsetsType = new FieldType(positionsType);\n    offsetsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    Field field1 = new Field(\"field1docs\", \"\", docsOnlyType);\n    Field field2 = new Field(\"field2freqs\", \"\", docsAndFreqsType);\n    Field field3 = new Field(\"field3positions\", \"\", positionsType);\n    Field field4 = new Field(\"field4offsets\", \"\", offsetsType);\n    Field field5 = new Field(\"field5payloadsFixed\", \"\", positionsType);\n    Field field6 = new Field(\"field6payloadsVariable\", \"\", positionsType);\n    Field field7 = new Field(\"field7payloadsFixedOffsets\", \"\", offsetsType);\n    Field field8 = new Field(\"field8payloadsVariableOffsets\", \"\", offsetsType);\n    doc.add(field1);\n    doc.add(field2);\n    doc.add(field3);\n    doc.add(field4);\n    doc.add(field5);\n    doc.add(field6);\n    doc.add(field7);\n    doc.add(field8);\n    for (int i = 0; i < MAXDOC; i++) {\n      String stringValue = Integer.toString(i) + \" verycommon \" + English.intToEnglish(i).replace('-', ' ') + \" \" + _TestUtil.randomSimpleString(random());\n      field1.setStringValue(stringValue);\n      field2.setStringValue(stringValue);\n      field3.setStringValue(stringValue);\n      field4.setStringValue(stringValue);\n      field5.setStringValue(stringValue);\n      field6.setStringValue(stringValue);\n      field7.setStringValue(stringValue);\n      field8.setStringValue(stringValue);\n      iw.addDocument(doc);\n    }\n    iw.close();\n    verify(dir);\n    _TestUtil.checkIndex(dir); // for some extra coverage, checkIndex before we forceMerge\n    iwc.setOpenMode(OpenMode.APPEND);\n    IndexWriter iw2 = new IndexWriter(dir, iwc.clone());\n    iw2.forceMerge(1);\n    iw2.close();\n    verify(dir);\n    dir.close();\n  }\n\n","sourceOld":"  // creates 8 fields with different options and does \"duels\" of fields against each other\n  public void test() throws Exception {\n    Directory dir = newDirectory();\n    Analyzer analyzer = new Analyzer(new Analyzer.PerFieldReuseStrategy()) {\n      @Override\n      protected TokenStreamComponents createComponents(String fieldName, Reader reader) {\n        Tokenizer tokenizer = new MockTokenizer(reader);\n        if (fieldName.contains(\"payloadsFixed\")) {\n          TokenFilter filter = new MockFixedLengthPayloadFilter(new Random(0), tokenizer, 1);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else if (fieldName.contains(\"payloadsVariable\")) {\n          TokenFilter filter = new MockVariableLengthPayloadFilter(new Random(0), tokenizer);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else {\n          return new TokenStreamComponents(tokenizer);\n        }\n      }\n    };\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer);\n    iwc.setCodec(_TestUtil.alwaysPostingsFormat(new Lucene41PostingsFormat())); \n    // TODO we could actually add more fields implemented with different PFs\n    // or, just put this test into the usual rotation?\n    RandomIndexWriter iw = new RandomIndexWriter(random(), dir, iwc);\n    Document doc = new Document();\n    FieldType docsOnlyType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsOnlyType.setStoreTermVectors(true);\n    docsOnlyType.setIndexOptions(IndexOptions.DOCS_ONLY);\n    \n    FieldType docsAndFreqsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsAndFreqsType.setStoreTermVectors(true);\n    docsAndFreqsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    \n    FieldType positionsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn these on for a cross-check\n    positionsType.setStoreTermVectors(true);\n    positionsType.setStoreTermVectorPositions(true);\n    positionsType.setStoreTermVectorOffsets(true);\n    positionsType.setStoreTermVectorPayloads(true);\n    FieldType offsetsType = new FieldType(positionsType);\n    offsetsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    Field field1 = new Field(\"field1docs\", \"\", docsOnlyType);\n    Field field2 = new Field(\"field2freqs\", \"\", docsAndFreqsType);\n    Field field3 = new Field(\"field3positions\", \"\", positionsType);\n    Field field4 = new Field(\"field4offsets\", \"\", offsetsType);\n    Field field5 = new Field(\"field5payloadsFixed\", \"\", positionsType);\n    Field field6 = new Field(\"field6payloadsVariable\", \"\", positionsType);\n    Field field7 = new Field(\"field7payloadsFixedOffsets\", \"\", offsetsType);\n    Field field8 = new Field(\"field8payloadsVariableOffsets\", \"\", offsetsType);\n    doc.add(field1);\n    doc.add(field2);\n    doc.add(field3);\n    doc.add(field4);\n    doc.add(field5);\n    doc.add(field6);\n    doc.add(field7);\n    doc.add(field8);\n    for (int i = 0; i < MAXDOC; i++) {\n      String stringValue = Integer.toString(i) + \" verycommon \" + English.intToEnglish(i).replace('-', ' ') + \" \" + _TestUtil.randomSimpleString(random());\n      field1.setStringValue(stringValue);\n      field2.setStringValue(stringValue);\n      field3.setStringValue(stringValue);\n      field4.setStringValue(stringValue);\n      field5.setStringValue(stringValue);\n      field6.setStringValue(stringValue);\n      field7.setStringValue(stringValue);\n      field8.setStringValue(stringValue);\n      iw.addDocument(doc);\n    }\n    iw.close();\n    verify(dir);\n    _TestUtil.checkIndex(dir); // for some extra coverage, checkIndex before we forceMerge\n    iwc.setOpenMode(OpenMode.APPEND);\n    IndexWriter iw2 = new IndexWriter(dir, iwc);\n    iw2.forceMerge(1);\n    iw2.close();\n    verify(dir);\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"38061899d760e06a12fe186bc1f09ca9ff0e64a6","date":1376491296,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/lucene41/TestBlockPostingsFormat3#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/lucene41/TestBlockPostingsFormat3#test().mjava","sourceNew":"  // creates 8 fields with different options and does \"duels\" of fields against each other\n  public void test() throws Exception {\n    Directory dir = newDirectory();\n    Analyzer analyzer = new Analyzer(Analyzer.PER_FIELD_REUSE_STRATEGY) {\n      @Override\n      protected TokenStreamComponents createComponents(String fieldName, Reader reader) {\n        Tokenizer tokenizer = new MockTokenizer(reader);\n        if (fieldName.contains(\"payloadsFixed\")) {\n          TokenFilter filter = new MockFixedLengthPayloadFilter(new Random(0), tokenizer, 1);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else if (fieldName.contains(\"payloadsVariable\")) {\n          TokenFilter filter = new MockVariableLengthPayloadFilter(new Random(0), tokenizer);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else {\n          return new TokenStreamComponents(tokenizer);\n        }\n      }\n    };\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer);\n    iwc.setCodec(_TestUtil.alwaysPostingsFormat(new Lucene41PostingsFormat())); \n    // TODO we could actually add more fields implemented with different PFs\n    // or, just put this test into the usual rotation?\n    RandomIndexWriter iw = new RandomIndexWriter(random(), dir, iwc.clone());\n    Document doc = new Document();\n    FieldType docsOnlyType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsOnlyType.setStoreTermVectors(true);\n    docsOnlyType.setIndexOptions(IndexOptions.DOCS_ONLY);\n    \n    FieldType docsAndFreqsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsAndFreqsType.setStoreTermVectors(true);\n    docsAndFreqsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    \n    FieldType positionsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn these on for a cross-check\n    positionsType.setStoreTermVectors(true);\n    positionsType.setStoreTermVectorPositions(true);\n    positionsType.setStoreTermVectorOffsets(true);\n    positionsType.setStoreTermVectorPayloads(true);\n    FieldType offsetsType = new FieldType(positionsType);\n    offsetsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    Field field1 = new Field(\"field1docs\", \"\", docsOnlyType);\n    Field field2 = new Field(\"field2freqs\", \"\", docsAndFreqsType);\n    Field field3 = new Field(\"field3positions\", \"\", positionsType);\n    Field field4 = new Field(\"field4offsets\", \"\", offsetsType);\n    Field field5 = new Field(\"field5payloadsFixed\", \"\", positionsType);\n    Field field6 = new Field(\"field6payloadsVariable\", \"\", positionsType);\n    Field field7 = new Field(\"field7payloadsFixedOffsets\", \"\", offsetsType);\n    Field field8 = new Field(\"field8payloadsVariableOffsets\", \"\", offsetsType);\n    doc.add(field1);\n    doc.add(field2);\n    doc.add(field3);\n    doc.add(field4);\n    doc.add(field5);\n    doc.add(field6);\n    doc.add(field7);\n    doc.add(field8);\n    for (int i = 0; i < MAXDOC; i++) {\n      String stringValue = Integer.toString(i) + \" verycommon \" + English.intToEnglish(i).replace('-', ' ') + \" \" + _TestUtil.randomSimpleString(random());\n      field1.setStringValue(stringValue);\n      field2.setStringValue(stringValue);\n      field3.setStringValue(stringValue);\n      field4.setStringValue(stringValue);\n      field5.setStringValue(stringValue);\n      field6.setStringValue(stringValue);\n      field7.setStringValue(stringValue);\n      field8.setStringValue(stringValue);\n      iw.addDocument(doc);\n    }\n    iw.close();\n    verify(dir);\n    _TestUtil.checkIndex(dir); // for some extra coverage, checkIndex before we forceMerge\n    iwc.setOpenMode(OpenMode.APPEND);\n    IndexWriter iw2 = new IndexWriter(dir, iwc.clone());\n    iw2.forceMerge(1);\n    iw2.close();\n    verify(dir);\n    dir.close();\n  }\n\n","sourceOld":"  // creates 8 fields with different options and does \"duels\" of fields against each other\n  public void test() throws Exception {\n    Directory dir = newDirectory();\n    Analyzer analyzer = new Analyzer(new Analyzer.PerFieldReuseStrategy()) {\n      @Override\n      protected TokenStreamComponents createComponents(String fieldName, Reader reader) {\n        Tokenizer tokenizer = new MockTokenizer(reader);\n        if (fieldName.contains(\"payloadsFixed\")) {\n          TokenFilter filter = new MockFixedLengthPayloadFilter(new Random(0), tokenizer, 1);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else if (fieldName.contains(\"payloadsVariable\")) {\n          TokenFilter filter = new MockVariableLengthPayloadFilter(new Random(0), tokenizer);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else {\n          return new TokenStreamComponents(tokenizer);\n        }\n      }\n    };\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer);\n    iwc.setCodec(_TestUtil.alwaysPostingsFormat(new Lucene41PostingsFormat())); \n    // TODO we could actually add more fields implemented with different PFs\n    // or, just put this test into the usual rotation?\n    RandomIndexWriter iw = new RandomIndexWriter(random(), dir, iwc.clone());\n    Document doc = new Document();\n    FieldType docsOnlyType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsOnlyType.setStoreTermVectors(true);\n    docsOnlyType.setIndexOptions(IndexOptions.DOCS_ONLY);\n    \n    FieldType docsAndFreqsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsAndFreqsType.setStoreTermVectors(true);\n    docsAndFreqsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    \n    FieldType positionsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn these on for a cross-check\n    positionsType.setStoreTermVectors(true);\n    positionsType.setStoreTermVectorPositions(true);\n    positionsType.setStoreTermVectorOffsets(true);\n    positionsType.setStoreTermVectorPayloads(true);\n    FieldType offsetsType = new FieldType(positionsType);\n    offsetsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    Field field1 = new Field(\"field1docs\", \"\", docsOnlyType);\n    Field field2 = new Field(\"field2freqs\", \"\", docsAndFreqsType);\n    Field field3 = new Field(\"field3positions\", \"\", positionsType);\n    Field field4 = new Field(\"field4offsets\", \"\", offsetsType);\n    Field field5 = new Field(\"field5payloadsFixed\", \"\", positionsType);\n    Field field6 = new Field(\"field6payloadsVariable\", \"\", positionsType);\n    Field field7 = new Field(\"field7payloadsFixedOffsets\", \"\", offsetsType);\n    Field field8 = new Field(\"field8payloadsVariableOffsets\", \"\", offsetsType);\n    doc.add(field1);\n    doc.add(field2);\n    doc.add(field3);\n    doc.add(field4);\n    doc.add(field5);\n    doc.add(field6);\n    doc.add(field7);\n    doc.add(field8);\n    for (int i = 0; i < MAXDOC; i++) {\n      String stringValue = Integer.toString(i) + \" verycommon \" + English.intToEnglish(i).replace('-', ' ') + \" \" + _TestUtil.randomSimpleString(random());\n      field1.setStringValue(stringValue);\n      field2.setStringValue(stringValue);\n      field3.setStringValue(stringValue);\n      field4.setStringValue(stringValue);\n      field5.setStringValue(stringValue);\n      field6.setStringValue(stringValue);\n      field7.setStringValue(stringValue);\n      field8.setStringValue(stringValue);\n      iw.addDocument(doc);\n    }\n    iw.close();\n    verify(dir);\n    _TestUtil.checkIndex(dir); // for some extra coverage, checkIndex before we forceMerge\n    iwc.setOpenMode(OpenMode.APPEND);\n    IndexWriter iw2 = new IndexWriter(dir, iwc.clone());\n    iw2.forceMerge(1);\n    iw2.close();\n    verify(dir);\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3dffec77fb8f7d0e9ca4869dddd6af94528b4576","date":1377875202,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/lucene41/TestBlockPostingsFormat3#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/lucene41/TestBlockPostingsFormat3#test().mjava","sourceNew":"  // creates 8 fields with different options and does \"duels\" of fields against each other\n  public void test() throws Exception {\n    Directory dir = newDirectory();\n    Analyzer analyzer = new Analyzer(Analyzer.PER_FIELD_REUSE_STRATEGY) {\n      @Override\n      protected TokenStreamComponents createComponents(String fieldName, Reader reader) {\n        Tokenizer tokenizer = new MockTokenizer(reader);\n        if (fieldName.contains(\"payloadsFixed\")) {\n          TokenFilter filter = new MockFixedLengthPayloadFilter(new Random(0), tokenizer, 1);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else if (fieldName.contains(\"payloadsVariable\")) {\n          TokenFilter filter = new MockVariableLengthPayloadFilter(new Random(0), tokenizer);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else {\n          return new TokenStreamComponents(tokenizer);\n        }\n      }\n    };\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer);\n    iwc.setCodec(_TestUtil.alwaysPostingsFormat(new Lucene41PostingsFormat())); \n    // TODO we could actually add more fields implemented with different PFs\n    // or, just put this test into the usual rotation?\n    RandomIndexWriter iw = new RandomIndexWriter(random(), dir, iwc.clone());\n    Document doc = new Document();\n    FieldType docsOnlyType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsOnlyType.setStoreTermVectors(true);\n    docsOnlyType.setIndexOptions(IndexOptions.DOCS_ONLY);\n    \n    FieldType docsAndFreqsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsAndFreqsType.setStoreTermVectors(true);\n    docsAndFreqsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    \n    FieldType positionsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn these on for a cross-check\n    positionsType.setStoreTermVectors(true);\n    positionsType.setStoreTermVectorPositions(true);\n    positionsType.setStoreTermVectorOffsets(true);\n    positionsType.setStoreTermVectorPayloads(true);\n    FieldType offsetsType = new FieldType(positionsType);\n    offsetsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    Field field1 = new Field(\"field1docs\", \"\", docsOnlyType);\n    Field field2 = new Field(\"field2freqs\", \"\", docsAndFreqsType);\n    Field field3 = new Field(\"field3positions\", \"\", positionsType);\n    Field field4 = new Field(\"field4offsets\", \"\", offsetsType);\n    Field field5 = new Field(\"field5payloadsFixed\", \"\", positionsType);\n    Field field6 = new Field(\"field6payloadsVariable\", \"\", positionsType);\n    Field field7 = new Field(\"field7payloadsFixedOffsets\", \"\", offsetsType);\n    Field field8 = new Field(\"field8payloadsVariableOffsets\", \"\", offsetsType);\n    doc.add(field1);\n    doc.add(field2);\n    doc.add(field3);\n    doc.add(field4);\n    doc.add(field5);\n    doc.add(field6);\n    doc.add(field7);\n    doc.add(field8);\n    for (int i = 0; i < MAXDOC; i++) {\n      String stringValue = Integer.toString(i) + \" verycommon \" + English.intToEnglish(i).replace('-', ' ') + \" \" + _TestUtil.randomSimpleString(random());\n      field1.setStringValue(stringValue);\n      field2.setStringValue(stringValue);\n      field3.setStringValue(stringValue);\n      field4.setStringValue(stringValue);\n      field5.setStringValue(stringValue);\n      field6.setStringValue(stringValue);\n      field7.setStringValue(stringValue);\n      field8.setStringValue(stringValue);\n      iw.addDocument(doc);\n    }\n    iw.close();\n    verify(dir);\n    _TestUtil.checkIndex(dir); // for some extra coverage, checkIndex before we forceMerge\n    iwc.setOpenMode(OpenMode.APPEND);\n    IndexWriter iw2 = new IndexWriter(dir, iwc.clone());\n    iw2.forceMerge(1);\n    iw2.close();\n    verify(dir);\n    dir.close();\n  }\n\n","sourceOld":"  // creates 8 fields with different options and does \"duels\" of fields against each other\n  public void test() throws Exception {\n    Directory dir = newDirectory();\n    Analyzer analyzer = new Analyzer(new Analyzer.PerFieldReuseStrategy()) {\n      @Override\n      protected TokenStreamComponents createComponents(String fieldName, Reader reader) {\n        Tokenizer tokenizer = new MockTokenizer(reader);\n        if (fieldName.contains(\"payloadsFixed\")) {\n          TokenFilter filter = new MockFixedLengthPayloadFilter(new Random(0), tokenizer, 1);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else if (fieldName.contains(\"payloadsVariable\")) {\n          TokenFilter filter = new MockVariableLengthPayloadFilter(new Random(0), tokenizer);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else {\n          return new TokenStreamComponents(tokenizer);\n        }\n      }\n    };\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer);\n    iwc.setCodec(_TestUtil.alwaysPostingsFormat(new Lucene41PostingsFormat())); \n    // TODO we could actually add more fields implemented with different PFs\n    // or, just put this test into the usual rotation?\n    RandomIndexWriter iw = new RandomIndexWriter(random(), dir, iwc.clone());\n    Document doc = new Document();\n    FieldType docsOnlyType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsOnlyType.setStoreTermVectors(true);\n    docsOnlyType.setIndexOptions(IndexOptions.DOCS_ONLY);\n    \n    FieldType docsAndFreqsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsAndFreqsType.setStoreTermVectors(true);\n    docsAndFreqsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    \n    FieldType positionsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn these on for a cross-check\n    positionsType.setStoreTermVectors(true);\n    positionsType.setStoreTermVectorPositions(true);\n    positionsType.setStoreTermVectorOffsets(true);\n    positionsType.setStoreTermVectorPayloads(true);\n    FieldType offsetsType = new FieldType(positionsType);\n    offsetsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    Field field1 = new Field(\"field1docs\", \"\", docsOnlyType);\n    Field field2 = new Field(\"field2freqs\", \"\", docsAndFreqsType);\n    Field field3 = new Field(\"field3positions\", \"\", positionsType);\n    Field field4 = new Field(\"field4offsets\", \"\", offsetsType);\n    Field field5 = new Field(\"field5payloadsFixed\", \"\", positionsType);\n    Field field6 = new Field(\"field6payloadsVariable\", \"\", positionsType);\n    Field field7 = new Field(\"field7payloadsFixedOffsets\", \"\", offsetsType);\n    Field field8 = new Field(\"field8payloadsVariableOffsets\", \"\", offsetsType);\n    doc.add(field1);\n    doc.add(field2);\n    doc.add(field3);\n    doc.add(field4);\n    doc.add(field5);\n    doc.add(field6);\n    doc.add(field7);\n    doc.add(field8);\n    for (int i = 0; i < MAXDOC; i++) {\n      String stringValue = Integer.toString(i) + \" verycommon \" + English.intToEnglish(i).replace('-', ' ') + \" \" + _TestUtil.randomSimpleString(random());\n      field1.setStringValue(stringValue);\n      field2.setStringValue(stringValue);\n      field3.setStringValue(stringValue);\n      field4.setStringValue(stringValue);\n      field5.setStringValue(stringValue);\n      field6.setStringValue(stringValue);\n      field7.setStringValue(stringValue);\n      field8.setStringValue(stringValue);\n      iw.addDocument(doc);\n    }\n    iw.close();\n    verify(dir);\n    _TestUtil.checkIndex(dir); // for some extra coverage, checkIndex before we forceMerge\n    iwc.setOpenMode(OpenMode.APPEND);\n    IndexWriter iw2 = new IndexWriter(dir, iwc.clone());\n    iw2.forceMerge(1);\n    iw2.close();\n    verify(dir);\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae889fd5c8a69f6b5d130d3c895bfa5b04d07338","date":1389274049,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/lucene41/TestBlockPostingsFormat3#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/lucene41/TestBlockPostingsFormat3#test().mjava","sourceNew":"  // creates 8 fields with different options and does \"duels\" of fields against each other\n  public void test() throws Exception {\n    Directory dir = newDirectory();\n    Analyzer analyzer = new Analyzer(Analyzer.PER_FIELD_REUSE_STRATEGY) {\n      @Override\n      protected TokenStreamComponents createComponents(String fieldName) {\n        Tokenizer tokenizer = new MockTokenizer();\n        if (fieldName.contains(\"payloadsFixed\")) {\n          TokenFilter filter = new MockFixedLengthPayloadFilter(new Random(0), tokenizer, 1);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else if (fieldName.contains(\"payloadsVariable\")) {\n          TokenFilter filter = new MockVariableLengthPayloadFilter(new Random(0), tokenizer);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else {\n          return new TokenStreamComponents(tokenizer);\n        }\n      }\n    };\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer);\n    iwc.setCodec(_TestUtil.alwaysPostingsFormat(new Lucene41PostingsFormat())); \n    // TODO we could actually add more fields implemented with different PFs\n    // or, just put this test into the usual rotation?\n    RandomIndexWriter iw = new RandomIndexWriter(random(), dir, iwc.clone());\n    Document doc = new Document();\n    FieldType docsOnlyType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsOnlyType.setStoreTermVectors(true);\n    docsOnlyType.setIndexOptions(IndexOptions.DOCS_ONLY);\n    \n    FieldType docsAndFreqsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsAndFreqsType.setStoreTermVectors(true);\n    docsAndFreqsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    \n    FieldType positionsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn these on for a cross-check\n    positionsType.setStoreTermVectors(true);\n    positionsType.setStoreTermVectorPositions(true);\n    positionsType.setStoreTermVectorOffsets(true);\n    positionsType.setStoreTermVectorPayloads(true);\n    FieldType offsetsType = new FieldType(positionsType);\n    offsetsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    Field field1 = new Field(\"field1docs\", \"\", docsOnlyType);\n    Field field2 = new Field(\"field2freqs\", \"\", docsAndFreqsType);\n    Field field3 = new Field(\"field3positions\", \"\", positionsType);\n    Field field4 = new Field(\"field4offsets\", \"\", offsetsType);\n    Field field5 = new Field(\"field5payloadsFixed\", \"\", positionsType);\n    Field field6 = new Field(\"field6payloadsVariable\", \"\", positionsType);\n    Field field7 = new Field(\"field7payloadsFixedOffsets\", \"\", offsetsType);\n    Field field8 = new Field(\"field8payloadsVariableOffsets\", \"\", offsetsType);\n    doc.add(field1);\n    doc.add(field2);\n    doc.add(field3);\n    doc.add(field4);\n    doc.add(field5);\n    doc.add(field6);\n    doc.add(field7);\n    doc.add(field8);\n    for (int i = 0; i < MAXDOC; i++) {\n      String stringValue = Integer.toString(i) + \" verycommon \" + English.intToEnglish(i).replace('-', ' ') + \" \" + _TestUtil.randomSimpleString(random());\n      field1.setStringValue(stringValue);\n      field2.setStringValue(stringValue);\n      field3.setStringValue(stringValue);\n      field4.setStringValue(stringValue);\n      field5.setStringValue(stringValue);\n      field6.setStringValue(stringValue);\n      field7.setStringValue(stringValue);\n      field8.setStringValue(stringValue);\n      iw.addDocument(doc);\n    }\n    iw.close();\n    verify(dir);\n    _TestUtil.checkIndex(dir); // for some extra coverage, checkIndex before we forceMerge\n    iwc.setOpenMode(OpenMode.APPEND);\n    IndexWriter iw2 = new IndexWriter(dir, iwc.clone());\n    iw2.forceMerge(1);\n    iw2.close();\n    verify(dir);\n    dir.close();\n  }\n\n","sourceOld":"  // creates 8 fields with different options and does \"duels\" of fields against each other\n  public void test() throws Exception {\n    Directory dir = newDirectory();\n    Analyzer analyzer = new Analyzer(Analyzer.PER_FIELD_REUSE_STRATEGY) {\n      @Override\n      protected TokenStreamComponents createComponents(String fieldName, Reader reader) {\n        Tokenizer tokenizer = new MockTokenizer(reader);\n        if (fieldName.contains(\"payloadsFixed\")) {\n          TokenFilter filter = new MockFixedLengthPayloadFilter(new Random(0), tokenizer, 1);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else if (fieldName.contains(\"payloadsVariable\")) {\n          TokenFilter filter = new MockVariableLengthPayloadFilter(new Random(0), tokenizer);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else {\n          return new TokenStreamComponents(tokenizer);\n        }\n      }\n    };\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer);\n    iwc.setCodec(_TestUtil.alwaysPostingsFormat(new Lucene41PostingsFormat())); \n    // TODO we could actually add more fields implemented with different PFs\n    // or, just put this test into the usual rotation?\n    RandomIndexWriter iw = new RandomIndexWriter(random(), dir, iwc.clone());\n    Document doc = new Document();\n    FieldType docsOnlyType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsOnlyType.setStoreTermVectors(true);\n    docsOnlyType.setIndexOptions(IndexOptions.DOCS_ONLY);\n    \n    FieldType docsAndFreqsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsAndFreqsType.setStoreTermVectors(true);\n    docsAndFreqsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    \n    FieldType positionsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn these on for a cross-check\n    positionsType.setStoreTermVectors(true);\n    positionsType.setStoreTermVectorPositions(true);\n    positionsType.setStoreTermVectorOffsets(true);\n    positionsType.setStoreTermVectorPayloads(true);\n    FieldType offsetsType = new FieldType(positionsType);\n    offsetsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    Field field1 = new Field(\"field1docs\", \"\", docsOnlyType);\n    Field field2 = new Field(\"field2freqs\", \"\", docsAndFreqsType);\n    Field field3 = new Field(\"field3positions\", \"\", positionsType);\n    Field field4 = new Field(\"field4offsets\", \"\", offsetsType);\n    Field field5 = new Field(\"field5payloadsFixed\", \"\", positionsType);\n    Field field6 = new Field(\"field6payloadsVariable\", \"\", positionsType);\n    Field field7 = new Field(\"field7payloadsFixedOffsets\", \"\", offsetsType);\n    Field field8 = new Field(\"field8payloadsVariableOffsets\", \"\", offsetsType);\n    doc.add(field1);\n    doc.add(field2);\n    doc.add(field3);\n    doc.add(field4);\n    doc.add(field5);\n    doc.add(field6);\n    doc.add(field7);\n    doc.add(field8);\n    for (int i = 0; i < MAXDOC; i++) {\n      String stringValue = Integer.toString(i) + \" verycommon \" + English.intToEnglish(i).replace('-', ' ') + \" \" + _TestUtil.randomSimpleString(random());\n      field1.setStringValue(stringValue);\n      field2.setStringValue(stringValue);\n      field3.setStringValue(stringValue);\n      field4.setStringValue(stringValue);\n      field5.setStringValue(stringValue);\n      field6.setStringValue(stringValue);\n      field7.setStringValue(stringValue);\n      field8.setStringValue(stringValue);\n      iw.addDocument(doc);\n    }\n    iw.close();\n    verify(dir);\n    _TestUtil.checkIndex(dir); // for some extra coverage, checkIndex before we forceMerge\n    iwc.setOpenMode(OpenMode.APPEND);\n    IndexWriter iw2 = new IndexWriter(dir, iwc.clone());\n    iw2.forceMerge(1);\n    iw2.close();\n    verify(dir);\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/lucene41/TestBlockPostingsFormat3#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/lucene41/TestBlockPostingsFormat3#test().mjava","sourceNew":"  // creates 8 fields with different options and does \"duels\" of fields against each other\n  public void test() throws Exception {\n    Directory dir = newDirectory();\n    Analyzer analyzer = new Analyzer(Analyzer.PER_FIELD_REUSE_STRATEGY) {\n      @Override\n      protected TokenStreamComponents createComponents(String fieldName) {\n        Tokenizer tokenizer = new MockTokenizer();\n        if (fieldName.contains(\"payloadsFixed\")) {\n          TokenFilter filter = new MockFixedLengthPayloadFilter(new Random(0), tokenizer, 1);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else if (fieldName.contains(\"payloadsVariable\")) {\n          TokenFilter filter = new MockVariableLengthPayloadFilter(new Random(0), tokenizer);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else {\n          return new TokenStreamComponents(tokenizer);\n        }\n      }\n    };\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer);\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new Lucene41PostingsFormat()));\n    // TODO we could actually add more fields implemented with different PFs\n    // or, just put this test into the usual rotation?\n    RandomIndexWriter iw = new RandomIndexWriter(random(), dir, iwc.clone());\n    Document doc = new Document();\n    FieldType docsOnlyType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsOnlyType.setStoreTermVectors(true);\n    docsOnlyType.setIndexOptions(IndexOptions.DOCS_ONLY);\n    \n    FieldType docsAndFreqsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsAndFreqsType.setStoreTermVectors(true);\n    docsAndFreqsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    \n    FieldType positionsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn these on for a cross-check\n    positionsType.setStoreTermVectors(true);\n    positionsType.setStoreTermVectorPositions(true);\n    positionsType.setStoreTermVectorOffsets(true);\n    positionsType.setStoreTermVectorPayloads(true);\n    FieldType offsetsType = new FieldType(positionsType);\n    offsetsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    Field field1 = new Field(\"field1docs\", \"\", docsOnlyType);\n    Field field2 = new Field(\"field2freqs\", \"\", docsAndFreqsType);\n    Field field3 = new Field(\"field3positions\", \"\", positionsType);\n    Field field4 = new Field(\"field4offsets\", \"\", offsetsType);\n    Field field5 = new Field(\"field5payloadsFixed\", \"\", positionsType);\n    Field field6 = new Field(\"field6payloadsVariable\", \"\", positionsType);\n    Field field7 = new Field(\"field7payloadsFixedOffsets\", \"\", offsetsType);\n    Field field8 = new Field(\"field8payloadsVariableOffsets\", \"\", offsetsType);\n    doc.add(field1);\n    doc.add(field2);\n    doc.add(field3);\n    doc.add(field4);\n    doc.add(field5);\n    doc.add(field6);\n    doc.add(field7);\n    doc.add(field8);\n    for (int i = 0; i < MAXDOC; i++) {\n      String stringValue = Integer.toString(i) + \" verycommon \" + English.intToEnglish(i).replace('-', ' ') + \" \" + TestUtil.randomSimpleString(random());\n      field1.setStringValue(stringValue);\n      field2.setStringValue(stringValue);\n      field3.setStringValue(stringValue);\n      field4.setStringValue(stringValue);\n      field5.setStringValue(stringValue);\n      field6.setStringValue(stringValue);\n      field7.setStringValue(stringValue);\n      field8.setStringValue(stringValue);\n      iw.addDocument(doc);\n    }\n    iw.close();\n    verify(dir);\n    TestUtil.checkIndex(dir); // for some extra coverage, checkIndex before we forceMerge\n    iwc.setOpenMode(OpenMode.APPEND);\n    IndexWriter iw2 = new IndexWriter(dir, iwc.clone());\n    iw2.forceMerge(1);\n    iw2.close();\n    verify(dir);\n    dir.close();\n  }\n\n","sourceOld":"  // creates 8 fields with different options and does \"duels\" of fields against each other\n  public void test() throws Exception {\n    Directory dir = newDirectory();\n    Analyzer analyzer = new Analyzer(Analyzer.PER_FIELD_REUSE_STRATEGY) {\n      @Override\n      protected TokenStreamComponents createComponents(String fieldName) {\n        Tokenizer tokenizer = new MockTokenizer();\n        if (fieldName.contains(\"payloadsFixed\")) {\n          TokenFilter filter = new MockFixedLengthPayloadFilter(new Random(0), tokenizer, 1);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else if (fieldName.contains(\"payloadsVariable\")) {\n          TokenFilter filter = new MockVariableLengthPayloadFilter(new Random(0), tokenizer);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else {\n          return new TokenStreamComponents(tokenizer);\n        }\n      }\n    };\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer);\n    iwc.setCodec(_TestUtil.alwaysPostingsFormat(new Lucene41PostingsFormat())); \n    // TODO we could actually add more fields implemented with different PFs\n    // or, just put this test into the usual rotation?\n    RandomIndexWriter iw = new RandomIndexWriter(random(), dir, iwc.clone());\n    Document doc = new Document();\n    FieldType docsOnlyType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsOnlyType.setStoreTermVectors(true);\n    docsOnlyType.setIndexOptions(IndexOptions.DOCS_ONLY);\n    \n    FieldType docsAndFreqsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsAndFreqsType.setStoreTermVectors(true);\n    docsAndFreqsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    \n    FieldType positionsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn these on for a cross-check\n    positionsType.setStoreTermVectors(true);\n    positionsType.setStoreTermVectorPositions(true);\n    positionsType.setStoreTermVectorOffsets(true);\n    positionsType.setStoreTermVectorPayloads(true);\n    FieldType offsetsType = new FieldType(positionsType);\n    offsetsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    Field field1 = new Field(\"field1docs\", \"\", docsOnlyType);\n    Field field2 = new Field(\"field2freqs\", \"\", docsAndFreqsType);\n    Field field3 = new Field(\"field3positions\", \"\", positionsType);\n    Field field4 = new Field(\"field4offsets\", \"\", offsetsType);\n    Field field5 = new Field(\"field5payloadsFixed\", \"\", positionsType);\n    Field field6 = new Field(\"field6payloadsVariable\", \"\", positionsType);\n    Field field7 = new Field(\"field7payloadsFixedOffsets\", \"\", offsetsType);\n    Field field8 = new Field(\"field8payloadsVariableOffsets\", \"\", offsetsType);\n    doc.add(field1);\n    doc.add(field2);\n    doc.add(field3);\n    doc.add(field4);\n    doc.add(field5);\n    doc.add(field6);\n    doc.add(field7);\n    doc.add(field8);\n    for (int i = 0; i < MAXDOC; i++) {\n      String stringValue = Integer.toString(i) + \" verycommon \" + English.intToEnglish(i).replace('-', ' ') + \" \" + _TestUtil.randomSimpleString(random());\n      field1.setStringValue(stringValue);\n      field2.setStringValue(stringValue);\n      field3.setStringValue(stringValue);\n      field4.setStringValue(stringValue);\n      field5.setStringValue(stringValue);\n      field6.setStringValue(stringValue);\n      field7.setStringValue(stringValue);\n      field8.setStringValue(stringValue);\n      iw.addDocument(doc);\n    }\n    iw.close();\n    verify(dir);\n    _TestUtil.checkIndex(dir); // for some extra coverage, checkIndex before we forceMerge\n    iwc.setOpenMode(OpenMode.APPEND);\n    IndexWriter iw2 = new IndexWriter(dir, iwc.clone());\n    iw2.forceMerge(1);\n    iw2.close();\n    verify(dir);\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae14298f4eec6d5faee6a149f88ba57d14a6f21a","date":1396971290,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/lucene41/TestBlockPostingsFormat3#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/lucene41/TestBlockPostingsFormat3#test().mjava","sourceNew":"  // creates 8 fields with different options and does \"duels\" of fields against each other\n  public void test() throws Exception {\n    Directory dir = newDirectory();\n    Analyzer analyzer = new Analyzer(Analyzer.PER_FIELD_REUSE_STRATEGY) {\n      @Override\n      protected TokenStreamComponents createComponents(String fieldName) {\n        Tokenizer tokenizer = new MockTokenizer();\n        if (fieldName.contains(\"payloadsFixed\")) {\n          TokenFilter filter = new MockFixedLengthPayloadFilter(new Random(0), tokenizer, 1);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else if (fieldName.contains(\"payloadsVariable\")) {\n          TokenFilter filter = new MockVariableLengthPayloadFilter(new Random(0), tokenizer);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else {\n          return new TokenStreamComponents(tokenizer);\n        }\n      }\n    };\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer);\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new Lucene41PostingsFormat()));\n    // TODO we could actually add more fields implemented with different PFs\n    // or, just put this test into the usual rotation?\n    RandomIndexWriter iw = new RandomIndexWriter(random(), dir, iwc.clone());\n    Document doc = new Document();\n    FieldType docsOnlyType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsOnlyType.setStoreTermVectors(true);\n    docsOnlyType.setIndexOptions(IndexOptions.DOCS_ONLY);\n    \n    FieldType docsAndFreqsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsAndFreqsType.setStoreTermVectors(true);\n    docsAndFreqsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    \n    FieldType positionsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn these on for a cross-check\n    positionsType.setStoreTermVectors(true);\n    positionsType.setStoreTermVectorPositions(true);\n    positionsType.setStoreTermVectorOffsets(true);\n    positionsType.setStoreTermVectorPayloads(true);\n    FieldType offsetsType = new FieldType(positionsType);\n    offsetsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    Field field1 = new Field(\"field1docs\", \"\", docsOnlyType);\n    Field field2 = new Field(\"field2freqs\", \"\", docsAndFreqsType);\n    Field field3 = new Field(\"field3positions\", \"\", positionsType);\n    Field field4 = new Field(\"field4offsets\", \"\", offsetsType);\n    Field field5 = new Field(\"field5payloadsFixed\", \"\", positionsType);\n    Field field6 = new Field(\"field6payloadsVariable\", \"\", positionsType);\n    Field field7 = new Field(\"field7payloadsFixedOffsets\", \"\", offsetsType);\n    Field field8 = new Field(\"field8payloadsVariableOffsets\", \"\", offsetsType);\n    doc.add(field1);\n    doc.add(field2);\n    doc.add(field3);\n    doc.add(field4);\n    doc.add(field5);\n    doc.add(field6);\n    doc.add(field7);\n    doc.add(field8);\n    for (int i = 0; i < MAXDOC; i++) {\n      String stringValue = Integer.toString(i) + \" verycommon \" + English.intToEnglish(i).replace('-', ' ') + \" \" + TestUtil.randomSimpleString(random());\n      field1.setStringValue(stringValue);\n      field2.setStringValue(stringValue);\n      field3.setStringValue(stringValue);\n      field4.setStringValue(stringValue);\n      field5.setStringValue(stringValue);\n      field6.setStringValue(stringValue);\n      field7.setStringValue(stringValue);\n      field8.setStringValue(stringValue);\n      iw.addDocument(doc);\n    }\n    iw.shutdown();\n    verify(dir);\n    TestUtil.checkIndex(dir); // for some extra coverage, checkIndex before we forceMerge\n    iwc.setOpenMode(OpenMode.APPEND);\n    IndexWriter iw2 = new IndexWriter(dir, iwc.clone());\n    iw2.forceMerge(1);\n    iw2.shutdown();\n    verify(dir);\n    dir.close();\n  }\n\n","sourceOld":"  // creates 8 fields with different options and does \"duels\" of fields against each other\n  public void test() throws Exception {\n    Directory dir = newDirectory();\n    Analyzer analyzer = new Analyzer(Analyzer.PER_FIELD_REUSE_STRATEGY) {\n      @Override\n      protected TokenStreamComponents createComponents(String fieldName) {\n        Tokenizer tokenizer = new MockTokenizer();\n        if (fieldName.contains(\"payloadsFixed\")) {\n          TokenFilter filter = new MockFixedLengthPayloadFilter(new Random(0), tokenizer, 1);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else if (fieldName.contains(\"payloadsVariable\")) {\n          TokenFilter filter = new MockVariableLengthPayloadFilter(new Random(0), tokenizer);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else {\n          return new TokenStreamComponents(tokenizer);\n        }\n      }\n    };\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer);\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new Lucene41PostingsFormat()));\n    // TODO we could actually add more fields implemented with different PFs\n    // or, just put this test into the usual rotation?\n    RandomIndexWriter iw = new RandomIndexWriter(random(), dir, iwc.clone());\n    Document doc = new Document();\n    FieldType docsOnlyType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsOnlyType.setStoreTermVectors(true);\n    docsOnlyType.setIndexOptions(IndexOptions.DOCS_ONLY);\n    \n    FieldType docsAndFreqsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsAndFreqsType.setStoreTermVectors(true);\n    docsAndFreqsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    \n    FieldType positionsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn these on for a cross-check\n    positionsType.setStoreTermVectors(true);\n    positionsType.setStoreTermVectorPositions(true);\n    positionsType.setStoreTermVectorOffsets(true);\n    positionsType.setStoreTermVectorPayloads(true);\n    FieldType offsetsType = new FieldType(positionsType);\n    offsetsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    Field field1 = new Field(\"field1docs\", \"\", docsOnlyType);\n    Field field2 = new Field(\"field2freqs\", \"\", docsAndFreqsType);\n    Field field3 = new Field(\"field3positions\", \"\", positionsType);\n    Field field4 = new Field(\"field4offsets\", \"\", offsetsType);\n    Field field5 = new Field(\"field5payloadsFixed\", \"\", positionsType);\n    Field field6 = new Field(\"field6payloadsVariable\", \"\", positionsType);\n    Field field7 = new Field(\"field7payloadsFixedOffsets\", \"\", offsetsType);\n    Field field8 = new Field(\"field8payloadsVariableOffsets\", \"\", offsetsType);\n    doc.add(field1);\n    doc.add(field2);\n    doc.add(field3);\n    doc.add(field4);\n    doc.add(field5);\n    doc.add(field6);\n    doc.add(field7);\n    doc.add(field8);\n    for (int i = 0; i < MAXDOC; i++) {\n      String stringValue = Integer.toString(i) + \" verycommon \" + English.intToEnglish(i).replace('-', ' ') + \" \" + TestUtil.randomSimpleString(random());\n      field1.setStringValue(stringValue);\n      field2.setStringValue(stringValue);\n      field3.setStringValue(stringValue);\n      field4.setStringValue(stringValue);\n      field5.setStringValue(stringValue);\n      field6.setStringValue(stringValue);\n      field7.setStringValue(stringValue);\n      field8.setStringValue(stringValue);\n      iw.addDocument(doc);\n    }\n    iw.close();\n    verify(dir);\n    TestUtil.checkIndex(dir); // for some extra coverage, checkIndex before we forceMerge\n    iwc.setOpenMode(OpenMode.APPEND);\n    IndexWriter iw2 = new IndexWriter(dir, iwc.clone());\n    iw2.forceMerge(1);\n    iw2.close();\n    verify(dir);\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cfc45818441587d8004ff1a119fb60ac9ecb9a14","date":1401437797,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/lucene41/TestBlockPostingsFormat3#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/lucene41/TestBlockPostingsFormat3#test().mjava","sourceNew":"  // creates 8 fields with different options and does \"duels\" of fields against each other\n  public void test() throws Exception {\n    Directory dir = newDirectory();\n    Analyzer analyzer = new Analyzer(Analyzer.PER_FIELD_REUSE_STRATEGY) {\n      @Override\n      protected TokenStreamComponents createComponents(String fieldName) {\n        Tokenizer tokenizer = new MockTokenizer();\n        if (fieldName.contains(\"payloadsFixed\")) {\n          TokenFilter filter = new MockFixedLengthPayloadFilter(new Random(0), tokenizer, 1);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else if (fieldName.contains(\"payloadsVariable\")) {\n          TokenFilter filter = new MockVariableLengthPayloadFilter(new Random(0), tokenizer);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else {\n          return new TokenStreamComponents(tokenizer);\n        }\n      }\n    };\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer);\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new Lucene41PostingsFormat()));\n    // TODO we could actually add more fields implemented with different PFs\n    // or, just put this test into the usual rotation?\n    RandomIndexWriter iw = new RandomIndexWriter(random(), dir, iwc);\n    Document doc = new Document();\n    FieldType docsOnlyType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsOnlyType.setStoreTermVectors(true);\n    docsOnlyType.setIndexOptions(IndexOptions.DOCS_ONLY);\n    \n    FieldType docsAndFreqsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsAndFreqsType.setStoreTermVectors(true);\n    docsAndFreqsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    \n    FieldType positionsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn these on for a cross-check\n    positionsType.setStoreTermVectors(true);\n    positionsType.setStoreTermVectorPositions(true);\n    positionsType.setStoreTermVectorOffsets(true);\n    positionsType.setStoreTermVectorPayloads(true);\n    FieldType offsetsType = new FieldType(positionsType);\n    offsetsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    Field field1 = new Field(\"field1docs\", \"\", docsOnlyType);\n    Field field2 = new Field(\"field2freqs\", \"\", docsAndFreqsType);\n    Field field3 = new Field(\"field3positions\", \"\", positionsType);\n    Field field4 = new Field(\"field4offsets\", \"\", offsetsType);\n    Field field5 = new Field(\"field5payloadsFixed\", \"\", positionsType);\n    Field field6 = new Field(\"field6payloadsVariable\", \"\", positionsType);\n    Field field7 = new Field(\"field7payloadsFixedOffsets\", \"\", offsetsType);\n    Field field8 = new Field(\"field8payloadsVariableOffsets\", \"\", offsetsType);\n    doc.add(field1);\n    doc.add(field2);\n    doc.add(field3);\n    doc.add(field4);\n    doc.add(field5);\n    doc.add(field6);\n    doc.add(field7);\n    doc.add(field8);\n    for (int i = 0; i < MAXDOC; i++) {\n      String stringValue = Integer.toString(i) + \" verycommon \" + English.intToEnglish(i).replace('-', ' ') + \" \" + TestUtil.randomSimpleString(random());\n      field1.setStringValue(stringValue);\n      field2.setStringValue(stringValue);\n      field3.setStringValue(stringValue);\n      field4.setStringValue(stringValue);\n      field5.setStringValue(stringValue);\n      field6.setStringValue(stringValue);\n      field7.setStringValue(stringValue);\n      field8.setStringValue(stringValue);\n      iw.addDocument(doc);\n    }\n    iw.shutdown();\n    verify(dir);\n    TestUtil.checkIndex(dir); // for some extra coverage, checkIndex before we forceMerge\n    iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer);\n    iwc.setOpenMode(OpenMode.APPEND);\n    IndexWriter iw2 = new IndexWriter(dir, iwc);\n    iw2.forceMerge(1);\n    iw2.shutdown();\n    verify(dir);\n    dir.close();\n  }\n\n","sourceOld":"  // creates 8 fields with different options and does \"duels\" of fields against each other\n  public void test() throws Exception {\n    Directory dir = newDirectory();\n    Analyzer analyzer = new Analyzer(Analyzer.PER_FIELD_REUSE_STRATEGY) {\n      @Override\n      protected TokenStreamComponents createComponents(String fieldName) {\n        Tokenizer tokenizer = new MockTokenizer();\n        if (fieldName.contains(\"payloadsFixed\")) {\n          TokenFilter filter = new MockFixedLengthPayloadFilter(new Random(0), tokenizer, 1);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else if (fieldName.contains(\"payloadsVariable\")) {\n          TokenFilter filter = new MockVariableLengthPayloadFilter(new Random(0), tokenizer);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else {\n          return new TokenStreamComponents(tokenizer);\n        }\n      }\n    };\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer);\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new Lucene41PostingsFormat()));\n    // TODO we could actually add more fields implemented with different PFs\n    // or, just put this test into the usual rotation?\n    RandomIndexWriter iw = new RandomIndexWriter(random(), dir, iwc.clone());\n    Document doc = new Document();\n    FieldType docsOnlyType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsOnlyType.setStoreTermVectors(true);\n    docsOnlyType.setIndexOptions(IndexOptions.DOCS_ONLY);\n    \n    FieldType docsAndFreqsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsAndFreqsType.setStoreTermVectors(true);\n    docsAndFreqsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    \n    FieldType positionsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn these on for a cross-check\n    positionsType.setStoreTermVectors(true);\n    positionsType.setStoreTermVectorPositions(true);\n    positionsType.setStoreTermVectorOffsets(true);\n    positionsType.setStoreTermVectorPayloads(true);\n    FieldType offsetsType = new FieldType(positionsType);\n    offsetsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    Field field1 = new Field(\"field1docs\", \"\", docsOnlyType);\n    Field field2 = new Field(\"field2freqs\", \"\", docsAndFreqsType);\n    Field field3 = new Field(\"field3positions\", \"\", positionsType);\n    Field field4 = new Field(\"field4offsets\", \"\", offsetsType);\n    Field field5 = new Field(\"field5payloadsFixed\", \"\", positionsType);\n    Field field6 = new Field(\"field6payloadsVariable\", \"\", positionsType);\n    Field field7 = new Field(\"field7payloadsFixedOffsets\", \"\", offsetsType);\n    Field field8 = new Field(\"field8payloadsVariableOffsets\", \"\", offsetsType);\n    doc.add(field1);\n    doc.add(field2);\n    doc.add(field3);\n    doc.add(field4);\n    doc.add(field5);\n    doc.add(field6);\n    doc.add(field7);\n    doc.add(field8);\n    for (int i = 0; i < MAXDOC; i++) {\n      String stringValue = Integer.toString(i) + \" verycommon \" + English.intToEnglish(i).replace('-', ' ') + \" \" + TestUtil.randomSimpleString(random());\n      field1.setStringValue(stringValue);\n      field2.setStringValue(stringValue);\n      field3.setStringValue(stringValue);\n      field4.setStringValue(stringValue);\n      field5.setStringValue(stringValue);\n      field6.setStringValue(stringValue);\n      field7.setStringValue(stringValue);\n      field8.setStringValue(stringValue);\n      iw.addDocument(doc);\n    }\n    iw.shutdown();\n    verify(dir);\n    TestUtil.checkIndex(dir); // for some extra coverage, checkIndex before we forceMerge\n    iwc.setOpenMode(OpenMode.APPEND);\n    IndexWriter iw2 = new IndexWriter(dir, iwc.clone());\n    iw2.forceMerge(1);\n    iw2.shutdown();\n    verify(dir);\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9aafa6ae784e45294cc6d2beb96ad0e5a7a5ce22","date":1401440313,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/lucene41/TestBlockPostingsFormat3#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/lucene41/TestBlockPostingsFormat3#test().mjava","sourceNew":"  // creates 8 fields with different options and does \"duels\" of fields against each other\n  public void test() throws Exception {\n    Directory dir = newDirectory();\n    Analyzer analyzer = new Analyzer(Analyzer.PER_FIELD_REUSE_STRATEGY) {\n      @Override\n      protected TokenStreamComponents createComponents(String fieldName) {\n        Tokenizer tokenizer = new MockTokenizer();\n        if (fieldName.contains(\"payloadsFixed\")) {\n          TokenFilter filter = new MockFixedLengthPayloadFilter(new Random(0), tokenizer, 1);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else if (fieldName.contains(\"payloadsVariable\")) {\n          TokenFilter filter = new MockVariableLengthPayloadFilter(new Random(0), tokenizer);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else {\n          return new TokenStreamComponents(tokenizer);\n        }\n      }\n    };\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer);\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new Lucene41PostingsFormat()));\n    // TODO we could actually add more fields implemented with different PFs\n    // or, just put this test into the usual rotation?\n    RandomIndexWriter iw = new RandomIndexWriter(random(), dir, iwc);\n    Document doc = new Document();\n    FieldType docsOnlyType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsOnlyType.setStoreTermVectors(true);\n    docsOnlyType.setIndexOptions(IndexOptions.DOCS_ONLY);\n    \n    FieldType docsAndFreqsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsAndFreqsType.setStoreTermVectors(true);\n    docsAndFreqsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    \n    FieldType positionsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn these on for a cross-check\n    positionsType.setStoreTermVectors(true);\n    positionsType.setStoreTermVectorPositions(true);\n    positionsType.setStoreTermVectorOffsets(true);\n    positionsType.setStoreTermVectorPayloads(true);\n    FieldType offsetsType = new FieldType(positionsType);\n    offsetsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    Field field1 = new Field(\"field1docs\", \"\", docsOnlyType);\n    Field field2 = new Field(\"field2freqs\", \"\", docsAndFreqsType);\n    Field field3 = new Field(\"field3positions\", \"\", positionsType);\n    Field field4 = new Field(\"field4offsets\", \"\", offsetsType);\n    Field field5 = new Field(\"field5payloadsFixed\", \"\", positionsType);\n    Field field6 = new Field(\"field6payloadsVariable\", \"\", positionsType);\n    Field field7 = new Field(\"field7payloadsFixedOffsets\", \"\", offsetsType);\n    Field field8 = new Field(\"field8payloadsVariableOffsets\", \"\", offsetsType);\n    doc.add(field1);\n    doc.add(field2);\n    doc.add(field3);\n    doc.add(field4);\n    doc.add(field5);\n    doc.add(field6);\n    doc.add(field7);\n    doc.add(field8);\n    for (int i = 0; i < MAXDOC; i++) {\n      String stringValue = Integer.toString(i) + \" verycommon \" + English.intToEnglish(i).replace('-', ' ') + \" \" + TestUtil.randomSimpleString(random());\n      field1.setStringValue(stringValue);\n      field2.setStringValue(stringValue);\n      field3.setStringValue(stringValue);\n      field4.setStringValue(stringValue);\n      field5.setStringValue(stringValue);\n      field6.setStringValue(stringValue);\n      field7.setStringValue(stringValue);\n      field8.setStringValue(stringValue);\n      iw.addDocument(doc);\n    }\n    iw.shutdown();\n    verify(dir);\n    TestUtil.checkIndex(dir); // for some extra coverage, checkIndex before we forceMerge\n    iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer);\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new Lucene41PostingsFormat()));\n    iwc.setOpenMode(OpenMode.APPEND);\n    IndexWriter iw2 = new IndexWriter(dir, iwc);\n    iw2.forceMerge(1);\n    iw2.shutdown();\n    verify(dir);\n    dir.close();\n  }\n\n","sourceOld":"  // creates 8 fields with different options and does \"duels\" of fields against each other\n  public void test() throws Exception {\n    Directory dir = newDirectory();\n    Analyzer analyzer = new Analyzer(Analyzer.PER_FIELD_REUSE_STRATEGY) {\n      @Override\n      protected TokenStreamComponents createComponents(String fieldName) {\n        Tokenizer tokenizer = new MockTokenizer();\n        if (fieldName.contains(\"payloadsFixed\")) {\n          TokenFilter filter = new MockFixedLengthPayloadFilter(new Random(0), tokenizer, 1);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else if (fieldName.contains(\"payloadsVariable\")) {\n          TokenFilter filter = new MockVariableLengthPayloadFilter(new Random(0), tokenizer);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else {\n          return new TokenStreamComponents(tokenizer);\n        }\n      }\n    };\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer);\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new Lucene41PostingsFormat()));\n    // TODO we could actually add more fields implemented with different PFs\n    // or, just put this test into the usual rotation?\n    RandomIndexWriter iw = new RandomIndexWriter(random(), dir, iwc);\n    Document doc = new Document();\n    FieldType docsOnlyType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsOnlyType.setStoreTermVectors(true);\n    docsOnlyType.setIndexOptions(IndexOptions.DOCS_ONLY);\n    \n    FieldType docsAndFreqsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsAndFreqsType.setStoreTermVectors(true);\n    docsAndFreqsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    \n    FieldType positionsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn these on for a cross-check\n    positionsType.setStoreTermVectors(true);\n    positionsType.setStoreTermVectorPositions(true);\n    positionsType.setStoreTermVectorOffsets(true);\n    positionsType.setStoreTermVectorPayloads(true);\n    FieldType offsetsType = new FieldType(positionsType);\n    offsetsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    Field field1 = new Field(\"field1docs\", \"\", docsOnlyType);\n    Field field2 = new Field(\"field2freqs\", \"\", docsAndFreqsType);\n    Field field3 = new Field(\"field3positions\", \"\", positionsType);\n    Field field4 = new Field(\"field4offsets\", \"\", offsetsType);\n    Field field5 = new Field(\"field5payloadsFixed\", \"\", positionsType);\n    Field field6 = new Field(\"field6payloadsVariable\", \"\", positionsType);\n    Field field7 = new Field(\"field7payloadsFixedOffsets\", \"\", offsetsType);\n    Field field8 = new Field(\"field8payloadsVariableOffsets\", \"\", offsetsType);\n    doc.add(field1);\n    doc.add(field2);\n    doc.add(field3);\n    doc.add(field4);\n    doc.add(field5);\n    doc.add(field6);\n    doc.add(field7);\n    doc.add(field8);\n    for (int i = 0; i < MAXDOC; i++) {\n      String stringValue = Integer.toString(i) + \" verycommon \" + English.intToEnglish(i).replace('-', ' ') + \" \" + TestUtil.randomSimpleString(random());\n      field1.setStringValue(stringValue);\n      field2.setStringValue(stringValue);\n      field3.setStringValue(stringValue);\n      field4.setStringValue(stringValue);\n      field5.setStringValue(stringValue);\n      field6.setStringValue(stringValue);\n      field7.setStringValue(stringValue);\n      field8.setStringValue(stringValue);\n      iw.addDocument(doc);\n    }\n    iw.shutdown();\n    verify(dir);\n    TestUtil.checkIndex(dir); // for some extra coverage, checkIndex before we forceMerge\n    iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer);\n    iwc.setOpenMode(OpenMode.APPEND);\n    IndexWriter iw2 = new IndexWriter(dir, iwc);\n    iw2.forceMerge(1);\n    iw2.shutdown();\n    verify(dir);\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e","date":1406737224,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/lucene41/TestBlockPostingsFormat3#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/lucene41/TestBlockPostingsFormat3#test().mjava","sourceNew":"  // creates 8 fields with different options and does \"duels\" of fields against each other\n  public void test() throws Exception {\n    Directory dir = newDirectory();\n    Analyzer analyzer = new Analyzer(Analyzer.PER_FIELD_REUSE_STRATEGY) {\n      @Override\n      protected TokenStreamComponents createComponents(String fieldName) {\n        Tokenizer tokenizer = new MockTokenizer();\n        if (fieldName.contains(\"payloadsFixed\")) {\n          TokenFilter filter = new MockFixedLengthPayloadFilter(new Random(0), tokenizer, 1);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else if (fieldName.contains(\"payloadsVariable\")) {\n          TokenFilter filter = new MockVariableLengthPayloadFilter(new Random(0), tokenizer);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else {\n          return new TokenStreamComponents(tokenizer);\n        }\n      }\n    };\n    IndexWriterConfig iwc = newIndexWriterConfig(analyzer);\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new Lucene41PostingsFormat()));\n    // TODO we could actually add more fields implemented with different PFs\n    // or, just put this test into the usual rotation?\n    RandomIndexWriter iw = new RandomIndexWriter(random(), dir, iwc);\n    Document doc = new Document();\n    FieldType docsOnlyType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsOnlyType.setStoreTermVectors(true);\n    docsOnlyType.setIndexOptions(IndexOptions.DOCS_ONLY);\n    \n    FieldType docsAndFreqsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsAndFreqsType.setStoreTermVectors(true);\n    docsAndFreqsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    \n    FieldType positionsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn these on for a cross-check\n    positionsType.setStoreTermVectors(true);\n    positionsType.setStoreTermVectorPositions(true);\n    positionsType.setStoreTermVectorOffsets(true);\n    positionsType.setStoreTermVectorPayloads(true);\n    FieldType offsetsType = new FieldType(positionsType);\n    offsetsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    Field field1 = new Field(\"field1docs\", \"\", docsOnlyType);\n    Field field2 = new Field(\"field2freqs\", \"\", docsAndFreqsType);\n    Field field3 = new Field(\"field3positions\", \"\", positionsType);\n    Field field4 = new Field(\"field4offsets\", \"\", offsetsType);\n    Field field5 = new Field(\"field5payloadsFixed\", \"\", positionsType);\n    Field field6 = new Field(\"field6payloadsVariable\", \"\", positionsType);\n    Field field7 = new Field(\"field7payloadsFixedOffsets\", \"\", offsetsType);\n    Field field8 = new Field(\"field8payloadsVariableOffsets\", \"\", offsetsType);\n    doc.add(field1);\n    doc.add(field2);\n    doc.add(field3);\n    doc.add(field4);\n    doc.add(field5);\n    doc.add(field6);\n    doc.add(field7);\n    doc.add(field8);\n    for (int i = 0; i < MAXDOC; i++) {\n      String stringValue = Integer.toString(i) + \" verycommon \" + English.intToEnglish(i).replace('-', ' ') + \" \" + TestUtil.randomSimpleString(random());\n      field1.setStringValue(stringValue);\n      field2.setStringValue(stringValue);\n      field3.setStringValue(stringValue);\n      field4.setStringValue(stringValue);\n      field5.setStringValue(stringValue);\n      field6.setStringValue(stringValue);\n      field7.setStringValue(stringValue);\n      field8.setStringValue(stringValue);\n      iw.addDocument(doc);\n    }\n    iw.shutdown();\n    verify(dir);\n    TestUtil.checkIndex(dir); // for some extra coverage, checkIndex before we forceMerge\n    iwc = newIndexWriterConfig(analyzer);\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new Lucene41PostingsFormat()));\n    iwc.setOpenMode(OpenMode.APPEND);\n    IndexWriter iw2 = new IndexWriter(dir, iwc);\n    iw2.forceMerge(1);\n    iw2.shutdown();\n    verify(dir);\n    dir.close();\n  }\n\n","sourceOld":"  // creates 8 fields with different options and does \"duels\" of fields against each other\n  public void test() throws Exception {\n    Directory dir = newDirectory();\n    Analyzer analyzer = new Analyzer(Analyzer.PER_FIELD_REUSE_STRATEGY) {\n      @Override\n      protected TokenStreamComponents createComponents(String fieldName) {\n        Tokenizer tokenizer = new MockTokenizer();\n        if (fieldName.contains(\"payloadsFixed\")) {\n          TokenFilter filter = new MockFixedLengthPayloadFilter(new Random(0), tokenizer, 1);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else if (fieldName.contains(\"payloadsVariable\")) {\n          TokenFilter filter = new MockVariableLengthPayloadFilter(new Random(0), tokenizer);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else {\n          return new TokenStreamComponents(tokenizer);\n        }\n      }\n    };\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer);\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new Lucene41PostingsFormat()));\n    // TODO we could actually add more fields implemented with different PFs\n    // or, just put this test into the usual rotation?\n    RandomIndexWriter iw = new RandomIndexWriter(random(), dir, iwc);\n    Document doc = new Document();\n    FieldType docsOnlyType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsOnlyType.setStoreTermVectors(true);\n    docsOnlyType.setIndexOptions(IndexOptions.DOCS_ONLY);\n    \n    FieldType docsAndFreqsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsAndFreqsType.setStoreTermVectors(true);\n    docsAndFreqsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    \n    FieldType positionsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn these on for a cross-check\n    positionsType.setStoreTermVectors(true);\n    positionsType.setStoreTermVectorPositions(true);\n    positionsType.setStoreTermVectorOffsets(true);\n    positionsType.setStoreTermVectorPayloads(true);\n    FieldType offsetsType = new FieldType(positionsType);\n    offsetsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    Field field1 = new Field(\"field1docs\", \"\", docsOnlyType);\n    Field field2 = new Field(\"field2freqs\", \"\", docsAndFreqsType);\n    Field field3 = new Field(\"field3positions\", \"\", positionsType);\n    Field field4 = new Field(\"field4offsets\", \"\", offsetsType);\n    Field field5 = new Field(\"field5payloadsFixed\", \"\", positionsType);\n    Field field6 = new Field(\"field6payloadsVariable\", \"\", positionsType);\n    Field field7 = new Field(\"field7payloadsFixedOffsets\", \"\", offsetsType);\n    Field field8 = new Field(\"field8payloadsVariableOffsets\", \"\", offsetsType);\n    doc.add(field1);\n    doc.add(field2);\n    doc.add(field3);\n    doc.add(field4);\n    doc.add(field5);\n    doc.add(field6);\n    doc.add(field7);\n    doc.add(field8);\n    for (int i = 0; i < MAXDOC; i++) {\n      String stringValue = Integer.toString(i) + \" verycommon \" + English.intToEnglish(i).replace('-', ' ') + \" \" + TestUtil.randomSimpleString(random());\n      field1.setStringValue(stringValue);\n      field2.setStringValue(stringValue);\n      field3.setStringValue(stringValue);\n      field4.setStringValue(stringValue);\n      field5.setStringValue(stringValue);\n      field6.setStringValue(stringValue);\n      field7.setStringValue(stringValue);\n      field8.setStringValue(stringValue);\n      iw.addDocument(doc);\n    }\n    iw.shutdown();\n    verify(dir);\n    TestUtil.checkIndex(dir); // for some extra coverage, checkIndex before we forceMerge\n    iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer);\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new Lucene41PostingsFormat()));\n    iwc.setOpenMode(OpenMode.APPEND);\n    IndexWriter iw2 = new IndexWriter(dir, iwc);\n    iw2.forceMerge(1);\n    iw2.shutdown();\n    verify(dir);\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0ef034a4f10871667ae75181537775ddcf8ade4","date":1407610475,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/lucene41/TestBlockPostingsFormat3#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/lucene41/TestBlockPostingsFormat3#test().mjava","sourceNew":"  // creates 8 fields with different options and does \"duels\" of fields against each other\n  public void test() throws Exception {\n    Directory dir = newDirectory();\n    Analyzer analyzer = new Analyzer(Analyzer.PER_FIELD_REUSE_STRATEGY) {\n      @Override\n      protected TokenStreamComponents createComponents(String fieldName) {\n        Tokenizer tokenizer = new MockTokenizer();\n        if (fieldName.contains(\"payloadsFixed\")) {\n          TokenFilter filter = new MockFixedLengthPayloadFilter(new Random(0), tokenizer, 1);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else if (fieldName.contains(\"payloadsVariable\")) {\n          TokenFilter filter = new MockVariableLengthPayloadFilter(new Random(0), tokenizer);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else {\n          return new TokenStreamComponents(tokenizer);\n        }\n      }\n    };\n    IndexWriterConfig iwc = newIndexWriterConfig(analyzer);\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new Lucene41PostingsFormat()));\n    // TODO we could actually add more fields implemented with different PFs\n    // or, just put this test into the usual rotation?\n    RandomIndexWriter iw = new RandomIndexWriter(random(), dir, iwc);\n    Document doc = new Document();\n    FieldType docsOnlyType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsOnlyType.setStoreTermVectors(true);\n    docsOnlyType.setIndexOptions(IndexOptions.DOCS_ONLY);\n    \n    FieldType docsAndFreqsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsAndFreqsType.setStoreTermVectors(true);\n    docsAndFreqsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    \n    FieldType positionsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn these on for a cross-check\n    positionsType.setStoreTermVectors(true);\n    positionsType.setStoreTermVectorPositions(true);\n    positionsType.setStoreTermVectorOffsets(true);\n    positionsType.setStoreTermVectorPayloads(true);\n    FieldType offsetsType = new FieldType(positionsType);\n    offsetsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    Field field1 = new Field(\"field1docs\", \"\", docsOnlyType);\n    Field field2 = new Field(\"field2freqs\", \"\", docsAndFreqsType);\n    Field field3 = new Field(\"field3positions\", \"\", positionsType);\n    Field field4 = new Field(\"field4offsets\", \"\", offsetsType);\n    Field field5 = new Field(\"field5payloadsFixed\", \"\", positionsType);\n    Field field6 = new Field(\"field6payloadsVariable\", \"\", positionsType);\n    Field field7 = new Field(\"field7payloadsFixedOffsets\", \"\", offsetsType);\n    Field field8 = new Field(\"field8payloadsVariableOffsets\", \"\", offsetsType);\n    doc.add(field1);\n    doc.add(field2);\n    doc.add(field3);\n    doc.add(field4);\n    doc.add(field5);\n    doc.add(field6);\n    doc.add(field7);\n    doc.add(field8);\n    for (int i = 0; i < MAXDOC; i++) {\n      String stringValue = Integer.toString(i) + \" verycommon \" + English.intToEnglish(i).replace('-', ' ') + \" \" + TestUtil.randomSimpleString(random());\n      field1.setStringValue(stringValue);\n      field2.setStringValue(stringValue);\n      field3.setStringValue(stringValue);\n      field4.setStringValue(stringValue);\n      field5.setStringValue(stringValue);\n      field6.setStringValue(stringValue);\n      field7.setStringValue(stringValue);\n      field8.setStringValue(stringValue);\n      iw.addDocument(doc);\n    }\n    iw.close();\n    verify(dir);\n    TestUtil.checkIndex(dir); // for some extra coverage, checkIndex before we forceMerge\n    iwc = newIndexWriterConfig(analyzer);\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new Lucene41PostingsFormat()));\n    iwc.setOpenMode(OpenMode.APPEND);\n    IndexWriter iw2 = new IndexWriter(dir, iwc);\n    iw2.forceMerge(1);\n    iw2.close();\n    verify(dir);\n    dir.close();\n  }\n\n","sourceOld":"  // creates 8 fields with different options and does \"duels\" of fields against each other\n  public void test() throws Exception {\n    Directory dir = newDirectory();\n    Analyzer analyzer = new Analyzer(Analyzer.PER_FIELD_REUSE_STRATEGY) {\n      @Override\n      protected TokenStreamComponents createComponents(String fieldName) {\n        Tokenizer tokenizer = new MockTokenizer();\n        if (fieldName.contains(\"payloadsFixed\")) {\n          TokenFilter filter = new MockFixedLengthPayloadFilter(new Random(0), tokenizer, 1);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else if (fieldName.contains(\"payloadsVariable\")) {\n          TokenFilter filter = new MockVariableLengthPayloadFilter(new Random(0), tokenizer);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else {\n          return new TokenStreamComponents(tokenizer);\n        }\n      }\n    };\n    IndexWriterConfig iwc = newIndexWriterConfig(analyzer);\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new Lucene41PostingsFormat()));\n    // TODO we could actually add more fields implemented with different PFs\n    // or, just put this test into the usual rotation?\n    RandomIndexWriter iw = new RandomIndexWriter(random(), dir, iwc);\n    Document doc = new Document();\n    FieldType docsOnlyType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsOnlyType.setStoreTermVectors(true);\n    docsOnlyType.setIndexOptions(IndexOptions.DOCS_ONLY);\n    \n    FieldType docsAndFreqsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsAndFreqsType.setStoreTermVectors(true);\n    docsAndFreqsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    \n    FieldType positionsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn these on for a cross-check\n    positionsType.setStoreTermVectors(true);\n    positionsType.setStoreTermVectorPositions(true);\n    positionsType.setStoreTermVectorOffsets(true);\n    positionsType.setStoreTermVectorPayloads(true);\n    FieldType offsetsType = new FieldType(positionsType);\n    offsetsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    Field field1 = new Field(\"field1docs\", \"\", docsOnlyType);\n    Field field2 = new Field(\"field2freqs\", \"\", docsAndFreqsType);\n    Field field3 = new Field(\"field3positions\", \"\", positionsType);\n    Field field4 = new Field(\"field4offsets\", \"\", offsetsType);\n    Field field5 = new Field(\"field5payloadsFixed\", \"\", positionsType);\n    Field field6 = new Field(\"field6payloadsVariable\", \"\", positionsType);\n    Field field7 = new Field(\"field7payloadsFixedOffsets\", \"\", offsetsType);\n    Field field8 = new Field(\"field8payloadsVariableOffsets\", \"\", offsetsType);\n    doc.add(field1);\n    doc.add(field2);\n    doc.add(field3);\n    doc.add(field4);\n    doc.add(field5);\n    doc.add(field6);\n    doc.add(field7);\n    doc.add(field8);\n    for (int i = 0; i < MAXDOC; i++) {\n      String stringValue = Integer.toString(i) + \" verycommon \" + English.intToEnglish(i).replace('-', ' ') + \" \" + TestUtil.randomSimpleString(random());\n      field1.setStringValue(stringValue);\n      field2.setStringValue(stringValue);\n      field3.setStringValue(stringValue);\n      field4.setStringValue(stringValue);\n      field5.setStringValue(stringValue);\n      field6.setStringValue(stringValue);\n      field7.setStringValue(stringValue);\n      field8.setStringValue(stringValue);\n      iw.addDocument(doc);\n    }\n    iw.shutdown();\n    verify(dir);\n    TestUtil.checkIndex(dir); // for some extra coverage, checkIndex before we forceMerge\n    iwc = newIndexWriterConfig(analyzer);\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new Lucene41PostingsFormat()));\n    iwc.setOpenMode(OpenMode.APPEND);\n    IndexWriter iw2 = new IndexWriter(dir, iwc);\n    iw2.forceMerge(1);\n    iw2.shutdown();\n    verify(dir);\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"99eb4a732d1a908f4636ace52928876136bf1896","date":1413829552,"type":6,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene41/TestLucene41PostingsFormat3#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/lucene41/TestBlockPostingsFormat3#test().mjava","sourceNew":"  // creates 8 fields with different options and does \"duels\" of fields against each other\n  public void test() throws Exception {\n    Directory dir = newDirectory();\n    Analyzer analyzer = new Analyzer(Analyzer.PER_FIELD_REUSE_STRATEGY) {\n      @Override\n      protected TokenStreamComponents createComponents(String fieldName) {\n        Tokenizer tokenizer = new MockTokenizer();\n        if (fieldName.contains(\"payloadsFixed\")) {\n          TokenFilter filter = new MockFixedLengthPayloadFilter(new Random(0), tokenizer, 1);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else if (fieldName.contains(\"payloadsVariable\")) {\n          TokenFilter filter = new MockVariableLengthPayloadFilter(new Random(0), tokenizer);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else {\n          return new TokenStreamComponents(tokenizer);\n        }\n      }\n    };\n    IndexWriterConfig iwc = newIndexWriterConfig(analyzer);\n    iwc.setCodec(new Lucene41RWCodec());\n    // TODO we could actually add more fields implemented with different PFs\n    // or, just put this test into the usual rotation?\n    RandomIndexWriter iw = new RandomIndexWriter(random(), dir, iwc);\n    Document doc = new Document();\n    FieldType docsOnlyType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsOnlyType.setStoreTermVectors(true);\n    docsOnlyType.setIndexOptions(IndexOptions.DOCS_ONLY);\n    \n    FieldType docsAndFreqsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsAndFreqsType.setStoreTermVectors(true);\n    docsAndFreqsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    \n    FieldType positionsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn these on for a cross-check\n    positionsType.setStoreTermVectors(true);\n    positionsType.setStoreTermVectorPositions(true);\n    positionsType.setStoreTermVectorOffsets(true);\n    positionsType.setStoreTermVectorPayloads(true);\n    FieldType offsetsType = new FieldType(positionsType);\n    offsetsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    Field field1 = new Field(\"field1docs\", \"\", docsOnlyType);\n    Field field2 = new Field(\"field2freqs\", \"\", docsAndFreqsType);\n    Field field3 = new Field(\"field3positions\", \"\", positionsType);\n    Field field4 = new Field(\"field4offsets\", \"\", offsetsType);\n    Field field5 = new Field(\"field5payloadsFixed\", \"\", positionsType);\n    Field field6 = new Field(\"field6payloadsVariable\", \"\", positionsType);\n    Field field7 = new Field(\"field7payloadsFixedOffsets\", \"\", offsetsType);\n    Field field8 = new Field(\"field8payloadsVariableOffsets\", \"\", offsetsType);\n    doc.add(field1);\n    doc.add(field2);\n    doc.add(field3);\n    doc.add(field4);\n    doc.add(field5);\n    doc.add(field6);\n    doc.add(field7);\n    doc.add(field8);\n    for (int i = 0; i < MAXDOC; i++) {\n      String stringValue = Integer.toString(i) + \" verycommon \" + English.intToEnglish(i).replace('-', ' ') + \" \" + TestUtil.randomSimpleString(random());\n      field1.setStringValue(stringValue);\n      field2.setStringValue(stringValue);\n      field3.setStringValue(stringValue);\n      field4.setStringValue(stringValue);\n      field5.setStringValue(stringValue);\n      field6.setStringValue(stringValue);\n      field7.setStringValue(stringValue);\n      field8.setStringValue(stringValue);\n      iw.addDocument(doc);\n    }\n    iw.close();\n    verify(dir);\n    TestUtil.checkIndex(dir); // for some extra coverage, checkIndex before we forceMerge\n    iwc = newIndexWriterConfig(analyzer);\n    iwc.setCodec(new Lucene41RWCodec());\n    iwc.setOpenMode(OpenMode.APPEND);\n    IndexWriter iw2 = new IndexWriter(dir, iwc);\n    iw2.forceMerge(1);\n    iw2.close();\n    verify(dir);\n    dir.close();\n  }\n\n","sourceOld":"  // creates 8 fields with different options and does \"duels\" of fields against each other\n  public void test() throws Exception {\n    Directory dir = newDirectory();\n    Analyzer analyzer = new Analyzer(Analyzer.PER_FIELD_REUSE_STRATEGY) {\n      @Override\n      protected TokenStreamComponents createComponents(String fieldName) {\n        Tokenizer tokenizer = new MockTokenizer();\n        if (fieldName.contains(\"payloadsFixed\")) {\n          TokenFilter filter = new MockFixedLengthPayloadFilter(new Random(0), tokenizer, 1);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else if (fieldName.contains(\"payloadsVariable\")) {\n          TokenFilter filter = new MockVariableLengthPayloadFilter(new Random(0), tokenizer);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else {\n          return new TokenStreamComponents(tokenizer);\n        }\n      }\n    };\n    IndexWriterConfig iwc = newIndexWriterConfig(analyzer);\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new Lucene41PostingsFormat()));\n    // TODO we could actually add more fields implemented with different PFs\n    // or, just put this test into the usual rotation?\n    RandomIndexWriter iw = new RandomIndexWriter(random(), dir, iwc);\n    Document doc = new Document();\n    FieldType docsOnlyType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsOnlyType.setStoreTermVectors(true);\n    docsOnlyType.setIndexOptions(IndexOptions.DOCS_ONLY);\n    \n    FieldType docsAndFreqsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsAndFreqsType.setStoreTermVectors(true);\n    docsAndFreqsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    \n    FieldType positionsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn these on for a cross-check\n    positionsType.setStoreTermVectors(true);\n    positionsType.setStoreTermVectorPositions(true);\n    positionsType.setStoreTermVectorOffsets(true);\n    positionsType.setStoreTermVectorPayloads(true);\n    FieldType offsetsType = new FieldType(positionsType);\n    offsetsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    Field field1 = new Field(\"field1docs\", \"\", docsOnlyType);\n    Field field2 = new Field(\"field2freqs\", \"\", docsAndFreqsType);\n    Field field3 = new Field(\"field3positions\", \"\", positionsType);\n    Field field4 = new Field(\"field4offsets\", \"\", offsetsType);\n    Field field5 = new Field(\"field5payloadsFixed\", \"\", positionsType);\n    Field field6 = new Field(\"field6payloadsVariable\", \"\", positionsType);\n    Field field7 = new Field(\"field7payloadsFixedOffsets\", \"\", offsetsType);\n    Field field8 = new Field(\"field8payloadsVariableOffsets\", \"\", offsetsType);\n    doc.add(field1);\n    doc.add(field2);\n    doc.add(field3);\n    doc.add(field4);\n    doc.add(field5);\n    doc.add(field6);\n    doc.add(field7);\n    doc.add(field8);\n    for (int i = 0; i < MAXDOC; i++) {\n      String stringValue = Integer.toString(i) + \" verycommon \" + English.intToEnglish(i).replace('-', ' ') + \" \" + TestUtil.randomSimpleString(random());\n      field1.setStringValue(stringValue);\n      field2.setStringValue(stringValue);\n      field3.setStringValue(stringValue);\n      field4.setStringValue(stringValue);\n      field5.setStringValue(stringValue);\n      field6.setStringValue(stringValue);\n      field7.setStringValue(stringValue);\n      field8.setStringValue(stringValue);\n      iw.addDocument(doc);\n    }\n    iw.close();\n    verify(dir);\n    TestUtil.checkIndex(dir); // for some extra coverage, checkIndex before we forceMerge\n    iwc = newIndexWriterConfig(analyzer);\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new Lucene41PostingsFormat()));\n    iwc.setOpenMode(OpenMode.APPEND);\n    IndexWriter iw2 = new IndexWriter(dir, iwc);\n    iw2.forceMerge(1);\n    iw2.close();\n    verify(dir);\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"99eb4a732d1a908f4636ace52928876136bf1896","date":1413829552,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/lucene50/TestBlockPostingsFormat3#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/lucene41/TestBlockPostingsFormat3#test().mjava","sourceNew":"  // creates 8 fields with different options and does \"duels\" of fields against each other\n  public void test() throws Exception {\n    Directory dir = newDirectory();\n    Analyzer analyzer = new Analyzer(Analyzer.PER_FIELD_REUSE_STRATEGY) {\n      @Override\n      protected TokenStreamComponents createComponents(String fieldName) {\n        Tokenizer tokenizer = new MockTokenizer();\n        if (fieldName.contains(\"payloadsFixed\")) {\n          TokenFilter filter = new MockFixedLengthPayloadFilter(new Random(0), tokenizer, 1);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else if (fieldName.contains(\"payloadsVariable\")) {\n          TokenFilter filter = new MockVariableLengthPayloadFilter(new Random(0), tokenizer);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else {\n          return new TokenStreamComponents(tokenizer);\n        }\n      }\n    };\n    IndexWriterConfig iwc = newIndexWriterConfig(analyzer);\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new Lucene50PostingsFormat()));\n    // TODO we could actually add more fields implemented with different PFs\n    // or, just put this test into the usual rotation?\n    RandomIndexWriter iw = new RandomIndexWriter(random(), dir, iwc);\n    Document doc = new Document();\n    FieldType docsOnlyType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsOnlyType.setStoreTermVectors(true);\n    docsOnlyType.setIndexOptions(IndexOptions.DOCS_ONLY);\n    \n    FieldType docsAndFreqsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsAndFreqsType.setStoreTermVectors(true);\n    docsAndFreqsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    \n    FieldType positionsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn these on for a cross-check\n    positionsType.setStoreTermVectors(true);\n    positionsType.setStoreTermVectorPositions(true);\n    positionsType.setStoreTermVectorOffsets(true);\n    positionsType.setStoreTermVectorPayloads(true);\n    FieldType offsetsType = new FieldType(positionsType);\n    offsetsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    Field field1 = new Field(\"field1docs\", \"\", docsOnlyType);\n    Field field2 = new Field(\"field2freqs\", \"\", docsAndFreqsType);\n    Field field3 = new Field(\"field3positions\", \"\", positionsType);\n    Field field4 = new Field(\"field4offsets\", \"\", offsetsType);\n    Field field5 = new Field(\"field5payloadsFixed\", \"\", positionsType);\n    Field field6 = new Field(\"field6payloadsVariable\", \"\", positionsType);\n    Field field7 = new Field(\"field7payloadsFixedOffsets\", \"\", offsetsType);\n    Field field8 = new Field(\"field8payloadsVariableOffsets\", \"\", offsetsType);\n    doc.add(field1);\n    doc.add(field2);\n    doc.add(field3);\n    doc.add(field4);\n    doc.add(field5);\n    doc.add(field6);\n    doc.add(field7);\n    doc.add(field8);\n    for (int i = 0; i < MAXDOC; i++) {\n      String stringValue = Integer.toString(i) + \" verycommon \" + English.intToEnglish(i).replace('-', ' ') + \" \" + TestUtil.randomSimpleString(random());\n      field1.setStringValue(stringValue);\n      field2.setStringValue(stringValue);\n      field3.setStringValue(stringValue);\n      field4.setStringValue(stringValue);\n      field5.setStringValue(stringValue);\n      field6.setStringValue(stringValue);\n      field7.setStringValue(stringValue);\n      field8.setStringValue(stringValue);\n      iw.addDocument(doc);\n    }\n    iw.close();\n    verify(dir);\n    TestUtil.checkIndex(dir); // for some extra coverage, checkIndex before we forceMerge\n    iwc = newIndexWriterConfig(analyzer);\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new Lucene50PostingsFormat()));\n    iwc.setOpenMode(OpenMode.APPEND);\n    IndexWriter iw2 = new IndexWriter(dir, iwc);\n    iw2.forceMerge(1);\n    iw2.close();\n    verify(dir);\n    dir.close();\n  }\n\n","sourceOld":"  // creates 8 fields with different options and does \"duels\" of fields against each other\n  public void test() throws Exception {\n    Directory dir = newDirectory();\n    Analyzer analyzer = new Analyzer(Analyzer.PER_FIELD_REUSE_STRATEGY) {\n      @Override\n      protected TokenStreamComponents createComponents(String fieldName) {\n        Tokenizer tokenizer = new MockTokenizer();\n        if (fieldName.contains(\"payloadsFixed\")) {\n          TokenFilter filter = new MockFixedLengthPayloadFilter(new Random(0), tokenizer, 1);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else if (fieldName.contains(\"payloadsVariable\")) {\n          TokenFilter filter = new MockVariableLengthPayloadFilter(new Random(0), tokenizer);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else {\n          return new TokenStreamComponents(tokenizer);\n        }\n      }\n    };\n    IndexWriterConfig iwc = newIndexWriterConfig(analyzer);\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new Lucene41PostingsFormat()));\n    // TODO we could actually add more fields implemented with different PFs\n    // or, just put this test into the usual rotation?\n    RandomIndexWriter iw = new RandomIndexWriter(random(), dir, iwc);\n    Document doc = new Document();\n    FieldType docsOnlyType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsOnlyType.setStoreTermVectors(true);\n    docsOnlyType.setIndexOptions(IndexOptions.DOCS_ONLY);\n    \n    FieldType docsAndFreqsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsAndFreqsType.setStoreTermVectors(true);\n    docsAndFreqsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    \n    FieldType positionsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn these on for a cross-check\n    positionsType.setStoreTermVectors(true);\n    positionsType.setStoreTermVectorPositions(true);\n    positionsType.setStoreTermVectorOffsets(true);\n    positionsType.setStoreTermVectorPayloads(true);\n    FieldType offsetsType = new FieldType(positionsType);\n    offsetsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    Field field1 = new Field(\"field1docs\", \"\", docsOnlyType);\n    Field field2 = new Field(\"field2freqs\", \"\", docsAndFreqsType);\n    Field field3 = new Field(\"field3positions\", \"\", positionsType);\n    Field field4 = new Field(\"field4offsets\", \"\", offsetsType);\n    Field field5 = new Field(\"field5payloadsFixed\", \"\", positionsType);\n    Field field6 = new Field(\"field6payloadsVariable\", \"\", positionsType);\n    Field field7 = new Field(\"field7payloadsFixedOffsets\", \"\", offsetsType);\n    Field field8 = new Field(\"field8payloadsVariableOffsets\", \"\", offsetsType);\n    doc.add(field1);\n    doc.add(field2);\n    doc.add(field3);\n    doc.add(field4);\n    doc.add(field5);\n    doc.add(field6);\n    doc.add(field7);\n    doc.add(field8);\n    for (int i = 0; i < MAXDOC; i++) {\n      String stringValue = Integer.toString(i) + \" verycommon \" + English.intToEnglish(i).replace('-', ' ') + \" \" + TestUtil.randomSimpleString(random());\n      field1.setStringValue(stringValue);\n      field2.setStringValue(stringValue);\n      field3.setStringValue(stringValue);\n      field4.setStringValue(stringValue);\n      field5.setStringValue(stringValue);\n      field6.setStringValue(stringValue);\n      field7.setStringValue(stringValue);\n      field8.setStringValue(stringValue);\n      iw.addDocument(doc);\n    }\n    iw.close();\n    verify(dir);\n    TestUtil.checkIndex(dir); // for some extra coverage, checkIndex before we forceMerge\n    iwc = newIndexWriterConfig(analyzer);\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new Lucene41PostingsFormat()));\n    iwc.setOpenMode(OpenMode.APPEND);\n    IndexWriter iw2 = new IndexWriter(dir, iwc);\n    iw2.forceMerge(1);\n    iw2.close();\n    verify(dir);\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"db68c63cbfaa8698b9c4475f75ed2b9c9696d238","date":1414118621,"type":6,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene41/TestLucene41PostingsFormat3#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/lucene41/TestBlockPostingsFormat3#test().mjava","sourceNew":"  // creates 8 fields with different options and does \"duels\" of fields against each other\n  public void test() throws Exception {\n    Directory dir = newDirectory();\n    Analyzer analyzer = new Analyzer(Analyzer.PER_FIELD_REUSE_STRATEGY) {\n      @Override\n      protected TokenStreamComponents createComponents(String fieldName) {\n        Tokenizer tokenizer = new MockTokenizer();\n        if (fieldName.contains(\"payloadsFixed\")) {\n          TokenFilter filter = new MockFixedLengthPayloadFilter(new Random(0), tokenizer, 1);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else if (fieldName.contains(\"payloadsVariable\")) {\n          TokenFilter filter = new MockVariableLengthPayloadFilter(new Random(0), tokenizer);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else {\n          return new TokenStreamComponents(tokenizer);\n        }\n      }\n    };\n    IndexWriterConfig iwc = newIndexWriterConfig(analyzer);\n    iwc.setCodec(new Lucene41RWCodec());\n    // TODO we could actually add more fields implemented with different PFs\n    // or, just put this test into the usual rotation?\n    RandomIndexWriter iw = new RandomIndexWriter(random(), dir, iwc);\n    Document doc = new Document();\n    FieldType docsOnlyType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsOnlyType.setStoreTermVectors(true);\n    docsOnlyType.setIndexOptions(IndexOptions.DOCS_ONLY);\n    \n    FieldType docsAndFreqsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsAndFreqsType.setStoreTermVectors(true);\n    docsAndFreqsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    \n    FieldType positionsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn these on for a cross-check\n    positionsType.setStoreTermVectors(true);\n    positionsType.setStoreTermVectorPositions(true);\n    positionsType.setStoreTermVectorOffsets(true);\n    positionsType.setStoreTermVectorPayloads(true);\n    FieldType offsetsType = new FieldType(positionsType);\n    offsetsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    Field field1 = new Field(\"field1docs\", \"\", docsOnlyType);\n    Field field2 = new Field(\"field2freqs\", \"\", docsAndFreqsType);\n    Field field3 = new Field(\"field3positions\", \"\", positionsType);\n    Field field4 = new Field(\"field4offsets\", \"\", offsetsType);\n    Field field5 = new Field(\"field5payloadsFixed\", \"\", positionsType);\n    Field field6 = new Field(\"field6payloadsVariable\", \"\", positionsType);\n    Field field7 = new Field(\"field7payloadsFixedOffsets\", \"\", offsetsType);\n    Field field8 = new Field(\"field8payloadsVariableOffsets\", \"\", offsetsType);\n    doc.add(field1);\n    doc.add(field2);\n    doc.add(field3);\n    doc.add(field4);\n    doc.add(field5);\n    doc.add(field6);\n    doc.add(field7);\n    doc.add(field8);\n    for (int i = 0; i < MAXDOC; i++) {\n      String stringValue = Integer.toString(i) + \" verycommon \" + English.intToEnglish(i).replace('-', ' ') + \" \" + TestUtil.randomSimpleString(random());\n      field1.setStringValue(stringValue);\n      field2.setStringValue(stringValue);\n      field3.setStringValue(stringValue);\n      field4.setStringValue(stringValue);\n      field5.setStringValue(stringValue);\n      field6.setStringValue(stringValue);\n      field7.setStringValue(stringValue);\n      field8.setStringValue(stringValue);\n      iw.addDocument(doc);\n    }\n    iw.close();\n    verify(dir);\n    TestUtil.checkIndex(dir); // for some extra coverage, checkIndex before we forceMerge\n    iwc = newIndexWriterConfig(analyzer);\n    iwc.setCodec(new Lucene41RWCodec());\n    iwc.setOpenMode(OpenMode.APPEND);\n    IndexWriter iw2 = new IndexWriter(dir, iwc);\n    iw2.forceMerge(1);\n    iw2.close();\n    verify(dir);\n    dir.close();\n  }\n\n","sourceOld":"  // creates 8 fields with different options and does \"duels\" of fields against each other\n  public void test() throws Exception {\n    Directory dir = newDirectory();\n    Analyzer analyzer = new Analyzer(Analyzer.PER_FIELD_REUSE_STRATEGY) {\n      @Override\n      protected TokenStreamComponents createComponents(String fieldName) {\n        Tokenizer tokenizer = new MockTokenizer();\n        if (fieldName.contains(\"payloadsFixed\")) {\n          TokenFilter filter = new MockFixedLengthPayloadFilter(new Random(0), tokenizer, 1);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else if (fieldName.contains(\"payloadsVariable\")) {\n          TokenFilter filter = new MockVariableLengthPayloadFilter(new Random(0), tokenizer);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else {\n          return new TokenStreamComponents(tokenizer);\n        }\n      }\n    };\n    IndexWriterConfig iwc = newIndexWriterConfig(analyzer);\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new Lucene41PostingsFormat()));\n    // TODO we could actually add more fields implemented with different PFs\n    // or, just put this test into the usual rotation?\n    RandomIndexWriter iw = new RandomIndexWriter(random(), dir, iwc);\n    Document doc = new Document();\n    FieldType docsOnlyType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsOnlyType.setStoreTermVectors(true);\n    docsOnlyType.setIndexOptions(IndexOptions.DOCS_ONLY);\n    \n    FieldType docsAndFreqsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsAndFreqsType.setStoreTermVectors(true);\n    docsAndFreqsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    \n    FieldType positionsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn these on for a cross-check\n    positionsType.setStoreTermVectors(true);\n    positionsType.setStoreTermVectorPositions(true);\n    positionsType.setStoreTermVectorOffsets(true);\n    positionsType.setStoreTermVectorPayloads(true);\n    FieldType offsetsType = new FieldType(positionsType);\n    offsetsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    Field field1 = new Field(\"field1docs\", \"\", docsOnlyType);\n    Field field2 = new Field(\"field2freqs\", \"\", docsAndFreqsType);\n    Field field3 = new Field(\"field3positions\", \"\", positionsType);\n    Field field4 = new Field(\"field4offsets\", \"\", offsetsType);\n    Field field5 = new Field(\"field5payloadsFixed\", \"\", positionsType);\n    Field field6 = new Field(\"field6payloadsVariable\", \"\", positionsType);\n    Field field7 = new Field(\"field7payloadsFixedOffsets\", \"\", offsetsType);\n    Field field8 = new Field(\"field8payloadsVariableOffsets\", \"\", offsetsType);\n    doc.add(field1);\n    doc.add(field2);\n    doc.add(field3);\n    doc.add(field4);\n    doc.add(field5);\n    doc.add(field6);\n    doc.add(field7);\n    doc.add(field8);\n    for (int i = 0; i < MAXDOC; i++) {\n      String stringValue = Integer.toString(i) + \" verycommon \" + English.intToEnglish(i).replace('-', ' ') + \" \" + TestUtil.randomSimpleString(random());\n      field1.setStringValue(stringValue);\n      field2.setStringValue(stringValue);\n      field3.setStringValue(stringValue);\n      field4.setStringValue(stringValue);\n      field5.setStringValue(stringValue);\n      field6.setStringValue(stringValue);\n      field7.setStringValue(stringValue);\n      field8.setStringValue(stringValue);\n      iw.addDocument(doc);\n    }\n    iw.close();\n    verify(dir);\n    TestUtil.checkIndex(dir); // for some extra coverage, checkIndex before we forceMerge\n    iwc = newIndexWriterConfig(analyzer);\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new Lucene41PostingsFormat()));\n    iwc.setOpenMode(OpenMode.APPEND);\n    IndexWriter iw2 = new IndexWriter(dir, iwc);\n    iw2.forceMerge(1);\n    iw2.close();\n    verify(dir);\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"db68c63cbfaa8698b9c4475f75ed2b9c9696d238","date":1414118621,"type":5,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/codecs/lucene50/TestBlockPostingsFormat3#test().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/codecs/lucene41/TestBlockPostingsFormat3#test().mjava","sourceNew":"  // creates 8 fields with different options and does \"duels\" of fields against each other\n  public void test() throws Exception {\n    Directory dir = newDirectory();\n    Analyzer analyzer = new Analyzer(Analyzer.PER_FIELD_REUSE_STRATEGY) {\n      @Override\n      protected TokenStreamComponents createComponents(String fieldName) {\n        Tokenizer tokenizer = new MockTokenizer();\n        if (fieldName.contains(\"payloadsFixed\")) {\n          TokenFilter filter = new MockFixedLengthPayloadFilter(new Random(0), tokenizer, 1);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else if (fieldName.contains(\"payloadsVariable\")) {\n          TokenFilter filter = new MockVariableLengthPayloadFilter(new Random(0), tokenizer);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else {\n          return new TokenStreamComponents(tokenizer);\n        }\n      }\n    };\n    IndexWriterConfig iwc = newIndexWriterConfig(analyzer);\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new Lucene50PostingsFormat()));\n    // TODO we could actually add more fields implemented with different PFs\n    // or, just put this test into the usual rotation?\n    RandomIndexWriter iw = new RandomIndexWriter(random(), dir, iwc);\n    Document doc = new Document();\n    FieldType docsOnlyType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsOnlyType.setStoreTermVectors(true);\n    docsOnlyType.setIndexOptions(IndexOptions.DOCS_ONLY);\n    \n    FieldType docsAndFreqsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsAndFreqsType.setStoreTermVectors(true);\n    docsAndFreqsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    \n    FieldType positionsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn these on for a cross-check\n    positionsType.setStoreTermVectors(true);\n    positionsType.setStoreTermVectorPositions(true);\n    positionsType.setStoreTermVectorOffsets(true);\n    positionsType.setStoreTermVectorPayloads(true);\n    FieldType offsetsType = new FieldType(positionsType);\n    offsetsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    Field field1 = new Field(\"field1docs\", \"\", docsOnlyType);\n    Field field2 = new Field(\"field2freqs\", \"\", docsAndFreqsType);\n    Field field3 = new Field(\"field3positions\", \"\", positionsType);\n    Field field4 = new Field(\"field4offsets\", \"\", offsetsType);\n    Field field5 = new Field(\"field5payloadsFixed\", \"\", positionsType);\n    Field field6 = new Field(\"field6payloadsVariable\", \"\", positionsType);\n    Field field7 = new Field(\"field7payloadsFixedOffsets\", \"\", offsetsType);\n    Field field8 = new Field(\"field8payloadsVariableOffsets\", \"\", offsetsType);\n    doc.add(field1);\n    doc.add(field2);\n    doc.add(field3);\n    doc.add(field4);\n    doc.add(field5);\n    doc.add(field6);\n    doc.add(field7);\n    doc.add(field8);\n    for (int i = 0; i < MAXDOC; i++) {\n      String stringValue = Integer.toString(i) + \" verycommon \" + English.intToEnglish(i).replace('-', ' ') + \" \" + TestUtil.randomSimpleString(random());\n      field1.setStringValue(stringValue);\n      field2.setStringValue(stringValue);\n      field3.setStringValue(stringValue);\n      field4.setStringValue(stringValue);\n      field5.setStringValue(stringValue);\n      field6.setStringValue(stringValue);\n      field7.setStringValue(stringValue);\n      field8.setStringValue(stringValue);\n      iw.addDocument(doc);\n    }\n    iw.close();\n    verify(dir);\n    TestUtil.checkIndex(dir); // for some extra coverage, checkIndex before we forceMerge\n    iwc = newIndexWriterConfig(analyzer);\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new Lucene50PostingsFormat()));\n    iwc.setOpenMode(OpenMode.APPEND);\n    IndexWriter iw2 = new IndexWriter(dir, iwc);\n    iw2.forceMerge(1);\n    iw2.close();\n    verify(dir);\n    dir.close();\n  }\n\n","sourceOld":"  // creates 8 fields with different options and does \"duels\" of fields against each other\n  public void test() throws Exception {\n    Directory dir = newDirectory();\n    Analyzer analyzer = new Analyzer(Analyzer.PER_FIELD_REUSE_STRATEGY) {\n      @Override\n      protected TokenStreamComponents createComponents(String fieldName) {\n        Tokenizer tokenizer = new MockTokenizer();\n        if (fieldName.contains(\"payloadsFixed\")) {\n          TokenFilter filter = new MockFixedLengthPayloadFilter(new Random(0), tokenizer, 1);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else if (fieldName.contains(\"payloadsVariable\")) {\n          TokenFilter filter = new MockVariableLengthPayloadFilter(new Random(0), tokenizer);\n          return new TokenStreamComponents(tokenizer, filter);\n        } else {\n          return new TokenStreamComponents(tokenizer);\n        }\n      }\n    };\n    IndexWriterConfig iwc = newIndexWriterConfig(analyzer);\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new Lucene41PostingsFormat()));\n    // TODO we could actually add more fields implemented with different PFs\n    // or, just put this test into the usual rotation?\n    RandomIndexWriter iw = new RandomIndexWriter(random(), dir, iwc);\n    Document doc = new Document();\n    FieldType docsOnlyType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsOnlyType.setStoreTermVectors(true);\n    docsOnlyType.setIndexOptions(IndexOptions.DOCS_ONLY);\n    \n    FieldType docsAndFreqsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn this on for a cross-check\n    docsAndFreqsType.setStoreTermVectors(true);\n    docsAndFreqsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS);\n    \n    FieldType positionsType = new FieldType(TextField.TYPE_NOT_STORED);\n    // turn these on for a cross-check\n    positionsType.setStoreTermVectors(true);\n    positionsType.setStoreTermVectorPositions(true);\n    positionsType.setStoreTermVectorOffsets(true);\n    positionsType.setStoreTermVectorPayloads(true);\n    FieldType offsetsType = new FieldType(positionsType);\n    offsetsType.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);\n    Field field1 = new Field(\"field1docs\", \"\", docsOnlyType);\n    Field field2 = new Field(\"field2freqs\", \"\", docsAndFreqsType);\n    Field field3 = new Field(\"field3positions\", \"\", positionsType);\n    Field field4 = new Field(\"field4offsets\", \"\", offsetsType);\n    Field field5 = new Field(\"field5payloadsFixed\", \"\", positionsType);\n    Field field6 = new Field(\"field6payloadsVariable\", \"\", positionsType);\n    Field field7 = new Field(\"field7payloadsFixedOffsets\", \"\", offsetsType);\n    Field field8 = new Field(\"field8payloadsVariableOffsets\", \"\", offsetsType);\n    doc.add(field1);\n    doc.add(field2);\n    doc.add(field3);\n    doc.add(field4);\n    doc.add(field5);\n    doc.add(field6);\n    doc.add(field7);\n    doc.add(field8);\n    for (int i = 0; i < MAXDOC; i++) {\n      String stringValue = Integer.toString(i) + \" verycommon \" + English.intToEnglish(i).replace('-', ' ') + \" \" + TestUtil.randomSimpleString(random());\n      field1.setStringValue(stringValue);\n      field2.setStringValue(stringValue);\n      field3.setStringValue(stringValue);\n      field4.setStringValue(stringValue);\n      field5.setStringValue(stringValue);\n      field6.setStringValue(stringValue);\n      field7.setStringValue(stringValue);\n      field8.setStringValue(stringValue);\n      iw.addDocument(doc);\n    }\n    iw.close();\n    verify(dir);\n    TestUtil.checkIndex(dir); // for some extra coverage, checkIndex before we forceMerge\n    iwc = newIndexWriterConfig(analyzer);\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new Lucene41PostingsFormat()));\n    iwc.setOpenMode(OpenMode.APPEND);\n    IndexWriter iw2 = new IndexWriter(dir, iwc);\n    iw2.forceMerge(1);\n    iw2.close();\n    verify(dir);\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"99eb4a732d1a908f4636ace52928876136bf1896":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e":["9aafa6ae784e45294cc6d2beb96ad0e5a7a5ce22"],"cfc45818441587d8004ff1a119fb60ac9ecb9a14":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"ae889fd5c8a69f6b5d130d3c895bfa5b04d07338":["38061899d760e06a12fe186bc1f09ca9ff0e64a6"],"6613659748fe4411a7dcf85266e55db1f95f7315":["ae889fd5c8a69f6b5d130d3c895bfa5b04d07338"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","38061899d760e06a12fe186bc1f09ca9ff0e64a6"],"db4fdbf3d262768eabc027cd8321edca0cd11fa8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c7492bcb52be51e55d596134b95b2e53cc4ffb91"],"d33aeb9ed95127e3cb6b2abce6c4b0441e6c3633":["2989b58779e186266a5d5ab0c6fc46096e68b848"],"38061899d760e06a12fe186bc1f09ca9ff0e64a6":["4ce24aa081e44190692bbebc8aead342ad7060e8"],"4ce24aa081e44190692bbebc8aead342ad7060e8":["d33aeb9ed95127e3cb6b2abce6c4b0441e6c3633"],"c7492bcb52be51e55d596134b95b2e53cc4ffb91":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","cf8086c7e11dc41303ef1b8050bd355ddfaee76d"],"cf8086c7e11dc41303ef1b8050bd355ddfaee76d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3fe3dfb6cc2d72874c6ebeee5cf8b6818434714e":["2989b58779e186266a5d5ab0c6fc46096e68b848"],"62e52115b56781006682fd92c6938efaf174304d":["db4fdbf3d262768eabc027cd8321edca0cd11fa8","2989b58779e186266a5d5ab0c6fc46096e68b848"],"2989b58779e186266a5d5ab0c6fc46096e68b848":["c7492bcb52be51e55d596134b95b2e53cc4ffb91"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d0ef034a4f10871667ae75181537775ddcf8ade4":["54a6bea0b991120a99ad0e2f72ae853fd5ecae0e"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":["d33aeb9ed95127e3cb6b2abce6c4b0441e6c3633"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["6613659748fe4411a7dcf85266e55db1f95f7315"],"db68c63cbfaa8698b9c4475f75ed2b9c9696d238":["d0ef034a4f10871667ae75181537775ddcf8ade4","99eb4a732d1a908f4636ace52928876136bf1896"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"9aafa6ae784e45294cc6d2beb96ad0e5a7a5ce22":["cfc45818441587d8004ff1a119fb60ac9ecb9a14"]},"commit2Childs":{"99eb4a732d1a908f4636ace52928876136bf1896":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"cfc45818441587d8004ff1a119fb60ac9ecb9a14":["9aafa6ae784e45294cc6d2beb96ad0e5a7a5ce22"],"ae889fd5c8a69f6b5d130d3c895bfa5b04d07338":["6613659748fe4411a7dcf85266e55db1f95f7315"],"6613659748fe4411a7dcf85266e55db1f95f7315":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":[],"db4fdbf3d262768eabc027cd8321edca0cd11fa8":["62e52115b56781006682fd92c6938efaf174304d"],"d33aeb9ed95127e3cb6b2abce6c4b0441e6c3633":["4ce24aa081e44190692bbebc8aead342ad7060e8","8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee"],"38061899d760e06a12fe186bc1f09ca9ff0e64a6":["ae889fd5c8a69f6b5d130d3c895bfa5b04d07338","3dffec77fb8f7d0e9ca4869dddd6af94528b4576"],"c7492bcb52be51e55d596134b95b2e53cc4ffb91":["db4fdbf3d262768eabc027cd8321edca0cd11fa8","2989b58779e186266a5d5ab0c6fc46096e68b848"],"4ce24aa081e44190692bbebc8aead342ad7060e8":["38061899d760e06a12fe186bc1f09ca9ff0e64a6"],"cf8086c7e11dc41303ef1b8050bd355ddfaee76d":["c7492bcb52be51e55d596134b95b2e53cc4ffb91"],"3fe3dfb6cc2d72874c6ebeee5cf8b6818434714e":[],"62e52115b56781006682fd92c6938efaf174304d":[],"2989b58779e186266a5d5ab0c6fc46096e68b848":["d33aeb9ed95127e3cb6b2abce6c4b0441e6c3633","3fe3dfb6cc2d72874c6ebeee5cf8b6818434714e","62e52115b56781006682fd92c6938efaf174304d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["db4fdbf3d262768eabc027cd8321edca0cd11fa8","c7492bcb52be51e55d596134b95b2e53cc4ffb91","cf8086c7e11dc41303ef1b8050bd355ddfaee76d"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["99eb4a732d1a908f4636ace52928876136bf1896","db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["cfc45818441587d8004ff1a119fb60ac9ecb9a14"],"db68c63cbfaa8698b9c4475f75ed2b9c9696d238":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9aafa6ae784e45294cc6d2beb96ad0e5a7a5ce22":["54a6bea0b991120a99ad0e2f72ae853fd5ecae0e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576","3fe3dfb6cc2d72874c6ebeee5cf8b6818434714e","62e52115b56781006682fd92c6938efaf174304d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}