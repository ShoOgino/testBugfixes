{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","commits":[{"id":"7321b77a7bc3edfebd637ef273e9dfaa9969eba6","date":1333023097,"type":0,"author":"Sami Siren","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","pathOld":"/dev/null","sourceNew":"  public NamedList<Object> request(final SolrRequest request,\n      final ResponseParser processor) throws SolrServerException {\n    HttpRequestBase method = null;\n    SolrParams params = request.getParams();\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    wparams.set(CommonParams.WT, parser.getWriterType());\n    wparams.set(CommonParams.VERSION, parser.getVersion());\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    params = wparams;\n    \n    int tries = maxRetries + 1;\n    try {\n      while (tries-- > 0) { // XXX this retry thing seems noop to me\n        Collection<ContentStream> streams = requestWriter\n            .getContentStreams(request);\n        // Note: since we aren't doing intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if (SolrRequest.METHOD.GET == request.getMethod()) {\n            if (streams != null) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                  \"GET can't send streams!\");\n            }\n            method = new HttpGet(baseUrl + path\n                + ClientUtils.toQueryString(params, false));\n          } else if (SolrRequest.METHOD.POST == request.getMethod()) {\n            String url = baseUrl + path;\n            \n            MultipartEntity entity = new MultipartEntity(\n                HttpMultipartMode.BROWSER_COMPATIBLE);\n            \n            final HttpPost post = new HttpPost(url);\n            \n            final Iterator<String> iter = params.getParameterNamesIterator();\n            if (iter.hasNext()) {\n              \n              while (iter.hasNext()) {\n                final String name = iter.next();\n                final String[] vals = params.getParams(name);\n                if (vals != null) {\n                  for (String value : vals) {\n                    entity.addPart(name, new StringBody(value));\n                  }\n                }\n              }\n            }\n            addParts(streams, entity);\n            post.setEntity(entity);\n            method = post;\n          } else {\n            throw new SolrServerException(\"Unsupported method: \"\n                + request.getMethod());\n          }\n        } catch (RuntimeException r) {\n          // If out of tries then just rethrow (as normal error).\n          if ((tries < 1)) {\n            throw r;\n          }\n          // log.warn( \"Caught: \" + r + \". Retrying...\" );\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    // TODO: move to a interceptor?\n    method.getParams().setParameter(ClientPNames.HANDLE_REDIRECTS,\n        followRedirects);\n    method.addHeader(\"User-Agent\", AGENT);\n    method.setHeader(\"Content-Charset\", UTF_8);\n    method.setHeader(\"Accept-Charset\", UTF_8);\n    \n    InputStream respBody = null;\n    \n    try {\n      // Execute the method.\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      // Read the contents\n      String charset = EntityUtils.getContentCharSet(response.getEntity());\n      respBody = response.getEntity().getContent();\n      \n      // handle some http level checks before trying to parse the response\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        case HttpStatus.SC_NOT_FOUND:\n          throw new SolrServerException(\"Server at \" + getBaseURL()\n              + \" was not found (404).\");\n        default:\n          throw new SolrException(SolrException.ErrorCode.getErrorCode(httpStatus), \"Server at \" + getBaseURL()\n              + \" returned non ok status:\" + httpStatus + \", message:\"\n              + response.getStatusLine().getReasonPhrase());\n          \n      }\n      NamedList<Object> rsp = processor.processResponse(respBody, charset);\n      if (httpStatus != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            // TODO? get the trace?\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase());\n          msg.append(\"\\n\\n\");\n          msg.append(\"request: \" + method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n        }\n        throw new SolrException(\n            SolrException.ErrorCode.getErrorCode(httpStatus), reason);\n      }\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occured while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occured when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (respBody != null) {\n        try {\n          respBody.close();\n        } catch (Throwable t) {} // ignore\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["7a899ae08a2414e44e9aec7db9783e3da08996d9","f1b4258e8d84ded627a66ea993d8c7acdc6ae7ad","f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e6265065eff8fca7d05265677a74384fd538cec3","date":1334776760,"type":3,"author":"Sami Siren","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","sourceNew":"  public NamedList<Object> request(final SolrRequest request,\n      final ResponseParser processor) throws SolrServerException, IOException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    wparams.set(CommonParams.WT, parser.getWriterType());\n    wparams.set(CommonParams.VERSION, parser.getVersion());\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    params = wparams;\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            LinkedList<NameValuePair> postParams = new LinkedList<NameValuePair>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url);\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<FormBodyPart>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                for (ContentStream content : streams) {\n                   parts.add(new FormBodyPart(content.getName(), new InputStreamBody(content.getStream(), content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.BROWSER_COMPATIBLE);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                HttpEntity e;\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    // TODO: move to a interceptor?\n    method.getParams().setParameter(ClientPNames.HANDLE_REDIRECTS,\n        followRedirects);\n    method.addHeader(\"User-Agent\", AGENT);\n    \n    InputStream respBody = null;\n    \n    try {\n      // Execute the method.\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      // Read the contents\n      String charset = EntityUtils.getContentCharSet(response.getEntity());\n      respBody = response.getEntity().getContent();\n      \n      // handle some http level checks before trying to parse the response\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        case HttpStatus.SC_NOT_FOUND:\n          throw new SolrServerException(\"Server at \" + getBaseURL()\n              + \" was not found (404).\");\n        default:\n          throw new SolrException(SolrException.ErrorCode.getErrorCode(httpStatus), \"Server at \" + getBaseURL()\n              + \" returned non ok status:\" + httpStatus + \", message:\"\n              + response.getStatusLine().getReasonPhrase());\n          \n      }\n      NamedList<Object> rsp = processor.processResponse(respBody, charset);\n      if (httpStatus != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            // TODO? get the trace?\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase());\n          msg.append(\"\\n\\n\");\n          msg.append(\"request: \" + method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n        }\n        throw new SolrException(\n            SolrException.ErrorCode.getErrorCode(httpStatus), reason);\n      }\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occured while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occured when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (respBody != null) {\n        try {\n          respBody.close();\n        } catch (Throwable t) {} // ignore\n      }\n    }\n  }\n\n","sourceOld":"  public NamedList<Object> request(final SolrRequest request,\n      final ResponseParser processor) throws SolrServerException {\n    HttpRequestBase method = null;\n    SolrParams params = request.getParams();\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    wparams.set(CommonParams.WT, parser.getWriterType());\n    wparams.set(CommonParams.VERSION, parser.getVersion());\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    params = wparams;\n    \n    int tries = maxRetries + 1;\n    try {\n      while (tries-- > 0) { // XXX this retry thing seems noop to me\n        Collection<ContentStream> streams = requestWriter\n            .getContentStreams(request);\n        // Note: since we aren't doing intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if (SolrRequest.METHOD.GET == request.getMethod()) {\n            if (streams != null) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                  \"GET can't send streams!\");\n            }\n            method = new HttpGet(baseUrl + path\n                + ClientUtils.toQueryString(params, false));\n          } else if (SolrRequest.METHOD.POST == request.getMethod()) {\n            String url = baseUrl + path;\n            \n            MultipartEntity entity = new MultipartEntity(\n                HttpMultipartMode.BROWSER_COMPATIBLE);\n            \n            final HttpPost post = new HttpPost(url);\n            \n            final Iterator<String> iter = params.getParameterNamesIterator();\n            if (iter.hasNext()) {\n              \n              while (iter.hasNext()) {\n                final String name = iter.next();\n                final String[] vals = params.getParams(name);\n                if (vals != null) {\n                  for (String value : vals) {\n                    entity.addPart(name, new StringBody(value));\n                  }\n                }\n              }\n            }\n            addParts(streams, entity);\n            post.setEntity(entity);\n            method = post;\n          } else {\n            throw new SolrServerException(\"Unsupported method: \"\n                + request.getMethod());\n          }\n        } catch (RuntimeException r) {\n          // If out of tries then just rethrow (as normal error).\n          if ((tries < 1)) {\n            throw r;\n          }\n          // log.warn( \"Caught: \" + r + \". Retrying...\" );\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    // TODO: move to a interceptor?\n    method.getParams().setParameter(ClientPNames.HANDLE_REDIRECTS,\n        followRedirects);\n    method.addHeader(\"User-Agent\", AGENT);\n    method.setHeader(\"Content-Charset\", UTF_8);\n    method.setHeader(\"Accept-Charset\", UTF_8);\n    \n    InputStream respBody = null;\n    \n    try {\n      // Execute the method.\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      // Read the contents\n      String charset = EntityUtils.getContentCharSet(response.getEntity());\n      respBody = response.getEntity().getContent();\n      \n      // handle some http level checks before trying to parse the response\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        case HttpStatus.SC_NOT_FOUND:\n          throw new SolrServerException(\"Server at \" + getBaseURL()\n              + \" was not found (404).\");\n        default:\n          throw new SolrException(SolrException.ErrorCode.getErrorCode(httpStatus), \"Server at \" + getBaseURL()\n              + \" returned non ok status:\" + httpStatus + \", message:\"\n              + response.getStatusLine().getReasonPhrase());\n          \n      }\n      NamedList<Object> rsp = processor.processResponse(respBody, charset);\n      if (httpStatus != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            // TODO? get the trace?\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase());\n          msg.append(\"\\n\\n\");\n          msg.append(\"request: \" + method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n        }\n        throw new SolrException(\n            SolrException.ErrorCode.getErrorCode(httpStatus), reason);\n      }\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occured while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occured when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (respBody != null) {\n        try {\n          respBody.close();\n        } catch (Throwable t) {} // ignore\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["db38df1327eb9a91d4f733219b3865b3af2650fa"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"70b0517a5cc408febadb78196f1d6938f7fbff13","date":1334961703,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","sourceNew":"  public NamedList<Object> request(final SolrRequest request,\n      final ResponseParser processor) throws SolrServerException, IOException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    wparams.set(CommonParams.WT, parser.getWriterType());\n    wparams.set(CommonParams.VERSION, parser.getVersion());\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    params = wparams;\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            LinkedList<NameValuePair> postParams = new LinkedList<NameValuePair>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url);\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<FormBodyPart>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                for (ContentStream content : streams) {\n                   parts.add(new FormBodyPart(content.getName(), \n                       new InputStreamBody(\n                           content.getStream(), \n                           content.getContentType(), \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.BROWSER_COMPATIBLE);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                HttpEntity e;\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    // TODO: move to a interceptor?\n    method.getParams().setParameter(ClientPNames.HANDLE_REDIRECTS,\n        followRedirects);\n    method.addHeader(\"User-Agent\", AGENT);\n    \n    InputStream respBody = null;\n    \n    try {\n      // Execute the method.\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      // Read the contents\n      String charset = EntityUtils.getContentCharSet(response.getEntity());\n      respBody = response.getEntity().getContent();\n      \n      // handle some http level checks before trying to parse the response\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        case HttpStatus.SC_NOT_FOUND:\n          throw new SolrServerException(\"Server at \" + getBaseURL()\n              + \" was not found (404).\");\n        default:\n          throw new SolrException(SolrException.ErrorCode.getErrorCode(httpStatus), \"Server at \" + getBaseURL()\n              + \" returned non ok status:\" + httpStatus + \", message:\"\n              + response.getStatusLine().getReasonPhrase());\n          \n      }\n      NamedList<Object> rsp = processor.processResponse(respBody, charset);\n      if (httpStatus != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            // TODO? get the trace?\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase());\n          msg.append(\"\\n\\n\");\n          msg.append(\"request: \" + method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n        }\n        throw new SolrException(\n            SolrException.ErrorCode.getErrorCode(httpStatus), reason);\n      }\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occured while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occured when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (respBody != null) {\n        try {\n          respBody.close();\n        } catch (Throwable t) {} // ignore\n      }\n    }\n  }\n\n","sourceOld":"  public NamedList<Object> request(final SolrRequest request,\n      final ResponseParser processor) throws SolrServerException, IOException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    wparams.set(CommonParams.WT, parser.getWriterType());\n    wparams.set(CommonParams.VERSION, parser.getVersion());\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    params = wparams;\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            LinkedList<NameValuePair> postParams = new LinkedList<NameValuePair>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url);\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<FormBodyPart>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                for (ContentStream content : streams) {\n                   parts.add(new FormBodyPart(content.getName(), new InputStreamBody(content.getStream(), content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.BROWSER_COMPATIBLE);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                HttpEntity e;\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    // TODO: move to a interceptor?\n    method.getParams().setParameter(ClientPNames.HANDLE_REDIRECTS,\n        followRedirects);\n    method.addHeader(\"User-Agent\", AGENT);\n    \n    InputStream respBody = null;\n    \n    try {\n      // Execute the method.\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      // Read the contents\n      String charset = EntityUtils.getContentCharSet(response.getEntity());\n      respBody = response.getEntity().getContent();\n      \n      // handle some http level checks before trying to parse the response\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        case HttpStatus.SC_NOT_FOUND:\n          throw new SolrServerException(\"Server at \" + getBaseURL()\n              + \" was not found (404).\");\n        default:\n          throw new SolrException(SolrException.ErrorCode.getErrorCode(httpStatus), \"Server at \" + getBaseURL()\n              + \" returned non ok status:\" + httpStatus + \", message:\"\n              + response.getStatusLine().getReasonPhrase());\n          \n      }\n      NamedList<Object> rsp = processor.processResponse(respBody, charset);\n      if (httpStatus != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            // TODO? get the trace?\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase());\n          msg.append(\"\\n\\n\");\n          msg.append(\"request: \" + method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n        }\n        throw new SolrException(\n            SolrException.ErrorCode.getErrorCode(httpStatus), reason);\n      }\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occured while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occured when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (respBody != null) {\n        try {\n          respBody.close();\n        } catch (Throwable t) {} // ignore\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"52fffe2fb680c61aa1d03f7a774e3def8126203a","date":1334965470,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","sourceNew":"  public NamedList<Object> request(final SolrRequest request,\n      final ResponseParser processor) throws SolrServerException, IOException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    wparams.set(CommonParams.WT, parser.getWriterType());\n    wparams.set(CommonParams.VERSION, parser.getVersion());\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    params = wparams;\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            LinkedList<NameValuePair> postParams = new LinkedList<NameValuePair>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url);\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<FormBodyPart>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = \"application/octet-stream\"; // default\n                  }\n                  parts.add(new FormBodyPart(content.getName(), \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.BROWSER_COMPATIBLE);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                HttpEntity e;\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    // TODO: move to a interceptor?\n    method.getParams().setParameter(ClientPNames.HANDLE_REDIRECTS,\n        followRedirects);\n    method.addHeader(\"User-Agent\", AGENT);\n    \n    InputStream respBody = null;\n    \n    try {\n      // Execute the method.\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      // Read the contents\n      String charset = EntityUtils.getContentCharSet(response.getEntity());\n      respBody = response.getEntity().getContent();\n      \n      // handle some http level checks before trying to parse the response\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        case HttpStatus.SC_NOT_FOUND:\n          throw new SolrServerException(\"Server at \" + getBaseURL()\n              + \" was not found (404).\");\n        default:\n          throw new SolrException(SolrException.ErrorCode.getErrorCode(httpStatus), \"Server at \" + getBaseURL()\n              + \" returned non ok status:\" + httpStatus + \", message:\"\n              + response.getStatusLine().getReasonPhrase());\n          \n      }\n      NamedList<Object> rsp = processor.processResponse(respBody, charset);\n      if (httpStatus != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            // TODO? get the trace?\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase());\n          msg.append(\"\\n\\n\");\n          msg.append(\"request: \" + method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n        }\n        throw new SolrException(\n            SolrException.ErrorCode.getErrorCode(httpStatus), reason);\n      }\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occured while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occured when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (respBody != null) {\n        try {\n          respBody.close();\n        } catch (Throwable t) {} // ignore\n      }\n    }\n  }\n\n","sourceOld":"  public NamedList<Object> request(final SolrRequest request,\n      final ResponseParser processor) throws SolrServerException, IOException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    wparams.set(CommonParams.WT, parser.getWriterType());\n    wparams.set(CommonParams.VERSION, parser.getVersion());\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    params = wparams;\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            LinkedList<NameValuePair> postParams = new LinkedList<NameValuePair>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url);\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<FormBodyPart>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                for (ContentStream content : streams) {\n                   parts.add(new FormBodyPart(content.getName(), \n                       new InputStreamBody(\n                           content.getStream(), \n                           content.getContentType(), \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.BROWSER_COMPATIBLE);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                HttpEntity e;\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    // TODO: move to a interceptor?\n    method.getParams().setParameter(ClientPNames.HANDLE_REDIRECTS,\n        followRedirects);\n    method.addHeader(\"User-Agent\", AGENT);\n    \n    InputStream respBody = null;\n    \n    try {\n      // Execute the method.\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      // Read the contents\n      String charset = EntityUtils.getContentCharSet(response.getEntity());\n      respBody = response.getEntity().getContent();\n      \n      // handle some http level checks before trying to parse the response\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        case HttpStatus.SC_NOT_FOUND:\n          throw new SolrServerException(\"Server at \" + getBaseURL()\n              + \" was not found (404).\");\n        default:\n          throw new SolrException(SolrException.ErrorCode.getErrorCode(httpStatus), \"Server at \" + getBaseURL()\n              + \" returned non ok status:\" + httpStatus + \", message:\"\n              + response.getStatusLine().getReasonPhrase());\n          \n      }\n      NamedList<Object> rsp = processor.processResponse(respBody, charset);\n      if (httpStatus != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            // TODO? get the trace?\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase());\n          msg.append(\"\\n\\n\");\n          msg.append(\"request: \" + method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n        }\n        throw new SolrException(\n            SolrException.ErrorCode.getErrorCode(httpStatus), reason);\n      }\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occured while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occured when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (respBody != null) {\n        try {\n          respBody.close();\n        } catch (Throwable t) {} // ignore\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["7a899ae08a2414e44e9aec7db9783e3da08996d9","db38df1327eb9a91d4f733219b3865b3af2650fa"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"054986425ac6be57638da07535df74c6b9dbcb99","date":1335442678,"type":3,"author":"Sami Siren","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","sourceNew":"  public NamedList<Object> request(final SolrRequest request,\n      final ResponseParser processor) throws SolrServerException, IOException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    wparams.set(CommonParams.WT, parser.getWriterType());\n    wparams.set(CommonParams.VERSION, parser.getVersion());\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    params = wparams;\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            LinkedList<NameValuePair> postParams = new LinkedList<NameValuePair>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url);\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<FormBodyPart>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = \"application/octet-stream\"; // default\n                  }\n                  parts.add(new FormBodyPart(content.getName(), \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                HttpEntity e;\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    // TODO: move to a interceptor?\n    method.getParams().setParameter(ClientPNames.HANDLE_REDIRECTS,\n        followRedirects);\n    method.addHeader(\"User-Agent\", AGENT);\n    \n    InputStream respBody = null;\n    \n    try {\n      // Execute the method.\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      // Read the contents\n      String charset = EntityUtils.getContentCharSet(response.getEntity());\n      respBody = response.getEntity().getContent();\n      \n      // handle some http level checks before trying to parse the response\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        case HttpStatus.SC_NOT_FOUND:\n          throw new SolrServerException(\"Server at \" + getBaseURL()\n              + \" was not found (404).\");\n        default:\n          throw new SolrException(SolrException.ErrorCode.getErrorCode(httpStatus), \"Server at \" + getBaseURL()\n              + \" returned non ok status:\" + httpStatus + \", message:\"\n              + response.getStatusLine().getReasonPhrase());\n          \n      }\n      NamedList<Object> rsp = processor.processResponse(respBody, charset);\n      if (httpStatus != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            // TODO? get the trace?\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase());\n          msg.append(\"\\n\\n\");\n          msg.append(\"request: \" + method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n        }\n        throw new SolrException(\n            SolrException.ErrorCode.getErrorCode(httpStatus), reason);\n      }\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occured while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occured when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (respBody != null) {\n        try {\n          respBody.close();\n        } catch (Throwable t) {} // ignore\n      }\n    }\n  }\n\n","sourceOld":"  public NamedList<Object> request(final SolrRequest request,\n      final ResponseParser processor) throws SolrServerException, IOException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    wparams.set(CommonParams.WT, parser.getWriterType());\n    wparams.set(CommonParams.VERSION, parser.getVersion());\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    params = wparams;\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            LinkedList<NameValuePair> postParams = new LinkedList<NameValuePair>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url);\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<FormBodyPart>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = \"application/octet-stream\"; // default\n                  }\n                  parts.add(new FormBodyPart(content.getName(), \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.BROWSER_COMPATIBLE);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                HttpEntity e;\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    // TODO: move to a interceptor?\n    method.getParams().setParameter(ClientPNames.HANDLE_REDIRECTS,\n        followRedirects);\n    method.addHeader(\"User-Agent\", AGENT);\n    \n    InputStream respBody = null;\n    \n    try {\n      // Execute the method.\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      // Read the contents\n      String charset = EntityUtils.getContentCharSet(response.getEntity());\n      respBody = response.getEntity().getContent();\n      \n      // handle some http level checks before trying to parse the response\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        case HttpStatus.SC_NOT_FOUND:\n          throw new SolrServerException(\"Server at \" + getBaseURL()\n              + \" was not found (404).\");\n        default:\n          throw new SolrException(SolrException.ErrorCode.getErrorCode(httpStatus), \"Server at \" + getBaseURL()\n              + \" returned non ok status:\" + httpStatus + \", message:\"\n              + response.getStatusLine().getReasonPhrase());\n          \n      }\n      NamedList<Object> rsp = processor.processResponse(respBody, charset);\n      if (httpStatus != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            // TODO? get the trace?\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase());\n          msg.append(\"\\n\\n\");\n          msg.append(\"request: \" + method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n        }\n        throw new SolrException(\n            SolrException.ErrorCode.getErrorCode(httpStatus), reason);\n      }\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occured while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occured when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (respBody != null) {\n        try {\n          respBody.close();\n        } catch (Throwable t) {} // ignore\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1bea3922196318026c4274f2013416acb60c691e","date":1336496433,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","sourceNew":"  public NamedList<Object> request(final SolrRequest request,\n      final ResponseParser processor) throws SolrServerException, IOException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    wparams.set(CommonParams.WT, parser.getWriterType());\n    wparams.set(CommonParams.VERSION, parser.getVersion());\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    params = wparams;\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            LinkedList<NameValuePair> postParams = new LinkedList<NameValuePair>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url);\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<FormBodyPart>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = \"application/octet-stream\"; // default\n                  }\n                  parts.add(new FormBodyPart(content.getName(), \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                HttpEntity e;\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    // TODO: move to a interceptor?\n    method.getParams().setParameter(ClientPNames.HANDLE_REDIRECTS,\n        followRedirects);\n    method.addHeader(\"User-Agent\", AGENT);\n    \n    InputStream respBody = null;\n    \n    try {\n      // Execute the method.\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      // Read the contents\n      String charset = EntityUtils.getContentCharSet(response.getEntity());\n      respBody = response.getEntity().getContent();\n      \n      // handle some http level checks before trying to parse the response\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n        case HttpStatus.SC_CONFLICT:  // 409\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        case HttpStatus.SC_NOT_FOUND:\n          throw new SolrServerException(\"Server at \" + getBaseURL()\n              + \" was not found (404).\");\n        default:\n          throw new SolrException(SolrException.ErrorCode.getErrorCode(httpStatus), \"Server at \" + getBaseURL()\n              + \" returned non ok status:\" + httpStatus + \", message:\"\n              + response.getStatusLine().getReasonPhrase());\n          \n      }\n      NamedList<Object> rsp = processor.processResponse(respBody, charset);\n      if (httpStatus != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            // TODO? get the trace?\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase());\n          msg.append(\"\\n\\n\");\n          msg.append(\"request: \" + method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n        }\n        throw new SolrException(\n            SolrException.ErrorCode.getErrorCode(httpStatus), reason);\n      }\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occured while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occured when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (respBody != null) {\n        try {\n          respBody.close();\n        } catch (Throwable t) {} // ignore\n      }\n    }\n  }\n\n","sourceOld":"  public NamedList<Object> request(final SolrRequest request,\n      final ResponseParser processor) throws SolrServerException, IOException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    wparams.set(CommonParams.WT, parser.getWriterType());\n    wparams.set(CommonParams.VERSION, parser.getVersion());\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    params = wparams;\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            LinkedList<NameValuePair> postParams = new LinkedList<NameValuePair>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url);\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<FormBodyPart>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = \"application/octet-stream\"; // default\n                  }\n                  parts.add(new FormBodyPart(content.getName(), \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                HttpEntity e;\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    // TODO: move to a interceptor?\n    method.getParams().setParameter(ClientPNames.HANDLE_REDIRECTS,\n        followRedirects);\n    method.addHeader(\"User-Agent\", AGENT);\n    \n    InputStream respBody = null;\n    \n    try {\n      // Execute the method.\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      // Read the contents\n      String charset = EntityUtils.getContentCharSet(response.getEntity());\n      respBody = response.getEntity().getContent();\n      \n      // handle some http level checks before trying to parse the response\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        case HttpStatus.SC_NOT_FOUND:\n          throw new SolrServerException(\"Server at \" + getBaseURL()\n              + \" was not found (404).\");\n        default:\n          throw new SolrException(SolrException.ErrorCode.getErrorCode(httpStatus), \"Server at \" + getBaseURL()\n              + \" returned non ok status:\" + httpStatus + \", message:\"\n              + response.getStatusLine().getReasonPhrase());\n          \n      }\n      NamedList<Object> rsp = processor.processResponse(respBody, charset);\n      if (httpStatus != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            // TODO? get the trace?\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase());\n          msg.append(\"\\n\\n\");\n          msg.append(\"request: \" + method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n        }\n        throw new SolrException(\n            SolrException.ErrorCode.getErrorCode(httpStatus), reason);\n      }\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occured while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occured when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (respBody != null) {\n        try {\n          respBody.close();\n        } catch (Throwable t) {} // ignore\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"eb99886ff640d94edb43e0d36112a2b7023379ba","date":1338292884,"type":3,"author":"Sami Siren","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","sourceNew":"  public NamedList<Object> request(final SolrRequest request,\n      final ResponseParser processor) throws SolrServerException, IOException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    wparams.set(CommonParams.WT, parser.getWriterType());\n    wparams.set(CommonParams.VERSION, parser.getVersion());\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    params = wparams;\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            LinkedList<NameValuePair> postParams = new LinkedList<NameValuePair>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url);\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<FormBodyPart>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = \"application/octet-stream\"; // default\n                  }\n                  parts.add(new FormBodyPart(content.getName(), \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    // XXX client already has this set, is this needed?\n    method.getParams().setParameter(ClientPNames.HANDLE_REDIRECTS,\n        followRedirects);\n    method.addHeader(\"User-Agent\", AGENT);\n    \n    InputStream respBody = null;\n    \n    try {\n      // Execute the method.\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      // Read the contents\n      String charset = EntityUtils.getContentCharSet(response.getEntity());\n      respBody = response.getEntity().getContent();\n      \n      // handle some http level checks before trying to parse the response\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n        case HttpStatus.SC_CONFLICT:  // 409\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        case HttpStatus.SC_NOT_FOUND:\n          throw new SolrServerException(\"Server at \" + getBaseURL()\n              + \" was not found (404).\");\n        default:\n          throw new SolrException(SolrException.ErrorCode.getErrorCode(httpStatus), \"Server at \" + getBaseURL()\n              + \" returned non ok status:\" + httpStatus + \", message:\"\n              + response.getStatusLine().getReasonPhrase());\n          \n      }\n      NamedList<Object> rsp = processor.processResponse(respBody, charset);\n      if (httpStatus != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            // TODO? get the trace?\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase());\n          msg.append(\"\\n\\n\");\n          msg.append(\"request: \" + method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n        }\n        throw new SolrException(\n            SolrException.ErrorCode.getErrorCode(httpStatus), reason);\n      }\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occured while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occured when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (respBody != null) {\n        try {\n          respBody.close();\n        } catch (Throwable t) {} // ignore\n      }\n    }\n  }\n\n","sourceOld":"  public NamedList<Object> request(final SolrRequest request,\n      final ResponseParser processor) throws SolrServerException, IOException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    wparams.set(CommonParams.WT, parser.getWriterType());\n    wparams.set(CommonParams.VERSION, parser.getVersion());\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    params = wparams;\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            LinkedList<NameValuePair> postParams = new LinkedList<NameValuePair>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url);\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<FormBodyPart>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = \"application/octet-stream\"; // default\n                  }\n                  parts.add(new FormBodyPart(content.getName(), \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                HttpEntity e;\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    // TODO: move to a interceptor?\n    method.getParams().setParameter(ClientPNames.HANDLE_REDIRECTS,\n        followRedirects);\n    method.addHeader(\"User-Agent\", AGENT);\n    \n    InputStream respBody = null;\n    \n    try {\n      // Execute the method.\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      // Read the contents\n      String charset = EntityUtils.getContentCharSet(response.getEntity());\n      respBody = response.getEntity().getContent();\n      \n      // handle some http level checks before trying to parse the response\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n        case HttpStatus.SC_CONFLICT:  // 409\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        case HttpStatus.SC_NOT_FOUND:\n          throw new SolrServerException(\"Server at \" + getBaseURL()\n              + \" was not found (404).\");\n        default:\n          throw new SolrException(SolrException.ErrorCode.getErrorCode(httpStatus), \"Server at \" + getBaseURL()\n              + \" returned non ok status:\" + httpStatus + \", message:\"\n              + response.getStatusLine().getReasonPhrase());\n          \n      }\n      NamedList<Object> rsp = processor.processResponse(respBody, charset);\n      if (httpStatus != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            // TODO? get the trace?\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase());\n          msg.append(\"\\n\\n\");\n          msg.append(\"request: \" + method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n        }\n        throw new SolrException(\n            SolrException.ErrorCode.getErrorCode(httpStatus), reason);\n      }\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occured while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occured when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (respBody != null) {\n        try {\n          respBody.close();\n        } catch (Throwable t) {} // ignore\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f2425308ebcd91b538a601df94ae1551ccaab2bb","date":1340702883,"type":3,"author":"Sami Siren","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","sourceNew":"  public NamedList<Object> request(final SolrRequest request,\n      final ResponseParser processor) throws SolrServerException, IOException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    params = wparams;\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            LinkedList<NameValuePair> postParams = new LinkedList<NameValuePair>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url);\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<FormBodyPart>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = \"application/octet-stream\"; // default\n                  }\n                  parts.add(new FormBodyPart(content.getName(), \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    // XXX client already has this set, is this needed?\n    method.getParams().setParameter(ClientPNames.HANDLE_REDIRECTS,\n        followRedirects);\n    method.addHeader(\"User-Agent\", AGENT);\n    \n    InputStream respBody = null;\n    \n    try {\n      // Execute the method.\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      // Read the contents\n      respBody = response.getEntity().getContent();\n      \n      // handle some http level checks before trying to parse the response\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n        case HttpStatus.SC_CONFLICT:  // 409\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        case HttpStatus.SC_NOT_FOUND:\n          throw new SolrServerException(\"Server at \" + getBaseURL()\n              + \" was not found (404).\");\n        default:\n          throw new SolrException(SolrException.ErrorCode.getErrorCode(httpStatus), \"Server at \" + getBaseURL()\n              + \" returned non ok status:\" + httpStatus + \", message:\"\n              + response.getStatusLine().getReasonPhrase());\n          \n      }\n      if (processor == null) {\n        // no processor specified, return raw stream\n        NamedList<Object> rsp = new NamedList<Object>();\n        rsp.add(\"stream\", respBody);\n        return rsp;\n      }\n      String charset = EntityUtils.getContentCharSet(response.getEntity());\n      NamedList<Object> rsp = processor.processResponse(respBody, charset);\n      if (httpStatus != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            // TODO? get the trace?\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase());\n          msg.append(\"\\n\\n\");\n          msg.append(\"request: \" + method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n        }\n        throw new SolrException(\n            SolrException.ErrorCode.getErrorCode(httpStatus), reason);\n      }\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occured while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occured when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (respBody != null && processor!=null) {\n        try {\n          respBody.close();\n        } catch (Throwable t) {} // ignore\n      }\n    }\n  }\n\n","sourceOld":"  public NamedList<Object> request(final SolrRequest request,\n      final ResponseParser processor) throws SolrServerException, IOException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    wparams.set(CommonParams.WT, parser.getWriterType());\n    wparams.set(CommonParams.VERSION, parser.getVersion());\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    params = wparams;\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            LinkedList<NameValuePair> postParams = new LinkedList<NameValuePair>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url);\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<FormBodyPart>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = \"application/octet-stream\"; // default\n                  }\n                  parts.add(new FormBodyPart(content.getName(), \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    // XXX client already has this set, is this needed?\n    method.getParams().setParameter(ClientPNames.HANDLE_REDIRECTS,\n        followRedirects);\n    method.addHeader(\"User-Agent\", AGENT);\n    \n    InputStream respBody = null;\n    \n    try {\n      // Execute the method.\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      // Read the contents\n      String charset = EntityUtils.getContentCharSet(response.getEntity());\n      respBody = response.getEntity().getContent();\n      \n      // handle some http level checks before trying to parse the response\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n        case HttpStatus.SC_CONFLICT:  // 409\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        case HttpStatus.SC_NOT_FOUND:\n          throw new SolrServerException(\"Server at \" + getBaseURL()\n              + \" was not found (404).\");\n        default:\n          throw new SolrException(SolrException.ErrorCode.getErrorCode(httpStatus), \"Server at \" + getBaseURL()\n              + \" returned non ok status:\" + httpStatus + \", message:\"\n              + response.getStatusLine().getReasonPhrase());\n          \n      }\n      NamedList<Object> rsp = processor.processResponse(respBody, charset);\n      if (httpStatus != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            // TODO? get the trace?\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase());\n          msg.append(\"\\n\\n\");\n          msg.append(\"request: \" + method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n        }\n        throw new SolrException(\n            SolrException.ErrorCode.getErrorCode(httpStatus), reason);\n      }\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occured while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occured when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (respBody != null) {\n        try {\n          respBody.close();\n        } catch (Throwable t) {} // ignore\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["f7eb24c6d5e358d7d23adf107b71f769ffba6162"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f95bfa4089ad59d67823e4a5939995f8eec11b7e","date":1342705795,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","sourceNew":"  public NamedList<Object> request(final SolrRequest request,\n      final ResponseParser processor) throws SolrServerException, IOException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    params = wparams;\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            LinkedList<NameValuePair> postParams = new LinkedList<NameValuePair>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url);\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<FormBodyPart>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = \"application/octet-stream\"; // default\n                  }\n                  parts.add(new FormBodyPart(content.getName(), \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    // XXX client already has this set, is this needed?\n    method.getParams().setParameter(ClientPNames.HANDLE_REDIRECTS,\n        followRedirects);\n    method.addHeader(\"User-Agent\", AGENT);\n    \n    InputStream respBody = null;\n    \n    try {\n      // Execute the method.\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      // Read the contents\n      respBody = response.getEntity().getContent();\n      \n      // handle some http level checks before trying to parse the response\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n        case HttpStatus.SC_CONFLICT:  // 409\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        default:\n          throw new SolrException(SolrException.ErrorCode.getErrorCode(httpStatus), \"Server at \" + getBaseURL()\n              + \" returned non ok status:\" + httpStatus + \", message:\"\n              + response.getStatusLine().getReasonPhrase());\n          \n      }\n      if (processor == null) {\n        // no processor specified, return raw stream\n        NamedList<Object> rsp = new NamedList<Object>();\n        rsp.add(\"stream\", respBody);\n        return rsp;\n      }\n      String charset = EntityUtils.getContentCharSet(response.getEntity());\n      NamedList<Object> rsp = processor.processResponse(respBody, charset);\n      if (httpStatus != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            // TODO? get the trace?\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase());\n          msg.append(\"\\n\\n\");\n          msg.append(\"request: \" + method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n        }\n        throw new SolrException(\n            SolrException.ErrorCode.getErrorCode(httpStatus), reason);\n      }\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occured while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occured when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (respBody != null && processor!=null) {\n        try {\n          respBody.close();\n        } catch (Throwable t) {} // ignore\n      }\n    }\n  }\n\n","sourceOld":"  public NamedList<Object> request(final SolrRequest request,\n      final ResponseParser processor) throws SolrServerException, IOException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    params = wparams;\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            LinkedList<NameValuePair> postParams = new LinkedList<NameValuePair>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url);\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<FormBodyPart>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = \"application/octet-stream\"; // default\n                  }\n                  parts.add(new FormBodyPart(content.getName(), \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    // XXX client already has this set, is this needed?\n    method.getParams().setParameter(ClientPNames.HANDLE_REDIRECTS,\n        followRedirects);\n    method.addHeader(\"User-Agent\", AGENT);\n    \n    InputStream respBody = null;\n    \n    try {\n      // Execute the method.\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      // Read the contents\n      respBody = response.getEntity().getContent();\n      \n      // handle some http level checks before trying to parse the response\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n        case HttpStatus.SC_CONFLICT:  // 409\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        case HttpStatus.SC_NOT_FOUND:\n          throw new SolrServerException(\"Server at \" + getBaseURL()\n              + \" was not found (404).\");\n        default:\n          throw new SolrException(SolrException.ErrorCode.getErrorCode(httpStatus), \"Server at \" + getBaseURL()\n              + \" returned non ok status:\" + httpStatus + \", message:\"\n              + response.getStatusLine().getReasonPhrase());\n          \n      }\n      if (processor == null) {\n        // no processor specified, return raw stream\n        NamedList<Object> rsp = new NamedList<Object>();\n        rsp.add(\"stream\", respBody);\n        return rsp;\n      }\n      String charset = EntityUtils.getContentCharSet(response.getEntity());\n      NamedList<Object> rsp = processor.processResponse(respBody, charset);\n      if (httpStatus != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            // TODO? get the trace?\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase());\n          msg.append(\"\\n\\n\");\n          msg.append(\"request: \" + method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n        }\n        throw new SolrException(\n            SolrException.ErrorCode.getErrorCode(httpStatus), reason);\n      }\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occured while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occured when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (respBody != null && processor!=null) {\n        try {\n          respBody.close();\n        } catch (Throwable t) {} // ignore\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","sourceNew":"  public NamedList<Object> request(final SolrRequest request,\n      final ResponseParser processor) throws SolrServerException, IOException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    params = wparams;\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            LinkedList<NameValuePair> postParams = new LinkedList<NameValuePair>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url);\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<FormBodyPart>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = \"application/octet-stream\"; // default\n                  }\n                  parts.add(new FormBodyPart(content.getName(), \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    // XXX client already has this set, is this needed?\n    method.getParams().setParameter(ClientPNames.HANDLE_REDIRECTS,\n        followRedirects);\n    method.addHeader(\"User-Agent\", AGENT);\n    \n    InputStream respBody = null;\n    \n    try {\n      // Execute the method.\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      // Read the contents\n      respBody = response.getEntity().getContent();\n      \n      // handle some http level checks before trying to parse the response\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n        case HttpStatus.SC_CONFLICT:  // 409\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        default:\n          throw new SolrException(SolrException.ErrorCode.getErrorCode(httpStatus), \"Server at \" + getBaseURL()\n              + \" returned non ok status:\" + httpStatus + \", message:\"\n              + response.getStatusLine().getReasonPhrase());\n          \n      }\n      if (processor == null) {\n        // no processor specified, return raw stream\n        NamedList<Object> rsp = new NamedList<Object>();\n        rsp.add(\"stream\", respBody);\n        return rsp;\n      }\n      String charset = EntityUtils.getContentCharSet(response.getEntity());\n      NamedList<Object> rsp = processor.processResponse(respBody, charset);\n      if (httpStatus != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            // TODO? get the trace?\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase());\n          msg.append(\"\\n\\n\");\n          msg.append(\"request: \" + method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n        }\n        throw new SolrException(\n            SolrException.ErrorCode.getErrorCode(httpStatus), reason);\n      }\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occured while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occured when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (respBody != null && processor!=null) {\n        try {\n          respBody.close();\n        } catch (Throwable t) {} // ignore\n      }\n    }\n  }\n\n","sourceOld":"  public NamedList<Object> request(final SolrRequest request,\n      final ResponseParser processor) throws SolrServerException, IOException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    wparams.set(CommonParams.WT, parser.getWriterType());\n    wparams.set(CommonParams.VERSION, parser.getVersion());\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    params = wparams;\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            LinkedList<NameValuePair> postParams = new LinkedList<NameValuePair>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url);\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<FormBodyPart>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = \"application/octet-stream\"; // default\n                  }\n                  parts.add(new FormBodyPart(content.getName(), \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    // XXX client already has this set, is this needed?\n    method.getParams().setParameter(ClientPNames.HANDLE_REDIRECTS,\n        followRedirects);\n    method.addHeader(\"User-Agent\", AGENT);\n    \n    InputStream respBody = null;\n    \n    try {\n      // Execute the method.\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      // Read the contents\n      String charset = EntityUtils.getContentCharSet(response.getEntity());\n      respBody = response.getEntity().getContent();\n      \n      // handle some http level checks before trying to parse the response\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n        case HttpStatus.SC_CONFLICT:  // 409\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        case HttpStatus.SC_NOT_FOUND:\n          throw new SolrServerException(\"Server at \" + getBaseURL()\n              + \" was not found (404).\");\n        default:\n          throw new SolrException(SolrException.ErrorCode.getErrorCode(httpStatus), \"Server at \" + getBaseURL()\n              + \" returned non ok status:\" + httpStatus + \", message:\"\n              + response.getStatusLine().getReasonPhrase());\n          \n      }\n      NamedList<Object> rsp = processor.processResponse(respBody, charset);\n      if (httpStatus != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            // TODO? get the trace?\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase());\n          msg.append(\"\\n\\n\");\n          msg.append(\"request: \" + method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n        }\n        throw new SolrException(\n            SolrException.ErrorCode.getErrorCode(httpStatus), reason);\n      }\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occured while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occured when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (respBody != null) {\n        try {\n          respBody.close();\n        } catch (Throwable t) {} // ignore\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","sourceNew":"  public NamedList<Object> request(final SolrRequest request,\n      final ResponseParser processor) throws SolrServerException, IOException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    params = wparams;\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            LinkedList<NameValuePair> postParams = new LinkedList<NameValuePair>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url);\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<FormBodyPart>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = \"application/octet-stream\"; // default\n                  }\n                  parts.add(new FormBodyPart(content.getName(), \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    // XXX client already has this set, is this needed?\n    method.getParams().setParameter(ClientPNames.HANDLE_REDIRECTS,\n        followRedirects);\n    method.addHeader(\"User-Agent\", AGENT);\n    \n    InputStream respBody = null;\n    \n    try {\n      // Execute the method.\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      // Read the contents\n      respBody = response.getEntity().getContent();\n      \n      // handle some http level checks before trying to parse the response\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n        case HttpStatus.SC_CONFLICT:  // 409\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        default:\n          throw new SolrException(SolrException.ErrorCode.getErrorCode(httpStatus), \"Server at \" + getBaseURL()\n              + \" returned non ok status:\" + httpStatus + \", message:\"\n              + response.getStatusLine().getReasonPhrase());\n          \n      }\n      if (processor == null) {\n        // no processor specified, return raw stream\n        NamedList<Object> rsp = new NamedList<Object>();\n        rsp.add(\"stream\", respBody);\n        return rsp;\n      }\n      String charset = EntityUtils.getContentCharSet(response.getEntity());\n      NamedList<Object> rsp = processor.processResponse(respBody, charset);\n      if (httpStatus != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            // TODO? get the trace?\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase());\n          msg.append(\"\\n\\n\");\n          msg.append(\"request: \" + method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n        }\n        throw new SolrException(\n            SolrException.ErrorCode.getErrorCode(httpStatus), reason);\n      }\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occured while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occured when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (respBody != null && processor!=null) {\n        try {\n          respBody.close();\n        } catch (Throwable t) {} // ignore\n      }\n    }\n  }\n\n","sourceOld":"  public NamedList<Object> request(final SolrRequest request,\n      final ResponseParser processor) throws SolrServerException, IOException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    params = wparams;\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            LinkedList<NameValuePair> postParams = new LinkedList<NameValuePair>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url);\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<FormBodyPart>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = \"application/octet-stream\"; // default\n                  }\n                  parts.add(new FormBodyPart(content.getName(), \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    // XXX client already has this set, is this needed?\n    method.getParams().setParameter(ClientPNames.HANDLE_REDIRECTS,\n        followRedirects);\n    method.addHeader(\"User-Agent\", AGENT);\n    \n    InputStream respBody = null;\n    \n    try {\n      // Execute the method.\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      // Read the contents\n      respBody = response.getEntity().getContent();\n      \n      // handle some http level checks before trying to parse the response\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n        case HttpStatus.SC_CONFLICT:  // 409\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        case HttpStatus.SC_NOT_FOUND:\n          throw new SolrServerException(\"Server at \" + getBaseURL()\n              + \" was not found (404).\");\n        default:\n          throw new SolrException(SolrException.ErrorCode.getErrorCode(httpStatus), \"Server at \" + getBaseURL()\n              + \" returned non ok status:\" + httpStatus + \", message:\"\n              + response.getStatusLine().getReasonPhrase());\n          \n      }\n      if (processor == null) {\n        // no processor specified, return raw stream\n        NamedList<Object> rsp = new NamedList<Object>();\n        rsp.add(\"stream\", respBody);\n        return rsp;\n      }\n      String charset = EntityUtils.getContentCharSet(response.getEntity());\n      NamedList<Object> rsp = processor.processResponse(respBody, charset);\n      if (httpStatus != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            // TODO? get the trace?\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase());\n          msg.append(\"\\n\\n\");\n          msg.append(\"request: \" + method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n        }\n        throw new SolrException(\n            SolrException.ErrorCode.getErrorCode(httpStatus), reason);\n      }\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occured while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occured when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (respBody != null && processor!=null) {\n        try {\n          respBody.close();\n        } catch (Throwable t) {} // ignore\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f7eb24c6d5e358d7d23adf107b71f769ffba6162","date":1358362607,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","sourceNew":"  public NamedList<Object> request(final SolrRequest request,\n      final ResponseParser processor) throws SolrServerException, IOException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    params = wparams;\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            LinkedList<NameValuePair> postParams = new LinkedList<NameValuePair>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url);\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<FormBodyPart>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = \"application/octet-stream\"; // default\n                  }\n                  parts.add(new FormBodyPart(content.getName(), \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    // XXX client already has this set, is this needed?\n    method.getParams().setParameter(ClientPNames.HANDLE_REDIRECTS,\n        followRedirects);\n    method.addHeader(\"User-Agent\", AGENT);\n    \n    InputStream respBody = null;\n    boolean shouldClose = true;\n    \n    try {\n      // Execute the method.\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      // Read the contents\n      respBody = response.getEntity().getContent();\n      \n      // handle some http level checks before trying to parse the response\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n        case HttpStatus.SC_CONFLICT:  // 409\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        default:\n          throw new SolrException(SolrException.ErrorCode.getErrorCode(httpStatus), \"Server at \" + getBaseURL()\n              + \" returned non ok status:\" + httpStatus + \", message:\"\n              + response.getStatusLine().getReasonPhrase());\n          \n      }\n      if (processor == null) {\n        // no processor specified, return raw stream\n        NamedList<Object> rsp = new NamedList<Object>();\n        rsp.add(\"stream\", respBody);\n        // Only case where stream should not be closed\n        shouldClose = false;\n        return rsp;\n      }\n      String charset = EntityUtils.getContentCharSet(response.getEntity());\n      NamedList<Object> rsp = processor.processResponse(respBody, charset);\n      if (httpStatus != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            // TODO? get the trace?\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase());\n          msg.append(\"\\n\\n\");\n          msg.append(\"request: \" + method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n        }\n        throw new SolrException(\n            SolrException.ErrorCode.getErrorCode(httpStatus), reason);\n      }\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occured while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occured when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (respBody != null && shouldClose) {\n        try {\n          respBody.close();\n        } catch (Throwable t) {} // ignore\n      }\n    }\n  }\n\n","sourceOld":"  public NamedList<Object> request(final SolrRequest request,\n      final ResponseParser processor) throws SolrServerException, IOException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    params = wparams;\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            LinkedList<NameValuePair> postParams = new LinkedList<NameValuePair>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url);\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<FormBodyPart>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = \"application/octet-stream\"; // default\n                  }\n                  parts.add(new FormBodyPart(content.getName(), \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    // XXX client already has this set, is this needed?\n    method.getParams().setParameter(ClientPNames.HANDLE_REDIRECTS,\n        followRedirects);\n    method.addHeader(\"User-Agent\", AGENT);\n    \n    InputStream respBody = null;\n    \n    try {\n      // Execute the method.\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      // Read the contents\n      respBody = response.getEntity().getContent();\n      \n      // handle some http level checks before trying to parse the response\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n        case HttpStatus.SC_CONFLICT:  // 409\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        default:\n          throw new SolrException(SolrException.ErrorCode.getErrorCode(httpStatus), \"Server at \" + getBaseURL()\n              + \" returned non ok status:\" + httpStatus + \", message:\"\n              + response.getStatusLine().getReasonPhrase());\n          \n      }\n      if (processor == null) {\n        // no processor specified, return raw stream\n        NamedList<Object> rsp = new NamedList<Object>();\n        rsp.add(\"stream\", respBody);\n        return rsp;\n      }\n      String charset = EntityUtils.getContentCharSet(response.getEntity());\n      NamedList<Object> rsp = processor.processResponse(respBody, charset);\n      if (httpStatus != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            // TODO? get the trace?\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase());\n          msg.append(\"\\n\\n\");\n          msg.append(\"request: \" + method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n        }\n        throw new SolrException(\n            SolrException.ErrorCode.getErrorCode(httpStatus), reason);\n      }\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occured while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occured when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (respBody != null && processor!=null) {\n        try {\n          respBody.close();\n        } catch (Throwable t) {} // ignore\n      }\n    }\n  }\n\n","bugFix":["f2425308ebcd91b538a601df94ae1551ccaab2bb"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c4015cd39dff8d4dec562d909f9766debac53aa6","date":1358548736,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","sourceNew":"  public NamedList<Object> request(final SolrRequest request,\n      final ResponseParser processor) throws SolrServerException, IOException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    params = wparams;\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            LinkedList<NameValuePair> postParams = new LinkedList<NameValuePair>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url);\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<FormBodyPart>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = \"application/octet-stream\"; // default\n                  }\n                  parts.add(new FormBodyPart(content.getName(), \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    // XXX client already has this set, is this needed?\n    method.getParams().setParameter(ClientPNames.HANDLE_REDIRECTS,\n        followRedirects);\n    method.addHeader(\"User-Agent\", AGENT);\n    \n    InputStream respBody = null;\n    boolean shouldClose = true;\n    \n    try {\n      // Execute the method.\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      // Read the contents\n      respBody = response.getEntity().getContent();\n      \n      // handle some http level checks before trying to parse the response\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n        case HttpStatus.SC_CONFLICT:  // 409\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        default:\n          throw new SolrException(SolrException.ErrorCode.getErrorCode(httpStatus), \"Server at \" + getBaseURL()\n              + \" returned non ok status:\" + httpStatus + \", message:\"\n              + response.getStatusLine().getReasonPhrase());\n          \n      }\n      if (processor == null) {\n        // no processor specified, return raw stream\n        NamedList<Object> rsp = new NamedList<Object>();\n        rsp.add(\"stream\", respBody);\n        // Only case where stream should not be closed\n        shouldClose = false;\n        return rsp;\n      }\n      String charset = EntityUtils.getContentCharSet(response.getEntity());\n      NamedList<Object> rsp = processor.processResponse(respBody, charset);\n      if (httpStatus != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            // TODO? get the trace?\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase());\n          msg.append(\"\\n\\n\");\n          msg.append(\"request: \" + method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n        }\n        throw new SolrException(\n            SolrException.ErrorCode.getErrorCode(httpStatus), reason);\n      }\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occured while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occured when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (respBody != null && shouldClose) {\n        try {\n          respBody.close();\n        } catch (Throwable t) {} // ignore\n      }\n    }\n  }\n\n","sourceOld":"  public NamedList<Object> request(final SolrRequest request,\n      final ResponseParser processor) throws SolrServerException, IOException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    params = wparams;\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            LinkedList<NameValuePair> postParams = new LinkedList<NameValuePair>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url);\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<FormBodyPart>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = \"application/octet-stream\"; // default\n                  }\n                  parts.add(new FormBodyPart(content.getName(), \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    // XXX client already has this set, is this needed?\n    method.getParams().setParameter(ClientPNames.HANDLE_REDIRECTS,\n        followRedirects);\n    method.addHeader(\"User-Agent\", AGENT);\n    \n    InputStream respBody = null;\n    \n    try {\n      // Execute the method.\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      // Read the contents\n      respBody = response.getEntity().getContent();\n      \n      // handle some http level checks before trying to parse the response\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n        case HttpStatus.SC_CONFLICT:  // 409\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        default:\n          throw new SolrException(SolrException.ErrorCode.getErrorCode(httpStatus), \"Server at \" + getBaseURL()\n              + \" returned non ok status:\" + httpStatus + \", message:\"\n              + response.getStatusLine().getReasonPhrase());\n          \n      }\n      if (processor == null) {\n        // no processor specified, return raw stream\n        NamedList<Object> rsp = new NamedList<Object>();\n        rsp.add(\"stream\", respBody);\n        return rsp;\n      }\n      String charset = EntityUtils.getContentCharSet(response.getEntity());\n      NamedList<Object> rsp = processor.processResponse(respBody, charset);\n      if (httpStatus != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            // TODO? get the trace?\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase());\n          msg.append(\"\\n\\n\");\n          msg.append(\"request: \" + method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n        }\n        throw new SolrException(\n            SolrException.ErrorCode.getErrorCode(httpStatus), reason);\n      }\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occured while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occured when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (respBody != null && processor!=null) {\n        try {\n          respBody.close();\n        } catch (Throwable t) {} // ignore\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"936c22f779fb06bef139a9163a9b21efd18bb8dd","date":1366140372,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","sourceNew":"  public NamedList<Object> request(final SolrRequest request,\n      final ResponseParser processor) throws SolrServerException, IOException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( wparams, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            LinkedList<NameValuePair> postParams = new LinkedList<NameValuePair>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url);\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<FormBodyPart>();\n              Iterator<String> iter = wparams.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = wparams.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = \"application/octet-stream\"; // default\n                  }\n                  parts.add(new FormBodyPart(content.getName(), \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              } else {\n                for (ContentStream content : streams) {\n                  if (content.getName() != null) {\n                    postParams.add(new BasicNameValuePair(RESOURCE_NAME, content.getName()));\n                  }\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] != null && contentStream[0].getName() != null) {\n                wparams.set(RESOURCE_NAME, contentStream[0].getName());\n              }\n              String pstr = ClientUtils.toQueryString(wparams, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    // XXX client already has this set, is this needed?\n    method.getParams().setParameter(ClientPNames.HANDLE_REDIRECTS, followRedirects);\n    method.addHeader(\"User-Agent\", AGENT);\n    \n    InputStream respBody = null;\n    boolean shouldClose = true;\n    \n    try {\n      // Execute the method.\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      // Read the contents\n      respBody = response.getEntity().getContent();\n      \n      // handle some http level checks before trying to parse the response\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n        case HttpStatus.SC_CONFLICT:  // 409\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        default:\n          throw new SolrException(SolrException.ErrorCode.getErrorCode(httpStatus), \"Server at \" + getBaseURL()\n              + \" returned non ok status:\" + httpStatus + \", message:\"\n              + response.getStatusLine().getReasonPhrase());\n          \n      }\n      if (processor == null) {\n        // no processor specified, return raw stream\n        NamedList<Object> rsp = new NamedList<Object>();\n        rsp.add(\"stream\", respBody);\n        // Only case where stream should not be closed\n        shouldClose = false;\n        return rsp;\n      }\n      String charset = EntityUtils.getContentCharSet(response.getEntity());\n      NamedList<Object> rsp = processor.processResponse(respBody, charset);\n      if (httpStatus != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            // TODO? get the trace?\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase());\n          msg.append(\"\\n\\n\");\n          msg.append(\"request: \" + method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n        }\n        throw new SolrException(\n            SolrException.ErrorCode.getErrorCode(httpStatus), reason);\n      }\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occured while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occured when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (respBody != null && shouldClose) {\n        try {\n          respBody.close();\n        } catch (Throwable t) {} // ignore\n      }\n    }\n  }\n\n","sourceOld":"  public NamedList<Object> request(final SolrRequest request,\n      final ResponseParser processor) throws SolrServerException, IOException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    params = wparams;\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            LinkedList<NameValuePair> postParams = new LinkedList<NameValuePair>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url);\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<FormBodyPart>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = \"application/octet-stream\"; // default\n                  }\n                  parts.add(new FormBodyPart(content.getName(), \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    // XXX client already has this set, is this needed?\n    method.getParams().setParameter(ClientPNames.HANDLE_REDIRECTS,\n        followRedirects);\n    method.addHeader(\"User-Agent\", AGENT);\n    \n    InputStream respBody = null;\n    boolean shouldClose = true;\n    \n    try {\n      // Execute the method.\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      // Read the contents\n      respBody = response.getEntity().getContent();\n      \n      // handle some http level checks before trying to parse the response\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n        case HttpStatus.SC_CONFLICT:  // 409\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        default:\n          throw new SolrException(SolrException.ErrorCode.getErrorCode(httpStatus), \"Server at \" + getBaseURL()\n              + \" returned non ok status:\" + httpStatus + \", message:\"\n              + response.getStatusLine().getReasonPhrase());\n          \n      }\n      if (processor == null) {\n        // no processor specified, return raw stream\n        NamedList<Object> rsp = new NamedList<Object>();\n        rsp.add(\"stream\", respBody);\n        // Only case where stream should not be closed\n        shouldClose = false;\n        return rsp;\n      }\n      String charset = EntityUtils.getContentCharSet(response.getEntity());\n      NamedList<Object> rsp = processor.processResponse(respBody, charset);\n      if (httpStatus != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            // TODO? get the trace?\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase());\n          msg.append(\"\\n\\n\");\n          msg.append(\"request: \" + method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n        }\n        throw new SolrException(\n            SolrException.ErrorCode.getErrorCode(httpStatus), reason);\n      }\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occured while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occured when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (respBody != null && shouldClose) {\n        try {\n          respBody.close();\n        } catch (Throwable t) {} // ignore\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7d65e2bb40ac4c612ba4b101b445fbe172545043","date":1366155070,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","sourceNew":"  public NamedList<Object> request(final SolrRequest request,\n      final ResponseParser processor) throws SolrServerException, IOException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    params = wparams;\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            LinkedList<NameValuePair> postParams = new LinkedList<NameValuePair>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url);\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<FormBodyPart>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = \"application/octet-stream\"; // default\n                  }\n                  parts.add(new FormBodyPart(content.getName(), \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    // XXX client already has this set, is this needed?\n    method.getParams().setParameter(ClientPNames.HANDLE_REDIRECTS,\n        followRedirects);\n    method.addHeader(\"User-Agent\", AGENT);\n    \n    InputStream respBody = null;\n    boolean shouldClose = true;\n    \n    try {\n      // Execute the method.\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      // Read the contents\n      respBody = response.getEntity().getContent();\n      \n      // handle some http level checks before trying to parse the response\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n        case HttpStatus.SC_CONFLICT:  // 409\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        default:\n          throw new SolrException(SolrException.ErrorCode.getErrorCode(httpStatus), \"Server at \" + getBaseURL()\n              + \" returned non ok status:\" + httpStatus + \", message:\"\n              + response.getStatusLine().getReasonPhrase());\n          \n      }\n      if (processor == null) {\n        // no processor specified, return raw stream\n        NamedList<Object> rsp = new NamedList<Object>();\n        rsp.add(\"stream\", respBody);\n        // Only case where stream should not be closed\n        shouldClose = false;\n        return rsp;\n      }\n      String charset = EntityUtils.getContentCharSet(response.getEntity());\n      NamedList<Object> rsp = processor.processResponse(respBody, charset);\n      if (httpStatus != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            // TODO? get the trace?\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase());\n          msg.append(\"\\n\\n\");\n          msg.append(\"request: \" + method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n        }\n        throw new SolrException(\n            SolrException.ErrorCode.getErrorCode(httpStatus), reason);\n      }\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occured while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occured when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (respBody != null && shouldClose) {\n        try {\n          respBody.close();\n        } catch (Throwable t) {} // ignore\n      }\n    }\n  }\n\n","sourceOld":"  public NamedList<Object> request(final SolrRequest request,\n      final ResponseParser processor) throws SolrServerException, IOException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( wparams, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            LinkedList<NameValuePair> postParams = new LinkedList<NameValuePair>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url);\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<FormBodyPart>();\n              Iterator<String> iter = wparams.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = wparams.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = \"application/octet-stream\"; // default\n                  }\n                  parts.add(new FormBodyPart(content.getName(), \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              } else {\n                for (ContentStream content : streams) {\n                  if (content.getName() != null) {\n                    postParams.add(new BasicNameValuePair(RESOURCE_NAME, content.getName()));\n                  }\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] != null && contentStream[0].getName() != null) {\n                wparams.set(RESOURCE_NAME, contentStream[0].getName());\n              }\n              String pstr = ClientUtils.toQueryString(wparams, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    // XXX client already has this set, is this needed?\n    method.getParams().setParameter(ClientPNames.HANDLE_REDIRECTS, followRedirects);\n    method.addHeader(\"User-Agent\", AGENT);\n    \n    InputStream respBody = null;\n    boolean shouldClose = true;\n    \n    try {\n      // Execute the method.\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      // Read the contents\n      respBody = response.getEntity().getContent();\n      \n      // handle some http level checks before trying to parse the response\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n        case HttpStatus.SC_CONFLICT:  // 409\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        default:\n          throw new SolrException(SolrException.ErrorCode.getErrorCode(httpStatus), \"Server at \" + getBaseURL()\n              + \" returned non ok status:\" + httpStatus + \", message:\"\n              + response.getStatusLine().getReasonPhrase());\n          \n      }\n      if (processor == null) {\n        // no processor specified, return raw stream\n        NamedList<Object> rsp = new NamedList<Object>();\n        rsp.add(\"stream\", respBody);\n        // Only case where stream should not be closed\n        shouldClose = false;\n        return rsp;\n      }\n      String charset = EntityUtils.getContentCharSet(response.getEntity());\n      NamedList<Object> rsp = processor.processResponse(respBody, charset);\n      if (httpStatus != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            // TODO? get the trace?\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase());\n          msg.append(\"\\n\\n\");\n          msg.append(\"request: \" + method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n        }\n        throw new SolrException(\n            SolrException.ErrorCode.getErrorCode(httpStatus), reason);\n      }\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occured while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occured when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (respBody != null && shouldClose) {\n        try {\n          respBody.close();\n        } catch (Throwable t) {} // ignore\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"196ccd109e6a8e7cc1fddcc105ae99e8894b98d1","date":1366161893,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","sourceNew":"  public NamedList<Object> request(final SolrRequest request,\n      final ResponseParser processor) throws SolrServerException, IOException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    params = wparams;\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            LinkedList<NameValuePair> postParams = new LinkedList<NameValuePair>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url);\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<FormBodyPart>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = \"application/octet-stream\"; // default\n                  }\n                  parts.add(new FormBodyPart(content.getName(), \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    // XXX client already has this set, is this needed?\n    method.getParams().setParameter(ClientPNames.HANDLE_REDIRECTS,\n        followRedirects);\n    method.addHeader(\"User-Agent\", AGENT);\n    \n    InputStream respBody = null;\n    boolean shouldClose = true;\n    \n    try {\n      // Execute the method.\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      // Read the contents\n      respBody = response.getEntity().getContent();\n      \n      // handle some http level checks before trying to parse the response\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n        case HttpStatus.SC_CONFLICT:  // 409\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        default:\n          throw new RemoteSolrException(httpStatus, \"Server at \" + getBaseURL()\n              + \" returned non ok status:\" + httpStatus + \", message:\"\n              + response.getStatusLine().getReasonPhrase(), null);\n      }\n      if (processor == null) {\n        // no processor specified, return raw stream\n        NamedList<Object> rsp = new NamedList<Object>();\n        rsp.add(\"stream\", respBody);\n        // Only case where stream should not be closed\n        shouldClose = false;\n        return rsp;\n      }\n      String charset = EntityUtils.getContentCharSet(response.getEntity());\n      NamedList<Object> rsp = processor.processResponse(respBody, charset);\n      if (httpStatus != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            // TODO? get the trace?\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase());\n          msg.append(\"\\n\\n\");\n          msg.append(\"request: \" + method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n        }\n        throw new RemoteSolrException(httpStatus, reason, null);\n      }\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occured while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occured when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (respBody != null && shouldClose) {\n        try {\n          respBody.close();\n        } catch (Throwable t) {} // ignore\n      }\n    }\n  }\n\n","sourceOld":"  public NamedList<Object> request(final SolrRequest request,\n      final ResponseParser processor) throws SolrServerException, IOException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    params = wparams;\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            LinkedList<NameValuePair> postParams = new LinkedList<NameValuePair>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url);\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<FormBodyPart>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = \"application/octet-stream\"; // default\n                  }\n                  parts.add(new FormBodyPart(content.getName(), \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    // XXX client already has this set, is this needed?\n    method.getParams().setParameter(ClientPNames.HANDLE_REDIRECTS,\n        followRedirects);\n    method.addHeader(\"User-Agent\", AGENT);\n    \n    InputStream respBody = null;\n    boolean shouldClose = true;\n    \n    try {\n      // Execute the method.\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      // Read the contents\n      respBody = response.getEntity().getContent();\n      \n      // handle some http level checks before trying to parse the response\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n        case HttpStatus.SC_CONFLICT:  // 409\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        default:\n          throw new SolrException(SolrException.ErrorCode.getErrorCode(httpStatus), \"Server at \" + getBaseURL()\n              + \" returned non ok status:\" + httpStatus + \", message:\"\n              + response.getStatusLine().getReasonPhrase());\n          \n      }\n      if (processor == null) {\n        // no processor specified, return raw stream\n        NamedList<Object> rsp = new NamedList<Object>();\n        rsp.add(\"stream\", respBody);\n        // Only case where stream should not be closed\n        shouldClose = false;\n        return rsp;\n      }\n      String charset = EntityUtils.getContentCharSet(response.getEntity());\n      NamedList<Object> rsp = processor.processResponse(respBody, charset);\n      if (httpStatus != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            // TODO? get the trace?\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase());\n          msg.append(\"\\n\\n\");\n          msg.append(\"request: \" + method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n        }\n        throw new SolrException(\n            SolrException.ErrorCode.getErrorCode(httpStatus), reason);\n      }\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occured while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occured when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (respBody != null && shouldClose) {\n        try {\n          respBody.close();\n        } catch (Throwable t) {} // ignore\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["7a899ae08a2414e44e9aec7db9783e3da08996d9"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"db38df1327eb9a91d4f733219b3865b3af2650fa","date":1366389326,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","sourceNew":"  public NamedList<Object> request(final SolrRequest request,\n      final ResponseParser processor) throws SolrServerException, IOException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    params = wparams;\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean hasNullStreamName = false;\n            if (streams != null) {\n              for (ContentStream cs : streams) {\n                if (cs.getName() == null) {\n                  hasNullStreamName = true;\n                  break;\n                }\n              }\n            }\n            boolean isMultipart = (this.useMultiPartPost || ( streams != null && streams.size() > 1 )) && !hasNullStreamName;\n\n            LinkedList<NameValuePair> postParams = new LinkedList<NameValuePair>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url);\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<FormBodyPart>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart && streams != null) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = \"application/octet-stream\"; // default\n                  }\n                  String name = content.getName();\n                  if(name==null) {\n                    name = \"\";\n                  }\n                  parts.add(new FormBodyPart(name, \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    // XXX client already has this set, is this needed?\n    method.getParams().setParameter(ClientPNames.HANDLE_REDIRECTS,\n        followRedirects);\n    method.addHeader(\"User-Agent\", AGENT);\n    \n    InputStream respBody = null;\n    boolean shouldClose = true;\n    \n    try {\n      // Execute the method.\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      // Read the contents\n      respBody = response.getEntity().getContent();\n      \n      // handle some http level checks before trying to parse the response\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n        case HttpStatus.SC_CONFLICT:  // 409\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        default:\n          throw new RemoteSolrException(httpStatus, \"Server at \" + getBaseURL()\n              + \" returned non ok status:\" + httpStatus + \", message:\"\n              + response.getStatusLine().getReasonPhrase(), null);\n      }\n      if (processor == null) {\n        // no processor specified, return raw stream\n        NamedList<Object> rsp = new NamedList<Object>();\n        rsp.add(\"stream\", respBody);\n        // Only case where stream should not be closed\n        shouldClose = false;\n        return rsp;\n      }\n      \n//      if(true) {\n//        ByteArrayOutputStream copy = new ByteArrayOutputStream();\n//        IOUtils.copy(respBody, copy);\n//        String val = new String(copy.toByteArray());\n//        System.out.println(\">RESPONSE>\"+val+\"<\"+val.length());\n//        respBody = new ByteArrayInputStream(copy.toByteArray());\n//      }\n      \n      String charset = EntityUtils.getContentCharSet(response.getEntity());\n      NamedList<Object> rsp = processor.processResponse(respBody, charset);\n      if (httpStatus != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            // TODO? get the trace?\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase());\n          msg.append(\"\\n\\n\");\n          msg.append(\"request: \" + method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n        }\n        throw new RemoteSolrException(httpStatus, reason, null);\n      }\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occured while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occured when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (respBody != null && shouldClose) {\n        try {\n          respBody.close();\n        } catch (Throwable t) {} // ignore\n      }\n    }\n  }\n\n","sourceOld":"  public NamedList<Object> request(final SolrRequest request,\n      final ResponseParser processor) throws SolrServerException, IOException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    params = wparams;\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            LinkedList<NameValuePair> postParams = new LinkedList<NameValuePair>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url);\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<FormBodyPart>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = \"application/octet-stream\"; // default\n                  }\n                  parts.add(new FormBodyPart(content.getName(), \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    // XXX client already has this set, is this needed?\n    method.getParams().setParameter(ClientPNames.HANDLE_REDIRECTS,\n        followRedirects);\n    method.addHeader(\"User-Agent\", AGENT);\n    \n    InputStream respBody = null;\n    boolean shouldClose = true;\n    \n    try {\n      // Execute the method.\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      // Read the contents\n      respBody = response.getEntity().getContent();\n      \n      // handle some http level checks before trying to parse the response\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n        case HttpStatus.SC_CONFLICT:  // 409\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        default:\n          throw new RemoteSolrException(httpStatus, \"Server at \" + getBaseURL()\n              + \" returned non ok status:\" + httpStatus + \", message:\"\n              + response.getStatusLine().getReasonPhrase(), null);\n      }\n      if (processor == null) {\n        // no processor specified, return raw stream\n        NamedList<Object> rsp = new NamedList<Object>();\n        rsp.add(\"stream\", respBody);\n        // Only case where stream should not be closed\n        shouldClose = false;\n        return rsp;\n      }\n      String charset = EntityUtils.getContentCharSet(response.getEntity());\n      NamedList<Object> rsp = processor.processResponse(respBody, charset);\n      if (httpStatus != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            // TODO? get the trace?\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase());\n          msg.append(\"\\n\\n\");\n          msg.append(\"request: \" + method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n        }\n        throw new RemoteSolrException(httpStatus, reason, null);\n      }\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occured while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occured when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (respBody != null && shouldClose) {\n        try {\n          respBody.close();\n        } catch (Throwable t) {} // ignore\n      }\n    }\n  }\n\n","bugFix":["52fffe2fb680c61aa1d03f7a774e3def8126203a","e6265065eff8fca7d05265677a74384fd538cec3"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7a899ae08a2414e44e9aec7db9783e3da08996d9","date":1380547227,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","sourceNew":"  public NamedList<Object> request(final SolrRequest request,\n      final ResponseParser processor) throws SolrServerException, IOException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    params = wparams;\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean hasNullStreamName = false;\n            if (streams != null) {\n              for (ContentStream cs : streams) {\n                if (cs.getName() == null) {\n                  hasNullStreamName = true;\n                  break;\n                }\n              }\n            }\n            boolean isMultipart = (this.useMultiPartPost || ( streams != null && streams.size() > 1 )) && !hasNullStreamName;\n\n            LinkedList<NameValuePair> postParams = new LinkedList<NameValuePair>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url);\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<FormBodyPart>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart && streams != null) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = BinaryResponseParser.BINARY_CONTENT_TYPE; // default\n                  }\n                  String name = content.getName();\n                  if(name==null) {\n                    name = \"\";\n                  }\n                  parts.add(new FormBodyPart(name, \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    // XXX client already has this set, is this needed?\n    method.getParams().setParameter(ClientPNames.HANDLE_REDIRECTS,\n        followRedirects);\n    method.addHeader(\"User-Agent\", AGENT);\n    \n    InputStream respBody = null;\n    boolean shouldClose = true;\n    \n    try {\n      // Execute the method.\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      // Read the contents\n      respBody = response.getEntity().getContent();\n      Header ctHeader = response.getLastHeader(\"content-type\");\n      String contentType;\n      if (ctHeader != null) {\n        contentType = ctHeader.getValue();\n      } else {\n        contentType = \"\";\n      }\n      \n      // handle some http level checks before trying to parse the response\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n        case HttpStatus.SC_CONFLICT:  // 409\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        default:\n          if (processor == null) {\n            throw new RemoteSolrException(httpStatus, \"Server at \"\n                + getBaseURL() + \" returned non ok status:\" + httpStatus\n                + \", message:\" + response.getStatusLine().getReasonPhrase(),\n                null);\n          }\n      }\n      if (processor == null) {\n        \n        // no processor specified, return raw stream\n        NamedList<Object> rsp = new NamedList<Object>();\n        rsp.add(\"stream\", respBody);\n        // Only case where stream should not be closed\n        shouldClose = false;\n        return rsp;\n      }\n      \n      String procCt = processor.getContentType();\n      if (procCt != null) {\n        if (!contentType.equals(procCt)) {\n          // unexpected content type\n          String msg = \"Expected content type \" + procCt + \" but got \" + contentType + \".\";\n          RemoteSolrException e = new RemoteSolrException(httpStatus, msg + \" \" +\n              IOUtils.toString(respBody), null);\n          throw e;\n        }\n      }\n      \n//      if(true) {\n//        ByteArrayOutputStream copy = new ByteArrayOutputStream();\n//        IOUtils.copy(respBody, copy);\n//        String val = new String(copy.toByteArray());\n//        System.out.println(\">RESPONSE>\"+val+\"<\"+val.length());\n//        respBody = new ByteArrayInputStream(copy.toByteArray());\n//      }\n      \n      NamedList<Object> rsp = null;\n      String charset = EntityUtils.getContentCharSet(response.getEntity());\n      try {\n        rsp = processor.processResponse(respBody, charset);\n      } catch (Exception e) {\n        throw new RemoteSolrException(httpStatus, e.getMessage(), e);\n      }\n      if (httpStatus != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            // TODO? get the trace?\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase());\n          msg.append(\"\\n\\n\");\n          msg.append(\"request: \" + method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n        }\n        throw new RemoteSolrException(httpStatus, reason, null);\n      }\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occured while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occured when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (respBody != null && shouldClose) {\n        try {\n          respBody.close();\n        } catch (Throwable t) {} // ignore\n      }\n    }\n  }\n\n","sourceOld":"  public NamedList<Object> request(final SolrRequest request,\n      final ResponseParser processor) throws SolrServerException, IOException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    params = wparams;\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean hasNullStreamName = false;\n            if (streams != null) {\n              for (ContentStream cs : streams) {\n                if (cs.getName() == null) {\n                  hasNullStreamName = true;\n                  break;\n                }\n              }\n            }\n            boolean isMultipart = (this.useMultiPartPost || ( streams != null && streams.size() > 1 )) && !hasNullStreamName;\n\n            LinkedList<NameValuePair> postParams = new LinkedList<NameValuePair>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url);\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<FormBodyPart>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart && streams != null) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = \"application/octet-stream\"; // default\n                  }\n                  String name = content.getName();\n                  if(name==null) {\n                    name = \"\";\n                  }\n                  parts.add(new FormBodyPart(name, \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    // XXX client already has this set, is this needed?\n    method.getParams().setParameter(ClientPNames.HANDLE_REDIRECTS,\n        followRedirects);\n    method.addHeader(\"User-Agent\", AGENT);\n    \n    InputStream respBody = null;\n    boolean shouldClose = true;\n    \n    try {\n      // Execute the method.\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      // Read the contents\n      respBody = response.getEntity().getContent();\n      \n      // handle some http level checks before trying to parse the response\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n        case HttpStatus.SC_CONFLICT:  // 409\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        default:\n          throw new RemoteSolrException(httpStatus, \"Server at \" + getBaseURL()\n              + \" returned non ok status:\" + httpStatus + \", message:\"\n              + response.getStatusLine().getReasonPhrase(), null);\n      }\n      if (processor == null) {\n        // no processor specified, return raw stream\n        NamedList<Object> rsp = new NamedList<Object>();\n        rsp.add(\"stream\", respBody);\n        // Only case where stream should not be closed\n        shouldClose = false;\n        return rsp;\n      }\n      \n//      if(true) {\n//        ByteArrayOutputStream copy = new ByteArrayOutputStream();\n//        IOUtils.copy(respBody, copy);\n//        String val = new String(copy.toByteArray());\n//        System.out.println(\">RESPONSE>\"+val+\"<\"+val.length());\n//        respBody = new ByteArrayInputStream(copy.toByteArray());\n//      }\n      \n      String charset = EntityUtils.getContentCharSet(response.getEntity());\n      NamedList<Object> rsp = processor.processResponse(respBody, charset);\n      if (httpStatus != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            // TODO? get the trace?\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase());\n          msg.append(\"\\n\\n\");\n          msg.append(\"request: \" + method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n        }\n        throw new RemoteSolrException(httpStatus, reason, null);\n      }\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occured while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occured when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (respBody != null && shouldClose) {\n        try {\n          respBody.close();\n        } catch (Throwable t) {} // ignore\n      }\n    }\n  }\n\n","bugFix":["196ccd109e6a8e7cc1fddcc105ae99e8894b98d1","52fffe2fb680c61aa1d03f7a774e3def8126203a","7321b77a7bc3edfebd637ef273e9dfaa9969eba6"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"aba545e9109e49fd275ffc3160444096a9ef0f75","date":1380574404,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","sourceNew":"  public NamedList<Object> request(final SolrRequest request,\n      final ResponseParser processor) throws SolrServerException, IOException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    params = wparams;\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean hasNullStreamName = false;\n            if (streams != null) {\n              for (ContentStream cs : streams) {\n                if (cs.getName() == null) {\n                  hasNullStreamName = true;\n                  break;\n                }\n              }\n            }\n            boolean isMultipart = (this.useMultiPartPost || ( streams != null && streams.size() > 1 )) && !hasNullStreamName;\n\n            LinkedList<NameValuePair> postParams = new LinkedList<NameValuePair>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url);\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<FormBodyPart>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart && streams != null) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = BinaryResponseParser.BINARY_CONTENT_TYPE; // default\n                  }\n                  String name = content.getName();\n                  if(name==null) {\n                    name = \"\";\n                  }\n                  parts.add(new FormBodyPart(name, \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    // XXX client already has this set, is this needed?\n    method.getParams().setParameter(ClientPNames.HANDLE_REDIRECTS,\n        followRedirects);\n    method.addHeader(\"User-Agent\", AGENT);\n    \n    InputStream respBody = null;\n    boolean shouldClose = true;\n    \n    try {\n      // Execute the method.\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      // Read the contents\n      respBody = response.getEntity().getContent();\n      Header ctHeader = response.getLastHeader(\"content-type\");\n      String contentType;\n      if (ctHeader != null) {\n        contentType = ctHeader.getValue();\n      } else {\n        contentType = \"\";\n      }\n      \n      // handle some http level checks before trying to parse the response\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n        case HttpStatus.SC_CONFLICT:  // 409\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        default:\n          if (processor == null) {\n            throw new RemoteSolrException(httpStatus, \"Server at \"\n                + getBaseURL() + \" returned non ok status:\" + httpStatus\n                + \", message:\" + response.getStatusLine().getReasonPhrase(),\n                null);\n          }\n      }\n      if (processor == null) {\n        \n        // no processor specified, return raw stream\n        NamedList<Object> rsp = new NamedList<Object>();\n        rsp.add(\"stream\", respBody);\n        // Only case where stream should not be closed\n        shouldClose = false;\n        return rsp;\n      }\n      \n      String procCt = processor.getContentType();\n      if (procCt != null) {\n        if (!contentType.equals(procCt)) {\n          // unexpected content type\n          String msg = \"Expected content type \" + procCt + \" but got \" + contentType + \".\";\n          Header encodingHeader = response.getEntity().getContentEncoding();\n          String encoding;\n          if (encodingHeader != null) {\n            encoding = encodingHeader.getValue();\n          } else {\n            encoding = \"UTF-8\"; // try UTF-8\n          }\n          try {\n            msg = msg + \" \" + IOUtils.toString(respBody, encoding);\n          } catch (IOException e) {\n            new RemoteSolrException(httpStatus, \"Could not parse response with encoding \" + encoding, e);\n          }\n          RemoteSolrException e = new RemoteSolrException(httpStatus, msg, null);\n          throw e;\n        }\n      }\n      \n//      if(true) {\n//        ByteArrayOutputStream copy = new ByteArrayOutputStream();\n//        IOUtils.copy(respBody, copy);\n//        String val = new String(copy.toByteArray());\n//        System.out.println(\">RESPONSE>\"+val+\"<\"+val.length());\n//        respBody = new ByteArrayInputStream(copy.toByteArray());\n//      }\n      \n      NamedList<Object> rsp = null;\n      String charset = EntityUtils.getContentCharSet(response.getEntity());\n      try {\n        rsp = processor.processResponse(respBody, charset);\n      } catch (Exception e) {\n        throw new RemoteSolrException(httpStatus, e.getMessage(), e);\n      }\n      if (httpStatus != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            // TODO? get the trace?\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase());\n          msg.append(\"\\n\\n\");\n          msg.append(\"request: \" + method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n        }\n        throw new RemoteSolrException(httpStatus, reason, null);\n      }\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occured while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occured when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (respBody != null && shouldClose) {\n        try {\n          respBody.close();\n        } catch (Throwable t) {} // ignore\n      }\n    }\n  }\n\n","sourceOld":"  public NamedList<Object> request(final SolrRequest request,\n      final ResponseParser processor) throws SolrServerException, IOException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    params = wparams;\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean hasNullStreamName = false;\n            if (streams != null) {\n              for (ContentStream cs : streams) {\n                if (cs.getName() == null) {\n                  hasNullStreamName = true;\n                  break;\n                }\n              }\n            }\n            boolean isMultipart = (this.useMultiPartPost || ( streams != null && streams.size() > 1 )) && !hasNullStreamName;\n\n            LinkedList<NameValuePair> postParams = new LinkedList<NameValuePair>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url);\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<FormBodyPart>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart && streams != null) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = BinaryResponseParser.BINARY_CONTENT_TYPE; // default\n                  }\n                  String name = content.getName();\n                  if(name==null) {\n                    name = \"\";\n                  }\n                  parts.add(new FormBodyPart(name, \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    // XXX client already has this set, is this needed?\n    method.getParams().setParameter(ClientPNames.HANDLE_REDIRECTS,\n        followRedirects);\n    method.addHeader(\"User-Agent\", AGENT);\n    \n    InputStream respBody = null;\n    boolean shouldClose = true;\n    \n    try {\n      // Execute the method.\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      // Read the contents\n      respBody = response.getEntity().getContent();\n      Header ctHeader = response.getLastHeader(\"content-type\");\n      String contentType;\n      if (ctHeader != null) {\n        contentType = ctHeader.getValue();\n      } else {\n        contentType = \"\";\n      }\n      \n      // handle some http level checks before trying to parse the response\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n        case HttpStatus.SC_CONFLICT:  // 409\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        default:\n          if (processor == null) {\n            throw new RemoteSolrException(httpStatus, \"Server at \"\n                + getBaseURL() + \" returned non ok status:\" + httpStatus\n                + \", message:\" + response.getStatusLine().getReasonPhrase(),\n                null);\n          }\n      }\n      if (processor == null) {\n        \n        // no processor specified, return raw stream\n        NamedList<Object> rsp = new NamedList<Object>();\n        rsp.add(\"stream\", respBody);\n        // Only case where stream should not be closed\n        shouldClose = false;\n        return rsp;\n      }\n      \n      String procCt = processor.getContentType();\n      if (procCt != null) {\n        if (!contentType.equals(procCt)) {\n          // unexpected content type\n          String msg = \"Expected content type \" + procCt + \" but got \" + contentType + \".\";\n          RemoteSolrException e = new RemoteSolrException(httpStatus, msg + \" \" +\n              IOUtils.toString(respBody), null);\n          throw e;\n        }\n      }\n      \n//      if(true) {\n//        ByteArrayOutputStream copy = new ByteArrayOutputStream();\n//        IOUtils.copy(respBody, copy);\n//        String val = new String(copy.toByteArray());\n//        System.out.println(\">RESPONSE>\"+val+\"<\"+val.length());\n//        respBody = new ByteArrayInputStream(copy.toByteArray());\n//      }\n      \n      NamedList<Object> rsp = null;\n      String charset = EntityUtils.getContentCharSet(response.getEntity());\n      try {\n        rsp = processor.processResponse(respBody, charset);\n      } catch (Exception e) {\n        throw new RemoteSolrException(httpStatus, e.getMessage(), e);\n      }\n      if (httpStatus != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            // TODO? get the trace?\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase());\n          msg.append(\"\\n\\n\");\n          msg.append(\"request: \" + method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n        }\n        throw new RemoteSolrException(httpStatus, reason, null);\n      }\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occured while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occured when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (respBody != null && shouldClose) {\n        try {\n          respBody.close();\n        } catch (Throwable t) {} // ignore\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"becffa5e015a681af7926933a40ced882581d344","date":1380574877,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","sourceNew":"  public NamedList<Object> request(final SolrRequest request,\n      final ResponseParser processor) throws SolrServerException, IOException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    params = wparams;\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean hasNullStreamName = false;\n            if (streams != null) {\n              for (ContentStream cs : streams) {\n                if (cs.getName() == null) {\n                  hasNullStreamName = true;\n                  break;\n                }\n              }\n            }\n            boolean isMultipart = (this.useMultiPartPost || ( streams != null && streams.size() > 1 )) && !hasNullStreamName;\n\n            LinkedList<NameValuePair> postParams = new LinkedList<NameValuePair>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url);\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<FormBodyPart>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart && streams != null) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = BinaryResponseParser.BINARY_CONTENT_TYPE; // default\n                  }\n                  String name = content.getName();\n                  if(name==null) {\n                    name = \"\";\n                  }\n                  parts.add(new FormBodyPart(name, \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    // XXX client already has this set, is this needed?\n    method.getParams().setParameter(ClientPNames.HANDLE_REDIRECTS,\n        followRedirects);\n    method.addHeader(\"User-Agent\", AGENT);\n    \n    InputStream respBody = null;\n    boolean shouldClose = true;\n    \n    try {\n      // Execute the method.\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      // Read the contents\n      respBody = response.getEntity().getContent();\n      Header ctHeader = response.getLastHeader(\"content-type\");\n      String contentType;\n      if (ctHeader != null) {\n        contentType = ctHeader.getValue();\n      } else {\n        contentType = \"\";\n      }\n      \n      // handle some http level checks before trying to parse the response\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n        case HttpStatus.SC_CONFLICT:  // 409\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        default:\n          if (processor == null) {\n            throw new RemoteSolrException(httpStatus, \"Server at \"\n                + getBaseURL() + \" returned non ok status:\" + httpStatus\n                + \", message:\" + response.getStatusLine().getReasonPhrase(),\n                null);\n          }\n      }\n      if (processor == null) {\n        \n        // no processor specified, return raw stream\n        NamedList<Object> rsp = new NamedList<Object>();\n        rsp.add(\"stream\", respBody);\n        // Only case where stream should not be closed\n        shouldClose = false;\n        return rsp;\n      }\n      \n      String procCt = processor.getContentType();\n      if (procCt != null) {\n        if (!contentType.equals(procCt)) {\n          // unexpected content type\n          String msg = \"Expected content type \" + procCt + \" but got \" + contentType + \".\";\n          Header encodingHeader = response.getEntity().getContentEncoding();\n          String encoding;\n          if (encodingHeader != null) {\n            encoding = encodingHeader.getValue();\n          } else {\n            encoding = \"UTF-8\"; // try UTF-8\n          }\n          try {\n            msg = msg + \" \" + IOUtils.toString(respBody, encoding);\n          } catch (IOException e) {\n            throw new RemoteSolrException(httpStatus, \"Could not parse response with encoding \" + encoding, e);\n          }\n          RemoteSolrException e = new RemoteSolrException(httpStatus, msg, null);\n          throw e;\n        }\n      }\n      \n//      if(true) {\n//        ByteArrayOutputStream copy = new ByteArrayOutputStream();\n//        IOUtils.copy(respBody, copy);\n//        String val = new String(copy.toByteArray());\n//        System.out.println(\">RESPONSE>\"+val+\"<\"+val.length());\n//        respBody = new ByteArrayInputStream(copy.toByteArray());\n//      }\n      \n      NamedList<Object> rsp = null;\n      String charset = EntityUtils.getContentCharSet(response.getEntity());\n      try {\n        rsp = processor.processResponse(respBody, charset);\n      } catch (Exception e) {\n        throw new RemoteSolrException(httpStatus, e.getMessage(), e);\n      }\n      if (httpStatus != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            // TODO? get the trace?\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase());\n          msg.append(\"\\n\\n\");\n          msg.append(\"request: \" + method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n        }\n        throw new RemoteSolrException(httpStatus, reason, null);\n      }\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occured while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occured when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (respBody != null && shouldClose) {\n        try {\n          respBody.close();\n        } catch (Throwable t) {} // ignore\n      }\n    }\n  }\n\n","sourceOld":"  public NamedList<Object> request(final SolrRequest request,\n      final ResponseParser processor) throws SolrServerException, IOException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    params = wparams;\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean hasNullStreamName = false;\n            if (streams != null) {\n              for (ContentStream cs : streams) {\n                if (cs.getName() == null) {\n                  hasNullStreamName = true;\n                  break;\n                }\n              }\n            }\n            boolean isMultipart = (this.useMultiPartPost || ( streams != null && streams.size() > 1 )) && !hasNullStreamName;\n\n            LinkedList<NameValuePair> postParams = new LinkedList<NameValuePair>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url);\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<FormBodyPart>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart && streams != null) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = BinaryResponseParser.BINARY_CONTENT_TYPE; // default\n                  }\n                  String name = content.getName();\n                  if(name==null) {\n                    name = \"\";\n                  }\n                  parts.add(new FormBodyPart(name, \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    // XXX client already has this set, is this needed?\n    method.getParams().setParameter(ClientPNames.HANDLE_REDIRECTS,\n        followRedirects);\n    method.addHeader(\"User-Agent\", AGENT);\n    \n    InputStream respBody = null;\n    boolean shouldClose = true;\n    \n    try {\n      // Execute the method.\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      // Read the contents\n      respBody = response.getEntity().getContent();\n      Header ctHeader = response.getLastHeader(\"content-type\");\n      String contentType;\n      if (ctHeader != null) {\n        contentType = ctHeader.getValue();\n      } else {\n        contentType = \"\";\n      }\n      \n      // handle some http level checks before trying to parse the response\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n        case HttpStatus.SC_CONFLICT:  // 409\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        default:\n          if (processor == null) {\n            throw new RemoteSolrException(httpStatus, \"Server at \"\n                + getBaseURL() + \" returned non ok status:\" + httpStatus\n                + \", message:\" + response.getStatusLine().getReasonPhrase(),\n                null);\n          }\n      }\n      if (processor == null) {\n        \n        // no processor specified, return raw stream\n        NamedList<Object> rsp = new NamedList<Object>();\n        rsp.add(\"stream\", respBody);\n        // Only case where stream should not be closed\n        shouldClose = false;\n        return rsp;\n      }\n      \n      String procCt = processor.getContentType();\n      if (procCt != null) {\n        if (!contentType.equals(procCt)) {\n          // unexpected content type\n          String msg = \"Expected content type \" + procCt + \" but got \" + contentType + \".\";\n          Header encodingHeader = response.getEntity().getContentEncoding();\n          String encoding;\n          if (encodingHeader != null) {\n            encoding = encodingHeader.getValue();\n          } else {\n            encoding = \"UTF-8\"; // try UTF-8\n          }\n          try {\n            msg = msg + \" \" + IOUtils.toString(respBody, encoding);\n          } catch (IOException e) {\n            new RemoteSolrException(httpStatus, \"Could not parse response with encoding \" + encoding, e);\n          }\n          RemoteSolrException e = new RemoteSolrException(httpStatus, msg, null);\n          throw e;\n        }\n      }\n      \n//      if(true) {\n//        ByteArrayOutputStream copy = new ByteArrayOutputStream();\n//        IOUtils.copy(respBody, copy);\n//        String val = new String(copy.toByteArray());\n//        System.out.println(\">RESPONSE>\"+val+\"<\"+val.length());\n//        respBody = new ByteArrayInputStream(copy.toByteArray());\n//      }\n      \n      NamedList<Object> rsp = null;\n      String charset = EntityUtils.getContentCharSet(response.getEntity());\n      try {\n        rsp = processor.processResponse(respBody, charset);\n      } catch (Exception e) {\n        throw new RemoteSolrException(httpStatus, e.getMessage(), e);\n      }\n      if (httpStatus != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            // TODO? get the trace?\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase());\n          msg.append(\"\\n\\n\");\n          msg.append(\"request: \" + method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n        }\n        throw new RemoteSolrException(httpStatus, reason, null);\n      }\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occured while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occured when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (respBody != null && shouldClose) {\n        try {\n          respBody.close();\n        } catch (Throwable t) {} // ignore\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f1b4258e8d84ded627a66ea993d8c7acdc6ae7ad","date":1381613214,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","sourceNew":"  public NamedList<Object> request(final SolrRequest request,\n      final ResponseParser processor) throws SolrServerException, IOException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    params = wparams;\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean hasNullStreamName = false;\n            if (streams != null) {\n              for (ContentStream cs : streams) {\n                if (cs.getName() == null) {\n                  hasNullStreamName = true;\n                  break;\n                }\n              }\n            }\n            boolean isMultipart = (this.useMultiPartPost || ( streams != null && streams.size() > 1 )) && !hasNullStreamName;\n\n            LinkedList<NameValuePair> postParams = new LinkedList<NameValuePair>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url);\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<FormBodyPart>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart && streams != null) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = BinaryResponseParser.BINARY_CONTENT_TYPE; // default\n                  }\n                  String name = content.getName();\n                  if(name==null) {\n                    name = \"\";\n                  }\n                  parts.add(new FormBodyPart(name, \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    // XXX client already has this set, is this needed?\n    method.getParams().setParameter(ClientPNames.HANDLE_REDIRECTS,\n        followRedirects);\n    method.addHeader(\"User-Agent\", AGENT);\n    \n    InputStream respBody = null;\n    boolean shouldClose = true;\n    boolean success = false;\n    try {\n      // Execute the method.\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      // Read the contents\n      respBody = response.getEntity().getContent();\n      Header ctHeader = response.getLastHeader(\"content-type\");\n      String contentType;\n      if (ctHeader != null) {\n        contentType = ctHeader.getValue();\n      } else {\n        contentType = \"\";\n      }\n      \n      // handle some http level checks before trying to parse the response\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n        case HttpStatus.SC_CONFLICT:  // 409\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        default:\n          if (processor == null) {\n            throw new RemoteSolrException(httpStatus, \"Server at \"\n                + getBaseURL() + \" returned non ok status:\" + httpStatus\n                + \", message:\" + response.getStatusLine().getReasonPhrase(),\n                null);\n          }\n      }\n      if (processor == null) {\n        \n        // no processor specified, return raw stream\n        NamedList<Object> rsp = new NamedList<Object>();\n        rsp.add(\"stream\", respBody);\n        // Only case where stream should not be closed\n        shouldClose = false;\n        success = true;\n        return rsp;\n      }\n      \n      String procCt = processor.getContentType();\n      if (procCt != null) {\n        if (!contentType.equals(procCt)) {\n          // unexpected content type\n          String msg = \"Expected content type \" + procCt + \" but got \" + contentType + \".\";\n          Header encodingHeader = response.getEntity().getContentEncoding();\n          String encoding;\n          if (encodingHeader != null) {\n            encoding = encodingHeader.getValue();\n          } else {\n            encoding = \"UTF-8\"; // try UTF-8\n          }\n          try {\n            msg = msg + \" \" + IOUtils.toString(respBody, encoding);\n          } catch (IOException e) {\n            throw new RemoteSolrException(httpStatus, \"Could not parse response with encoding \" + encoding, e);\n          }\n          RemoteSolrException e = new RemoteSolrException(httpStatus, msg, null);\n          throw e;\n        }\n      }\n      \n//      if(true) {\n//        ByteArrayOutputStream copy = new ByteArrayOutputStream();\n//        IOUtils.copy(respBody, copy);\n//        String val = new String(copy.toByteArray());\n//        System.out.println(\">RESPONSE>\"+val+\"<\"+val.length());\n//        respBody = new ByteArrayInputStream(copy.toByteArray());\n//      }\n      \n      NamedList<Object> rsp = null;\n      String charset = EntityUtils.getContentCharSet(response.getEntity());\n      try {\n        rsp = processor.processResponse(respBody, charset);\n      } catch (Exception e) {\n        throw new RemoteSolrException(httpStatus, e.getMessage(), e);\n      }\n      if (httpStatus != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            // TODO? get the trace?\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase());\n          msg.append(\"\\n\\n\");\n          msg.append(\"request: \" + method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n        }\n        throw new RemoteSolrException(httpStatus, reason, null);\n      }\n      success = true;\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occured while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occured when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (respBody != null && shouldClose) {\n        try {\n          respBody.close();\n        } catch (Throwable t) {} // ignore\n        if (!success) {\n          method.abort();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public NamedList<Object> request(final SolrRequest request,\n      final ResponseParser processor) throws SolrServerException, IOException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    params = wparams;\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean hasNullStreamName = false;\n            if (streams != null) {\n              for (ContentStream cs : streams) {\n                if (cs.getName() == null) {\n                  hasNullStreamName = true;\n                  break;\n                }\n              }\n            }\n            boolean isMultipart = (this.useMultiPartPost || ( streams != null && streams.size() > 1 )) && !hasNullStreamName;\n\n            LinkedList<NameValuePair> postParams = new LinkedList<NameValuePair>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url);\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<FormBodyPart>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart && streams != null) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = BinaryResponseParser.BINARY_CONTENT_TYPE; // default\n                  }\n                  String name = content.getName();\n                  if(name==null) {\n                    name = \"\";\n                  }\n                  parts.add(new FormBodyPart(name, \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    // XXX client already has this set, is this needed?\n    method.getParams().setParameter(ClientPNames.HANDLE_REDIRECTS,\n        followRedirects);\n    method.addHeader(\"User-Agent\", AGENT);\n    \n    InputStream respBody = null;\n    boolean shouldClose = true;\n    \n    try {\n      // Execute the method.\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      // Read the contents\n      respBody = response.getEntity().getContent();\n      Header ctHeader = response.getLastHeader(\"content-type\");\n      String contentType;\n      if (ctHeader != null) {\n        contentType = ctHeader.getValue();\n      } else {\n        contentType = \"\";\n      }\n      \n      // handle some http level checks before trying to parse the response\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n        case HttpStatus.SC_CONFLICT:  // 409\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        default:\n          if (processor == null) {\n            throw new RemoteSolrException(httpStatus, \"Server at \"\n                + getBaseURL() + \" returned non ok status:\" + httpStatus\n                + \", message:\" + response.getStatusLine().getReasonPhrase(),\n                null);\n          }\n      }\n      if (processor == null) {\n        \n        // no processor specified, return raw stream\n        NamedList<Object> rsp = new NamedList<Object>();\n        rsp.add(\"stream\", respBody);\n        // Only case where stream should not be closed\n        shouldClose = false;\n        return rsp;\n      }\n      \n      String procCt = processor.getContentType();\n      if (procCt != null) {\n        if (!contentType.equals(procCt)) {\n          // unexpected content type\n          String msg = \"Expected content type \" + procCt + \" but got \" + contentType + \".\";\n          Header encodingHeader = response.getEntity().getContentEncoding();\n          String encoding;\n          if (encodingHeader != null) {\n            encoding = encodingHeader.getValue();\n          } else {\n            encoding = \"UTF-8\"; // try UTF-8\n          }\n          try {\n            msg = msg + \" \" + IOUtils.toString(respBody, encoding);\n          } catch (IOException e) {\n            throw new RemoteSolrException(httpStatus, \"Could not parse response with encoding \" + encoding, e);\n          }\n          RemoteSolrException e = new RemoteSolrException(httpStatus, msg, null);\n          throw e;\n        }\n      }\n      \n//      if(true) {\n//        ByteArrayOutputStream copy = new ByteArrayOutputStream();\n//        IOUtils.copy(respBody, copy);\n//        String val = new String(copy.toByteArray());\n//        System.out.println(\">RESPONSE>\"+val+\"<\"+val.length());\n//        respBody = new ByteArrayInputStream(copy.toByteArray());\n//      }\n      \n      NamedList<Object> rsp = null;\n      String charset = EntityUtils.getContentCharSet(response.getEntity());\n      try {\n        rsp = processor.processResponse(respBody, charset);\n      } catch (Exception e) {\n        throw new RemoteSolrException(httpStatus, e.getMessage(), e);\n      }\n      if (httpStatus != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            // TODO? get the trace?\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase());\n          msg.append(\"\\n\\n\");\n          msg.append(\"request: \" + method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n        }\n        throw new RemoteSolrException(httpStatus, reason, null);\n      }\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occured while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occured when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (respBody != null && shouldClose) {\n        try {\n          respBody.close();\n        } catch (Throwable t) {} // ignore\n      }\n    }\n  }\n\n","bugFix":["7321b77a7bc3edfebd637ef273e9dfaa9969eba6"],"bugIntro":["f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3e5ef402099a6d54398ce3ac65c0b7506bbfece5","date":1384830813,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","sourceNew":"  public NamedList<Object> request(final SolrRequest request,\n      final ResponseParser processor) throws SolrServerException, IOException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( wparams, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean hasNullStreamName = false;\n            if (streams != null) {\n              for (ContentStream cs : streams) {\n                if (cs.getName() == null) {\n                  hasNullStreamName = true;\n                  break;\n                }\n              }\n            }\n            boolean isMultipart = (this.useMultiPartPost || ( streams != null && streams.size() > 1 )) && !hasNullStreamName;\n            \n            // only send this list of params as query string params\n            ModifiableSolrParams queryParams = new ModifiableSolrParams();\n            for (String param : this.queryParams) {\n              String[] value = wparams.getParams(param) ;\n              if (value != null) {\n                for (String v : value) {\n                  queryParams.add(param, v);\n                }\n                wparams.remove(param);\n              }\n            }\n            \n            LinkedList<NameValuePair> postParams = new LinkedList<NameValuePair>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url + ClientUtils.toQueryString( queryParams, false ));\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<FormBodyPart>();\n              Iterator<String> iter = wparams.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = wparams.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart && streams != null) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = BinaryResponseParser.BINARY_CONTENT_TYPE; // default\n                  }\n                  String name = content.getName();\n                  if(name==null) {\n                    name = \"\";\n                  }\n                  parts.add(new FormBodyPart(name, \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(wparams, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    // XXX client already has this set, is this needed?\n    method.getParams().setParameter(ClientPNames.HANDLE_REDIRECTS,\n        followRedirects);\n    method.addHeader(\"User-Agent\", AGENT);\n    \n    InputStream respBody = null;\n    boolean shouldClose = true;\n    boolean success = false;\n    try {\n      // Execute the method.\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      // Read the contents\n      respBody = response.getEntity().getContent();\n      Header ctHeader = response.getLastHeader(\"content-type\");\n      String contentType;\n      if (ctHeader != null) {\n        contentType = ctHeader.getValue();\n      } else {\n        contentType = \"\";\n      }\n      \n      // handle some http level checks before trying to parse the response\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n        case HttpStatus.SC_CONFLICT:  // 409\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        default:\n          if (processor == null) {\n            throw new RemoteSolrException(httpStatus, \"Server at \"\n                + getBaseURL() + \" returned non ok status:\" + httpStatus\n                + \", message:\" + response.getStatusLine().getReasonPhrase(),\n                null);\n          }\n      }\n      if (processor == null) {\n        \n        // no processor specified, return raw stream\n        NamedList<Object> rsp = new NamedList<Object>();\n        rsp.add(\"stream\", respBody);\n        // Only case where stream should not be closed\n        shouldClose = false;\n        success = true;\n        return rsp;\n      }\n      \n      String procCt = processor.getContentType();\n      if (procCt != null) {\n        if (!contentType.equals(procCt)) {\n          // unexpected content type\n          String msg = \"Expected content type \" + procCt + \" but got \" + contentType + \".\";\n          Header encodingHeader = response.getEntity().getContentEncoding();\n          String encoding;\n          if (encodingHeader != null) {\n            encoding = encodingHeader.getValue();\n          } else {\n            encoding = \"UTF-8\"; // try UTF-8\n          }\n          try {\n            msg = msg + \" \" + IOUtils.toString(respBody, encoding);\n          } catch (IOException e) {\n            throw new RemoteSolrException(httpStatus, \"Could not parse response with encoding \" + encoding, e);\n          }\n          RemoteSolrException e = new RemoteSolrException(httpStatus, msg, null);\n          throw e;\n        }\n      }\n      \n//      if(true) {\n//        ByteArrayOutputStream copy = new ByteArrayOutputStream();\n//        IOUtils.copy(respBody, copy);\n//        String val = new String(copy.toByteArray());\n//        System.out.println(\">RESPONSE>\"+val+\"<\"+val.length());\n//        respBody = new ByteArrayInputStream(copy.toByteArray());\n//      }\n      \n      NamedList<Object> rsp = null;\n      String charset = EntityUtils.getContentCharSet(response.getEntity());\n      try {\n        rsp = processor.processResponse(respBody, charset);\n      } catch (Exception e) {\n        throw new RemoteSolrException(httpStatus, e.getMessage(), e);\n      }\n      if (httpStatus != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            // TODO? get the trace?\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase());\n          msg.append(\"\\n\\n\");\n          msg.append(\"request: \" + method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n        }\n        throw new RemoteSolrException(httpStatus, reason, null);\n      }\n      success = true;\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occured while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occured when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (respBody != null && shouldClose) {\n        try {\n          respBody.close();\n        } catch (Throwable t) {} // ignore\n        if (!success) {\n          method.abort();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public NamedList<Object> request(final SolrRequest request,\n      final ResponseParser processor) throws SolrServerException, IOException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    params = wparams;\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean hasNullStreamName = false;\n            if (streams != null) {\n              for (ContentStream cs : streams) {\n                if (cs.getName() == null) {\n                  hasNullStreamName = true;\n                  break;\n                }\n              }\n            }\n            boolean isMultipart = (this.useMultiPartPost || ( streams != null && streams.size() > 1 )) && !hasNullStreamName;\n\n            LinkedList<NameValuePair> postParams = new LinkedList<NameValuePair>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url);\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<FormBodyPart>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart && streams != null) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = BinaryResponseParser.BINARY_CONTENT_TYPE; // default\n                  }\n                  String name = content.getName();\n                  if(name==null) {\n                    name = \"\";\n                  }\n                  parts.add(new FormBodyPart(name, \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    // XXX client already has this set, is this needed?\n    method.getParams().setParameter(ClientPNames.HANDLE_REDIRECTS,\n        followRedirects);\n    method.addHeader(\"User-Agent\", AGENT);\n    \n    InputStream respBody = null;\n    boolean shouldClose = true;\n    boolean success = false;\n    try {\n      // Execute the method.\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      // Read the contents\n      respBody = response.getEntity().getContent();\n      Header ctHeader = response.getLastHeader(\"content-type\");\n      String contentType;\n      if (ctHeader != null) {\n        contentType = ctHeader.getValue();\n      } else {\n        contentType = \"\";\n      }\n      \n      // handle some http level checks before trying to parse the response\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n        case HttpStatus.SC_CONFLICT:  // 409\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        default:\n          if (processor == null) {\n            throw new RemoteSolrException(httpStatus, \"Server at \"\n                + getBaseURL() + \" returned non ok status:\" + httpStatus\n                + \", message:\" + response.getStatusLine().getReasonPhrase(),\n                null);\n          }\n      }\n      if (processor == null) {\n        \n        // no processor specified, return raw stream\n        NamedList<Object> rsp = new NamedList<Object>();\n        rsp.add(\"stream\", respBody);\n        // Only case where stream should not be closed\n        shouldClose = false;\n        success = true;\n        return rsp;\n      }\n      \n      String procCt = processor.getContentType();\n      if (procCt != null) {\n        if (!contentType.equals(procCt)) {\n          // unexpected content type\n          String msg = \"Expected content type \" + procCt + \" but got \" + contentType + \".\";\n          Header encodingHeader = response.getEntity().getContentEncoding();\n          String encoding;\n          if (encodingHeader != null) {\n            encoding = encodingHeader.getValue();\n          } else {\n            encoding = \"UTF-8\"; // try UTF-8\n          }\n          try {\n            msg = msg + \" \" + IOUtils.toString(respBody, encoding);\n          } catch (IOException e) {\n            throw new RemoteSolrException(httpStatus, \"Could not parse response with encoding \" + encoding, e);\n          }\n          RemoteSolrException e = new RemoteSolrException(httpStatus, msg, null);\n          throw e;\n        }\n      }\n      \n//      if(true) {\n//        ByteArrayOutputStream copy = new ByteArrayOutputStream();\n//        IOUtils.copy(respBody, copy);\n//        String val = new String(copy.toByteArray());\n//        System.out.println(\">RESPONSE>\"+val+\"<\"+val.length());\n//        respBody = new ByteArrayInputStream(copy.toByteArray());\n//      }\n      \n      NamedList<Object> rsp = null;\n      String charset = EntityUtils.getContentCharSet(response.getEntity());\n      try {\n        rsp = processor.processResponse(respBody, charset);\n      } catch (Exception e) {\n        throw new RemoteSolrException(httpStatus, e.getMessage(), e);\n      }\n      if (httpStatus != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            // TODO? get the trace?\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase());\n          msg.append(\"\\n\\n\");\n          msg.append(\"request: \" + method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n        }\n        throw new RemoteSolrException(httpStatus, reason, null);\n      }\n      success = true;\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occured while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occured when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (respBody != null && shouldClose) {\n        try {\n          respBody.close();\n        } catch (Throwable t) {} // ignore\n        if (!success) {\n          method.abort();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0d7e876b400387e12251ef67c5c17971bf36cf9b","date":1386356463,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","sourceNew":"  public NamedList<Object> request(final SolrRequest request,\n      final ResponseParser processor) throws SolrServerException, IOException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( wparams, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean hasNullStreamName = false;\n            if (streams != null) {\n              for (ContentStream cs : streams) {\n                if (cs.getName() == null) {\n                  hasNullStreamName = true;\n                  break;\n                }\n              }\n            }\n            boolean isMultipart = (this.useMultiPartPost || ( streams != null && streams.size() > 1 )) && !hasNullStreamName;\n            \n            // only send this list of params as query string params\n            ModifiableSolrParams queryParams = new ModifiableSolrParams();\n            for (String param : this.queryParams) {\n              String[] value = wparams.getParams(param) ;\n              if (value != null) {\n                for (String v : value) {\n                  queryParams.add(param, v);\n                }\n                wparams.remove(param);\n              }\n            }\n            \n            LinkedList<NameValuePair> postParams = new LinkedList<NameValuePair>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url + ClientUtils.toQueryString( queryParams, false ));\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<FormBodyPart>();\n              Iterator<String> iter = wparams.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = wparams.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart && streams != null) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = BinaryResponseParser.BINARY_CONTENT_TYPE; // default\n                  }\n                  String name = content.getName();\n                  if(name==null) {\n                    name = \"\";\n                  }\n                  parts.add(new FormBodyPart(name, \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(wparams, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    // XXX client already has this set, is this needed?\n    method.getParams().setParameter(ClientPNames.HANDLE_REDIRECTS,\n        followRedirects);\n    method.addHeader(\"User-Agent\", AGENT);\n    \n    InputStream respBody = null;\n    boolean shouldClose = true;\n    boolean success = false;\n    try {\n      // Execute the method.\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      // Read the contents\n      respBody = response.getEntity().getContent();\n      Header ctHeader = response.getLastHeader(\"content-type\");\n      String contentType;\n      if (ctHeader != null) {\n        contentType = ctHeader.getValue();\n      } else {\n        contentType = \"\";\n      }\n      \n      // handle some http level checks before trying to parse the response\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n        case HttpStatus.SC_CONFLICT:  // 409\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        default:\n          if (processor == null) {\n            throw new RemoteSolrException(httpStatus, \"Server at \"\n                + getBaseURL() + \" returned non ok status:\" + httpStatus\n                + \", message:\" + response.getStatusLine().getReasonPhrase(),\n                null);\n          }\n      }\n      if (processor == null) {\n        \n        // no processor specified, return raw stream\n        NamedList<Object> rsp = new NamedList<Object>();\n        rsp.add(\"stream\", respBody);\n        // Only case where stream should not be closed\n        shouldClose = false;\n        success = true;\n        return rsp;\n      }\n      \n      String procCt = processor.getContentType();\n      if (procCt != null) {\n        String procMimeType = ContentType.parse(procCt).getMimeType().trim().toLowerCase(Locale.ROOT);\n        String mimeType = ContentType.parse(contentType).getMimeType().trim().toLowerCase(Locale.ROOT);\n        if (!procMimeType.equals(mimeType)) {\n          // unexpected mime type\n          String msg = \"Expected mime type \" + procMimeType + \" but got \" + mimeType + \".\";\n          Header encodingHeader = response.getEntity().getContentEncoding();\n          String encoding;\n          if (encodingHeader != null) {\n            encoding = encodingHeader.getValue();\n          } else {\n            encoding = \"UTF-8\"; // try UTF-8\n          }\n          try {\n            msg = msg + \" \" + IOUtils.toString(respBody, encoding);\n          } catch (IOException e) {\n            throw new RemoteSolrException(httpStatus, \"Could not parse response with encoding \" + encoding, e);\n          }\n          RemoteSolrException e = new RemoteSolrException(httpStatus, msg, null);\n          throw e;\n        }\n      }\n      \n//      if(true) {\n//        ByteArrayOutputStream copy = new ByteArrayOutputStream();\n//        IOUtils.copy(respBody, copy);\n//        String val = new String(copy.toByteArray());\n//        System.out.println(\">RESPONSE>\"+val+\"<\"+val.length());\n//        respBody = new ByteArrayInputStream(copy.toByteArray());\n//      }\n      \n      NamedList<Object> rsp = null;\n      String charset = EntityUtils.getContentCharSet(response.getEntity());\n      try {\n        rsp = processor.processResponse(respBody, charset);\n      } catch (Exception e) {\n        throw new RemoteSolrException(httpStatus, e.getMessage(), e);\n      }\n      if (httpStatus != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            // TODO? get the trace?\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase());\n          msg.append(\"\\n\\n\");\n          msg.append(\"request: \" + method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n        }\n        throw new RemoteSolrException(httpStatus, reason, null);\n      }\n      success = true;\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occured while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occured when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (respBody != null && shouldClose) {\n        try {\n          respBody.close();\n        } catch (Throwable t) {} // ignore\n        if (!success) {\n          method.abort();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public NamedList<Object> request(final SolrRequest request,\n      final ResponseParser processor) throws SolrServerException, IOException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( wparams, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean hasNullStreamName = false;\n            if (streams != null) {\n              for (ContentStream cs : streams) {\n                if (cs.getName() == null) {\n                  hasNullStreamName = true;\n                  break;\n                }\n              }\n            }\n            boolean isMultipart = (this.useMultiPartPost || ( streams != null && streams.size() > 1 )) && !hasNullStreamName;\n            \n            // only send this list of params as query string params\n            ModifiableSolrParams queryParams = new ModifiableSolrParams();\n            for (String param : this.queryParams) {\n              String[] value = wparams.getParams(param) ;\n              if (value != null) {\n                for (String v : value) {\n                  queryParams.add(param, v);\n                }\n                wparams.remove(param);\n              }\n            }\n            \n            LinkedList<NameValuePair> postParams = new LinkedList<NameValuePair>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url + ClientUtils.toQueryString( queryParams, false ));\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<FormBodyPart>();\n              Iterator<String> iter = wparams.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = wparams.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart && streams != null) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = BinaryResponseParser.BINARY_CONTENT_TYPE; // default\n                  }\n                  String name = content.getName();\n                  if(name==null) {\n                    name = \"\";\n                  }\n                  parts.add(new FormBodyPart(name, \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(wparams, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    // XXX client already has this set, is this needed?\n    method.getParams().setParameter(ClientPNames.HANDLE_REDIRECTS,\n        followRedirects);\n    method.addHeader(\"User-Agent\", AGENT);\n    \n    InputStream respBody = null;\n    boolean shouldClose = true;\n    boolean success = false;\n    try {\n      // Execute the method.\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      // Read the contents\n      respBody = response.getEntity().getContent();\n      Header ctHeader = response.getLastHeader(\"content-type\");\n      String contentType;\n      if (ctHeader != null) {\n        contentType = ctHeader.getValue();\n      } else {\n        contentType = \"\";\n      }\n      \n      // handle some http level checks before trying to parse the response\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n        case HttpStatus.SC_CONFLICT:  // 409\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        default:\n          if (processor == null) {\n            throw new RemoteSolrException(httpStatus, \"Server at \"\n                + getBaseURL() + \" returned non ok status:\" + httpStatus\n                + \", message:\" + response.getStatusLine().getReasonPhrase(),\n                null);\n          }\n      }\n      if (processor == null) {\n        \n        // no processor specified, return raw stream\n        NamedList<Object> rsp = new NamedList<Object>();\n        rsp.add(\"stream\", respBody);\n        // Only case where stream should not be closed\n        shouldClose = false;\n        success = true;\n        return rsp;\n      }\n      \n      String procCt = processor.getContentType();\n      if (procCt != null) {\n        if (!contentType.equals(procCt)) {\n          // unexpected content type\n          String msg = \"Expected content type \" + procCt + \" but got \" + contentType + \".\";\n          Header encodingHeader = response.getEntity().getContentEncoding();\n          String encoding;\n          if (encodingHeader != null) {\n            encoding = encodingHeader.getValue();\n          } else {\n            encoding = \"UTF-8\"; // try UTF-8\n          }\n          try {\n            msg = msg + \" \" + IOUtils.toString(respBody, encoding);\n          } catch (IOException e) {\n            throw new RemoteSolrException(httpStatus, \"Could not parse response with encoding \" + encoding, e);\n          }\n          RemoteSolrException e = new RemoteSolrException(httpStatus, msg, null);\n          throw e;\n        }\n      }\n      \n//      if(true) {\n//        ByteArrayOutputStream copy = new ByteArrayOutputStream();\n//        IOUtils.copy(respBody, copy);\n//        String val = new String(copy.toByteArray());\n//        System.out.println(\">RESPONSE>\"+val+\"<\"+val.length());\n//        respBody = new ByteArrayInputStream(copy.toByteArray());\n//      }\n      \n      NamedList<Object> rsp = null;\n      String charset = EntityUtils.getContentCharSet(response.getEntity());\n      try {\n        rsp = processor.processResponse(respBody, charset);\n      } catch (Exception e) {\n        throw new RemoteSolrException(httpStatus, e.getMessage(), e);\n      }\n      if (httpStatus != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            // TODO? get the trace?\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase());\n          msg.append(\"\\n\\n\");\n          msg.append(\"request: \" + method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n        }\n        throw new RemoteSolrException(httpStatus, reason, null);\n      }\n      success = true;\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occured while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occured when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (respBody != null && shouldClose) {\n        try {\n          respBody.close();\n        } catch (Throwable t) {} // ignore\n        if (!success) {\n          method.abort();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","sourceNew":"  public NamedList<Object> request(final SolrRequest request,\n      final ResponseParser processor) throws SolrServerException, IOException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( wparams, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean hasNullStreamName = false;\n            if (streams != null) {\n              for (ContentStream cs : streams) {\n                if (cs.getName() == null) {\n                  hasNullStreamName = true;\n                  break;\n                }\n              }\n            }\n            boolean isMultipart = (this.useMultiPartPost || ( streams != null && streams.size() > 1 )) && !hasNullStreamName;\n            \n            // only send this list of params as query string params\n            ModifiableSolrParams queryParams = new ModifiableSolrParams();\n            for (String param : this.queryParams) {\n              String[] value = wparams.getParams(param) ;\n              if (value != null) {\n                for (String v : value) {\n                  queryParams.add(param, v);\n                }\n                wparams.remove(param);\n              }\n            }\n            \n            LinkedList<NameValuePair> postParams = new LinkedList<NameValuePair>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url + ClientUtils.toQueryString( queryParams, false ));\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<FormBodyPart>();\n              Iterator<String> iter = wparams.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = wparams.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart && streams != null) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = BinaryResponseParser.BINARY_CONTENT_TYPE; // default\n                  }\n                  String name = content.getName();\n                  if(name==null) {\n                    name = \"\";\n                  }\n                  parts.add(new FormBodyPart(name, \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(wparams, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    // XXX client already has this set, is this needed?\n    method.getParams().setParameter(ClientPNames.HANDLE_REDIRECTS,\n        followRedirects);\n    method.addHeader(\"User-Agent\", AGENT);\n    \n    InputStream respBody = null;\n    boolean shouldClose = true;\n    boolean success = false;\n    try {\n      // Execute the method.\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      // Read the contents\n      respBody = response.getEntity().getContent();\n      Header ctHeader = response.getLastHeader(\"content-type\");\n      String contentType;\n      if (ctHeader != null) {\n        contentType = ctHeader.getValue();\n      } else {\n        contentType = \"\";\n      }\n      \n      // handle some http level checks before trying to parse the response\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n        case HttpStatus.SC_CONFLICT:  // 409\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        default:\n          if (processor == null) {\n            throw new RemoteSolrException(httpStatus, \"Server at \"\n                + getBaseURL() + \" returned non ok status:\" + httpStatus\n                + \", message:\" + response.getStatusLine().getReasonPhrase(),\n                null);\n          }\n      }\n      if (processor == null) {\n        \n        // no processor specified, return raw stream\n        NamedList<Object> rsp = new NamedList<Object>();\n        rsp.add(\"stream\", respBody);\n        // Only case where stream should not be closed\n        shouldClose = false;\n        success = true;\n        return rsp;\n      }\n      \n      String procCt = processor.getContentType();\n      if (procCt != null) {\n        String procMimeType = ContentType.parse(procCt).getMimeType().trim().toLowerCase(Locale.ROOT);\n        String mimeType = ContentType.parse(contentType).getMimeType().trim().toLowerCase(Locale.ROOT);\n        if (!procMimeType.equals(mimeType)) {\n          // unexpected mime type\n          String msg = \"Expected mime type \" + procMimeType + \" but got \" + mimeType + \".\";\n          Header encodingHeader = response.getEntity().getContentEncoding();\n          String encoding;\n          if (encodingHeader != null) {\n            encoding = encodingHeader.getValue();\n          } else {\n            encoding = \"UTF-8\"; // try UTF-8\n          }\n          try {\n            msg = msg + \" \" + IOUtils.toString(respBody, encoding);\n          } catch (IOException e) {\n            throw new RemoteSolrException(httpStatus, \"Could not parse response with encoding \" + encoding, e);\n          }\n          RemoteSolrException e = new RemoteSolrException(httpStatus, msg, null);\n          throw e;\n        }\n      }\n      \n//      if(true) {\n//        ByteArrayOutputStream copy = new ByteArrayOutputStream();\n//        IOUtils.copy(respBody, copy);\n//        String val = new String(copy.toByteArray());\n//        System.out.println(\">RESPONSE>\"+val+\"<\"+val.length());\n//        respBody = new ByteArrayInputStream(copy.toByteArray());\n//      }\n      \n      NamedList<Object> rsp = null;\n      String charset = EntityUtils.getContentCharSet(response.getEntity());\n      try {\n        rsp = processor.processResponse(respBody, charset);\n      } catch (Exception e) {\n        throw new RemoteSolrException(httpStatus, e.getMessage(), e);\n      }\n      if (httpStatus != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            // TODO? get the trace?\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase());\n          msg.append(\"\\n\\n\");\n          msg.append(\"request: \" + method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n        }\n        throw new RemoteSolrException(httpStatus, reason, null);\n      }\n      success = true;\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occured while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occured when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (respBody != null && shouldClose) {\n        try {\n          respBody.close();\n        } catch (Throwable t) {} // ignore\n        if (!success) {\n          method.abort();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public NamedList<Object> request(final SolrRequest request,\n      final ResponseParser processor) throws SolrServerException, IOException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    params = wparams;\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean hasNullStreamName = false;\n            if (streams != null) {\n              for (ContentStream cs : streams) {\n                if (cs.getName() == null) {\n                  hasNullStreamName = true;\n                  break;\n                }\n              }\n            }\n            boolean isMultipart = (this.useMultiPartPost || ( streams != null && streams.size() > 1 )) && !hasNullStreamName;\n\n            LinkedList<NameValuePair> postParams = new LinkedList<NameValuePair>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url);\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<FormBodyPart>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart && streams != null) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = BinaryResponseParser.BINARY_CONTENT_TYPE; // default\n                  }\n                  String name = content.getName();\n                  if(name==null) {\n                    name = \"\";\n                  }\n                  parts.add(new FormBodyPart(name, \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    // XXX client already has this set, is this needed?\n    method.getParams().setParameter(ClientPNames.HANDLE_REDIRECTS,\n        followRedirects);\n    method.addHeader(\"User-Agent\", AGENT);\n    \n    InputStream respBody = null;\n    boolean shouldClose = true;\n    boolean success = false;\n    try {\n      // Execute the method.\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      // Read the contents\n      respBody = response.getEntity().getContent();\n      Header ctHeader = response.getLastHeader(\"content-type\");\n      String contentType;\n      if (ctHeader != null) {\n        contentType = ctHeader.getValue();\n      } else {\n        contentType = \"\";\n      }\n      \n      // handle some http level checks before trying to parse the response\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n        case HttpStatus.SC_CONFLICT:  // 409\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        default:\n          if (processor == null) {\n            throw new RemoteSolrException(httpStatus, \"Server at \"\n                + getBaseURL() + \" returned non ok status:\" + httpStatus\n                + \", message:\" + response.getStatusLine().getReasonPhrase(),\n                null);\n          }\n      }\n      if (processor == null) {\n        \n        // no processor specified, return raw stream\n        NamedList<Object> rsp = new NamedList<Object>();\n        rsp.add(\"stream\", respBody);\n        // Only case where stream should not be closed\n        shouldClose = false;\n        success = true;\n        return rsp;\n      }\n      \n      String procCt = processor.getContentType();\n      if (procCt != null) {\n        if (!contentType.equals(procCt)) {\n          // unexpected content type\n          String msg = \"Expected content type \" + procCt + \" but got \" + contentType + \".\";\n          Header encodingHeader = response.getEntity().getContentEncoding();\n          String encoding;\n          if (encodingHeader != null) {\n            encoding = encodingHeader.getValue();\n          } else {\n            encoding = \"UTF-8\"; // try UTF-8\n          }\n          try {\n            msg = msg + \" \" + IOUtils.toString(respBody, encoding);\n          } catch (IOException e) {\n            throw new RemoteSolrException(httpStatus, \"Could not parse response with encoding \" + encoding, e);\n          }\n          RemoteSolrException e = new RemoteSolrException(httpStatus, msg, null);\n          throw e;\n        }\n      }\n      \n//      if(true) {\n//        ByteArrayOutputStream copy = new ByteArrayOutputStream();\n//        IOUtils.copy(respBody, copy);\n//        String val = new String(copy.toByteArray());\n//        System.out.println(\">RESPONSE>\"+val+\"<\"+val.length());\n//        respBody = new ByteArrayInputStream(copy.toByteArray());\n//      }\n      \n      NamedList<Object> rsp = null;\n      String charset = EntityUtils.getContentCharSet(response.getEntity());\n      try {\n        rsp = processor.processResponse(respBody, charset);\n      } catch (Exception e) {\n        throw new RemoteSolrException(httpStatus, e.getMessage(), e);\n      }\n      if (httpStatus != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            // TODO? get the trace?\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase());\n          msg.append(\"\\n\\n\");\n          msg.append(\"request: \" + method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n        }\n        throw new RemoteSolrException(httpStatus, reason, null);\n      }\n      success = true;\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occured while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occured when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (respBody != null && shouldClose) {\n        try {\n          respBody.close();\n        } catch (Throwable t) {} // ignore\n        if (!success) {\n          method.abort();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2","date":1389633998,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","sourceNew":"  public NamedList<Object> request(final SolrRequest request,\n      final ResponseParser processor) throws SolrServerException, IOException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( wparams, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean hasNullStreamName = false;\n            if (streams != null) {\n              for (ContentStream cs : streams) {\n                if (cs.getName() == null) {\n                  hasNullStreamName = true;\n                  break;\n                }\n              }\n            }\n            boolean isMultipart = (this.useMultiPartPost || ( streams != null && streams.size() > 1 )) && !hasNullStreamName;\n            \n            // only send this list of params as query string params\n            ModifiableSolrParams queryParams = new ModifiableSolrParams();\n            for (String param : this.queryParams) {\n              String[] value = wparams.getParams(param) ;\n              if (value != null) {\n                for (String v : value) {\n                  queryParams.add(param, v);\n                }\n                wparams.remove(param);\n              }\n            }\n            \n            LinkedList<NameValuePair> postParams = new LinkedList<NameValuePair>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url + ClientUtils.toQueryString( queryParams, false ));\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<FormBodyPart>();\n              Iterator<String> iter = wparams.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = wparams.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart && streams != null) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = BinaryResponseParser.BINARY_CONTENT_TYPE; // default\n                  }\n                  String name = content.getName();\n                  if(name==null) {\n                    name = \"\";\n                  }\n                  parts.add(new FormBodyPart(name, \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(wparams, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    // XXX client already has this set, is this needed?\n    method.getParams().setParameter(ClientPNames.HANDLE_REDIRECTS,\n        followRedirects);\n    method.addHeader(\"User-Agent\", AGENT);\n    \n    InputStream respBody = null;\n    boolean shouldClose = true;\n    boolean success = false;\n    try {\n      // Execute the method.\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      // Read the contents\n      respBody = response.getEntity().getContent();\n      Header ctHeader = response.getLastHeader(\"content-type\");\n      String contentType;\n      if (ctHeader != null) {\n        contentType = ctHeader.getValue();\n      } else {\n        contentType = \"\";\n      }\n      \n      // handle some http level checks before trying to parse the response\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n        case HttpStatus.SC_CONFLICT:  // 409\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        default:\n          if (processor == null) {\n            throw new RemoteSolrException(httpStatus, \"Server at \"\n                + getBaseURL() + \" returned non ok status:\" + httpStatus\n                + \", message:\" + response.getStatusLine().getReasonPhrase(),\n                null);\n          }\n      }\n      if (processor == null) {\n        \n        // no processor specified, return raw stream\n        NamedList<Object> rsp = new NamedList<Object>();\n        rsp.add(\"stream\", respBody);\n        // Only case where stream should not be closed\n        shouldClose = false;\n        success = true;\n        return rsp;\n      }\n      \n      String procCt = processor.getContentType();\n      if (procCt != null) {\n        String procMimeType = ContentType.parse(procCt).getMimeType().trim().toLowerCase(Locale.ROOT);\n        String mimeType = ContentType.parse(contentType).getMimeType().trim().toLowerCase(Locale.ROOT);\n        if (!procMimeType.equals(mimeType)) {\n          // unexpected mime type\n          String msg = \"Expected mime type \" + procMimeType + \" but got \" + mimeType + \".\";\n          Header encodingHeader = response.getEntity().getContentEncoding();\n          String encoding;\n          if (encodingHeader != null) {\n            encoding = encodingHeader.getValue();\n          } else {\n            encoding = \"UTF-8\"; // try UTF-8\n          }\n          try {\n            msg = msg + \" \" + IOUtils.toString(respBody, encoding);\n          } catch (IOException e) {\n            throw new RemoteSolrException(httpStatus, \"Could not parse response with encoding \" + encoding, e);\n          }\n          RemoteSolrException e = new RemoteSolrException(httpStatus, msg, null);\n          throw e;\n        }\n      }\n      \n//      if(true) {\n//        ByteArrayOutputStream copy = new ByteArrayOutputStream();\n//        IOUtils.copy(respBody, copy);\n//        String val = new String(copy.toByteArray());\n//        System.out.println(\">RESPONSE>\"+val+\"<\"+val.length());\n//        respBody = new ByteArrayInputStream(copy.toByteArray());\n//      }\n      \n      NamedList<Object> rsp = null;\n      String charset = EntityUtils.getContentCharSet(response.getEntity());\n      try {\n        rsp = processor.processResponse(respBody, charset);\n      } catch (Exception e) {\n        throw new RemoteSolrException(httpStatus, e.getMessage(), e);\n      }\n      if (httpStatus != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            // TODO? get the trace?\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase());\n          msg.append(\"\\n\\n\");\n          msg.append(\"request: \" + method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n        }\n        throw new RemoteSolrException(httpStatus, reason, null);\n      }\n      success = true;\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occured while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occured when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (respBody != null && shouldClose) {\n        try {\n          respBody.close();\n        } catch (IOException e) {\n          log.error(\"\", e);\n        } finally {\n          if (!success) {\n            method.abort();\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public NamedList<Object> request(final SolrRequest request,\n      final ResponseParser processor) throws SolrServerException, IOException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( wparams, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean hasNullStreamName = false;\n            if (streams != null) {\n              for (ContentStream cs : streams) {\n                if (cs.getName() == null) {\n                  hasNullStreamName = true;\n                  break;\n                }\n              }\n            }\n            boolean isMultipart = (this.useMultiPartPost || ( streams != null && streams.size() > 1 )) && !hasNullStreamName;\n            \n            // only send this list of params as query string params\n            ModifiableSolrParams queryParams = new ModifiableSolrParams();\n            for (String param : this.queryParams) {\n              String[] value = wparams.getParams(param) ;\n              if (value != null) {\n                for (String v : value) {\n                  queryParams.add(param, v);\n                }\n                wparams.remove(param);\n              }\n            }\n            \n            LinkedList<NameValuePair> postParams = new LinkedList<NameValuePair>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url + ClientUtils.toQueryString( queryParams, false ));\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<FormBodyPart>();\n              Iterator<String> iter = wparams.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = wparams.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart && streams != null) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = BinaryResponseParser.BINARY_CONTENT_TYPE; // default\n                  }\n                  String name = content.getName();\n                  if(name==null) {\n                    name = \"\";\n                  }\n                  parts.add(new FormBodyPart(name, \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(wparams, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    // XXX client already has this set, is this needed?\n    method.getParams().setParameter(ClientPNames.HANDLE_REDIRECTS,\n        followRedirects);\n    method.addHeader(\"User-Agent\", AGENT);\n    \n    InputStream respBody = null;\n    boolean shouldClose = true;\n    boolean success = false;\n    try {\n      // Execute the method.\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      // Read the contents\n      respBody = response.getEntity().getContent();\n      Header ctHeader = response.getLastHeader(\"content-type\");\n      String contentType;\n      if (ctHeader != null) {\n        contentType = ctHeader.getValue();\n      } else {\n        contentType = \"\";\n      }\n      \n      // handle some http level checks before trying to parse the response\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n        case HttpStatus.SC_CONFLICT:  // 409\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        default:\n          if (processor == null) {\n            throw new RemoteSolrException(httpStatus, \"Server at \"\n                + getBaseURL() + \" returned non ok status:\" + httpStatus\n                + \", message:\" + response.getStatusLine().getReasonPhrase(),\n                null);\n          }\n      }\n      if (processor == null) {\n        \n        // no processor specified, return raw stream\n        NamedList<Object> rsp = new NamedList<Object>();\n        rsp.add(\"stream\", respBody);\n        // Only case where stream should not be closed\n        shouldClose = false;\n        success = true;\n        return rsp;\n      }\n      \n      String procCt = processor.getContentType();\n      if (procCt != null) {\n        String procMimeType = ContentType.parse(procCt).getMimeType().trim().toLowerCase(Locale.ROOT);\n        String mimeType = ContentType.parse(contentType).getMimeType().trim().toLowerCase(Locale.ROOT);\n        if (!procMimeType.equals(mimeType)) {\n          // unexpected mime type\n          String msg = \"Expected mime type \" + procMimeType + \" but got \" + mimeType + \".\";\n          Header encodingHeader = response.getEntity().getContentEncoding();\n          String encoding;\n          if (encodingHeader != null) {\n            encoding = encodingHeader.getValue();\n          } else {\n            encoding = \"UTF-8\"; // try UTF-8\n          }\n          try {\n            msg = msg + \" \" + IOUtils.toString(respBody, encoding);\n          } catch (IOException e) {\n            throw new RemoteSolrException(httpStatus, \"Could not parse response with encoding \" + encoding, e);\n          }\n          RemoteSolrException e = new RemoteSolrException(httpStatus, msg, null);\n          throw e;\n        }\n      }\n      \n//      if(true) {\n//        ByteArrayOutputStream copy = new ByteArrayOutputStream();\n//        IOUtils.copy(respBody, copy);\n//        String val = new String(copy.toByteArray());\n//        System.out.println(\">RESPONSE>\"+val+\"<\"+val.length());\n//        respBody = new ByteArrayInputStream(copy.toByteArray());\n//      }\n      \n      NamedList<Object> rsp = null;\n      String charset = EntityUtils.getContentCharSet(response.getEntity());\n      try {\n        rsp = processor.processResponse(respBody, charset);\n      } catch (Exception e) {\n        throw new RemoteSolrException(httpStatus, e.getMessage(), e);\n      }\n      if (httpStatus != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            // TODO? get the trace?\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase());\n          msg.append(\"\\n\\n\");\n          msg.append(\"request: \" + method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n        }\n        throw new RemoteSolrException(httpStatus, reason, null);\n      }\n      success = true;\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occured while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occured when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (respBody != null && shouldClose) {\n        try {\n          respBody.close();\n        } catch (Throwable t) {} // ignore\n        if (!success) {\n          method.abort();\n        }\n      }\n    }\n  }\n\n","bugFix":["f1b4258e8d84ded627a66ea993d8c7acdc6ae7ad","7321b77a7bc3edfebd637ef273e9dfaa9969eba6"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a6446ce810056afd1a06b7a7239ec3cb3b65e31e","date":1393220603,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","sourceNew":"  public NamedList<Object> request(final SolrRequest request,\n      final ResponseParser processor) throws SolrServerException, IOException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( wparams, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean hasNullStreamName = false;\n            if (streams != null) {\n              for (ContentStream cs : streams) {\n                if (cs.getName() == null) {\n                  hasNullStreamName = true;\n                  break;\n                }\n              }\n            }\n            boolean isMultipart = (this.useMultiPartPost || ( streams != null && streams.size() > 1 )) && !hasNullStreamName;\n            \n            // only send this list of params as query string params\n            ModifiableSolrParams queryParams = new ModifiableSolrParams();\n            for (String param : this.queryParams) {\n              String[] value = wparams.getParams(param) ;\n              if (value != null) {\n                for (String v : value) {\n                  queryParams.add(param, v);\n                }\n                wparams.remove(param);\n              }\n            }\n            \n            LinkedList<NameValuePair> postParams = new LinkedList<NameValuePair>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url + ClientUtils.toQueryString( queryParams, false ));\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<FormBodyPart>();\n              Iterator<String> iter = wparams.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = wparams.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart && streams != null) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = BinaryResponseParser.BINARY_CONTENT_TYPE; // default\n                  }\n                  String name = content.getName();\n                  if(name==null) {\n                    name = \"\";\n                  }\n                  parts.add(new FormBodyPart(name, \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(wparams, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    // XXX client already has this set, is this needed?\n    method.getParams().setParameter(ClientPNames.HANDLE_REDIRECTS,\n        followRedirects);\n    method.addHeader(\"User-Agent\", AGENT);\n    \n    InputStream respBody = null;\n    boolean shouldClose = true;\n    boolean success = false;\n    try {\n      // Execute the method.\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      // Read the contents\n      respBody = response.getEntity().getContent();\n      Header ctHeader = response.getLastHeader(\"content-type\");\n      String contentType;\n      if (ctHeader != null) {\n        contentType = ctHeader.getValue();\n      } else {\n        contentType = \"\";\n      }\n      \n      // handle some http level checks before trying to parse the response\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n        case HttpStatus.SC_CONFLICT:  // 409\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        default:\n          if (processor == null) {\n            throw new RemoteSolrException(httpStatus, \"Server at \"\n                + getBaseURL() + \" returned non ok status:\" + httpStatus\n                + \", message:\" + response.getStatusLine().getReasonPhrase(),\n                null);\n          }\n      }\n      if (processor == null) {\n        \n        // no processor specified, return raw stream\n        NamedList<Object> rsp = new NamedList<Object>();\n        rsp.add(\"stream\", respBody);\n        // Only case where stream should not be closed\n        shouldClose = false;\n        success = true;\n        return rsp;\n      }\n      \n      String procCt = processor.getContentType();\n      if (procCt != null) {\n        String procMimeType = ContentType.parse(procCt).getMimeType().trim().toLowerCase(Locale.ROOT);\n        String mimeType = ContentType.parse(contentType).getMimeType().trim().toLowerCase(Locale.ROOT);\n        if (!procMimeType.equals(mimeType)) {\n          // unexpected mime type\n          String msg = \"Expected mime type \" + procMimeType + \" but got \" + mimeType + \".\";\n          Header encodingHeader = response.getEntity().getContentEncoding();\n          String encoding;\n          if (encodingHeader != null) {\n            encoding = encodingHeader.getValue();\n          } else {\n            encoding = \"UTF-8\"; // try UTF-8\n          }\n          try {\n            msg = msg + \" \" + IOUtils.toString(respBody, encoding);\n          } catch (IOException e) {\n            throw new RemoteSolrException(httpStatus, \"Could not parse response with encoding \" + encoding, e);\n          }\n          RemoteSolrException e = new RemoteSolrException(httpStatus, msg, null);\n          throw e;\n        }\n      }\n      \n//      if(true) {\n//        ByteArrayOutputStream copy = new ByteArrayOutputStream();\n//        IOUtils.copy(respBody, copy);\n//        String val = new String(copy.toByteArray());\n//        System.out.println(\">RESPONSE>\"+val+\"<\"+val.length());\n//        respBody = new ByteArrayInputStream(copy.toByteArray());\n//      }\n      \n      NamedList<Object> rsp = null;\n      String charset = EntityUtils.getContentCharSet(response.getEntity());\n      try {\n        rsp = processor.processResponse(respBody, charset);\n      } catch (Exception e) {\n        throw new RemoteSolrException(httpStatus, e.getMessage(), e);\n      }\n      if (httpStatus != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            if(reason == null) {\n              reason = (String) err.get(\"trace\");\n            }\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase());\n          msg.append(\"\\n\\n\");\n          msg.append(\"request: \" + method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n        }\n        throw new RemoteSolrException(httpStatus, reason, null);\n      }\n      success = true;\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occured while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occured when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (respBody != null && shouldClose) {\n        try {\n          respBody.close();\n        } catch (IOException e) {\n          log.error(\"\", e);\n        } finally {\n          if (!success) {\n            method.abort();\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public NamedList<Object> request(final SolrRequest request,\n      final ResponseParser processor) throws SolrServerException, IOException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( wparams, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean hasNullStreamName = false;\n            if (streams != null) {\n              for (ContentStream cs : streams) {\n                if (cs.getName() == null) {\n                  hasNullStreamName = true;\n                  break;\n                }\n              }\n            }\n            boolean isMultipart = (this.useMultiPartPost || ( streams != null && streams.size() > 1 )) && !hasNullStreamName;\n            \n            // only send this list of params as query string params\n            ModifiableSolrParams queryParams = new ModifiableSolrParams();\n            for (String param : this.queryParams) {\n              String[] value = wparams.getParams(param) ;\n              if (value != null) {\n                for (String v : value) {\n                  queryParams.add(param, v);\n                }\n                wparams.remove(param);\n              }\n            }\n            \n            LinkedList<NameValuePair> postParams = new LinkedList<NameValuePair>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url + ClientUtils.toQueryString( queryParams, false ));\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<FormBodyPart>();\n              Iterator<String> iter = wparams.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = wparams.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart && streams != null) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = BinaryResponseParser.BINARY_CONTENT_TYPE; // default\n                  }\n                  String name = content.getName();\n                  if(name==null) {\n                    name = \"\";\n                  }\n                  parts.add(new FormBodyPart(name, \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(wparams, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    // XXX client already has this set, is this needed?\n    method.getParams().setParameter(ClientPNames.HANDLE_REDIRECTS,\n        followRedirects);\n    method.addHeader(\"User-Agent\", AGENT);\n    \n    InputStream respBody = null;\n    boolean shouldClose = true;\n    boolean success = false;\n    try {\n      // Execute the method.\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      // Read the contents\n      respBody = response.getEntity().getContent();\n      Header ctHeader = response.getLastHeader(\"content-type\");\n      String contentType;\n      if (ctHeader != null) {\n        contentType = ctHeader.getValue();\n      } else {\n        contentType = \"\";\n      }\n      \n      // handle some http level checks before trying to parse the response\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n        case HttpStatus.SC_CONFLICT:  // 409\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        default:\n          if (processor == null) {\n            throw new RemoteSolrException(httpStatus, \"Server at \"\n                + getBaseURL() + \" returned non ok status:\" + httpStatus\n                + \", message:\" + response.getStatusLine().getReasonPhrase(),\n                null);\n          }\n      }\n      if (processor == null) {\n        \n        // no processor specified, return raw stream\n        NamedList<Object> rsp = new NamedList<Object>();\n        rsp.add(\"stream\", respBody);\n        // Only case where stream should not be closed\n        shouldClose = false;\n        success = true;\n        return rsp;\n      }\n      \n      String procCt = processor.getContentType();\n      if (procCt != null) {\n        String procMimeType = ContentType.parse(procCt).getMimeType().trim().toLowerCase(Locale.ROOT);\n        String mimeType = ContentType.parse(contentType).getMimeType().trim().toLowerCase(Locale.ROOT);\n        if (!procMimeType.equals(mimeType)) {\n          // unexpected mime type\n          String msg = \"Expected mime type \" + procMimeType + \" but got \" + mimeType + \".\";\n          Header encodingHeader = response.getEntity().getContentEncoding();\n          String encoding;\n          if (encodingHeader != null) {\n            encoding = encodingHeader.getValue();\n          } else {\n            encoding = \"UTF-8\"; // try UTF-8\n          }\n          try {\n            msg = msg + \" \" + IOUtils.toString(respBody, encoding);\n          } catch (IOException e) {\n            throw new RemoteSolrException(httpStatus, \"Could not parse response with encoding \" + encoding, e);\n          }\n          RemoteSolrException e = new RemoteSolrException(httpStatus, msg, null);\n          throw e;\n        }\n      }\n      \n//      if(true) {\n//        ByteArrayOutputStream copy = new ByteArrayOutputStream();\n//        IOUtils.copy(respBody, copy);\n//        String val = new String(copy.toByteArray());\n//        System.out.println(\">RESPONSE>\"+val+\"<\"+val.length());\n//        respBody = new ByteArrayInputStream(copy.toByteArray());\n//      }\n      \n      NamedList<Object> rsp = null;\n      String charset = EntityUtils.getContentCharSet(response.getEntity());\n      try {\n        rsp = processor.processResponse(respBody, charset);\n      } catch (Exception e) {\n        throw new RemoteSolrException(httpStatus, e.getMessage(), e);\n      }\n      if (httpStatus != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            // TODO? get the trace?\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase());\n          msg.append(\"\\n\\n\");\n          msg.append(\"request: \" + method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n        }\n        throw new RemoteSolrException(httpStatus, reason, null);\n      }\n      success = true;\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occured while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occured when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (respBody != null && shouldClose) {\n        try {\n          respBody.close();\n        } catch (IOException e) {\n          log.error(\"\", e);\n        } finally {\n          if (!success) {\n            method.abort();\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"13f445c5bd6f19fd57d5a3ca0a35244c96f45aa8","date":1393532551,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","sourceNew":"  public NamedList<Object> request(final SolrRequest request,\n      final ResponseParser processor) throws SolrServerException, IOException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( wparams, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean hasNullStreamName = false;\n            if (streams != null) {\n              for (ContentStream cs : streams) {\n                if (cs.getName() == null) {\n                  hasNullStreamName = true;\n                  break;\n                }\n              }\n            }\n            boolean isMultipart = (this.useMultiPartPost || ( streams != null && streams.size() > 1 )) && !hasNullStreamName;\n            \n            // only send this list of params as query string params\n            ModifiableSolrParams queryParams = new ModifiableSolrParams();\n            for (String param : this.queryParams) {\n              String[] value = wparams.getParams(param) ;\n              if (value != null) {\n                for (String v : value) {\n                  queryParams.add(param, v);\n                }\n                wparams.remove(param);\n              }\n            }\n            \n            LinkedList<NameValuePair> postParams = new LinkedList<NameValuePair>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url + ClientUtils.toQueryString( queryParams, false ));\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<FormBodyPart>();\n              Iterator<String> iter = wparams.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = wparams.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart && streams != null) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = BinaryResponseParser.BINARY_CONTENT_TYPE; // default\n                  }\n                  String name = content.getName();\n                  if(name==null) {\n                    name = \"\";\n                  }\n                  parts.add(new FormBodyPart(name, \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(wparams, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    // XXX client already has this set, is this needed?\n    method.getParams().setParameter(ClientPNames.HANDLE_REDIRECTS,\n        followRedirects);\n    method.addHeader(\"User-Agent\", AGENT);\n    \n    InputStream respBody = null;\n    boolean shouldClose = true;\n    boolean success = false;\n    try {\n      // Execute the method.\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      // Read the contents\n      respBody = response.getEntity().getContent();\n      Header ctHeader = response.getLastHeader(\"content-type\");\n      String contentType;\n      if (ctHeader != null) {\n        contentType = ctHeader.getValue();\n      } else {\n        contentType = \"\";\n      }\n      \n      // handle some http level checks before trying to parse the response\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n        case HttpStatus.SC_CONFLICT:  // 409\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        default:\n          if (processor == null) {\n            throw new RemoteSolrException(httpStatus, \"Server at \"\n                + getBaseURL() + \" returned non ok status:\" + httpStatus\n                + \", message:\" + response.getStatusLine().getReasonPhrase(),\n                null);\n          }\n      }\n      if (processor == null) {\n        \n        // no processor specified, return raw stream\n        NamedList<Object> rsp = new NamedList<Object>();\n        rsp.add(\"stream\", respBody);\n        // Only case where stream should not be closed\n        shouldClose = false;\n        success = true;\n        return rsp;\n      }\n      \n      String procCt = processor.getContentType();\n      if (procCt != null) {\n        String procMimeType = ContentType.parse(procCt).getMimeType().trim().toLowerCase(Locale.ROOT);\n        String mimeType = ContentType.parse(contentType).getMimeType().trim().toLowerCase(Locale.ROOT);\n        if (!procMimeType.equals(mimeType)) {\n          // unexpected mime type\n          String msg = \"Expected mime type \" + procMimeType + \" but got \" + mimeType + \".\";\n          Header encodingHeader = response.getEntity().getContentEncoding();\n          String encoding;\n          if (encodingHeader != null) {\n            encoding = encodingHeader.getValue();\n          } else {\n            encoding = \"UTF-8\"; // try UTF-8\n          }\n          try {\n            msg = msg + \" \" + IOUtils.toString(respBody, encoding);\n          } catch (IOException e) {\n            throw new RemoteSolrException(httpStatus, \"Could not parse response with encoding \" + encoding, e);\n          }\n          RemoteSolrException e = new RemoteSolrException(httpStatus, msg, null);\n          throw e;\n        }\n      }\n      \n//      if(true) {\n//        ByteArrayOutputStream copy = new ByteArrayOutputStream();\n//        IOUtils.copy(respBody, copy);\n//        String val = new String(copy.toByteArray());\n//        System.out.println(\">RESPONSE>\"+val+\"<\"+val.length());\n//        respBody = new ByteArrayInputStream(copy.toByteArray());\n//      }\n      \n      NamedList<Object> rsp = null;\n      String charset = EntityUtils.getContentCharSet(response.getEntity());\n      try {\n        rsp = processor.processResponse(respBody, charset);\n      } catch (Exception e) {\n        throw new RemoteSolrException(httpStatus, e.getMessage(), e);\n      }\n      if (httpStatus != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            if(reason == null) {\n              reason = (String) err.get(\"trace\");\n            }\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase());\n          msg.append(\"\\n\\n\");\n          msg.append(\"request: \" + method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n        }\n        throw new RemoteSolrException(httpStatus, reason, null);\n      }\n      success = true;\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occured while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occured when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (respBody != null && shouldClose) {\n        try {\n          respBody.close();\n        } catch (IOException e) {\n          log.error(\"\", e);\n        } finally {\n          if (!success) {\n            method.abort();\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public NamedList<Object> request(final SolrRequest request,\n      final ResponseParser processor) throws SolrServerException, IOException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( wparams, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean hasNullStreamName = false;\n            if (streams != null) {\n              for (ContentStream cs : streams) {\n                if (cs.getName() == null) {\n                  hasNullStreamName = true;\n                  break;\n                }\n              }\n            }\n            boolean isMultipart = (this.useMultiPartPost || ( streams != null && streams.size() > 1 )) && !hasNullStreamName;\n            \n            // only send this list of params as query string params\n            ModifiableSolrParams queryParams = new ModifiableSolrParams();\n            for (String param : this.queryParams) {\n              String[] value = wparams.getParams(param) ;\n              if (value != null) {\n                for (String v : value) {\n                  queryParams.add(param, v);\n                }\n                wparams.remove(param);\n              }\n            }\n            \n            LinkedList<NameValuePair> postParams = new LinkedList<NameValuePair>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url + ClientUtils.toQueryString( queryParams, false ));\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<FormBodyPart>();\n              Iterator<String> iter = wparams.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = wparams.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart && streams != null) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = BinaryResponseParser.BINARY_CONTENT_TYPE; // default\n                  }\n                  String name = content.getName();\n                  if(name==null) {\n                    name = \"\";\n                  }\n                  parts.add(new FormBodyPart(name, \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(wparams, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    // XXX client already has this set, is this needed?\n    method.getParams().setParameter(ClientPNames.HANDLE_REDIRECTS,\n        followRedirects);\n    method.addHeader(\"User-Agent\", AGENT);\n    \n    InputStream respBody = null;\n    boolean shouldClose = true;\n    boolean success = false;\n    try {\n      // Execute the method.\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      // Read the contents\n      respBody = response.getEntity().getContent();\n      Header ctHeader = response.getLastHeader(\"content-type\");\n      String contentType;\n      if (ctHeader != null) {\n        contentType = ctHeader.getValue();\n      } else {\n        contentType = \"\";\n      }\n      \n      // handle some http level checks before trying to parse the response\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n        case HttpStatus.SC_CONFLICT:  // 409\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        default:\n          if (processor == null) {\n            throw new RemoteSolrException(httpStatus, \"Server at \"\n                + getBaseURL() + \" returned non ok status:\" + httpStatus\n                + \", message:\" + response.getStatusLine().getReasonPhrase(),\n                null);\n          }\n      }\n      if (processor == null) {\n        \n        // no processor specified, return raw stream\n        NamedList<Object> rsp = new NamedList<Object>();\n        rsp.add(\"stream\", respBody);\n        // Only case where stream should not be closed\n        shouldClose = false;\n        success = true;\n        return rsp;\n      }\n      \n      String procCt = processor.getContentType();\n      if (procCt != null) {\n        String procMimeType = ContentType.parse(procCt).getMimeType().trim().toLowerCase(Locale.ROOT);\n        String mimeType = ContentType.parse(contentType).getMimeType().trim().toLowerCase(Locale.ROOT);\n        if (!procMimeType.equals(mimeType)) {\n          // unexpected mime type\n          String msg = \"Expected mime type \" + procMimeType + \" but got \" + mimeType + \".\";\n          Header encodingHeader = response.getEntity().getContentEncoding();\n          String encoding;\n          if (encodingHeader != null) {\n            encoding = encodingHeader.getValue();\n          } else {\n            encoding = \"UTF-8\"; // try UTF-8\n          }\n          try {\n            msg = msg + \" \" + IOUtils.toString(respBody, encoding);\n          } catch (IOException e) {\n            throw new RemoteSolrException(httpStatus, \"Could not parse response with encoding \" + encoding, e);\n          }\n          RemoteSolrException e = new RemoteSolrException(httpStatus, msg, null);\n          throw e;\n        }\n      }\n      \n//      if(true) {\n//        ByteArrayOutputStream copy = new ByteArrayOutputStream();\n//        IOUtils.copy(respBody, copy);\n//        String val = new String(copy.toByteArray());\n//        System.out.println(\">RESPONSE>\"+val+\"<\"+val.length());\n//        respBody = new ByteArrayInputStream(copy.toByteArray());\n//      }\n      \n      NamedList<Object> rsp = null;\n      String charset = EntityUtils.getContentCharSet(response.getEntity());\n      try {\n        rsp = processor.processResponse(respBody, charset);\n      } catch (Exception e) {\n        throw new RemoteSolrException(httpStatus, e.getMessage(), e);\n      }\n      if (httpStatus != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            // TODO? get the trace?\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase());\n          msg.append(\"\\n\\n\");\n          msg.append(\"request: \" + method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n        }\n        throw new RemoteSolrException(httpStatus, reason, null);\n      }\n      success = true;\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occured while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occured when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (respBody != null && shouldClose) {\n        try {\n          respBody.close();\n        } catch (IOException e) {\n          log.error(\"\", e);\n        } finally {\n          if (!success) {\n            method.abort();\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4be6b65a4bd628f9b1c1a8832622df34d6eba980","date":1394300189,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","sourceNew":"  public NamedList<Object> request(final SolrRequest request, final ResponseParser processor) throws SolrServerException, IOException {\n    return executeMethod(createMethod(request),processor);\n  }\n\n","sourceOld":"  public NamedList<Object> request(final SolrRequest request,\n      final ResponseParser processor) throws SolrServerException, IOException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( wparams, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean hasNullStreamName = false;\n            if (streams != null) {\n              for (ContentStream cs : streams) {\n                if (cs.getName() == null) {\n                  hasNullStreamName = true;\n                  break;\n                }\n              }\n            }\n            boolean isMultipart = (this.useMultiPartPost || ( streams != null && streams.size() > 1 )) && !hasNullStreamName;\n            \n            // only send this list of params as query string params\n            ModifiableSolrParams queryParams = new ModifiableSolrParams();\n            for (String param : this.queryParams) {\n              String[] value = wparams.getParams(param) ;\n              if (value != null) {\n                for (String v : value) {\n                  queryParams.add(param, v);\n                }\n                wparams.remove(param);\n              }\n            }\n            \n            LinkedList<NameValuePair> postParams = new LinkedList<NameValuePair>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url + ClientUtils.toQueryString( queryParams, false ));\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<FormBodyPart>();\n              Iterator<String> iter = wparams.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = wparams.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart && streams != null) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = BinaryResponseParser.BINARY_CONTENT_TYPE; // default\n                  }\n                  String name = content.getName();\n                  if(name==null) {\n                    name = \"\";\n                  }\n                  parts.add(new FormBodyPart(name, \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(wparams, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    // XXX client already has this set, is this needed?\n    method.getParams().setParameter(ClientPNames.HANDLE_REDIRECTS,\n        followRedirects);\n    method.addHeader(\"User-Agent\", AGENT);\n    \n    InputStream respBody = null;\n    boolean shouldClose = true;\n    boolean success = false;\n    try {\n      // Execute the method.\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      // Read the contents\n      respBody = response.getEntity().getContent();\n      Header ctHeader = response.getLastHeader(\"content-type\");\n      String contentType;\n      if (ctHeader != null) {\n        contentType = ctHeader.getValue();\n      } else {\n        contentType = \"\";\n      }\n      \n      // handle some http level checks before trying to parse the response\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n        case HttpStatus.SC_CONFLICT:  // 409\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        default:\n          if (processor == null) {\n            throw new RemoteSolrException(httpStatus, \"Server at \"\n                + getBaseURL() + \" returned non ok status:\" + httpStatus\n                + \", message:\" + response.getStatusLine().getReasonPhrase(),\n                null);\n          }\n      }\n      if (processor == null) {\n        \n        // no processor specified, return raw stream\n        NamedList<Object> rsp = new NamedList<Object>();\n        rsp.add(\"stream\", respBody);\n        // Only case where stream should not be closed\n        shouldClose = false;\n        success = true;\n        return rsp;\n      }\n      \n      String procCt = processor.getContentType();\n      if (procCt != null) {\n        String procMimeType = ContentType.parse(procCt).getMimeType().trim().toLowerCase(Locale.ROOT);\n        String mimeType = ContentType.parse(contentType).getMimeType().trim().toLowerCase(Locale.ROOT);\n        if (!procMimeType.equals(mimeType)) {\n          // unexpected mime type\n          String msg = \"Expected mime type \" + procMimeType + \" but got \" + mimeType + \".\";\n          Header encodingHeader = response.getEntity().getContentEncoding();\n          String encoding;\n          if (encodingHeader != null) {\n            encoding = encodingHeader.getValue();\n          } else {\n            encoding = \"UTF-8\"; // try UTF-8\n          }\n          try {\n            msg = msg + \" \" + IOUtils.toString(respBody, encoding);\n          } catch (IOException e) {\n            throw new RemoteSolrException(httpStatus, \"Could not parse response with encoding \" + encoding, e);\n          }\n          RemoteSolrException e = new RemoteSolrException(httpStatus, msg, null);\n          throw e;\n        }\n      }\n      \n//      if(true) {\n//        ByteArrayOutputStream copy = new ByteArrayOutputStream();\n//        IOUtils.copy(respBody, copy);\n//        String val = new String(copy.toByteArray());\n//        System.out.println(\">RESPONSE>\"+val+\"<\"+val.length());\n//        respBody = new ByteArrayInputStream(copy.toByteArray());\n//      }\n      \n      NamedList<Object> rsp = null;\n      String charset = EntityUtils.getContentCharSet(response.getEntity());\n      try {\n        rsp = processor.processResponse(respBody, charset);\n      } catch (Exception e) {\n        throw new RemoteSolrException(httpStatus, e.getMessage(), e);\n      }\n      if (httpStatus != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            if(reason == null) {\n              reason = (String) err.get(\"trace\");\n            }\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase());\n          msg.append(\"\\n\\n\");\n          msg.append(\"request: \" + method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n        }\n        throw new RemoteSolrException(httpStatus, reason, null);\n      }\n      success = true;\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occured while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occured when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (respBody != null && shouldClose) {\n        try {\n          respBody.close();\n        } catch (IOException e) {\n          log.error(\"\", e);\n        } finally {\n          if (!success) {\n            method.abort();\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a58bbbe1c866963764d3f15d3a26a6a85f6c6af4","date":1394564625,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","sourceNew":"  public NamedList<Object> request(final SolrRequest request, final ResponseParser processor) throws SolrServerException, IOException {\n    return executeMethod(createMethod(request),processor);\n  }\n\n","sourceOld":"  public NamedList<Object> request(final SolrRequest request,\n      final ResponseParser processor) throws SolrServerException, IOException {\n    HttpRequestBase method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if (path == null || !path.startsWith(\"/\")) {\n      path = DEFAULT_PATH;\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if (parser == null) {\n      parser = this.parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original\n    // params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    if (parser != null) {\n      wparams.set(CommonParams.WT, parser.getWriterType());\n      wparams.set(CommonParams.VERSION, parser.getVersion());\n    }\n    if (invariantParams != null) {\n      wparams.add(invariantParams);\n    }\n    \n    int tries = maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new HttpGet( baseUrl + path + ClientUtils.toQueryString( wparams, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = baseUrl + path;\n            boolean hasNullStreamName = false;\n            if (streams != null) {\n              for (ContentStream cs : streams) {\n                if (cs.getName() == null) {\n                  hasNullStreamName = true;\n                  break;\n                }\n              }\n            }\n            boolean isMultipart = (this.useMultiPartPost || ( streams != null && streams.size() > 1 )) && !hasNullStreamName;\n            \n            // only send this list of params as query string params\n            ModifiableSolrParams queryParams = new ModifiableSolrParams();\n            for (String param : this.queryParams) {\n              String[] value = wparams.getParams(param) ;\n              if (value != null) {\n                for (String v : value) {\n                  queryParams.add(param, v);\n                }\n                wparams.remove(param);\n              }\n            }\n            \n            LinkedList<NameValuePair> postParams = new LinkedList<NameValuePair>();\n            if (streams == null || isMultipart) {\n              HttpPost post = new HttpPost(url + ClientUtils.toQueryString( queryParams, false ));\n              post.setHeader(\"Content-Charset\", \"UTF-8\");\n              if (!isMultipart) {\n                post.addHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<FormBodyPart> parts = new LinkedList<FormBodyPart>();\n              Iterator<String> iter = wparams.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = wparams.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (isMultipart) {\n                      parts.add(new FormBodyPart(p, new StringBody(v, Charset.forName(\"UTF-8\"))));\n                    } else {\n                      postParams.add(new BasicNameValuePair(p, v));\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart && streams != null) {\n                for (ContentStream content : streams) {\n                  String contentType = content.getContentType();\n                  if(contentType==null) {\n                    contentType = BinaryResponseParser.BINARY_CONTENT_TYPE; // default\n                  }\n                  String name = content.getName();\n                  if(name==null) {\n                    name = \"\";\n                  }\n                  parts.add(new FormBodyPart(name, \n                       new InputStreamBody(\n                           content.getStream(), \n                           contentType, \n                           content.getName())));\n                }\n              }\n              \n              if (parts.size() > 0) {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.STRICT);\n                for(FormBodyPart p: parts) {\n                  entity.addPart(p);\n                }\n                post.setEntity(entity);\n              } else {\n                //not using multipart\n                post.setEntity(new UrlEncodedFormEntity(postParams, \"UTF-8\"));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(wparams, false);\n              HttpPost post = new HttpPost(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                  \n                });\n              } else {\n                post.setEntity(new InputStreamEntity(contentStream[0].getStream(), -1) {\n                  @Override\n                  public Header getContentType() {\n                    return new BasicHeader(\"Content-Type\", contentStream[0].getContentType());\n                  }\n                  \n                  @Override\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n                });\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if (tries < 1) {\n            throw r;\n          }\n        }\n      }\n    } catch (IOException ex) {\n      throw new SolrServerException(\"error reading streams\", ex);\n    }\n    \n    // XXX client already has this set, is this needed?\n    method.getParams().setParameter(ClientPNames.HANDLE_REDIRECTS,\n        followRedirects);\n    method.addHeader(\"User-Agent\", AGENT);\n    \n    InputStream respBody = null;\n    boolean shouldClose = true;\n    boolean success = false;\n    try {\n      // Execute the method.\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      \n      // Read the contents\n      respBody = response.getEntity().getContent();\n      Header ctHeader = response.getLastHeader(\"content-type\");\n      String contentType;\n      if (ctHeader != null) {\n        contentType = ctHeader.getValue();\n      } else {\n        contentType = \"\";\n      }\n      \n      // handle some http level checks before trying to parse the response\n      switch (httpStatus) {\n        case HttpStatus.SC_OK:\n        case HttpStatus.SC_BAD_REQUEST:\n        case HttpStatus.SC_CONFLICT:  // 409\n          break;\n        case HttpStatus.SC_MOVED_PERMANENTLY:\n        case HttpStatus.SC_MOVED_TEMPORARILY:\n          if (!followRedirects) {\n            throw new SolrServerException(\"Server at \" + getBaseURL()\n                + \" sent back a redirect (\" + httpStatus + \").\");\n          }\n          break;\n        default:\n          if (processor == null) {\n            throw new RemoteSolrException(httpStatus, \"Server at \"\n                + getBaseURL() + \" returned non ok status:\" + httpStatus\n                + \", message:\" + response.getStatusLine().getReasonPhrase(),\n                null);\n          }\n      }\n      if (processor == null) {\n        \n        // no processor specified, return raw stream\n        NamedList<Object> rsp = new NamedList<Object>();\n        rsp.add(\"stream\", respBody);\n        // Only case where stream should not be closed\n        shouldClose = false;\n        success = true;\n        return rsp;\n      }\n      \n      String procCt = processor.getContentType();\n      if (procCt != null) {\n        String procMimeType = ContentType.parse(procCt).getMimeType().trim().toLowerCase(Locale.ROOT);\n        String mimeType = ContentType.parse(contentType).getMimeType().trim().toLowerCase(Locale.ROOT);\n        if (!procMimeType.equals(mimeType)) {\n          // unexpected mime type\n          String msg = \"Expected mime type \" + procMimeType + \" but got \" + mimeType + \".\";\n          Header encodingHeader = response.getEntity().getContentEncoding();\n          String encoding;\n          if (encodingHeader != null) {\n            encoding = encodingHeader.getValue();\n          } else {\n            encoding = \"UTF-8\"; // try UTF-8\n          }\n          try {\n            msg = msg + \" \" + IOUtils.toString(respBody, encoding);\n          } catch (IOException e) {\n            throw new RemoteSolrException(httpStatus, \"Could not parse response with encoding \" + encoding, e);\n          }\n          RemoteSolrException e = new RemoteSolrException(httpStatus, msg, null);\n          throw e;\n        }\n      }\n      \n//      if(true) {\n//        ByteArrayOutputStream copy = new ByteArrayOutputStream();\n//        IOUtils.copy(respBody, copy);\n//        String val = new String(copy.toByteArray());\n//        System.out.println(\">RESPONSE>\"+val+\"<\"+val.length());\n//        respBody = new ByteArrayInputStream(copy.toByteArray());\n//      }\n      \n      NamedList<Object> rsp = null;\n      String charset = EntityUtils.getContentCharSet(response.getEntity());\n      try {\n        rsp = processor.processResponse(respBody, charset);\n      } catch (Exception e) {\n        throw new RemoteSolrException(httpStatus, e.getMessage(), e);\n      }\n      if (httpStatus != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList) rsp.get(\"error\");\n          if (err != null) {\n            reason = (String) err.get(\"msg\");\n            if(reason == null) {\n              reason = (String) err.get(\"trace\");\n            }\n          }\n        } catch (Exception ex) {}\n        if (reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(response.getStatusLine().getReasonPhrase());\n          msg.append(\"\\n\\n\");\n          msg.append(\"request: \" + method.getURI());\n          reason = java.net.URLDecoder.decode(msg.toString(), UTF_8);\n        }\n        throw new RemoteSolrException(httpStatus, reason, null);\n      }\n      success = true;\n      return rsp;\n    } catch (ConnectException e) {\n      throw new SolrServerException(\"Server refused connection at: \"\n          + getBaseURL(), e);\n    } catch (SocketTimeoutException e) {\n      throw new SolrServerException(\n          \"Timeout occured while waiting response from server at: \"\n              + getBaseURL(), e);\n    } catch (IOException e) {\n      throw new SolrServerException(\n          \"IOException occured when talking to server at: \" + getBaseURL(), e);\n    } finally {\n      if (respBody != null && shouldClose) {\n        try {\n          respBody.close();\n        } catch (IOException e) {\n          log.error(\"\", e);\n        } finally {\n          if (!success) {\n            method.abort();\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bafca15d8e408346a67f4282ad1143b88023893b","date":1420034748,"type":5,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrClient#request(SolrRequest,ResponseParser).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrServer#request(SolrRequest,ResponseParser).mjava","sourceNew":"  public NamedList<Object> request(final SolrRequest request, final ResponseParser processor) throws SolrServerException, IOException {\n    return executeMethod(createMethod(request),processor);\n  }\n\n","sourceOld":"  public NamedList<Object> request(final SolrRequest request, final ResponseParser processor) throws SolrServerException, IOException {\n    return executeMethod(createMethod(request),processor);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c4015cd39dff8d4dec562d909f9766debac53aa6":["f95bfa4089ad59d67823e4a5939995f8eec11b7e","f7eb24c6d5e358d7d23adf107b71f769ffba6162"],"a58bbbe1c866963764d3f15d3a26a6a85f6c6af4":["a6446ce810056afd1a06b7a7239ec3cb3b65e31e","4be6b65a4bd628f9b1c1a8832622df34d6eba980"],"bafca15d8e408346a67f4282ad1143b88023893b":["4be6b65a4bd628f9b1c1a8832622df34d6eba980"],"1bea3922196318026c4274f2013416acb60c691e":["054986425ac6be57638da07535df74c6b9dbcb99"],"f2425308ebcd91b538a601df94ae1551ccaab2bb":["eb99886ff640d94edb43e0d36112a2b7023379ba"],"13f445c5bd6f19fd57d5a3ca0a35244c96f45aa8":["f56da6f4f15d95f318d2d6ac2a39a9183dfecff2","a6446ce810056afd1a06b7a7239ec3cb3b65e31e"],"3e5ef402099a6d54398ce3ac65c0b7506bbfece5":["f1b4258e8d84ded627a66ea993d8c7acdc6ae7ad"],"f95bfa4089ad59d67823e4a5939995f8eec11b7e":["f2425308ebcd91b538a601df94ae1551ccaab2bb"],"aba371508186796cc6151d8223a5b4e16d02e26e":["f2425308ebcd91b538a601df94ae1551ccaab2bb","f95bfa4089ad59d67823e4a5939995f8eec11b7e"],"054986425ac6be57638da07535df74c6b9dbcb99":["52fffe2fb680c61aa1d03f7a774e3def8126203a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e6265065eff8fca7d05265677a74384fd538cec3":["7321b77a7bc3edfebd637ef273e9dfaa9969eba6"],"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2":["0d7e876b400387e12251ef67c5c17971bf36cf9b"],"f1b4258e8d84ded627a66ea993d8c7acdc6ae7ad":["becffa5e015a681af7926933a40ced882581d344"],"f7eb24c6d5e358d7d23adf107b71f769ffba6162":["f95bfa4089ad59d67823e4a5939995f8eec11b7e"],"7d65e2bb40ac4c612ba4b101b445fbe172545043":["936c22f779fb06bef139a9163a9b21efd18bb8dd"],"becffa5e015a681af7926933a40ced882581d344":["aba545e9109e49fd275ffc3160444096a9ef0f75"],"7a899ae08a2414e44e9aec7db9783e3da08996d9":["db38df1327eb9a91d4f733219b3865b3af2650fa"],"7321b77a7bc3edfebd637ef273e9dfaa9969eba6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"52fffe2fb680c61aa1d03f7a774e3def8126203a":["70b0517a5cc408febadb78196f1d6938f7fbff13"],"4be6b65a4bd628f9b1c1a8832622df34d6eba980":["a6446ce810056afd1a06b7a7239ec3cb3b65e31e"],"196ccd109e6a8e7cc1fddcc105ae99e8894b98d1":["7d65e2bb40ac4c612ba4b101b445fbe172545043"],"eb99886ff640d94edb43e0d36112a2b7023379ba":["1bea3922196318026c4274f2013416acb60c691e"],"a6446ce810056afd1a06b7a7239ec3cb3b65e31e":["f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"aba545e9109e49fd275ffc3160444096a9ef0f75":["7a899ae08a2414e44e9aec7db9783e3da08996d9"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["eb99886ff640d94edb43e0d36112a2b7023379ba","f95bfa4089ad59d67823e4a5939995f8eec11b7e"],"70b0517a5cc408febadb78196f1d6938f7fbff13":["e6265065eff8fca7d05265677a74384fd538cec3"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["f1b4258e8d84ded627a66ea993d8c7acdc6ae7ad","0d7e876b400387e12251ef67c5c17971bf36cf9b"],"db38df1327eb9a91d4f733219b3865b3af2650fa":["196ccd109e6a8e7cc1fddcc105ae99e8894b98d1"],"0d7e876b400387e12251ef67c5c17971bf36cf9b":["3e5ef402099a6d54398ce3ac65c0b7506bbfece5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bafca15d8e408346a67f4282ad1143b88023893b"],"936c22f779fb06bef139a9163a9b21efd18bb8dd":["f7eb24c6d5e358d7d23adf107b71f769ffba6162"]},"commit2Childs":{"c4015cd39dff8d4dec562d909f9766debac53aa6":[],"a58bbbe1c866963764d3f15d3a26a6a85f6c6af4":[],"bafca15d8e408346a67f4282ad1143b88023893b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"1bea3922196318026c4274f2013416acb60c691e":["eb99886ff640d94edb43e0d36112a2b7023379ba"],"f2425308ebcd91b538a601df94ae1551ccaab2bb":["f95bfa4089ad59d67823e4a5939995f8eec11b7e","aba371508186796cc6151d8223a5b4e16d02e26e"],"13f445c5bd6f19fd57d5a3ca0a35244c96f45aa8":[],"3e5ef402099a6d54398ce3ac65c0b7506bbfece5":["0d7e876b400387e12251ef67c5c17971bf36cf9b"],"f95bfa4089ad59d67823e4a5939995f8eec11b7e":["c4015cd39dff8d4dec562d909f9766debac53aa6","aba371508186796cc6151d8223a5b4e16d02e26e","f7eb24c6d5e358d7d23adf107b71f769ffba6162","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"aba371508186796cc6151d8223a5b4e16d02e26e":[],"054986425ac6be57638da07535df74c6b9dbcb99":["1bea3922196318026c4274f2013416acb60c691e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7321b77a7bc3edfebd637ef273e9dfaa9969eba6"],"e6265065eff8fca7d05265677a74384fd538cec3":["70b0517a5cc408febadb78196f1d6938f7fbff13"],"f7eb24c6d5e358d7d23adf107b71f769ffba6162":["c4015cd39dff8d4dec562d909f9766debac53aa6","936c22f779fb06bef139a9163a9b21efd18bb8dd"],"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2":["13f445c5bd6f19fd57d5a3ca0a35244c96f45aa8","a6446ce810056afd1a06b7a7239ec3cb3b65e31e"],"f1b4258e8d84ded627a66ea993d8c7acdc6ae7ad":["3e5ef402099a6d54398ce3ac65c0b7506bbfece5","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"7d65e2bb40ac4c612ba4b101b445fbe172545043":["196ccd109e6a8e7cc1fddcc105ae99e8894b98d1"],"becffa5e015a681af7926933a40ced882581d344":["f1b4258e8d84ded627a66ea993d8c7acdc6ae7ad"],"7a899ae08a2414e44e9aec7db9783e3da08996d9":["aba545e9109e49fd275ffc3160444096a9ef0f75"],"7321b77a7bc3edfebd637ef273e9dfaa9969eba6":["e6265065eff8fca7d05265677a74384fd538cec3"],"52fffe2fb680c61aa1d03f7a774e3def8126203a":["054986425ac6be57638da07535df74c6b9dbcb99"],"4be6b65a4bd628f9b1c1a8832622df34d6eba980":["a58bbbe1c866963764d3f15d3a26a6a85f6c6af4","bafca15d8e408346a67f4282ad1143b88023893b"],"196ccd109e6a8e7cc1fddcc105ae99e8894b98d1":["db38df1327eb9a91d4f733219b3865b3af2650fa"],"eb99886ff640d94edb43e0d36112a2b7023379ba":["f2425308ebcd91b538a601df94ae1551ccaab2bb","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"a6446ce810056afd1a06b7a7239ec3cb3b65e31e":["a58bbbe1c866963764d3f15d3a26a6a85f6c6af4","13f445c5bd6f19fd57d5a3ca0a35244c96f45aa8","4be6b65a4bd628f9b1c1a8832622df34d6eba980"],"aba545e9109e49fd275ffc3160444096a9ef0f75":["becffa5e015a681af7926933a40ced882581d344"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"70b0517a5cc408febadb78196f1d6938f7fbff13":["52fffe2fb680c61aa1d03f7a774e3def8126203a"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"db38df1327eb9a91d4f733219b3865b3af2650fa":["7a899ae08a2414e44e9aec7db9783e3da08996d9"],"0d7e876b400387e12251ef67c5c17971bf36cf9b":["f56da6f4f15d95f318d2d6ac2a39a9183dfecff2","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"936c22f779fb06bef139a9163a9b21efd18bb8dd":["7d65e2bb40ac4c612ba4b101b445fbe172545043"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c4015cd39dff8d4dec562d909f9766debac53aa6","a58bbbe1c866963764d3f15d3a26a6a85f6c6af4","13f445c5bd6f19fd57d5a3ca0a35244c96f45aa8","aba371508186796cc6151d8223a5b4e16d02e26e","fe33227f6805edab2036cbb80645cc4e2d1fa424","74f45af4339b0daf7a95c820ab88c1aea74fbce0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}