{"path":"lucene/src/test/org/apache/lucene/search/TestNRTManager#testThreadStarvationNoDeleteNRTReader().mjava","commits":[{"id":"df16fc2e9b615e0138edac46655ae628f5d098ad","date":1320876869,"type":1,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestNRTManager#testThreadStarvationNoDeleteNRTReader().mjava","pathOld":"lucene/contrib/misc/src/test/org/apache/lucene/index/TestNRTManager#testThreadStarvationNoDeleteNRTReader().mjava","sourceNew":"  /*\n   * LUCENE-3528 - NRTManager hangs in certain situations \n   */\n  public void testThreadStarvationNoDeleteNRTReader() throws IOException, InterruptedException {\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random));\n    Directory d = newDirectory();\n    final CountDownLatch latch = new CountDownLatch(1);\n    final CountDownLatch signal = new CountDownLatch(1);\n\n    LatchedIndexWriter writer = new LatchedIndexWriter(d, conf, latch, signal);\n    final NRTManager manager = new NRTManager(writer, null, null, false);\n    Document doc = new Document();\n    doc.add(newField(\"test\",\"test\", TextField.TYPE_STORED));\n    long gen = manager.addDocument(doc);\n    assertTrue(manager.maybeReopen(false));\n    assertFalse(gen < manager.getCurrentSearchingGen(false));\n    Thread t = new Thread() {\n      public void run() {\n        try {\n          signal.await();\n          assertTrue(manager.maybeReopen(false));\n          manager.deleteDocuments(new TermQuery(new Term(\"foo\", \"barista\")));\n          manager.maybeReopen(false); // kick off another reopen so we inc. the internal gen\n        } catch (Exception e) {\n          e.printStackTrace();\n        } finally {\n          latch.countDown(); // let the add below finish\n        }\n      }\n    };\n    t.start();\n    writer.waitAfterUpdate = true; // wait in addDocument to let some reopens go through\n    final long lastGen = manager.updateDocument(new Term(\"foo\", \"bar\"), doc); // once this returns the doc is already reflected in the last reopen\n    assertFalse(manager.getSearcherManager(false).isSearcherCurrent()); // false since there is a delete in the queue\n    \n    IndexSearcher acquire = manager.getSearcherManager(false).acquire();\n    try {\n      assertEquals(2, acquire.getIndexReader().numDocs());\n    } finally {\n      acquire.getIndexReader().decRef();\n    }\n    NRTManagerReopenThread thread = new NRTManagerReopenThread(manager, 0.01, 0.01);\n    thread.start(); // start reopening\n    if (VERBOSE) {\n      System.out.println(\"waiting now for generation \" + lastGen);\n    }\n    \n    final AtomicBoolean finished = new AtomicBoolean(false);\n    Thread waiter = new Thread() {\n      public void run() {\n        manager.waitForGeneration(lastGen, false);\n        finished.set(true);\n      }\n    };\n    waiter.start();\n    manager.maybeReopen(false);\n    waiter.join(1000);\n    if (!finished.get()) {\n      waiter.interrupt();\n      fail(\"thread deadlocked on waitForGeneration\");\n    }\n    thread.close();\n    thread.join();\n    IOUtils.close(manager, writer, d);\n  }\n\n","sourceOld":"  /*\n   * LUCENE-3528 - NRTManager hangs in certain situations \n   */\n  public void testThreadStarvationNoDeleteNRTReader() throws IOException, InterruptedException {\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random));\n    Directory d = newDirectory();\n    final CountDownLatch latch = new CountDownLatch(1);\n    final CountDownLatch signal = new CountDownLatch(1);\n\n    LatchedIndexWriter writer = new LatchedIndexWriter(d, conf, latch, signal);\n    final NRTManager manager = new NRTManager(writer, null, null, false);\n    Document doc = new Document();\n    doc.add(newField(\"test\",\"test\", TextField.TYPE_STORED));\n    long gen = manager.addDocument(doc);\n    assertTrue(manager.maybeReopen(false));\n    assertFalse(gen < manager.getCurrentSearchingGen(false));\n    Thread t = new Thread() {\n      public void run() {\n        try {\n          signal.await();\n          assertTrue(manager.maybeReopen(false));\n          manager.deleteDocuments(new TermQuery(new Term(\"foo\", \"barista\")));\n          manager.maybeReopen(false); // kick off another reopen so we inc. the internal gen\n        } catch (Exception e) {\n          e.printStackTrace();\n        } finally {\n          latch.countDown(); // let the add below finish\n        }\n      }\n    };\n    t.start();\n    writer.waitAfterUpdate = true; // wait in addDocument to let some reopens go through\n    final long lastGen = manager.updateDocument(new Term(\"foo\", \"bar\"), doc); // once this returns the doc is already reflected in the last reopen\n    assertFalse(manager.getSearcherManager(false).isSearcherCurrent()); // false since there is a delete in the queue\n    \n    IndexSearcher acquire = manager.getSearcherManager(false).acquire();\n    try {\n      assertEquals(2, acquire.getIndexReader().numDocs());\n    } finally {\n      acquire.getIndexReader().decRef();\n    }\n    NRTManagerReopenThread thread = new NRTManagerReopenThread(manager, 0.01, 0.01);\n    thread.start(); // start reopening\n    if (VERBOSE) {\n      System.out.println(\"waiting now for generation \" + lastGen);\n    }\n    \n    final AtomicBoolean finished = new AtomicBoolean(false);\n    Thread waiter = new Thread() {\n      public void run() {\n        manager.waitForGeneration(lastGen, false);\n        finished.set(true);\n      }\n    };\n    waiter.start();\n    manager.maybeReopen(false);\n    waiter.join(1000);\n    if (!finished.get()) {\n      waiter.interrupt();\n      fail(\"thread deadlocked on waitForGeneration\");\n    }\n    thread.close();\n    thread.join();\n    IOUtils.close(manager, writer, d);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"568cba246a11f491637ba492f881589c2142667c","date":1323623267,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestNRTManager#testThreadStarvationNoDeleteNRTReader().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestNRTManager#testThreadStarvationNoDeleteNRTReader().mjava","sourceNew":"  /*\n   * LUCENE-3528 - NRTManager hangs in certain situations \n   */\n  public void testThreadStarvationNoDeleteNRTReader() throws IOException, InterruptedException {\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random));\n    Directory d = newDirectory();\n    final CountDownLatch latch = new CountDownLatch(1);\n    final CountDownLatch signal = new CountDownLatch(1);\n\n    LatchedIndexWriter writer = new LatchedIndexWriter(d, conf, latch, signal);\n    final NRTManager manager = new NRTManager(writer, null, false);\n    Document doc = new Document();\n    doc.add(newField(\"test\",\"test\", TextField.TYPE_STORED));\n    long gen = manager.addDocument(doc);\n    assertTrue(manager.maybeReopen(false));\n    assertFalse(gen < manager.getCurrentSearchingGen(false));\n    Thread t = new Thread() {\n      public void run() {\n        try {\n          signal.await();\n          assertTrue(manager.maybeReopen(false));\n          manager.deleteDocuments(new TermQuery(new Term(\"foo\", \"barista\")));\n          manager.maybeReopen(false); // kick off another reopen so we inc. the internal gen\n        } catch (Exception e) {\n          e.printStackTrace();\n        } finally {\n          latch.countDown(); // let the add below finish\n        }\n      }\n    };\n    t.start();\n    writer.waitAfterUpdate = true; // wait in addDocument to let some reopens go through\n    final long lastGen = manager.updateDocument(new Term(\"foo\", \"bar\"), doc); // once this returns the doc is already reflected in the last reopen\n    assertFalse(manager.getSearcherManager(false).isSearcherCurrent()); // false since there is a delete in the queue\n    \n    IndexSearcher acquire = manager.getSearcherManager(false).acquire();\n    try {\n      assertEquals(2, acquire.getIndexReader().numDocs());\n    } finally {\n      acquire.getIndexReader().decRef();\n    }\n    NRTManagerReopenThread thread = new NRTManagerReopenThread(manager, 0.01, 0.01);\n    thread.start(); // start reopening\n    if (VERBOSE) {\n      System.out.println(\"waiting now for generation \" + lastGen);\n    }\n    \n    final AtomicBoolean finished = new AtomicBoolean(false);\n    Thread waiter = new Thread() {\n      public void run() {\n        manager.waitForGeneration(lastGen, false);\n        finished.set(true);\n      }\n    };\n    waiter.start();\n    manager.maybeReopen(false);\n    waiter.join(1000);\n    if (!finished.get()) {\n      waiter.interrupt();\n      fail(\"thread deadlocked on waitForGeneration\");\n    }\n    thread.close();\n    thread.join();\n    IOUtils.close(manager, writer, d);\n  }\n\n","sourceOld":"  /*\n   * LUCENE-3528 - NRTManager hangs in certain situations \n   */\n  public void testThreadStarvationNoDeleteNRTReader() throws IOException, InterruptedException {\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random));\n    Directory d = newDirectory();\n    final CountDownLatch latch = new CountDownLatch(1);\n    final CountDownLatch signal = new CountDownLatch(1);\n\n    LatchedIndexWriter writer = new LatchedIndexWriter(d, conf, latch, signal);\n    final NRTManager manager = new NRTManager(writer, null, null, false);\n    Document doc = new Document();\n    doc.add(newField(\"test\",\"test\", TextField.TYPE_STORED));\n    long gen = manager.addDocument(doc);\n    assertTrue(manager.maybeReopen(false));\n    assertFalse(gen < manager.getCurrentSearchingGen(false));\n    Thread t = new Thread() {\n      public void run() {\n        try {\n          signal.await();\n          assertTrue(manager.maybeReopen(false));\n          manager.deleteDocuments(new TermQuery(new Term(\"foo\", \"barista\")));\n          manager.maybeReopen(false); // kick off another reopen so we inc. the internal gen\n        } catch (Exception e) {\n          e.printStackTrace();\n        } finally {\n          latch.countDown(); // let the add below finish\n        }\n      }\n    };\n    t.start();\n    writer.waitAfterUpdate = true; // wait in addDocument to let some reopens go through\n    final long lastGen = manager.updateDocument(new Term(\"foo\", \"bar\"), doc); // once this returns the doc is already reflected in the last reopen\n    assertFalse(manager.getSearcherManager(false).isSearcherCurrent()); // false since there is a delete in the queue\n    \n    IndexSearcher acquire = manager.getSearcherManager(false).acquire();\n    try {\n      assertEquals(2, acquire.getIndexReader().numDocs());\n    } finally {\n      acquire.getIndexReader().decRef();\n    }\n    NRTManagerReopenThread thread = new NRTManagerReopenThread(manager, 0.01, 0.01);\n    thread.start(); // start reopening\n    if (VERBOSE) {\n      System.out.println(\"waiting now for generation \" + lastGen);\n    }\n    \n    final AtomicBoolean finished = new AtomicBoolean(false);\n    Thread waiter = new Thread() {\n      public void run() {\n        manager.waitForGeneration(lastGen, false);\n        finished.set(true);\n      }\n    };\n    waiter.start();\n    manager.maybeReopen(false);\n    waiter.join(1000);\n    if (!finished.get()) {\n      waiter.interrupt();\n      fail(\"thread deadlocked on waitForGeneration\");\n    }\n    thread.close();\n    thread.join();\n    IOUtils.close(manager, writer, d);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","date":1323720782,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/search/TestNRTManager#testThreadStarvationNoDeleteNRTReader().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestNRTManager#testThreadStarvationNoDeleteNRTReader().mjava","sourceNew":"  /*\n   * LUCENE-3528 - NRTManager hangs in certain situations \n   */\n  public void testThreadStarvationNoDeleteNRTReader() throws IOException, InterruptedException {\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random));\n    Directory d = newDirectory();\n    final CountDownLatch latch = new CountDownLatch(1);\n    final CountDownLatch signal = new CountDownLatch(1);\n\n    LatchedIndexWriter writer = new LatchedIndexWriter(d, conf, latch, signal);\n    final NRTManager manager = new NRTManager(writer, null, false);\n    Document doc = new Document();\n    doc.add(newField(\"test\",\"test\", TextField.TYPE_STORED));\n    long gen = manager.addDocument(doc);\n    assertTrue(manager.maybeReopen(false));\n    assertFalse(gen < manager.getCurrentSearchingGen(false));\n    Thread t = new Thread() {\n      public void run() {\n        try {\n          signal.await();\n          assertTrue(manager.maybeReopen(false));\n          manager.deleteDocuments(new TermQuery(new Term(\"foo\", \"barista\")));\n          manager.maybeReopen(false); // kick off another reopen so we inc. the internal gen\n        } catch (Exception e) {\n          e.printStackTrace();\n        } finally {\n          latch.countDown(); // let the add below finish\n        }\n      }\n    };\n    t.start();\n    writer.waitAfterUpdate = true; // wait in addDocument to let some reopens go through\n    final long lastGen = manager.updateDocument(new Term(\"foo\", \"bar\"), doc); // once this returns the doc is already reflected in the last reopen\n    assertFalse(manager.getSearcherManager(false).isSearcherCurrent()); // false since there is a delete in the queue\n    \n    IndexSearcher acquire = manager.getSearcherManager(false).acquire();\n    try {\n      assertEquals(2, acquire.getIndexReader().numDocs());\n    } finally {\n      acquire.getIndexReader().decRef();\n    }\n    NRTManagerReopenThread thread = new NRTManagerReopenThread(manager, 0.01, 0.01);\n    thread.start(); // start reopening\n    if (VERBOSE) {\n      System.out.println(\"waiting now for generation \" + lastGen);\n    }\n    \n    final AtomicBoolean finished = new AtomicBoolean(false);\n    Thread waiter = new Thread() {\n      public void run() {\n        manager.waitForGeneration(lastGen, false);\n        finished.set(true);\n      }\n    };\n    waiter.start();\n    manager.maybeReopen(false);\n    waiter.join(1000);\n    if (!finished.get()) {\n      waiter.interrupt();\n      fail(\"thread deadlocked on waitForGeneration\");\n    }\n    thread.close();\n    thread.join();\n    IOUtils.close(manager, writer, d);\n  }\n\n","sourceOld":"  /*\n   * LUCENE-3528 - NRTManager hangs in certain situations \n   */\n  public void testThreadStarvationNoDeleteNRTReader() throws IOException, InterruptedException {\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random));\n    Directory d = newDirectory();\n    final CountDownLatch latch = new CountDownLatch(1);\n    final CountDownLatch signal = new CountDownLatch(1);\n\n    LatchedIndexWriter writer = new LatchedIndexWriter(d, conf, latch, signal);\n    final NRTManager manager = new NRTManager(writer, null, null, false);\n    Document doc = new Document();\n    doc.add(newField(\"test\",\"test\", TextField.TYPE_STORED));\n    long gen = manager.addDocument(doc);\n    assertTrue(manager.maybeReopen(false));\n    assertFalse(gen < manager.getCurrentSearchingGen(false));\n    Thread t = new Thread() {\n      public void run() {\n        try {\n          signal.await();\n          assertTrue(manager.maybeReopen(false));\n          manager.deleteDocuments(new TermQuery(new Term(\"foo\", \"barista\")));\n          manager.maybeReopen(false); // kick off another reopen so we inc. the internal gen\n        } catch (Exception e) {\n          e.printStackTrace();\n        } finally {\n          latch.countDown(); // let the add below finish\n        }\n      }\n    };\n    t.start();\n    writer.waitAfterUpdate = true; // wait in addDocument to let some reopens go through\n    final long lastGen = manager.updateDocument(new Term(\"foo\", \"bar\"), doc); // once this returns the doc is already reflected in the last reopen\n    assertFalse(manager.getSearcherManager(false).isSearcherCurrent()); // false since there is a delete in the queue\n    \n    IndexSearcher acquire = manager.getSearcherManager(false).acquire();\n    try {\n      assertEquals(2, acquire.getIndexReader().numDocs());\n    } finally {\n      acquire.getIndexReader().decRef();\n    }\n    NRTManagerReopenThread thread = new NRTManagerReopenThread(manager, 0.01, 0.01);\n    thread.start(); // start reopening\n    if (VERBOSE) {\n      System.out.println(\"waiting now for generation \" + lastGen);\n    }\n    \n    final AtomicBoolean finished = new AtomicBoolean(false);\n    Thread waiter = new Thread() {\n      public void run() {\n        manager.waitForGeneration(lastGen, false);\n        finished.set(true);\n      }\n    };\n    waiter.start();\n    manager.maybeReopen(false);\n    waiter.join(1000);\n    if (!finished.get()) {\n      waiter.interrupt();\n      fail(\"thread deadlocked on waitForGeneration\");\n    }\n    thread.close();\n    thread.join();\n    IOUtils.close(manager, writer, d);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestNRTManager#testThreadStarvationNoDeleteNRTReader().mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestNRTManager#testThreadStarvationNoDeleteNRTReader().mjava","sourceNew":"  /*\n   * LUCENE-3528 - NRTManager hangs in certain situations \n   */\n  public void testThreadStarvationNoDeleteNRTReader() throws IOException, InterruptedException {\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random));\n    Directory d = newDirectory();\n    final CountDownLatch latch = new CountDownLatch(1);\n    final CountDownLatch signal = new CountDownLatch(1);\n\n    LatchedIndexWriter writer = new LatchedIndexWriter(d, conf, latch, signal);\n    final NRTManager manager = new NRTManager(writer, null, false);\n    Document doc = new Document();\n    doc.add(newField(\"test\",\"test\", TextField.TYPE_STORED));\n    long gen = manager.addDocument(doc);\n    assertTrue(manager.maybeReopen(false));\n    assertFalse(gen < manager.getCurrentSearchingGen(false));\n    Thread t = new Thread() {\n      public void run() {\n        try {\n          signal.await();\n          assertTrue(manager.maybeReopen(false));\n          manager.deleteDocuments(new TermQuery(new Term(\"foo\", \"barista\")));\n          manager.maybeReopen(false); // kick off another reopen so we inc. the internal gen\n        } catch (Exception e) {\n          e.printStackTrace();\n        } finally {\n          latch.countDown(); // let the add below finish\n        }\n      }\n    };\n    t.start();\n    writer.waitAfterUpdate = true; // wait in addDocument to let some reopens go through\n    final long lastGen = manager.updateDocument(new Term(\"foo\", \"bar\"), doc); // once this returns the doc is already reflected in the last reopen\n    assertFalse(manager.getSearcherManager(false).isSearcherCurrent()); // false since there is a delete in the queue\n    \n    IndexSearcher acquire = manager.getSearcherManager(false).acquire();\n    try {\n      assertEquals(2, acquire.getIndexReader().numDocs());\n    } finally {\n      acquire.getIndexReader().decRef();\n    }\n    NRTManagerReopenThread thread = new NRTManagerReopenThread(manager, 0.01, 0.01);\n    thread.start(); // start reopening\n    if (VERBOSE) {\n      System.out.println(\"waiting now for generation \" + lastGen);\n    }\n    \n    final AtomicBoolean finished = new AtomicBoolean(false);\n    Thread waiter = new Thread() {\n      public void run() {\n        manager.waitForGeneration(lastGen, false);\n        finished.set(true);\n      }\n    };\n    waiter.start();\n    manager.maybeReopen(false);\n    waiter.join(1000);\n    if (!finished.get()) {\n      waiter.interrupt();\n      fail(\"thread deadlocked on waitForGeneration\");\n    }\n    thread.close();\n    thread.join();\n    IOUtils.close(manager, writer, d);\n  }\n\n","sourceOld":"  /*\n   * LUCENE-3528 - NRTManager hangs in certain situations \n   */\n  public void testThreadStarvationNoDeleteNRTReader() throws IOException, InterruptedException {\n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random));\n    Directory d = newDirectory();\n    final CountDownLatch latch = new CountDownLatch(1);\n    final CountDownLatch signal = new CountDownLatch(1);\n\n    LatchedIndexWriter writer = new LatchedIndexWriter(d, conf, latch, signal);\n    final NRTManager manager = new NRTManager(writer, null, false);\n    Document doc = new Document();\n    doc.add(newField(\"test\",\"test\", TextField.TYPE_STORED));\n    long gen = manager.addDocument(doc);\n    assertTrue(manager.maybeReopen(false));\n    assertFalse(gen < manager.getCurrentSearchingGen(false));\n    Thread t = new Thread() {\n      public void run() {\n        try {\n          signal.await();\n          assertTrue(manager.maybeReopen(false));\n          manager.deleteDocuments(new TermQuery(new Term(\"foo\", \"barista\")));\n          manager.maybeReopen(false); // kick off another reopen so we inc. the internal gen\n        } catch (Exception e) {\n          e.printStackTrace();\n        } finally {\n          latch.countDown(); // let the add below finish\n        }\n      }\n    };\n    t.start();\n    writer.waitAfterUpdate = true; // wait in addDocument to let some reopens go through\n    final long lastGen = manager.updateDocument(new Term(\"foo\", \"bar\"), doc); // once this returns the doc is already reflected in the last reopen\n    assertFalse(manager.getSearcherManager(false).isSearcherCurrent()); // false since there is a delete in the queue\n    \n    IndexSearcher acquire = manager.getSearcherManager(false).acquire();\n    try {\n      assertEquals(2, acquire.getIndexReader().numDocs());\n    } finally {\n      acquire.getIndexReader().decRef();\n    }\n    NRTManagerReopenThread thread = new NRTManagerReopenThread(manager, 0.01, 0.01);\n    thread.start(); // start reopening\n    if (VERBOSE) {\n      System.out.println(\"waiting now for generation \" + lastGen);\n    }\n    \n    final AtomicBoolean finished = new AtomicBoolean(false);\n    Thread waiter = new Thread() {\n      public void run() {\n        manager.waitForGeneration(lastGen, false);\n        finished.set(true);\n      }\n    };\n    waiter.start();\n    manager.maybeReopen(false);\n    waiter.join(1000);\n    if (!finished.get()) {\n      waiter.interrupt();\n      fail(\"thread deadlocked on waitForGeneration\");\n    }\n    thread.close();\n    thread.join();\n    IOUtils.close(manager, writer, d);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"568cba246a11f491637ba492f881589c2142667c":["df16fc2e9b615e0138edac46655ae628f5d098ad"],"df16fc2e9b615e0138edac46655ae628f5d098ad":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["568cba246a11f491637ba492f881589c2142667c"],"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c":["df16fc2e9b615e0138edac46655ae628f5d098ad","568cba246a11f491637ba492f881589c2142667c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"568cba246a11f491637ba492f881589c2142667c":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","93ccd971aca7fb61b7f1b946e44714cfc80bfc7c"],"df16fc2e9b615e0138edac46655ae628f5d098ad":["568cba246a11f491637ba492f881589c2142667c","93ccd971aca7fb61b7f1b946e44714cfc80bfc7c"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["df16fc2e9b615e0138edac46655ae628f5d098ad"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}