{"path":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggesterTest#testTieBreakOnSurfaceForm().mjava","commits":[{"id":"de73f9a96d7a4c91d4ec773c03aa188940382805","date":1505662644,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggesterTest#testTieBreakOnSurfaceForm().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Adds 50 random keys, that all analyze to the same thing (dog), with the same cost,\n   * and checks that they come back in surface-form order.\n   */\n  public void testTieBreakOnSurfaceForm() throws Exception {\n    Analyzer a = new Analyzer() {\n      @Override\n      protected TokenStreamComponents createComponents(String fieldName) {\n        Tokenizer tokenizer = new MockTokenizer(MockTokenizer.SIMPLE, true);\n\n        return new TokenStreamComponents(tokenizer) {\n          @Override\n          public TokenStream getTokenStream() {\n            return new CannedTokenStream(new Token[] {\n                token(\"dog\", 1, 1)\n              });\n          }\n          @Override\n          protected void setReader(final Reader reader) {\n          }\n        };\n      }\n    };\n\n    Directory tempDir = getDirectory();\n    AnalyzingSuggester suggester = new AnalyzingSuggester(tempDir, \"suggest\", a, a, 0, 256, -1, true);\n\n    // make 50 inputs all with the same cost of 1, random strings\n    Input[] inputs = new Input[100];\n    for (int i = 0; i < inputs.length; i++) {\n      inputs[i] = new Input(TestUtil.randomSimpleString(random()), 1);\n    }\n\n    suggester.build(new InputArrayIterator(inputs));\n\n    // Try to save/load:\n    Path tmpDir = createTempDir(\"AnalyzingSuggesterTest\");\n    Path path = tmpDir.resolve(\"suggester\");\n\n    OutputStream os = Files.newOutputStream(path);\n    suggester.store(os);\n    os.close();\n\n    InputStream is = Files.newInputStream(path);\n    suggester.load(is);\n    is.close();\n\n    // now suggest everything, and check that stuff comes back in order\n    List<LookupResult> results = suggester.lookup(\"\", false, 50);\n    assertEquals(50, results.size());\n    for (int i = 1; i < 50; i++) {\n      String previous = results.get(i-1).toString();\n      String current = results.get(i).toString();\n      assertTrue(\"surface forms out of order: previous=\" + previous + \",current=\" + current,\n                 current.compareTo(previous) >= 0);\n    }\n\n    IOUtils.close(a, tempDir);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"685bd38810c206c93e9058f3c2cfa9827c086c27","date":1505751821,"type":0,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggesterTest#testTieBreakOnSurfaceForm().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Adds 50 random keys, that all analyze to the same thing (dog), with the same cost,\n   * and checks that they come back in surface-form order.\n   */\n  public void testTieBreakOnSurfaceForm() throws Exception {\n    Analyzer a = new Analyzer() {\n      @Override\n      protected TokenStreamComponents createComponents(String fieldName) {\n        Tokenizer tokenizer = new MockTokenizer(MockTokenizer.SIMPLE, true);\n\n        return new TokenStreamComponents(tokenizer) {\n          @Override\n          public TokenStream getTokenStream() {\n            return new CannedTokenStream(new Token[] {\n                token(\"dog\", 1, 1)\n              });\n          }\n          @Override\n          protected void setReader(final Reader reader) {\n          }\n        };\n      }\n    };\n\n    Directory tempDir = getDirectory();\n    AnalyzingSuggester suggester = new AnalyzingSuggester(tempDir, \"suggest\", a, a, 0, 256, -1, true);\n\n    // make 50 inputs all with the same cost of 1, random strings\n    Input[] inputs = new Input[100];\n    for (int i = 0; i < inputs.length; i++) {\n      inputs[i] = new Input(TestUtil.randomSimpleString(random()), 1);\n    }\n\n    suggester.build(new InputArrayIterator(inputs));\n\n    // Try to save/load:\n    Path tmpDir = createTempDir(\"AnalyzingSuggesterTest\");\n    Path path = tmpDir.resolve(\"suggester\");\n\n    OutputStream os = Files.newOutputStream(path);\n    suggester.store(os);\n    os.close();\n\n    InputStream is = Files.newInputStream(path);\n    suggester.load(is);\n    is.close();\n\n    // now suggest everything, and check that stuff comes back in order\n    List<LookupResult> results = suggester.lookup(\"\", false, 50);\n    assertEquals(50, results.size());\n    for (int i = 1; i < 50; i++) {\n      String previous = results.get(i-1).toString();\n      String current = results.get(i).toString();\n      assertTrue(\"surface forms out of order: previous=\" + previous + \",current=\" + current,\n                 current.compareTo(previous) >= 0);\n    }\n\n    IOUtils.close(a, tempDir);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fac252ef8e3d0bbff9303ffbf675e824a729dfaf","date":1537347776,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggesterTest#testTieBreakOnSurfaceForm().mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggesterTest#testTieBreakOnSurfaceForm().mjava","sourceNew":"  /**\n   * Adds 50 random keys, that all analyze to the same thing (dog), with the same cost,\n   * and checks that they come back in surface-form order.\n   */\n  public void testTieBreakOnSurfaceForm() throws Exception {\n    Analyzer a = new MultiCannedAnalyzer(new CannedTokenStream(token(\"dog\", 1, 1)));\n\n    Directory tempDir = getDirectory();\n    AnalyzingSuggester suggester = new AnalyzingSuggester(tempDir, \"suggest\", a, a, 0, 256, -1, true);\n\n    // make 50 inputs all with the same cost of 1, random strings\n    Input[] inputs = new Input[100];\n    for (int i = 0; i < inputs.length; i++) {\n      inputs[i] = new Input(TestUtil.randomSimpleString(random()), 1);\n    }\n\n    suggester.build(new InputArrayIterator(inputs));\n\n    // Try to save/load:\n    Path tmpDir = createTempDir(\"AnalyzingSuggesterTest\");\n    Path path = tmpDir.resolve(\"suggester\");\n\n    OutputStream os = Files.newOutputStream(path);\n    suggester.store(os);\n    os.close();\n\n    InputStream is = Files.newInputStream(path);\n    suggester.load(is);\n    is.close();\n\n    // now suggest everything, and check that stuff comes back in order\n    List<LookupResult> results = suggester.lookup(\"\", false, 50);\n    assertEquals(50, results.size());\n    for (int i = 1; i < 50; i++) {\n      String previous = results.get(i-1).toString();\n      String current = results.get(i).toString();\n      assertTrue(\"surface forms out of order: previous=\" + previous + \",current=\" + current,\n                 current.compareTo(previous) >= 0);\n    }\n\n    IOUtils.close(a, tempDir);\n  }\n\n","sourceOld":"  /**\n   * Adds 50 random keys, that all analyze to the same thing (dog), with the same cost,\n   * and checks that they come back in surface-form order.\n   */\n  public void testTieBreakOnSurfaceForm() throws Exception {\n    Analyzer a = new Analyzer() {\n      @Override\n      protected TokenStreamComponents createComponents(String fieldName) {\n        Tokenizer tokenizer = new MockTokenizer(MockTokenizer.SIMPLE, true);\n\n        return new TokenStreamComponents(tokenizer) {\n          @Override\n          public TokenStream getTokenStream() {\n            return new CannedTokenStream(new Token[] {\n                token(\"dog\", 1, 1)\n              });\n          }\n          @Override\n          protected void setReader(final Reader reader) {\n          }\n        };\n      }\n    };\n\n    Directory tempDir = getDirectory();\n    AnalyzingSuggester suggester = new AnalyzingSuggester(tempDir, \"suggest\", a, a, 0, 256, -1, true);\n\n    // make 50 inputs all with the same cost of 1, random strings\n    Input[] inputs = new Input[100];\n    for (int i = 0; i < inputs.length; i++) {\n      inputs[i] = new Input(TestUtil.randomSimpleString(random()), 1);\n    }\n\n    suggester.build(new InputArrayIterator(inputs));\n\n    // Try to save/load:\n    Path tmpDir = createTempDir(\"AnalyzingSuggesterTest\");\n    Path path = tmpDir.resolve(\"suggester\");\n\n    OutputStream os = Files.newOutputStream(path);\n    suggester.store(os);\n    os.close();\n\n    InputStream is = Files.newInputStream(path);\n    suggester.load(is);\n    is.close();\n\n    // now suggest everything, and check that stuff comes back in order\n    List<LookupResult> results = suggester.lookup(\"\", false, 50);\n    assertEquals(50, results.size());\n    for (int i = 1; i < 50; i++) {\n      String previous = results.get(i-1).toString();\n      String current = results.get(i).toString();\n      assertTrue(\"surface forms out of order: previous=\" + previous + \",current=\" + current,\n                 current.compareTo(previous) >= 0);\n    }\n\n    IOUtils.close(a, tempDir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"de73f9a96d7a4c91d4ec773c03aa188940382805":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"685bd38810c206c93e9058f3c2cfa9827c086c27":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","de73f9a96d7a4c91d4ec773c03aa188940382805"],"fac252ef8e3d0bbff9303ffbf675e824a729dfaf":["de73f9a96d7a4c91d4ec773c03aa188940382805"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["fac252ef8e3d0bbff9303ffbf675e824a729dfaf"]},"commit2Childs":{"de73f9a96d7a4c91d4ec773c03aa188940382805":["685bd38810c206c93e9058f3c2cfa9827c086c27","fac252ef8e3d0bbff9303ffbf675e824a729dfaf"],"685bd38810c206c93e9058f3c2cfa9827c086c27":[],"fac252ef8e3d0bbff9303ffbf675e824a729dfaf":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["de73f9a96d7a4c91d4ec773c03aa188940382805","685bd38810c206c93e9058f3c2cfa9827c086c27"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["685bd38810c206c93e9058f3c2cfa9827c086c27","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}