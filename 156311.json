{"path":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","sourceNew":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort() throws IOException {\n\n    try {\n      if (infoStream != null) {\n        message(\"docWriter: now abort\");\n      }\n\n      // Forcefully remove waiting ThreadStates from line\n      waitQueue.abort();\n\n      // Wait for all other threads to finish with\n      // DocumentsWriter:\n      pauseAllThreads();\n\n      try {\n\n        assert 0 == waitQueue.numWaiting;\n\n        waitQueue.waitingBytes = 0;\n\n        try {\n          abortedFiles = openFiles();\n        } catch (Throwable t) {\n          abortedFiles = null;\n        }\n\n        deletesInRAM.clear();\n\n        openFiles.clear();\n\n        for(int i=0;i<threadStates.length;i++)\n          try {\n            threadStates[i].consumer.abort();\n          } catch (Throwable t) {\n          }\n\n        try {\n          consumer.abort();\n        } catch (Throwable t) {\n        }\n\n        docStoreSegment = null;\n        numDocsInStore = 0;\n        docStoreOffset = 0;\n\n        // Reset all postings data\n        doAfterFlush();\n\n      } finally {\n        resumeAllThreads();\n      }\n    } finally {\n      aborting = false;\n      notifyAll();\n      if (infoStream != null) {\n        message(\"docWriter: done abort\");\n      }\n    }\n  }\n\n","sourceOld":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort() throws IOException {\n\n    try {\n      if (infoStream != null) {\n        message(\"docWriter: now abort\");\n      }\n\n      // Forcefully remove waiting ThreadStates from line\n      waitQueue.abort();\n\n      // Wait for all other threads to finish with\n      // DocumentsWriter:\n      pauseAllThreads();\n\n      try {\n\n        assert 0 == waitQueue.numWaiting;\n\n        waitQueue.waitingBytes = 0;\n\n        try {\n          abortedFiles = openFiles();\n        } catch (Throwable t) {\n          abortedFiles = null;\n        }\n\n        deletesInRAM.clear();\n\n        openFiles.clear();\n\n        for(int i=0;i<threadStates.length;i++)\n          try {\n            threadStates[i].consumer.abort();\n          } catch (Throwable t) {\n          }\n\n        try {\n          consumer.abort();\n        } catch (Throwable t) {\n        }\n\n        docStoreSegment = null;\n        numDocsInStore = 0;\n        docStoreOffset = 0;\n\n        // Reset all postings data\n        doAfterFlush();\n\n      } finally {\n        resumeAllThreads();\n      }\n    } finally {\n      aborting = false;\n      notifyAll();\n      if (infoStream != null) {\n        message(\"docWriter: done abort\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"67ed9fd4da5f37b8d0e9f22418cc6eb3dfa26c0f","date":1279037830,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","sourceNew":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort() throws IOException {\n\n    try {\n      if (infoStream != null) {\n        message(\"docWriter: now abort\");\n      }\n\n      // Forcefully remove waiting ThreadStates from line\n      waitQueue.abort();\n\n      // Wait for all other threads to finish with\n      // DocumentsWriter:\n      pauseAllThreads();\n\n      try {\n\n        assert 0 == waitQueue.numWaiting;\n\n        waitQueue.waitingBytes = 0;\n\n        try {\n          abortedFiles = openFiles();\n        } catch (Throwable t) {\n          abortedFiles = null;\n        }\n\n        deletesInRAM.clear();\n        deletesFlushed.clear();\n\n        openFiles.clear();\n\n        for(int i=0;i<threadStates.length;i++)\n          try {\n            threadStates[i].consumer.abort();\n          } catch (Throwable t) {\n          }\n\n        try {\n          consumer.abort();\n        } catch (Throwable t) {\n        }\n\n        docStoreSegment = null;\n        numDocsInStore = 0;\n        docStoreOffset = 0;\n\n        // Reset all postings data\n        doAfterFlush();\n\n      } finally {\n        resumeAllThreads();\n      }\n    } finally {\n      aborting = false;\n      notifyAll();\n      if (infoStream != null) {\n        message(\"docWriter: done abort\");\n      }\n    }\n  }\n\n","sourceOld":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort() throws IOException {\n\n    try {\n      if (infoStream != null) {\n        message(\"docWriter: now abort\");\n      }\n\n      // Forcefully remove waiting ThreadStates from line\n      waitQueue.abort();\n\n      // Wait for all other threads to finish with\n      // DocumentsWriter:\n      pauseAllThreads();\n\n      try {\n\n        assert 0 == waitQueue.numWaiting;\n\n        waitQueue.waitingBytes = 0;\n\n        try {\n          abortedFiles = openFiles();\n        } catch (Throwable t) {\n          abortedFiles = null;\n        }\n\n        deletesInRAM.clear();\n\n        openFiles.clear();\n\n        for(int i=0;i<threadStates.length;i++)\n          try {\n            threadStates[i].consumer.abort();\n          } catch (Throwable t) {\n          }\n\n        try {\n          consumer.abort();\n        } catch (Throwable t) {\n        }\n\n        docStoreSegment = null;\n        numDocsInStore = 0;\n        docStoreOffset = 0;\n\n        // Reset all postings data\n        doAfterFlush();\n\n      } finally {\n        resumeAllThreads();\n      }\n    } finally {\n      aborting = false;\n      notifyAll();\n      if (infoStream != null) {\n        message(\"docWriter: done abort\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9b832cbed6eb3d54a8bb9339296bdda8eeb53014","date":1279708040,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","sourceNew":"  void abort() throws IOException {\n    threadPool.abort();\n    try {\n      try {\n        abortedFiles = openFiles();\n      } catch (Throwable t) {\n        abortedFiles = null;\n      }\n  \n      deletesInRAM.clear();\n      // nocommit\n  //        deletesFlushed.clear();\n  \n      openFiles.clear();\n    } finally {\n      threadPool.finishAbort();\n    }\n\n  }\n\n","sourceOld":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort() throws IOException {\n\n    try {\n      if (infoStream != null) {\n        message(\"docWriter: now abort\");\n      }\n\n      // Forcefully remove waiting ThreadStates from line\n      waitQueue.abort();\n\n      // Wait for all other threads to finish with\n      // DocumentsWriter:\n      pauseAllThreads();\n\n      try {\n\n        assert 0 == waitQueue.numWaiting;\n\n        waitQueue.waitingBytes = 0;\n\n        try {\n          abortedFiles = openFiles();\n        } catch (Throwable t) {\n          abortedFiles = null;\n        }\n\n        deletesInRAM.clear();\n        deletesFlushed.clear();\n\n        openFiles.clear();\n\n        for(int i=0;i<threadStates.length;i++)\n          try {\n            threadStates[i].consumer.abort();\n          } catch (Throwable t) {\n          }\n\n        try {\n          consumer.abort();\n        } catch (Throwable t) {\n        }\n\n        docStoreSegment = null;\n        numDocsInStore = 0;\n        docStoreOffset = 0;\n\n        // Reset all postings data\n        doAfterFlush();\n\n      } finally {\n        resumeAllThreads();\n      }\n    } finally {\n      aborting = false;\n      notifyAll();\n      if (infoStream != null) {\n        message(\"docWriter: done abort\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"334c1175813aea771a71728cd2c4ee4754fd0603","date":1279710173,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","sourceNew":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort() throws IOException {\n\n    try {\n      if (infoStream != null) {\n        message(\"docWriter: now abort\");\n      }\n\n      // Forcefully remove waiting ThreadStates from line\n      waitQueue.abort();\n\n      // Wait for all other threads to finish with\n      // DocumentsWriter:\n      pauseAllThreads();\n\n      try {\n\n        assert 0 == waitQueue.numWaiting;\n\n        waitQueue.waitingBytes = 0;\n\n        try {\n          abortedFiles = openFiles();\n        } catch (Throwable t) {\n          abortedFiles = null;\n        }\n\n        deletesInRAM.clear();\n        deletesFlushed.clear();\n\n        openFiles.clear();\n\n        for(int i=0;i<threadStates.length;i++)\n          try {\n            threadStates[i].consumer.abort();\n          } catch (Throwable t) {\n          }\n\n        try {\n          consumer.abort();\n        } catch (Throwable t) {\n        }\n\n        docStoreSegment = null;\n        numDocsInStore = 0;\n        docStoreOffset = 0;\n\n        // Reset all postings data\n        doAfterFlush();\n\n      } finally {\n        resumeAllThreads();\n      }\n    } finally {\n      aborting = false;\n      notifyAll();\n      if (infoStream != null) {\n        message(\"docWriter: done abort\");\n      }\n    }\n  }\n\n","sourceOld":"  void abort() throws IOException {\n    threadPool.abort();\n    try {\n      try {\n        abortedFiles = openFiles();\n      } catch (Throwable t) {\n        abortedFiles = null;\n      }\n  \n      deletesInRAM.clear();\n      // nocommit\n  //        deletesFlushed.clear();\n  \n      openFiles.clear();\n    } finally {\n      threadPool.finishAbort();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":["f241b963c5bcd6c2293a928059dd2d64988a6042","f241b963c5bcd6c2293a928059dd2d64988a6042","f241b963c5bcd6c2293a928059dd2d64988a6042","4d3e8520fd031bab31fd0e4d480e55958bc45efe","4d3e8520fd031bab31fd0e4d480e55958bc45efe","4d3e8520fd031bab31fd0e4d480e55958bc45efe","2a186ae8733084223c22044e935e4ef848a143d1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8fe956d65251358d755c56f14fe8380644790e47","date":1279711318,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","sourceNew":"  void abort() throws IOException {\n    threadPool.abort();\n    try {\n      try {\n        abortedFiles = openFiles();\n      } catch (Throwable t) {\n        abortedFiles = null;\n      }\n  \n      deletesInRAM.clear();\n      // nocommit\n  //        deletesFlushed.clear();\n  \n      openFiles.clear();\n    } finally {\n      threadPool.finishAbort();\n    }\n\n  }\n\n","sourceOld":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort() throws IOException {\n\n    try {\n      if (infoStream != null) {\n        message(\"docWriter: now abort\");\n      }\n\n      // Forcefully remove waiting ThreadStates from line\n      waitQueue.abort();\n\n      // Wait for all other threads to finish with\n      // DocumentsWriter:\n      pauseAllThreads();\n\n      try {\n\n        assert 0 == waitQueue.numWaiting;\n\n        waitQueue.waitingBytes = 0;\n\n        try {\n          abortedFiles = openFiles();\n        } catch (Throwable t) {\n          abortedFiles = null;\n        }\n\n        deletesInRAM.clear();\n\n        openFiles.clear();\n\n        for(int i=0;i<threadStates.length;i++)\n          try {\n            threadStates[i].consumer.abort();\n          } catch (Throwable t) {\n          }\n\n        try {\n          consumer.abort();\n        } catch (Throwable t) {\n        }\n\n        docStoreSegment = null;\n        numDocsInStore = 0;\n        docStoreOffset = 0;\n\n        // Reset all postings data\n        doAfterFlush();\n\n      } finally {\n        resumeAllThreads();\n      }\n    } finally {\n      aborting = false;\n      notifyAll();\n      if (infoStream != null) {\n        message(\"docWriter: done abort\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["5ef87af8c7bd0f8429622b83aa74202383f2e757"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5ef87af8c7bd0f8429622b83aa74202383f2e757","date":1280262785,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","sourceNew":"  void abort() throws IOException {\n    threadPool.abort(new DocumentsWriterThreadPool.AbortTask() {\n      \n      @Override\n      void abort() throws IOException {\n        try {\n          abortedFiles = openFiles();\n        } catch (Throwable t) {\n          abortedFiles = null;\n        }\n    \n        deletesInRAM.clear();\n        // nocommit\n    //        deletesFlushed.clear();\n    \n        openFiles.clear();\n        deletesInRAM.clear();\n      }\n    });\n  }\n\n","sourceOld":"  void abort() throws IOException {\n    threadPool.abort();\n    try {\n      try {\n        abortedFiles = openFiles();\n      } catch (Throwable t) {\n        abortedFiles = null;\n      }\n  \n      deletesInRAM.clear();\n      // nocommit\n  //        deletesFlushed.clear();\n  \n      openFiles.clear();\n    } finally {\n      threadPool.finishAbort();\n    }\n\n  }\n\n","bugFix":["5350389bf83287111f7760b9e3db3af8e3648474","8fe956d65251358d755c56f14fe8380644790e47"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2a186ae8733084223c22044e935e4ef848a143d1","date":1289694819,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","sourceNew":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort() throws IOException {\n\n    try {\n      if (infoStream != null) {\n        message(\"docWriter: now abort\");\n      }\n\n      // Forcefully remove waiting ThreadStates from line\n      waitQueue.abort();\n\n      // Wait for all other threads to finish with\n      // DocumentsWriter:\n      pauseAllThreads();\n\n      try {\n\n        assert 0 == waitQueue.numWaiting;\n\n        waitQueue.waitingBytes = 0;\n\n        try {\n          abortedFiles = openFiles();\n        } catch (Throwable t) {\n          abortedFiles = null;\n        }\n\n        deletesInRAM.clear();\n        deletesFlushed.clear();\n\n        openFiles.clear();\n\n        for(int i=0;i<threadStates.length;i++)\n          try {\n            threadStates[i].consumer.abort();\n          } catch (Throwable t) {\n          }\n\n        try {\n          consumer.abort();\n        } catch (Throwable t) {\n        }\n\n        docStoreSegment = null;\n        numDocsInStore = 0;\n        docStoreOffset = 0;\n\n        // Reset all postings data\n        doAfterFlush();\n\n      } finally {\n        resumeAllThreads();\n      }\n    } finally {\n      aborting = false;\n      notifyAll();\n      if (infoStream != null) {\n        message(\"docWriter: done abort; abortedFiles=\" + abortedFiles);\n      }\n    }\n  }\n\n","sourceOld":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort() throws IOException {\n\n    try {\n      if (infoStream != null) {\n        message(\"docWriter: now abort\");\n      }\n\n      // Forcefully remove waiting ThreadStates from line\n      waitQueue.abort();\n\n      // Wait for all other threads to finish with\n      // DocumentsWriter:\n      pauseAllThreads();\n\n      try {\n\n        assert 0 == waitQueue.numWaiting;\n\n        waitQueue.waitingBytes = 0;\n\n        try {\n          abortedFiles = openFiles();\n        } catch (Throwable t) {\n          abortedFiles = null;\n        }\n\n        deletesInRAM.clear();\n        deletesFlushed.clear();\n\n        openFiles.clear();\n\n        for(int i=0;i<threadStates.length;i++)\n          try {\n            threadStates[i].consumer.abort();\n          } catch (Throwable t) {\n          }\n\n        try {\n          consumer.abort();\n        } catch (Throwable t) {\n        }\n\n        docStoreSegment = null;\n        numDocsInStore = 0;\n        docStoreOffset = 0;\n\n        // Reset all postings data\n        doAfterFlush();\n\n      } finally {\n        resumeAllThreads();\n      }\n    } finally {\n      aborting = false;\n      notifyAll();\n      if (infoStream != null) {\n        message(\"docWriter: done abort\");\n      }\n    }\n  }\n\n","bugFix":["334c1175813aea771a71728cd2c4ee4754fd0603"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c498d3f8d75170b121f5eda2c6210ac5beb5d411","date":1289726298,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","sourceNew":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort() throws IOException {\n\n    try {\n      if (infoStream != null) {\n        message(\"docWriter: now abort\");\n      }\n\n      // Forcefully remove waiting ThreadStates from line\n      waitQueue.abort();\n\n      // Wait for all other threads to finish with\n      // DocumentsWriter:\n      pauseAllThreads();\n\n      try {\n\n        assert 0 == waitQueue.numWaiting;\n\n        waitQueue.waitingBytes = 0;\n\n        try {\n          abortedFiles = openFiles();\n        } catch (Throwable t) {\n          abortedFiles = null;\n        }\n\n        deletesInRAM.clear();\n        deletesFlushed.clear();\n\n        openFiles.clear();\n\n        for(int i=0;i<threadStates.length;i++)\n          try {\n            threadStates[i].consumer.abort();\n          } catch (Throwable t) {\n          }\n\n        try {\n          consumer.abort();\n        } catch (Throwable t) {\n        }\n\n        docStoreSegment = null;\n        numDocsInStore = 0;\n        docStoreOffset = 0;\n\n        // Reset all postings data\n        doAfterFlush();\n\n      } finally {\n        resumeAllThreads();\n      }\n    } finally {\n      aborting = false;\n      notifyAll();\n      if (infoStream != null) {\n        message(\"docWriter: done abort; abortedFiles=\" + abortedFiles);\n      }\n    }\n  }\n\n","sourceOld":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort() throws IOException {\n\n    try {\n      if (infoStream != null) {\n        message(\"docWriter: now abort\");\n      }\n\n      // Forcefully remove waiting ThreadStates from line\n      waitQueue.abort();\n\n      // Wait for all other threads to finish with\n      // DocumentsWriter:\n      pauseAllThreads();\n\n      try {\n\n        assert 0 == waitQueue.numWaiting;\n\n        waitQueue.waitingBytes = 0;\n\n        try {\n          abortedFiles = openFiles();\n        } catch (Throwable t) {\n          abortedFiles = null;\n        }\n\n        deletesInRAM.clear();\n        deletesFlushed.clear();\n\n        openFiles.clear();\n\n        for(int i=0;i<threadStates.length;i++)\n          try {\n            threadStates[i].consumer.abort();\n          } catch (Throwable t) {\n          }\n\n        try {\n          consumer.abort();\n        } catch (Throwable t) {\n        }\n\n        docStoreSegment = null;\n        numDocsInStore = 0;\n        docStoreOffset = 0;\n\n        // Reset all postings data\n        doAfterFlush();\n\n      } finally {\n        resumeAllThreads();\n      }\n    } finally {\n      aborting = false;\n      notifyAll();\n      if (infoStream != null) {\n        message(\"docWriter: done abort\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"44fcbde6fb2ac44ee3b45e013e54a42911e689ff","date":1292065621,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","sourceNew":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort() throws IOException {\n\n    if (infoStream != null) {\n      message(\"docWriter: abort\");\n    }\n\n    boolean success = false;\n\n    try {\n\n      // Forcefully remove waiting ThreadStates from line\n      waitQueue.abort();\n\n      // Wait for all other threads to finish with\n      // DocumentsWriter:\n      waitIdle();\n\n      if (infoStream != null) {\n        message(\"docWriter: abort waitIdle done\");\n      }\n\n      assert 0 == waitQueue.numWaiting: \"waitQueue.numWaiting=\" + waitQueue.numWaiting;\n\n      waitQueue.waitingBytes = 0;\n\n      try {\n        abortedFiles = openFiles();\n      } catch (Throwable t) {\n        abortedFiles = null;\n      }\n\n      pendingDeletes.clear();\n        \n      openFiles.clear();\n\n      for(int i=0;i<threadStates.length;i++)\n        try {\n          threadStates[i].consumer.abort();\n        } catch (Throwable t) {\n        }\n\n      try {\n        consumer.abort();\n      } catch (Throwable t) {\n      }\n\n      docStoreSegment = null;\n      numDocsInStore = 0;\n      docStoreOffset = 0;\n\n      // Reset all postings data\n      doAfterFlush();\n      success = true;\n    } finally {\n      aborting = false;\n      notifyAll();\n      if (infoStream != null) {\n        message(\"docWriter: done abort; abortedFiles=\" + abortedFiles + \" success=\" + success);\n      }\n    }\n  }\n\n","sourceOld":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort() throws IOException {\n\n    try {\n      if (infoStream != null) {\n        message(\"docWriter: now abort\");\n      }\n\n      // Forcefully remove waiting ThreadStates from line\n      waitQueue.abort();\n\n      // Wait for all other threads to finish with\n      // DocumentsWriter:\n      pauseAllThreads();\n\n      try {\n\n        assert 0 == waitQueue.numWaiting;\n\n        waitQueue.waitingBytes = 0;\n\n        try {\n          abortedFiles = openFiles();\n        } catch (Throwable t) {\n          abortedFiles = null;\n        }\n\n        deletesInRAM.clear();\n        deletesFlushed.clear();\n\n        openFiles.clear();\n\n        for(int i=0;i<threadStates.length;i++)\n          try {\n            threadStates[i].consumer.abort();\n          } catch (Throwable t) {\n          }\n\n        try {\n          consumer.abort();\n        } catch (Throwable t) {\n        }\n\n        docStoreSegment = null;\n        numDocsInStore = 0;\n        docStoreOffset = 0;\n\n        // Reset all postings data\n        doAfterFlush();\n\n      } finally {\n        resumeAllThreads();\n      }\n    } finally {\n      aborting = false;\n      notifyAll();\n      if (infoStream != null) {\n        message(\"docWriter: done abort; abortedFiles=\" + abortedFiles);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4948bc5d29211f0c9b5ccc31b2632cdd27066ea5","date":1292695408,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","sourceNew":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort() throws IOException {\n    if (infoStream != null) {\n      message(\"docWriter: abort\");\n    }\n\n    boolean success = false;\n\n    try {\n\n      // Forcefully remove waiting ThreadStates from line\n      waitQueue.abort();\n\n      // Wait for all other threads to finish with\n      // DocumentsWriter:\n      waitIdle();\n\n      if (infoStream != null) {\n        message(\"docWriter: abort waitIdle done\");\n      }\n\n      assert 0 == waitQueue.numWaiting: \"waitQueue.numWaiting=\" + waitQueue.numWaiting;\n\n      waitQueue.waitingBytes = 0;\n\n      pendingDeletes.clear();\n\n      for (DocumentsWriterThreadState threadState : threadStates)\n        try {\n          threadState.consumer.abort();\n        } catch (Throwable t) {\n        }\n\n      try {\n        consumer.abort();\n      } catch (Throwable t) {\n      }\n\n      // Reset all postings data\n      doAfterFlush();\n      success = true;\n    } finally {\n      aborting = false;\n      notifyAll();\n      if (infoStream != null) {\n        message(\"docWriter: done abort; success=\" + success);\n      }\n    }\n  }\n\n","sourceOld":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort() throws IOException {\n\n    if (infoStream != null) {\n      message(\"docWriter: abort\");\n    }\n\n    boolean success = false;\n\n    try {\n\n      // Forcefully remove waiting ThreadStates from line\n      waitQueue.abort();\n\n      // Wait for all other threads to finish with\n      // DocumentsWriter:\n      waitIdle();\n\n      if (infoStream != null) {\n        message(\"docWriter: abort waitIdle done\");\n      }\n\n      assert 0 == waitQueue.numWaiting: \"waitQueue.numWaiting=\" + waitQueue.numWaiting;\n\n      waitQueue.waitingBytes = 0;\n\n      try {\n        abortedFiles = openFiles();\n      } catch (Throwable t) {\n        abortedFiles = null;\n      }\n\n      pendingDeletes.clear();\n        \n      openFiles.clear();\n\n      for(int i=0;i<threadStates.length;i++)\n        try {\n          threadStates[i].consumer.abort();\n        } catch (Throwable t) {\n        }\n\n      try {\n        consumer.abort();\n      } catch (Throwable t) {\n      }\n\n      docStoreSegment = null;\n      numDocsInStore = 0;\n      docStoreOffset = 0;\n\n      // Reset all postings data\n      doAfterFlush();\n      success = true;\n    } finally {\n      aborting = false;\n      notifyAll();\n      if (infoStream != null) {\n        message(\"docWriter: done abort; abortedFiles=\" + abortedFiles + \" success=\" + success);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ab5cb6a74aefb78aa0569857970b9151dfe2e787","date":1292842407,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","sourceNew":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort() throws IOException {\n    if (infoStream != null) {\n      message(\"docWriter: abort\");\n    }\n\n    boolean success = false;\n\n    try {\n\n      // Forcefully remove waiting ThreadStates from line\n      waitQueue.abort();\n\n      // Wait for all other threads to finish with\n      // DocumentsWriter:\n      waitIdle();\n\n      if (infoStream != null) {\n        message(\"docWriter: abort waitIdle done\");\n      }\n\n      assert 0 == waitQueue.numWaiting: \"waitQueue.numWaiting=\" + waitQueue.numWaiting;\n\n      waitQueue.waitingBytes = 0;\n\n      pendingDeletes.clear();\n\n      for (DocumentsWriterThreadState threadState : threadStates)\n        try {\n          threadState.consumer.abort();\n        } catch (Throwable t) {\n        }\n\n      try {\n        consumer.abort();\n      } catch (Throwable t) {\n      }\n\n      // Reset all postings data\n      doAfterFlush();\n      success = true;\n    } finally {\n      aborting = false;\n      notifyAll();\n      if (infoStream != null) {\n        message(\"docWriter: done abort; success=\" + success);\n      }\n    }\n  }\n\n","sourceOld":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort() throws IOException {\n\n    try {\n      if (infoStream != null) {\n        message(\"docWriter: now abort\");\n      }\n\n      // Forcefully remove waiting ThreadStates from line\n      waitQueue.abort();\n\n      // Wait for all other threads to finish with\n      // DocumentsWriter:\n      pauseAllThreads();\n\n      try {\n\n        assert 0 == waitQueue.numWaiting;\n\n        waitQueue.waitingBytes = 0;\n\n        try {\n          abortedFiles = openFiles();\n        } catch (Throwable t) {\n          abortedFiles = null;\n        }\n\n        deletesInRAM.clear();\n        deletesFlushed.clear();\n\n        openFiles.clear();\n\n        for(int i=0;i<threadStates.length;i++)\n          try {\n            threadStates[i].consumer.abort();\n          } catch (Throwable t) {\n          }\n\n        try {\n          consumer.abort();\n        } catch (Throwable t) {\n        }\n\n        docStoreSegment = null;\n        numDocsInStore = 0;\n        docStoreOffset = 0;\n\n        // Reset all postings data\n        doAfterFlush();\n\n      } finally {\n        resumeAllThreads();\n      }\n    } finally {\n      aborting = false;\n      notifyAll();\n      if (infoStream != null) {\n        message(\"docWriter: done abort; abortedFiles=\" + abortedFiles);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","sourceNew":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort() throws IOException {\n    if (infoStream != null) {\n      message(\"docWriter: abort\");\n    }\n\n    boolean success = false;\n    try {\n\n      threadPool.abort();\n      success = true;\n    } finally {\n      notifyAll();\n      if (infoStream != null) {\n        message(\"docWriter: done abort; abortedFiles=\" + abortedFiles + \" success=\" + success);\n      }\n    }\n  }\n\n","sourceOld":"  void abort() throws IOException {\n    threadPool.abort(new DocumentsWriterThreadPool.AbortTask() {\n      \n      @Override\n      void abort() throws IOException {\n        try {\n          abortedFiles = openFiles();\n        } catch (Throwable t) {\n          abortedFiles = null;\n        }\n    \n        deletesInRAM.clear();\n        // nocommit\n    //        deletesFlushed.clear();\n    \n        openFiles.clear();\n        deletesInRAM.clear();\n      }\n    });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ff78505662c0b741e2663a9f38a4889c12a32c9f","date":1294908561,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","sourceNew":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort() throws IOException {\n    boolean success = false;\n\n    try {\n      if (infoStream != null) {\n        message(\"docWriter: abort\");\n      }\n\n      Iterator<ThreadState> threadsIterator = perThreadPool.getActivePerThreadsIterator();\n\n      while (threadsIterator.hasNext()) {\n        ThreadState perThread = threadsIterator.next();\n        perThread.lock();\n        try {\n          perThread.perThread.abort();\n        } finally {\n          perThread.unlock();\n        }\n      }\n\n      success = true;\n    } finally {\n      notifyAll();\n      if (infoStream != null) {\n        message(\"docWriter: done abort; abortedFiles=\" + abortedFiles + \" success=\" + success);\n      }\n    }\n  }\n\n","sourceOld":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort() throws IOException {\n    if (infoStream != null) {\n      message(\"docWriter: abort\");\n    }\n\n    boolean success = false;\n    try {\n\n      threadPool.abort();\n      success = true;\n    } finally {\n      notifyAll();\n      if (infoStream != null) {\n        message(\"docWriter: done abort; abortedFiles=\" + abortedFiles + \" success=\" + success);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["c00afe74a80796ed1f30a9509b150ff104746a1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"eeb75d1685f27b55c20770200a5a24a8251ce9d5","date":1295257851,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","sourceNew":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort() throws IOException {\n    boolean success = false;\n\n    try {\n      if (infoStream != null) {\n        message(\"docWriter: abort\");\n      }\n\n      Iterator<ThreadState> threadsIterator = perThreadPool.getActivePerThreadsIterator();\n\n      while (threadsIterator.hasNext()) {\n        ThreadState perThread = threadsIterator.next();\n        perThread.lock();\n        try {\n          perThread.perThread.abort();\n        } finally {\n          perThread.unlock();\n        }\n      }\n\n      success = true;\n    } finally {\n      if (infoStream != null) {\n        message(\"docWriter: done abort; abortedFiles=\" + abortedFiles + \" success=\" + success);\n      }\n    }\n  }\n\n","sourceOld":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort() throws IOException {\n    boolean success = false;\n\n    try {\n      if (infoStream != null) {\n        message(\"docWriter: abort\");\n      }\n\n      Iterator<ThreadState> threadsIterator = perThreadPool.getActivePerThreadsIterator();\n\n      while (threadsIterator.hasNext()) {\n        ThreadState perThread = threadsIterator.next();\n        perThread.lock();\n        try {\n          perThread.perThread.abort();\n        } finally {\n          perThread.unlock();\n        }\n      }\n\n      success = true;\n    } finally {\n      notifyAll();\n      if (infoStream != null) {\n        message(\"docWriter: done abort; abortedFiles=\" + abortedFiles + \" success=\" + success);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bfaa69f5e3b29a90ec41762bfbfa166a9e52eccf","date":1298618128,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","sourceNew":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort() throws IOException {\n    boolean success = false;\n\n    synchronized (this) {\n      pendingDeletes.clear();\n    }\n\n    try {\n      if (infoStream != null) {\n        message(\"docWriter: abort\");\n      }\n\n      Iterator<ThreadState> threadsIterator = perThreadPool.getActivePerThreadsIterator();\n\n      while (threadsIterator.hasNext()) {\n        ThreadState perThread = threadsIterator.next();\n        perThread.lock();\n        try {\n          perThread.perThread.abort();\n        } finally {\n          perThread.unlock();\n        }\n      }\n\n      success = true;\n    } finally {\n      if (infoStream != null) {\n        message(\"docWriter: done abort; abortedFiles=\" + abortedFiles + \" success=\" + success);\n      }\n    }\n  }\n\n","sourceOld":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort() throws IOException {\n    boolean success = false;\n\n    try {\n      if (infoStream != null) {\n        message(\"docWriter: abort\");\n      }\n\n      Iterator<ThreadState> threadsIterator = perThreadPool.getActivePerThreadsIterator();\n\n      while (threadsIterator.hasNext()) {\n        ThreadState perThread = threadsIterator.next();\n        perThread.lock();\n        try {\n          perThread.perThread.abort();\n        } finally {\n          perThread.unlock();\n        }\n      }\n\n      success = true;\n    } finally {\n      if (infoStream != null) {\n        message(\"docWriter: done abort; abortedFiles=\" + abortedFiles + \" success=\" + success);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["6ab569c1172c7f749243bbad23c63f9c5542aca4","6ab569c1172c7f749243bbad23c63f9c5542aca4","6ab569c1172c7f749243bbad23c63f9c5542aca4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d2ed1b9b7b46829fe3199afe9a8bc203f201b175","date":1301491807,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","sourceNew":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort() throws IOException {\n    boolean success = false;\n\n    synchronized (this) {\n      pendingDeletes.clear();\n    }\n\n    try {\n      if (infoStream != null) {\n        message(\"docWriter: abort\");\n      }\n\n      final Iterator<ThreadState> threadsIterator = perThreadPool.getActivePerThreadsIterator();\n\n      while (threadsIterator.hasNext()) {\n        ThreadState perThread = threadsIterator.next();\n        perThread.lock();\n        try {\n          if (perThread.isActive()) { // we might be closed\n            perThread.perThread.abort();\n            perThread.perThread.checkAndResetHasAborted();\n          } else {\n            assert closed;\n          }\n        } finally {\n          perThread.unlock();\n        }\n      }\n\n      success = true;\n    } finally {\n      if (infoStream != null) {\n        message(\"docWriter: done abort; abortedFiles=\" + abortedFiles + \" success=\" + success);\n      }\n    }\n  }\n\n","sourceOld":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort() throws IOException {\n    boolean success = false;\n\n    synchronized (this) {\n      pendingDeletes.clear();\n    }\n\n    try {\n      if (infoStream != null) {\n        message(\"docWriter: abort\");\n      }\n\n      Iterator<ThreadState> threadsIterator = perThreadPool.getActivePerThreadsIterator();\n\n      while (threadsIterator.hasNext()) {\n        ThreadState perThread = threadsIterator.next();\n        perThread.lock();\n        try {\n          perThread.perThread.abort();\n        } finally {\n          perThread.unlock();\n        }\n      }\n\n      success = true;\n    } finally {\n      if (infoStream != null) {\n        message(\"docWriter: done abort; abortedFiles=\" + abortedFiles + \" success=\" + success);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"327863a2fd61e831028b6c56c8fef6b00a44eb0b","date":1302686439,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","sourceNew":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort() throws IOException {\n    boolean success = false;\n\n    synchronized (this) {\n      deleteQueue.clear();\n    }\n\n    try {\n      if (infoStream != null) {\n        message(\"docWriter: abort\");\n      }\n\n      final Iterator<ThreadState> threadsIterator = perThreadPool.getActivePerThreadsIterator();\n\n      while (threadsIterator.hasNext()) {\n        ThreadState perThread = threadsIterator.next();\n        perThread.lock();\n        try {\n          if (perThread.isActive()) { // we might be closed\n            perThread.perThread.abort();\n            perThread.perThread.checkAndResetHasAborted();\n          } else {\n            assert closed;\n          }\n        } finally {\n          perThread.unlock();\n        }\n      }\n\n      success = true;\n    } finally {\n      if (infoStream != null) {\n        message(\"docWriter: done abort; abortedFiles=\" + abortedFiles + \" success=\" + success);\n      }\n    }\n  }\n\n","sourceOld":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort() throws IOException {\n    boolean success = false;\n\n    synchronized (this) {\n      pendingDeletes.clear();\n    }\n\n    try {\n      if (infoStream != null) {\n        message(\"docWriter: abort\");\n      }\n\n      final Iterator<ThreadState> threadsIterator = perThreadPool.getActivePerThreadsIterator();\n\n      while (threadsIterator.hasNext()) {\n        ThreadState perThread = threadsIterator.next();\n        perThread.lock();\n        try {\n          if (perThread.isActive()) { // we might be closed\n            perThread.perThread.abort();\n            perThread.perThread.checkAndResetHasAborted();\n          } else {\n            assert closed;\n          }\n        } finally {\n          perThread.unlock();\n        }\n      }\n\n      success = true;\n    } finally {\n      if (infoStream != null) {\n        message(\"docWriter: done abort; abortedFiles=\" + abortedFiles + \" success=\" + success);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["6ab569c1172c7f749243bbad23c63f9c5542aca4","6ab569c1172c7f749243bbad23c63f9c5542aca4","6ab569c1172c7f749243bbad23c63f9c5542aca4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b3e06be49006ecac364d39d12b9c9f74882f9b9f","date":1304289513,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","sourceNew":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort() throws IOException {\n    boolean success = false;\n\n    synchronized (this) {\n      deleteQueue.clear();\n    }\n\n    try {\n      if (infoStream != null) {\n        message(\"docWriter: abort\");\n      }\n\n      final Iterator<ThreadState> threadsIterator = perThreadPool.getActivePerThreadsIterator();\n\n      while (threadsIterator.hasNext()) {\n        ThreadState perThread = threadsIterator.next();\n        perThread.lock();\n        try {\n          if (perThread.isActive()) { // we might be closed\n            perThread.perThread.abort();\n            perThread.perThread.checkAndResetHasAborted();\n          } else {\n            assert closed;\n          }\n        } finally {\n          perThread.unlock();\n        }\n      }\n\n      success = true;\n    } finally {\n      if (infoStream != null) {\n        message(\"docWriter: done abort; abortedFiles=\" + abortedFiles + \" success=\" + success);\n      }\n    }\n  }\n\n","sourceOld":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort() throws IOException {\n    if (infoStream != null) {\n      message(\"docWriter: abort\");\n    }\n\n    boolean success = false;\n\n    try {\n\n      // Forcefully remove waiting ThreadStates from line\n      waitQueue.abort();\n\n      // Wait for all other threads to finish with\n      // DocumentsWriter:\n      waitIdle();\n\n      if (infoStream != null) {\n        message(\"docWriter: abort waitIdle done\");\n      }\n\n      assert 0 == waitQueue.numWaiting: \"waitQueue.numWaiting=\" + waitQueue.numWaiting;\n\n      waitQueue.waitingBytes = 0;\n\n      pendingDeletes.clear();\n\n      for (DocumentsWriterThreadState threadState : threadStates)\n        try {\n          threadState.consumer.abort();\n        } catch (Throwable t) {\n        }\n\n      try {\n        consumer.abort();\n      } catch (Throwable t) {\n      }\n\n      // Reset all postings data\n      doAfterFlush();\n      success = true;\n    } finally {\n      aborting = false;\n      notifyAll();\n      if (infoStream != null) {\n        message(\"docWriter: done abort; success=\" + success);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"135621f3a0670a9394eb563224a3b76cc4dddc0f","date":1304344257,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","sourceNew":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort() throws IOException {\n    boolean success = false;\n\n    synchronized (this) {\n      deleteQueue.clear();\n    }\n\n    try {\n      if (infoStream != null) {\n        message(\"docWriter: abort\");\n      }\n\n      final Iterator<ThreadState> threadsIterator = perThreadPool.getActivePerThreadsIterator();\n\n      while (threadsIterator.hasNext()) {\n        ThreadState perThread = threadsIterator.next();\n        perThread.lock();\n        try {\n          if (perThread.isActive()) { // we might be closed\n            perThread.perThread.abort();\n            perThread.perThread.checkAndResetHasAborted();\n          } else {\n            assert closed;\n          }\n        } finally {\n          perThread.unlock();\n        }\n      }\n\n      success = true;\n    } finally {\n      if (infoStream != null) {\n        message(\"docWriter: done abort; abortedFiles=\" + abortedFiles + \" success=\" + success);\n      }\n    }\n  }\n\n","sourceOld":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort() throws IOException {\n    if (infoStream != null) {\n      message(\"docWriter: abort\");\n    }\n\n    boolean success = false;\n\n    try {\n\n      // Forcefully remove waiting ThreadStates from line\n      waitQueue.abort();\n\n      // Wait for all other threads to finish with\n      // DocumentsWriter:\n      waitIdle();\n\n      if (infoStream != null) {\n        message(\"docWriter: abort waitIdle done\");\n      }\n\n      assert 0 == waitQueue.numWaiting: \"waitQueue.numWaiting=\" + waitQueue.numWaiting;\n\n      waitQueue.waitingBytes = 0;\n\n      pendingDeletes.clear();\n\n      for (DocumentsWriterThreadState threadState : threadStates)\n        try {\n          threadState.consumer.abort();\n        } catch (Throwable t) {\n        }\n\n      try {\n        consumer.abort();\n      } catch (Throwable t) {\n      }\n\n      // Reset all postings data\n      doAfterFlush();\n      success = true;\n    } finally {\n      aborting = false;\n      notifyAll();\n      if (infoStream != null) {\n        message(\"docWriter: done abort; success=\" + success);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3776dccca01c11e7046323cfad46a3b4a471233","date":1306100719,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","sourceNew":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort() throws IOException {\n    boolean success = false;\n\n    synchronized (this) {\n      deleteQueue.clear();\n    }\n\n    try {\n      if (infoStream != null) {\n        message(\"docWriter: abort\");\n      }\n\n      final Iterator<ThreadState> threadsIterator = perThreadPool.getActivePerThreadsIterator();\n\n      while (threadsIterator.hasNext()) {\n        ThreadState perThread = threadsIterator.next();\n        perThread.lock();\n        try {\n          if (perThread.isActive()) { // we might be closed\n            perThread.perThread.abort();\n            perThread.perThread.checkAndResetHasAborted();\n          } else {\n            assert closed;\n          }\n        } finally {\n          perThread.unlock();\n        }\n      }\n\n      success = true;\n    } finally {\n      if (infoStream != null) {\n        message(\"docWriter: done abort; abortedFiles=\" + abortedFiles + \" success=\" + success);\n      }\n    }\n  }\n\n","sourceOld":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort() throws IOException {\n    if (infoStream != null) {\n      message(\"docWriter: abort\");\n    }\n\n    boolean success = false;\n\n    try {\n\n      // Forcefully remove waiting ThreadStates from line\n      waitQueue.abort();\n\n      // Wait for all other threads to finish with\n      // DocumentsWriter:\n      waitIdle();\n\n      if (infoStream != null) {\n        message(\"docWriter: abort waitIdle done\");\n      }\n\n      assert 0 == waitQueue.numWaiting: \"waitQueue.numWaiting=\" + waitQueue.numWaiting;\n\n      waitQueue.waitingBytes = 0;\n\n      pendingDeletes.clear();\n\n      for (DocumentsWriterThreadState threadState : threadStates)\n        try {\n          threadState.consumer.abort();\n        } catch (Throwable t) {\n        }\n\n      try {\n        consumer.abort();\n      } catch (Throwable t) {\n      }\n\n      // Reset all postings data\n      doAfterFlush();\n      success = true;\n    } finally {\n      aborting = false;\n      notifyAll();\n      if (infoStream != null) {\n        message(\"docWriter: done abort; success=\" + success);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"efb7a19703a037c29e30440260d393500febc1f4","date":1306648116,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","sourceNew":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort() throws IOException {\n    boolean success = false;\n\n    synchronized (this) {\n      deleteQueue.clear();\n    }\n\n    try {\n      if (infoStream != null) {\n        message(\"docWriter: abort\");\n      }\n\n      final Iterator<ThreadState> threadsIterator = perThreadPool.getActivePerThreadsIterator();\n      while (threadsIterator.hasNext()) {\n        final ThreadState perThread = threadsIterator.next();\n        perThread.lock();\n        try {\n          if (perThread.isActive()) { // we might be closed\n            try {\n              perThread.perThread.abort();\n            } catch (IOException ex) {\n              // continue\n            } finally {\n              perThread.perThread.checkAndResetHasAborted();\n              flushControl.doOnAbort(perThread);\n            }\n          } else {\n            assert closed;\n          }\n        } finally {\n          perThread.unlock();\n        }\n      }\n      success = true;\n    } finally {\n      if (infoStream != null) {\n        message(\"docWriter: done abort; abortedFiles=\" + abortedFiles + \" success=\" + success);\n      }\n    }\n  }\n\n","sourceOld":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort() throws IOException {\n    boolean success = false;\n\n    synchronized (this) {\n      deleteQueue.clear();\n    }\n\n    try {\n      if (infoStream != null) {\n        message(\"docWriter: abort\");\n      }\n\n      final Iterator<ThreadState> threadsIterator = perThreadPool.getActivePerThreadsIterator();\n\n      while (threadsIterator.hasNext()) {\n        ThreadState perThread = threadsIterator.next();\n        perThread.lock();\n        try {\n          if (perThread.isActive()) { // we might be closed\n            perThread.perThread.abort();\n            perThread.perThread.checkAndResetHasAborted();\n          } else {\n            assert closed;\n          }\n        } finally {\n          perThread.unlock();\n        }\n      }\n\n      success = true;\n    } finally {\n      if (infoStream != null) {\n        message(\"docWriter: done abort; abortedFiles=\" + abortedFiles + \" success=\" + success);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["4d3e8520fd031bab31fd0e4d480e55958bc45efe","4d3e8520fd031bab31fd0e4d480e55958bc45efe","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","date":1306767085,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","sourceNew":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort() throws IOException {\n    boolean success = false;\n\n    synchronized (this) {\n      deleteQueue.clear();\n    }\n\n    try {\n      if (infoStream != null) {\n        message(\"docWriter: abort\");\n      }\n\n      final Iterator<ThreadState> threadsIterator = perThreadPool.getActivePerThreadsIterator();\n      while (threadsIterator.hasNext()) {\n        final ThreadState perThread = threadsIterator.next();\n        perThread.lock();\n        try {\n          if (perThread.isActive()) { // we might be closed\n            try {\n              perThread.perThread.abort();\n            } catch (IOException ex) {\n              // continue\n            } finally {\n              perThread.perThread.checkAndResetHasAborted();\n              flushControl.doOnAbort(perThread);\n            }\n          } else {\n            assert closed;\n          }\n        } finally {\n          perThread.unlock();\n        }\n      }\n      success = true;\n    } finally {\n      if (infoStream != null) {\n        message(\"docWriter: done abort; abortedFiles=\" + abortedFiles + \" success=\" + success);\n      }\n    }\n  }\n\n","sourceOld":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort() throws IOException {\n    boolean success = false;\n\n    synchronized (this) {\n      deleteQueue.clear();\n    }\n\n    try {\n      if (infoStream != null) {\n        message(\"docWriter: abort\");\n      }\n\n      final Iterator<ThreadState> threadsIterator = perThreadPool.getActivePerThreadsIterator();\n\n      while (threadsIterator.hasNext()) {\n        ThreadState perThread = threadsIterator.next();\n        perThread.lock();\n        try {\n          if (perThread.isActive()) { // we might be closed\n            perThread.perThread.abort();\n            perThread.perThread.checkAndResetHasAborted();\n          } else {\n            assert closed;\n          }\n        } finally {\n          perThread.unlock();\n        }\n      }\n\n      success = true;\n    } finally {\n      if (infoStream != null) {\n        message(\"docWriter: done abort; abortedFiles=\" + abortedFiles + \" success=\" + success);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2e10cb22a8bdb44339e282925a29182bb2f3174d","date":1306841137,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","sourceNew":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort() throws IOException {\n    boolean success = false;\n\n    synchronized (this) {\n      deleteQueue.clear();\n    }\n\n    try {\n      if (infoStream != null) {\n        message(\"docWriter: abort\");\n      }\n\n      final Iterator<ThreadState> threadsIterator = perThreadPool.getActivePerThreadsIterator();\n      while (threadsIterator.hasNext()) {\n        final ThreadState perThread = threadsIterator.next();\n        perThread.lock();\n        try {\n          if (perThread.isActive()) { // we might be closed\n            try {\n              perThread.perThread.abort();\n            } catch (IOException ex) {\n              // continue\n            } finally {\n              perThread.perThread.checkAndResetHasAborted();\n              flushControl.doOnAbort(perThread);\n            }\n          } else {\n            assert closed;\n          }\n        } finally {\n          perThread.unlock();\n        }\n      }\n      success = true;\n    } finally {\n      if (infoStream != null) {\n        message(\"docWriter: done abort; abortedFiles=\" + abortedFiles + \" success=\" + success);\n      }\n    }\n  }\n\n","sourceOld":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort() throws IOException {\n    boolean success = false;\n\n    synchronized (this) {\n      deleteQueue.clear();\n    }\n\n    try {\n      if (infoStream != null) {\n        message(\"docWriter: abort\");\n      }\n\n      final Iterator<ThreadState> threadsIterator = perThreadPool.getActivePerThreadsIterator();\n\n      while (threadsIterator.hasNext()) {\n        ThreadState perThread = threadsIterator.next();\n        perThread.lock();\n        try {\n          if (perThread.isActive()) { // we might be closed\n            perThread.perThread.abort();\n            perThread.perThread.checkAndResetHasAborted();\n          } else {\n            assert closed;\n          }\n        } finally {\n          perThread.unlock();\n        }\n      }\n\n      success = true;\n    } finally {\n      if (infoStream != null) {\n        message(\"docWriter: done abort; abortedFiles=\" + abortedFiles + \" success=\" + success);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c00afe74a80796ed1f30a9509b150ff104746a1f","date":1312881735,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","sourceNew":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort() throws IOException {\n    boolean success = false;\n\n    synchronized (this) {\n      deleteQueue.clear();\n    }\n\n    try {\n      if (infoStream != null) {\n        message(\"DW: abort\");\n      }\n\n      final Iterator<ThreadState> threadsIterator = perThreadPool.getActivePerThreadsIterator();\n      while (threadsIterator.hasNext()) {\n        final ThreadState perThread = threadsIterator.next();\n        perThread.lock();\n        try {\n          if (perThread.isActive()) { // we might be closed\n            try {\n              perThread.perThread.abort();\n            } catch (IOException ex) {\n              // continue\n            } finally {\n              perThread.perThread.checkAndResetHasAborted();\n              flushControl.doOnAbort(perThread);\n            }\n          } else {\n            assert closed;\n          }\n        } finally {\n          perThread.unlock();\n        }\n      }\n      success = true;\n    } finally {\n      if (infoStream != null) {\n        message(\"docWriter: done abort; abortedFiles=\" + abortedFiles + \" success=\" + success);\n      }\n    }\n  }\n\n","sourceOld":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort() throws IOException {\n    boolean success = false;\n\n    synchronized (this) {\n      deleteQueue.clear();\n    }\n\n    try {\n      if (infoStream != null) {\n        message(\"docWriter: abort\");\n      }\n\n      final Iterator<ThreadState> threadsIterator = perThreadPool.getActivePerThreadsIterator();\n      while (threadsIterator.hasNext()) {\n        final ThreadState perThread = threadsIterator.next();\n        perThread.lock();\n        try {\n          if (perThread.isActive()) { // we might be closed\n            try {\n              perThread.perThread.abort();\n            } catch (IOException ex) {\n              // continue\n            } finally {\n              perThread.perThread.checkAndResetHasAborted();\n              flushControl.doOnAbort(perThread);\n            }\n          } else {\n            assert closed;\n          }\n        } finally {\n          perThread.unlock();\n        }\n      }\n      success = true;\n    } finally {\n      if (infoStream != null) {\n        message(\"docWriter: done abort; abortedFiles=\" + abortedFiles + \" success=\" + success);\n      }\n    }\n  }\n\n","bugFix":["ff78505662c0b741e2663a9f38a4889c12a32c9f"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"06584e6e98d592b34e1329b384182f368d2025e8","date":1320850353,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","sourceNew":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort() throws IOException {\n    boolean success = false;\n\n    synchronized (this) {\n      deleteQueue.clear();\n    }\n\n    try {\n      if (infoStream != null) {\n        infoStream.message(\"DW\", \"abort\");\n      }\n\n      final Iterator<ThreadState> threadsIterator = perThreadPool.getActivePerThreadsIterator();\n      while (threadsIterator.hasNext()) {\n        final ThreadState perThread = threadsIterator.next();\n        perThread.lock();\n        try {\n          if (perThread.isActive()) { // we might be closed\n            try {\n              perThread.perThread.abort();\n            } catch (IOException ex) {\n              // continue\n            } finally {\n              perThread.perThread.checkAndResetHasAborted();\n              flushControl.doOnAbort(perThread);\n            }\n          } else {\n            assert closed;\n          }\n        } finally {\n          perThread.unlock();\n        }\n      }\n      success = true;\n    } finally {\n      if (infoStream != null) {\n        infoStream.message(\"DW\", \"done abort; abortedFiles=\" + abortedFiles + \" success=\" + success);\n      }\n    }\n  }\n\n","sourceOld":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort() throws IOException {\n    boolean success = false;\n\n    synchronized (this) {\n      deleteQueue.clear();\n    }\n\n    try {\n      if (infoStream != null) {\n        message(\"DW: abort\");\n      }\n\n      final Iterator<ThreadState> threadsIterator = perThreadPool.getActivePerThreadsIterator();\n      while (threadsIterator.hasNext()) {\n        final ThreadState perThread = threadsIterator.next();\n        perThread.lock();\n        try {\n          if (perThread.isActive()) { // we might be closed\n            try {\n              perThread.perThread.abort();\n            } catch (IOException ex) {\n              // continue\n            } finally {\n              perThread.perThread.checkAndResetHasAborted();\n              flushControl.doOnAbort(perThread);\n            }\n          } else {\n            assert closed;\n          }\n        } finally {\n          perThread.unlock();\n        }\n      }\n      success = true;\n    } finally {\n      if (infoStream != null) {\n        message(\"docWriter: done abort; abortedFiles=\" + abortedFiles + \" success=\" + success);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"58c6bbc222f074c844e736e6fb23647e3db9cfe3","date":1322743940,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","sourceNew":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort() throws IOException {\n    boolean success = false;\n\n    synchronized (this) {\n      deleteQueue.clear();\n    }\n\n    try {\n      infoStream.message(\"DW\", \"abort\");\n\n      final Iterator<ThreadState> threadsIterator = perThreadPool.getActivePerThreadsIterator();\n      while (threadsIterator.hasNext()) {\n        final ThreadState perThread = threadsIterator.next();\n        perThread.lock();\n        try {\n          if (perThread.isActive()) { // we might be closed\n            try {\n              perThread.perThread.abort();\n            } catch (IOException ex) {\n              // continue\n            } finally {\n              perThread.perThread.checkAndResetHasAborted();\n              flushControl.doOnAbort(perThread);\n            }\n          } else {\n            assert closed;\n          }\n        } finally {\n          perThread.unlock();\n        }\n      }\n      success = true;\n    } finally {\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"done abort; abortedFiles=\" + abortedFiles + \" success=\" + success);\n      }\n    }\n  }\n\n","sourceOld":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort() throws IOException {\n    boolean success = false;\n\n    synchronized (this) {\n      deleteQueue.clear();\n    }\n\n    try {\n      if (infoStream != null) {\n        infoStream.message(\"DW\", \"abort\");\n      }\n\n      final Iterator<ThreadState> threadsIterator = perThreadPool.getActivePerThreadsIterator();\n      while (threadsIterator.hasNext()) {\n        final ThreadState perThread = threadsIterator.next();\n        perThread.lock();\n        try {\n          if (perThread.isActive()) { // we might be closed\n            try {\n              perThread.perThread.abort();\n            } catch (IOException ex) {\n              // continue\n            } finally {\n              perThread.perThread.checkAndResetHasAborted();\n              flushControl.doOnAbort(perThread);\n            }\n          } else {\n            assert closed;\n          }\n        } finally {\n          perThread.unlock();\n        }\n      }\n      success = true;\n    } finally {\n      if (infoStream != null) {\n        infoStream.message(\"DW\", \"done abort; abortedFiles=\" + abortedFiles + \" success=\" + success);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c5df35ab57c223ea11aec64b53bf611904f3dced","date":1323640545,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","sourceNew":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort() throws IOException {\n    boolean success = false;\n\n    synchronized (this) {\n      deleteQueue.clear();\n    }\n\n    try {\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"abort\");\n      }\n\n      final Iterator<ThreadState> threadsIterator = perThreadPool.getActivePerThreadsIterator();\n      while (threadsIterator.hasNext()) {\n        final ThreadState perThread = threadsIterator.next();\n        perThread.lock();\n        try {\n          if (perThread.isActive()) { // we might be closed\n            try {\n              perThread.perThread.abort();\n            } catch (IOException ex) {\n              // continue\n            } finally {\n              perThread.perThread.checkAndResetHasAborted();\n              flushControl.doOnAbort(perThread);\n            }\n          } else {\n            assert closed;\n          }\n        } finally {\n          perThread.unlock();\n        }\n      }\n      success = true;\n    } finally {\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"done abort; abortedFiles=\" + abortedFiles + \" success=\" + success);\n      }\n    }\n  }\n\n","sourceOld":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort() throws IOException {\n    boolean success = false;\n\n    synchronized (this) {\n      deleteQueue.clear();\n    }\n\n    try {\n      infoStream.message(\"DW\", \"abort\");\n\n      final Iterator<ThreadState> threadsIterator = perThreadPool.getActivePerThreadsIterator();\n      while (threadsIterator.hasNext()) {\n        final ThreadState perThread = threadsIterator.next();\n        perThread.lock();\n        try {\n          if (perThread.isActive()) { // we might be closed\n            try {\n              perThread.perThread.abort();\n            } catch (IOException ex) {\n              // continue\n            } finally {\n              perThread.perThread.checkAndResetHasAborted();\n              flushControl.doOnAbort(perThread);\n            }\n          } else {\n            assert closed;\n          }\n        } finally {\n          perThread.unlock();\n        }\n      }\n      success = true;\n    } finally {\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"done abort; abortedFiles=\" + abortedFiles + \" success=\" + success);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","date":1323720782,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","sourceNew":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort() throws IOException {\n    boolean success = false;\n\n    synchronized (this) {\n      deleteQueue.clear();\n    }\n\n    try {\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"abort\");\n      }\n\n      final Iterator<ThreadState> threadsIterator = perThreadPool.getActivePerThreadsIterator();\n      while (threadsIterator.hasNext()) {\n        final ThreadState perThread = threadsIterator.next();\n        perThread.lock();\n        try {\n          if (perThread.isActive()) { // we might be closed\n            try {\n              perThread.perThread.abort();\n            } catch (IOException ex) {\n              // continue\n            } finally {\n              perThread.perThread.checkAndResetHasAborted();\n              flushControl.doOnAbort(perThread);\n            }\n          } else {\n            assert closed;\n          }\n        } finally {\n          perThread.unlock();\n        }\n      }\n      success = true;\n    } finally {\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"done abort; abortedFiles=\" + abortedFiles + \" success=\" + success);\n      }\n    }\n  }\n\n","sourceOld":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort() throws IOException {\n    boolean success = false;\n\n    synchronized (this) {\n      deleteQueue.clear();\n    }\n\n    try {\n      infoStream.message(\"DW\", \"abort\");\n\n      final Iterator<ThreadState> threadsIterator = perThreadPool.getActivePerThreadsIterator();\n      while (threadsIterator.hasNext()) {\n        final ThreadState perThread = threadsIterator.next();\n        perThread.lock();\n        try {\n          if (perThread.isActive()) { // we might be closed\n            try {\n              perThread.perThread.abort();\n            } catch (IOException ex) {\n              // continue\n            } finally {\n              perThread.perThread.checkAndResetHasAborted();\n              flushControl.doOnAbort(perThread);\n            }\n          } else {\n            assert closed;\n          }\n        } finally {\n          perThread.unlock();\n        }\n      }\n      success = true;\n    } finally {\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"done abort; abortedFiles=\" + abortedFiles + \" success=\" + success);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#abort().mjava","sourceNew":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort() throws IOException {\n    boolean success = false;\n\n    synchronized (this) {\n      deleteQueue.clear();\n    }\n\n    try {\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"abort\");\n      }\n\n      final Iterator<ThreadState> threadsIterator = perThreadPool.getActivePerThreadsIterator();\n      while (threadsIterator.hasNext()) {\n        final ThreadState perThread = threadsIterator.next();\n        perThread.lock();\n        try {\n          if (perThread.isActive()) { // we might be closed\n            try {\n              perThread.perThread.abort();\n            } catch (IOException ex) {\n              // continue\n            } finally {\n              perThread.perThread.checkAndResetHasAborted();\n              flushControl.doOnAbort(perThread);\n            }\n          } else {\n            assert closed;\n          }\n        } finally {\n          perThread.unlock();\n        }\n      }\n      success = true;\n    } finally {\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"done abort; abortedFiles=\" + abortedFiles + \" success=\" + success);\n      }\n    }\n  }\n\n","sourceOld":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  synchronized void abort() throws IOException {\n    boolean success = false;\n\n    synchronized (this) {\n      deleteQueue.clear();\n    }\n\n    try {\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"abort\");\n      }\n\n      final Iterator<ThreadState> threadsIterator = perThreadPool.getActivePerThreadsIterator();\n      while (threadsIterator.hasNext()) {\n        final ThreadState perThread = threadsIterator.next();\n        perThread.lock();\n        try {\n          if (perThread.isActive()) { // we might be closed\n            try {\n              perThread.perThread.abort();\n            } catch (IOException ex) {\n              // continue\n            } finally {\n              perThread.perThread.checkAndResetHasAborted();\n              flushControl.doOnAbort(perThread);\n            }\n          } else {\n            assert closed;\n          }\n        } finally {\n          perThread.unlock();\n        }\n      }\n      success = true;\n    } finally {\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"done abort; abortedFiles=\" + abortedFiles + \" success=\" + success);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"c5df35ab57c223ea11aec64b53bf611904f3dced":["58c6bbc222f074c844e736e6fb23647e3db9cfe3"],"eeb75d1685f27b55c20770200a5a24a8251ce9d5":["ff78505662c0b741e2663a9f38a4889c12a32c9f"],"58c6bbc222f074c844e736e6fb23647e3db9cfe3":["06584e6e98d592b34e1329b384182f368d2025e8"],"44fcbde6fb2ac44ee3b45e013e54a42911e689ff":["2a186ae8733084223c22044e935e4ef848a143d1"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["c5df35ab57c223ea11aec64b53bf611904f3dced"],"efb7a19703a037c29e30440260d393500febc1f4":["b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c":["58c6bbc222f074c844e736e6fb23647e3db9cfe3","c5df35ab57c223ea11aec64b53bf611904f3dced"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["5ef87af8c7bd0f8429622b83aa74202383f2e757","4948bc5d29211f0c9b5ccc31b2632cdd27066ea5"],"c00afe74a80796ed1f30a9509b150ff104746a1f":["efb7a19703a037c29e30440260d393500febc1f4"],"d2ed1b9b7b46829fe3199afe9a8bc203f201b175":["bfaa69f5e3b29a90ec41762bfbfa166a9e52eccf"],"67ed9fd4da5f37b8d0e9f22418cc6eb3dfa26c0f":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":["a3776dccca01c11e7046323cfad46a3b4a471233","efb7a19703a037c29e30440260d393500febc1f4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5ef87af8c7bd0f8429622b83aa74202383f2e757":["8fe956d65251358d755c56f14fe8380644790e47"],"4948bc5d29211f0c9b5ccc31b2632cdd27066ea5":["44fcbde6fb2ac44ee3b45e013e54a42911e689ff"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"2e10cb22a8bdb44339e282925a29182bb2f3174d":["135621f3a0670a9394eb563224a3b76cc4dddc0f","efb7a19703a037c29e30440260d393500febc1f4"],"ff78505662c0b741e2663a9f38a4889c12a32c9f":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"2a186ae8733084223c22044e935e4ef848a143d1":["334c1175813aea771a71728cd2c4ee4754fd0603"],"c498d3f8d75170b121f5eda2c6210ac5beb5d411":["334c1175813aea771a71728cd2c4ee4754fd0603","2a186ae8733084223c22044e935e4ef848a143d1"],"06584e6e98d592b34e1329b384182f368d2025e8":["c00afe74a80796ed1f30a9509b150ff104746a1f"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":["ab5cb6a74aefb78aa0569857970b9151dfe2e787","b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"b3e06be49006ecac364d39d12b9c9f74882f9b9f":["4948bc5d29211f0c9b5ccc31b2632cdd27066ea5","327863a2fd61e831028b6c56c8fef6b00a44eb0b"],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":["c498d3f8d75170b121f5eda2c6210ac5beb5d411","4948bc5d29211f0c9b5ccc31b2632cdd27066ea5"],"334c1175813aea771a71728cd2c4ee4754fd0603":["9b832cbed6eb3d54a8bb9339296bdda8eeb53014"],"327863a2fd61e831028b6c56c8fef6b00a44eb0b":["d2ed1b9b7b46829fe3199afe9a8bc203f201b175"],"9b832cbed6eb3d54a8bb9339296bdda8eeb53014":["67ed9fd4da5f37b8d0e9f22418cc6eb3dfa26c0f"],"a3776dccca01c11e7046323cfad46a3b4a471233":["4948bc5d29211f0c9b5ccc31b2632cdd27066ea5","b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"8fe956d65251358d755c56f14fe8380644790e47":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"bfaa69f5e3b29a90ec41762bfbfa166a9e52eccf":["eeb75d1685f27b55c20770200a5a24a8251ce9d5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"c5df35ab57c223ea11aec64b53bf611904f3dced":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","93ccd971aca7fb61b7f1b946e44714cfc80bfc7c"],"eeb75d1685f27b55c20770200a5a24a8251ce9d5":["bfaa69f5e3b29a90ec41762bfbfa166a9e52eccf"],"58c6bbc222f074c844e736e6fb23647e3db9cfe3":["c5df35ab57c223ea11aec64b53bf611904f3dced","93ccd971aca7fb61b7f1b946e44714cfc80bfc7c"],"44fcbde6fb2ac44ee3b45e013e54a42911e689ff":["4948bc5d29211f0c9b5ccc31b2632cdd27066ea5"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"efb7a19703a037c29e30440260d393500febc1f4":["c00afe74a80796ed1f30a9509b150ff104746a1f","5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","2e10cb22a8bdb44339e282925a29182bb2f3174d"],"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c":[],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["ff78505662c0b741e2663a9f38a4889c12a32c9f"],"c00afe74a80796ed1f30a9509b150ff104746a1f":["06584e6e98d592b34e1329b384182f368d2025e8"],"d2ed1b9b7b46829fe3199afe9a8bc203f201b175":["327863a2fd61e831028b6c56c8fef6b00a44eb0b"],"67ed9fd4da5f37b8d0e9f22418cc6eb3dfa26c0f":["9b832cbed6eb3d54a8bb9339296bdda8eeb53014"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"5ef87af8c7bd0f8429622b83aa74202383f2e757":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"4948bc5d29211f0c9b5ccc31b2632cdd27066ea5":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","b3e06be49006ecac364d39d12b9c9f74882f9b9f","ab5cb6a74aefb78aa0569857970b9151dfe2e787","a3776dccca01c11e7046323cfad46a3b4a471233"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["67ed9fd4da5f37b8d0e9f22418cc6eb3dfa26c0f","8fe956d65251358d755c56f14fe8380644790e47"],"2e10cb22a8bdb44339e282925a29182bb2f3174d":[],"ff78505662c0b741e2663a9f38a4889c12a32c9f":["eeb75d1685f27b55c20770200a5a24a8251ce9d5"],"2a186ae8733084223c22044e935e4ef848a143d1":["44fcbde6fb2ac44ee3b45e013e54a42911e689ff","c498d3f8d75170b121f5eda2c6210ac5beb5d411"],"c498d3f8d75170b121f5eda2c6210ac5beb5d411":["ab5cb6a74aefb78aa0569857970b9151dfe2e787"],"06584e6e98d592b34e1329b384182f368d2025e8":["58c6bbc222f074c844e736e6fb23647e3db9cfe3"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":["2e10cb22a8bdb44339e282925a29182bb2f3174d"],"b3e06be49006ecac364d39d12b9c9f74882f9b9f":["efb7a19703a037c29e30440260d393500febc1f4","135621f3a0670a9394eb563224a3b76cc4dddc0f","a3776dccca01c11e7046323cfad46a3b4a471233"],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":["135621f3a0670a9394eb563224a3b76cc4dddc0f"],"334c1175813aea771a71728cd2c4ee4754fd0603":["2a186ae8733084223c22044e935e4ef848a143d1","c498d3f8d75170b121f5eda2c6210ac5beb5d411"],"327863a2fd61e831028b6c56c8fef6b00a44eb0b":["b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"9b832cbed6eb3d54a8bb9339296bdda8eeb53014":["334c1175813aea771a71728cd2c4ee4754fd0603"],"a3776dccca01c11e7046323cfad46a3b4a471233":["5128b7b3b73fedff05fdc5ea2e6be53c1020bb91"],"8fe956d65251358d755c56f14fe8380644790e47":["5ef87af8c7bd0f8429622b83aa74202383f2e757"],"bfaa69f5e3b29a90ec41762bfbfa166a9e52eccf":["d2ed1b9b7b46829fe3199afe9a8bc203f201b175"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","2e10cb22a8bdb44339e282925a29182bb2f3174d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}