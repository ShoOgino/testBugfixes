{"path":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","sourceNew":"  public void checkDistributed(ResponseBuilder rb) {\r\n    SolrQueryRequest req = rb.req;\r\n    SolrParams params = req.getParams();\r\n\r\n    rb.isDistrib = params.getBool(\"distrib\",false);\r\n    String shards = params.get(ShardParams.SHARDS);\r\n\r\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\r\n    // search is distributed.\r\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\r\n    rb.isDistrib = hasShardURL | rb.isDistrib;\r\n\r\n    if (rb.isDistrib) {\r\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\r\n      // if we need it.\r\n      CloudState cloudState = null;\r\n      Map<String,Slice> slices = null;\r\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\r\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\r\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\r\n\r\n\r\n      if (shards != null) {\r\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\r\n        rb.shards = lst.toArray(new String[lst.size()]);\r\n        rb.slices = new String[rb.shards.length];\r\n\r\n        if (zkController != null) {\r\n          // figure out which shards are slices\r\n          for (int i=0; i<rb.shards.length; i++) {\r\n            if (rb.shards[i].indexOf('/') < 0) {\r\n              // this is a logical shard\r\n              rb.slices[i] = rb.shards[i];\r\n              rb.shards[i] = null;\r\n            }\r\n          }\r\n        }\r\n      } else if (zkController != null) {\r\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\r\n\r\n        cloudState =  zkController.getCloudState();\r\n\r\n        // TODO: check \"collection\" for which collection(s) to search.. but for now, just default\r\n        // to the collection for this core.\r\n        // This can be more efficient... we only record the name, even though we have the\r\n        // shard info we need in the next step of mapping slice->shards\r\n        slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\r\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\r\n        rb.shards = new String[rb.slices.length];\r\n\r\n        /***\r\n         rb.slices = new String[slices.size()];\r\n         for (int i=0; i<rb.slices.length; i++) {\r\n         rb.slices[i] = slices.get(i).getName();\r\n         }\r\n         ***/\r\n      }\r\n\r\n      //\r\n      // Map slices to shards\r\n      //\r\n      if (zkController != null) {\r\n        for (int i=0; i<rb.shards.length; i++) {\r\n          if (rb.shards[i] == null) {\r\n            if (cloudState == null) {\r\n              cloudState =  zkController.getCloudState();\r\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\r\n            }\r\n            String sliceName = rb.slices[i];\r\n\r\n            Slice slice = slices.get(sliceName);\r\n\r\n            if (slice==null) {\r\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\r\n              // if partial results are acceptable\r\n              rb.shards[i] = \"\";\r\n              continue;\r\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\r\n            }\r\n\r\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\r\n\r\n            // For now, recreate the | delimited list of equivalent servers\r\n            Set<String> liveNodes = cloudState.getLiveNodes();\r\n            StringBuilder sliceShardsStr = new StringBuilder();\r\n            boolean first = true;\r\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\r\n              if (!liveNodes.contains(nodeProps.get(ZkStateReader.NODE_NAME)))\r\n                continue;\r\n              if (first) {\r\n                first = false;\r\n              } else {\r\n                sliceShardsStr.append('|');\r\n              }\r\n              String url = nodeProps.get(\"url\");\r\n              if (url.startsWith(\"http://\"))\r\n                url = url.substring(7);\r\n              sliceShardsStr.append(url);\r\n            }\r\n\r\n            rb.shards[i] = sliceShardsStr.toString();\r\n          }\r\n        }\r\n      }\r\n    }\r\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\r\n    if(shards_rows != null) {\r\n      rb.shards_rows = Integer.parseInt(shards_rows);\r\n    }\r\n    String shards_start = params.get(ShardParams.SHARDS_START);\r\n    if(shards_start != null) {\r\n      rb.shards_start = Integer.parseInt(shards_start);\r\n    }\r\n  }\r\n\n","sourceOld":"  public void checkDistributed(ResponseBuilder rb) {\r\n    SolrQueryRequest req = rb.req;\r\n    SolrParams params = req.getParams();\r\n\r\n    rb.isDistrib = params.getBool(\"distrib\",false);\r\n    String shards = params.get(ShardParams.SHARDS);\r\n\r\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\r\n    // search is distributed.\r\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\r\n    rb.isDistrib = hasShardURL | rb.isDistrib;\r\n\r\n    if (rb.isDistrib) {\r\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\r\n      // if we need it.\r\n      CloudState cloudState = null;\r\n      Map<String,Slice> slices = null;\r\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\r\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\r\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\r\n\r\n\r\n      if (shards != null) {\r\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\r\n        rb.shards = lst.toArray(new String[lst.size()]);\r\n        rb.slices = new String[rb.shards.length];\r\n\r\n        if (zkController != null) {\r\n          // figure out which shards are slices\r\n          for (int i=0; i<rb.shards.length; i++) {\r\n            if (rb.shards[i].indexOf('/') < 0) {\r\n              // this is a logical shard\r\n              rb.slices[i] = rb.shards[i];\r\n              rb.shards[i] = null;\r\n            }\r\n          }\r\n        }\r\n      } else if (zkController != null) {\r\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\r\n\r\n        cloudState =  zkController.getCloudState();\r\n\r\n        // TODO: check \"collection\" for which collection(s) to search.. but for now, just default\r\n        // to the collection for this core.\r\n        // This can be more efficient... we only record the name, even though we have the\r\n        // shard info we need in the next step of mapping slice->shards\r\n        slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\r\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\r\n        rb.shards = new String[rb.slices.length];\r\n\r\n        /***\r\n         rb.slices = new String[slices.size()];\r\n         for (int i=0; i<rb.slices.length; i++) {\r\n         rb.slices[i] = slices.get(i).getName();\r\n         }\r\n         ***/\r\n      }\r\n\r\n      //\r\n      // Map slices to shards\r\n      //\r\n      if (zkController != null) {\r\n        for (int i=0; i<rb.shards.length; i++) {\r\n          if (rb.shards[i] == null) {\r\n            if (cloudState == null) {\r\n              cloudState =  zkController.getCloudState();\r\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\r\n            }\r\n            String sliceName = rb.slices[i];\r\n\r\n            Slice slice = slices.get(sliceName);\r\n\r\n            if (slice==null) {\r\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\r\n              // if partial results are acceptable\r\n              rb.shards[i] = \"\";\r\n              continue;\r\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\r\n            }\r\n\r\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\r\n\r\n            // For now, recreate the | delimited list of equivalent servers\r\n            Set<String> liveNodes = cloudState.getLiveNodes();\r\n            StringBuilder sliceShardsStr = new StringBuilder();\r\n            boolean first = true;\r\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\r\n              if (!liveNodes.contains(nodeProps.get(ZkStateReader.NODE_NAME)))\r\n                continue;\r\n              if (first) {\r\n                first = false;\r\n              } else {\r\n                sliceShardsStr.append('|');\r\n              }\r\n              String url = nodeProps.get(\"url\");\r\n              if (url.startsWith(\"http://\"))\r\n                url = url.substring(7);\r\n              sliceShardsStr.append(url);\r\n            }\r\n\r\n            rb.shards[i] = sliceShardsStr.toString();\r\n          }\r\n        }\r\n      }\r\n    }\r\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\r\n    if(shards_rows != null) {\r\n      rb.shards_rows = Integer.parseInt(shards_rows);\r\n    }\r\n    String shards_start = params.get(ShardParams.SHARDS_START);\r\n    if(shards_start != null) {\r\n      rb.shards_start = Integer.parseInt(shards_start);\r\n    }\r\n  }\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","sourceNew":"  public void checkDistributed(ResponseBuilder rb) {\r\n    SolrQueryRequest req = rb.req;\r\n    SolrParams params = req.getParams();\r\n\r\n    rb.isDistrib = params.getBool(\"distrib\",false);\r\n    String shards = params.get(ShardParams.SHARDS);\r\n\r\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\r\n    // search is distributed.\r\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\r\n    rb.isDistrib = hasShardURL | rb.isDistrib;\r\n\r\n    if (rb.isDistrib) {\r\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\r\n      // if we need it.\r\n      CloudState cloudState = null;\r\n      Map<String,Slice> slices = null;\r\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\r\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\r\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\r\n\r\n\r\n      if (shards != null) {\r\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\r\n        rb.shards = lst.toArray(new String[lst.size()]);\r\n        rb.slices = new String[rb.shards.length];\r\n\r\n        if (zkController != null) {\r\n          // figure out which shards are slices\r\n          for (int i=0; i<rb.shards.length; i++) {\r\n            if (rb.shards[i].indexOf('/') < 0) {\r\n              // this is a logical shard\r\n              rb.slices[i] = rb.shards[i];\r\n              rb.shards[i] = null;\r\n            }\r\n          }\r\n        }\r\n      } else if (zkController != null) {\r\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\r\n\r\n        cloudState =  zkController.getCloudState();\r\n\r\n        // TODO: check \"collection\" for which collection(s) to search.. but for now, just default\r\n        // to the collection for this core.\r\n        // This can be more efficient... we only record the name, even though we have the\r\n        // shard info we need in the next step of mapping slice->shards\r\n        slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\r\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\r\n        rb.shards = new String[rb.slices.length];\r\n\r\n        /***\r\n         rb.slices = new String[slices.size()];\r\n         for (int i=0; i<rb.slices.length; i++) {\r\n         rb.slices[i] = slices.get(i).getName();\r\n         }\r\n         ***/\r\n      }\r\n\r\n      //\r\n      // Map slices to shards\r\n      //\r\n      if (zkController != null) {\r\n        for (int i=0; i<rb.shards.length; i++) {\r\n          if (rb.shards[i] == null) {\r\n            if (cloudState == null) {\r\n              cloudState =  zkController.getCloudState();\r\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\r\n            }\r\n            String sliceName = rb.slices[i];\r\n\r\n            Slice slice = slices.get(sliceName);\r\n\r\n            if (slice==null) {\r\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\r\n              // if partial results are acceptable\r\n              rb.shards[i] = \"\";\r\n              continue;\r\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\r\n            }\r\n\r\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\r\n\r\n            // For now, recreate the | delimited list of equivalent servers\r\n            Set<String> liveNodes = cloudState.getLiveNodes();\r\n            StringBuilder sliceShardsStr = new StringBuilder();\r\n            boolean first = true;\r\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\r\n              if (!liveNodes.contains(nodeProps.get(ZkStateReader.NODE_NAME)))\r\n                continue;\r\n              if (first) {\r\n                first = false;\r\n              } else {\r\n                sliceShardsStr.append('|');\r\n              }\r\n              String url = nodeProps.get(\"url\");\r\n              if (url.startsWith(\"http://\"))\r\n                url = url.substring(7);\r\n              sliceShardsStr.append(url);\r\n            }\r\n\r\n            rb.shards[i] = sliceShardsStr.toString();\r\n          }\r\n        }\r\n      }\r\n    }\r\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\r\n    if(shards_rows != null) {\r\n      rb.shards_rows = Integer.parseInt(shards_rows);\r\n    }\r\n    String shards_start = params.get(ShardParams.SHARDS_START);\r\n    if(shards_start != null) {\r\n      rb.shards_start = Integer.parseInt(shards_start);\r\n    }\r\n  }\r\n\n","sourceOld":"  public void checkDistributed(ResponseBuilder rb) {\r\n    SolrQueryRequest req = rb.req;\r\n    SolrParams params = req.getParams();\r\n\r\n    rb.isDistrib = params.getBool(\"distrib\",false);\r\n    String shards = params.get(ShardParams.SHARDS);\r\n\r\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\r\n    // search is distributed.\r\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\r\n    rb.isDistrib = hasShardURL | rb.isDistrib;\r\n\r\n    if (rb.isDistrib) {\r\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\r\n      // if we need it.\r\n      CloudState cloudState = null;\r\n      Map<String,Slice> slices = null;\r\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\r\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\r\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\r\n\r\n\r\n      if (shards != null) {\r\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\r\n        rb.shards = lst.toArray(new String[lst.size()]);\r\n        rb.slices = new String[rb.shards.length];\r\n\r\n        if (zkController != null) {\r\n          // figure out which shards are slices\r\n          for (int i=0; i<rb.shards.length; i++) {\r\n            if (rb.shards[i].indexOf('/') < 0) {\r\n              // this is a logical shard\r\n              rb.slices[i] = rb.shards[i];\r\n              rb.shards[i] = null;\r\n            }\r\n          }\r\n        }\r\n      } else if (zkController != null) {\r\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\r\n\r\n        cloudState =  zkController.getCloudState();\r\n\r\n        // TODO: check \"collection\" for which collection(s) to search.. but for now, just default\r\n        // to the collection for this core.\r\n        // This can be more efficient... we only record the name, even though we have the\r\n        // shard info we need in the next step of mapping slice->shards\r\n        slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\r\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\r\n        rb.shards = new String[rb.slices.length];\r\n\r\n        /***\r\n         rb.slices = new String[slices.size()];\r\n         for (int i=0; i<rb.slices.length; i++) {\r\n         rb.slices[i] = slices.get(i).getName();\r\n         }\r\n         ***/\r\n      }\r\n\r\n      //\r\n      // Map slices to shards\r\n      //\r\n      if (zkController != null) {\r\n        for (int i=0; i<rb.shards.length; i++) {\r\n          if (rb.shards[i] == null) {\r\n            if (cloudState == null) {\r\n              cloudState =  zkController.getCloudState();\r\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\r\n            }\r\n            String sliceName = rb.slices[i];\r\n\r\n            Slice slice = slices.get(sliceName);\r\n\r\n            if (slice==null) {\r\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\r\n              // if partial results are acceptable\r\n              rb.shards[i] = \"\";\r\n              continue;\r\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\r\n            }\r\n\r\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\r\n\r\n            // For now, recreate the | delimited list of equivalent servers\r\n            Set<String> liveNodes = cloudState.getLiveNodes();\r\n            StringBuilder sliceShardsStr = new StringBuilder();\r\n            boolean first = true;\r\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\r\n              if (!liveNodes.contains(nodeProps.get(ZkStateReader.NODE_NAME)))\r\n                continue;\r\n              if (first) {\r\n                first = false;\r\n              } else {\r\n                sliceShardsStr.append('|');\r\n              }\r\n              String url = nodeProps.get(\"url\");\r\n              if (url.startsWith(\"http://\"))\r\n                url = url.substring(7);\r\n              sliceShardsStr.append(url);\r\n            }\r\n\r\n            rb.shards[i] = sliceShardsStr.toString();\r\n          }\r\n        }\r\n      }\r\n    }\r\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\r\n    if(shards_rows != null) {\r\n      rb.shards_rows = Integer.parseInt(shards_rows);\r\n    }\r\n    String shards_start = params.get(ShardParams.SHARDS_START);\r\n    if(shards_start != null) {\r\n      rb.shards_start = Integer.parseInt(shards_start);\r\n    }\r\n  }\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","sourceNew":"  public void checkDistributed(ResponseBuilder rb) {\r\n    SolrQueryRequest req = rb.req;\r\n    SolrParams params = req.getParams();\r\n\r\n    rb.isDistrib = params.getBool(\"distrib\",false);\r\n    String shards = params.get(ShardParams.SHARDS);\r\n\r\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\r\n    // search is distributed.\r\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\r\n    rb.isDistrib = hasShardURL | rb.isDistrib;\r\n\r\n    if (rb.isDistrib) {\r\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\r\n      // if we need it.\r\n      CloudState cloudState = null;\r\n      Map<String,Slice> slices = null;\r\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\r\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\r\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\r\n\r\n\r\n      if (shards != null) {\r\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\r\n        rb.shards = lst.toArray(new String[lst.size()]);\r\n        rb.slices = new String[rb.shards.length];\r\n\r\n        if (zkController != null) {\r\n          // figure out which shards are slices\r\n          for (int i=0; i<rb.shards.length; i++) {\r\n            if (rb.shards[i].indexOf('/') < 0) {\r\n              // this is a logical shard\r\n              rb.slices[i] = rb.shards[i];\r\n              rb.shards[i] = null;\r\n            }\r\n          }\r\n        }\r\n      } else if (zkController != null) {\r\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\r\n\r\n        cloudState =  zkController.getCloudState();\r\n\r\n        // TODO: check \"collection\" for which collection(s) to search.. but for now, just default\r\n        // to the collection for this core.\r\n        // This can be more efficient... we only record the name, even though we have the\r\n        // shard info we need in the next step of mapping slice->shards\r\n        slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\r\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\r\n        rb.shards = new String[rb.slices.length];\r\n\r\n        /***\r\n         rb.slices = new String[slices.size()];\r\n         for (int i=0; i<rb.slices.length; i++) {\r\n         rb.slices[i] = slices.get(i).getName();\r\n         }\r\n         ***/\r\n      }\r\n\r\n      //\r\n      // Map slices to shards\r\n      //\r\n      if (zkController != null) {\r\n        for (int i=0; i<rb.shards.length; i++) {\r\n          if (rb.shards[i] == null) {\r\n            if (cloudState == null) {\r\n              cloudState =  zkController.getCloudState();\r\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\r\n            }\r\n            String sliceName = rb.slices[i];\r\n\r\n            Slice slice = slices.get(sliceName);\r\n\r\n            if (slice==null) {\r\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\r\n              // if partial results are acceptable\r\n              rb.shards[i] = \"\";\r\n              continue;\r\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\r\n            }\r\n\r\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\r\n\r\n            // For now, recreate the | delimited list of equivalent servers\r\n            Set<String> liveNodes = cloudState.getLiveNodes();\r\n            StringBuilder sliceShardsStr = new StringBuilder();\r\n            boolean first = true;\r\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\r\n              if (!liveNodes.contains(nodeProps.get(ZkStateReader.NODE_NAME)))\r\n                continue;\r\n              if (first) {\r\n                first = false;\r\n              } else {\r\n                sliceShardsStr.append('|');\r\n              }\r\n              String url = nodeProps.get(\"url\");\r\n              if (url.startsWith(\"http://\"))\r\n                url = url.substring(7);\r\n              sliceShardsStr.append(url);\r\n            }\r\n\r\n            rb.shards[i] = sliceShardsStr.toString();\r\n          }\r\n        }\r\n      }\r\n    }\r\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\r\n    if(shards_rows != null) {\r\n      rb.shards_rows = Integer.parseInt(shards_rows);\r\n    }\r\n    String shards_start = params.get(ShardParams.SHARDS_START);\r\n    if(shards_start != null) {\r\n      rb.shards_start = Integer.parseInt(shards_start);\r\n    }\r\n  }\r\n\n","sourceOld":"  public void checkDistributed(ResponseBuilder rb) {\r\n    SolrQueryRequest req = rb.req;\r\n    SolrParams params = req.getParams();\r\n\r\n    rb.isDistrib = params.getBool(\"distrib\",false);\r\n    String shards = params.get(ShardParams.SHARDS);\r\n\r\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\r\n    // search is distributed.\r\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\r\n    rb.isDistrib = hasShardURL | rb.isDistrib;\r\n\r\n    if (rb.isDistrib) {\r\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\r\n      // if we need it.\r\n      CloudState cloudState = null;\r\n      Map<String,Slice> slices = null;\r\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\r\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\r\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\r\n\r\n\r\n      if (shards != null) {\r\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\r\n        rb.shards = lst.toArray(new String[lst.size()]);\r\n        rb.slices = new String[rb.shards.length];\r\n\r\n        if (zkController != null) {\r\n          // figure out which shards are slices\r\n          for (int i=0; i<rb.shards.length; i++) {\r\n            if (rb.shards[i].indexOf('/') < 0) {\r\n              // this is a logical shard\r\n              rb.slices[i] = rb.shards[i];\r\n              rb.shards[i] = null;\r\n            }\r\n          }\r\n        }\r\n      } else if (zkController != null) {\r\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\r\n\r\n        cloudState =  zkController.getCloudState();\r\n\r\n        // TODO: check \"collection\" for which collection(s) to search.. but for now, just default\r\n        // to the collection for this core.\r\n        // This can be more efficient... we only record the name, even though we have the\r\n        // shard info we need in the next step of mapping slice->shards\r\n        slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\r\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\r\n        rb.shards = new String[rb.slices.length];\r\n\r\n        /***\r\n         rb.slices = new String[slices.size()];\r\n         for (int i=0; i<rb.slices.length; i++) {\r\n         rb.slices[i] = slices.get(i).getName();\r\n         }\r\n         ***/\r\n      }\r\n\r\n      //\r\n      // Map slices to shards\r\n      //\r\n      if (zkController != null) {\r\n        for (int i=0; i<rb.shards.length; i++) {\r\n          if (rb.shards[i] == null) {\r\n            if (cloudState == null) {\r\n              cloudState =  zkController.getCloudState();\r\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\r\n            }\r\n            String sliceName = rb.slices[i];\r\n\r\n            Slice slice = slices.get(sliceName);\r\n\r\n            if (slice==null) {\r\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\r\n              // if partial results are acceptable\r\n              rb.shards[i] = \"\";\r\n              continue;\r\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\r\n            }\r\n\r\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\r\n\r\n            // For now, recreate the | delimited list of equivalent servers\r\n            Set<String> liveNodes = cloudState.getLiveNodes();\r\n            StringBuilder sliceShardsStr = new StringBuilder();\r\n            boolean first = true;\r\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\r\n              if (!liveNodes.contains(nodeProps.get(ZkStateReader.NODE_NAME)))\r\n                continue;\r\n              if (first) {\r\n                first = false;\r\n              } else {\r\n                sliceShardsStr.append('|');\r\n              }\r\n              String url = nodeProps.get(\"url\");\r\n              if (url.startsWith(\"http://\"))\r\n                url = url.substring(7);\r\n              sliceShardsStr.append(url);\r\n            }\r\n\r\n            rb.shards[i] = sliceShardsStr.toString();\r\n          }\r\n        }\r\n      }\r\n    }\r\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\r\n    if(shards_rows != null) {\r\n      rb.shards_rows = Integer.parseInt(shards_rows);\r\n    }\r\n    String shards_start = params.get(ShardParams.SHARDS_START);\r\n    if(shards_start != null) {\r\n      rb.shards_start = Integer.parseInt(shards_start);\r\n    }\r\n  }\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2c007e7c4cf8c55bc2a5884e315123afaaeec87f","date":1327520966,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","sourceNew":"  public void checkDistributed(ResponseBuilder rb) {\r\n    SolrQueryRequest req = rb.req;\r\n    SolrParams params = req.getParams();\r\n\r\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\r\n        .getCoreContainer().isZooKeeperAware());\r\n    String shards = params.get(ShardParams.SHARDS);\r\n\r\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\r\n    // search is distributed.\r\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\r\n    rb.isDistrib = hasShardURL | rb.isDistrib;\r\n\r\n    if (rb.isDistrib) {\r\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\r\n      // if we need it.\r\n      CloudState cloudState = null;\r\n      Map<String,Slice> slices = null;\r\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\r\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\r\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\r\n\r\n\r\n      if (shards != null) {\r\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\r\n        rb.shards = lst.toArray(new String[lst.size()]);\r\n        rb.slices = new String[rb.shards.length];\r\n\r\n        if (zkController != null) {\r\n          // figure out which shards are slices\r\n          for (int i=0; i<rb.shards.length; i++) {\r\n            if (rb.shards[i].indexOf('/') < 0) {\r\n              // this is a logical shard\r\n              rb.slices[i] = rb.shards[i];\r\n              rb.shards[i] = null;\r\n            }\r\n          }\r\n        }\r\n      } else if (zkController != null) {\r\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\r\n\r\n        cloudState =  zkController.getCloudState();\r\n\r\n        // This can be more efficient... we only record the name, even though we\r\n        // have the shard info we need in the next step of mapping slice->shards\r\n        \r\n        // Stores the comma-separated list of specified collections.\r\n        // Eg: \"collection1,collection2,collection3\"\r\n        String collections = params.get(\"collection\");\r\n        if (collections != null) {\r\n          // If there were one or more collections specified in the query, split\r\n          // each parameter and store as a seperate member of a List.\r\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\r\n              true);\r\n          \r\n          // First create an empty HashMap to add the slice info to.\r\n          slices = new HashMap<String,Slice>();\r\n          \r\n          // In turn, retrieve the slices that cover each collection from the\r\n          // cloud state and add them to the Map 'slices'.\r\n          for (int i = 0; i < collectionList.size(); i++) {\r\n            String collection = collectionList.get(i);\r\n            ClientUtils.appendMap(collection, slices, cloudState.getSlices(collection));\r\n          }\r\n        } else {\r\n          // If no collections were specified, default to the collection for\r\n          // this core.\r\n          slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\r\n        }\r\n        \r\n        // Store the logical slices in the ResponseBuilder and create a new\r\n        // String array to hold the physical shards (which will be mapped\r\n        // later).\r\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\r\n        rb.shards = new String[rb.slices.length];\r\n\r\n        /***\r\n         rb.slices = new String[slices.size()];\r\n         for (int i=0; i<rb.slices.length; i++) {\r\n         rb.slices[i] = slices.get(i).getName();\r\n         }\r\n         ***/\r\n      }\r\n\r\n      //\r\n      // Map slices to shards\r\n      //\r\n      if (zkController != null) {\r\n        for (int i=0; i<rb.shards.length; i++) {\r\n          if (rb.shards[i] == null) {\r\n            if (cloudState == null) {\r\n              cloudState =  zkController.getCloudState();\r\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\r\n            }\r\n            String sliceName = rb.slices[i];\r\n\r\n            Slice slice = slices.get(sliceName);\r\n\r\n            if (slice==null) {\r\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\r\n              // if partial results are acceptable\r\n              rb.shards[i] = \"\";\r\n              continue;\r\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\r\n            }\r\n\r\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\r\n\r\n            // For now, recreate the | delimited list of equivalent servers\r\n            Set<String> liveNodes = cloudState.getLiveNodes();\r\n            StringBuilder sliceShardsStr = new StringBuilder();\r\n            boolean first = true;\r\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\r\n              ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\r\n              if (!liveNodes.contains(coreNodeProps.getNodeName())\r\n                  || !coreNodeProps.getState().equals(\r\n                      ZkStateReader.ACTIVE)) continue;\r\n              if (first) {\r\n                first = false;\r\n              } else {\r\n                sliceShardsStr.append('|');\r\n              }\r\n              String url = coreNodeProps.getCoreUrl();\r\n              if (url.startsWith(\"http://\"))\r\n                url = url.substring(7);\r\n              sliceShardsStr.append(url);\r\n            }\r\n\r\n            rb.shards[i] = sliceShardsStr.toString();\r\n          }\r\n        }\r\n      }\r\n    }\r\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\r\n    if(shards_rows != null) {\r\n      rb.shards_rows = Integer.parseInt(shards_rows);\r\n    }\r\n    String shards_start = params.get(ShardParams.SHARDS_START);\r\n    if(shards_start != null) {\r\n      rb.shards_start = Integer.parseInt(shards_start);\r\n    }\r\n  }\r\n\n","sourceOld":"  public void checkDistributed(ResponseBuilder rb) {\r\n    SolrQueryRequest req = rb.req;\r\n    SolrParams params = req.getParams();\r\n\r\n    rb.isDistrib = params.getBool(\"distrib\",false);\r\n    String shards = params.get(ShardParams.SHARDS);\r\n\r\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\r\n    // search is distributed.\r\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\r\n    rb.isDistrib = hasShardURL | rb.isDistrib;\r\n\r\n    if (rb.isDistrib) {\r\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\r\n      // if we need it.\r\n      CloudState cloudState = null;\r\n      Map<String,Slice> slices = null;\r\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\r\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\r\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\r\n\r\n\r\n      if (shards != null) {\r\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\r\n        rb.shards = lst.toArray(new String[lst.size()]);\r\n        rb.slices = new String[rb.shards.length];\r\n\r\n        if (zkController != null) {\r\n          // figure out which shards are slices\r\n          for (int i=0; i<rb.shards.length; i++) {\r\n            if (rb.shards[i].indexOf('/') < 0) {\r\n              // this is a logical shard\r\n              rb.slices[i] = rb.shards[i];\r\n              rb.shards[i] = null;\r\n            }\r\n          }\r\n        }\r\n      } else if (zkController != null) {\r\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\r\n\r\n        cloudState =  zkController.getCloudState();\r\n\r\n        // TODO: check \"collection\" for which collection(s) to search.. but for now, just default\r\n        // to the collection for this core.\r\n        // This can be more efficient... we only record the name, even though we have the\r\n        // shard info we need in the next step of mapping slice->shards\r\n        slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\r\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\r\n        rb.shards = new String[rb.slices.length];\r\n\r\n        /***\r\n         rb.slices = new String[slices.size()];\r\n         for (int i=0; i<rb.slices.length; i++) {\r\n         rb.slices[i] = slices.get(i).getName();\r\n         }\r\n         ***/\r\n      }\r\n\r\n      //\r\n      // Map slices to shards\r\n      //\r\n      if (zkController != null) {\r\n        for (int i=0; i<rb.shards.length; i++) {\r\n          if (rb.shards[i] == null) {\r\n            if (cloudState == null) {\r\n              cloudState =  zkController.getCloudState();\r\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\r\n            }\r\n            String sliceName = rb.slices[i];\r\n\r\n            Slice slice = slices.get(sliceName);\r\n\r\n            if (slice==null) {\r\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\r\n              // if partial results are acceptable\r\n              rb.shards[i] = \"\";\r\n              continue;\r\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\r\n            }\r\n\r\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\r\n\r\n            // For now, recreate the | delimited list of equivalent servers\r\n            Set<String> liveNodes = cloudState.getLiveNodes();\r\n            StringBuilder sliceShardsStr = new StringBuilder();\r\n            boolean first = true;\r\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\r\n              if (!liveNodes.contains(nodeProps.get(ZkStateReader.NODE_NAME)))\r\n                continue;\r\n              if (first) {\r\n                first = false;\r\n              } else {\r\n                sliceShardsStr.append('|');\r\n              }\r\n              String url = nodeProps.get(\"url\");\r\n              if (url.startsWith(\"http://\"))\r\n                url = url.substring(7);\r\n              sliceShardsStr.append(url);\r\n            }\r\n\r\n            rb.shards[i] = sliceShardsStr.toString();\r\n          }\r\n        }\r\n      }\r\n    }\r\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\r\n    if(shards_rows != null) {\r\n      rb.shards_rows = Integer.parseInt(shards_rows);\r\n    }\r\n    String shards_start = params.get(ShardParams.SHARDS_START);\r\n    if(shards_start != null) {\r\n      rb.shards_start = Integer.parseInt(shards_start);\r\n    }\r\n  }\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","sourceNew":"  public void checkDistributed(ResponseBuilder rb) {\r\n    SolrQueryRequest req = rb.req;\r\n    SolrParams params = req.getParams();\r\n\r\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\r\n        .getCoreContainer().isZooKeeperAware());\r\n    String shards = params.get(ShardParams.SHARDS);\r\n\r\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\r\n    // search is distributed.\r\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\r\n    rb.isDistrib = hasShardURL | rb.isDistrib;\r\n\r\n    if (rb.isDistrib) {\r\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\r\n      // if we need it.\r\n      CloudState cloudState = null;\r\n      Map<String,Slice> slices = null;\r\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\r\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\r\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\r\n\r\n\r\n      if (shards != null) {\r\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\r\n        rb.shards = lst.toArray(new String[lst.size()]);\r\n        rb.slices = new String[rb.shards.length];\r\n\r\n        if (zkController != null) {\r\n          // figure out which shards are slices\r\n          for (int i=0; i<rb.shards.length; i++) {\r\n            if (rb.shards[i].indexOf('/') < 0) {\r\n              // this is a logical shard\r\n              rb.slices[i] = rb.shards[i];\r\n              rb.shards[i] = null;\r\n            }\r\n          }\r\n        }\r\n      } else if (zkController != null) {\r\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\r\n\r\n        cloudState =  zkController.getCloudState();\r\n\r\n        // This can be more efficient... we only record the name, even though we\r\n        // have the shard info we need in the next step of mapping slice->shards\r\n        \r\n        // Stores the comma-separated list of specified collections.\r\n        // Eg: \"collection1,collection2,collection3\"\r\n        String collections = params.get(\"collection\");\r\n        if (collections != null) {\r\n          // If there were one or more collections specified in the query, split\r\n          // each parameter and store as a seperate member of a List.\r\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\r\n              true);\r\n          \r\n          // First create an empty HashMap to add the slice info to.\r\n          slices = new HashMap<String,Slice>();\r\n          \r\n          // In turn, retrieve the slices that cover each collection from the\r\n          // cloud state and add them to the Map 'slices'.\r\n          for (int i = 0; i < collectionList.size(); i++) {\r\n            String collection = collectionList.get(i);\r\n            ClientUtils.appendMap(collection, slices, cloudState.getSlices(collection));\r\n          }\r\n        } else {\r\n          // If no collections were specified, default to the collection for\r\n          // this core.\r\n          slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\r\n        }\r\n        \r\n        // Store the logical slices in the ResponseBuilder and create a new\r\n        // String array to hold the physical shards (which will be mapped\r\n        // later).\r\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\r\n        rb.shards = new String[rb.slices.length];\r\n\r\n        /***\r\n         rb.slices = new String[slices.size()];\r\n         for (int i=0; i<rb.slices.length; i++) {\r\n         rb.slices[i] = slices.get(i).getName();\r\n         }\r\n         ***/\r\n      }\r\n\r\n      //\r\n      // Map slices to shards\r\n      //\r\n      if (zkController != null) {\r\n        for (int i=0; i<rb.shards.length; i++) {\r\n          if (rb.shards[i] == null) {\r\n            if (cloudState == null) {\r\n              cloudState =  zkController.getCloudState();\r\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\r\n            }\r\n            String sliceName = rb.slices[i];\r\n\r\n            Slice slice = slices.get(sliceName);\r\n\r\n            if (slice==null) {\r\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\r\n              // if partial results are acceptable\r\n              rb.shards[i] = \"\";\r\n              continue;\r\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\r\n            }\r\n\r\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\r\n\r\n            // For now, recreate the | delimited list of equivalent servers\r\n            Set<String> liveNodes = cloudState.getLiveNodes();\r\n            StringBuilder sliceShardsStr = new StringBuilder();\r\n            boolean first = true;\r\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\r\n              ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\r\n              if (!liveNodes.contains(coreNodeProps.getNodeName())\r\n                  || !coreNodeProps.getState().equals(\r\n                      ZkStateReader.ACTIVE)) continue;\r\n              if (first) {\r\n                first = false;\r\n              } else {\r\n                sliceShardsStr.append('|');\r\n              }\r\n              String url = coreNodeProps.getCoreUrl();\r\n              if (url.startsWith(\"http://\"))\r\n                url = url.substring(7);\r\n              sliceShardsStr.append(url);\r\n            }\r\n\r\n            rb.shards[i] = sliceShardsStr.toString();\r\n          }\r\n        }\r\n      }\r\n    }\r\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\r\n    if(shards_rows != null) {\r\n      rb.shards_rows = Integer.parseInt(shards_rows);\r\n    }\r\n    String shards_start = params.get(ShardParams.SHARDS_START);\r\n    if(shards_start != null) {\r\n      rb.shards_start = Integer.parseInt(shards_start);\r\n    }\r\n  }\r\n\n","sourceOld":"  public void checkDistributed(ResponseBuilder rb) {\r\n    SolrQueryRequest req = rb.req;\r\n    SolrParams params = req.getParams();\r\n\r\n    rb.isDistrib = params.getBool(\"distrib\",false);\r\n    String shards = params.get(ShardParams.SHARDS);\r\n\r\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\r\n    // search is distributed.\r\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\r\n    rb.isDistrib = hasShardURL | rb.isDistrib;\r\n\r\n    if (rb.isDistrib) {\r\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\r\n      // if we need it.\r\n      CloudState cloudState = null;\r\n      Map<String,Slice> slices = null;\r\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\r\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\r\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\r\n\r\n\r\n      if (shards != null) {\r\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\r\n        rb.shards = lst.toArray(new String[lst.size()]);\r\n        rb.slices = new String[rb.shards.length];\r\n\r\n        if (zkController != null) {\r\n          // figure out which shards are slices\r\n          for (int i=0; i<rb.shards.length; i++) {\r\n            if (rb.shards[i].indexOf('/') < 0) {\r\n              // this is a logical shard\r\n              rb.slices[i] = rb.shards[i];\r\n              rb.shards[i] = null;\r\n            }\r\n          }\r\n        }\r\n      } else if (zkController != null) {\r\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\r\n\r\n        cloudState =  zkController.getCloudState();\r\n\r\n        // TODO: check \"collection\" for which collection(s) to search.. but for now, just default\r\n        // to the collection for this core.\r\n        // This can be more efficient... we only record the name, even though we have the\r\n        // shard info we need in the next step of mapping slice->shards\r\n        slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\r\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\r\n        rb.shards = new String[rb.slices.length];\r\n\r\n        /***\r\n         rb.slices = new String[slices.size()];\r\n         for (int i=0; i<rb.slices.length; i++) {\r\n         rb.slices[i] = slices.get(i).getName();\r\n         }\r\n         ***/\r\n      }\r\n\r\n      //\r\n      // Map slices to shards\r\n      //\r\n      if (zkController != null) {\r\n        for (int i=0; i<rb.shards.length; i++) {\r\n          if (rb.shards[i] == null) {\r\n            if (cloudState == null) {\r\n              cloudState =  zkController.getCloudState();\r\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\r\n            }\r\n            String sliceName = rb.slices[i];\r\n\r\n            Slice slice = slices.get(sliceName);\r\n\r\n            if (slice==null) {\r\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\r\n              // if partial results are acceptable\r\n              rb.shards[i] = \"\";\r\n              continue;\r\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\r\n            }\r\n\r\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\r\n\r\n            // For now, recreate the | delimited list of equivalent servers\r\n            Set<String> liveNodes = cloudState.getLiveNodes();\r\n            StringBuilder sliceShardsStr = new StringBuilder();\r\n            boolean first = true;\r\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\r\n              if (!liveNodes.contains(nodeProps.get(ZkStateReader.NODE_NAME)))\r\n                continue;\r\n              if (first) {\r\n                first = false;\r\n              } else {\r\n                sliceShardsStr.append('|');\r\n              }\r\n              String url = nodeProps.get(\"url\");\r\n              if (url.startsWith(\"http://\"))\r\n                url = url.substring(7);\r\n              sliceShardsStr.append(url);\r\n            }\r\n\r\n            rb.shards[i] = sliceShardsStr.toString();\r\n          }\r\n        }\r\n      }\r\n    }\r\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\r\n    if(shards_rows != null) {\r\n      rb.shards_rows = Integer.parseInt(shards_rows);\r\n    }\r\n    String shards_start = params.get(ShardParams.SHARDS_START);\r\n    if(shards_start != null) {\r\n      rb.shards_start = Integer.parseInt(shards_start);\r\n    }\r\n  }\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d22ac6a4146774c1bc8400160fc0b6150294e92","date":1327528604,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","sourceNew":"  public void checkDistributed(ResponseBuilder rb) {\r\n    SolrQueryRequest req = rb.req;\r\n    SolrParams params = req.getParams();\r\n\r\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\r\n        .getCoreContainer().isZooKeeperAware());\r\n    String shards = params.get(ShardParams.SHARDS);\r\n\r\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\r\n    // search is distributed.\r\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\r\n    rb.isDistrib = hasShardURL | rb.isDistrib;\r\n\r\n    if (rb.isDistrib) {\r\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\r\n      // if we need it.\r\n      CloudState cloudState = null;\r\n      Map<String,Slice> slices = null;\r\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\r\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\r\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\r\n\r\n\r\n      if (shards != null) {\r\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\r\n        rb.shards = lst.toArray(new String[lst.size()]);\r\n        rb.slices = new String[rb.shards.length];\r\n\r\n        if (zkController != null) {\r\n          // figure out which shards are slices\r\n          for (int i=0; i<rb.shards.length; i++) {\r\n            if (rb.shards[i].indexOf('/') < 0) {\r\n              // this is a logical shard\r\n              rb.slices[i] = rb.shards[i];\r\n              rb.shards[i] = null;\r\n            }\r\n          }\r\n        }\r\n      } else if (zkController != null) {\r\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\r\n\r\n        cloudState =  zkController.getCloudState();\r\n\r\n        // This can be more efficient... we only record the name, even though we\r\n        // have the shard info we need in the next step of mapping slice->shards\r\n        \r\n        // Stores the comma-separated list of specified collections.\r\n        // Eg: \"collection1,collection2,collection3\"\r\n        String collections = params.get(\"collection\");\r\n        if (collections != null) {\r\n          // If there were one or more collections specified in the query, split\r\n          // each parameter and store as a seperate member of a List.\r\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\r\n              true);\r\n          \r\n          // First create an empty HashMap to add the slice info to.\r\n          slices = new HashMap<String,Slice>();\r\n          \r\n          // In turn, retrieve the slices that cover each collection from the\r\n          // cloud state and add them to the Map 'slices'.\r\n          for (int i = 0; i < collectionList.size(); i++) {\r\n            String collection = collectionList.get(i);\r\n            ClientUtils.appendMap(collection, slices, cloudState.getSlices(collection));\r\n          }\r\n        } else {\r\n          // If no collections were specified, default to the collection for\r\n          // this core.\r\n          slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\r\n        }\r\n        \r\n        // Store the logical slices in the ResponseBuilder and create a new\r\n        // String array to hold the physical shards (which will be mapped\r\n        // later).\r\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\r\n        rb.shards = new String[rb.slices.length];\r\n\r\n        /***\r\n         rb.slices = new String[slices.size()];\r\n         for (int i=0; i<rb.slices.length; i++) {\r\n         rb.slices[i] = slices.get(i).getName();\r\n         }\r\n         ***/\r\n      }\r\n\r\n      //\r\n      // Map slices to shards\r\n      //\r\n      if (zkController != null) {\r\n        for (int i=0; i<rb.shards.length; i++) {\r\n          if (rb.shards[i] == null) {\r\n            if (cloudState == null) {\r\n              cloudState =  zkController.getCloudState();\r\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\r\n            }\r\n            String sliceName = rb.slices[i];\r\n\r\n            Slice slice = slices.get(sliceName);\r\n\r\n            if (slice==null) {\r\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\r\n              // if partial results are acceptable\r\n              rb.shards[i] = \"\";\r\n              continue;\r\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\r\n            }\r\n\r\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\r\n\r\n            // For now, recreate the | delimited list of equivalent servers\r\n            Set<String> liveNodes = cloudState.getLiveNodes();\r\n            StringBuilder sliceShardsStr = new StringBuilder();\r\n            boolean first = true;\r\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\r\n              ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\r\n              if (!liveNodes.contains(coreNodeProps.getNodeName())\r\n                  || !coreNodeProps.getState().equals(\r\n                      ZkStateReader.ACTIVE)) continue;\r\n              if (first) {\r\n                first = false;\r\n              } else {\r\n                sliceShardsStr.append('|');\r\n              }\r\n              String url = coreNodeProps.getCoreUrl();\r\n              if (url.startsWith(\"http://\"))\r\n                url = url.substring(7);\r\n              sliceShardsStr.append(url);\r\n            }\r\n\r\n            rb.shards[i] = sliceShardsStr.toString();\r\n          }\r\n        }\r\n      }\r\n    }\r\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\r\n    if(shards_rows != null) {\r\n      rb.shards_rows = Integer.parseInt(shards_rows);\r\n    }\r\n    String shards_start = params.get(ShardParams.SHARDS_START);\r\n    if(shards_start != null) {\r\n      rb.shards_start = Integer.parseInt(shards_start);\r\n    }\r\n  }\r\n\n","sourceOld":"  public void checkDistributed(ResponseBuilder rb) {\r\n    SolrQueryRequest req = rb.req;\r\n    SolrParams params = req.getParams();\r\n\r\n    rb.isDistrib = params.getBool(\"distrib\",false);\r\n    String shards = params.get(ShardParams.SHARDS);\r\n\r\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\r\n    // search is distributed.\r\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\r\n    rb.isDistrib = hasShardURL | rb.isDistrib;\r\n\r\n    if (rb.isDistrib) {\r\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\r\n      // if we need it.\r\n      CloudState cloudState = null;\r\n      Map<String,Slice> slices = null;\r\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\r\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\r\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\r\n\r\n\r\n      if (shards != null) {\r\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\r\n        rb.shards = lst.toArray(new String[lst.size()]);\r\n        rb.slices = new String[rb.shards.length];\r\n\r\n        if (zkController != null) {\r\n          // figure out which shards are slices\r\n          for (int i=0; i<rb.shards.length; i++) {\r\n            if (rb.shards[i].indexOf('/') < 0) {\r\n              // this is a logical shard\r\n              rb.slices[i] = rb.shards[i];\r\n              rb.shards[i] = null;\r\n            }\r\n          }\r\n        }\r\n      } else if (zkController != null) {\r\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\r\n\r\n        cloudState =  zkController.getCloudState();\r\n\r\n        // TODO: check \"collection\" for which collection(s) to search.. but for now, just default\r\n        // to the collection for this core.\r\n        // This can be more efficient... we only record the name, even though we have the\r\n        // shard info we need in the next step of mapping slice->shards\r\n        slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\r\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\r\n        rb.shards = new String[rb.slices.length];\r\n\r\n        /***\r\n         rb.slices = new String[slices.size()];\r\n         for (int i=0; i<rb.slices.length; i++) {\r\n         rb.slices[i] = slices.get(i).getName();\r\n         }\r\n         ***/\r\n      }\r\n\r\n      //\r\n      // Map slices to shards\r\n      //\r\n      if (zkController != null) {\r\n        for (int i=0; i<rb.shards.length; i++) {\r\n          if (rb.shards[i] == null) {\r\n            if (cloudState == null) {\r\n              cloudState =  zkController.getCloudState();\r\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\r\n            }\r\n            String sliceName = rb.slices[i];\r\n\r\n            Slice slice = slices.get(sliceName);\r\n\r\n            if (slice==null) {\r\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\r\n              // if partial results are acceptable\r\n              rb.shards[i] = \"\";\r\n              continue;\r\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\r\n            }\r\n\r\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\r\n\r\n            // For now, recreate the | delimited list of equivalent servers\r\n            Set<String> liveNodes = cloudState.getLiveNodes();\r\n            StringBuilder sliceShardsStr = new StringBuilder();\r\n            boolean first = true;\r\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\r\n              if (!liveNodes.contains(nodeProps.get(ZkStateReader.NODE_NAME)))\r\n                continue;\r\n              if (first) {\r\n                first = false;\r\n              } else {\r\n                sliceShardsStr.append('|');\r\n              }\r\n              String url = nodeProps.get(\"url\");\r\n              if (url.startsWith(\"http://\"))\r\n                url = url.substring(7);\r\n              sliceShardsStr.append(url);\r\n            }\r\n\r\n            rb.shards[i] = sliceShardsStr.toString();\r\n          }\r\n        }\r\n      }\r\n    }\r\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\r\n    if(shards_rows != null) {\r\n      rb.shards_rows = Integer.parseInt(shards_rows);\r\n    }\r\n    String shards_start = params.get(ShardParams.SHARDS_START);\r\n    if(shards_start != null) {\r\n      rb.shards_start = Integer.parseInt(shards_start);\r\n    }\r\n  }\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0c66f8d4f044af481e9d86acc1b092d44db7c20f","date":1328030645,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","sourceNew":"  public void checkDistributed(ResponseBuilder rb) {\r\n    SolrQueryRequest req = rb.req;\r\n    SolrParams params = req.getParams();\r\n\r\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\r\n        .getCoreContainer().isZooKeeperAware());\r\n    String shards = params.get(ShardParams.SHARDS);\r\n\r\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\r\n    // search is distributed.\r\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\r\n    rb.isDistrib = hasShardURL | rb.isDistrib;\r\n\r\n    if (rb.isDistrib) {\r\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\r\n      // if we need it.\r\n      CloudState cloudState = null;\r\n      Map<String,Slice> slices = null;\r\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\r\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\r\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\r\n\r\n\r\n      if (shards != null) {\r\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\r\n        rb.shards = lst.toArray(new String[lst.size()]);\r\n        rb.slices = new String[rb.shards.length];\r\n\r\n        if (zkController != null) {\r\n          // figure out which shards are slices\r\n          for (int i=0; i<rb.shards.length; i++) {\r\n            if (rb.shards[i].indexOf('/') < 0) {\r\n              // this is a logical shard\r\n              rb.slices[i] = rb.shards[i];\r\n              rb.shards[i] = null;\r\n            }\r\n          }\r\n        }\r\n      } else if (zkController != null) {\r\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\r\n\r\n        cloudState =  zkController.getCloudState();\r\n\r\n        // This can be more efficient... we only record the name, even though we\r\n        // have the shard info we need in the next step of mapping slice->shards\r\n        \r\n        // Stores the comma-separated list of specified collections.\r\n        // Eg: \"collection1,collection2,collection3\"\r\n        String collections = params.get(\"collection\");\r\n        if (collections != null) {\r\n          // If there were one or more collections specified in the query, split\r\n          // each parameter and store as a seperate member of a List.\r\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\r\n              true);\r\n          \r\n          // First create an empty HashMap to add the slice info to.\r\n          slices = new HashMap<String,Slice>();\r\n          \r\n          // In turn, retrieve the slices that cover each collection from the\r\n          // cloud state and add them to the Map 'slices'.\r\n          for (int i = 0; i < collectionList.size(); i++) {\r\n            String collection = collectionList.get(i);\r\n            ClientUtils.appendMap(collection, slices, cloudState.getSlices(collection));\r\n          }\r\n        } else {\r\n          // If no collections were specified, default to the collection for\r\n          // this core.\r\n          slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\r\n          if (slices == null) {\r\n            throw new SolrException(ErrorCode.BAD_REQUEST,\r\n                \"Could not find collection:\"\r\n                    + cloudDescriptor.getCollectionName());\r\n          }\r\n        }\r\n        \r\n        // Store the logical slices in the ResponseBuilder and create a new\r\n        // String array to hold the physical shards (which will be mapped\r\n        // later).\r\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\r\n        rb.shards = new String[rb.slices.length];\r\n\r\n        /***\r\n         rb.slices = new String[slices.size()];\r\n         for (int i=0; i<rb.slices.length; i++) {\r\n         rb.slices[i] = slices.get(i).getName();\r\n         }\r\n         ***/\r\n      }\r\n\r\n      //\r\n      // Map slices to shards\r\n      //\r\n      if (zkController != null) {\r\n        for (int i=0; i<rb.shards.length; i++) {\r\n          if (rb.shards[i] == null) {\r\n            if (cloudState == null) {\r\n              cloudState =  zkController.getCloudState();\r\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\r\n            }\r\n            String sliceName = rb.slices[i];\r\n\r\n            Slice slice = slices.get(sliceName);\r\n\r\n            if (slice==null) {\r\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\r\n              // if partial results are acceptable\r\n              rb.shards[i] = \"\";\r\n              continue;\r\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\r\n            }\r\n\r\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\r\n\r\n            // For now, recreate the | delimited list of equivalent servers\r\n            Set<String> liveNodes = cloudState.getLiveNodes();\r\n            StringBuilder sliceShardsStr = new StringBuilder();\r\n            boolean first = true;\r\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\r\n              ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\r\n              if (!liveNodes.contains(coreNodeProps.getNodeName())\r\n                  || !coreNodeProps.getState().equals(\r\n                      ZkStateReader.ACTIVE)) continue;\r\n              if (first) {\r\n                first = false;\r\n              } else {\r\n                sliceShardsStr.append('|');\r\n              }\r\n              String url = coreNodeProps.getCoreUrl();\r\n              if (url.startsWith(\"http://\"))\r\n                url = url.substring(7);\r\n              sliceShardsStr.append(url);\r\n            }\r\n\r\n            rb.shards[i] = sliceShardsStr.toString();\r\n          }\r\n        }\r\n      }\r\n    }\r\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\r\n    if(shards_rows != null) {\r\n      rb.shards_rows = Integer.parseInt(shards_rows);\r\n    }\r\n    String shards_start = params.get(ShardParams.SHARDS_START);\r\n    if(shards_start != null) {\r\n      rb.shards_start = Integer.parseInt(shards_start);\r\n    }\r\n  }\r\n\n","sourceOld":"  public void checkDistributed(ResponseBuilder rb) {\r\n    SolrQueryRequest req = rb.req;\r\n    SolrParams params = req.getParams();\r\n\r\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\r\n        .getCoreContainer().isZooKeeperAware());\r\n    String shards = params.get(ShardParams.SHARDS);\r\n\r\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\r\n    // search is distributed.\r\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\r\n    rb.isDistrib = hasShardURL | rb.isDistrib;\r\n\r\n    if (rb.isDistrib) {\r\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\r\n      // if we need it.\r\n      CloudState cloudState = null;\r\n      Map<String,Slice> slices = null;\r\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\r\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\r\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\r\n\r\n\r\n      if (shards != null) {\r\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\r\n        rb.shards = lst.toArray(new String[lst.size()]);\r\n        rb.slices = new String[rb.shards.length];\r\n\r\n        if (zkController != null) {\r\n          // figure out which shards are slices\r\n          for (int i=0; i<rb.shards.length; i++) {\r\n            if (rb.shards[i].indexOf('/') < 0) {\r\n              // this is a logical shard\r\n              rb.slices[i] = rb.shards[i];\r\n              rb.shards[i] = null;\r\n            }\r\n          }\r\n        }\r\n      } else if (zkController != null) {\r\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\r\n\r\n        cloudState =  zkController.getCloudState();\r\n\r\n        // This can be more efficient... we only record the name, even though we\r\n        // have the shard info we need in the next step of mapping slice->shards\r\n        \r\n        // Stores the comma-separated list of specified collections.\r\n        // Eg: \"collection1,collection2,collection3\"\r\n        String collections = params.get(\"collection\");\r\n        if (collections != null) {\r\n          // If there were one or more collections specified in the query, split\r\n          // each parameter and store as a seperate member of a List.\r\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\r\n              true);\r\n          \r\n          // First create an empty HashMap to add the slice info to.\r\n          slices = new HashMap<String,Slice>();\r\n          \r\n          // In turn, retrieve the slices that cover each collection from the\r\n          // cloud state and add them to the Map 'slices'.\r\n          for (int i = 0; i < collectionList.size(); i++) {\r\n            String collection = collectionList.get(i);\r\n            ClientUtils.appendMap(collection, slices, cloudState.getSlices(collection));\r\n          }\r\n        } else {\r\n          // If no collections were specified, default to the collection for\r\n          // this core.\r\n          slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\r\n        }\r\n        \r\n        // Store the logical slices in the ResponseBuilder and create a new\r\n        // String array to hold the physical shards (which will be mapped\r\n        // later).\r\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\r\n        rb.shards = new String[rb.slices.length];\r\n\r\n        /***\r\n         rb.slices = new String[slices.size()];\r\n         for (int i=0; i<rb.slices.length; i++) {\r\n         rb.slices[i] = slices.get(i).getName();\r\n         }\r\n         ***/\r\n      }\r\n\r\n      //\r\n      // Map slices to shards\r\n      //\r\n      if (zkController != null) {\r\n        for (int i=0; i<rb.shards.length; i++) {\r\n          if (rb.shards[i] == null) {\r\n            if (cloudState == null) {\r\n              cloudState =  zkController.getCloudState();\r\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\r\n            }\r\n            String sliceName = rb.slices[i];\r\n\r\n            Slice slice = slices.get(sliceName);\r\n\r\n            if (slice==null) {\r\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\r\n              // if partial results are acceptable\r\n              rb.shards[i] = \"\";\r\n              continue;\r\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\r\n            }\r\n\r\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\r\n\r\n            // For now, recreate the | delimited list of equivalent servers\r\n            Set<String> liveNodes = cloudState.getLiveNodes();\r\n            StringBuilder sliceShardsStr = new StringBuilder();\r\n            boolean first = true;\r\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\r\n              ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\r\n              if (!liveNodes.contains(coreNodeProps.getNodeName())\r\n                  || !coreNodeProps.getState().equals(\r\n                      ZkStateReader.ACTIVE)) continue;\r\n              if (first) {\r\n                first = false;\r\n              } else {\r\n                sliceShardsStr.append('|');\r\n              }\r\n              String url = coreNodeProps.getCoreUrl();\r\n              if (url.startsWith(\"http://\"))\r\n                url = url.substring(7);\r\n              sliceShardsStr.append(url);\r\n            }\r\n\r\n            rb.shards[i] = sliceShardsStr.toString();\r\n          }\r\n        }\r\n      }\r\n    }\r\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\r\n    if(shards_rows != null) {\r\n      rb.shards_rows = Integer.parseInt(shards_rows);\r\n    }\r\n    String shards_start = params.get(ShardParams.SHARDS_START);\r\n    if(shards_start != null) {\r\n      rb.shards_start = Integer.parseInt(shards_start);\r\n    }\r\n  }\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d66363068e87a246ce08fee4a42f30f126b92723","date":1329988051,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","sourceNew":"  public void checkDistributed(ResponseBuilder rb) {\r\n    SolrQueryRequest req = rb.req;\r\n    SolrParams params = req.getParams();\r\n\r\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\r\n        .getCoreContainer().isZooKeeperAware());\r\n    String shards = params.get(ShardParams.SHARDS);\r\n\r\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\r\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n    \n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      CloudState cloudState = null;\r\n      Map<String,Slice> slices = null;\r\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\r\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\r\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\r\n\r\n\r\n      if (shards != null) {\r\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\r\n        rb.shards = lst.toArray(new String[lst.size()]);\r\n        rb.slices = new String[rb.shards.length];\r\n\r\n        if (zkController != null) {\r\n          // figure out which shards are slices\r\n          for (int i=0; i<rb.shards.length; i++) {\r\n            if (rb.shards[i].indexOf('/') < 0) {\r\n              // this is a logical shard\r\n              rb.slices[i] = rb.shards[i];\r\n              rb.shards[i] = null;\r\n            }\r\n          }\r\n        }\r\n      } else if (zkController != null) {\r\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\r\n\r\n        cloudState =  zkController.getCloudState();\r\n\r\n        // This can be more efficient... we only record the name, even though we\r\n        // have the shard info we need in the next step of mapping slice->shards\r\n        \r\n        // Stores the comma-separated list of specified collections.\r\n        // Eg: \"collection1,collection2,collection3\"\r\n        String collections = params.get(\"collection\");\r\n        if (collections != null) {\r\n          // If there were one or more collections specified in the query, split\r\n          // each parameter and store as a seperate member of a List.\r\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\r\n              true);\r\n          \r\n          // First create an empty HashMap to add the slice info to.\r\n          slices = new HashMap<String,Slice>();\r\n          \r\n          // In turn, retrieve the slices that cover each collection from the\r\n          // cloud state and add them to the Map 'slices'.\r\n          for (int i = 0; i < collectionList.size(); i++) {\r\n            String collection = collectionList.get(i);\r\n            ClientUtils.appendMap(collection, slices, cloudState.getSlices(collection));\r\n          }\r\n        } else {\r\n          // If no collections were specified, default to the collection for\r\n          // this core.\r\n          slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\r\n          if (slices == null) {\r\n            throw new SolrException(ErrorCode.BAD_REQUEST,\r\n                \"Could not find collection:\"\r\n                    + cloudDescriptor.getCollectionName());\r\n          }\r\n        }\r\n        \r\n        // Store the logical slices in the ResponseBuilder and create a new\r\n        // String array to hold the physical shards (which will be mapped\r\n        // later).\r\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\r\n        rb.shards = new String[rb.slices.length];\r\n\r\n        /***\r\n         rb.slices = new String[slices.size()];\r\n         for (int i=0; i<rb.slices.length; i++) {\r\n         rb.slices[i] = slices.get(i).getName();\r\n         }\r\n         ***/\r\n      }\r\n\r\n      //\r\n      // Map slices to shards\r\n      //\r\n      if (zkController != null) {\r\n        for (int i=0; i<rb.shards.length; i++) {\r\n          if (rb.shards[i] == null) {\r\n            if (cloudState == null) {\r\n              cloudState =  zkController.getCloudState();\r\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\r\n            }\r\n            String sliceName = rb.slices[i];\r\n\r\n            Slice slice = slices.get(sliceName);\r\n\r\n            if (slice==null) {\r\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\r\n              // if partial results are acceptable\r\n              rb.shards[i] = \"\";\r\n              continue;\r\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\r\n            }\r\n\r\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\r\n\r\n            // For now, recreate the | delimited list of equivalent servers\r\n            Set<String> liveNodes = cloudState.getLiveNodes();\r\n            StringBuilder sliceShardsStr = new StringBuilder();\r\n            boolean first = true;\r\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\r\n              ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\r\n              if (!liveNodes.contains(coreNodeProps.getNodeName())\r\n                  || !coreNodeProps.getState().equals(\r\n                      ZkStateReader.ACTIVE)) continue;\r\n              if (first) {\r\n                first = false;\r\n              } else {\r\n                sliceShardsStr.append('|');\r\n              }\r\n              String url = coreNodeProps.getCoreUrl();\r\n              if (url.startsWith(\"http://\"))\r\n                url = url.substring(7);\r\n              sliceShardsStr.append(url);\r\n            }\r\n\r\n            rb.shards[i] = sliceShardsStr.toString();\r\n          }\r\n        }\r\n      }\r\n    }\r\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\r\n    if(shards_rows != null) {\r\n      rb.shards_rows = Integer.parseInt(shards_rows);\r\n    }\r\n    String shards_start = params.get(ShardParams.SHARDS_START);\r\n    if(shards_start != null) {\r\n      rb.shards_start = Integer.parseInt(shards_start);\r\n    }\r\n  }\r\n\n","sourceOld":"  public void checkDistributed(ResponseBuilder rb) {\r\n    SolrQueryRequest req = rb.req;\r\n    SolrParams params = req.getParams();\r\n\r\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\r\n        .getCoreContainer().isZooKeeperAware());\r\n    String shards = params.get(ShardParams.SHARDS);\r\n\r\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\r\n    // search is distributed.\r\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\r\n    rb.isDistrib = hasShardURL | rb.isDistrib;\r\n\r\n    if (rb.isDistrib) {\r\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\r\n      // if we need it.\r\n      CloudState cloudState = null;\r\n      Map<String,Slice> slices = null;\r\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\r\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\r\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\r\n\r\n\r\n      if (shards != null) {\r\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\r\n        rb.shards = lst.toArray(new String[lst.size()]);\r\n        rb.slices = new String[rb.shards.length];\r\n\r\n        if (zkController != null) {\r\n          // figure out which shards are slices\r\n          for (int i=0; i<rb.shards.length; i++) {\r\n            if (rb.shards[i].indexOf('/') < 0) {\r\n              // this is a logical shard\r\n              rb.slices[i] = rb.shards[i];\r\n              rb.shards[i] = null;\r\n            }\r\n          }\r\n        }\r\n      } else if (zkController != null) {\r\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\r\n\r\n        cloudState =  zkController.getCloudState();\r\n\r\n        // This can be more efficient... we only record the name, even though we\r\n        // have the shard info we need in the next step of mapping slice->shards\r\n        \r\n        // Stores the comma-separated list of specified collections.\r\n        // Eg: \"collection1,collection2,collection3\"\r\n        String collections = params.get(\"collection\");\r\n        if (collections != null) {\r\n          // If there were one or more collections specified in the query, split\r\n          // each parameter and store as a seperate member of a List.\r\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\r\n              true);\r\n          \r\n          // First create an empty HashMap to add the slice info to.\r\n          slices = new HashMap<String,Slice>();\r\n          \r\n          // In turn, retrieve the slices that cover each collection from the\r\n          // cloud state and add them to the Map 'slices'.\r\n          for (int i = 0; i < collectionList.size(); i++) {\r\n            String collection = collectionList.get(i);\r\n            ClientUtils.appendMap(collection, slices, cloudState.getSlices(collection));\r\n          }\r\n        } else {\r\n          // If no collections were specified, default to the collection for\r\n          // this core.\r\n          slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\r\n          if (slices == null) {\r\n            throw new SolrException(ErrorCode.BAD_REQUEST,\r\n                \"Could not find collection:\"\r\n                    + cloudDescriptor.getCollectionName());\r\n          }\r\n        }\r\n        \r\n        // Store the logical slices in the ResponseBuilder and create a new\r\n        // String array to hold the physical shards (which will be mapped\r\n        // later).\r\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\r\n        rb.shards = new String[rb.slices.length];\r\n\r\n        /***\r\n         rb.slices = new String[slices.size()];\r\n         for (int i=0; i<rb.slices.length; i++) {\r\n         rb.slices[i] = slices.get(i).getName();\r\n         }\r\n         ***/\r\n      }\r\n\r\n      //\r\n      // Map slices to shards\r\n      //\r\n      if (zkController != null) {\r\n        for (int i=0; i<rb.shards.length; i++) {\r\n          if (rb.shards[i] == null) {\r\n            if (cloudState == null) {\r\n              cloudState =  zkController.getCloudState();\r\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\r\n            }\r\n            String sliceName = rb.slices[i];\r\n\r\n            Slice slice = slices.get(sliceName);\r\n\r\n            if (slice==null) {\r\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\r\n              // if partial results are acceptable\r\n              rb.shards[i] = \"\";\r\n              continue;\r\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\r\n            }\r\n\r\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\r\n\r\n            // For now, recreate the | delimited list of equivalent servers\r\n            Set<String> liveNodes = cloudState.getLiveNodes();\r\n            StringBuilder sliceShardsStr = new StringBuilder();\r\n            boolean first = true;\r\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\r\n              ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\r\n              if (!liveNodes.contains(coreNodeProps.getNodeName())\r\n                  || !coreNodeProps.getState().equals(\r\n                      ZkStateReader.ACTIVE)) continue;\r\n              if (first) {\r\n                first = false;\r\n              } else {\r\n                sliceShardsStr.append('|');\r\n              }\r\n              String url = coreNodeProps.getCoreUrl();\r\n              if (url.startsWith(\"http://\"))\r\n                url = url.substring(7);\r\n              sliceShardsStr.append(url);\r\n            }\r\n\r\n            rb.shards[i] = sliceShardsStr.toString();\r\n          }\r\n        }\r\n      }\r\n    }\r\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\r\n    if(shards_rows != null) {\r\n      rb.shards_rows = Integer.parseInt(shards_rows);\r\n    }\r\n    String shards_start = params.get(ShardParams.SHARDS_START);\r\n    if(shards_start != null) {\r\n      rb.shards_start = Integer.parseInt(shards_start);\r\n    }\r\n  }\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","sourceNew":"  public void checkDistributed(ResponseBuilder rb) {\r\n    SolrQueryRequest req = rb.req;\r\n    SolrParams params = req.getParams();\r\n\r\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\r\n        .getCoreContainer().isZooKeeperAware());\r\n    String shards = params.get(ShardParams.SHARDS);\r\n\r\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\r\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n    \n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      CloudState cloudState = null;\r\n      Map<String,Slice> slices = null;\r\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\r\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\r\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\r\n\r\n\r\n      if (shards != null) {\r\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\r\n        rb.shards = lst.toArray(new String[lst.size()]);\r\n        rb.slices = new String[rb.shards.length];\r\n\r\n        if (zkController != null) {\r\n          // figure out which shards are slices\r\n          for (int i=0; i<rb.shards.length; i++) {\r\n            if (rb.shards[i].indexOf('/') < 0) {\r\n              // this is a logical shard\r\n              rb.slices[i] = rb.shards[i];\r\n              rb.shards[i] = null;\r\n            }\r\n          }\r\n        }\r\n      } else if (zkController != null) {\r\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\r\n\r\n        cloudState =  zkController.getCloudState();\r\n\r\n        // This can be more efficient... we only record the name, even though we\r\n        // have the shard info we need in the next step of mapping slice->shards\r\n        \r\n        // Stores the comma-separated list of specified collections.\r\n        // Eg: \"collection1,collection2,collection3\"\r\n        String collections = params.get(\"collection\");\r\n        if (collections != null) {\r\n          // If there were one or more collections specified in the query, split\r\n          // each parameter and store as a seperate member of a List.\r\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\r\n              true);\r\n          \r\n          // First create an empty HashMap to add the slice info to.\r\n          slices = new HashMap<String,Slice>();\r\n          \r\n          // In turn, retrieve the slices that cover each collection from the\r\n          // cloud state and add them to the Map 'slices'.\r\n          for (int i = 0; i < collectionList.size(); i++) {\r\n            String collection = collectionList.get(i);\r\n            ClientUtils.appendMap(collection, slices, cloudState.getSlices(collection));\r\n          }\r\n        } else {\r\n          // If no collections were specified, default to the collection for\r\n          // this core.\r\n          slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\r\n          if (slices == null) {\r\n            throw new SolrException(ErrorCode.BAD_REQUEST,\r\n                \"Could not find collection:\"\r\n                    + cloudDescriptor.getCollectionName());\r\n          }\r\n        }\r\n        \r\n        // Store the logical slices in the ResponseBuilder and create a new\r\n        // String array to hold the physical shards (which will be mapped\r\n        // later).\r\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\r\n        rb.shards = new String[rb.slices.length];\r\n\r\n        /***\r\n         rb.slices = new String[slices.size()];\r\n         for (int i=0; i<rb.slices.length; i++) {\r\n         rb.slices[i] = slices.get(i).getName();\r\n         }\r\n         ***/\r\n      }\r\n\r\n      //\r\n      // Map slices to shards\r\n      //\r\n      if (zkController != null) {\r\n        for (int i=0; i<rb.shards.length; i++) {\r\n          if (rb.shards[i] == null) {\r\n            if (cloudState == null) {\r\n              cloudState =  zkController.getCloudState();\r\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\r\n            }\r\n            String sliceName = rb.slices[i];\r\n\r\n            Slice slice = slices.get(sliceName);\r\n\r\n            if (slice==null) {\r\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\r\n              // if partial results are acceptable\r\n              rb.shards[i] = \"\";\r\n              continue;\r\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\r\n            }\r\n\r\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\r\n\r\n            // For now, recreate the | delimited list of equivalent servers\r\n            Set<String> liveNodes = cloudState.getLiveNodes();\r\n            StringBuilder sliceShardsStr = new StringBuilder();\r\n            boolean first = true;\r\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\r\n              ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\r\n              if (!liveNodes.contains(coreNodeProps.getNodeName())\r\n                  || !coreNodeProps.getState().equals(\r\n                      ZkStateReader.ACTIVE)) continue;\r\n              if (first) {\r\n                first = false;\r\n              } else {\r\n                sliceShardsStr.append('|');\r\n              }\r\n              String url = coreNodeProps.getCoreUrl();\r\n              if (url.startsWith(\"http://\"))\r\n                url = url.substring(7);\r\n              sliceShardsStr.append(url);\r\n            }\r\n\r\n            rb.shards[i] = sliceShardsStr.toString();\r\n          }\r\n        }\r\n      }\r\n    }\r\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\r\n    if(shards_rows != null) {\r\n      rb.shards_rows = Integer.parseInt(shards_rows);\r\n    }\r\n    String shards_start = params.get(ShardParams.SHARDS_START);\r\n    if(shards_start != null) {\r\n      rb.shards_start = Integer.parseInt(shards_start);\r\n    }\r\n  }\r\n\n","sourceOld":"  public void checkDistributed(ResponseBuilder rb) {\r\n    SolrQueryRequest req = rb.req;\r\n    SolrParams params = req.getParams();\r\n\r\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\r\n        .getCoreContainer().isZooKeeperAware());\r\n    String shards = params.get(ShardParams.SHARDS);\r\n\r\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\r\n    // search is distributed.\r\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\r\n    rb.isDistrib = hasShardURL | rb.isDistrib;\r\n\r\n    if (rb.isDistrib) {\r\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\r\n      // if we need it.\r\n      CloudState cloudState = null;\r\n      Map<String,Slice> slices = null;\r\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\r\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\r\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\r\n\r\n\r\n      if (shards != null) {\r\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\r\n        rb.shards = lst.toArray(new String[lst.size()]);\r\n        rb.slices = new String[rb.shards.length];\r\n\r\n        if (zkController != null) {\r\n          // figure out which shards are slices\r\n          for (int i=0; i<rb.shards.length; i++) {\r\n            if (rb.shards[i].indexOf('/') < 0) {\r\n              // this is a logical shard\r\n              rb.slices[i] = rb.shards[i];\r\n              rb.shards[i] = null;\r\n            }\r\n          }\r\n        }\r\n      } else if (zkController != null) {\r\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\r\n\r\n        cloudState =  zkController.getCloudState();\r\n\r\n        // This can be more efficient... we only record the name, even though we\r\n        // have the shard info we need in the next step of mapping slice->shards\r\n        \r\n        // Stores the comma-separated list of specified collections.\r\n        // Eg: \"collection1,collection2,collection3\"\r\n        String collections = params.get(\"collection\");\r\n        if (collections != null) {\r\n          // If there were one or more collections specified in the query, split\r\n          // each parameter and store as a seperate member of a List.\r\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\r\n              true);\r\n          \r\n          // First create an empty HashMap to add the slice info to.\r\n          slices = new HashMap<String,Slice>();\r\n          \r\n          // In turn, retrieve the slices that cover each collection from the\r\n          // cloud state and add them to the Map 'slices'.\r\n          for (int i = 0; i < collectionList.size(); i++) {\r\n            String collection = collectionList.get(i);\r\n            ClientUtils.appendMap(collection, slices, cloudState.getSlices(collection));\r\n          }\r\n        } else {\r\n          // If no collections were specified, default to the collection for\r\n          // this core.\r\n          slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\r\n          if (slices == null) {\r\n            throw new SolrException(ErrorCode.BAD_REQUEST,\r\n                \"Could not find collection:\"\r\n                    + cloudDescriptor.getCollectionName());\r\n          }\r\n        }\r\n        \r\n        // Store the logical slices in the ResponseBuilder and create a new\r\n        // String array to hold the physical shards (which will be mapped\r\n        // later).\r\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\r\n        rb.shards = new String[rb.slices.length];\r\n\r\n        /***\r\n         rb.slices = new String[slices.size()];\r\n         for (int i=0; i<rb.slices.length; i++) {\r\n         rb.slices[i] = slices.get(i).getName();\r\n         }\r\n         ***/\r\n      }\r\n\r\n      //\r\n      // Map slices to shards\r\n      //\r\n      if (zkController != null) {\r\n        for (int i=0; i<rb.shards.length; i++) {\r\n          if (rb.shards[i] == null) {\r\n            if (cloudState == null) {\r\n              cloudState =  zkController.getCloudState();\r\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\r\n            }\r\n            String sliceName = rb.slices[i];\r\n\r\n            Slice slice = slices.get(sliceName);\r\n\r\n            if (slice==null) {\r\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\r\n              // if partial results are acceptable\r\n              rb.shards[i] = \"\";\r\n              continue;\r\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\r\n            }\r\n\r\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\r\n\r\n            // For now, recreate the | delimited list of equivalent servers\r\n            Set<String> liveNodes = cloudState.getLiveNodes();\r\n            StringBuilder sliceShardsStr = new StringBuilder();\r\n            boolean first = true;\r\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\r\n              ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\r\n              if (!liveNodes.contains(coreNodeProps.getNodeName())\r\n                  || !coreNodeProps.getState().equals(\r\n                      ZkStateReader.ACTIVE)) continue;\r\n              if (first) {\r\n                first = false;\r\n              } else {\r\n                sliceShardsStr.append('|');\r\n              }\r\n              String url = coreNodeProps.getCoreUrl();\r\n              if (url.startsWith(\"http://\"))\r\n                url = url.substring(7);\r\n              sliceShardsStr.append(url);\r\n            }\r\n\r\n            rb.shards[i] = sliceShardsStr.toString();\r\n          }\r\n        }\r\n      }\r\n    }\r\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\r\n    if(shards_rows != null) {\r\n      rb.shards_rows = Integer.parseInt(shards_rows);\r\n    }\r\n    String shards_start = params.get(ShardParams.SHARDS_START);\r\n    if(shards_start != null) {\r\n      rb.shards_start = Integer.parseInt(shards_start);\r\n    }\r\n  }\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d76dfc2581b6998f72c0e749c6200e9c2432c36f","date":1332788228,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","sourceNew":"  public void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\n        .getCoreContainer().isZooKeeperAware());\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n    \n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      CloudState cloudState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\n\n        cloudState =  zkController.getCloudState();\n\n        // This can be more efficient... we only record the name, even though we\n        // have the shard info we need in the next step of mapping slice->shards\n        \n        // Stores the comma-separated list of specified collections.\n        // Eg: \"collection1,collection2,collection3\"\n        String collections = params.get(\"collection\");\n        if (collections != null) {\n          // If there were one or more collections specified in the query, split\n          // each parameter and store as a seperate member of a List.\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\n              true);\n          \n          // First create an empty HashMap to add the slice info to.\n          slices = new HashMap<String,Slice>();\n          \n          // In turn, retrieve the slices that cover each collection from the\n          // cloud state and add them to the Map 'slices'.\n          for (int i = 0; i < collectionList.size(); i++) {\n            String collection = collectionList.get(i);\n            ClientUtils.appendMap(collection, slices, cloudState.getSlices(collection));\n          }\n        } else {\n          // If no collections were specified, default to the collection for\n          // this core.\n          slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n          if (slices == null) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\n                \"Could not find collection:\"\n                    + cloudDescriptor.getCollectionName());\n          }\n        }\n        \n        // Store the logical slices in the ResponseBuilder and create a new\n        // String array to hold the physical shards (which will be mapped\n        // later).\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n\n        /***\n         rb.slices = new String[slices.size()];\n         for (int i=0; i<rb.slices.length; i++) {\n         rb.slices[i] = slices.get(i).getName();\n         }\n         ***/\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (cloudState == null) {\n              cloudState =  zkController.getCloudState();\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\n\n            // For now, recreate the | delimited list of equivalent servers\n            Set<String> liveNodes = cloudState.getLiveNodes();\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\n              ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n              if (!liveNodes.contains(coreNodeProps.getNodeName())\n                  || !coreNodeProps.getState().equals(\n                      ZkStateReader.ACTIVE)) continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = coreNodeProps.getCoreUrl();\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","sourceOld":"  public void checkDistributed(ResponseBuilder rb) {\r\n    SolrQueryRequest req = rb.req;\r\n    SolrParams params = req.getParams();\r\n\r\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\r\n        .getCoreContainer().isZooKeeperAware());\r\n    String shards = params.get(ShardParams.SHARDS);\r\n\r\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\r\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n    \n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      CloudState cloudState = null;\r\n      Map<String,Slice> slices = null;\r\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\r\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\r\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\r\n\r\n\r\n      if (shards != null) {\r\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\r\n        rb.shards = lst.toArray(new String[lst.size()]);\r\n        rb.slices = new String[rb.shards.length];\r\n\r\n        if (zkController != null) {\r\n          // figure out which shards are slices\r\n          for (int i=0; i<rb.shards.length; i++) {\r\n            if (rb.shards[i].indexOf('/') < 0) {\r\n              // this is a logical shard\r\n              rb.slices[i] = rb.shards[i];\r\n              rb.shards[i] = null;\r\n            }\r\n          }\r\n        }\r\n      } else if (zkController != null) {\r\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\r\n\r\n        cloudState =  zkController.getCloudState();\r\n\r\n        // This can be more efficient... we only record the name, even though we\r\n        // have the shard info we need in the next step of mapping slice->shards\r\n        \r\n        // Stores the comma-separated list of specified collections.\r\n        // Eg: \"collection1,collection2,collection3\"\r\n        String collections = params.get(\"collection\");\r\n        if (collections != null) {\r\n          // If there were one or more collections specified in the query, split\r\n          // each parameter and store as a seperate member of a List.\r\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\r\n              true);\r\n          \r\n          // First create an empty HashMap to add the slice info to.\r\n          slices = new HashMap<String,Slice>();\r\n          \r\n          // In turn, retrieve the slices that cover each collection from the\r\n          // cloud state and add them to the Map 'slices'.\r\n          for (int i = 0; i < collectionList.size(); i++) {\r\n            String collection = collectionList.get(i);\r\n            ClientUtils.appendMap(collection, slices, cloudState.getSlices(collection));\r\n          }\r\n        } else {\r\n          // If no collections were specified, default to the collection for\r\n          // this core.\r\n          slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\r\n          if (slices == null) {\r\n            throw new SolrException(ErrorCode.BAD_REQUEST,\r\n                \"Could not find collection:\"\r\n                    + cloudDescriptor.getCollectionName());\r\n          }\r\n        }\r\n        \r\n        // Store the logical slices in the ResponseBuilder and create a new\r\n        // String array to hold the physical shards (which will be mapped\r\n        // later).\r\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\r\n        rb.shards = new String[rb.slices.length];\r\n\r\n        /***\r\n         rb.slices = new String[slices.size()];\r\n         for (int i=0; i<rb.slices.length; i++) {\r\n         rb.slices[i] = slices.get(i).getName();\r\n         }\r\n         ***/\r\n      }\r\n\r\n      //\r\n      // Map slices to shards\r\n      //\r\n      if (zkController != null) {\r\n        for (int i=0; i<rb.shards.length; i++) {\r\n          if (rb.shards[i] == null) {\r\n            if (cloudState == null) {\r\n              cloudState =  zkController.getCloudState();\r\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\r\n            }\r\n            String sliceName = rb.slices[i];\r\n\r\n            Slice slice = slices.get(sliceName);\r\n\r\n            if (slice==null) {\r\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\r\n              // if partial results are acceptable\r\n              rb.shards[i] = \"\";\r\n              continue;\r\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\r\n            }\r\n\r\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\r\n\r\n            // For now, recreate the | delimited list of equivalent servers\r\n            Set<String> liveNodes = cloudState.getLiveNodes();\r\n            StringBuilder sliceShardsStr = new StringBuilder();\r\n            boolean first = true;\r\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\r\n              ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\r\n              if (!liveNodes.contains(coreNodeProps.getNodeName())\r\n                  || !coreNodeProps.getState().equals(\r\n                      ZkStateReader.ACTIVE)) continue;\r\n              if (first) {\r\n                first = false;\r\n              } else {\r\n                sliceShardsStr.append('|');\r\n              }\r\n              String url = coreNodeProps.getCoreUrl();\r\n              if (url.startsWith(\"http://\"))\r\n                url = url.substring(7);\r\n              sliceShardsStr.append(url);\r\n            }\r\n\r\n            rb.shards[i] = sliceShardsStr.toString();\r\n          }\r\n        }\r\n      }\r\n    }\r\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\r\n    if(shards_rows != null) {\r\n      rb.shards_rows = Integer.parseInt(shards_rows);\r\n    }\r\n    String shards_start = params.get(ShardParams.SHARDS_START);\r\n    if(shards_start != null) {\r\n      rb.shards_start = Integer.parseInt(shards_start);\r\n    }\r\n  }\r\n\n","bugFix":null,"bugIntro":["7602e63987582091a0e432f8d8f7619d2206fab7"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3f767f8c99eaedb984df754fe61f21c5de260f94","date":1344105153,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","sourceNew":"  public void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\n        .getCoreContainer().isZooKeeperAware());\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n    \n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      ClusterState clusterState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\n\n        clusterState =  zkController.getClusterState();\n\n        // This can be more efficient... we only record the name, even though we\n        // have the shard info we need in the next step of mapping slice->shards\n        \n        // Stores the comma-separated list of specified collections.\n        // Eg: \"collection1,collection2,collection3\"\n        String collections = params.get(\"collection\");\n        if (collections != null) {\n          // If there were one or more collections specified in the query, split\n          // each parameter and store as a seperate member of a List.\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\n              true);\n          \n          // First create an empty HashMap to add the slice info to.\n          slices = new HashMap<String,Slice>();\n          \n          // In turn, retrieve the slices that cover each collection from the\n          // cloud state and add them to the Map 'slices'.\n          for (int i = 0; i < collectionList.size(); i++) {\n            String collection = collectionList.get(i);\n            ClientUtils.appendMap(collection, slices, clusterState.getSlices(collection));\n          }\n        } else {\n          // If no collections were specified, default to the collection for\n          // this core.\n          slices = clusterState.getSlices(cloudDescriptor.getCollectionName());\n          if (slices == null) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\n                \"Could not find collection:\"\n                    + cloudDescriptor.getCollectionName());\n          }\n        }\n        \n        // Store the logical slices in the ResponseBuilder and create a new\n        // String array to hold the physical shards (which will be mapped\n        // later).\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n\n        /***\n         rb.slices = new String[slices.size()];\n         for (int i=0; i<rb.slices.length; i++) {\n         rb.slices[i] = slices.get(i).getName();\n         }\n         ***/\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (clusterState == null) {\n              clusterState =  zkController.getClusterState();\n              slices = clusterState.getSlices(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\n\n            // For now, recreate the | delimited list of equivalent servers\n            Set<String> liveNodes = clusterState.getLiveNodes();\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\n              ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n              if (!liveNodes.contains(coreNodeProps.getNodeName())\n                  || !coreNodeProps.getState().equals(\n                      ZkStateReader.ACTIVE)) continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = coreNodeProps.getCoreUrl();\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","sourceOld":"  public void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\n        .getCoreContainer().isZooKeeperAware());\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n    \n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      CloudState cloudState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\n\n        cloudState =  zkController.getCloudState();\n\n        // This can be more efficient... we only record the name, even though we\n        // have the shard info we need in the next step of mapping slice->shards\n        \n        // Stores the comma-separated list of specified collections.\n        // Eg: \"collection1,collection2,collection3\"\n        String collections = params.get(\"collection\");\n        if (collections != null) {\n          // If there were one or more collections specified in the query, split\n          // each parameter and store as a seperate member of a List.\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\n              true);\n          \n          // First create an empty HashMap to add the slice info to.\n          slices = new HashMap<String,Slice>();\n          \n          // In turn, retrieve the slices that cover each collection from the\n          // cloud state and add them to the Map 'slices'.\n          for (int i = 0; i < collectionList.size(); i++) {\n            String collection = collectionList.get(i);\n            ClientUtils.appendMap(collection, slices, cloudState.getSlices(collection));\n          }\n        } else {\n          // If no collections were specified, default to the collection for\n          // this core.\n          slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n          if (slices == null) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\n                \"Could not find collection:\"\n                    + cloudDescriptor.getCollectionName());\n          }\n        }\n        \n        // Store the logical slices in the ResponseBuilder and create a new\n        // String array to hold the physical shards (which will be mapped\n        // later).\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n\n        /***\n         rb.slices = new String[slices.size()];\n         for (int i=0; i<rb.slices.length; i++) {\n         rb.slices[i] = slices.get(i).getName();\n         }\n         ***/\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (cloudState == null) {\n              cloudState =  zkController.getCloudState();\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\n\n            // For now, recreate the | delimited list of equivalent servers\n            Set<String> liveNodes = cloudState.getLiveNodes();\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\n              ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n              if (!liveNodes.contains(coreNodeProps.getNodeName())\n                  || !coreNodeProps.getState().equals(\n                      ZkStateReader.ACTIVE)) continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = coreNodeProps.getCoreUrl();\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8fd5be977c105554c6a7b68afcdbc511439723ab","date":1344115570,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","sourceNew":"  public void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\n        .getCoreContainer().isZooKeeperAware());\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n    \n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      ClusterState clusterState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\n\n        clusterState =  zkController.getClusterState();\n\n        // This can be more efficient... we only record the name, even though we\n        // have the shard info we need in the next step of mapping slice->shards\n        \n        // Stores the comma-separated list of specified collections.\n        // Eg: \"collection1,collection2,collection3\"\n        String collections = params.get(\"collection\");\n        if (collections != null) {\n          // If there were one or more collections specified in the query, split\n          // each parameter and store as a seperate member of a List.\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\n              true);\n          \n          // First create an empty HashMap to add the slice info to.\n          slices = new HashMap<String,Slice>();\n          \n          // In turn, retrieve the slices that cover each collection from the\n          // cloud state and add them to the Map 'slices'.\n          for (int i = 0; i < collectionList.size(); i++) {\n            String collection = collectionList.get(i);\n            ClientUtils.appendMap(collection, slices, clusterState.getSlices(collection));\n          }\n        } else {\n          // If no collections were specified, default to the collection for\n          // this core.\n          slices = clusterState.getSlices(cloudDescriptor.getCollectionName());\n          if (slices == null) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\n                \"Could not find collection:\"\n                    + cloudDescriptor.getCollectionName());\n          }\n        }\n        \n        // Store the logical slices in the ResponseBuilder and create a new\n        // String array to hold the physical shards (which will be mapped\n        // later).\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n\n        /***\n         rb.slices = new String[slices.size()];\n         for (int i=0; i<rb.slices.length; i++) {\n         rb.slices[i] = slices.get(i).getName();\n         }\n         ***/\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (clusterState == null) {\n              clusterState =  zkController.getClusterState();\n              slices = clusterState.getSlices(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\n\n            // For now, recreate the | delimited list of equivalent servers\n            Set<String> liveNodes = clusterState.getLiveNodes();\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\n              ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n              if (!liveNodes.contains(coreNodeProps.getNodeName())\n                  || !coreNodeProps.getState().equals(\n                      ZkStateReader.ACTIVE)) continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = coreNodeProps.getCoreUrl();\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","sourceOld":"  public void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\n        .getCoreContainer().isZooKeeperAware());\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n    \n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      CloudState cloudState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\n\n        cloudState =  zkController.getCloudState();\n\n        // This can be more efficient... we only record the name, even though we\n        // have the shard info we need in the next step of mapping slice->shards\n        \n        // Stores the comma-separated list of specified collections.\n        // Eg: \"collection1,collection2,collection3\"\n        String collections = params.get(\"collection\");\n        if (collections != null) {\n          // If there were one or more collections specified in the query, split\n          // each parameter and store as a seperate member of a List.\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\n              true);\n          \n          // First create an empty HashMap to add the slice info to.\n          slices = new HashMap<String,Slice>();\n          \n          // In turn, retrieve the slices that cover each collection from the\n          // cloud state and add them to the Map 'slices'.\n          for (int i = 0; i < collectionList.size(); i++) {\n            String collection = collectionList.get(i);\n            ClientUtils.appendMap(collection, slices, cloudState.getSlices(collection));\n          }\n        } else {\n          // If no collections were specified, default to the collection for\n          // this core.\n          slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n          if (slices == null) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\n                \"Could not find collection:\"\n                    + cloudDescriptor.getCollectionName());\n          }\n        }\n        \n        // Store the logical slices in the ResponseBuilder and create a new\n        // String array to hold the physical shards (which will be mapped\n        // later).\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n\n        /***\n         rb.slices = new String[slices.size()];\n         for (int i=0; i<rb.slices.length; i++) {\n         rb.slices[i] = slices.get(i).getName();\n         }\n         ***/\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (cloudState == null) {\n              cloudState =  zkController.getCloudState();\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\n\n            // For now, recreate the | delimited list of equivalent servers\n            Set<String> liveNodes = cloudState.getLiveNodes();\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\n              ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n              if (!liveNodes.contains(coreNodeProps.getNodeName())\n                  || !coreNodeProps.getState().equals(\n                      ZkStateReader.ACTIVE)) continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = coreNodeProps.getCoreUrl();\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","sourceNew":"  public void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\n        .getCoreContainer().isZooKeeperAware());\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n    \n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      ClusterState clusterState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\n\n        clusterState =  zkController.getClusterState();\n\n        // This can be more efficient... we only record the name, even though we\n        // have the shard info we need in the next step of mapping slice->shards\n        \n        // Stores the comma-separated list of specified collections.\n        // Eg: \"collection1,collection2,collection3\"\n        String collections = params.get(\"collection\");\n        if (collections != null) {\n          // If there were one or more collections specified in the query, split\n          // each parameter and store as a seperate member of a List.\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\n              true);\n          \n          // First create an empty HashMap to add the slice info to.\n          slices = new HashMap<String,Slice>();\n          \n          // In turn, retrieve the slices that cover each collection from the\n          // cloud state and add them to the Map 'slices'.\n          for (int i = 0; i < collectionList.size(); i++) {\n            String collection = collectionList.get(i);\n            ClientUtils.appendMap(collection, slices, clusterState.getSlices(collection));\n          }\n        } else {\n          // If no collections were specified, default to the collection for\n          // this core.\n          slices = clusterState.getSlices(cloudDescriptor.getCollectionName());\n          if (slices == null) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\n                \"Could not find collection:\"\n                    + cloudDescriptor.getCollectionName());\n          }\n        }\n        \n        // Store the logical slices in the ResponseBuilder and create a new\n        // String array to hold the physical shards (which will be mapped\n        // later).\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n\n        /***\n         rb.slices = new String[slices.size()];\n         for (int i=0; i<rb.slices.length; i++) {\n         rb.slices[i] = slices.get(i).getName();\n         }\n         ***/\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (clusterState == null) {\n              clusterState =  zkController.getClusterState();\n              slices = clusterState.getSlices(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\n\n            // For now, recreate the | delimited list of equivalent servers\n            Set<String> liveNodes = clusterState.getLiveNodes();\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\n              ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n              if (!liveNodes.contains(coreNodeProps.getNodeName())\n                  || !coreNodeProps.getState().equals(\n                      ZkStateReader.ACTIVE)) continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = coreNodeProps.getCoreUrl();\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","sourceOld":"  public void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\n        .getCoreContainer().isZooKeeperAware());\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n    \n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      CloudState cloudState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\n\n        cloudState =  zkController.getCloudState();\n\n        // This can be more efficient... we only record the name, even though we\n        // have the shard info we need in the next step of mapping slice->shards\n        \n        // Stores the comma-separated list of specified collections.\n        // Eg: \"collection1,collection2,collection3\"\n        String collections = params.get(\"collection\");\n        if (collections != null) {\n          // If there were one or more collections specified in the query, split\n          // each parameter and store as a seperate member of a List.\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\n              true);\n          \n          // First create an empty HashMap to add the slice info to.\n          slices = new HashMap<String,Slice>();\n          \n          // In turn, retrieve the slices that cover each collection from the\n          // cloud state and add them to the Map 'slices'.\n          for (int i = 0; i < collectionList.size(); i++) {\n            String collection = collectionList.get(i);\n            ClientUtils.appendMap(collection, slices, cloudState.getSlices(collection));\n          }\n        } else {\n          // If no collections were specified, default to the collection for\n          // this core.\n          slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n          if (slices == null) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\n                \"Could not find collection:\"\n                    + cloudDescriptor.getCollectionName());\n          }\n        }\n        \n        // Store the logical slices in the ResponseBuilder and create a new\n        // String array to hold the physical shards (which will be mapped\n        // later).\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n\n        /***\n         rb.slices = new String[slices.size()];\n         for (int i=0; i<rb.slices.length; i++) {\n         rb.slices[i] = slices.get(i).getName();\n         }\n         ***/\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (cloudState == null) {\n              cloudState =  zkController.getCloudState();\n              slices = cloudState.getSlices(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\n\n            // For now, recreate the | delimited list of equivalent servers\n            Set<String> liveNodes = cloudState.getLiveNodes();\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\n              ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n              if (!liveNodes.contains(coreNodeProps.getNodeName())\n                  || !coreNodeProps.getState().equals(\n                      ZkStateReader.ACTIVE)) continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = coreNodeProps.getCoreUrl();\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fa64435b5902ce266c23755a4a00691a3285dab8","date":1347243290,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","sourceNew":"  public void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\n        .getCoreContainer().isZooKeeperAware());\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n    \n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      ClusterState clusterState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\n\n        clusterState =  zkController.getClusterState();\n\n        // This can be more efficient... we only record the name, even though we\n        // have the shard info we need in the next step of mapping slice->shards\n        \n        // Stores the comma-separated list of specified collections.\n        // Eg: \"collection1,collection2,collection3\"\n        String collections = params.get(\"collection\");\n        if (collections != null) {\n          // If there were one or more collections specified in the query, split\n          // each parameter and store as a seperate member of a List.\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\n              true);\n          \n          // First create an empty HashMap to add the slice info to.\n          slices = new HashMap<String,Slice>();\n          \n          // In turn, retrieve the slices that cover each collection from the\n          // cloud state and add them to the Map 'slices'.\n          for (int i = 0; i < collectionList.size(); i++) {\n            String collection = collectionList.get(i);\n            ClientUtils.appendMap(collection, slices, clusterState.getSlices(collection));\n          }\n        } else {\n          // If no collections were specified, default to the collection for\n          // this core.\n          slices = clusterState.getSlices(cloudDescriptor.getCollectionName());\n          if (slices == null) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\n                \"Could not find collection:\"\n                    + cloudDescriptor.getCollectionName());\n          }\n        }\n        \n        // Store the logical slices in the ResponseBuilder and create a new\n        // String array to hold the physical shards (which will be mapped\n        // later).\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n\n        /***\n         rb.slices = new String[slices.size()];\n         for (int i=0; i<rb.slices.length; i++) {\n         rb.slices[i] = slices.get(i).getName();\n         }\n         ***/\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (clusterState == null) {\n              clusterState =  zkController.getClusterState();\n              slices = clusterState.getSlices(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, Replica> sliceShards = slice.getReplicasMap();\n\n            // For now, recreate the | delimited list of equivalent servers\n            Set<String> liveNodes = clusterState.getLiveNodes();\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\n              ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n              if (!liveNodes.contains(coreNodeProps.getNodeName())\n                  || !coreNodeProps.getState().equals(\n                      ZkStateReader.ACTIVE)) continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = coreNodeProps.getCoreUrl();\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","sourceOld":"  public void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\n        .getCoreContainer().isZooKeeperAware());\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n    \n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      ClusterState clusterState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\n\n        clusterState =  zkController.getClusterState();\n\n        // This can be more efficient... we only record the name, even though we\n        // have the shard info we need in the next step of mapping slice->shards\n        \n        // Stores the comma-separated list of specified collections.\n        // Eg: \"collection1,collection2,collection3\"\n        String collections = params.get(\"collection\");\n        if (collections != null) {\n          // If there were one or more collections specified in the query, split\n          // each parameter and store as a seperate member of a List.\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\n              true);\n          \n          // First create an empty HashMap to add the slice info to.\n          slices = new HashMap<String,Slice>();\n          \n          // In turn, retrieve the slices that cover each collection from the\n          // cloud state and add them to the Map 'slices'.\n          for (int i = 0; i < collectionList.size(); i++) {\n            String collection = collectionList.get(i);\n            ClientUtils.appendMap(collection, slices, clusterState.getSlices(collection));\n          }\n        } else {\n          // If no collections were specified, default to the collection for\n          // this core.\n          slices = clusterState.getSlices(cloudDescriptor.getCollectionName());\n          if (slices == null) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\n                \"Could not find collection:\"\n                    + cloudDescriptor.getCollectionName());\n          }\n        }\n        \n        // Store the logical slices in the ResponseBuilder and create a new\n        // String array to hold the physical shards (which will be mapped\n        // later).\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n\n        /***\n         rb.slices = new String[slices.size()];\n         for (int i=0; i<rb.slices.length; i++) {\n         rb.slices[i] = slices.get(i).getName();\n         }\n         ***/\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (clusterState == null) {\n              clusterState =  zkController.getClusterState();\n              slices = clusterState.getSlices(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, ZkNodeProps> sliceShards = slice.getShards();\n\n            // For now, recreate the | delimited list of equivalent servers\n            Set<String> liveNodes = clusterState.getLiveNodes();\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\n              ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n              if (!liveNodes.contains(coreNodeProps.getNodeName())\n                  || !coreNodeProps.getState().equals(\n                      ZkStateReader.ACTIVE)) continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = coreNodeProps.getCoreUrl();\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c5a558d54519c651068ddb202f03befefb1514a7","date":1354382006,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","sourceNew":"  public void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\n        .getCoreContainer().isZooKeeperAware());\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n    \n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      ClusterState clusterState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\n\n        clusterState =  zkController.getClusterState();\n\n        // This can be more efficient... we only record the name, even though we\n        // have the shard info we need in the next step of mapping slice->shards\n        \n        // Stores the comma-separated list of specified collections.\n        // Eg: \"collection1,collection2,collection3\"\n        String collections = params.get(\"collection\");\n        if (collections != null) {\n          // If there were one or more collections specified in the query, split\n          // each parameter and store as a seperate member of a List.\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\n              true);\n          \n          // First create an empty HashMap to add the slice info to.\n          slices = new HashMap<String,Slice>();\n          \n          // In turn, retrieve the slices that cover each collection from the\n          // cloud state and add them to the Map 'slices'.\n          for (int i = 0; i < collectionList.size(); i++) {\n            String collection = collectionList.get(i);\n            ClientUtils.appendMap(collection, slices, clusterState.getSlicesMap(collection));\n          }\n        } else {\n          // If no collections were specified, default to the collection for\n          // this core.\n          slices = clusterState.getSlicesMap(cloudDescriptor.getCollectionName());\n          if (slices == null) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\n                \"Could not find collection:\"\n                    + cloudDescriptor.getCollectionName());\n          }\n        }\n        \n        // Store the logical slices in the ResponseBuilder and create a new\n        // String array to hold the physical shards (which will be mapped\n        // later).\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n\n        /***\n         rb.slices = new String[slices.size()];\n         for (int i=0; i<rb.slices.length; i++) {\n         rb.slices[i] = slices.get(i).getName();\n         }\n         ***/\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (clusterState == null) {\n              clusterState =  zkController.getClusterState();\n              slices = clusterState.getSlicesMap(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, Replica> sliceShards = slice.getReplicasMap();\n\n            // For now, recreate the | delimited list of equivalent servers\n            Set<String> liveNodes = clusterState.getLiveNodes();\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\n              ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n              if (!liveNodes.contains(coreNodeProps.getNodeName())\n                  || !coreNodeProps.getState().equals(\n                      ZkStateReader.ACTIVE)) continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = coreNodeProps.getCoreUrl();\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","sourceOld":"  public void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\n        .getCoreContainer().isZooKeeperAware());\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n    \n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      ClusterState clusterState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\n\n        clusterState =  zkController.getClusterState();\n\n        // This can be more efficient... we only record the name, even though we\n        // have the shard info we need in the next step of mapping slice->shards\n        \n        // Stores the comma-separated list of specified collections.\n        // Eg: \"collection1,collection2,collection3\"\n        String collections = params.get(\"collection\");\n        if (collections != null) {\n          // If there were one or more collections specified in the query, split\n          // each parameter and store as a seperate member of a List.\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\n              true);\n          \n          // First create an empty HashMap to add the slice info to.\n          slices = new HashMap<String,Slice>();\n          \n          // In turn, retrieve the slices that cover each collection from the\n          // cloud state and add them to the Map 'slices'.\n          for (int i = 0; i < collectionList.size(); i++) {\n            String collection = collectionList.get(i);\n            ClientUtils.appendMap(collection, slices, clusterState.getSlices(collection));\n          }\n        } else {\n          // If no collections were specified, default to the collection for\n          // this core.\n          slices = clusterState.getSlices(cloudDescriptor.getCollectionName());\n          if (slices == null) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\n                \"Could not find collection:\"\n                    + cloudDescriptor.getCollectionName());\n          }\n        }\n        \n        // Store the logical slices in the ResponseBuilder and create a new\n        // String array to hold the physical shards (which will be mapped\n        // later).\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n\n        /***\n         rb.slices = new String[slices.size()];\n         for (int i=0; i<rb.slices.length; i++) {\n         rb.slices[i] = slices.get(i).getName();\n         }\n         ***/\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (clusterState == null) {\n              clusterState =  zkController.getClusterState();\n              slices = clusterState.getSlices(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, Replica> sliceShards = slice.getReplicasMap();\n\n            // For now, recreate the | delimited list of equivalent servers\n            Set<String> liveNodes = clusterState.getLiveNodes();\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\n              ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n              if (!liveNodes.contains(coreNodeProps.getNodeName())\n                  || !coreNodeProps.getState().equals(\n                      ZkStateReader.ACTIVE)) continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = coreNodeProps.getCoreUrl();\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e7754464847b06ced605515bd48219280ede29e9","date":1354586462,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","sourceNew":"  public void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\n        .getCoreContainer().isZooKeeperAware());\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n    \n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      ClusterState clusterState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with an explicit list of slices to query via \"shards\", so use the cluster state\n\n        clusterState =  zkController.getClusterState();\n        String shardKeys = params.get(ShardParams.SHARD_KEYS);\n\n        // This will be the complete list of slices we need to query for this request.\n        slices = new HashMap<String,Slice>();\n\n        // we need to find out what collections this request is for.\n\n        // A comma-separated list of specified collections.\n        // Eg: \"collection1,collection2,collection3\"\n        String collections = params.get(\"collection\");\n        if (collections != null) {\n          // If there were one or more collections specified in the query, split\n          // each parameter and store as a seperate member of a List.\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\n              true);\n          // In turn, retrieve the slices that cover each collection from the\n          // cloud state and add them to the Map 'slices'.\n          for (String collectionName : collectionList) {\n            DocCollection coll = clusterState.getCollection(collectionName);\n            // The original code produced <collection-name>_<shard-name> when the collections\n            // parameter was specified (see ClientUtils.appendMap)\n            // Is this necessary if ony one collection is specified?\n            // i.e. should we change multiCollection to collectionList.size() > 1?\n            addSlices(slices, clusterState, params, collectionName,  shardKeys, true);\n          }\n        } else {\n          // just this collection\n          String collectionName = cloudDescriptor.getCollectionName();\n          DocCollection coll = clusterState.getCollection(cloudDescriptor.getCollectionName());\n          addSlices(slices, clusterState, params, collectionName,  shardKeys, false);\n        }\n\n        \n        // Store the logical slices in the ResponseBuilder and create a new\n        // String array to hold the physical shards (which will be mapped\n        // later).\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n\n        /***\n         rb.slices = new String[slices.size()];\n         for (int i=0; i<rb.slices.length; i++) {\n         rb.slices[i] = slices.get(i).getName();\n         }\n         ***/\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (clusterState == null) {\n              clusterState =  zkController.getClusterState();\n              slices = clusterState.getSlicesMap(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, Replica> sliceShards = slice.getReplicasMap();\n\n            // For now, recreate the | delimited list of equivalent servers\n            Set<String> liveNodes = clusterState.getLiveNodes();\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\n              ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n              if (!liveNodes.contains(coreNodeProps.getNodeName())\n                  || !coreNodeProps.getState().equals(\n                      ZkStateReader.ACTIVE)) continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = coreNodeProps.getCoreUrl();\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","sourceOld":"  public void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\n        .getCoreContainer().isZooKeeperAware());\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n    \n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      ClusterState clusterState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\n\n        clusterState =  zkController.getClusterState();\n\n        // This can be more efficient... we only record the name, even though we\n        // have the shard info we need in the next step of mapping slice->shards\n        \n        // Stores the comma-separated list of specified collections.\n        // Eg: \"collection1,collection2,collection3\"\n        String collections = params.get(\"collection\");\n        if (collections != null) {\n          // If there were one or more collections specified in the query, split\n          // each parameter and store as a seperate member of a List.\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\n              true);\n          \n          // First create an empty HashMap to add the slice info to.\n          slices = new HashMap<String,Slice>();\n          \n          // In turn, retrieve the slices that cover each collection from the\n          // cloud state and add them to the Map 'slices'.\n          for (int i = 0; i < collectionList.size(); i++) {\n            String collection = collectionList.get(i);\n            ClientUtils.appendMap(collection, slices, clusterState.getSlicesMap(collection));\n          }\n        } else {\n          // If no collections were specified, default to the collection for\n          // this core.\n          slices = clusterState.getSlicesMap(cloudDescriptor.getCollectionName());\n          if (slices == null) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\n                \"Could not find collection:\"\n                    + cloudDescriptor.getCollectionName());\n          }\n        }\n        \n        // Store the logical slices in the ResponseBuilder and create a new\n        // String array to hold the physical shards (which will be mapped\n        // later).\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n\n        /***\n         rb.slices = new String[slices.size()];\n         for (int i=0; i<rb.slices.length; i++) {\n         rb.slices[i] = slices.get(i).getName();\n         }\n         ***/\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (clusterState == null) {\n              clusterState =  zkController.getClusterState();\n              slices = clusterState.getSlicesMap(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, Replica> sliceShards = slice.getReplicasMap();\n\n            // For now, recreate the | delimited list of equivalent servers\n            Set<String> liveNodes = clusterState.getLiveNodes();\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\n              ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n              if (!liveNodes.contains(coreNodeProps.getNodeName())\n                  || !coreNodeProps.getState().equals(\n                      ZkStateReader.ACTIVE)) continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = coreNodeProps.getCoreUrl();\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"60eb5eeae4d0ae8321b30a826435b6106634c09b","date":1354819356,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","sourceNew":"  public void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\n        .getCoreContainer().isZooKeeperAware());\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n    \n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      ClusterState clusterState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with an explicit list of slices to query via \"shards\", so use the cluster state\n\n        clusterState =  zkController.getClusterState();\n        String shardKeys = params.get(ShardParams.SHARD_KEYS);\n\n        // This will be the complete list of slices we need to query for this request.\n        slices = new HashMap<String,Slice>();\n\n        // we need to find out what collections this request is for.\n\n        // A comma-separated list of specified collections.\n        // Eg: \"collection1,collection2,collection3\"\n        String collections = params.get(\"collection\");\n        if (collections != null) {\n          // If there were one or more collections specified in the query, split\n          // each parameter and store as a seperate member of a List.\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\n              true);\n          // In turn, retrieve the slices that cover each collection from the\n          // cloud state and add them to the Map 'slices'.\n          for (String collectionName : collectionList) {\n            // The original code produced <collection-name>_<shard-name> when the collections\n            // parameter was specified (see ClientUtils.appendMap)\n            // Is this necessary if ony one collection is specified?\n            // i.e. should we change multiCollection to collectionList.size() > 1?\n            addSlices(slices, clusterState, params, collectionName,  shardKeys, true);\n          }\n        } else {\n          // just this collection\n          String collectionName = cloudDescriptor.getCollectionName();\n          addSlices(slices, clusterState, params, collectionName,  shardKeys, false);\n        }\n\n        \n        // Store the logical slices in the ResponseBuilder and create a new\n        // String array to hold the physical shards (which will be mapped\n        // later).\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n\n        // Are we hosting the shard that this request is for, and are we active? If so, then handle it ourselves\n        // and make it a non-distributed request.\n        String ourSlice = cloudDescriptor.getShardId();\n        String ourCollection = cloudDescriptor.getCollectionName();\n        if (rb.slices.length == 1\n            && ( rb.slices[0].equals(ourSlice) || rb.slices[0].equals(ourCollection + \"_\" + ourSlice) )  // handle the <collection>_<slice> format\n            && ZkStateReader.ACTIVE.equals(cloudDescriptor.getLastPublished()) )\n        {\n          boolean shortCircuit = params.getBool(\"shortCircuit\", true);       // currently just a debugging parameter to check distrib search on a single node\n\n          String targetHandler = params.get(ShardParams.SHARDS_QT);\n          shortCircuit = shortCircuit && targetHandler == null;             // if a different handler is specified, don't short-circuit\n\n          if (shortCircuit) {\n            rb.isDistrib = false;\n            return;\n          }\n          // We shouldn't need to do anything to handle \"shard.rows\" since it was previously meant to be an optimization?\n        }\n\n\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (clusterState == null) {\n              clusterState =  zkController.getClusterState();\n              slices = clusterState.getSlicesMap(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, Replica> sliceShards = slice.getReplicasMap();\n\n            // For now, recreate the | delimited list of equivalent servers\n            Set<String> liveNodes = clusterState.getLiveNodes();\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\n              ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n              if (!liveNodes.contains(coreNodeProps.getNodeName())\n                  || !coreNodeProps.getState().equals(\n                      ZkStateReader.ACTIVE)) continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = coreNodeProps.getCoreUrl();\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","sourceOld":"  public void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\n        .getCoreContainer().isZooKeeperAware());\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n    \n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      ClusterState clusterState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with an explicit list of slices to query via \"shards\", so use the cluster state\n\n        clusterState =  zkController.getClusterState();\n        String shardKeys = params.get(ShardParams.SHARD_KEYS);\n\n        // This will be the complete list of slices we need to query for this request.\n        slices = new HashMap<String,Slice>();\n\n        // we need to find out what collections this request is for.\n\n        // A comma-separated list of specified collections.\n        // Eg: \"collection1,collection2,collection3\"\n        String collections = params.get(\"collection\");\n        if (collections != null) {\n          // If there were one or more collections specified in the query, split\n          // each parameter and store as a seperate member of a List.\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\n              true);\n          // In turn, retrieve the slices that cover each collection from the\n          // cloud state and add them to the Map 'slices'.\n          for (String collectionName : collectionList) {\n            DocCollection coll = clusterState.getCollection(collectionName);\n            // The original code produced <collection-name>_<shard-name> when the collections\n            // parameter was specified (see ClientUtils.appendMap)\n            // Is this necessary if ony one collection is specified?\n            // i.e. should we change multiCollection to collectionList.size() > 1?\n            addSlices(slices, clusterState, params, collectionName,  shardKeys, true);\n          }\n        } else {\n          // just this collection\n          String collectionName = cloudDescriptor.getCollectionName();\n          DocCollection coll = clusterState.getCollection(cloudDescriptor.getCollectionName());\n          addSlices(slices, clusterState, params, collectionName,  shardKeys, false);\n        }\n\n        \n        // Store the logical slices in the ResponseBuilder and create a new\n        // String array to hold the physical shards (which will be mapped\n        // later).\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n\n        /***\n         rb.slices = new String[slices.size()];\n         for (int i=0; i<rb.slices.length; i++) {\n         rb.slices[i] = slices.get(i).getName();\n         }\n         ***/\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (clusterState == null) {\n              clusterState =  zkController.getClusterState();\n              slices = clusterState.getSlicesMap(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, Replica> sliceShards = slice.getReplicasMap();\n\n            // For now, recreate the | delimited list of equivalent servers\n            Set<String> liveNodes = clusterState.getLiveNodes();\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\n              ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n              if (!liveNodes.contains(coreNodeProps.getNodeName())\n                  || !coreNodeProps.getState().equals(\n                      ZkStateReader.ACTIVE)) continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = coreNodeProps.getCoreUrl();\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","sourceNew":"  public void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\n        .getCoreContainer().isZooKeeperAware());\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n    \n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      ClusterState clusterState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with an explicit list of slices to query via \"shards\", so use the cluster state\n\n        clusterState =  zkController.getClusterState();\n        String shardKeys = params.get(ShardParams.SHARD_KEYS);\n\n        // This will be the complete list of slices we need to query for this request.\n        slices = new HashMap<String,Slice>();\n\n        // we need to find out what collections this request is for.\n\n        // A comma-separated list of specified collections.\n        // Eg: \"collection1,collection2,collection3\"\n        String collections = params.get(\"collection\");\n        if (collections != null) {\n          // If there were one or more collections specified in the query, split\n          // each parameter and store as a seperate member of a List.\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\n              true);\n          // In turn, retrieve the slices that cover each collection from the\n          // cloud state and add them to the Map 'slices'.\n          for (String collectionName : collectionList) {\n            // The original code produced <collection-name>_<shard-name> when the collections\n            // parameter was specified (see ClientUtils.appendMap)\n            // Is this necessary if ony one collection is specified?\n            // i.e. should we change multiCollection to collectionList.size() > 1?\n            addSlices(slices, clusterState, params, collectionName,  shardKeys, true);\n          }\n        } else {\n          // just this collection\n          String collectionName = cloudDescriptor.getCollectionName();\n          addSlices(slices, clusterState, params, collectionName,  shardKeys, false);\n        }\n\n        \n        // Store the logical slices in the ResponseBuilder and create a new\n        // String array to hold the physical shards (which will be mapped\n        // later).\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n\n        // Are we hosting the shard that this request is for, and are we active? If so, then handle it ourselves\n        // and make it a non-distributed request.\n        String ourSlice = cloudDescriptor.getShardId();\n        String ourCollection = cloudDescriptor.getCollectionName();\n        if (rb.slices.length == 1\n            && ( rb.slices[0].equals(ourSlice) || rb.slices[0].equals(ourCollection + \"_\" + ourSlice) )  // handle the <collection>_<slice> format\n            && ZkStateReader.ACTIVE.equals(cloudDescriptor.getLastPublished()) )\n        {\n          boolean shortCircuit = params.getBool(\"shortCircuit\", true);       // currently just a debugging parameter to check distrib search on a single node\n\n          String targetHandler = params.get(ShardParams.SHARDS_QT);\n          shortCircuit = shortCircuit && targetHandler == null;             // if a different handler is specified, don't short-circuit\n\n          if (shortCircuit) {\n            rb.isDistrib = false;\n            return;\n          }\n          // We shouldn't need to do anything to handle \"shard.rows\" since it was previously meant to be an optimization?\n        }\n\n\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (clusterState == null) {\n              clusterState =  zkController.getClusterState();\n              slices = clusterState.getSlicesMap(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, Replica> sliceShards = slice.getReplicasMap();\n\n            // For now, recreate the | delimited list of equivalent servers\n            Set<String> liveNodes = clusterState.getLiveNodes();\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\n              ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n              if (!liveNodes.contains(coreNodeProps.getNodeName())\n                  || !coreNodeProps.getState().equals(\n                      ZkStateReader.ACTIVE)) continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = coreNodeProps.getCoreUrl();\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","sourceOld":"  public void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\n        .getCoreContainer().isZooKeeperAware());\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n    \n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      ClusterState clusterState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with a list of slices to query, so find the list that will cover the complete index\n\n        clusterState =  zkController.getClusterState();\n\n        // This can be more efficient... we only record the name, even though we\n        // have the shard info we need in the next step of mapping slice->shards\n        \n        // Stores the comma-separated list of specified collections.\n        // Eg: \"collection1,collection2,collection3\"\n        String collections = params.get(\"collection\");\n        if (collections != null) {\n          // If there were one or more collections specified in the query, split\n          // each parameter and store as a seperate member of a List.\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\n              true);\n          \n          // First create an empty HashMap to add the slice info to.\n          slices = new HashMap<String,Slice>();\n          \n          // In turn, retrieve the slices that cover each collection from the\n          // cloud state and add them to the Map 'slices'.\n          for (int i = 0; i < collectionList.size(); i++) {\n            String collection = collectionList.get(i);\n            ClientUtils.appendMap(collection, slices, clusterState.getSlices(collection));\n          }\n        } else {\n          // If no collections were specified, default to the collection for\n          // this core.\n          slices = clusterState.getSlices(cloudDescriptor.getCollectionName());\n          if (slices == null) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\n                \"Could not find collection:\"\n                    + cloudDescriptor.getCollectionName());\n          }\n        }\n        \n        // Store the logical slices in the ResponseBuilder and create a new\n        // String array to hold the physical shards (which will be mapped\n        // later).\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n\n        /***\n         rb.slices = new String[slices.size()];\n         for (int i=0; i<rb.slices.length; i++) {\n         rb.slices[i] = slices.get(i).getName();\n         }\n         ***/\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (clusterState == null) {\n              clusterState =  zkController.getClusterState();\n              slices = clusterState.getSlices(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, Replica> sliceShards = slice.getReplicasMap();\n\n            // For now, recreate the | delimited list of equivalent servers\n            Set<String> liveNodes = clusterState.getLiveNodes();\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\n              ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n              if (!liveNodes.contains(coreNodeProps.getNodeName())\n                  || !coreNodeProps.getState().equals(\n                      ZkStateReader.ACTIVE)) continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = coreNodeProps.getCoreUrl();\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7530de27b87b961b51f01bd1299b7004d46e8823","date":1355236261,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\n        .getCoreContainer().isZooKeeperAware());\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n    \n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      ClusterState clusterState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with an explicit list of slices to query via \"shards\", so use the cluster state\n\n        clusterState =  zkController.getClusterState();\n        String shardKeys = params.get(ShardParams.SHARD_KEYS);\n\n        // This will be the complete list of slices we need to query for this request.\n        slices = new HashMap<String,Slice>();\n\n        // we need to find out what collections this request is for.\n\n        // A comma-separated list of specified collections.\n        // Eg: \"collection1,collection2,collection3\"\n        String collections = params.get(\"collection\");\n        if (collections != null) {\n          // If there were one or more collections specified in the query, split\n          // each parameter and store as a seperate member of a List.\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\n              true);\n          // In turn, retrieve the slices that cover each collection from the\n          // cloud state and add them to the Map 'slices'.\n          for (String collectionName : collectionList) {\n            // The original code produced <collection-name>_<shard-name> when the collections\n            // parameter was specified (see ClientUtils.appendMap)\n            // Is this necessary if ony one collection is specified?\n            // i.e. should we change multiCollection to collectionList.size() > 1?\n            addSlices(slices, clusterState, params, collectionName,  shardKeys, true);\n          }\n        } else {\n          // just this collection\n          String collectionName = cloudDescriptor.getCollectionName();\n          addSlices(slices, clusterState, params, collectionName,  shardKeys, false);\n        }\n\n        \n        // Store the logical slices in the ResponseBuilder and create a new\n        // String array to hold the physical shards (which will be mapped\n        // later).\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n\n        // Are we hosting the shard that this request is for, and are we active? If so, then handle it ourselves\n        // and make it a non-distributed request.\n        String ourSlice = cloudDescriptor.getShardId();\n        String ourCollection = cloudDescriptor.getCollectionName();\n        if (rb.slices.length == 1\n            && ( rb.slices[0].equals(ourSlice) || rb.slices[0].equals(ourCollection + \"_\" + ourSlice) )  // handle the <collection>_<slice> format\n            && ZkStateReader.ACTIVE.equals(cloudDescriptor.getLastPublished()) )\n        {\n          boolean shortCircuit = params.getBool(\"shortCircuit\", true);       // currently just a debugging parameter to check distrib search on a single node\n\n          String targetHandler = params.get(ShardParams.SHARDS_QT);\n          shortCircuit = shortCircuit && targetHandler == null;             // if a different handler is specified, don't short-circuit\n\n          if (shortCircuit) {\n            rb.isDistrib = false;\n            return;\n          }\n          // We shouldn't need to do anything to handle \"shard.rows\" since it was previously meant to be an optimization?\n        }\n\n\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (clusterState == null) {\n              clusterState =  zkController.getClusterState();\n              slices = clusterState.getSlicesMap(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, Replica> sliceShards = slice.getReplicasMap();\n\n            // For now, recreate the | delimited list of equivalent servers\n            Set<String> liveNodes = clusterState.getLiveNodes();\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\n              ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n              if (!liveNodes.contains(coreNodeProps.getNodeName())\n                  || !coreNodeProps.getState().equals(\n                      ZkStateReader.ACTIVE)) continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = coreNodeProps.getCoreUrl();\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","sourceOld":"  public void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\n        .getCoreContainer().isZooKeeperAware());\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n    \n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      ClusterState clusterState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with an explicit list of slices to query via \"shards\", so use the cluster state\n\n        clusterState =  zkController.getClusterState();\n        String shardKeys = params.get(ShardParams.SHARD_KEYS);\n\n        // This will be the complete list of slices we need to query for this request.\n        slices = new HashMap<String,Slice>();\n\n        // we need to find out what collections this request is for.\n\n        // A comma-separated list of specified collections.\n        // Eg: \"collection1,collection2,collection3\"\n        String collections = params.get(\"collection\");\n        if (collections != null) {\n          // If there were one or more collections specified in the query, split\n          // each parameter and store as a seperate member of a List.\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\n              true);\n          // In turn, retrieve the slices that cover each collection from the\n          // cloud state and add them to the Map 'slices'.\n          for (String collectionName : collectionList) {\n            // The original code produced <collection-name>_<shard-name> when the collections\n            // parameter was specified (see ClientUtils.appendMap)\n            // Is this necessary if ony one collection is specified?\n            // i.e. should we change multiCollection to collectionList.size() > 1?\n            addSlices(slices, clusterState, params, collectionName,  shardKeys, true);\n          }\n        } else {\n          // just this collection\n          String collectionName = cloudDescriptor.getCollectionName();\n          addSlices(slices, clusterState, params, collectionName,  shardKeys, false);\n        }\n\n        \n        // Store the logical slices in the ResponseBuilder and create a new\n        // String array to hold the physical shards (which will be mapped\n        // later).\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n\n        // Are we hosting the shard that this request is for, and are we active? If so, then handle it ourselves\n        // and make it a non-distributed request.\n        String ourSlice = cloudDescriptor.getShardId();\n        String ourCollection = cloudDescriptor.getCollectionName();\n        if (rb.slices.length == 1\n            && ( rb.slices[0].equals(ourSlice) || rb.slices[0].equals(ourCollection + \"_\" + ourSlice) )  // handle the <collection>_<slice> format\n            && ZkStateReader.ACTIVE.equals(cloudDescriptor.getLastPublished()) )\n        {\n          boolean shortCircuit = params.getBool(\"shortCircuit\", true);       // currently just a debugging parameter to check distrib search on a single node\n\n          String targetHandler = params.get(ShardParams.SHARDS_QT);\n          shortCircuit = shortCircuit && targetHandler == null;             // if a different handler is specified, don't short-circuit\n\n          if (shortCircuit) {\n            rb.isDistrib = false;\n            return;\n          }\n          // We shouldn't need to do anything to handle \"shard.rows\" since it was previously meant to be an optimization?\n        }\n\n\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (clusterState == null) {\n              clusterState =  zkController.getClusterState();\n              slices = clusterState.getSlicesMap(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, Replica> sliceShards = slice.getReplicasMap();\n\n            // For now, recreate the | delimited list of equivalent servers\n            Set<String> liveNodes = clusterState.getLiveNodes();\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\n              ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n              if (!liveNodes.contains(coreNodeProps.getNodeName())\n                  || !coreNodeProps.getState().equals(\n                      ZkStateReader.ACTIVE)) continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = coreNodeProps.getCoreUrl();\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\n        .getCoreContainer().isZooKeeperAware());\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n    \n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      ClusterState clusterState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with an explicit list of slices to query via \"shards\", so use the cluster state\n\n        clusterState =  zkController.getClusterState();\n        String shardKeys = params.get(ShardParams.SHARD_KEYS);\n\n        // This will be the complete list of slices we need to query for this request.\n        slices = new HashMap<String,Slice>();\n\n        // we need to find out what collections this request is for.\n\n        // A comma-separated list of specified collections.\n        // Eg: \"collection1,collection2,collection3\"\n        String collections = params.get(\"collection\");\n        if (collections != null) {\n          // If there were one or more collections specified in the query, split\n          // each parameter and store as a seperate member of a List.\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\n              true);\n          // In turn, retrieve the slices that cover each collection from the\n          // cloud state and add them to the Map 'slices'.\n          for (String collectionName : collectionList) {\n            // The original code produced <collection-name>_<shard-name> when the collections\n            // parameter was specified (see ClientUtils.appendMap)\n            // Is this necessary if ony one collection is specified?\n            // i.e. should we change multiCollection to collectionList.size() > 1?\n            addSlices(slices, clusterState, params, collectionName,  shardKeys, true);\n          }\n        } else {\n          // just this collection\n          String collectionName = cloudDescriptor.getCollectionName();\n          addSlices(slices, clusterState, params, collectionName,  shardKeys, false);\n        }\n\n        \n        // Store the logical slices in the ResponseBuilder and create a new\n        // String array to hold the physical shards (which will be mapped\n        // later).\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n\n        // Are we hosting the shard that this request is for, and are we active? If so, then handle it ourselves\n        // and make it a non-distributed request.\n        String ourSlice = cloudDescriptor.getShardId();\n        String ourCollection = cloudDescriptor.getCollectionName();\n        if (rb.slices.length == 1\n            && ( rb.slices[0].equals(ourSlice) || rb.slices[0].equals(ourCollection + \"_\" + ourSlice) )  // handle the <collection>_<slice> format\n            && ZkStateReader.ACTIVE.equals(cloudDescriptor.getLastPublished()) )\n        {\n          boolean shortCircuit = params.getBool(\"shortCircuit\", true);       // currently just a debugging parameter to check distrib search on a single node\n\n          String targetHandler = params.get(ShardParams.SHARDS_QT);\n          shortCircuit = shortCircuit && targetHandler == null;             // if a different handler is specified, don't short-circuit\n\n          if (shortCircuit) {\n            rb.isDistrib = false;\n            return;\n          }\n          // We shouldn't need to do anything to handle \"shard.rows\" since it was previously meant to be an optimization?\n        }\n\n\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (clusterState == null) {\n              clusterState =  zkController.getClusterState();\n              slices = clusterState.getSlicesMap(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, Replica> sliceShards = slice.getReplicasMap();\n\n            // For now, recreate the | delimited list of equivalent servers\n            Set<String> liveNodes = clusterState.getLiveNodes();\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\n              ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n              if (!liveNodes.contains(coreNodeProps.getNodeName())\n                  || !coreNodeProps.getState().equals(\n                      ZkStateReader.ACTIVE)) continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = coreNodeProps.getCoreUrl();\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","sourceOld":"  public void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\n        .getCoreContainer().isZooKeeperAware());\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n    \n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      ClusterState clusterState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with an explicit list of slices to query via \"shards\", so use the cluster state\n\n        clusterState =  zkController.getClusterState();\n        String shardKeys = params.get(ShardParams.SHARD_KEYS);\n\n        // This will be the complete list of slices we need to query for this request.\n        slices = new HashMap<String,Slice>();\n\n        // we need to find out what collections this request is for.\n\n        // A comma-separated list of specified collections.\n        // Eg: \"collection1,collection2,collection3\"\n        String collections = params.get(\"collection\");\n        if (collections != null) {\n          // If there were one or more collections specified in the query, split\n          // each parameter and store as a seperate member of a List.\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\n              true);\n          // In turn, retrieve the slices that cover each collection from the\n          // cloud state and add them to the Map 'slices'.\n          for (String collectionName : collectionList) {\n            // The original code produced <collection-name>_<shard-name> when the collections\n            // parameter was specified (see ClientUtils.appendMap)\n            // Is this necessary if ony one collection is specified?\n            // i.e. should we change multiCollection to collectionList.size() > 1?\n            addSlices(slices, clusterState, params, collectionName,  shardKeys, true);\n          }\n        } else {\n          // just this collection\n          String collectionName = cloudDescriptor.getCollectionName();\n          addSlices(slices, clusterState, params, collectionName,  shardKeys, false);\n        }\n\n        \n        // Store the logical slices in the ResponseBuilder and create a new\n        // String array to hold the physical shards (which will be mapped\n        // later).\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n\n        // Are we hosting the shard that this request is for, and are we active? If so, then handle it ourselves\n        // and make it a non-distributed request.\n        String ourSlice = cloudDescriptor.getShardId();\n        String ourCollection = cloudDescriptor.getCollectionName();\n        if (rb.slices.length == 1\n            && ( rb.slices[0].equals(ourSlice) || rb.slices[0].equals(ourCollection + \"_\" + ourSlice) )  // handle the <collection>_<slice> format\n            && ZkStateReader.ACTIVE.equals(cloudDescriptor.getLastPublished()) )\n        {\n          boolean shortCircuit = params.getBool(\"shortCircuit\", true);       // currently just a debugging parameter to check distrib search on a single node\n\n          String targetHandler = params.get(ShardParams.SHARDS_QT);\n          shortCircuit = shortCircuit && targetHandler == null;             // if a different handler is specified, don't short-circuit\n\n          if (shortCircuit) {\n            rb.isDistrib = false;\n            return;\n          }\n          // We shouldn't need to do anything to handle \"shard.rows\" since it was previously meant to be an optimization?\n        }\n\n\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (clusterState == null) {\n              clusterState =  zkController.getClusterState();\n              slices = clusterState.getSlicesMap(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, Replica> sliceShards = slice.getReplicasMap();\n\n            // For now, recreate the | delimited list of equivalent servers\n            Set<String> liveNodes = clusterState.getLiveNodes();\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\n              ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n              if (!liveNodes.contains(coreNodeProps.getNodeName())\n                  || !coreNodeProps.getState().equals(\n                      ZkStateReader.ACTIVE)) continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = coreNodeProps.getCoreUrl();\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7602e63987582091a0e432f8d8f7619d2206fab7","date":1361393626,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\n        .getCoreContainer().isZooKeeperAware());\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n    \n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      ClusterState clusterState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with an explicit list of slices to query via \"shards\", so use the cluster state\n\n        clusterState =  zkController.getClusterState();\n        String shardKeys = params.get(ShardParams.SHARD_KEYS);\n\n        // This will be the complete list of slices we need to query for this request.\n        slices = new HashMap<String,Slice>();\n\n        // we need to find out what collections this request is for.\n\n        // A comma-separated list of specified collections.\n        // Eg: \"collection1,collection2,collection3\"\n        String collections = params.get(\"collection\");\n        if (collections != null) {\n          // If there were one or more collections specified in the query, split\n          // each parameter and store as a separate member of a List.\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\n              true);\n          // In turn, retrieve the slices that cover each collection from the\n          // cloud state and add them to the Map 'slices'.\n          for (String collectionName : collectionList) {\n            // The original code produced <collection-name>_<shard-name> when the collections\n            // parameter was specified (see ClientUtils.appendMap)\n            // Is this necessary if ony one collection is specified?\n            // i.e. should we change multiCollection to collectionList.size() > 1?\n            addSlices(slices, clusterState, params, collectionName,  shardKeys, true);\n          }\n        } else {\n          // just this collection\n          String collectionName = cloudDescriptor.getCollectionName();\n          addSlices(slices, clusterState, params, collectionName,  shardKeys, false);\n        }\n\n        \n        // Store the logical slices in the ResponseBuilder and create a new\n        // String array to hold the physical shards (which will be mapped\n        // later).\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n\n        // Are we hosting the shard that this request is for, and are we active? If so, then handle it ourselves\n        // and make it a non-distributed request.\n        String ourSlice = cloudDescriptor.getShardId();\n        String ourCollection = cloudDescriptor.getCollectionName();\n        if (rb.slices.length == 1\n            && ( rb.slices[0].equals(ourSlice) || rb.slices[0].equals(ourCollection + \"_\" + ourSlice) )  // handle the <collection>_<slice> format\n            && ZkStateReader.ACTIVE.equals(cloudDescriptor.getLastPublished()) )\n        {\n          boolean shortCircuit = params.getBool(\"shortCircuit\", true);       // currently just a debugging parameter to check distrib search on a single node\n\n          String targetHandler = params.get(ShardParams.SHARDS_QT);\n          shortCircuit = shortCircuit && targetHandler == null;             // if a different handler is specified, don't short-circuit\n\n          if (shortCircuit) {\n            rb.isDistrib = false;\n            return;\n          }\n          // We shouldn't need to do anything to handle \"shard.rows\" since it was previously meant to be an optimization?\n        }\n\n\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (clusterState == null) {\n              clusterState =  zkController.getClusterState();\n              slices = clusterState.getSlicesMap(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, Replica> sliceShards = slice.getReplicasMap();\n\n            // For now, recreate the | delimited list of equivalent servers\n            Set<String> liveNodes = clusterState.getLiveNodes();\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\n              ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n              if (!liveNodes.contains(coreNodeProps.getNodeName())\n                  || !coreNodeProps.getState().equals(\n                      ZkStateReader.ACTIVE)) continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = coreNodeProps.getCoreUrl();\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\n        .getCoreContainer().isZooKeeperAware());\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n    \n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      ClusterState clusterState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with an explicit list of slices to query via \"shards\", so use the cluster state\n\n        clusterState =  zkController.getClusterState();\n        String shardKeys = params.get(ShardParams.SHARD_KEYS);\n\n        // This will be the complete list of slices we need to query for this request.\n        slices = new HashMap<String,Slice>();\n\n        // we need to find out what collections this request is for.\n\n        // A comma-separated list of specified collections.\n        // Eg: \"collection1,collection2,collection3\"\n        String collections = params.get(\"collection\");\n        if (collections != null) {\n          // If there were one or more collections specified in the query, split\n          // each parameter and store as a seperate member of a List.\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\n              true);\n          // In turn, retrieve the slices that cover each collection from the\n          // cloud state and add them to the Map 'slices'.\n          for (String collectionName : collectionList) {\n            // The original code produced <collection-name>_<shard-name> when the collections\n            // parameter was specified (see ClientUtils.appendMap)\n            // Is this necessary if ony one collection is specified?\n            // i.e. should we change multiCollection to collectionList.size() > 1?\n            addSlices(slices, clusterState, params, collectionName,  shardKeys, true);\n          }\n        } else {\n          // just this collection\n          String collectionName = cloudDescriptor.getCollectionName();\n          addSlices(slices, clusterState, params, collectionName,  shardKeys, false);\n        }\n\n        \n        // Store the logical slices in the ResponseBuilder and create a new\n        // String array to hold the physical shards (which will be mapped\n        // later).\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n\n        // Are we hosting the shard that this request is for, and are we active? If so, then handle it ourselves\n        // and make it a non-distributed request.\n        String ourSlice = cloudDescriptor.getShardId();\n        String ourCollection = cloudDescriptor.getCollectionName();\n        if (rb.slices.length == 1\n            && ( rb.slices[0].equals(ourSlice) || rb.slices[0].equals(ourCollection + \"_\" + ourSlice) )  // handle the <collection>_<slice> format\n            && ZkStateReader.ACTIVE.equals(cloudDescriptor.getLastPublished()) )\n        {\n          boolean shortCircuit = params.getBool(\"shortCircuit\", true);       // currently just a debugging parameter to check distrib search on a single node\n\n          String targetHandler = params.get(ShardParams.SHARDS_QT);\n          shortCircuit = shortCircuit && targetHandler == null;             // if a different handler is specified, don't short-circuit\n\n          if (shortCircuit) {\n            rb.isDistrib = false;\n            return;\n          }\n          // We shouldn't need to do anything to handle \"shard.rows\" since it was previously meant to be an optimization?\n        }\n\n\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (clusterState == null) {\n              clusterState =  zkController.getClusterState();\n              slices = clusterState.getSlicesMap(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, Replica> sliceShards = slice.getReplicasMap();\n\n            // For now, recreate the | delimited list of equivalent servers\n            Set<String> liveNodes = clusterState.getLiveNodes();\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\n              ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n              if (!liveNodes.contains(coreNodeProps.getNodeName())\n                  || !coreNodeProps.getState().equals(\n                      ZkStateReader.ACTIVE)) continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = coreNodeProps.getCoreUrl();\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","bugFix":["d76dfc2581b6998f72c0e749c6200e9c2432c36f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e14913df9327ed5dfa00075dc1ff09137dbdb896","date":1366997648,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\n        .getCoreContainer().isZooKeeperAware());\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n    \n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      ClusterState clusterState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with an explicit list of slices to query via \"shards\", so use the cluster state\n\n        clusterState =  zkController.getClusterState();\n        String shardKeys = params.get(ShardParams.SHARD_KEYS);\n\n        // This will be the complete list of slices we need to query for this request.\n        slices = new HashMap<String,Slice>();\n\n        // we need to find out what collections this request is for.\n\n        // A comma-separated list of specified collections.\n        // Eg: \"collection1,collection2,collection3\"\n        String collections = params.get(\"collection\");\n        if (collections != null) {\n          // If there were one or more collections specified in the query, split\n          // each parameter and store as a separate member of a List.\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\n              true);\n          // In turn, retrieve the slices that cover each collection from the\n          // cloud state and add them to the Map 'slices'.\n          for (String collectionName : collectionList) {\n            // The original code produced <collection-name>_<shard-name> when the collections\n            // parameter was specified (see ClientUtils.appendMap)\n            // Is this necessary if ony one collection is specified?\n            // i.e. should we change multiCollection to collectionList.size() > 1?\n            addSlices(slices, clusterState, params, collectionName,  shardKeys, true);\n          }\n        } else {\n          // just this collection\n          String collectionName = cloudDescriptor.getCollectionName();\n          addSlices(slices, clusterState, params, collectionName,  shardKeys, false);\n        }\n\n        \n        // Store the logical slices in the ResponseBuilder and create a new\n        // String array to hold the physical shards (which will be mapped\n        // later).\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n\n        // Are we hosting the shard that this request is for, and are we active? If so, then handle it ourselves\n        // and make it a non-distributed request.\n        String ourSlice = cloudDescriptor.getShardId();\n        String ourCollection = cloudDescriptor.getCollectionName();\n        if (rb.slices.length == 1 && rb.slices[0] != null\n            && ( rb.slices[0].equals(ourSlice) || rb.slices[0].equals(ourCollection + \"_\" + ourSlice) )  // handle the <collection>_<slice> format\n            && ZkStateReader.ACTIVE.equals(cloudDescriptor.getLastPublished()) )\n        {\n          boolean shortCircuit = params.getBool(\"shortCircuit\", true);       // currently just a debugging parameter to check distrib search on a single node\n\n          String targetHandler = params.get(ShardParams.SHARDS_QT);\n          shortCircuit = shortCircuit && targetHandler == null;             // if a different handler is specified, don't short-circuit\n\n          if (shortCircuit) {\n            rb.isDistrib = false;\n            return;\n          }\n          // We shouldn't need to do anything to handle \"shard.rows\" since it was previously meant to be an optimization?\n        }\n\n\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (clusterState == null) {\n              clusterState =  zkController.getClusterState();\n              slices = clusterState.getSlicesMap(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, Replica> sliceShards = slice.getReplicasMap();\n\n            // For now, recreate the | delimited list of equivalent servers\n            Set<String> liveNodes = clusterState.getLiveNodes();\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\n              ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n              if (!liveNodes.contains(coreNodeProps.getNodeName())\n                  || !coreNodeProps.getState().equals(\n                      ZkStateReader.ACTIVE)) continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = coreNodeProps.getCoreUrl();\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\n        .getCoreContainer().isZooKeeperAware());\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n    \n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      ClusterState clusterState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with an explicit list of slices to query via \"shards\", so use the cluster state\n\n        clusterState =  zkController.getClusterState();\n        String shardKeys = params.get(ShardParams.SHARD_KEYS);\n\n        // This will be the complete list of slices we need to query for this request.\n        slices = new HashMap<String,Slice>();\n\n        // we need to find out what collections this request is for.\n\n        // A comma-separated list of specified collections.\n        // Eg: \"collection1,collection2,collection3\"\n        String collections = params.get(\"collection\");\n        if (collections != null) {\n          // If there were one or more collections specified in the query, split\n          // each parameter and store as a separate member of a List.\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\n              true);\n          // In turn, retrieve the slices that cover each collection from the\n          // cloud state and add them to the Map 'slices'.\n          for (String collectionName : collectionList) {\n            // The original code produced <collection-name>_<shard-name> when the collections\n            // parameter was specified (see ClientUtils.appendMap)\n            // Is this necessary if ony one collection is specified?\n            // i.e. should we change multiCollection to collectionList.size() > 1?\n            addSlices(slices, clusterState, params, collectionName,  shardKeys, true);\n          }\n        } else {\n          // just this collection\n          String collectionName = cloudDescriptor.getCollectionName();\n          addSlices(slices, clusterState, params, collectionName,  shardKeys, false);\n        }\n\n        \n        // Store the logical slices in the ResponseBuilder and create a new\n        // String array to hold the physical shards (which will be mapped\n        // later).\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n\n        // Are we hosting the shard that this request is for, and are we active? If so, then handle it ourselves\n        // and make it a non-distributed request.\n        String ourSlice = cloudDescriptor.getShardId();\n        String ourCollection = cloudDescriptor.getCollectionName();\n        if (rb.slices.length == 1\n            && ( rb.slices[0].equals(ourSlice) || rb.slices[0].equals(ourCollection + \"_\" + ourSlice) )  // handle the <collection>_<slice> format\n            && ZkStateReader.ACTIVE.equals(cloudDescriptor.getLastPublished()) )\n        {\n          boolean shortCircuit = params.getBool(\"shortCircuit\", true);       // currently just a debugging parameter to check distrib search on a single node\n\n          String targetHandler = params.get(ShardParams.SHARDS_QT);\n          shortCircuit = shortCircuit && targetHandler == null;             // if a different handler is specified, don't short-circuit\n\n          if (shortCircuit) {\n            rb.isDistrib = false;\n            return;\n          }\n          // We shouldn't need to do anything to handle \"shard.rows\" since it was previously meant to be an optimization?\n        }\n\n\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (clusterState == null) {\n              clusterState =  zkController.getClusterState();\n              slices = clusterState.getSlicesMap(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, Replica> sliceShards = slice.getReplicasMap();\n\n            // For now, recreate the | delimited list of equivalent servers\n            Set<String> liveNodes = clusterState.getLiveNodes();\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\n              ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n              if (!liveNodes.contains(coreNodeProps.getNodeName())\n                  || !coreNodeProps.getState().equals(\n                      ZkStateReader.ACTIVE)) continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = coreNodeProps.getCoreUrl();\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"849494cf2f3a96af5c8c84995108ddd8456fcd04","date":1372277913,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\n        .getCoreContainer().isZooKeeperAware());\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n    \n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      ClusterState clusterState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with an explicit list of slices to query via \"shards\", so use the cluster state\n\n        clusterState =  zkController.getClusterState();\n        String shardKeys = params.get(ShardParams.SHARD_KEYS);\n\n        // This will be the complete list of slices we need to query for this request.\n        slices = new HashMap<String,Slice>();\n\n        // we need to find out what collections this request is for.\n\n        // A comma-separated list of specified collections.\n        // Eg: \"collection1,collection2,collection3\"\n        String collections = params.get(\"collection\");\n        if (collections != null) {\n          // If there were one or more collections specified in the query, split\n          // each parameter and store as a separate member of a List.\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\n              true);\n          // In turn, retrieve the slices that cover each collection from the\n          // cloud state and add them to the Map 'slices'.\n          for (String collectionName : collectionList) {\n            // The original code produced <collection-name>_<shard-name> when the collections\n            // parameter was specified (see ClientUtils.appendMap)\n            // Is this necessary if ony one collection is specified?\n            // i.e. should we change multiCollection to collectionList.size() > 1?\n            addSlices(slices, clusterState, params, collectionName,  shardKeys, true);\n          }\n        } else {\n          // just this collection\n          String collectionName = cloudDescriptor.getCollectionName();\n          addSlices(slices, clusterState, params, collectionName,  shardKeys, false);\n        }\n\n        \n        // Store the logical slices in the ResponseBuilder and create a new\n        // String array to hold the physical shards (which will be mapped\n        // later).\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n\n        // Are we hosting the shard that this request is for, and are we active? If so, then handle it ourselves\n        // and make it a non-distributed request.\n        String ourSlice = cloudDescriptor.getShardId();\n        String ourCollection = cloudDescriptor.getCollectionName();\n        if (rb.slices.length == 1 && rb.slices[0] != null\n            && ( rb.slices[0].equals(ourSlice) || rb.slices[0].equals(ourCollection + \"_\" + ourSlice) )  // handle the <collection>_<slice> format\n            && ZkStateReader.ACTIVE.equals(cloudDescriptor.getLastPublished()) )\n        {\n          boolean shortCircuit = params.getBool(\"shortCircuit\", true);       // currently just a debugging parameter to check distrib search on a single node\n\n          String targetHandler = params.get(ShardParams.SHARDS_QT);\n          shortCircuit = shortCircuit && targetHandler == null;             // if a different handler is specified, don't short-circuit\n\n          if (shortCircuit) {\n            rb.isDistrib = false;\n            return;\n          }\n          // We shouldn't need to do anything to handle \"shard.rows\" since it was previously meant to be an optimization?\n        }\n\n\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (clusterState == null) {\n              clusterState =  zkController.getClusterState();\n              slices = clusterState.getSlicesMap(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, Replica> sliceShards = slice.getReplicasMap();\n\n            // For now, recreate the | delimited list of equivalent servers\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (Replica replica : sliceShards.values()) {\n              if (!clusterState.liveNodesContain(replica.getNodeName())\n                  || !replica.getStr(ZkStateReader.STATE_PROP).equals(\n                      ZkStateReader.ACTIVE)) continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = ZkCoreNodeProps.getCoreUrl(replica);\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\n        .getCoreContainer().isZooKeeperAware());\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n    \n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      ClusterState clusterState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with an explicit list of slices to query via \"shards\", so use the cluster state\n\n        clusterState =  zkController.getClusterState();\n        String shardKeys = params.get(ShardParams.SHARD_KEYS);\n\n        // This will be the complete list of slices we need to query for this request.\n        slices = new HashMap<String,Slice>();\n\n        // we need to find out what collections this request is for.\n\n        // A comma-separated list of specified collections.\n        // Eg: \"collection1,collection2,collection3\"\n        String collections = params.get(\"collection\");\n        if (collections != null) {\n          // If there were one or more collections specified in the query, split\n          // each parameter and store as a separate member of a List.\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\n              true);\n          // In turn, retrieve the slices that cover each collection from the\n          // cloud state and add them to the Map 'slices'.\n          for (String collectionName : collectionList) {\n            // The original code produced <collection-name>_<shard-name> when the collections\n            // parameter was specified (see ClientUtils.appendMap)\n            // Is this necessary if ony one collection is specified?\n            // i.e. should we change multiCollection to collectionList.size() > 1?\n            addSlices(slices, clusterState, params, collectionName,  shardKeys, true);\n          }\n        } else {\n          // just this collection\n          String collectionName = cloudDescriptor.getCollectionName();\n          addSlices(slices, clusterState, params, collectionName,  shardKeys, false);\n        }\n\n        \n        // Store the logical slices in the ResponseBuilder and create a new\n        // String array to hold the physical shards (which will be mapped\n        // later).\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n\n        // Are we hosting the shard that this request is for, and are we active? If so, then handle it ourselves\n        // and make it a non-distributed request.\n        String ourSlice = cloudDescriptor.getShardId();\n        String ourCollection = cloudDescriptor.getCollectionName();\n        if (rb.slices.length == 1 && rb.slices[0] != null\n            && ( rb.slices[0].equals(ourSlice) || rb.slices[0].equals(ourCollection + \"_\" + ourSlice) )  // handle the <collection>_<slice> format\n            && ZkStateReader.ACTIVE.equals(cloudDescriptor.getLastPublished()) )\n        {\n          boolean shortCircuit = params.getBool(\"shortCircuit\", true);       // currently just a debugging parameter to check distrib search on a single node\n\n          String targetHandler = params.get(ShardParams.SHARDS_QT);\n          shortCircuit = shortCircuit && targetHandler == null;             // if a different handler is specified, don't short-circuit\n\n          if (shortCircuit) {\n            rb.isDistrib = false;\n            return;\n          }\n          // We shouldn't need to do anything to handle \"shard.rows\" since it was previously meant to be an optimization?\n        }\n\n\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (clusterState == null) {\n              clusterState =  zkController.getClusterState();\n              slices = clusterState.getSlicesMap(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, Replica> sliceShards = slice.getReplicasMap();\n\n            // For now, recreate the | delimited list of equivalent servers\n            Set<String> liveNodes = clusterState.getLiveNodes();\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\n              ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n              if (!liveNodes.contains(coreNodeProps.getNodeName())\n                  || !coreNodeProps.getState().equals(\n                      ZkStateReader.ACTIVE)) continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = coreNodeProps.getCoreUrl();\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\n        .getCoreContainer().isZooKeeperAware());\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n    \n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      ClusterState clusterState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with an explicit list of slices to query via \"shards\", so use the cluster state\n\n        clusterState =  zkController.getClusterState();\n        String shardKeys = params.get(ShardParams.SHARD_KEYS);\n\n        // This will be the complete list of slices we need to query for this request.\n        slices = new HashMap<String,Slice>();\n\n        // we need to find out what collections this request is for.\n\n        // A comma-separated list of specified collections.\n        // Eg: \"collection1,collection2,collection3\"\n        String collections = params.get(\"collection\");\n        if (collections != null) {\n          // If there were one or more collections specified in the query, split\n          // each parameter and store as a separate member of a List.\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\n              true);\n          // In turn, retrieve the slices that cover each collection from the\n          // cloud state and add them to the Map 'slices'.\n          for (String collectionName : collectionList) {\n            // The original code produced <collection-name>_<shard-name> when the collections\n            // parameter was specified (see ClientUtils.appendMap)\n            // Is this necessary if ony one collection is specified?\n            // i.e. should we change multiCollection to collectionList.size() > 1?\n            addSlices(slices, clusterState, params, collectionName,  shardKeys, true);\n          }\n        } else {\n          // just this collection\n          String collectionName = cloudDescriptor.getCollectionName();\n          addSlices(slices, clusterState, params, collectionName,  shardKeys, false);\n        }\n\n        \n        // Store the logical slices in the ResponseBuilder and create a new\n        // String array to hold the physical shards (which will be mapped\n        // later).\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n\n        // Are we hosting the shard that this request is for, and are we active? If so, then handle it ourselves\n        // and make it a non-distributed request.\n        String ourSlice = cloudDescriptor.getShardId();\n        String ourCollection = cloudDescriptor.getCollectionName();\n        if (rb.slices.length == 1 && rb.slices[0] != null\n            && ( rb.slices[0].equals(ourSlice) || rb.slices[0].equals(ourCollection + \"_\" + ourSlice) )  // handle the <collection>_<slice> format\n            && ZkStateReader.ACTIVE.equals(cloudDescriptor.getLastPublished()) )\n        {\n          boolean shortCircuit = params.getBool(\"shortCircuit\", true);       // currently just a debugging parameter to check distrib search on a single node\n\n          String targetHandler = params.get(ShardParams.SHARDS_QT);\n          shortCircuit = shortCircuit && targetHandler == null;             // if a different handler is specified, don't short-circuit\n\n          if (shortCircuit) {\n            rb.isDistrib = false;\n            return;\n          }\n          // We shouldn't need to do anything to handle \"shard.rows\" since it was previously meant to be an optimization?\n        }\n\n\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (clusterState == null) {\n              clusterState =  zkController.getClusterState();\n              slices = clusterState.getSlicesMap(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, Replica> sliceShards = slice.getReplicasMap();\n\n            // For now, recreate the | delimited list of equivalent servers\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (Replica replica : sliceShards.values()) {\n              if (!clusterState.liveNodesContain(replica.getNodeName())\n                  || !replica.getStr(ZkStateReader.STATE_PROP).equals(\n                      ZkStateReader.ACTIVE)) continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = ZkCoreNodeProps.getCoreUrl(replica);\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\n        .getCoreContainer().isZooKeeperAware());\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n    \n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      ClusterState clusterState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with an explicit list of slices to query via \"shards\", so use the cluster state\n\n        clusterState =  zkController.getClusterState();\n        String shardKeys = params.get(ShardParams.SHARD_KEYS);\n\n        // This will be the complete list of slices we need to query for this request.\n        slices = new HashMap<String,Slice>();\n\n        // we need to find out what collections this request is for.\n\n        // A comma-separated list of specified collections.\n        // Eg: \"collection1,collection2,collection3\"\n        String collections = params.get(\"collection\");\n        if (collections != null) {\n          // If there were one or more collections specified in the query, split\n          // each parameter and store as a separate member of a List.\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\n              true);\n          // In turn, retrieve the slices that cover each collection from the\n          // cloud state and add them to the Map 'slices'.\n          for (String collectionName : collectionList) {\n            // The original code produced <collection-name>_<shard-name> when the collections\n            // parameter was specified (see ClientUtils.appendMap)\n            // Is this necessary if ony one collection is specified?\n            // i.e. should we change multiCollection to collectionList.size() > 1?\n            addSlices(slices, clusterState, params, collectionName,  shardKeys, true);\n          }\n        } else {\n          // just this collection\n          String collectionName = cloudDescriptor.getCollectionName();\n          addSlices(slices, clusterState, params, collectionName,  shardKeys, false);\n        }\n\n        \n        // Store the logical slices in the ResponseBuilder and create a new\n        // String array to hold the physical shards (which will be mapped\n        // later).\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n\n        // Are we hosting the shard that this request is for, and are we active? If so, then handle it ourselves\n        // and make it a non-distributed request.\n        String ourSlice = cloudDescriptor.getShardId();\n        String ourCollection = cloudDescriptor.getCollectionName();\n        if (rb.slices.length == 1 && rb.slices[0] != null\n            && ( rb.slices[0].equals(ourSlice) || rb.slices[0].equals(ourCollection + \"_\" + ourSlice) )  // handle the <collection>_<slice> format\n            && ZkStateReader.ACTIVE.equals(cloudDescriptor.getLastPublished()) )\n        {\n          boolean shortCircuit = params.getBool(\"shortCircuit\", true);       // currently just a debugging parameter to check distrib search on a single node\n\n          String targetHandler = params.get(ShardParams.SHARDS_QT);\n          shortCircuit = shortCircuit && targetHandler == null;             // if a different handler is specified, don't short-circuit\n\n          if (shortCircuit) {\n            rb.isDistrib = false;\n            return;\n          }\n          // We shouldn't need to do anything to handle \"shard.rows\" since it was previously meant to be an optimization?\n        }\n\n\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (clusterState == null) {\n              clusterState =  zkController.getClusterState();\n              slices = clusterState.getSlicesMap(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, Replica> sliceShards = slice.getReplicasMap();\n\n            // For now, recreate the | delimited list of equivalent servers\n            Set<String> liveNodes = clusterState.getLiveNodes();\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (ZkNodeProps nodeProps : sliceShards.values()) {\n              ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n              if (!liveNodes.contains(coreNodeProps.getNodeName())\n                  || !coreNodeProps.getState().equals(\n                      ZkStateReader.ACTIVE)) continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = coreNodeProps.getCoreUrl();\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1eeda7e62e149f90eee8895af874c74efa7d4852","date":1375293182,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\n        .getCoreContainer().isZooKeeperAware());\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n    \n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      ClusterState clusterState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with an explicit list of slices to query via \"shards\", so use the cluster state\n\n        clusterState =  zkController.getClusterState();\n        String shardKeys =  params.get(ShardParams._ROUTE_);\n        if(shardKeys == null) shardKeys = params.get(ShardParams.SHARD_KEYS);//eprecated\n\n        // This will be the complete list of slices we need to query for this request.\n        slices = new HashMap<String,Slice>();\n\n        // we need to find out what collections this request is for.\n\n        // A comma-separated list of specified collections.\n        // Eg: \"collection1,collection2,collection3\"\n        String collections = params.get(\"collection\");\n        if (collections != null) {\n          // If there were one or more collections specified in the query, split\n          // each parameter and store as a separate member of a List.\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\n              true);\n          // In turn, retrieve the slices that cover each collection from the\n          // cloud state and add them to the Map 'slices'.\n          for (String collectionName : collectionList) {\n            // The original code produced <collection-name>_<shard-name> when the collections\n            // parameter was specified (see ClientUtils.appendMap)\n            // Is this necessary if ony one collection is specified?\n            // i.e. should we change multiCollection to collectionList.size() > 1?\n            addSlices(slices, clusterState, params, collectionName,  shardKeys, true);\n          }\n        } else {\n          // just this collection\n          String collectionName = cloudDescriptor.getCollectionName();\n          addSlices(slices, clusterState, params, collectionName,  shardKeys, false);\n        }\n\n        \n        // Store the logical slices in the ResponseBuilder and create a new\n        // String array to hold the physical shards (which will be mapped\n        // later).\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n\n        // Are we hosting the shard that this request is for, and are we active? If so, then handle it ourselves\n        // and make it a non-distributed request.\n        String ourSlice = cloudDescriptor.getShardId();\n        String ourCollection = cloudDescriptor.getCollectionName();\n        if (rb.slices.length == 1 && rb.slices[0] != null\n            && ( rb.slices[0].equals(ourSlice) || rb.slices[0].equals(ourCollection + \"_\" + ourSlice) )  // handle the <collection>_<slice> format\n            && ZkStateReader.ACTIVE.equals(cloudDescriptor.getLastPublished()) )\n        {\n          boolean shortCircuit = params.getBool(\"shortCircuit\", true);       // currently just a debugging parameter to check distrib search on a single node\n\n          String targetHandler = params.get(ShardParams.SHARDS_QT);\n          shortCircuit = shortCircuit && targetHandler == null;             // if a different handler is specified, don't short-circuit\n\n          if (shortCircuit) {\n            rb.isDistrib = false;\n            return;\n          }\n          // We shouldn't need to do anything to handle \"shard.rows\" since it was previously meant to be an optimization?\n        }\n\n\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (clusterState == null) {\n              clusterState =  zkController.getClusterState();\n              slices = clusterState.getSlicesMap(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, Replica> sliceShards = slice.getReplicasMap();\n\n            // For now, recreate the | delimited list of equivalent servers\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (Replica replica : sliceShards.values()) {\n              if (!clusterState.liveNodesContain(replica.getNodeName())\n                  || !replica.getStr(ZkStateReader.STATE_PROP).equals(\n                      ZkStateReader.ACTIVE)) continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = ZkCoreNodeProps.getCoreUrl(replica);\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\n        .getCoreContainer().isZooKeeperAware());\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n    \n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      ClusterState clusterState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with an explicit list of slices to query via \"shards\", so use the cluster state\n\n        clusterState =  zkController.getClusterState();\n        String shardKeys = params.get(ShardParams.SHARD_KEYS);\n\n        // This will be the complete list of slices we need to query for this request.\n        slices = new HashMap<String,Slice>();\n\n        // we need to find out what collections this request is for.\n\n        // A comma-separated list of specified collections.\n        // Eg: \"collection1,collection2,collection3\"\n        String collections = params.get(\"collection\");\n        if (collections != null) {\n          // If there were one or more collections specified in the query, split\n          // each parameter and store as a separate member of a List.\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\n              true);\n          // In turn, retrieve the slices that cover each collection from the\n          // cloud state and add them to the Map 'slices'.\n          for (String collectionName : collectionList) {\n            // The original code produced <collection-name>_<shard-name> when the collections\n            // parameter was specified (see ClientUtils.appendMap)\n            // Is this necessary if ony one collection is specified?\n            // i.e. should we change multiCollection to collectionList.size() > 1?\n            addSlices(slices, clusterState, params, collectionName,  shardKeys, true);\n          }\n        } else {\n          // just this collection\n          String collectionName = cloudDescriptor.getCollectionName();\n          addSlices(slices, clusterState, params, collectionName,  shardKeys, false);\n        }\n\n        \n        // Store the logical slices in the ResponseBuilder and create a new\n        // String array to hold the physical shards (which will be mapped\n        // later).\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n\n        // Are we hosting the shard that this request is for, and are we active? If so, then handle it ourselves\n        // and make it a non-distributed request.\n        String ourSlice = cloudDescriptor.getShardId();\n        String ourCollection = cloudDescriptor.getCollectionName();\n        if (rb.slices.length == 1 && rb.slices[0] != null\n            && ( rb.slices[0].equals(ourSlice) || rb.slices[0].equals(ourCollection + \"_\" + ourSlice) )  // handle the <collection>_<slice> format\n            && ZkStateReader.ACTIVE.equals(cloudDescriptor.getLastPublished()) )\n        {\n          boolean shortCircuit = params.getBool(\"shortCircuit\", true);       // currently just a debugging parameter to check distrib search on a single node\n\n          String targetHandler = params.get(ShardParams.SHARDS_QT);\n          shortCircuit = shortCircuit && targetHandler == null;             // if a different handler is specified, don't short-circuit\n\n          if (shortCircuit) {\n            rb.isDistrib = false;\n            return;\n          }\n          // We shouldn't need to do anything to handle \"shard.rows\" since it was previously meant to be an optimization?\n        }\n\n\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (clusterState == null) {\n              clusterState =  zkController.getClusterState();\n              slices = clusterState.getSlicesMap(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, Replica> sliceShards = slice.getReplicasMap();\n\n            // For now, recreate the | delimited list of equivalent servers\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (Replica replica : sliceShards.values()) {\n              if (!clusterState.liveNodesContain(replica.getNodeName())\n                  || !replica.getStr(ZkStateReader.STATE_PROP).equals(\n                      ZkStateReader.ACTIVE)) continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = ZkCoreNodeProps.getCoreUrl(replica);\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","date":1376375609,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\n        .getCoreContainer().isZooKeeperAware());\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n    \n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      ClusterState clusterState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with an explicit list of slices to query via \"shards\", so use the cluster state\n\n        clusterState =  zkController.getClusterState();\n        String shardKeys =  params.get(ShardParams._ROUTE_);\n        if(shardKeys == null) shardKeys = params.get(ShardParams.SHARD_KEYS);//eprecated\n\n        // This will be the complete list of slices we need to query for this request.\n        slices = new HashMap<String,Slice>();\n\n        // we need to find out what collections this request is for.\n\n        // A comma-separated list of specified collections.\n        // Eg: \"collection1,collection2,collection3\"\n        String collections = params.get(\"collection\");\n        if (collections != null) {\n          // If there were one or more collections specified in the query, split\n          // each parameter and store as a separate member of a List.\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\n              true);\n          // In turn, retrieve the slices that cover each collection from the\n          // cloud state and add them to the Map 'slices'.\n          for (String collectionName : collectionList) {\n            // The original code produced <collection-name>_<shard-name> when the collections\n            // parameter was specified (see ClientUtils.appendMap)\n            // Is this necessary if ony one collection is specified?\n            // i.e. should we change multiCollection to collectionList.size() > 1?\n            addSlices(slices, clusterState, params, collectionName,  shardKeys, true);\n          }\n        } else {\n          // just this collection\n          String collectionName = cloudDescriptor.getCollectionName();\n          addSlices(slices, clusterState, params, collectionName,  shardKeys, false);\n        }\n\n        \n        // Store the logical slices in the ResponseBuilder and create a new\n        // String array to hold the physical shards (which will be mapped\n        // later).\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n\n        // Are we hosting the shard that this request is for, and are we active? If so, then handle it ourselves\n        // and make it a non-distributed request.\n        String ourSlice = cloudDescriptor.getShardId();\n        String ourCollection = cloudDescriptor.getCollectionName();\n        if (rb.slices.length == 1 && rb.slices[0] != null\n            && ( rb.slices[0].equals(ourSlice) || rb.slices[0].equals(ourCollection + \"_\" + ourSlice) )  // handle the <collection>_<slice> format\n            && ZkStateReader.ACTIVE.equals(cloudDescriptor.getLastPublished()) )\n        {\n          boolean shortCircuit = params.getBool(\"shortCircuit\", true);       // currently just a debugging parameter to check distrib search on a single node\n\n          String targetHandler = params.get(ShardParams.SHARDS_QT);\n          shortCircuit = shortCircuit && targetHandler == null;             // if a different handler is specified, don't short-circuit\n\n          if (shortCircuit) {\n            rb.isDistrib = false;\n            return;\n          }\n          // We shouldn't need to do anything to handle \"shard.rows\" since it was previously meant to be an optimization?\n        }\n\n\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (clusterState == null) {\n              clusterState =  zkController.getClusterState();\n              slices = clusterState.getSlicesMap(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, Replica> sliceShards = slice.getReplicasMap();\n\n            // For now, recreate the | delimited list of equivalent servers\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (Replica replica : sliceShards.values()) {\n              if (!clusterState.liveNodesContain(replica.getNodeName())\n                  || !replica.getStr(ZkStateReader.STATE_PROP).equals(\n                      ZkStateReader.ACTIVE)) continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = ZkCoreNodeProps.getCoreUrl(replica);\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\n        .getCoreContainer().isZooKeeperAware());\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n    \n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      ClusterState clusterState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with an explicit list of slices to query via \"shards\", so use the cluster state\n\n        clusterState =  zkController.getClusterState();\n        String shardKeys = params.get(ShardParams.SHARD_KEYS);\n\n        // This will be the complete list of slices we need to query for this request.\n        slices = new HashMap<String,Slice>();\n\n        // we need to find out what collections this request is for.\n\n        // A comma-separated list of specified collections.\n        // Eg: \"collection1,collection2,collection3\"\n        String collections = params.get(\"collection\");\n        if (collections != null) {\n          // If there were one or more collections specified in the query, split\n          // each parameter and store as a separate member of a List.\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\n              true);\n          // In turn, retrieve the slices that cover each collection from the\n          // cloud state and add them to the Map 'slices'.\n          for (String collectionName : collectionList) {\n            // The original code produced <collection-name>_<shard-name> when the collections\n            // parameter was specified (see ClientUtils.appendMap)\n            // Is this necessary if ony one collection is specified?\n            // i.e. should we change multiCollection to collectionList.size() > 1?\n            addSlices(slices, clusterState, params, collectionName,  shardKeys, true);\n          }\n        } else {\n          // just this collection\n          String collectionName = cloudDescriptor.getCollectionName();\n          addSlices(slices, clusterState, params, collectionName,  shardKeys, false);\n        }\n\n        \n        // Store the logical slices in the ResponseBuilder and create a new\n        // String array to hold the physical shards (which will be mapped\n        // later).\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n\n        // Are we hosting the shard that this request is for, and are we active? If so, then handle it ourselves\n        // and make it a non-distributed request.\n        String ourSlice = cloudDescriptor.getShardId();\n        String ourCollection = cloudDescriptor.getCollectionName();\n        if (rb.slices.length == 1 && rb.slices[0] != null\n            && ( rb.slices[0].equals(ourSlice) || rb.slices[0].equals(ourCollection + \"_\" + ourSlice) )  // handle the <collection>_<slice> format\n            && ZkStateReader.ACTIVE.equals(cloudDescriptor.getLastPublished()) )\n        {\n          boolean shortCircuit = params.getBool(\"shortCircuit\", true);       // currently just a debugging parameter to check distrib search on a single node\n\n          String targetHandler = params.get(ShardParams.SHARDS_QT);\n          shortCircuit = shortCircuit && targetHandler == null;             // if a different handler is specified, don't short-circuit\n\n          if (shortCircuit) {\n            rb.isDistrib = false;\n            return;\n          }\n          // We shouldn't need to do anything to handle \"shard.rows\" since it was previously meant to be an optimization?\n        }\n\n\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (clusterState == null) {\n              clusterState =  zkController.getClusterState();\n              slices = clusterState.getSlicesMap(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, Replica> sliceShards = slice.getReplicasMap();\n\n            // For now, recreate the | delimited list of equivalent servers\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (Replica replica : sliceShards.values()) {\n              if (!clusterState.liveNodesContain(replica.getNodeName())\n                  || !replica.getStr(ZkStateReader.STATE_PROP).equals(\n                      ZkStateReader.ACTIVE)) continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = ZkCoreNodeProps.getCoreUrl(replica);\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"57641b2e9dc6155be493cfb6ae9b8a9c8ceffa72","date":1391985588,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\n        .getCoreContainer().isZooKeeperAware());\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n    \n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      ClusterState clusterState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with an explicit list of slices to query via \"shards\", so use the cluster state\n\n        clusterState =  zkController.getClusterState();\n        String shardKeys =  params.get(ShardParams._ROUTE_);\n        if(shardKeys == null) shardKeys = params.get(ShardParams.SHARD_KEYS);//eprecated\n\n        // This will be the complete list of slices we need to query for this request.\n        slices = new HashMap<String,Slice>();\n\n        // we need to find out what collections this request is for.\n\n        // A comma-separated list of specified collections.\n        // Eg: \"collection1,collection2,collection3\"\n        String collections = params.get(\"collection\");\n        if (collections != null) {\n          // If there were one or more collections specified in the query, split\n          // each parameter and store as a separate member of a List.\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\n              true);\n          // In turn, retrieve the slices that cover each collection from the\n          // cloud state and add them to the Map 'slices'.\n          for (String collectionName : collectionList) {\n            // The original code produced <collection-name>_<shard-name> when the collections\n            // parameter was specified (see ClientUtils.appendMap)\n            // Is this necessary if ony one collection is specified?\n            // i.e. should we change multiCollection to collectionList.size() > 1?\n            addSlices(slices, clusterState, params, collectionName,  shardKeys, true);\n          }\n        } else {\n          // just this collection\n          String collectionName = cloudDescriptor.getCollectionName();\n          addSlices(slices, clusterState, params, collectionName,  shardKeys, false);\n        }\n\n        \n        // Store the logical slices in the ResponseBuilder and create a new\n        // String array to hold the physical shards (which will be mapped\n        // later).\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n\n        // Are we hosting the shard that this request is for, and are we active? If so, then handle it ourselves\n        // and make it a non-distributed request.\n        String ourSlice = cloudDescriptor.getShardId();\n        String ourCollection = cloudDescriptor.getCollectionName();\n        if (rb.slices.length == 1 && rb.slices[0] != null\n            && ( rb.slices[0].equals(ourSlice) || rb.slices[0].equals(ourCollection + \"_\" + ourSlice) )  // handle the <collection>_<slice> format\n            && ZkStateReader.ACTIVE.equals(cloudDescriptor.getLastPublished()) )\n        {\n          boolean shortCircuit = params.getBool(\"shortCircuit\", true);       // currently just a debugging parameter to check distrib search on a single node\n\n          String targetHandler = params.get(ShardParams.SHARDS_QT);\n          shortCircuit = shortCircuit && targetHandler == null;             // if a different handler is specified, don't short-circuit\n\n          if (shortCircuit) {\n            rb.isDistrib = false;\n            return;\n          }\n          // We shouldn't need to do anything to handle \"shard.rows\" since it was previously meant to be an optimization?\n        }\n\n\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (clusterState == null) {\n              clusterState =  zkController.getClusterState();\n              slices = clusterState.getSlicesMap(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, Replica> sliceShards = slice.getReplicasMap();\n\n            // For now, recreate the | delimited list of equivalent servers\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (Replica replica : sliceShards.values()) {\n              if (!clusterState.liveNodesContain(replica.getNodeName())\n                  || !replica.getStr(ZkStateReader.STATE_PROP).equals(\n                      ZkStateReader.ACTIVE)) continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = ZkCoreNodeProps.getCoreUrl(replica);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\n        .getCoreContainer().isZooKeeperAware());\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n    \n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      ClusterState clusterState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with an explicit list of slices to query via \"shards\", so use the cluster state\n\n        clusterState =  zkController.getClusterState();\n        String shardKeys =  params.get(ShardParams._ROUTE_);\n        if(shardKeys == null) shardKeys = params.get(ShardParams.SHARD_KEYS);//eprecated\n\n        // This will be the complete list of slices we need to query for this request.\n        slices = new HashMap<String,Slice>();\n\n        // we need to find out what collections this request is for.\n\n        // A comma-separated list of specified collections.\n        // Eg: \"collection1,collection2,collection3\"\n        String collections = params.get(\"collection\");\n        if (collections != null) {\n          // If there were one or more collections specified in the query, split\n          // each parameter and store as a separate member of a List.\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\n              true);\n          // In turn, retrieve the slices that cover each collection from the\n          // cloud state and add them to the Map 'slices'.\n          for (String collectionName : collectionList) {\n            // The original code produced <collection-name>_<shard-name> when the collections\n            // parameter was specified (see ClientUtils.appendMap)\n            // Is this necessary if ony one collection is specified?\n            // i.e. should we change multiCollection to collectionList.size() > 1?\n            addSlices(slices, clusterState, params, collectionName,  shardKeys, true);\n          }\n        } else {\n          // just this collection\n          String collectionName = cloudDescriptor.getCollectionName();\n          addSlices(slices, clusterState, params, collectionName,  shardKeys, false);\n        }\n\n        \n        // Store the logical slices in the ResponseBuilder and create a new\n        // String array to hold the physical shards (which will be mapped\n        // later).\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n\n        // Are we hosting the shard that this request is for, and are we active? If so, then handle it ourselves\n        // and make it a non-distributed request.\n        String ourSlice = cloudDescriptor.getShardId();\n        String ourCollection = cloudDescriptor.getCollectionName();\n        if (rb.slices.length == 1 && rb.slices[0] != null\n            && ( rb.slices[0].equals(ourSlice) || rb.slices[0].equals(ourCollection + \"_\" + ourSlice) )  // handle the <collection>_<slice> format\n            && ZkStateReader.ACTIVE.equals(cloudDescriptor.getLastPublished()) )\n        {\n          boolean shortCircuit = params.getBool(\"shortCircuit\", true);       // currently just a debugging parameter to check distrib search on a single node\n\n          String targetHandler = params.get(ShardParams.SHARDS_QT);\n          shortCircuit = shortCircuit && targetHandler == null;             // if a different handler is specified, don't short-circuit\n\n          if (shortCircuit) {\n            rb.isDistrib = false;\n            return;\n          }\n          // We shouldn't need to do anything to handle \"shard.rows\" since it was previously meant to be an optimization?\n        }\n\n\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (clusterState == null) {\n              clusterState =  zkController.getClusterState();\n              slices = clusterState.getSlicesMap(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, Replica> sliceShards = slice.getReplicasMap();\n\n            // For now, recreate the | delimited list of equivalent servers\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (Replica replica : sliceShards.values()) {\n              if (!clusterState.liveNodesContain(replica.getNodeName())\n                  || !replica.getStr(ZkStateReader.STATE_PROP).equals(\n                      ZkStateReader.ACTIVE)) continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = ZkCoreNodeProps.getCoreUrl(replica);\n              if (url.startsWith(\"http://\"))\n                url = url.substring(7);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\n        .getCoreContainer().isZooKeeperAware());\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n    \n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      ClusterState clusterState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with an explicit list of slices to query via \"shards\", so use the cluster state\n\n        clusterState =  zkController.getClusterState();\n        String shardKeys =  params.get(ShardParams._ROUTE_);\n        if(shardKeys == null) shardKeys = params.get(ShardParams.SHARD_KEYS);//eprecated\n\n        // This will be the complete list of slices we need to query for this request.\n        slices = new HashMap<>();\n\n        // we need to find out what collections this request is for.\n\n        // A comma-separated list of specified collections.\n        // Eg: \"collection1,collection2,collection3\"\n        String collections = params.get(\"collection\");\n        if (collections != null) {\n          // If there were one or more collections specified in the query, split\n          // each parameter and store as a separate member of a List.\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\n              true);\n          // In turn, retrieve the slices that cover each collection from the\n          // cloud state and add them to the Map 'slices'.\n          for (String collectionName : collectionList) {\n            // The original code produced <collection-name>_<shard-name> when the collections\n            // parameter was specified (see ClientUtils.appendMap)\n            // Is this necessary if ony one collection is specified?\n            // i.e. should we change multiCollection to collectionList.size() > 1?\n            addSlices(slices, clusterState, params, collectionName,  shardKeys, true);\n          }\n        } else {\n          // just this collection\n          String collectionName = cloudDescriptor.getCollectionName();\n          addSlices(slices, clusterState, params, collectionName,  shardKeys, false);\n        }\n\n        \n        // Store the logical slices in the ResponseBuilder and create a new\n        // String array to hold the physical shards (which will be mapped\n        // later).\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n\n        // Are we hosting the shard that this request is for, and are we active? If so, then handle it ourselves\n        // and make it a non-distributed request.\n        String ourSlice = cloudDescriptor.getShardId();\n        String ourCollection = cloudDescriptor.getCollectionName();\n        if (rb.slices.length == 1 && rb.slices[0] != null\n            && ( rb.slices[0].equals(ourSlice) || rb.slices[0].equals(ourCollection + \"_\" + ourSlice) )  // handle the <collection>_<slice> format\n            && ZkStateReader.ACTIVE.equals(cloudDescriptor.getLastPublished()) )\n        {\n          boolean shortCircuit = params.getBool(\"shortCircuit\", true);       // currently just a debugging parameter to check distrib search on a single node\n\n          String targetHandler = params.get(ShardParams.SHARDS_QT);\n          shortCircuit = shortCircuit && targetHandler == null;             // if a different handler is specified, don't short-circuit\n\n          if (shortCircuit) {\n            rb.isDistrib = false;\n            return;\n          }\n          // We shouldn't need to do anything to handle \"shard.rows\" since it was previously meant to be an optimization?\n        }\n\n\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (clusterState == null) {\n              clusterState =  zkController.getClusterState();\n              slices = clusterState.getSlicesMap(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, Replica> sliceShards = slice.getReplicasMap();\n\n            // For now, recreate the | delimited list of equivalent servers\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (Replica replica : sliceShards.values()) {\n              if (!clusterState.liveNodesContain(replica.getNodeName())\n                  || !replica.getStr(ZkStateReader.STATE_PROP).equals(\n                      ZkStateReader.ACTIVE)) continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = ZkCoreNodeProps.getCoreUrl(replica);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\n        .getCoreContainer().isZooKeeperAware());\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n    \n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      ClusterState clusterState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with an explicit list of slices to query via \"shards\", so use the cluster state\n\n        clusterState =  zkController.getClusterState();\n        String shardKeys =  params.get(ShardParams._ROUTE_);\n        if(shardKeys == null) shardKeys = params.get(ShardParams.SHARD_KEYS);//eprecated\n\n        // This will be the complete list of slices we need to query for this request.\n        slices = new HashMap<String,Slice>();\n\n        // we need to find out what collections this request is for.\n\n        // A comma-separated list of specified collections.\n        // Eg: \"collection1,collection2,collection3\"\n        String collections = params.get(\"collection\");\n        if (collections != null) {\n          // If there were one or more collections specified in the query, split\n          // each parameter and store as a separate member of a List.\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\n              true);\n          // In turn, retrieve the slices that cover each collection from the\n          // cloud state and add them to the Map 'slices'.\n          for (String collectionName : collectionList) {\n            // The original code produced <collection-name>_<shard-name> when the collections\n            // parameter was specified (see ClientUtils.appendMap)\n            // Is this necessary if ony one collection is specified?\n            // i.e. should we change multiCollection to collectionList.size() > 1?\n            addSlices(slices, clusterState, params, collectionName,  shardKeys, true);\n          }\n        } else {\n          // just this collection\n          String collectionName = cloudDescriptor.getCollectionName();\n          addSlices(slices, clusterState, params, collectionName,  shardKeys, false);\n        }\n\n        \n        // Store the logical slices in the ResponseBuilder and create a new\n        // String array to hold the physical shards (which will be mapped\n        // later).\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n\n        // Are we hosting the shard that this request is for, and are we active? If so, then handle it ourselves\n        // and make it a non-distributed request.\n        String ourSlice = cloudDescriptor.getShardId();\n        String ourCollection = cloudDescriptor.getCollectionName();\n        if (rb.slices.length == 1 && rb.slices[0] != null\n            && ( rb.slices[0].equals(ourSlice) || rb.slices[0].equals(ourCollection + \"_\" + ourSlice) )  // handle the <collection>_<slice> format\n            && ZkStateReader.ACTIVE.equals(cloudDescriptor.getLastPublished()) )\n        {\n          boolean shortCircuit = params.getBool(\"shortCircuit\", true);       // currently just a debugging parameter to check distrib search on a single node\n\n          String targetHandler = params.get(ShardParams.SHARDS_QT);\n          shortCircuit = shortCircuit && targetHandler == null;             // if a different handler is specified, don't short-circuit\n\n          if (shortCircuit) {\n            rb.isDistrib = false;\n            return;\n          }\n          // We shouldn't need to do anything to handle \"shard.rows\" since it was previously meant to be an optimization?\n        }\n\n\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (clusterState == null) {\n              clusterState =  zkController.getClusterState();\n              slices = clusterState.getSlicesMap(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, Replica> sliceShards = slice.getReplicasMap();\n\n            // For now, recreate the | delimited list of equivalent servers\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (Replica replica : sliceShards.values()) {\n              if (!clusterState.liveNodesContain(replica.getNodeName())\n                  || !replica.getStr(ZkStateReader.STATE_PROP).equals(\n                      ZkStateReader.ACTIVE)) continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = ZkCoreNodeProps.getCoreUrl(replica);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c0d0eda576bd1392f929c375143ff45503e89192","date":1394979067,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\n        .getCoreContainer().isZooKeeperAware());\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n    \n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      ClusterState clusterState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with an explicit list of slices to query via \"shards\", so use the cluster state\n\n        clusterState =  zkController.getClusterState();\n        String shardKeys =  params.get(ShardParams._ROUTE_);\n        if(shardKeys == null) shardKeys = params.get(ShardParams.SHARD_KEYS);//eprecated\n\n        // This will be the complete list of slices we need to query for this request.\n        slices = new HashMap<>();\n\n        // we need to find out what collections this request is for.\n\n        // A comma-separated list of specified collections.\n        // Eg: \"collection1,collection2,collection3\"\n        String collections = params.get(\"collection\");\n        if (collections != null) {\n          // If there were one or more collections specified in the query, split\n          // each parameter and store as a separate member of a List.\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\n              true);\n          // In turn, retrieve the slices that cover each collection from the\n          // cloud state and add them to the Map 'slices'.\n          for (String collectionName : collectionList) {\n            // The original code produced <collection-name>_<shard-name> when the collections\n            // parameter was specified (see ClientUtils.appendMap)\n            // Is this necessary if ony one collection is specified?\n            // i.e. should we change multiCollection to collectionList.size() > 1?\n            addSlices(slices, clusterState, params, collectionName,  shardKeys, true);\n          }\n        } else {\n          // just this collection\n          String collectionName = cloudDescriptor.getCollectionName();\n          addSlices(slices, clusterState, params, collectionName,  shardKeys, false);\n        }\n\n        \n        // Store the logical slices in the ResponseBuilder and create a new\n        // String array to hold the physical shards (which will be mapped\n        // later).\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n\n        // Are we hosting the shard that this request is for, and are we active? If so, then handle it ourselves\n        // and make it a non-distributed request.\n        String ourSlice = cloudDescriptor.getShardId();\n        String ourCollection = cloudDescriptor.getCollectionName();\n        if (rb.slices.length == 1 && rb.slices[0] != null\n            && ( rb.slices[0].equals(ourSlice) || rb.slices[0].equals(ourCollection + \"_\" + ourSlice) )  // handle the <collection>_<slice> format\n            && ZkStateReader.ACTIVE.equals(cloudDescriptor.getLastPublished()) )\n        {\n          boolean shortCircuit = params.getBool(\"shortCircuit\", true);       // currently just a debugging parameter to check distrib search on a single node\n\n          String targetHandler = params.get(ShardParams.SHARDS_QT);\n          shortCircuit = shortCircuit && targetHandler == null;             // if a different handler is specified, don't short-circuit\n\n          if (shortCircuit) {\n            rb.isDistrib = false;\n            rb.shortCircuitedURL = ZkCoreNodeProps.getCoreUrl(zkController.getBaseUrl(), coreDescriptor.getName());\n            return;\n          }\n          // We shouldn't need to do anything to handle \"shard.rows\" since it was previously meant to be an optimization?\n        }\n\n\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (clusterState == null) {\n              clusterState =  zkController.getClusterState();\n              slices = clusterState.getSlicesMap(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, Replica> sliceShards = slice.getReplicasMap();\n\n            // For now, recreate the | delimited list of equivalent servers\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (Replica replica : sliceShards.values()) {\n              if (!clusterState.liveNodesContain(replica.getNodeName())\n                  || !replica.getStr(ZkStateReader.STATE_PROP).equals(\n                      ZkStateReader.ACTIVE)) continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = ZkCoreNodeProps.getCoreUrl(replica);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\n        .getCoreContainer().isZooKeeperAware());\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n    \n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      ClusterState clusterState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with an explicit list of slices to query via \"shards\", so use the cluster state\n\n        clusterState =  zkController.getClusterState();\n        String shardKeys =  params.get(ShardParams._ROUTE_);\n        if(shardKeys == null) shardKeys = params.get(ShardParams.SHARD_KEYS);//eprecated\n\n        // This will be the complete list of slices we need to query for this request.\n        slices = new HashMap<>();\n\n        // we need to find out what collections this request is for.\n\n        // A comma-separated list of specified collections.\n        // Eg: \"collection1,collection2,collection3\"\n        String collections = params.get(\"collection\");\n        if (collections != null) {\n          // If there were one or more collections specified in the query, split\n          // each parameter and store as a separate member of a List.\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\n              true);\n          // In turn, retrieve the slices that cover each collection from the\n          // cloud state and add them to the Map 'slices'.\n          for (String collectionName : collectionList) {\n            // The original code produced <collection-name>_<shard-name> when the collections\n            // parameter was specified (see ClientUtils.appendMap)\n            // Is this necessary if ony one collection is specified?\n            // i.e. should we change multiCollection to collectionList.size() > 1?\n            addSlices(slices, clusterState, params, collectionName,  shardKeys, true);\n          }\n        } else {\n          // just this collection\n          String collectionName = cloudDescriptor.getCollectionName();\n          addSlices(slices, clusterState, params, collectionName,  shardKeys, false);\n        }\n\n        \n        // Store the logical slices in the ResponseBuilder and create a new\n        // String array to hold the physical shards (which will be mapped\n        // later).\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n\n        // Are we hosting the shard that this request is for, and are we active? If so, then handle it ourselves\n        // and make it a non-distributed request.\n        String ourSlice = cloudDescriptor.getShardId();\n        String ourCollection = cloudDescriptor.getCollectionName();\n        if (rb.slices.length == 1 && rb.slices[0] != null\n            && ( rb.slices[0].equals(ourSlice) || rb.slices[0].equals(ourCollection + \"_\" + ourSlice) )  // handle the <collection>_<slice> format\n            && ZkStateReader.ACTIVE.equals(cloudDescriptor.getLastPublished()) )\n        {\n          boolean shortCircuit = params.getBool(\"shortCircuit\", true);       // currently just a debugging parameter to check distrib search on a single node\n\n          String targetHandler = params.get(ShardParams.SHARDS_QT);\n          shortCircuit = shortCircuit && targetHandler == null;             // if a different handler is specified, don't short-circuit\n\n          if (shortCircuit) {\n            rb.isDistrib = false;\n            return;\n          }\n          // We shouldn't need to do anything to handle \"shard.rows\" since it was previously meant to be an optimization?\n        }\n\n\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (clusterState == null) {\n              clusterState =  zkController.getClusterState();\n              slices = clusterState.getSlicesMap(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, Replica> sliceShards = slice.getReplicasMap();\n\n            // For now, recreate the | delimited list of equivalent servers\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (Replica replica : sliceShards.values()) {\n              if (!clusterState.liveNodesContain(replica.getNodeName())\n                  || !replica.getStr(ZkStateReader.STATE_PROP).equals(\n                      ZkStateReader.ACTIVE)) continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = ZkCoreNodeProps.getCoreUrl(replica);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2fc9f4a33c8fefeb1260aea04273a36b0d32378e","date":1421852764,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\n        .getCoreContainer().isZooKeeperAware());\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n    \n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      ClusterState clusterState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with an explicit list of slices to query via \"shards\", so use the cluster state\n\n        clusterState =  zkController.getClusterState();\n        String shardKeys =  params.get(ShardParams._ROUTE_);\n\n        // This will be the complete list of slices we need to query for this request.\n        slices = new HashMap<>();\n\n        // we need to find out what collections this request is for.\n\n        // A comma-separated list of specified collections.\n        // Eg: \"collection1,collection2,collection3\"\n        String collections = params.get(\"collection\");\n        if (collections != null) {\n          // If there were one or more collections specified in the query, split\n          // each parameter and store as a separate member of a List.\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\n              true);\n          // In turn, retrieve the slices that cover each collection from the\n          // cloud state and add them to the Map 'slices'.\n          for (String collectionName : collectionList) {\n            // The original code produced <collection-name>_<shard-name> when the collections\n            // parameter was specified (see ClientUtils.appendMap)\n            // Is this necessary if ony one collection is specified?\n            // i.e. should we change multiCollection to collectionList.size() > 1?\n            addSlices(slices, clusterState, params, collectionName,  shardKeys, true);\n          }\n        } else {\n          // just this collection\n          String collectionName = cloudDescriptor.getCollectionName();\n          addSlices(slices, clusterState, params, collectionName,  shardKeys, false);\n        }\n\n        \n        // Store the logical slices in the ResponseBuilder and create a new\n        // String array to hold the physical shards (which will be mapped\n        // later).\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n\n        // Are we hosting the shard that this request is for, and are we active? If so, then handle it ourselves\n        // and make it a non-distributed request.\n        String ourSlice = cloudDescriptor.getShardId();\n        String ourCollection = cloudDescriptor.getCollectionName();\n        if (rb.slices.length == 1 && rb.slices[0] != null\n            && ( rb.slices[0].equals(ourSlice) || rb.slices[0].equals(ourCollection + \"_\" + ourSlice) )  // handle the <collection>_<slice> format\n            && ZkStateReader.ACTIVE.equals(cloudDescriptor.getLastPublished()) )\n        {\n          boolean shortCircuit = params.getBool(\"shortCircuit\", true);       // currently just a debugging parameter to check distrib search on a single node\n\n          String targetHandler = params.get(ShardParams.SHARDS_QT);\n          shortCircuit = shortCircuit && targetHandler == null;             // if a different handler is specified, don't short-circuit\n\n          if (shortCircuit) {\n            rb.isDistrib = false;\n            rb.shortCircuitedURL = ZkCoreNodeProps.getCoreUrl(zkController.getBaseUrl(), coreDescriptor.getName());\n            return;\n          }\n          // We shouldn't need to do anything to handle \"shard.rows\" since it was previously meant to be an optimization?\n        }\n\n\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (clusterState == null) {\n              clusterState =  zkController.getClusterState();\n              slices = clusterState.getSlicesMap(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, Replica> sliceShards = slice.getReplicasMap();\n\n            // For now, recreate the | delimited list of equivalent servers\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (Replica replica : sliceShards.values()) {\n              if (!clusterState.liveNodesContain(replica.getNodeName())\n                  || !replica.getStr(ZkStateReader.STATE_PROP).equals(\n                      ZkStateReader.ACTIVE)) continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = ZkCoreNodeProps.getCoreUrl(replica);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\n        .getCoreContainer().isZooKeeperAware());\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n    \n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      ClusterState clusterState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with an explicit list of slices to query via \"shards\", so use the cluster state\n\n        clusterState =  zkController.getClusterState();\n        String shardKeys =  params.get(ShardParams._ROUTE_);\n        if(shardKeys == null) shardKeys = params.get(ShardParams.SHARD_KEYS);//eprecated\n\n        // This will be the complete list of slices we need to query for this request.\n        slices = new HashMap<>();\n\n        // we need to find out what collections this request is for.\n\n        // A comma-separated list of specified collections.\n        // Eg: \"collection1,collection2,collection3\"\n        String collections = params.get(\"collection\");\n        if (collections != null) {\n          // If there were one or more collections specified in the query, split\n          // each parameter and store as a separate member of a List.\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\n              true);\n          // In turn, retrieve the slices that cover each collection from the\n          // cloud state and add them to the Map 'slices'.\n          for (String collectionName : collectionList) {\n            // The original code produced <collection-name>_<shard-name> when the collections\n            // parameter was specified (see ClientUtils.appendMap)\n            // Is this necessary if ony one collection is specified?\n            // i.e. should we change multiCollection to collectionList.size() > 1?\n            addSlices(slices, clusterState, params, collectionName,  shardKeys, true);\n          }\n        } else {\n          // just this collection\n          String collectionName = cloudDescriptor.getCollectionName();\n          addSlices(slices, clusterState, params, collectionName,  shardKeys, false);\n        }\n\n        \n        // Store the logical slices in the ResponseBuilder and create a new\n        // String array to hold the physical shards (which will be mapped\n        // later).\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n\n        // Are we hosting the shard that this request is for, and are we active? If so, then handle it ourselves\n        // and make it a non-distributed request.\n        String ourSlice = cloudDescriptor.getShardId();\n        String ourCollection = cloudDescriptor.getCollectionName();\n        if (rb.slices.length == 1 && rb.slices[0] != null\n            && ( rb.slices[0].equals(ourSlice) || rb.slices[0].equals(ourCollection + \"_\" + ourSlice) )  // handle the <collection>_<slice> format\n            && ZkStateReader.ACTIVE.equals(cloudDescriptor.getLastPublished()) )\n        {\n          boolean shortCircuit = params.getBool(\"shortCircuit\", true);       // currently just a debugging parameter to check distrib search on a single node\n\n          String targetHandler = params.get(ShardParams.SHARDS_QT);\n          shortCircuit = shortCircuit && targetHandler == null;             // if a different handler is specified, don't short-circuit\n\n          if (shortCircuit) {\n            rb.isDistrib = false;\n            rb.shortCircuitedURL = ZkCoreNodeProps.getCoreUrl(zkController.getBaseUrl(), coreDescriptor.getName());\n            return;\n          }\n          // We shouldn't need to do anything to handle \"shard.rows\" since it was previously meant to be an optimization?\n        }\n\n\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (clusterState == null) {\n              clusterState =  zkController.getClusterState();\n              slices = clusterState.getSlicesMap(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, Replica> sliceShards = slice.getReplicasMap();\n\n            // For now, recreate the | delimited list of equivalent servers\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (Replica replica : sliceShards.values()) {\n              if (!clusterState.liveNodesContain(replica.getNodeName())\n                  || !replica.getStr(ZkStateReader.STATE_PROP).equals(\n                      ZkStateReader.ACTIVE)) continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = ZkCoreNodeProps.getCoreUrl(replica);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a219f1dcad1700e84807666bdbd2b573e8de7021","date":1428130940,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\n        .getCoreContainer().isZooKeeperAware());\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n    \n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      ClusterState clusterState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with an explicit list of slices to query via \"shards\", so use the cluster state\n\n        clusterState =  zkController.getClusterState();\n        String shardKeys =  params.get(ShardParams._ROUTE_);\n\n        // This will be the complete list of slices we need to query for this request.\n        slices = new HashMap<>();\n\n        // we need to find out what collections this request is for.\n\n        // A comma-separated list of specified collections.\n        // Eg: \"collection1,collection2,collection3\"\n        String collections = params.get(\"collection\");\n        if (collections != null) {\n          // If there were one or more collections specified in the query, split\n          // each parameter and store as a separate member of a List.\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\n              true);\n          // In turn, retrieve the slices that cover each collection from the\n          // cloud state and add them to the Map 'slices'.\n          for (String collectionName : collectionList) {\n            // The original code produced <collection-name>_<shard-name> when the collections\n            // parameter was specified (see ClientUtils.appendMap)\n            // Is this necessary if ony one collection is specified?\n            // i.e. should we change multiCollection to collectionList.size() > 1?\n            addSlices(slices, clusterState, params, collectionName,  shardKeys, true);\n          }\n        } else {\n          // just this collection\n          String collectionName = cloudDescriptor.getCollectionName();\n          addSlices(slices, clusterState, params, collectionName,  shardKeys, false);\n        }\n\n        \n        // Store the logical slices in the ResponseBuilder and create a new\n        // String array to hold the physical shards (which will be mapped\n        // later).\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n\n        // Are we hosting the shard that this request is for, and are we active? If so, then handle it ourselves\n        // and make it a non-distributed request.\n        String ourSlice = cloudDescriptor.getShardId();\n        String ourCollection = cloudDescriptor.getCollectionName();\n        if (rb.slices.length == 1 && rb.slices[0] != null\n            && ( rb.slices[0].equals(ourSlice) || rb.slices[0].equals(ourCollection + \"_\" + ourSlice) )  // handle the <collection>_<slice> format\n            && cloudDescriptor.getLastPublished() == Replica.State.ACTIVE) {\n          boolean shortCircuit = params.getBool(\"shortCircuit\", true);       // currently just a debugging parameter to check distrib search on a single node\n\n          String targetHandler = params.get(ShardParams.SHARDS_QT);\n          shortCircuit = shortCircuit && targetHandler == null;             // if a different handler is specified, don't short-circuit\n\n          if (shortCircuit) {\n            rb.isDistrib = false;\n            rb.shortCircuitedURL = ZkCoreNodeProps.getCoreUrl(zkController.getBaseUrl(), coreDescriptor.getName());\n            return;\n          }\n          // We shouldn't need to do anything to handle \"shard.rows\" since it was previously meant to be an optimization?\n        }\n\n\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (clusterState == null) {\n              clusterState =  zkController.getClusterState();\n              slices = clusterState.getSlicesMap(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, Replica> sliceShards = slice.getReplicasMap();\n\n            // For now, recreate the | delimited list of equivalent servers\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (Replica replica : sliceShards.values()) {\n              if (!clusterState.liveNodesContain(replica.getNodeName())\n                  || replica.getState() != Replica.State.ACTIVE) {\n                continue;\n              }\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = ZkCoreNodeProps.getCoreUrl(replica);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\n        .getCoreContainer().isZooKeeperAware());\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n    \n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      ClusterState clusterState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with an explicit list of slices to query via \"shards\", so use the cluster state\n\n        clusterState =  zkController.getClusterState();\n        String shardKeys =  params.get(ShardParams._ROUTE_);\n\n        // This will be the complete list of slices we need to query for this request.\n        slices = new HashMap<>();\n\n        // we need to find out what collections this request is for.\n\n        // A comma-separated list of specified collections.\n        // Eg: \"collection1,collection2,collection3\"\n        String collections = params.get(\"collection\");\n        if (collections != null) {\n          // If there were one or more collections specified in the query, split\n          // each parameter and store as a separate member of a List.\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\n              true);\n          // In turn, retrieve the slices that cover each collection from the\n          // cloud state and add them to the Map 'slices'.\n          for (String collectionName : collectionList) {\n            // The original code produced <collection-name>_<shard-name> when the collections\n            // parameter was specified (see ClientUtils.appendMap)\n            // Is this necessary if ony one collection is specified?\n            // i.e. should we change multiCollection to collectionList.size() > 1?\n            addSlices(slices, clusterState, params, collectionName,  shardKeys, true);\n          }\n        } else {\n          // just this collection\n          String collectionName = cloudDescriptor.getCollectionName();\n          addSlices(slices, clusterState, params, collectionName,  shardKeys, false);\n        }\n\n        \n        // Store the logical slices in the ResponseBuilder and create a new\n        // String array to hold the physical shards (which will be mapped\n        // later).\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n\n        // Are we hosting the shard that this request is for, and are we active? If so, then handle it ourselves\n        // and make it a non-distributed request.\n        String ourSlice = cloudDescriptor.getShardId();\n        String ourCollection = cloudDescriptor.getCollectionName();\n        if (rb.slices.length == 1 && rb.slices[0] != null\n            && ( rb.slices[0].equals(ourSlice) || rb.slices[0].equals(ourCollection + \"_\" + ourSlice) )  // handle the <collection>_<slice> format\n            && ZkStateReader.ACTIVE.equals(cloudDescriptor.getLastPublished()) )\n        {\n          boolean shortCircuit = params.getBool(\"shortCircuit\", true);       // currently just a debugging parameter to check distrib search on a single node\n\n          String targetHandler = params.get(ShardParams.SHARDS_QT);\n          shortCircuit = shortCircuit && targetHandler == null;             // if a different handler is specified, don't short-circuit\n\n          if (shortCircuit) {\n            rb.isDistrib = false;\n            rb.shortCircuitedURL = ZkCoreNodeProps.getCoreUrl(zkController.getBaseUrl(), coreDescriptor.getName());\n            return;\n          }\n          // We shouldn't need to do anything to handle \"shard.rows\" since it was previously meant to be an optimization?\n        }\n\n\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (clusterState == null) {\n              clusterState =  zkController.getClusterState();\n              slices = clusterState.getSlicesMap(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, Replica> sliceShards = slice.getReplicasMap();\n\n            // For now, recreate the | delimited list of equivalent servers\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (Replica replica : sliceShards.values()) {\n              if (!clusterState.liveNodesContain(replica.getNodeName())\n                  || !replica.getStr(ZkStateReader.STATE_PROP).equals(\n                      ZkStateReader.ACTIVE)) continue;\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = ZkCoreNodeProps.getCoreUrl(replica);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"84bf44b1557bad2a5df2cb3af4c39a2b3f0e1efe","date":1434139436,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\n        .getCoreContainer().isZooKeeperAware());\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n    \n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      ClusterState clusterState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with an explicit list of slices to query via \"shards\", so use the cluster state\n\n        clusterState =  zkController.getClusterState();\n        String shardKeys =  params.get(ShardParams._ROUTE_);\n\n        // This will be the complete list of slices we need to query for this request.\n        slices = new HashMap<>();\n\n        // we need to find out what collections this request is for.\n\n        // A comma-separated list of specified collections.\n        // Eg: \"collection1,collection2,collection3\"\n        String collections = params.get(\"collection\");\n        if (collections != null) {\n          // If there were one or more collections specified in the query, split\n          // each parameter and store as a separate member of a List.\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\n              true);\n          // In turn, retrieve the slices that cover each collection from the\n          // cloud state and add them to the Map 'slices'.\n          for (String collectionName : collectionList) {\n            // The original code produced <collection-name>_<shard-name> when the collections\n            // parameter was specified (see ClientUtils.appendMap)\n            // Is this necessary if ony one collection is specified?\n            // i.e. should we change multiCollection to collectionList.size() > 1?\n            addSlices(slices, clusterState, params, collectionName,  shardKeys, true);\n          }\n        } else {\n          // just this collection\n          String collectionName = cloudDescriptor.getCollectionName();\n          addSlices(slices, clusterState, params, collectionName,  shardKeys, false);\n        }\n\n        \n        // Store the logical slices in the ResponseBuilder and create a new\n        // String array to hold the physical shards (which will be mapped\n        // later).\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n\n        // Are we hosting the shard that this request is for, and are we active? If so, then handle it ourselves\n        // and make it a non-distributed request.\n        String ourSlice = cloudDescriptor.getShardId();\n        String ourCollection = cloudDescriptor.getCollectionName();\n        if (rb.slices.length == 1 && rb.slices[0] != null\n            && ( rb.slices[0].equals(ourSlice) || rb.slices[0].equals(ourCollection + \"_\" + ourSlice) )  // handle the <collection>_<slice> format\n            && cloudDescriptor.getLastPublished() == Replica.State.ACTIVE) {\n          boolean shortCircuit = params.getBool(\"shortCircuit\", true);       // currently just a debugging parameter to check distrib search on a single node\n\n          String targetHandler = params.get(ShardParams.SHARDS_QT);\n          shortCircuit = shortCircuit && targetHandler == null;             // if a different handler is specified, don't short-circuit\n\n          if (shortCircuit) {\n            rb.isDistrib = false;\n            rb.shortCircuitedURL = ZkCoreNodeProps.getCoreUrl(zkController.getBaseUrl(), coreDescriptor.getName());\n            return;\n          }\n          // We shouldn't need to do anything to handle \"shard.rows\" since it was previously meant to be an optimization?\n        }\n\n\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (clusterState == null) {\n              clusterState =  zkController.getClusterState();\n              slices = clusterState.getSlicesMap(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, Replica> sliceShards = slice.getReplicasMap();\n\n            // For now, recreate the | delimited list of equivalent servers\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (Replica replica : sliceShards.values()) {\n              if (!clusterState.liveNodesContain(replica.getNodeName())\n                  || replica.getState() != Replica.State.ACTIVE) {\n                continue;\n              }\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = ZkCoreNodeProps.getCoreUrl(replica);\n              sliceShardsStr.append(url);\n            }\n\n            if (sliceShardsStr.length() == 0) {\n              boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n              if (!tolerant) {\n                // stop the check when there are no replicas available for a shard\n                throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n                    \"no servers hosting shard: \" + rb.slices[i]);\n              }\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\n        .getCoreContainer().isZooKeeperAware());\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n    \n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      ClusterState clusterState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with an explicit list of slices to query via \"shards\", so use the cluster state\n\n        clusterState =  zkController.getClusterState();\n        String shardKeys =  params.get(ShardParams._ROUTE_);\n\n        // This will be the complete list of slices we need to query for this request.\n        slices = new HashMap<>();\n\n        // we need to find out what collections this request is for.\n\n        // A comma-separated list of specified collections.\n        // Eg: \"collection1,collection2,collection3\"\n        String collections = params.get(\"collection\");\n        if (collections != null) {\n          // If there were one or more collections specified in the query, split\n          // each parameter and store as a separate member of a List.\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\n              true);\n          // In turn, retrieve the slices that cover each collection from the\n          // cloud state and add them to the Map 'slices'.\n          for (String collectionName : collectionList) {\n            // The original code produced <collection-name>_<shard-name> when the collections\n            // parameter was specified (see ClientUtils.appendMap)\n            // Is this necessary if ony one collection is specified?\n            // i.e. should we change multiCollection to collectionList.size() > 1?\n            addSlices(slices, clusterState, params, collectionName,  shardKeys, true);\n          }\n        } else {\n          // just this collection\n          String collectionName = cloudDescriptor.getCollectionName();\n          addSlices(slices, clusterState, params, collectionName,  shardKeys, false);\n        }\n\n        \n        // Store the logical slices in the ResponseBuilder and create a new\n        // String array to hold the physical shards (which will be mapped\n        // later).\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n\n        // Are we hosting the shard that this request is for, and are we active? If so, then handle it ourselves\n        // and make it a non-distributed request.\n        String ourSlice = cloudDescriptor.getShardId();\n        String ourCollection = cloudDescriptor.getCollectionName();\n        if (rb.slices.length == 1 && rb.slices[0] != null\n            && ( rb.slices[0].equals(ourSlice) || rb.slices[0].equals(ourCollection + \"_\" + ourSlice) )  // handle the <collection>_<slice> format\n            && cloudDescriptor.getLastPublished() == Replica.State.ACTIVE) {\n          boolean shortCircuit = params.getBool(\"shortCircuit\", true);       // currently just a debugging parameter to check distrib search on a single node\n\n          String targetHandler = params.get(ShardParams.SHARDS_QT);\n          shortCircuit = shortCircuit && targetHandler == null;             // if a different handler is specified, don't short-circuit\n\n          if (shortCircuit) {\n            rb.isDistrib = false;\n            rb.shortCircuitedURL = ZkCoreNodeProps.getCoreUrl(zkController.getBaseUrl(), coreDescriptor.getName());\n            return;\n          }\n          // We shouldn't need to do anything to handle \"shard.rows\" since it was previously meant to be an optimization?\n        }\n\n\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (clusterState == null) {\n              clusterState =  zkController.getClusterState();\n              slices = clusterState.getSlicesMap(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, Replica> sliceShards = slice.getReplicasMap();\n\n            // For now, recreate the | delimited list of equivalent servers\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (Replica replica : sliceShards.values()) {\n              if (!clusterState.liveNodesContain(replica.getNodeName())\n                  || replica.getState() != Replica.State.ACTIVE) {\n                continue;\n              }\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = ZkCoreNodeProps.getCoreUrl(replica);\n              sliceShardsStr.append(url);\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5676bf22fd531b9a2a3053047d0e0f922c1c53ff","date":1435097302,"type":4,"author":"Ramkumar Aiyengar","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#checkDistributed(ResponseBuilder).mjava","sourceNew":null,"sourceOld":"  @Override\n  public void checkDistributed(ResponseBuilder rb) {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n\n    rb.isDistrib = params.getBool(\"distrib\", req.getCore().getCoreDescriptor()\n        .getCoreContainer().isZooKeeperAware());\n    String shards = params.get(ShardParams.SHARDS);\n\n    // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n    // search is distributed.\n    boolean hasShardURL = shards != null && shards.indexOf('/') > 0;\n    rb.isDistrib = hasShardURL | rb.isDistrib;\n    \n    if (rb.isDistrib) {\n      // since the cost of grabbing cloud state is still up in the air, we grab it only\n      // if we need it.\n      ClusterState clusterState = null;\n      Map<String,Slice> slices = null;\n      CoreDescriptor coreDescriptor = req.getCore().getCoreDescriptor();\n      CloudDescriptor cloudDescriptor = coreDescriptor.getCloudDescriptor();\n      ZkController zkController = coreDescriptor.getCoreContainer().getZkController();\n\n\n      if (shards != null) {\n        List<String> lst = StrUtils.splitSmart(shards, \",\", true);\n        rb.shards = lst.toArray(new String[lst.size()]);\n        rb.slices = new String[rb.shards.length];\n\n        if (zkController != null) {\n          // figure out which shards are slices\n          for (int i=0; i<rb.shards.length; i++) {\n            if (rb.shards[i].indexOf('/') < 0) {\n              // this is a logical shard\n              rb.slices[i] = rb.shards[i];\n              rb.shards[i] = null;\n            }\n          }\n        }\n      } else if (zkController != null) {\n        // we weren't provided with an explicit list of slices to query via \"shards\", so use the cluster state\n\n        clusterState =  zkController.getClusterState();\n        String shardKeys =  params.get(ShardParams._ROUTE_);\n\n        // This will be the complete list of slices we need to query for this request.\n        slices = new HashMap<>();\n\n        // we need to find out what collections this request is for.\n\n        // A comma-separated list of specified collections.\n        // Eg: \"collection1,collection2,collection3\"\n        String collections = params.get(\"collection\");\n        if (collections != null) {\n          // If there were one or more collections specified in the query, split\n          // each parameter and store as a separate member of a List.\n          List<String> collectionList = StrUtils.splitSmart(collections, \",\",\n              true);\n          // In turn, retrieve the slices that cover each collection from the\n          // cloud state and add them to the Map 'slices'.\n          for (String collectionName : collectionList) {\n            // The original code produced <collection-name>_<shard-name> when the collections\n            // parameter was specified (see ClientUtils.appendMap)\n            // Is this necessary if ony one collection is specified?\n            // i.e. should we change multiCollection to collectionList.size() > 1?\n            addSlices(slices, clusterState, params, collectionName,  shardKeys, true);\n          }\n        } else {\n          // just this collection\n          String collectionName = cloudDescriptor.getCollectionName();\n          addSlices(slices, clusterState, params, collectionName,  shardKeys, false);\n        }\n\n        \n        // Store the logical slices in the ResponseBuilder and create a new\n        // String array to hold the physical shards (which will be mapped\n        // later).\n        rb.slices = slices.keySet().toArray(new String[slices.size()]);\n        rb.shards = new String[rb.slices.length];\n      }\n\n      //\n      // Map slices to shards\n      //\n      if (zkController != null) {\n\n        // Are we hosting the shard that this request is for, and are we active? If so, then handle it ourselves\n        // and make it a non-distributed request.\n        String ourSlice = cloudDescriptor.getShardId();\n        String ourCollection = cloudDescriptor.getCollectionName();\n        if (rb.slices.length == 1 && rb.slices[0] != null\n            && ( rb.slices[0].equals(ourSlice) || rb.slices[0].equals(ourCollection + \"_\" + ourSlice) )  // handle the <collection>_<slice> format\n            && cloudDescriptor.getLastPublished() == Replica.State.ACTIVE) {\n          boolean shortCircuit = params.getBool(\"shortCircuit\", true);       // currently just a debugging parameter to check distrib search on a single node\n\n          String targetHandler = params.get(ShardParams.SHARDS_QT);\n          shortCircuit = shortCircuit && targetHandler == null;             // if a different handler is specified, don't short-circuit\n\n          if (shortCircuit) {\n            rb.isDistrib = false;\n            rb.shortCircuitedURL = ZkCoreNodeProps.getCoreUrl(zkController.getBaseUrl(), coreDescriptor.getName());\n            return;\n          }\n          // We shouldn't need to do anything to handle \"shard.rows\" since it was previously meant to be an optimization?\n        }\n\n\n        for (int i=0; i<rb.shards.length; i++) {\n          if (rb.shards[i] == null) {\n            if (clusterState == null) {\n              clusterState =  zkController.getClusterState();\n              slices = clusterState.getSlicesMap(cloudDescriptor.getCollectionName());\n            }\n            String sliceName = rb.slices[i];\n\n            Slice slice = slices.get(sliceName);\n\n            if (slice==null) {\n              // Treat this the same as \"all servers down\" for a slice, and let things continue\n              // if partial results are acceptable\n              rb.shards[i] = \"\";\n              continue;\n              // throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such shard: \" + sliceName);\n            }\n\n            Map<String, Replica> sliceShards = slice.getReplicasMap();\n\n            // For now, recreate the | delimited list of equivalent servers\n            StringBuilder sliceShardsStr = new StringBuilder();\n            boolean first = true;\n            for (Replica replica : sliceShards.values()) {\n              if (!clusterState.liveNodesContain(replica.getNodeName())\n                  || replica.getState() != Replica.State.ACTIVE) {\n                continue;\n              }\n              if (first) {\n                first = false;\n              } else {\n                sliceShardsStr.append('|');\n              }\n              String url = ZkCoreNodeProps.getCoreUrl(replica);\n              sliceShardsStr.append(url);\n            }\n\n            if (sliceShardsStr.length() == 0) {\n              boolean tolerant = rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false);\n              if (!tolerant) {\n                // stop the check when there are no replicas available for a shard\n                throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n                    \"no servers hosting shard: \" + rb.slices[i]);\n              }\n            }\n\n            rb.shards[i] = sliceShardsStr.toString();\n          }\n        }\n      }\n    }\n    String shards_rows = params.get(ShardParams.SHARDS_ROWS);\n    if(shards_rows != null) {\n      rb.shards_rows = Integer.parseInt(shards_rows);\n    }\n    String shards_start = params.get(ShardParams.SHARDS_START);\n    if(shards_start != null) {\n      rb.shards_start = Integer.parseInt(shards_start);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["407687e67faf6e1f02a211ca078d8e3eed631027","7530de27b87b961b51f01bd1299b7004d46e8823"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["e14913df9327ed5dfa00075dc1ff09137dbdb896","849494cf2f3a96af5c8c84995108ddd8456fcd04"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["0c66f8d4f044af481e9d86acc1b092d44db7c20f","d66363068e87a246ce08fee4a42f30f126b92723"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"1eeda7e62e149f90eee8895af874c74efa7d4852":["849494cf2f3a96af5c8c84995108ddd8456fcd04"],"a219f1dcad1700e84807666bdbd2b573e8de7021":["2fc9f4a33c8fefeb1260aea04273a36b0d32378e"],"e7754464847b06ced605515bd48219280ede29e9":["c5a558d54519c651068ddb202f03befefb1514a7"],"0c66f8d4f044af481e9d86acc1b092d44db7c20f":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"2fc9f4a33c8fefeb1260aea04273a36b0d32378e":["c0d0eda576bd1392f929c375143ff45503e89192"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["c26f00b574427b55127e869b935845554afde1fa","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"c0d0eda576bd1392f929c375143ff45503e89192":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e14913df9327ed5dfa00075dc1ff09137dbdb896":["7602e63987582091a0e432f8d8f7619d2206fab7"],"d66363068e87a246ce08fee4a42f30f126b92723":["0c66f8d4f044af481e9d86acc1b092d44db7c20f"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["57641b2e9dc6155be493cfb6ae9b8a9c8ceffa72"],"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":["37a0f60745e53927c4c876cfe5b5a58170f0646c","1eeda7e62e149f90eee8895af874c74efa7d4852"],"fa64435b5902ce266c23755a4a00691a3285dab8":["3f767f8c99eaedb984df754fe61f21c5de260f94"],"d76dfc2581b6998f72c0e749c6200e9c2432c36f":["d66363068e87a246ce08fee4a42f30f126b92723"],"407687e67faf6e1f02a211ca078d8e3eed631027":["fa64435b5902ce266c23755a4a00691a3285dab8","60eb5eeae4d0ae8321b30a826435b6106634c09b"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["c26f00b574427b55127e869b935845554afde1fa","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"8fd5be977c105554c6a7b68afcdbc511439723ab":["d76dfc2581b6998f72c0e749c6200e9c2432c36f","3f767f8c99eaedb984df754fe61f21c5de260f94"],"60eb5eeae4d0ae8321b30a826435b6106634c09b":["e7754464847b06ced605515bd48219280ede29e9"],"849494cf2f3a96af5c8c84995108ddd8456fcd04":["e14913df9327ed5dfa00075dc1ff09137dbdb896"],"3f767f8c99eaedb984df754fe61f21c5de260f94":["d76dfc2581b6998f72c0e749c6200e9c2432c36f"],"57641b2e9dc6155be493cfb6ae9b8a9c8ceffa72":["1eeda7e62e149f90eee8895af874c74efa7d4852"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c5a558d54519c651068ddb202f03befefb1514a7":["fa64435b5902ce266c23755a4a00691a3285dab8"],"5676bf22fd531b9a2a3053047d0e0f922c1c53ff":["84bf44b1557bad2a5df2cb3af4c39a2b3f0e1efe"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["d76dfc2581b6998f72c0e749c6200e9c2432c36f","3f767f8c99eaedb984df754fe61f21c5de260f94"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["c26f00b574427b55127e869b935845554afde1fa"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"84bf44b1557bad2a5df2cb3af4c39a2b3f0e1efe":["a219f1dcad1700e84807666bdbd2b573e8de7021"],"7530de27b87b961b51f01bd1299b7004d46e8823":["60eb5eeae4d0ae8321b30a826435b6106634c09b"],"7602e63987582091a0e432f8d8f7619d2206fab7":["7530de27b87b961b51f01bd1299b7004d46e8823"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5676bf22fd531b9a2a3053047d0e0f922c1c53ff"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"c26f00b574427b55127e869b935845554afde1fa":["0d22ac6a4146774c1bc8400160fc0b6150294e92","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"1eeda7e62e149f90eee8895af874c74efa7d4852":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","57641b2e9dc6155be493cfb6ae9b8a9c8ceffa72"],"a219f1dcad1700e84807666bdbd2b573e8de7021":["84bf44b1557bad2a5df2cb3af4c39a2b3f0e1efe"],"0c66f8d4f044af481e9d86acc1b092d44db7c20f":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","d66363068e87a246ce08fee4a42f30f126b92723"],"e7754464847b06ced605515bd48219280ede29e9":["60eb5eeae4d0ae8321b30a826435b6106634c09b"],"2fc9f4a33c8fefeb1260aea04273a36b0d32378e":["a219f1dcad1700e84807666bdbd2b573e8de7021"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":[],"c0d0eda576bd1392f929c375143ff45503e89192":["2fc9f4a33c8fefeb1260aea04273a36b0d32378e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"e14913df9327ed5dfa00075dc1ff09137dbdb896":["37a0f60745e53927c4c876cfe5b5a58170f0646c","849494cf2f3a96af5c8c84995108ddd8456fcd04"],"d66363068e87a246ce08fee4a42f30f126b92723":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","d76dfc2581b6998f72c0e749c6200e9c2432c36f"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["c0d0eda576bd1392f929c375143ff45503e89192"],"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":[],"fa64435b5902ce266c23755a4a00691a3285dab8":["407687e67faf6e1f02a211ca078d8e3eed631027","c5a558d54519c651068ddb202f03befefb1514a7"],"d76dfc2581b6998f72c0e749c6200e9c2432c36f":["8fd5be977c105554c6a7b68afcdbc511439723ab","3f767f8c99eaedb984df754fe61f21c5de260f94","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"407687e67faf6e1f02a211ca078d8e3eed631027":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":[],"8fd5be977c105554c6a7b68afcdbc511439723ab":[],"60eb5eeae4d0ae8321b30a826435b6106634c09b":["407687e67faf6e1f02a211ca078d8e3eed631027","7530de27b87b961b51f01bd1299b7004d46e8823"],"849494cf2f3a96af5c8c84995108ddd8456fcd04":["37a0f60745e53927c4c876cfe5b5a58170f0646c","1eeda7e62e149f90eee8895af874c74efa7d4852"],"3f767f8c99eaedb984df754fe61f21c5de260f94":["fa64435b5902ce266c23755a4a00691a3285dab8","8fd5be977c105554c6a7b68afcdbc511439723ab","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"57641b2e9dc6155be493cfb6ae9b8a9c8ceffa72":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"c5a558d54519c651068ddb202f03befefb1514a7":["e7754464847b06ced605515bd48219280ede29e9"],"5676bf22fd531b9a2a3053047d0e0f922c1c53ff":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":[],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["0c66f8d4f044af481e9d86acc1b092d44db7c20f","0d22ac6a4146774c1bc8400160fc0b6150294e92","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"7530de27b87b961b51f01bd1299b7004d46e8823":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","7602e63987582091a0e432f8d8f7619d2206fab7"],"84bf44b1557bad2a5df2cb3af4c39a2b3f0e1efe":["5676bf22fd531b9a2a3053047d0e0f922c1c53ff"],"7602e63987582091a0e432f8d8f7619d2206fab7":["e14913df9327ed5dfa00075dc1ff09137dbdb896"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","0d22ac6a4146774c1bc8400160fc0b6150294e92","716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","8fd5be977c105554c6a7b68afcdbc511439723ab","d6f074e73200c07d54f242d3880a8da5a35ff97b","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}