{"path":"backwards/src/test/org/apache/lucene/search/TestDateFilter#testAfter().mjava","commits":[{"id":"480d01e5b0ef8efb136d51670fec297ae5ae2c9c","date":1268821447,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"backwards/src/test/org/apache/lucene/search/TestDateFilter#testAfter().mjava","pathOld":"/dev/null","sourceNew":"    /**\n     *\n     */\n    public static void testAfter()\n\tthrows IOException\n    {\n\t// create an index\n        RAMDirectory indexStore = new RAMDirectory();\n        IndexWriter writer = new IndexWriter(indexStore, new SimpleAnalyzer(), true, IndexWriter.MaxFieldLength.LIMITED);\n\n \tlong now = System.currentTimeMillis();\n\n \tDocument doc = new Document();\n \t// add time that is in the future\n \tdoc.add(new Field(\"datefield\", DateTools.timeToString(now + 888888, DateTools.Resolution.MILLISECOND), Field.Store.YES, Field.Index.NOT_ANALYZED));\n \tdoc.add(new Field(\"body\", \"Today is a very sunny day in New York City\", Field.Store.YES, Field.Index.ANALYZED));\n  \twriter.addDocument(doc);\n \twriter.optimize();\n\twriter.close();\n\n\tIndexSearcher searcher = new IndexSearcher(indexStore, true);\n\n\t// filter that should preserve matches\n\t//DateFilter df1 = DateFilter.After(\"datefield\", now);\n    TermRangeFilter df1 = new TermRangeFilter(\"datefield\", DateTools.timeToString(now, DateTools.Resolution.MILLISECOND),\n                                      DateTools.timeToString(now + 999999, DateTools.Resolution.MILLISECOND), true, false);\n\t// filter that should discard matches\n\t//DateFilter df2 = DateFilter.After(\"datefield\", now + 999999);\n    TermRangeFilter df2 = new TermRangeFilter(\"datefield\", DateTools.timeToString(now + 999999, DateTools.Resolution.MILLISECOND),\n                                          DateTools.timeToString(now + 999999999, DateTools.Resolution.MILLISECOND), false, true);\n\n    // search something that doesn't exist with DateFilter\n\tQuery query1 = new TermQuery(new Term(\"body\", \"NoMatchForThis\"));\n\n\t// search for something that does exists\n\tQuery query2 = new TermQuery(new Term(\"body\", \"sunny\"));\n\n  ScoreDoc[] result;\n\n\t// ensure that queries return expected results without DateFilter first\n  result = searcher.search(query1, null, 1000).scoreDocs;\n  assertEquals(0, result.length);\n\n  result = searcher.search(query2, null, 1000).scoreDocs;\n  assertEquals(1, result.length);\n\n\n\t// run queries with DateFilter\n  result = searcher.search(query1, df1, 1000).scoreDocs;\n  assertEquals(0, result.length);\n\n  result = searcher.search(query1, df2, 1000).scoreDocs;\n  assertEquals(0, result.length);\n\n   result = searcher.search(query2, df1, 1000).scoreDocs;\n   assertEquals(1, result.length);\n\n  result = searcher.search(query2, df2, 1000).scoreDocs;\n  assertEquals(0, result.length);\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/backwards/src/test/org/apache/lucene/search/TestDateFilter#testAfter().mjava","pathOld":"backwards/src/test/org/apache/lucene/search/TestDateFilter#testAfter().mjava","sourceNew":"    /**\n     *\n     */\n    public static void testAfter()\n\tthrows IOException\n    {\n\t// create an index\n        RAMDirectory indexStore = new RAMDirectory();\n        IndexWriter writer = new IndexWriter(indexStore, new SimpleAnalyzer(), true, IndexWriter.MaxFieldLength.LIMITED);\n\n \tlong now = System.currentTimeMillis();\n\n \tDocument doc = new Document();\n \t// add time that is in the future\n \tdoc.add(new Field(\"datefield\", DateTools.timeToString(now + 888888, DateTools.Resolution.MILLISECOND), Field.Store.YES, Field.Index.NOT_ANALYZED));\n \tdoc.add(new Field(\"body\", \"Today is a very sunny day in New York City\", Field.Store.YES, Field.Index.ANALYZED));\n  \twriter.addDocument(doc);\n \twriter.optimize();\n\twriter.close();\n\n\tIndexSearcher searcher = new IndexSearcher(indexStore, true);\n\n\t// filter that should preserve matches\n\t//DateFilter df1 = DateFilter.After(\"datefield\", now);\n    TermRangeFilter df1 = new TermRangeFilter(\"datefield\", DateTools.timeToString(now, DateTools.Resolution.MILLISECOND),\n                                      DateTools.timeToString(now + 999999, DateTools.Resolution.MILLISECOND), true, false);\n\t// filter that should discard matches\n\t//DateFilter df2 = DateFilter.After(\"datefield\", now + 999999);\n    TermRangeFilter df2 = new TermRangeFilter(\"datefield\", DateTools.timeToString(now + 999999, DateTools.Resolution.MILLISECOND),\n                                          DateTools.timeToString(now + 999999999, DateTools.Resolution.MILLISECOND), false, true);\n\n    // search something that doesn't exist with DateFilter\n\tQuery query1 = new TermQuery(new Term(\"body\", \"NoMatchForThis\"));\n\n\t// search for something that does exists\n\tQuery query2 = new TermQuery(new Term(\"body\", \"sunny\"));\n\n  ScoreDoc[] result;\n\n\t// ensure that queries return expected results without DateFilter first\n  result = searcher.search(query1, null, 1000).scoreDocs;\n  assertEquals(0, result.length);\n\n  result = searcher.search(query2, null, 1000).scoreDocs;\n  assertEquals(1, result.length);\n\n\n\t// run queries with DateFilter\n  result = searcher.search(query1, df1, 1000).scoreDocs;\n  assertEquals(0, result.length);\n\n  result = searcher.search(query1, df2, 1000).scoreDocs;\n  assertEquals(0, result.length);\n\n   result = searcher.search(query2, df1, 1000).scoreDocs;\n   assertEquals(1, result.length);\n\n  result = searcher.search(query2, df2, 1000).scoreDocs;\n  assertEquals(0, result.length);\n    }\n\n","sourceOld":"    /**\n     *\n     */\n    public static void testAfter()\n\tthrows IOException\n    {\n\t// create an index\n        RAMDirectory indexStore = new RAMDirectory();\n        IndexWriter writer = new IndexWriter(indexStore, new SimpleAnalyzer(), true, IndexWriter.MaxFieldLength.LIMITED);\n\n \tlong now = System.currentTimeMillis();\n\n \tDocument doc = new Document();\n \t// add time that is in the future\n \tdoc.add(new Field(\"datefield\", DateTools.timeToString(now + 888888, DateTools.Resolution.MILLISECOND), Field.Store.YES, Field.Index.NOT_ANALYZED));\n \tdoc.add(new Field(\"body\", \"Today is a very sunny day in New York City\", Field.Store.YES, Field.Index.ANALYZED));\n  \twriter.addDocument(doc);\n \twriter.optimize();\n\twriter.close();\n\n\tIndexSearcher searcher = new IndexSearcher(indexStore, true);\n\n\t// filter that should preserve matches\n\t//DateFilter df1 = DateFilter.After(\"datefield\", now);\n    TermRangeFilter df1 = new TermRangeFilter(\"datefield\", DateTools.timeToString(now, DateTools.Resolution.MILLISECOND),\n                                      DateTools.timeToString(now + 999999, DateTools.Resolution.MILLISECOND), true, false);\n\t// filter that should discard matches\n\t//DateFilter df2 = DateFilter.After(\"datefield\", now + 999999);\n    TermRangeFilter df2 = new TermRangeFilter(\"datefield\", DateTools.timeToString(now + 999999, DateTools.Resolution.MILLISECOND),\n                                          DateTools.timeToString(now + 999999999, DateTools.Resolution.MILLISECOND), false, true);\n\n    // search something that doesn't exist with DateFilter\n\tQuery query1 = new TermQuery(new Term(\"body\", \"NoMatchForThis\"));\n\n\t// search for something that does exists\n\tQuery query2 = new TermQuery(new Term(\"body\", \"sunny\"));\n\n  ScoreDoc[] result;\n\n\t// ensure that queries return expected results without DateFilter first\n  result = searcher.search(query1, null, 1000).scoreDocs;\n  assertEquals(0, result.length);\n\n  result = searcher.search(query2, null, 1000).scoreDocs;\n  assertEquals(1, result.length);\n\n\n\t// run queries with DateFilter\n  result = searcher.search(query1, df1, 1000).scoreDocs;\n  assertEquals(0, result.length);\n\n  result = searcher.search(query1, df2, 1000).scoreDocs;\n  assertEquals(0, result.length);\n\n   result = searcher.search(query2, df1, 1000).scoreDocs;\n   assertEquals(1, result.length);\n\n  result = searcher.search(query2, df2, 1000).scoreDocs;\n  assertEquals(0, result.length);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"480d01e5b0ef8efb136d51670fec297ae5ae2c9c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["480d01e5b0ef8efb136d51670fec297ae5ae2c9c"]},"commit2Childs":{"480d01e5b0ef8efb136d51670fec297ae5ae2c9c":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["480d01e5b0ef8efb136d51670fec297ae5ae2c9c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}