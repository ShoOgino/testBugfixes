{"path":"lucene/sandbox/src/java/org/apache/lucene/util/GeoProjectionUtils#pointFromLonLatBearing(double,double,double,double,double[]).mjava","commits":[{"id":"a4c5421d43870949fb33be27fc9cba0f8f3a7c8d","date":1437181221,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/util/GeoProjectionUtils#pointFromLonLatBearing(double,double,double,double,double[]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Finds a point along a bearing from a given lon,lat geolocation using vincenty's distance formula\n   *\n   * @param lon origin longitude in degrees\n   * @param lat origin latitude in degrees\n   * @param bearing azimuthal bearing in degrees\n   * @param dist distance in meters\n   * @param pt resulting point\n   * @return the point along a bearing at a given distance in meters\n   */\n  public static final double[] pointFromLonLatBearing(double lon, double lat, double bearing, double dist, double[] pt) {\n\n    if (pt == null) {\n      pt = new double[2];\n    }\n\n    final double alpha1 = StrictMath.toRadians(bearing);\n    final double cosA1 = StrictMath.cos(alpha1);\n    final double sinA1 = StrictMath.sin(alpha1);\n    final double tanU1 = (1-FLATTENING) * StrictMath.tan(StrictMath.toRadians(lat));\n    final double cosU1 = 1 / StrictMath.sqrt((1+tanU1*tanU1));\n    final double sinU1 = tanU1*cosU1;\n    final double sig1 = StrictMath.atan2(tanU1, cosA1);\n    final double sinAlpha = cosU1 * sinA1;\n    final double cosSqAlpha = 1 - sinAlpha*sinAlpha;\n    final double uSq = cosSqAlpha * (SEMIMAJOR_AXIS2 - SEMIMINOR_AXIS2) / SEMIMINOR_AXIS2;\n    final double A = 1 + uSq/16384D*(4096D + uSq * (-768D + uSq * (320D - 175D*uSq)));\n    final double B = uSq/1024D * (256D + uSq * (-128D + uSq * (74D - 47D * uSq)));\n\n    double sigma = dist / (SEMIMINOR_AXIS*A);\n    double sigmaP;\n    double sinSigma, cosSigma, cos2SigmaM, deltaSigma;\n\n    do {\n      cos2SigmaM = StrictMath.cos(2*sig1 + sigma);\n      sinSigma = StrictMath.sin(sigma);\n      cosSigma = StrictMath.cos(sigma);\n\n      deltaSigma = B * sinSigma * (cos2SigmaM + (B/4D) * (cosSigma*(-1+2*cos2SigmaM*cos2SigmaM)-\n          (B/6) * cos2SigmaM*(-3+4*sinSigma*sinSigma)*(-3+4*cos2SigmaM*cos2SigmaM)));\n      sigmaP = sigma;\n      sigma = dist / (SEMIMINOR_AXIS*A) + deltaSigma;\n    } while (StrictMath.abs(sigma-sigmaP) > 1E-12);\n\n    final double tmp = sinU1*sinSigma - cosU1*cosSigma*cosA1;\n    final double lat2 = StrictMath.atan2(sinU1*cosSigma + cosU1*sinSigma*cosA1,\n        (1-FLATTENING) * StrictMath.sqrt(sinAlpha*sinAlpha + tmp*tmp));\n    final double lambda = StrictMath.atan2(sinSigma*sinA1, cosU1*cosSigma - sinU1*sinSigma*cosA1);\n    final double c = FLATTENING/16 * cosSqAlpha * (4 + FLATTENING * (4 - 3 * cosSqAlpha));\n\n    final double lam = lambda - (1-c) * FLATTENING * sinAlpha *\n        (sigma + c * sinSigma * (cos2SigmaM + c * cosSigma * (-1 + 2* cos2SigmaM*cos2SigmaM)));\n    pt[0] = lon + StrictMath.toDegrees(lam);\n    pt[1] = StrictMath.toDegrees(lat2);\n\n    return pt;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"07c50cb1eca5629cac5b6702dd0f5e06157af61a","date":1445464748,"type":3,"author":"Nick Knize","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/util/GeoProjectionUtils#pointFromLonLatBearing(double,double,double,double,double[]).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/util/GeoProjectionUtils#pointFromLonLatBearing(double,double,double,double,double[]).mjava","sourceNew":"  /**\n   * Finds a point along a bearing from a given lon,lat geolocation using vincenty's distance formula\n   *\n   * @param lon origin longitude in degrees\n   * @param lat origin latitude in degrees\n   * @param bearing azimuthal bearing in degrees\n   * @param dist distance in meters\n   * @param pt resulting point\n   * @return the point along a bearing at a given distance in meters\n   */\n  public static final double[] pointFromLonLatBearing(double lon, double lat, double bearing, double dist, double[] pt) {\n\n    if (pt == null) {\n      pt = new double[2];\n    }\n\n    final double alpha1 = StrictMath.toRadians(bearing);\n    final double cosA1 = StrictMath.cos(alpha1);\n    final double sinA1 = StrictMath.sin(alpha1);\n    final double tanU1 = (1-FLATTENING) * StrictMath.tan(StrictMath.toRadians(lat));\n    final double cosU1 = 1 / StrictMath.sqrt((1+tanU1*tanU1));\n    final double sinU1 = tanU1*cosU1;\n    final double sig1 = StrictMath.atan2(tanU1, cosA1);\n    final double sinAlpha = cosU1 * sinA1;\n    final double cosSqAlpha = 1 - sinAlpha*sinAlpha;\n    final double uSq = cosSqAlpha * (SEMIMAJOR_AXIS2 - SEMIMINOR_AXIS2) / SEMIMINOR_AXIS2;\n    final double A = 1 + uSq/16384D*(4096D + uSq * (-768D + uSq * (320D - 175D*uSq)));\n    final double B = uSq/1024D * (256D + uSq * (-128D + uSq * (74D - 47D * uSq)));\n\n    double sigma = dist / (SEMIMINOR_AXIS*A);\n    double sigmaP;\n    double sinSigma, cosSigma, cos2SigmaM, deltaSigma;\n\n    do {\n      cos2SigmaM = StrictMath.cos(2*sig1 + sigma);\n      sinSigma = StrictMath.sin(sigma);\n      cosSigma = StrictMath.cos(sigma);\n\n      deltaSigma = B * sinSigma * (cos2SigmaM + (B/4D) * (cosSigma*(-1+2*cos2SigmaM*cos2SigmaM)-\n          (B/6) * cos2SigmaM*(-3+4*sinSigma*sinSigma)*(-3+4*cos2SigmaM*cos2SigmaM)));\n      sigmaP = sigma;\n      sigma = dist / (SEMIMINOR_AXIS*A) + deltaSigma;\n    } while (StrictMath.abs(sigma-sigmaP) > 1E-12);\n\n    final double tmp = sinU1*sinSigma - cosU1*cosSigma*cosA1;\n    final double lat2 = StrictMath.atan2(sinU1*cosSigma + cosU1*sinSigma*cosA1,\n        (1-FLATTENING) * StrictMath.sqrt(sinAlpha*sinAlpha + tmp*tmp));\n    final double lambda = StrictMath.atan2(sinSigma*sinA1, cosU1*cosSigma - sinU1*sinSigma*cosA1);\n    final double c = FLATTENING/16 * cosSqAlpha * (4 + FLATTENING * (4 - 3 * cosSqAlpha));\n\n    final double lam = lambda - (1-c) * FLATTENING * sinAlpha *\n        (sigma + c * sinSigma * (cos2SigmaM + c * cosSigma * (-1 + 2* cos2SigmaM*cos2SigmaM)));\n    pt[0] = GeoUtils.normalizeLon(lon + StrictMath.toDegrees(lam));\n    pt[1] = GeoUtils.normalizeLat(StrictMath.toDegrees(lat2));\n\n    return pt;\n  }\n\n","sourceOld":"  /**\n   * Finds a point along a bearing from a given lon,lat geolocation using vincenty's distance formula\n   *\n   * @param lon origin longitude in degrees\n   * @param lat origin latitude in degrees\n   * @param bearing azimuthal bearing in degrees\n   * @param dist distance in meters\n   * @param pt resulting point\n   * @return the point along a bearing at a given distance in meters\n   */\n  public static final double[] pointFromLonLatBearing(double lon, double lat, double bearing, double dist, double[] pt) {\n\n    if (pt == null) {\n      pt = new double[2];\n    }\n\n    final double alpha1 = StrictMath.toRadians(bearing);\n    final double cosA1 = StrictMath.cos(alpha1);\n    final double sinA1 = StrictMath.sin(alpha1);\n    final double tanU1 = (1-FLATTENING) * StrictMath.tan(StrictMath.toRadians(lat));\n    final double cosU1 = 1 / StrictMath.sqrt((1+tanU1*tanU1));\n    final double sinU1 = tanU1*cosU1;\n    final double sig1 = StrictMath.atan2(tanU1, cosA1);\n    final double sinAlpha = cosU1 * sinA1;\n    final double cosSqAlpha = 1 - sinAlpha*sinAlpha;\n    final double uSq = cosSqAlpha * (SEMIMAJOR_AXIS2 - SEMIMINOR_AXIS2) / SEMIMINOR_AXIS2;\n    final double A = 1 + uSq/16384D*(4096D + uSq * (-768D + uSq * (320D - 175D*uSq)));\n    final double B = uSq/1024D * (256D + uSq * (-128D + uSq * (74D - 47D * uSq)));\n\n    double sigma = dist / (SEMIMINOR_AXIS*A);\n    double sigmaP;\n    double sinSigma, cosSigma, cos2SigmaM, deltaSigma;\n\n    do {\n      cos2SigmaM = StrictMath.cos(2*sig1 + sigma);\n      sinSigma = StrictMath.sin(sigma);\n      cosSigma = StrictMath.cos(sigma);\n\n      deltaSigma = B * sinSigma * (cos2SigmaM + (B/4D) * (cosSigma*(-1+2*cos2SigmaM*cos2SigmaM)-\n          (B/6) * cos2SigmaM*(-3+4*sinSigma*sinSigma)*(-3+4*cos2SigmaM*cos2SigmaM)));\n      sigmaP = sigma;\n      sigma = dist / (SEMIMINOR_AXIS*A) + deltaSigma;\n    } while (StrictMath.abs(sigma-sigmaP) > 1E-12);\n\n    final double tmp = sinU1*sinSigma - cosU1*cosSigma*cosA1;\n    final double lat2 = StrictMath.atan2(sinU1*cosSigma + cosU1*sinSigma*cosA1,\n        (1-FLATTENING) * StrictMath.sqrt(sinAlpha*sinAlpha + tmp*tmp));\n    final double lambda = StrictMath.atan2(sinSigma*sinA1, cosU1*cosSigma - sinU1*sinSigma*cosA1);\n    final double c = FLATTENING/16 * cosSqAlpha * (4 + FLATTENING * (4 - 3 * cosSqAlpha));\n\n    final double lam = lambda - (1-c) * FLATTENING * sinAlpha *\n        (sigma + c * sinSigma * (cos2SigmaM + c * cosSigma * (-1 + 2* cos2SigmaM*cos2SigmaM)));\n    pt[0] = lon + StrictMath.toDegrees(lam);\n    pt[1] = StrictMath.toDegrees(lat2);\n\n    return pt;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"33bb6bd7295e66f93f182556f5353b97243e62ba","date":1449525768,"type":5,"author":"Nick Knize","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/util/GeoProjectionUtils#pointFromLonLatBearingVincenty(double,double,double,double,double[]).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/util/GeoProjectionUtils#pointFromLonLatBearing(double,double,double,double,double[]).mjava","sourceNew":"  /**\n   * Finds a point along a bearing from a given lon,lat geolocation using vincenty's distance formula\n   *\n   * @param lon origin longitude in degrees\n   * @param lat origin latitude in degrees\n   * @param bearing azimuthal bearing in degrees\n   * @param dist distance in meters\n   * @param pt resulting point\n   * @return the point along a bearing at a given distance in meters\n   */\n  public static final double[] pointFromLonLatBearingVincenty(double lon, double lat, double bearing, double dist, double[] pt) {\n\n    if (pt == null) {\n      pt = new double[2];\n    }\n\n    final double alpha1 = TO_RADIANS * bearing;\n    final double cosA1 = SloppyMath.cos(alpha1);\n    final double sinA1 = SloppyMath.sin(alpha1);\n    final double tanU1 = (1-FLATTENING) * SloppyMath.tan(TO_RADIANS * lat);\n    final double cosU1 = 1 / StrictMath.sqrt((1+tanU1*tanU1));\n    final double sinU1 = tanU1*cosU1;\n    final double sig1 = StrictMath.atan2(tanU1, cosA1);\n    final double sinAlpha = cosU1 * sinA1;\n    final double cosSqAlpha = 1 - sinAlpha*sinAlpha;\n    final double uSq = cosSqAlpha * EP2;\n    final double A = 1 + uSq/16384D*(4096D + uSq * (-768D + uSq * (320D - 175D*uSq)));\n    final double B = uSq/1024D * (256D + uSq * (-128D + uSq * (74D - 47D * uSq)));\n\n    double sigma = dist / (SEMIMINOR_AXIS*A);\n    double sigmaP;\n    double sinSigma, cosSigma, cos2SigmaM, deltaSigma;\n\n    do {\n      cos2SigmaM = SloppyMath.cos(2*sig1 + sigma);\n      sinSigma = SloppyMath.sin(sigma);\n      cosSigma = SloppyMath.cos(sigma);\n\n      deltaSigma = B * sinSigma * (cos2SigmaM + (B/4D) * (cosSigma*(-1+2*cos2SigmaM*cos2SigmaM)-\n          (B/6) * cos2SigmaM*(-3+4*sinSigma*sinSigma)*(-3+4*cos2SigmaM*cos2SigmaM)));\n      sigmaP = sigma;\n      sigma = dist / (SEMIMINOR_AXIS*A) + deltaSigma;\n    } while (StrictMath.abs(sigma-sigmaP) > 1E-12);\n\n    final double tmp = sinU1*sinSigma - cosU1*cosSigma*cosA1;\n    final double lat2 = StrictMath.atan2(sinU1*cosSigma + cosU1*sinSigma*cosA1,\n        (1-FLATTENING) * StrictMath.sqrt(sinAlpha*sinAlpha + tmp*tmp));\n    final double lambda = StrictMath.atan2(sinSigma*sinA1, cosU1*cosSigma - sinU1*sinSigma*cosA1);\n    final double c = FLATTENING/16 * cosSqAlpha * (4 + FLATTENING * (4 - 3 * cosSqAlpha));\n\n    final double lam = lambda - (1-c) * FLATTENING * sinAlpha *\n        (sigma + c * sinSigma * (cos2SigmaM + c * cosSigma * (-1 + 2* cos2SigmaM*cos2SigmaM)));\n    pt[0] = GeoUtils.normalizeLon(lon + TO_DEGREES * lam);\n    pt[1] = GeoUtils.normalizeLat(TO_DEGREES * lat2);\n\n    return pt;\n  }\n\n","sourceOld":"  /**\n   * Finds a point along a bearing from a given lon,lat geolocation using vincenty's distance formula\n   *\n   * @param lon origin longitude in degrees\n   * @param lat origin latitude in degrees\n   * @param bearing azimuthal bearing in degrees\n   * @param dist distance in meters\n   * @param pt resulting point\n   * @return the point along a bearing at a given distance in meters\n   */\n  public static final double[] pointFromLonLatBearing(double lon, double lat, double bearing, double dist, double[] pt) {\n\n    if (pt == null) {\n      pt = new double[2];\n    }\n\n    final double alpha1 = StrictMath.toRadians(bearing);\n    final double cosA1 = StrictMath.cos(alpha1);\n    final double sinA1 = StrictMath.sin(alpha1);\n    final double tanU1 = (1-FLATTENING) * StrictMath.tan(StrictMath.toRadians(lat));\n    final double cosU1 = 1 / StrictMath.sqrt((1+tanU1*tanU1));\n    final double sinU1 = tanU1*cosU1;\n    final double sig1 = StrictMath.atan2(tanU1, cosA1);\n    final double sinAlpha = cosU1 * sinA1;\n    final double cosSqAlpha = 1 - sinAlpha*sinAlpha;\n    final double uSq = cosSqAlpha * (SEMIMAJOR_AXIS2 - SEMIMINOR_AXIS2) / SEMIMINOR_AXIS2;\n    final double A = 1 + uSq/16384D*(4096D + uSq * (-768D + uSq * (320D - 175D*uSq)));\n    final double B = uSq/1024D * (256D + uSq * (-128D + uSq * (74D - 47D * uSq)));\n\n    double sigma = dist / (SEMIMINOR_AXIS*A);\n    double sigmaP;\n    double sinSigma, cosSigma, cos2SigmaM, deltaSigma;\n\n    do {\n      cos2SigmaM = StrictMath.cos(2*sig1 + sigma);\n      sinSigma = StrictMath.sin(sigma);\n      cosSigma = StrictMath.cos(sigma);\n\n      deltaSigma = B * sinSigma * (cos2SigmaM + (B/4D) * (cosSigma*(-1+2*cos2SigmaM*cos2SigmaM)-\n          (B/6) * cos2SigmaM*(-3+4*sinSigma*sinSigma)*(-3+4*cos2SigmaM*cos2SigmaM)));\n      sigmaP = sigma;\n      sigma = dist / (SEMIMINOR_AXIS*A) + deltaSigma;\n    } while (StrictMath.abs(sigma-sigmaP) > 1E-12);\n\n    final double tmp = sinU1*sinSigma - cosU1*cosSigma*cosA1;\n    final double lat2 = StrictMath.atan2(sinU1*cosSigma + cosU1*sinSigma*cosA1,\n        (1-FLATTENING) * StrictMath.sqrt(sinAlpha*sinAlpha + tmp*tmp));\n    final double lambda = StrictMath.atan2(sinSigma*sinA1, cosU1*cosSigma - sinU1*sinSigma*cosA1);\n    final double c = FLATTENING/16 * cosSqAlpha * (4 + FLATTENING * (4 - 3 * cosSqAlpha));\n\n    final double lam = lambda - (1-c) * FLATTENING * sinAlpha *\n        (sigma + c * sinSigma * (cos2SigmaM + c * cosSigma * (-1 + 2* cos2SigmaM*cos2SigmaM)));\n    pt[0] = GeoUtils.normalizeLon(lon + StrictMath.toDegrees(lam));\n    pt[1] = GeoUtils.normalizeLat(StrictMath.toDegrees(lat2));\n\n    return pt;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a4c5421d43870949fb33be27fc9cba0f8f3a7c8d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"07c50cb1eca5629cac5b6702dd0f5e06157af61a":["a4c5421d43870949fb33be27fc9cba0f8f3a7c8d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["33bb6bd7295e66f93f182556f5353b97243e62ba"],"33bb6bd7295e66f93f182556f5353b97243e62ba":["07c50cb1eca5629cac5b6702dd0f5e06157af61a"]},"commit2Childs":{"a4c5421d43870949fb33be27fc9cba0f8f3a7c8d":["07c50cb1eca5629cac5b6702dd0f5e06157af61a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a4c5421d43870949fb33be27fc9cba0f8f3a7c8d"],"07c50cb1eca5629cac5b6702dd0f5e06157af61a":["33bb6bd7295e66f93f182556f5353b97243e62ba"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"33bb6bd7295e66f93f182556f5353b97243e62ba":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}