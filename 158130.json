{"path":"lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldPhraseList#FieldPhraseList(FieldTermStack,FieldQuery,int).mjava","commits":[{"id":"f5677ab05eb69cf61643b4c82187f841ca2f3345","date":1309139083,"type":0,"author":"Koji Sekiguchi","isMerge":false,"pathNew":"lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldPhraseList#FieldPhraseList(FieldTermStack,FieldQuery,int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * a constructor.\n   * \n   * @param fieldTermStack FieldTermStack object\n   * @param fieldQuery FieldQuery object\n   * @param phraseLimit maximum size of phraseList\n   */\n  public FieldPhraseList( FieldTermStack fieldTermStack, FieldQuery fieldQuery, int phraseLimit){\n    final String field = fieldTermStack.getFieldName();\n\n    LinkedList<TermInfo> phraseCandidate = new LinkedList<TermInfo>();\n    QueryPhraseMap currMap = null;\n    QueryPhraseMap nextMap = null;\n    while( !fieldTermStack.isEmpty() && (phraseList.size() < phraseLimit) )\n    {      \n      phraseCandidate.clear();\n\n      TermInfo ti = fieldTermStack.pop();\n      currMap = fieldQuery.getFieldTermMap( field, ti.getText() );\n\n      // if not found, discard top TermInfo from stack, then try next element\n      if( currMap == null ) continue;\n      \n      // if found, search the longest phrase\n      phraseCandidate.add( ti );\n      while( true ){\n        ti = fieldTermStack.pop();\n        nextMap = null;\n        if( ti != null )\n          nextMap = currMap.getTermMap( ti.getText() );\n        if( ti == null || nextMap == null ){\n          if( ti != null )\n            fieldTermStack.push( ti );\n          if( currMap.isValidTermOrPhrase( phraseCandidate ) ){\n            addIfNoOverlap( new WeightedPhraseInfo( phraseCandidate, currMap.getBoost(), currMap.getTermOrPhraseNumber() ) );\n          }\n          else{\n            while( phraseCandidate.size() > 1 ){\n              fieldTermStack.push( phraseCandidate.removeLast() );\n              currMap = fieldQuery.searchPhrase( field, phraseCandidate );\n              if( currMap != null ){\n                addIfNoOverlap( new WeightedPhraseInfo( phraseCandidate, currMap.getBoost(), currMap.getTermOrPhraseNumber() ) );\n                break;\n              }\n            }\n          }\n          break;\n        }\n        else{\n          phraseCandidate.add( ti );\n          currMap = nextMap;\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["4de9b9325d973e4bc4c97eb91fe119eafa6caa99"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2553b00f699380c64959ccb27991289aae87be2e","date":1309290151,"type":0,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldPhraseList#FieldPhraseList(FieldTermStack,FieldQuery,int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * a constructor.\n   * \n   * @param fieldTermStack FieldTermStack object\n   * @param fieldQuery FieldQuery object\n   * @param phraseLimit maximum size of phraseList\n   */\n  public FieldPhraseList( FieldTermStack fieldTermStack, FieldQuery fieldQuery, int phraseLimit){\n    final String field = fieldTermStack.getFieldName();\n\n    LinkedList<TermInfo> phraseCandidate = new LinkedList<TermInfo>();\n    QueryPhraseMap currMap = null;\n    QueryPhraseMap nextMap = null;\n    while( !fieldTermStack.isEmpty() && (phraseList.size() < phraseLimit) )\n    {      \n      phraseCandidate.clear();\n\n      TermInfo ti = fieldTermStack.pop();\n      currMap = fieldQuery.getFieldTermMap( field, ti.getText() );\n\n      // if not found, discard top TermInfo from stack, then try next element\n      if( currMap == null ) continue;\n      \n      // if found, search the longest phrase\n      phraseCandidate.add( ti );\n      while( true ){\n        ti = fieldTermStack.pop();\n        nextMap = null;\n        if( ti != null )\n          nextMap = currMap.getTermMap( ti.getText() );\n        if( ti == null || nextMap == null ){\n          if( ti != null )\n            fieldTermStack.push( ti );\n          if( currMap.isValidTermOrPhrase( phraseCandidate ) ){\n            addIfNoOverlap( new WeightedPhraseInfo( phraseCandidate, currMap.getBoost(), currMap.getTermOrPhraseNumber() ) );\n          }\n          else{\n            while( phraseCandidate.size() > 1 ){\n              fieldTermStack.push( phraseCandidate.removeLast() );\n              currMap = fieldQuery.searchPhrase( field, phraseCandidate );\n              if( currMap != null ){\n                addIfNoOverlap( new WeightedPhraseInfo( phraseCandidate, currMap.getBoost(), currMap.getTermOrPhraseNumber() ) );\n                break;\n              }\n            }\n          }\n          break;\n        }\n        else{\n          phraseCandidate.add( ti );\n          currMap = nextMap;\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d083e83f225b11e5fdd900e83d26ddb385b6955c","date":1310029438,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldPhraseList#FieldPhraseList(FieldTermStack,FieldQuery,int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * a constructor.\n   * \n   * @param fieldTermStack FieldTermStack object\n   * @param fieldQuery FieldQuery object\n   * @param phraseLimit maximum size of phraseList\n   */\n  public FieldPhraseList( FieldTermStack fieldTermStack, FieldQuery fieldQuery, int phraseLimit){\n    final String field = fieldTermStack.getFieldName();\n\n    LinkedList<TermInfo> phraseCandidate = new LinkedList<TermInfo>();\n    QueryPhraseMap currMap = null;\n    QueryPhraseMap nextMap = null;\n    while( !fieldTermStack.isEmpty() && (phraseList.size() < phraseLimit) )\n    {      \n      phraseCandidate.clear();\n\n      TermInfo ti = fieldTermStack.pop();\n      currMap = fieldQuery.getFieldTermMap( field, ti.getText() );\n\n      // if not found, discard top TermInfo from stack, then try next element\n      if( currMap == null ) continue;\n      \n      // if found, search the longest phrase\n      phraseCandidate.add( ti );\n      while( true ){\n        ti = fieldTermStack.pop();\n        nextMap = null;\n        if( ti != null )\n          nextMap = currMap.getTermMap( ti.getText() );\n        if( ti == null || nextMap == null ){\n          if( ti != null )\n            fieldTermStack.push( ti );\n          if( currMap.isValidTermOrPhrase( phraseCandidate ) ){\n            addIfNoOverlap( new WeightedPhraseInfo( phraseCandidate, currMap.getBoost(), currMap.getTermOrPhraseNumber() ) );\n          }\n          else{\n            while( phraseCandidate.size() > 1 ){\n              fieldTermStack.push( phraseCandidate.removeLast() );\n              currMap = fieldQuery.searchPhrase( field, phraseCandidate );\n              if( currMap != null ){\n                addIfNoOverlap( new WeightedPhraseInfo( phraseCandidate, currMap.getBoost(), currMap.getTermOrPhraseNumber() ) );\n                break;\n              }\n            }\n          }\n          break;\n        }\n        else{\n          phraseCandidate.add( ti );\n          currMap = nextMap;\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldPhraseList#FieldPhraseList(FieldTermStack,FieldQuery,int).mjava","pathOld":"lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldPhraseList#FieldPhraseList(FieldTermStack,FieldQuery,int).mjava","sourceNew":"  /**\n   * a constructor.\n   * \n   * @param fieldTermStack FieldTermStack object\n   * @param fieldQuery FieldQuery object\n   * @param phraseLimit maximum size of phraseList\n   */\n  public FieldPhraseList( FieldTermStack fieldTermStack, FieldQuery fieldQuery, int phraseLimit){\n    final String field = fieldTermStack.getFieldName();\n\n    LinkedList<TermInfo> phraseCandidate = new LinkedList<TermInfo>();\n    QueryPhraseMap currMap = null;\n    QueryPhraseMap nextMap = null;\n    while( !fieldTermStack.isEmpty() && (phraseList.size() < phraseLimit) )\n    {      \n      phraseCandidate.clear();\n\n      TermInfo ti = fieldTermStack.pop();\n      currMap = fieldQuery.getFieldTermMap( field, ti.getText() );\n\n      // if not found, discard top TermInfo from stack, then try next element\n      if( currMap == null ) continue;\n      \n      // if found, search the longest phrase\n      phraseCandidate.add( ti );\n      while( true ){\n        ti = fieldTermStack.pop();\n        nextMap = null;\n        if( ti != null )\n          nextMap = currMap.getTermMap( ti.getText() );\n        if( ti == null || nextMap == null ){\n          if( ti != null )\n            fieldTermStack.push( ti );\n          if( currMap.isValidTermOrPhrase( phraseCandidate ) ){\n            addIfNoOverlap( new WeightedPhraseInfo( phraseCandidate, currMap.getBoost(), currMap.getTermOrPhraseNumber() ) );\n          }\n          else{\n            while( phraseCandidate.size() > 1 ){\n              fieldTermStack.push( phraseCandidate.removeLast() );\n              currMap = fieldQuery.searchPhrase( field, phraseCandidate );\n              if( currMap != null ){\n                addIfNoOverlap( new WeightedPhraseInfo( phraseCandidate, currMap.getBoost(), currMap.getTermOrPhraseNumber() ) );\n                break;\n              }\n            }\n          }\n          break;\n        }\n        else{\n          phraseCandidate.add( ti );\n          currMap = nextMap;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * a constructor.\n   * \n   * @param fieldTermStack FieldTermStack object\n   * @param fieldQuery FieldQuery object\n   * @param phraseLimit maximum size of phraseList\n   */\n  public FieldPhraseList( FieldTermStack fieldTermStack, FieldQuery fieldQuery, int phraseLimit){\n    final String field = fieldTermStack.getFieldName();\n\n    LinkedList<TermInfo> phraseCandidate = new LinkedList<TermInfo>();\n    QueryPhraseMap currMap = null;\n    QueryPhraseMap nextMap = null;\n    while( !fieldTermStack.isEmpty() && (phraseList.size() < phraseLimit) )\n    {      \n      phraseCandidate.clear();\n\n      TermInfo ti = fieldTermStack.pop();\n      currMap = fieldQuery.getFieldTermMap( field, ti.getText() );\n\n      // if not found, discard top TermInfo from stack, then try next element\n      if( currMap == null ) continue;\n      \n      // if found, search the longest phrase\n      phraseCandidate.add( ti );\n      while( true ){\n        ti = fieldTermStack.pop();\n        nextMap = null;\n        if( ti != null )\n          nextMap = currMap.getTermMap( ti.getText() );\n        if( ti == null || nextMap == null ){\n          if( ti != null )\n            fieldTermStack.push( ti );\n          if( currMap.isValidTermOrPhrase( phraseCandidate ) ){\n            addIfNoOverlap( new WeightedPhraseInfo( phraseCandidate, currMap.getBoost(), currMap.getTermOrPhraseNumber() ) );\n          }\n          else{\n            while( phraseCandidate.size() > 1 ){\n              fieldTermStack.push( phraseCandidate.removeLast() );\n              currMap = fieldQuery.searchPhrase( field, phraseCandidate );\n              if( currMap != null ){\n                addIfNoOverlap( new WeightedPhraseInfo( phraseCandidate, currMap.getBoost(), currMap.getTermOrPhraseNumber() ) );\n                break;\n              }\n            }\n          }\n          break;\n        }\n        else{\n          phraseCandidate.add( ti );\n          currMap = nextMap;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["f5677ab05eb69cf61643b4c82187f841ca2f3345"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2553b00f699380c64959ccb27991289aae87be2e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","f5677ab05eb69cf61643b4c82187f841ca2f3345"],"f5677ab05eb69cf61643b4c82187f841ca2f3345":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","f5677ab05eb69cf61643b4c82187f841ca2f3345"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b89678825b68eccaf09e6ab71675fc0b0af1e099"]},"commit2Childs":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["2553b00f699380c64959ccb27991289aae87be2e","f5677ab05eb69cf61643b4c82187f841ca2f3345","d083e83f225b11e5fdd900e83d26ddb385b6955c"],"2553b00f699380c64959ccb27991289aae87be2e":[],"f5677ab05eb69cf61643b4c82187f841ca2f3345":["b89678825b68eccaf09e6ab71675fc0b0af1e099","2553b00f699380c64959ccb27991289aae87be2e","d083e83f225b11e5fdd900e83d26ddb385b6955c"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["2553b00f699380c64959ccb27991289aae87be2e","d083e83f225b11e5fdd900e83d26ddb385b6955c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}