{"path":"solr/contrib/analysis-extras/src/java/org/apache/solr/update/processor/OpenNLPExtractNamedEntitiesUpdateProcessorFactory#initSourceSelectorSyntax(NamedList).mjava","commits":[{"id":"afc5b4b2446e392448f36ae4f5a164540f2ccb65","date":1513355058,"type":0,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/contrib/analysis-extras/src/java/org/apache/solr/update/processor/OpenNLPExtractNamedEntitiesUpdateProcessorFactory#initSourceSelectorSyntax(NamedList).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * init helper method that should only be called when we know for certain that both the\n   * \"source\" and \"dest\" init params <em>do</em> exist.\n   */\n  @SuppressWarnings(\"unchecked\")\n  private void initSourceSelectorSyntax(NamedList args) {\n    // Full and complete syntax where source and dest are mandatory.\n    //\n    // source may be a single string or a selector.\n    // dest may be a single string or list containing pattern and replacement\n    //\n    //   source != null && dest != null\n\n    // if we got here we know we had source and dest, now check for the other two so that we can give a better\n    // message than \"unexpected\"\n    if (0 <= args.indexOf(PATTERN_PARAM, 0) || 0 <= args.indexOf(REPLACEMENT_PARAM, 0) ) {\n      throw new SolrException(SERVER_ERROR,\"Short hand syntax must not be mixed with full syntax. Found \" +\n          SOURCE_PARAM + \" and \" + DEST_PARAM + \" but also found \" + PATTERN_PARAM + \" or \" + REPLACEMENT_PARAM);\n    }\n\n    Object d = args.remove(DEST_PARAM);\n    assert null != d;\n\n    List<Object> sources = args.getAll(SOURCE_PARAM);\n    assert null != sources;\n\n    if (1 == sources.size()) {\n      if (sources.get(0) instanceof NamedList) {\n        // nested set of selector options\n        NamedList selectorConfig = (NamedList) args.remove(SOURCE_PARAM);\n\n        srcInclusions = parseSelectorParams(selectorConfig);\n\n        List<Object> excList = selectorConfig.getAll(\"exclude\");\n\n        for (Object excObj : excList) {\n          if (null == excObj) {\n            throw new SolrException(SERVER_ERROR, \"Init param '\" + SOURCE_PARAM +\n                \"' child 'exclude' can not be null\");\n          }\n          if (!(excObj instanceof NamedList)) {\n            throw new SolrException(SERVER_ERROR, \"Init param '\" + SOURCE_PARAM +\n                \"' child 'exclude' must be <lst/>\");\n          }\n          NamedList exc = (NamedList) excObj;\n          srcExclusions.add(parseSelectorParams(exc));\n          if (0 < exc.size()) {\n            throw new SolrException(SERVER_ERROR, \"Init param '\" + SOURCE_PARAM +\n                \"' has unexpected 'exclude' sub-param(s): '\"\n                + selectorConfig.getName(0) + \"'\");\n          }\n          // call once per instance\n          selectorConfig.remove(\"exclude\");\n        }\n\n        if (0 < selectorConfig.size()) {\n          throw new SolrException(SERVER_ERROR, \"Init param '\" + SOURCE_PARAM +\n              \"' contains unexpected child param(s): '\" +\n              selectorConfig.getName(0) + \"'\");\n        }\n        // consume from the named list so it doesn't interfere with subsequent processing\n        sources.remove(0);\n      }\n    }\n    if (1 <= sources.size()) {\n      // source better be one or more strings\n      srcInclusions.fieldName = new HashSet<>(args.removeConfigArgs(\"source\"));\n    }\n    if (srcInclusions == null) {\n      throw new SolrException(SERVER_ERROR,\n          \"Init params do not specify any field from which to extract entities, please supply either \"\n          + SOURCE_PARAM + \" and \" + DEST_PARAM + \" or \" + PATTERN_PARAM + \" and \" + REPLACEMENT_PARAM + \". See javadocs\" +\n          \"for OpenNLPExtractNamedEntitiesUpdateProcessor for further details.\");\n    }\n\n    if (d instanceof NamedList) {\n      NamedList destList = (NamedList) d;\n\n      Object patt = destList.remove(PATTERN_PARAM);\n      Object replacement = destList.remove(REPLACEMENT_PARAM);\n\n      if (null == patt || null == replacement) {\n        throw new SolrException(SERVER_ERROR, \"Init param '\" + DEST_PARAM + \"' children '\" +\n            PATTERN_PARAM + \"' and '\" + REPLACEMENT_PARAM +\n            \"' are both mandatory and can not be null\");\n      }\n      if (! (patt instanceof String && replacement instanceof String)) {\n        throw new SolrException(SERVER_ERROR, \"Init param '\" + DEST_PARAM + \"' children '\" +\n            PATTERN_PARAM + \"' and '\" + REPLACEMENT_PARAM +\n            \"' must both be strings (i.e. <str>)\");\n      }\n      if (0 != destList.size()) {\n        throw new SolrException(SERVER_ERROR, \"Init param '\" + DEST_PARAM + \"' has unexpected children: '\"\n            + destList.getName(0) + \"'\");\n      }\n\n      try {\n        this.pattern = Pattern.compile(patt.toString());\n      } catch (PatternSyntaxException pe) {\n        throw new SolrException(SERVER_ERROR, \"Init param '\" + DEST_PARAM + \"' child '\" + PATTERN_PARAM +\n            \" is not a valid regex pattern: \" + patt, pe);\n      }\n      dest = replacement.toString();\n\n    } else if (d instanceof String) {\n      dest = d.toString();\n    } else {\n      throw new SolrException(SERVER_ERROR, \"Init param '\" + DEST_PARAM + \"' must either be a string \" +\n          \"(i.e. <str>) or a list (i.e. <lst>) containing '\" +\n          PATTERN_PARAM + \"' and '\" + REPLACEMENT_PARAM);\n    }\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c19eeb5bbd032a02cb82a253c4c9ae35863ea2dc","date":1591973782,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/contrib/analysis-extras/src/java/org/apache/solr/update/processor/OpenNLPExtractNamedEntitiesUpdateProcessorFactory#initSourceSelectorSyntax(NamedList).mjava","pathOld":"solr/contrib/analysis-extras/src/java/org/apache/solr/update/processor/OpenNLPExtractNamedEntitiesUpdateProcessorFactory#initSourceSelectorSyntax(NamedList).mjava","sourceNew":"  /**\n   * init helper method that should only be called when we know for certain that both the\n   * \"source\" and \"dest\" init params <em>do</em> exist.\n   */\n  @SuppressWarnings(\"unchecked\")\n  private void initSourceSelectorSyntax(@SuppressWarnings({\"rawtypes\"})NamedList args) {\n    // Full and complete syntax where source and dest are mandatory.\n    //\n    // source may be a single string or a selector.\n    // dest may be a single string or list containing pattern and replacement\n    //\n    //   source != null && dest != null\n\n    // if we got here we know we had source and dest, now check for the other two so that we can give a better\n    // message than \"unexpected\"\n    if (0 <= args.indexOf(PATTERN_PARAM, 0) || 0 <= args.indexOf(REPLACEMENT_PARAM, 0) ) {\n      throw new SolrException(SERVER_ERROR,\"Short hand syntax must not be mixed with full syntax. Found \" +\n          SOURCE_PARAM + \" and \" + DEST_PARAM + \" but also found \" + PATTERN_PARAM + \" or \" + REPLACEMENT_PARAM);\n    }\n\n    Object d = args.remove(DEST_PARAM);\n    assert null != d;\n\n    List<Object> sources = args.getAll(SOURCE_PARAM);\n    assert null != sources;\n\n    if (1 == sources.size()) {\n      if (sources.get(0) instanceof NamedList) {\n        // nested set of selector options\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList selectorConfig = (NamedList) args.remove(SOURCE_PARAM);\n\n        srcInclusions = parseSelectorParams(selectorConfig);\n\n        List<Object> excList = selectorConfig.getAll(\"exclude\");\n\n        for (Object excObj : excList) {\n          if (null == excObj) {\n            throw new SolrException(SERVER_ERROR, \"Init param '\" + SOURCE_PARAM +\n                \"' child 'exclude' can not be null\");\n          }\n          if (!(excObj instanceof NamedList)) {\n            throw new SolrException(SERVER_ERROR, \"Init param '\" + SOURCE_PARAM +\n                \"' child 'exclude' must be <lst/>\");\n          }\n          @SuppressWarnings({\"rawtypes\"})\n          NamedList exc = (NamedList) excObj;\n          srcExclusions.add(parseSelectorParams(exc));\n          if (0 < exc.size()) {\n            throw new SolrException(SERVER_ERROR, \"Init param '\" + SOURCE_PARAM +\n                \"' has unexpected 'exclude' sub-param(s): '\"\n                + selectorConfig.getName(0) + \"'\");\n          }\n          // call once per instance\n          selectorConfig.remove(\"exclude\");\n        }\n\n        if (0 < selectorConfig.size()) {\n          throw new SolrException(SERVER_ERROR, \"Init param '\" + SOURCE_PARAM +\n              \"' contains unexpected child param(s): '\" +\n              selectorConfig.getName(0) + \"'\");\n        }\n        // consume from the named list so it doesn't interfere with subsequent processing\n        sources.remove(0);\n      }\n    }\n    if (1 <= sources.size()) {\n      // source better be one or more strings\n      srcInclusions.fieldName = new HashSet<>(args.removeConfigArgs(\"source\"));\n    }\n    if (srcInclusions == null) {\n      throw new SolrException(SERVER_ERROR,\n          \"Init params do not specify any field from which to extract entities, please supply either \"\n          + SOURCE_PARAM + \" and \" + DEST_PARAM + \" or \" + PATTERN_PARAM + \" and \" + REPLACEMENT_PARAM + \". See javadocs\" +\n          \"for OpenNLPExtractNamedEntitiesUpdateProcessor for further details.\");\n    }\n\n    if (d instanceof NamedList) {\n      @SuppressWarnings({\"rawtypes\"})\n      NamedList destList = (NamedList) d;\n\n      Object patt = destList.remove(PATTERN_PARAM);\n      Object replacement = destList.remove(REPLACEMENT_PARAM);\n\n      if (null == patt || null == replacement) {\n        throw new SolrException(SERVER_ERROR, \"Init param '\" + DEST_PARAM + \"' children '\" +\n            PATTERN_PARAM + \"' and '\" + REPLACEMENT_PARAM +\n            \"' are both mandatory and can not be null\");\n      }\n      if (! (patt instanceof String && replacement instanceof String)) {\n        throw new SolrException(SERVER_ERROR, \"Init param '\" + DEST_PARAM + \"' children '\" +\n            PATTERN_PARAM + \"' and '\" + REPLACEMENT_PARAM +\n            \"' must both be strings (i.e. <str>)\");\n      }\n      if (0 != destList.size()) {\n        throw new SolrException(SERVER_ERROR, \"Init param '\" + DEST_PARAM + \"' has unexpected children: '\"\n            + destList.getName(0) + \"'\");\n      }\n\n      try {\n        this.pattern = Pattern.compile(patt.toString());\n      } catch (PatternSyntaxException pe) {\n        throw new SolrException(SERVER_ERROR, \"Init param '\" + DEST_PARAM + \"' child '\" + PATTERN_PARAM +\n            \" is not a valid regex pattern: \" + patt, pe);\n      }\n      dest = replacement.toString();\n\n    } else if (d instanceof String) {\n      dest = d.toString();\n    } else {\n      throw new SolrException(SERVER_ERROR, \"Init param '\" + DEST_PARAM + \"' must either be a string \" +\n          \"(i.e. <str>) or a list (i.e. <lst>) containing '\" +\n          PATTERN_PARAM + \"' and '\" + REPLACEMENT_PARAM);\n    }\n\n  }\n\n","sourceOld":"  /**\n   * init helper method that should only be called when we know for certain that both the\n   * \"source\" and \"dest\" init params <em>do</em> exist.\n   */\n  @SuppressWarnings(\"unchecked\")\n  private void initSourceSelectorSyntax(NamedList args) {\n    // Full and complete syntax where source and dest are mandatory.\n    //\n    // source may be a single string or a selector.\n    // dest may be a single string or list containing pattern and replacement\n    //\n    //   source != null && dest != null\n\n    // if we got here we know we had source and dest, now check for the other two so that we can give a better\n    // message than \"unexpected\"\n    if (0 <= args.indexOf(PATTERN_PARAM, 0) || 0 <= args.indexOf(REPLACEMENT_PARAM, 0) ) {\n      throw new SolrException(SERVER_ERROR,\"Short hand syntax must not be mixed with full syntax. Found \" +\n          SOURCE_PARAM + \" and \" + DEST_PARAM + \" but also found \" + PATTERN_PARAM + \" or \" + REPLACEMENT_PARAM);\n    }\n\n    Object d = args.remove(DEST_PARAM);\n    assert null != d;\n\n    List<Object> sources = args.getAll(SOURCE_PARAM);\n    assert null != sources;\n\n    if (1 == sources.size()) {\n      if (sources.get(0) instanceof NamedList) {\n        // nested set of selector options\n        NamedList selectorConfig = (NamedList) args.remove(SOURCE_PARAM);\n\n        srcInclusions = parseSelectorParams(selectorConfig);\n\n        List<Object> excList = selectorConfig.getAll(\"exclude\");\n\n        for (Object excObj : excList) {\n          if (null == excObj) {\n            throw new SolrException(SERVER_ERROR, \"Init param '\" + SOURCE_PARAM +\n                \"' child 'exclude' can not be null\");\n          }\n          if (!(excObj instanceof NamedList)) {\n            throw new SolrException(SERVER_ERROR, \"Init param '\" + SOURCE_PARAM +\n                \"' child 'exclude' must be <lst/>\");\n          }\n          NamedList exc = (NamedList) excObj;\n          srcExclusions.add(parseSelectorParams(exc));\n          if (0 < exc.size()) {\n            throw new SolrException(SERVER_ERROR, \"Init param '\" + SOURCE_PARAM +\n                \"' has unexpected 'exclude' sub-param(s): '\"\n                + selectorConfig.getName(0) + \"'\");\n          }\n          // call once per instance\n          selectorConfig.remove(\"exclude\");\n        }\n\n        if (0 < selectorConfig.size()) {\n          throw new SolrException(SERVER_ERROR, \"Init param '\" + SOURCE_PARAM +\n              \"' contains unexpected child param(s): '\" +\n              selectorConfig.getName(0) + \"'\");\n        }\n        // consume from the named list so it doesn't interfere with subsequent processing\n        sources.remove(0);\n      }\n    }\n    if (1 <= sources.size()) {\n      // source better be one or more strings\n      srcInclusions.fieldName = new HashSet<>(args.removeConfigArgs(\"source\"));\n    }\n    if (srcInclusions == null) {\n      throw new SolrException(SERVER_ERROR,\n          \"Init params do not specify any field from which to extract entities, please supply either \"\n          + SOURCE_PARAM + \" and \" + DEST_PARAM + \" or \" + PATTERN_PARAM + \" and \" + REPLACEMENT_PARAM + \". See javadocs\" +\n          \"for OpenNLPExtractNamedEntitiesUpdateProcessor for further details.\");\n    }\n\n    if (d instanceof NamedList) {\n      NamedList destList = (NamedList) d;\n\n      Object patt = destList.remove(PATTERN_PARAM);\n      Object replacement = destList.remove(REPLACEMENT_PARAM);\n\n      if (null == patt || null == replacement) {\n        throw new SolrException(SERVER_ERROR, \"Init param '\" + DEST_PARAM + \"' children '\" +\n            PATTERN_PARAM + \"' and '\" + REPLACEMENT_PARAM +\n            \"' are both mandatory and can not be null\");\n      }\n      if (! (patt instanceof String && replacement instanceof String)) {\n        throw new SolrException(SERVER_ERROR, \"Init param '\" + DEST_PARAM + \"' children '\" +\n            PATTERN_PARAM + \"' and '\" + REPLACEMENT_PARAM +\n            \"' must both be strings (i.e. <str>)\");\n      }\n      if (0 != destList.size()) {\n        throw new SolrException(SERVER_ERROR, \"Init param '\" + DEST_PARAM + \"' has unexpected children: '\"\n            + destList.getName(0) + \"'\");\n      }\n\n      try {\n        this.pattern = Pattern.compile(patt.toString());\n      } catch (PatternSyntaxException pe) {\n        throw new SolrException(SERVER_ERROR, \"Init param '\" + DEST_PARAM + \"' child '\" + PATTERN_PARAM +\n            \" is not a valid regex pattern: \" + patt, pe);\n      }\n      dest = replacement.toString();\n\n    } else if (d instanceof String) {\n      dest = d.toString();\n    } else {\n      throw new SolrException(SERVER_ERROR, \"Init param '\" + DEST_PARAM + \"' must either be a string \" +\n          \"(i.e. <str>) or a list (i.e. <lst>) containing '\" +\n          PATTERN_PARAM + \"' and '\" + REPLACEMENT_PARAM);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c19eeb5bbd032a02cb82a253c4c9ae35863ea2dc":["afc5b4b2446e392448f36ae4f5a164540f2ccb65"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c19eeb5bbd032a02cb82a253c4c9ae35863ea2dc"],"afc5b4b2446e392448f36ae4f5a164540f2ccb65":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["afc5b4b2446e392448f36ae4f5a164540f2ccb65"],"c19eeb5bbd032a02cb82a253c4c9ae35863ea2dc":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"afc5b4b2446e392448f36ae4f5a164540f2ccb65":["c19eeb5bbd032a02cb82a253c4c9ae35863ea2dc"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}