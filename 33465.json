{"path":"lucene/core/src/java/org/apache/lucene/search/DocValuesRangeQuery#createWeight(IndexSearcher,boolean).mjava","commits":[{"id":"484e80062d7ab2729bc82f0311d6a97dd913961a","date":1424450206,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/DocValuesRangeQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    if (lowerVal == null && upperVal == null) {\n      throw new IllegalStateException(\"Both min and max values cannot be null, call rewrite first\");\n    }\n    return new Weight(DocValuesRangeQuery.this) {\n\n      private float queryNorm;\n      private float queryWeight;\n\n      @Override\n      public float getValueForNormalization() throws IOException {\n        queryWeight = getBoost();\n        return queryWeight * queryWeight;\n      }\n\n      @Override\n      public void normalize(float norm, float topLevelBoost) {\n        queryNorm = norm * topLevelBoost;\n        queryWeight *= queryNorm;\n      }\n\n      @Override\n      public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n        final Scorer s = scorer(context, context.reader().getLiveDocs());\n        final boolean exists = (s != null && s.advance(doc) == doc);\n\n        final ComplexExplanation result = new ComplexExplanation();\n        if (exists) {\n          result.setDescription(DocValuesRangeQuery.this.toString() + \", product of:\");\n          result.setValue(queryWeight);\n          result.setMatch(Boolean.TRUE);\n          result.addDetail(new Explanation(getBoost(), \"boost\"));\n          result.addDetail(new Explanation(queryNorm, \"queryNorm\"));\n        } else {\n          result.setDescription(DocValuesRangeQuery.this.toString() + \" doesn't match id \" + doc);\n          result.setValue(0);\n          result.setMatch(Boolean.FALSE);\n        }\n        return result;\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context, Bits acceptDocs) throws IOException {\n\n        final Bits docsWithField = context.reader().getDocsWithField(field);\n        if (docsWithField == null || docsWithField instanceof MatchNoBits) {\n          return null;\n        }\n\n        final DocIdSetIterator approximation = DocIdSetIterator.all(context.reader().maxDoc());\n        final TwoPhaseDocIdSetIterator twoPhaseRange;\n        if (lowerVal instanceof Long || upperVal instanceof Long) {\n\n          final SortedNumericDocValues values = DocValues.getSortedNumeric(context.reader(), field);\n\n          final long min;\n          if (lowerVal == null) {\n            min = Long.MIN_VALUE;\n          } else if (includeLower) {\n            min = (long) lowerVal;\n          } else {\n            min = 1 + (long) lowerVal;\n          }\n\n          final long max;\n          if (upperVal == null) {\n            max = Long.MAX_VALUE;\n          } else if (includeUpper) {\n            max = (long) upperVal;\n          } else {\n            max = -1 + (long) upperVal;\n          }\n\n          if (min > max) {\n            return null;\n          }\n\n          twoPhaseRange = new TwoPhaseNumericRange(values, min, max, approximation, acceptDocs);\n\n        } else if (lowerVal instanceof BytesRef || upperVal instanceof BytesRef) {\n\n          final SortedSetDocValues values = DocValues.getSortedSet(context.reader(), field);\n\n          final long minOrd;\n          if (lowerVal == null) {\n            minOrd = 0;\n          } else {\n            final long ord = values.lookupTerm((BytesRef) lowerVal);\n            if (ord < 0) {\n              minOrd = -1 - ord;\n            } else if (includeLower) {\n              minOrd = ord;\n            } else {\n              minOrd = ord + 1;\n            }\n          }\n\n          final long maxOrd;\n          if (upperVal == null) {\n            maxOrd = values.getValueCount() - 1;\n          } else {\n            final long ord = values.lookupTerm((BytesRef) upperVal);\n            if (ord < 0) {\n              maxOrd = -2 - ord;\n            } else if (includeUpper) {\n              maxOrd = ord;\n            } else {\n              maxOrd = ord - 1;\n            }\n          }\n\n          if (minOrd > maxOrd) {\n            return null;\n          }\n\n          twoPhaseRange = new TwoPhaseOrdRange(values, minOrd, maxOrd, approximation, acceptDocs);\n\n        } else {\n          throw new AssertionError();\n        }\n\n        return new RangeScorer(this, twoPhaseRange, queryWeight);\n      }\n\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["ad0d09e969f4763b0df4230f8e3f74357872a4e4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"87fab14adebb5b490363c9bc05f747938bd15e6a","date":1424877964,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/DocValuesRangeQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/DocValuesRangeQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    if (lowerVal == null && upperVal == null) {\n      throw new IllegalStateException(\"Both min and max values cannot be null, call rewrite first\");\n    }\n    return new ConstantScoreWeight(DocValuesRangeQuery.this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context, Bits acceptDocs, float score) throws IOException {\n\n        final Bits docsWithField = context.reader().getDocsWithField(field);\n        if (docsWithField == null || docsWithField instanceof MatchNoBits) {\n          return null;\n        }\n\n        final DocIdSetIterator approximation = DocIdSetIterator.all(context.reader().maxDoc());\n        final TwoPhaseDocIdSetIterator twoPhaseRange;\n        if (lowerVal instanceof Long || upperVal instanceof Long) {\n\n          final SortedNumericDocValues values = DocValues.getSortedNumeric(context.reader(), field);\n\n          final long min;\n          if (lowerVal == null) {\n            min = Long.MIN_VALUE;\n          } else if (includeLower) {\n            min = (long) lowerVal;\n          } else {\n            min = 1 + (long) lowerVal;\n          }\n\n          final long max;\n          if (upperVal == null) {\n            max = Long.MAX_VALUE;\n          } else if (includeUpper) {\n            max = (long) upperVal;\n          } else {\n            max = -1 + (long) upperVal;\n          }\n\n          if (min > max) {\n            return null;\n          }\n\n          twoPhaseRange = new TwoPhaseNumericRange(values, min, max, approximation, acceptDocs);\n\n        } else if (lowerVal instanceof BytesRef || upperVal instanceof BytesRef) {\n\n          final SortedSetDocValues values = DocValues.getSortedSet(context.reader(), field);\n\n          final long minOrd;\n          if (lowerVal == null) {\n            minOrd = 0;\n          } else {\n            final long ord = values.lookupTerm((BytesRef) lowerVal);\n            if (ord < 0) {\n              minOrd = -1 - ord;\n            } else if (includeLower) {\n              minOrd = ord;\n            } else {\n              minOrd = ord + 1;\n            }\n          }\n\n          final long maxOrd;\n          if (upperVal == null) {\n            maxOrd = values.getValueCount() - 1;\n          } else {\n            final long ord = values.lookupTerm((BytesRef) upperVal);\n            if (ord < 0) {\n              maxOrd = -2 - ord;\n            } else if (includeUpper) {\n              maxOrd = ord;\n            } else {\n              maxOrd = ord - 1;\n            }\n          }\n\n          if (minOrd > maxOrd) {\n            return null;\n          }\n\n          twoPhaseRange = new TwoPhaseOrdRange(values, minOrd, maxOrd, approximation, acceptDocs);\n\n        } else {\n          throw new AssertionError();\n        }\n\n        return new RangeScorer(this, twoPhaseRange, score);\n      }\n\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    if (lowerVal == null && upperVal == null) {\n      throw new IllegalStateException(\"Both min and max values cannot be null, call rewrite first\");\n    }\n    return new Weight(DocValuesRangeQuery.this) {\n\n      private float queryNorm;\n      private float queryWeight;\n\n      @Override\n      public float getValueForNormalization() throws IOException {\n        queryWeight = getBoost();\n        return queryWeight * queryWeight;\n      }\n\n      @Override\n      public void normalize(float norm, float topLevelBoost) {\n        queryNorm = norm * topLevelBoost;\n        queryWeight *= queryNorm;\n      }\n\n      @Override\n      public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n        final Scorer s = scorer(context, context.reader().getLiveDocs());\n        final boolean exists = (s != null && s.advance(doc) == doc);\n\n        final ComplexExplanation result = new ComplexExplanation();\n        if (exists) {\n          result.setDescription(DocValuesRangeQuery.this.toString() + \", product of:\");\n          result.setValue(queryWeight);\n          result.setMatch(Boolean.TRUE);\n          result.addDetail(new Explanation(getBoost(), \"boost\"));\n          result.addDetail(new Explanation(queryNorm, \"queryNorm\"));\n        } else {\n          result.setDescription(DocValuesRangeQuery.this.toString() + \" doesn't match id \" + doc);\n          result.setValue(0);\n          result.setMatch(Boolean.FALSE);\n        }\n        return result;\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context, Bits acceptDocs) throws IOException {\n\n        final Bits docsWithField = context.reader().getDocsWithField(field);\n        if (docsWithField == null || docsWithField instanceof MatchNoBits) {\n          return null;\n        }\n\n        final DocIdSetIterator approximation = DocIdSetIterator.all(context.reader().maxDoc());\n        final TwoPhaseDocIdSetIterator twoPhaseRange;\n        if (lowerVal instanceof Long || upperVal instanceof Long) {\n\n          final SortedNumericDocValues values = DocValues.getSortedNumeric(context.reader(), field);\n\n          final long min;\n          if (lowerVal == null) {\n            min = Long.MIN_VALUE;\n          } else if (includeLower) {\n            min = (long) lowerVal;\n          } else {\n            min = 1 + (long) lowerVal;\n          }\n\n          final long max;\n          if (upperVal == null) {\n            max = Long.MAX_VALUE;\n          } else if (includeUpper) {\n            max = (long) upperVal;\n          } else {\n            max = -1 + (long) upperVal;\n          }\n\n          if (min > max) {\n            return null;\n          }\n\n          twoPhaseRange = new TwoPhaseNumericRange(values, min, max, approximation, acceptDocs);\n\n        } else if (lowerVal instanceof BytesRef || upperVal instanceof BytesRef) {\n\n          final SortedSetDocValues values = DocValues.getSortedSet(context.reader(), field);\n\n          final long minOrd;\n          if (lowerVal == null) {\n            minOrd = 0;\n          } else {\n            final long ord = values.lookupTerm((BytesRef) lowerVal);\n            if (ord < 0) {\n              minOrd = -1 - ord;\n            } else if (includeLower) {\n              minOrd = ord;\n            } else {\n              minOrd = ord + 1;\n            }\n          }\n\n          final long maxOrd;\n          if (upperVal == null) {\n            maxOrd = values.getValueCount() - 1;\n          } else {\n            final long ord = values.lookupTerm((BytesRef) upperVal);\n            if (ord < 0) {\n              maxOrd = -2 - ord;\n            } else if (includeUpper) {\n              maxOrd = ord;\n            } else {\n              maxOrd = ord - 1;\n            }\n          }\n\n          if (minOrd > maxOrd) {\n            return null;\n          }\n\n          twoPhaseRange = new TwoPhaseOrdRange(values, minOrd, maxOrd, approximation, acceptDocs);\n\n        } else {\n          throw new AssertionError();\n        }\n\n        return new RangeScorer(this, twoPhaseRange, queryWeight);\n      }\n\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a3d6eb0072094d94624002318ba2d4c840946833","date":1424947971,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/DocValuesRangeQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/DocValuesRangeQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    if (lowerVal == null && upperVal == null) {\n      throw new IllegalStateException(\"Both min and max values cannot be null, call rewrite first\");\n    }\n    return new ConstantScoreWeight(DocValuesRangeQuery.this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context, Bits acceptDocs, float score) throws IOException {\n\n        final Bits docsWithField = context.reader().getDocsWithField(field);\n        if (docsWithField == null || docsWithField instanceof MatchNoBits) {\n          return null;\n        }\n\n        final DocIdSetIterator approximation = DocIdSetIterator.all(context.reader().maxDoc());\n        final TwoPhaseIterator twoPhaseRange;\n        if (lowerVal instanceof Long || upperVal instanceof Long) {\n\n          final SortedNumericDocValues values = DocValues.getSortedNumeric(context.reader(), field);\n\n          final long min;\n          if (lowerVal == null) {\n            min = Long.MIN_VALUE;\n          } else if (includeLower) {\n            min = (long) lowerVal;\n          } else {\n            min = 1 + (long) lowerVal;\n          }\n\n          final long max;\n          if (upperVal == null) {\n            max = Long.MAX_VALUE;\n          } else if (includeUpper) {\n            max = (long) upperVal;\n          } else {\n            max = -1 + (long) upperVal;\n          }\n\n          if (min > max) {\n            return null;\n          }\n\n          twoPhaseRange = new TwoPhaseNumericRange(values, min, max, approximation, acceptDocs);\n\n        } else if (lowerVal instanceof BytesRef || upperVal instanceof BytesRef) {\n\n          final SortedSetDocValues values = DocValues.getSortedSet(context.reader(), field);\n\n          final long minOrd;\n          if (lowerVal == null) {\n            minOrd = 0;\n          } else {\n            final long ord = values.lookupTerm((BytesRef) lowerVal);\n            if (ord < 0) {\n              minOrd = -1 - ord;\n            } else if (includeLower) {\n              minOrd = ord;\n            } else {\n              minOrd = ord + 1;\n            }\n          }\n\n          final long maxOrd;\n          if (upperVal == null) {\n            maxOrd = values.getValueCount() - 1;\n          } else {\n            final long ord = values.lookupTerm((BytesRef) upperVal);\n            if (ord < 0) {\n              maxOrd = -2 - ord;\n            } else if (includeUpper) {\n              maxOrd = ord;\n            } else {\n              maxOrd = ord - 1;\n            }\n          }\n\n          if (minOrd > maxOrd) {\n            return null;\n          }\n\n          twoPhaseRange = new TwoPhaseOrdRange(values, minOrd, maxOrd, approximation, acceptDocs);\n\n        } else {\n          throw new AssertionError();\n        }\n\n        return new RangeScorer(this, twoPhaseRange, score);\n      }\n\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    if (lowerVal == null && upperVal == null) {\n      throw new IllegalStateException(\"Both min and max values cannot be null, call rewrite first\");\n    }\n    return new ConstantScoreWeight(DocValuesRangeQuery.this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context, Bits acceptDocs, float score) throws IOException {\n\n        final Bits docsWithField = context.reader().getDocsWithField(field);\n        if (docsWithField == null || docsWithField instanceof MatchNoBits) {\n          return null;\n        }\n\n        final DocIdSetIterator approximation = DocIdSetIterator.all(context.reader().maxDoc());\n        final TwoPhaseDocIdSetIterator twoPhaseRange;\n        if (lowerVal instanceof Long || upperVal instanceof Long) {\n\n          final SortedNumericDocValues values = DocValues.getSortedNumeric(context.reader(), field);\n\n          final long min;\n          if (lowerVal == null) {\n            min = Long.MIN_VALUE;\n          } else if (includeLower) {\n            min = (long) lowerVal;\n          } else {\n            min = 1 + (long) lowerVal;\n          }\n\n          final long max;\n          if (upperVal == null) {\n            max = Long.MAX_VALUE;\n          } else if (includeUpper) {\n            max = (long) upperVal;\n          } else {\n            max = -1 + (long) upperVal;\n          }\n\n          if (min > max) {\n            return null;\n          }\n\n          twoPhaseRange = new TwoPhaseNumericRange(values, min, max, approximation, acceptDocs);\n\n        } else if (lowerVal instanceof BytesRef || upperVal instanceof BytesRef) {\n\n          final SortedSetDocValues values = DocValues.getSortedSet(context.reader(), field);\n\n          final long minOrd;\n          if (lowerVal == null) {\n            minOrd = 0;\n          } else {\n            final long ord = values.lookupTerm((BytesRef) lowerVal);\n            if (ord < 0) {\n              minOrd = -1 - ord;\n            } else if (includeLower) {\n              minOrd = ord;\n            } else {\n              minOrd = ord + 1;\n            }\n          }\n\n          final long maxOrd;\n          if (upperVal == null) {\n            maxOrd = values.getValueCount() - 1;\n          } else {\n            final long ord = values.lookupTerm((BytesRef) upperVal);\n            if (ord < 0) {\n              maxOrd = -2 - ord;\n            } else if (includeUpper) {\n              maxOrd = ord;\n            } else {\n              maxOrd = ord - 1;\n            }\n          }\n\n          if (minOrd > maxOrd) {\n            return null;\n          }\n\n          twoPhaseRange = new TwoPhaseOrdRange(values, minOrd, maxOrd, approximation, acceptDocs);\n\n        } else {\n          throw new AssertionError();\n        }\n\n        return new RangeScorer(this, twoPhaseRange, score);\n      }\n\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/DocValuesRangeQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/DocValuesRangeQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    if (lowerVal == null && upperVal == null) {\n      throw new IllegalStateException(\"Both min and max values cannot be null, call rewrite first\");\n    }\n    return new ConstantScoreWeight(DocValuesRangeQuery.this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context, Bits acceptDocs, float score) throws IOException {\n\n        final Bits docsWithField = context.reader().getDocsWithField(field);\n        if (docsWithField == null || docsWithField instanceof MatchNoBits) {\n          return null;\n        }\n\n        final DocIdSetIterator approximation = DocIdSetIterator.all(context.reader().maxDoc());\n        final TwoPhaseIterator twoPhaseRange;\n        if (lowerVal instanceof Long || upperVal instanceof Long) {\n\n          final SortedNumericDocValues values = DocValues.getSortedNumeric(context.reader(), field);\n\n          final long min;\n          if (lowerVal == null) {\n            min = Long.MIN_VALUE;\n          } else if (includeLower) {\n            min = (long) lowerVal;\n          } else {\n            min = 1 + (long) lowerVal;\n          }\n\n          final long max;\n          if (upperVal == null) {\n            max = Long.MAX_VALUE;\n          } else if (includeUpper) {\n            max = (long) upperVal;\n          } else {\n            max = -1 + (long) upperVal;\n          }\n\n          if (min > max) {\n            return null;\n          }\n\n          twoPhaseRange = new TwoPhaseNumericRange(values, min, max, approximation, acceptDocs);\n\n        } else if (lowerVal instanceof BytesRef || upperVal instanceof BytesRef) {\n\n          final SortedSetDocValues values = DocValues.getSortedSet(context.reader(), field);\n\n          final long minOrd;\n          if (lowerVal == null) {\n            minOrd = 0;\n          } else {\n            final long ord = values.lookupTerm((BytesRef) lowerVal);\n            if (ord < 0) {\n              minOrd = -1 - ord;\n            } else if (includeLower) {\n              minOrd = ord;\n            } else {\n              minOrd = ord + 1;\n            }\n          }\n\n          final long maxOrd;\n          if (upperVal == null) {\n            maxOrd = values.getValueCount() - 1;\n          } else {\n            final long ord = values.lookupTerm((BytesRef) upperVal);\n            if (ord < 0) {\n              maxOrd = -2 - ord;\n            } else if (includeUpper) {\n              maxOrd = ord;\n            } else {\n              maxOrd = ord - 1;\n            }\n          }\n\n          if (minOrd > maxOrd) {\n            return null;\n          }\n\n          twoPhaseRange = new TwoPhaseOrdRange(values, minOrd, maxOrd, approximation, acceptDocs);\n\n        } else {\n          throw new AssertionError();\n        }\n\n        return new RangeScorer(this, twoPhaseRange, score);\n      }\n\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    if (lowerVal == null && upperVal == null) {\n      throw new IllegalStateException(\"Both min and max values cannot be null, call rewrite first\");\n    }\n    return new Weight(DocValuesRangeQuery.this) {\n\n      private float queryNorm;\n      private float queryWeight;\n\n      @Override\n      public float getValueForNormalization() throws IOException {\n        queryWeight = getBoost();\n        return queryWeight * queryWeight;\n      }\n\n      @Override\n      public void normalize(float norm, float topLevelBoost) {\n        queryNorm = norm * topLevelBoost;\n        queryWeight *= queryNorm;\n      }\n\n      @Override\n      public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n        final Scorer s = scorer(context, context.reader().getLiveDocs());\n        final boolean exists = (s != null && s.advance(doc) == doc);\n\n        final ComplexExplanation result = new ComplexExplanation();\n        if (exists) {\n          result.setDescription(DocValuesRangeQuery.this.toString() + \", product of:\");\n          result.setValue(queryWeight);\n          result.setMatch(Boolean.TRUE);\n          result.addDetail(new Explanation(getBoost(), \"boost\"));\n          result.addDetail(new Explanation(queryNorm, \"queryNorm\"));\n        } else {\n          result.setDescription(DocValuesRangeQuery.this.toString() + \" doesn't match id \" + doc);\n          result.setValue(0);\n          result.setMatch(Boolean.FALSE);\n        }\n        return result;\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context, Bits acceptDocs) throws IOException {\n\n        final Bits docsWithField = context.reader().getDocsWithField(field);\n        if (docsWithField == null || docsWithField instanceof MatchNoBits) {\n          return null;\n        }\n\n        final DocIdSetIterator approximation = DocIdSetIterator.all(context.reader().maxDoc());\n        final TwoPhaseDocIdSetIterator twoPhaseRange;\n        if (lowerVal instanceof Long || upperVal instanceof Long) {\n\n          final SortedNumericDocValues values = DocValues.getSortedNumeric(context.reader(), field);\n\n          final long min;\n          if (lowerVal == null) {\n            min = Long.MIN_VALUE;\n          } else if (includeLower) {\n            min = (long) lowerVal;\n          } else {\n            min = 1 + (long) lowerVal;\n          }\n\n          final long max;\n          if (upperVal == null) {\n            max = Long.MAX_VALUE;\n          } else if (includeUpper) {\n            max = (long) upperVal;\n          } else {\n            max = -1 + (long) upperVal;\n          }\n\n          if (min > max) {\n            return null;\n          }\n\n          twoPhaseRange = new TwoPhaseNumericRange(values, min, max, approximation, acceptDocs);\n\n        } else if (lowerVal instanceof BytesRef || upperVal instanceof BytesRef) {\n\n          final SortedSetDocValues values = DocValues.getSortedSet(context.reader(), field);\n\n          final long minOrd;\n          if (lowerVal == null) {\n            minOrd = 0;\n          } else {\n            final long ord = values.lookupTerm((BytesRef) lowerVal);\n            if (ord < 0) {\n              minOrd = -1 - ord;\n            } else if (includeLower) {\n              minOrd = ord;\n            } else {\n              minOrd = ord + 1;\n            }\n          }\n\n          final long maxOrd;\n          if (upperVal == null) {\n            maxOrd = values.getValueCount() - 1;\n          } else {\n            final long ord = values.lookupTerm((BytesRef) upperVal);\n            if (ord < 0) {\n              maxOrd = -2 - ord;\n            } else if (includeUpper) {\n              maxOrd = ord;\n            } else {\n              maxOrd = ord - 1;\n            }\n          }\n\n          if (minOrd > maxOrd) {\n            return null;\n          }\n\n          twoPhaseRange = new TwoPhaseOrdRange(values, minOrd, maxOrd, approximation, acceptDocs);\n\n        } else {\n          throw new AssertionError();\n        }\n\n        return new RangeScorer(this, twoPhaseRange, queryWeight);\n      }\n\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a7f94ff172f40ff68a926d112e25b96bc38e5a27","date":1431002360,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/DocValuesRangeQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/DocValuesRangeQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    if (lowerVal == null && upperVal == null) {\n      throw new IllegalStateException(\"Both min and max values cannot be null, call rewrite first\");\n    }\n    return new RandomAccessWeight(DocValuesRangeQuery.this) {\n      \n      @Override\n      protected Bits getMatchingDocs(LeafReaderContext context) throws IOException {\n        if (lowerVal instanceof Long || upperVal instanceof Long) {\n\n          final SortedNumericDocValues values = DocValues.getSortedNumeric(context.reader(), field);\n\n          final long min;\n          if (lowerVal == null) {\n            min = Long.MIN_VALUE;\n          } else if (includeLower) {\n            min = (long) lowerVal;\n          } else {\n            min = 1 + (long) lowerVal;\n          }\n\n          final long max;\n          if (upperVal == null) {\n            max = Long.MAX_VALUE;\n          } else if (includeUpper) {\n            max = (long) upperVal;\n          } else {\n            max = -1 + (long) upperVal;\n          }\n\n          if (min > max) {\n            return null;\n          }\n\n          return new Bits() {\n\n            @Override\n            public boolean get(int doc) {\n              values.setDocument(doc);\n              final int count = values.count();\n              for (int i = 0; i < count; ++i) {\n                final long value = values.valueAt(i);\n                if (value >= min && value <= max) {\n                  return true;\n                }\n              }\n              return false;\n            }\n\n            @Override\n            public int length() {\n              return context.reader().maxDoc();\n            }\n\n          };\n\n        } else if (lowerVal instanceof BytesRef || upperVal instanceof BytesRef) {\n\n          final SortedSetDocValues values = DocValues.getSortedSet(context.reader(), field);\n\n          final long minOrd;\n          if (lowerVal == null) {\n            minOrd = 0;\n          } else {\n            final long ord = values.lookupTerm((BytesRef) lowerVal);\n            if (ord < 0) {\n              minOrd = -1 - ord;\n            } else if (includeLower) {\n              minOrd = ord;\n            } else {\n              minOrd = ord + 1;\n            }\n          }\n\n          final long maxOrd;\n          if (upperVal == null) {\n            maxOrd = values.getValueCount() - 1;\n          } else {\n            final long ord = values.lookupTerm((BytesRef) upperVal);\n            if (ord < 0) {\n              maxOrd = -2 - ord;\n            } else if (includeUpper) {\n              maxOrd = ord;\n            } else {\n              maxOrd = ord - 1;\n            }\n          }\n\n          if (minOrd > maxOrd) {\n            return null;\n          }\n\n          return new Bits() {\n\n            @Override\n            public boolean get(int doc) {\n              values.setDocument(doc);\n              for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n                if (ord >= minOrd && ord <= maxOrd) {\n                  return true;\n                }\n              }\n              return false;\n            }\n\n            @Override\n            public int length() {\n              return context.reader().maxDoc();\n            }\n\n          };\n\n        } else {\n          throw new AssertionError();\n        }\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    if (lowerVal == null && upperVal == null) {\n      throw new IllegalStateException(\"Both min and max values cannot be null, call rewrite first\");\n    }\n    return new ConstantScoreWeight(DocValuesRangeQuery.this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context, Bits acceptDocs, float score) throws IOException {\n\n        final Bits docsWithField = context.reader().getDocsWithField(field);\n        if (docsWithField == null || docsWithField instanceof MatchNoBits) {\n          return null;\n        }\n\n        final DocIdSetIterator approximation = DocIdSetIterator.all(context.reader().maxDoc());\n        final TwoPhaseIterator twoPhaseRange;\n        if (lowerVal instanceof Long || upperVal instanceof Long) {\n\n          final SortedNumericDocValues values = DocValues.getSortedNumeric(context.reader(), field);\n\n          final long min;\n          if (lowerVal == null) {\n            min = Long.MIN_VALUE;\n          } else if (includeLower) {\n            min = (long) lowerVal;\n          } else {\n            min = 1 + (long) lowerVal;\n          }\n\n          final long max;\n          if (upperVal == null) {\n            max = Long.MAX_VALUE;\n          } else if (includeUpper) {\n            max = (long) upperVal;\n          } else {\n            max = -1 + (long) upperVal;\n          }\n\n          if (min > max) {\n            return null;\n          }\n\n          twoPhaseRange = new TwoPhaseNumericRange(values, min, max, approximation, acceptDocs);\n\n        } else if (lowerVal instanceof BytesRef || upperVal instanceof BytesRef) {\n\n          final SortedSetDocValues values = DocValues.getSortedSet(context.reader(), field);\n\n          final long minOrd;\n          if (lowerVal == null) {\n            minOrd = 0;\n          } else {\n            final long ord = values.lookupTerm((BytesRef) lowerVal);\n            if (ord < 0) {\n              minOrd = -1 - ord;\n            } else if (includeLower) {\n              minOrd = ord;\n            } else {\n              minOrd = ord + 1;\n            }\n          }\n\n          final long maxOrd;\n          if (upperVal == null) {\n            maxOrd = values.getValueCount() - 1;\n          } else {\n            final long ord = values.lookupTerm((BytesRef) upperVal);\n            if (ord < 0) {\n              maxOrd = -2 - ord;\n            } else if (includeUpper) {\n              maxOrd = ord;\n            } else {\n              maxOrd = ord - 1;\n            }\n          }\n\n          if (minOrd > maxOrd) {\n            return null;\n          }\n\n          twoPhaseRange = new TwoPhaseOrdRange(values, minOrd, maxOrd, approximation, acceptDocs);\n\n        } else {\n          throw new AssertionError();\n        }\n\n        return new RangeScorer(this, twoPhaseRange, score);\n      }\n\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9fb0efe75e5c6021561f115dfe334b74786364ba","date":1434366074,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/search/DocValuesRangeQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/DocValuesRangeQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    if (lowerVal == null && upperVal == null) {\n      throw new IllegalStateException(\"Both min and max values cannot be null, call rewrite first\");\n    }\n    return new RandomAccessWeight(DocValuesRangeQuery.this) {\n      \n      @Override\n      protected Bits getMatchingDocs(LeafReaderContext context) throws IOException {\n        if (lowerVal instanceof Long || upperVal instanceof Long) {\n\n          final SortedNumericDocValues values = DocValues.getSortedNumeric(context.reader(), field);\n\n          final long min;\n          if (lowerVal == null) {\n            min = Long.MIN_VALUE;\n          } else if (includeLower) {\n            min = (long) lowerVal;\n          } else {\n            min = 1 + (long) lowerVal;\n          }\n\n          final long max;\n          if (upperVal == null) {\n            max = Long.MAX_VALUE;\n          } else if (includeUpper) {\n            max = (long) upperVal;\n          } else {\n            max = -1 + (long) upperVal;\n          }\n\n          if (min > max) {\n            return null;\n          }\n\n          return new Bits() {\n\n            @Override\n            public boolean get(int doc) {\n              values.setDocument(doc);\n              final int count = values.count();\n              for (int i = 0; i < count; ++i) {\n                final long value = values.valueAt(i);\n                if (value >= min && value <= max) {\n                  return true;\n                }\n              }\n              return false;\n            }\n\n            @Override\n            public int length() {\n              return context.reader().maxDoc();\n            }\n\n          };\n\n        } else if (lowerVal instanceof BytesRef || upperVal instanceof BytesRef) {\n\n          final SortedSetDocValues values = DocValues.getSortedSet(context.reader(), field);\n\n          final long minOrd;\n          if (lowerVal == null) {\n            minOrd = 0;\n          } else {\n            final long ord = values.lookupTerm((BytesRef) lowerVal);\n            if (ord < 0) {\n              minOrd = -1 - ord;\n            } else if (includeLower) {\n              minOrd = ord;\n            } else {\n              minOrd = ord + 1;\n            }\n          }\n\n          final long maxOrd;\n          if (upperVal == null) {\n            maxOrd = values.getValueCount() - 1;\n          } else {\n            final long ord = values.lookupTerm((BytesRef) upperVal);\n            if (ord < 0) {\n              maxOrd = -2 - ord;\n            } else if (includeUpper) {\n              maxOrd = ord;\n            } else {\n              maxOrd = ord - 1;\n            }\n          }\n\n          if (minOrd > maxOrd) {\n            return null;\n          }\n\n          return new Bits() {\n\n            @Override\n            public boolean get(int doc) {\n              values.setDocument(doc);\n              for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n                if (ord >= minOrd && ord <= maxOrd) {\n                  return true;\n                }\n              }\n              return false;\n            }\n\n            @Override\n            public int length() {\n              return context.reader().maxDoc();\n            }\n\n          };\n\n        } else {\n          throw new AssertionError();\n        }\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    if (lowerVal == null && upperVal == null) {\n      throw new IllegalStateException(\"Both min and max values cannot be null, call rewrite first\");\n    }\n    return new RandomAccessWeight(DocValuesRangeQuery.this) {\n      \n      @Override\n      protected Bits getMatchingDocs(LeafReaderContext context) throws IOException {\n        if (lowerVal instanceof Long || upperVal instanceof Long) {\n\n          final SortedNumericDocValues values = DocValues.getSortedNumeric(context.reader(), field);\n\n          final long min;\n          if (lowerVal == null) {\n            min = Long.MIN_VALUE;\n          } else if (includeLower) {\n            min = (long) lowerVal;\n          } else {\n            min = 1 + (long) lowerVal;\n          }\n\n          final long max;\n          if (upperVal == null) {\n            max = Long.MAX_VALUE;\n          } else if (includeUpper) {\n            max = (long) upperVal;\n          } else {\n            max = -1 + (long) upperVal;\n          }\n\n          if (min > max) {\n            return null;\n          }\n\n          return new Bits() {\n\n            @Override\n            public boolean get(int doc) {\n              values.setDocument(doc);\n              final int count = values.count();\n              for (int i = 0; i < count; ++i) {\n                final long value = values.valueAt(i);\n                if (value >= min && value <= max) {\n                  return true;\n                }\n              }\n              return false;\n            }\n\n            @Override\n            public int length() {\n              return context.reader().maxDoc();\n            }\n\n          };\n\n        } else if (lowerVal instanceof BytesRef || upperVal instanceof BytesRef) {\n\n          final SortedSetDocValues values = DocValues.getSortedSet(context.reader(), field);\n\n          final long minOrd;\n          if (lowerVal == null) {\n            minOrd = 0;\n          } else {\n            final long ord = values.lookupTerm((BytesRef) lowerVal);\n            if (ord < 0) {\n              minOrd = -1 - ord;\n            } else if (includeLower) {\n              minOrd = ord;\n            } else {\n              minOrd = ord + 1;\n            }\n          }\n\n          final long maxOrd;\n          if (upperVal == null) {\n            maxOrd = values.getValueCount() - 1;\n          } else {\n            final long ord = values.lookupTerm((BytesRef) upperVal);\n            if (ord < 0) {\n              maxOrd = -2 - ord;\n            } else if (includeUpper) {\n              maxOrd = ord;\n            } else {\n              maxOrd = ord - 1;\n            }\n          }\n\n          if (minOrd > maxOrd) {\n            return null;\n          }\n\n          return new Bits() {\n\n            @Override\n            public boolean get(int doc) {\n              values.setDocument(doc);\n              for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n                if (ord >= minOrd && ord <= maxOrd) {\n                  return true;\n                }\n              }\n              return false;\n            }\n\n            @Override\n            public int length() {\n              return context.reader().maxDoc();\n            }\n\n          };\n\n        } else {\n          throw new AssertionError();\n        }\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["484e80062d7ab2729bc82f0311d6a97dd913961a","a3d6eb0072094d94624002318ba2d4c840946833"],"a7f94ff172f40ff68a926d112e25b96bc38e5a27":["a3d6eb0072094d94624002318ba2d4c840946833"],"484e80062d7ab2729bc82f0311d6a97dd913961a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9fb0efe75e5c6021561f115dfe334b74786364ba":["a7f94ff172f40ff68a926d112e25b96bc38e5a27"],"a3d6eb0072094d94624002318ba2d4c840946833":["87fab14adebb5b490363c9bc05f747938bd15e6a"],"87fab14adebb5b490363c9bc05f747938bd15e6a":["484e80062d7ab2729bc82f0311d6a97dd913961a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9fb0efe75e5c6021561f115dfe334b74786364ba"]},"commit2Childs":{"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"a7f94ff172f40ff68a926d112e25b96bc38e5a27":["9fb0efe75e5c6021561f115dfe334b74786364ba"],"484e80062d7ab2729bc82f0311d6a97dd913961a":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","87fab14adebb5b490363c9bc05f747938bd15e6a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["484e80062d7ab2729bc82f0311d6a97dd913961a"],"a3d6eb0072094d94624002318ba2d4c840946833":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","a7f94ff172f40ff68a926d112e25b96bc38e5a27"],"9fb0efe75e5c6021561f115dfe334b74786364ba":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"87fab14adebb5b490363c9bc05f747938bd15e6a":["a3d6eb0072094d94624002318ba2d4c840946833"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}