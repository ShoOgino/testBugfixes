{"path":"lucene/codecs/src/java/org/apache/lucene/codecs/uniformsplit/IntersectBlockReader#nextTermInBlockMatching().mjava","commits":[{"id":"09dfa411e0e1bbfad83c3e6629cf1fe24a7aed89","date":1567784912,"type":0,"author":"David Smiley","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/uniformsplit/IntersectBlockReader#nextTermInBlockMatching().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Find the next block line that matches, or null when at end of block.\n   */\n  protected BytesRef nextTermInBlockMatching() throws IOException {\n    do {\n      // if seekTerm is set, then we seek into this block instead of starting with the first blindly.\n      if (seekTerm != null) {\n        assert blockLine == null;\n        boolean moveBeyondIfFound = seekTerm == startTerm; // for startTerm, we want to get the following term\n        SeekStatus seekStatus = seekInBlock(seekTerm);\n        seekTerm = null;// reset.\n        if (seekStatus == SeekStatus.END) {\n          return null;\n        } else if (seekStatus == SeekStatus.FOUND && moveBeyondIfFound) {\n          if (readLineInBlock() == null) {\n            return null;\n          }\n        }\n        assert blockLine != null;\n      } else {\n        if (readLineInBlock() == null) {\n          return null;\n        }\n      }\n\n      TermBytes lineTermBytes = blockLine.getTermBytes();\n      BytesRef lineTerm = lineTermBytes.getTerm();\n\n      if (commonSuffixRef == null || StringHelper.endsWith(lineTerm, commonSuffixRef)) {\n        if (runAutomatonFromPrefix(lineTerm)) {\n          return lineTerm;\n        } else if (beyondCommonPrefix) {\n          return null;\n        }\n      }\n\n    } while (true);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"23fcccd57316410c404dd37307a496ab850efa9c","date":1582897939,"type":3,"author":"Bruno Roustant","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/uniformsplit/IntersectBlockReader#nextTermInBlockMatching().mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/uniformsplit/IntersectBlockReader#nextTermInBlockMatching().mjava","sourceNew":"  /**\n   * Finds the next block line that matches (accepted by the automaton), or null when at end of block.\n   *\n   * @return The next term in the current block that is accepted by the automaton; or null if none.\n   */\n  protected BytesRef nextTermInBlockMatching() throws IOException {\n    if (seekTerm == null) {\n      if (readLineInBlock() == null) {\n        return null;\n      }\n    } else {\n      SeekStatus seekStatus = seekInBlock(seekTerm);\n      seekTerm = null;\n      if (seekStatus == SeekStatus.END) {\n        return null;\n      }\n      assert numMatchedBytes == 0;\n      assert numConsecutivelyRejectedTerms == 0;\n    }\n    while (true) {\n      TermBytes lineTermBytes = blockLine.getTermBytes();\n      BytesRef lineTerm = lineTermBytes.getTerm();\n      assert lineTerm.offset == 0;\n      if (states.length <= lineTerm.length) {\n        states = ArrayUtil.growExact(states, ArrayUtil.oversize(lineTerm.length + 1, Byte.BYTES));\n      }\n      // Since terms are delta encoded, we may start the automaton steps from the last state reached by the previous term.\n      int index = Math.min(lineTermBytes.getSuffixOffset(), numMatchedBytes);\n      // Skip this term early if it is shorter than the min term length, or if it does not end with the common suffix\n      // accepted by the automaton.\n      if (lineTerm.length >= minTermLength && (commonSuffix == null || endsWithCommonSuffix(lineTerm.bytes, lineTerm.length))) {\n        int state = states[index];\n        while (true) {\n          if (index == lineTerm.length) {\n            if (runAutomaton.isAccept(state)) {\n              // The automaton accepts the current term. Record the number of matched bytes and return the term.\n              assert runAutomaton.run(lineTerm.bytes, 0, lineTerm.length);\n              numMatchedBytes = index;\n              if (numConsecutivelyRejectedTerms > 0) {\n                numConsecutivelyRejectedTerms = 0;\n              }\n              assert blockIteration == BlockIteration.NEXT;\n              return lineTerm;\n            }\n            break;\n          }\n          state = runAutomaton.step(state, lineTerm.bytes[index] & 0xff);\n          if (state == -1) {\n            // The automaton rejects the current term.\n            break;\n          }\n          // Record the reached automaton state.\n          states[++index] = state;\n        }\n      }\n      // The current term is not accepted by the automaton.\n      // Still record the reached automaton state to start the next term steps from there.\n      assert !runAutomaton.run(lineTerm.bytes, 0, lineTerm.length);\n      numMatchedBytes = index;\n      // If the number of consecutively rejected terms reaches the threshold,\n      // then determine whether it is worthwhile to jump to a block away.\n      if (++numConsecutivelyRejectedTerms >= NUM_CONSECUTIVELY_REJECTED_TERMS_THRESHOLD\n          && lineIndexInBlock < blockHeader.getLinesCount() - 1\n          && !nextStringCalculator.isLinearState(lineTerm)) {\n        // Compute the next term accepted by the automaton after the current term.\n        if ((seekTerm = nextStringCalculator.nextSeekTerm(lineTerm)) == null) {\n          blockIteration = BlockIteration.END;\n          return null;\n        }\n        // It is worthwhile to jump to a block away if the next term accepted is after the next term in the block.\n        // Actually the block away may be the current block, but this is a good heuristic.\n        readLineInBlock();\n        if (seekTerm.compareTo(blockLine.getTermBytes().getTerm()) > 0) {\n          // Stop scanning this block terms and set the iteration order to jump to a block away by seeking seekTerm.\n          blockIteration = BlockIteration.SEEK;\n          return null;\n        }\n        seekTerm = null;\n        // If it is not worthwhile to jump to a block away, do not attempt anymore for the current block.\n        numConsecutivelyRejectedTerms = Integer.MIN_VALUE;\n      } else if (readLineInBlock() == null) {\n        // No more terms in the block. The iteration order is to open the very next block.\n        assert blockIteration == BlockIteration.NEXT;\n        return null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Find the next block line that matches, or null when at end of block.\n   */\n  protected BytesRef nextTermInBlockMatching() throws IOException {\n    do {\n      // if seekTerm is set, then we seek into this block instead of starting with the first blindly.\n      if (seekTerm != null) {\n        assert blockLine == null;\n        boolean moveBeyondIfFound = seekTerm == startTerm; // for startTerm, we want to get the following term\n        SeekStatus seekStatus = seekInBlock(seekTerm);\n        seekTerm = null;// reset.\n        if (seekStatus == SeekStatus.END) {\n          return null;\n        } else if (seekStatus == SeekStatus.FOUND && moveBeyondIfFound) {\n          if (readLineInBlock() == null) {\n            return null;\n          }\n        }\n        assert blockLine != null;\n      } else {\n        if (readLineInBlock() == null) {\n          return null;\n        }\n      }\n\n      TermBytes lineTermBytes = blockLine.getTermBytes();\n      BytesRef lineTerm = lineTermBytes.getTerm();\n\n      if (commonSuffixRef == null || StringHelper.endsWith(lineTerm, commonSuffixRef)) {\n        if (runAutomatonFromPrefix(lineTerm)) {\n          return lineTerm;\n        } else if (beyondCommonPrefix) {\n          return null;\n        }\n      }\n\n    } while (true);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"09dfa411e0e1bbfad83c3e6629cf1fe24a7aed89":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"23fcccd57316410c404dd37307a496ab850efa9c":["09dfa411e0e1bbfad83c3e6629cf1fe24a7aed89"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["23fcccd57316410c404dd37307a496ab850efa9c"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["09dfa411e0e1bbfad83c3e6629cf1fe24a7aed89"],"09dfa411e0e1bbfad83c3e6629cf1fe24a7aed89":["23fcccd57316410c404dd37307a496ab850efa9c"],"23fcccd57316410c404dd37307a496ab850efa9c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}