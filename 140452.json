{"path":"lucene/core/src/java/org/apache/lucene/util/fst/FST#pack(int,int,float).mjava","commits":[{"id":"edb74c83fff94196b864e08ca033d92823252cb7","date":1339593164,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#pack(int,int,float).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#pack(int,int).mjava","sourceNew":"  /** Expert: creates an FST by packing this one.  This\n   *  process requires substantial additional RAM (currently\n   *  up to ~8 bytes per node depending on\n   *  <code>acceptableOverheadRatio</code>), but then should\n   *  produce a smaller FST. */\n  public FST<T> pack(int minInCountDeref, int maxDerefNodes, float acceptableOverheadRatio) throws IOException {\n\n    // TODO: other things to try\n    //   - renumber the nodes to get more next / better locality?\n    //   - allow multiple input labels on an arc, so\n    //     singular chain of inputs can take one arc (on\n    //     wikipedia terms this could save another ~6%)\n    //   - in the ord case, the output '1' is presumably\n    //     very common (after NO_OUTPUT)... maybe use a bit\n    //     for it..?\n    //   - use spare bits in flags.... for top few labels /\n    //     outputs / targets\n\n    if (nodeAddress == null) {\n      throw new IllegalArgumentException(\"this FST was not built with willPackFST=true\");\n    }\n\n    Arc<T> arc = new Arc<T>();\n\n    final BytesReader r = getBytesReader(0);\n\n    final int topN = Math.min(maxDerefNodes, inCounts.size());\n\n    // Find top nodes with highest number of incoming arcs:\n    NodeQueue q = new NodeQueue(topN);\n\n    // TODO: we could use more RAM efficient selection algo here...\n    NodeAndInCount bottom = null;\n    for(int node=0; node<inCounts.size(); node++) {\n      if (inCounts.get(node) >= minInCountDeref) {\n        if (bottom == null) {\n          q.add(new NodeAndInCount(node, (int) inCounts.get(node)));\n          if (q.size() == topN) {\n            bottom = q.top();\n          }\n        } else if (inCounts.get(node) > bottom.count) {\n          q.insertWithOverflow(new NodeAndInCount(node, (int) inCounts.get(node)));\n        }\n      }\n    }\n\n    // Free up RAM:\n    inCounts = null;\n\n    final Map<Integer,Integer> topNodeMap = new HashMap<Integer,Integer>();\n    for(int downTo=q.size()-1;downTo>=0;downTo--) {\n      NodeAndInCount n = q.pop();\n      topNodeMap.put(n.node, downTo);\n      //System.out.println(\"map node=\" + n.node + \" inCount=\" + n.count + \" to newID=\" + downTo);\n    }\n\n    final FST<T> fst = new FST<T>(inputType, null, outputs);\n\n    final BytesWriter writer = fst.writer;\n\n    // +1 because node ords start at 1 (0 is reserved as stop node):\n    final GrowableWriter newNodeAddress = new GrowableWriter(\n        PackedInts.bitsRequired(bytes.length), 1 + nodeCount, acceptableOverheadRatio);\n\n    // Fill initial coarse guess:\n    for(int node=1;node<=nodeCount;node++) {\n      newNodeAddress.set(node, 1 + bytes.length - nodeAddress.get(node));\n    }\n\n    int absCount;\n    int deltaCount;\n    int topCount;\n    int nextCount;\n\n    // Iterate until we converge:\n    while(true) {\n\n      //System.out.println(\"\\nITER\");\n      boolean changed = false;\n\n      // for assert:\n      boolean negDelta = false;\n\n      writer.posWrite = 0;\n      // Skip 0 byte since 0 is reserved target:\n      writer.writeByte((byte) 0);\n\n      fst.arcWithOutputCount = 0;\n      fst.nodeCount = 0;\n      fst.arcCount = 0;\n\n      absCount = deltaCount = topCount = nextCount = 0;\n\n      int changedCount = 0;\n\n      int addressError = 0;\n\n      //int totWasted = 0;\n\n      // Since we re-reverse the bytes, we now write the\n      // nodes backwards, so that BIT_TARGET_NEXT is\n      // unchanged:\n      for(int node=nodeCount;node>=1;node--) {\n        fst.nodeCount++;\n        final int address = writer.posWrite;\n        //System.out.println(\"  node: \" + node + \" address=\" + address);\n        if (address != newNodeAddress.get(node)) {\n          addressError = address - (int) newNodeAddress.get(node);\n          //System.out.println(\"    change: \" + (address - newNodeAddress[node]));\n          changed = true;\n          newNodeAddress.set(node, address);\n          changedCount++;\n        }\n\n        int nodeArcCount = 0;\n        int bytesPerArc = 0;\n\n        boolean retry = false;\n\n        // for assert:\n        boolean anyNegDelta = false;\n\n        // Retry loop: possibly iterate more than once, if\n        // this is an array'd node and bytesPerArc changes:\n        writeNode:\n        while(true) { // retry writing this node\n\n          readFirstRealTargetArc(node, arc, r);\n\n          final boolean useArcArray = arc.bytesPerArc != 0;\n          if (useArcArray) {\n            // Write false first arc:\n            if (bytesPerArc == 0) {\n              bytesPerArc = arc.bytesPerArc;\n            }\n            writer.writeByte(ARCS_AS_FIXED_ARRAY);\n            writer.writeVInt(arc.numArcs);\n            writer.writeVInt(bytesPerArc);\n            //System.out.println(\"node \" + node + \": \" + arc.numArcs + \" arcs\");\n          }\n\n          int maxBytesPerArc = 0;\n          //int wasted = 0;\n          while(true) {  // iterate over all arcs for this node\n\n            //System.out.println(\"    arc label=\" + arc.label + \" target=\" + arc.target + \" pos=\" + writer.posWrite);\n            final int arcStartPos = writer.posWrite;\n            nodeArcCount++;\n\n            byte flags = 0;\n\n            if (arc.isLast()) {\n              flags += BIT_LAST_ARC;\n            }\n            /*\n            if (!useArcArray && nodeUpto < nodes.length-1 && arc.target == nodes[nodeUpto+1]) {\n              flags += BIT_TARGET_NEXT;\n            }\n            */\n            if (!useArcArray && node != 1 && arc.target == node-1) {\n              flags += BIT_TARGET_NEXT;\n              if (!retry) {\n                nextCount++;\n              }\n            }\n            if (arc.isFinal()) {\n              flags += BIT_FINAL_ARC;\n              if (arc.nextFinalOutput != NO_OUTPUT) {\n                flags += BIT_ARC_HAS_FINAL_OUTPUT;\n              }\n            } else {\n              assert arc.nextFinalOutput == NO_OUTPUT;\n            }\n            if (!targetHasArcs(arc)) {\n              flags += BIT_STOP_NODE;\n            }\n\n            if (arc.output != NO_OUTPUT) {\n              flags += BIT_ARC_HAS_OUTPUT;\n            }\n\n            final Integer ptr;\n            final int absPtr;\n            final boolean doWriteTarget = targetHasArcs(arc) && (flags & BIT_TARGET_NEXT) == 0;\n            if (doWriteTarget) {\n\n              ptr = topNodeMap.get(arc.target);\n              if (ptr != null) {\n                absPtr = ptr;\n              } else {\n                absPtr = topNodeMap.size() + (int) newNodeAddress.get(arc.target) + addressError;\n              }\n\n              int delta = (int) newNodeAddress.get(arc.target) + addressError - writer.posWrite - 2;\n              if (delta < 0) {\n                //System.out.println(\"neg: \" + delta);\n                anyNegDelta = true;\n                delta = 0;\n              }\n\n              if (delta < absPtr) {\n                flags |= BIT_TARGET_DELTA;\n              }\n            } else {\n              ptr = null;\n              absPtr = 0;\n            }\n\n            writer.writeByte(flags);\n            fst.writeLabel(arc.label);\n\n            if (arc.output != NO_OUTPUT) {\n              outputs.write(arc.output, writer);\n              if (!retry) {\n                fst.arcWithOutputCount++;\n              }\n            }\n            if (arc.nextFinalOutput != NO_OUTPUT) {\n              outputs.write(arc.nextFinalOutput, writer);\n            }\n\n            if (doWriteTarget) {\n\n              int delta = (int) newNodeAddress.get(arc.target) + addressError - writer.posWrite;\n              if (delta < 0) {\n                anyNegDelta = true;\n                //System.out.println(\"neg: \" + delta);\n                delta = 0;\n              }\n\n              if (flag(flags, BIT_TARGET_DELTA)) {\n                //System.out.println(\"        delta\");\n                writer.writeVInt(delta);\n                if (!retry) {\n                  deltaCount++;\n                }\n              } else {\n                /*\n                if (ptr != null) {\n                  System.out.println(\"        deref\");\n                } else {\n                  System.out.println(\"        abs\");\n                }\n                */\n                writer.writeVInt(absPtr);\n                if (!retry) {\n                  if (absPtr >= topNodeMap.size()) {\n                    absCount++;\n                  } else {\n                    topCount++;\n                  }\n                }\n              }\n            }\n\n            if (useArcArray) {\n              final int arcBytes = writer.posWrite - arcStartPos;\n              //System.out.println(\"  \" + arcBytes + \" bytes\");\n              maxBytesPerArc = Math.max(maxBytesPerArc, arcBytes);\n              // NOTE: this may in fact go \"backwards\", if\n              // somehow (rarely, possibly never) we use\n              // more bytesPerArc in this rewrite than the\n              // incoming FST did... but in this case we\n              // will retry (below) so it's OK to ovewrite\n              // bytes:\n              //wasted += bytesPerArc - arcBytes;\n              writer.setPosWrite(arcStartPos + bytesPerArc);\n            }\n\n            if (arc.isLast()) {\n              break;\n            }\n\n            readNextRealArc(arc, r);\n          }\n\n          if (useArcArray) {\n            if (maxBytesPerArc == bytesPerArc || (retry && maxBytesPerArc <= bytesPerArc)) {\n              // converged\n              //System.out.println(\"  bba=\" + bytesPerArc + \" wasted=\" + wasted);\n              //totWasted += wasted;\n              break;\n            }\n          } else {\n            break;\n          }\n\n          //System.out.println(\"  retry this node maxBytesPerArc=\" + maxBytesPerArc + \" vs \" + bytesPerArc);\n\n          // Retry:\n          bytesPerArc = maxBytesPerArc;\n          writer.posWrite = address;\n          nodeArcCount = 0;\n          retry = true;\n          anyNegDelta = false;\n        }\n        negDelta |= anyNegDelta;\n\n        fst.arcCount += nodeArcCount;\n      }\n\n      if (!changed) {\n        // We don't renumber the nodes (just reverse their\n        // order) so nodes should only point forward to\n        // other nodes because we only produce acyclic FSTs\n        // w/ nodes only pointing \"forwards\":\n        assert !negDelta;\n        //System.out.println(\"TOT wasted=\" + totWasted);\n        // Converged!\n        break;\n      }\n      //System.out.println(\"  \" + changedCount + \" of \" + fst.nodeCount + \" changed; retry\");\n    }\n\n    long maxAddress = 0;\n    for (int key : topNodeMap.keySet()) {\n      maxAddress = Math.max(maxAddress, newNodeAddress.get(key));\n    }\n\n    PackedInts.Mutable nodeRefToAddressIn = PackedInts.getMutable(topNodeMap.size(),\n        PackedInts.bitsRequired(maxAddress), acceptableOverheadRatio);\n    for(Map.Entry<Integer,Integer> ent : topNodeMap.entrySet()) {\n      nodeRefToAddressIn.set(ent.getValue(), newNodeAddress.get(ent.getKey()));\n    }\n    fst.nodeRefToAddress = nodeRefToAddressIn;\n    \n\n    fst.startNode = (int) newNodeAddress.get(startNode);\n    //System.out.println(\"new startNode=\" + fst.startNode + \" old startNode=\" + startNode);\n\n    if (emptyOutput != null) {\n      fst.setEmptyOutput(emptyOutput);\n    }\n\n    assert fst.nodeCount == nodeCount: \"fst.nodeCount=\" + fst.nodeCount + \" nodeCount=\" + nodeCount;\n    assert fst.arcCount == arcCount;\n    assert fst.arcWithOutputCount == arcWithOutputCount: \"fst.arcWithOutputCount=\" + fst.arcWithOutputCount + \" arcWithOutputCount=\" + arcWithOutputCount;\n    \n    final byte[] finalBytes = new byte[writer.posWrite];\n    //System.out.println(\"resize \" + fst.bytes.length + \" down to \" + writer.posWrite);\n    System.arraycopy(fst.bytes, 0, finalBytes, 0, writer.posWrite);\n    fst.bytes = finalBytes;\n    fst.cacheRootArcs();\n\n    //final int size = fst.sizeInBytes();\n    //System.out.println(\"nextCount=\" + nextCount + \" topCount=\" + topCount + \" deltaCount=\" + deltaCount + \" absCount=\" + absCount);\n\n    return fst;\n  }\n\n","sourceOld":"  /** Expert: creates an FST by packing this one.  This\n   *  process requires substantial additional RAM (currently\n   *  ~8 bytes per node), but then should produce a smaller FST. */\n  public FST<T> pack(int minInCountDeref, int maxDerefNodes) throws IOException {\n\n    // TODO: other things to try\n    //   - renumber the nodes to get more next / better locality?\n    //   - allow multiple input labels on an arc, so\n    //     singular chain of inputs can take one arc (on\n    //     wikipedia terms this could save another ~6%)\n    //   - in the ord case, the output '1' is presumably\n    //     very common (after NO_OUTPUT)... maybe use a bit\n    //     for it..?\n    //   - use spare bits in flags.... for top few labels /\n    //     outputs / targets\n\n    if (nodeAddress == null) {\n      throw new IllegalArgumentException(\"this FST was not built with willPackFST=true\");\n    }\n\n    Arc<T> arc = new Arc<T>();\n\n    final BytesReader r = getBytesReader(0);\n\n    final int topN = Math.min(maxDerefNodes, inCounts.length);\n\n    // Find top nodes with highest number of incoming arcs:\n    NodeQueue q = new NodeQueue(topN);\n\n    // TODO: we could use more RAM efficient selection algo here...\n    NodeAndInCount bottom = null;\n    for(int node=0;node<inCounts.length;node++) {\n      if (inCounts[node] >= minInCountDeref) {\n        if (bottom == null) {\n          q.add(new NodeAndInCount(node, inCounts[node]));\n          if (q.size() == topN) {\n            bottom = q.top();\n          }\n        } else if (inCounts[node] > bottom.count) {\n          q.insertWithOverflow(new NodeAndInCount(node, inCounts[node]));\n        }\n      }\n    }\n\n    // Free up RAM:\n    inCounts = null;\n\n    final Map<Integer,Integer> topNodeMap = new HashMap<Integer,Integer>();\n    for(int downTo=q.size()-1;downTo>=0;downTo--) {\n      NodeAndInCount n = q.pop();\n      topNodeMap.put(n.node, downTo);\n      //System.out.println(\"map node=\" + n.node + \" inCount=\" + n.count + \" to newID=\" + downTo);\n    }\n\n    // TODO: we can use packed ints:\n    // +1 because node ords start at 1 (0 is reserved as\n    // stop node):\n    final int[] nodeRefToAddressIn = new int[topNodeMap.size()];\n\n    final FST<T> fst = new FST<T>(inputType, nodeRefToAddressIn, outputs);\n\n    final BytesWriter writer = fst.writer;\n    \n    final int[] newNodeAddress = new int[1+nodeCount];\n\n    // Fill initial coarse guess:\n    for(int node=1;node<=nodeCount;node++) {\n      newNodeAddress[node] = 1 + bytes.length - nodeAddress[node];\n    }\n\n    int absCount;\n    int deltaCount;\n    int topCount;\n    int nextCount;\n\n    // Iterate until we converge:\n    while(true) {\n\n      //System.out.println(\"\\nITER\");\n      boolean changed = false;\n\n      // for assert:\n      boolean negDelta = false;\n\n      writer.posWrite = 0;\n      // Skip 0 byte since 0 is reserved target:\n      writer.writeByte((byte) 0);\n\n      fst.arcWithOutputCount = 0;\n      fst.nodeCount = 0;\n      fst.arcCount = 0;\n\n      absCount = deltaCount = topCount = nextCount = 0;\n\n      int changedCount = 0;\n\n      int addressError = 0;\n\n      //int totWasted = 0;\n\n      // Since we re-reverse the bytes, we now write the\n      // nodes backwards, so that BIT_TARGET_NEXT is\n      // unchanged:\n      for(int node=nodeCount;node>=1;node--) {\n        fst.nodeCount++;\n        final int address = writer.posWrite;\n        //System.out.println(\"  node: \" + node + \" address=\" + address);\n        if (address != newNodeAddress[node]) {\n          addressError = address - newNodeAddress[node];\n          //System.out.println(\"    change: \" + (address - newNodeAddress[node]));\n          changed = true;\n          newNodeAddress[node] = address;\n          changedCount++;\n        }\n\n        int nodeArcCount = 0;\n        int bytesPerArc = 0;\n\n        boolean retry = false;\n\n        // for assert:\n        boolean anyNegDelta = false;\n\n        // Retry loop: possibly iterate more than once, if\n        // this is an array'd node and bytesPerArc changes:\n        writeNode:\n        while(true) { // retry writing this node\n\n          readFirstRealTargetArc(node, arc, r);\n\n          final boolean useArcArray = arc.bytesPerArc != 0;\n          if (useArcArray) {\n            // Write false first arc:\n            if (bytesPerArc == 0) {\n              bytesPerArc = arc.bytesPerArc;\n            }\n            writer.writeByte(ARCS_AS_FIXED_ARRAY);\n            writer.writeVInt(arc.numArcs);\n            writer.writeVInt(bytesPerArc);\n            //System.out.println(\"node \" + node + \": \" + arc.numArcs + \" arcs\");\n          }\n\n          int maxBytesPerArc = 0;\n          //int wasted = 0;\n          while(true) {  // iterate over all arcs for this node\n\n            //System.out.println(\"    arc label=\" + arc.label + \" target=\" + arc.target + \" pos=\" + writer.posWrite);\n            final int arcStartPos = writer.posWrite;\n            nodeArcCount++;\n\n            byte flags = 0;\n\n            if (arc.isLast()) {\n              flags += BIT_LAST_ARC;\n            }\n            /*\n            if (!useArcArray && nodeUpto < nodes.length-1 && arc.target == nodes[nodeUpto+1]) {\n              flags += BIT_TARGET_NEXT;\n            }\n            */\n            if (!useArcArray && node != 1 && arc.target == node-1) {\n              flags += BIT_TARGET_NEXT;\n              if (!retry) {\n                nextCount++;\n              }\n            }\n            if (arc.isFinal()) {\n              flags += BIT_FINAL_ARC;\n              if (arc.nextFinalOutput != NO_OUTPUT) {\n                flags += BIT_ARC_HAS_FINAL_OUTPUT;\n              }\n            } else {\n              assert arc.nextFinalOutput == NO_OUTPUT;\n            }\n            if (!targetHasArcs(arc)) {\n              flags += BIT_STOP_NODE;\n            }\n\n            if (arc.output != NO_OUTPUT) {\n              flags += BIT_ARC_HAS_OUTPUT;\n            }\n\n            final Integer ptr;\n            final int absPtr;\n            final boolean doWriteTarget = targetHasArcs(arc) && (flags & BIT_TARGET_NEXT) == 0;\n            if (doWriteTarget) {\n\n              ptr = topNodeMap.get(arc.target);\n              if (ptr != null) {\n                absPtr = ptr;\n              } else {\n                absPtr = topNodeMap.size() + newNodeAddress[arc.target] + addressError;\n              }\n\n              int delta = newNodeAddress[arc.target] + addressError - writer.posWrite - 2;\n              if (delta < 0) {\n                //System.out.println(\"neg: \" + delta);\n                anyNegDelta = true;\n                delta = 0;\n              }\n\n              if (delta < absPtr) {\n                flags |= BIT_TARGET_DELTA;\n              }\n            } else {\n              ptr = null;\n              absPtr = 0;\n            }\n\n            writer.writeByte(flags);\n            fst.writeLabel(arc.label);\n\n            if (arc.output != NO_OUTPUT) {\n              outputs.write(arc.output, writer);\n              if (!retry) {\n                fst.arcWithOutputCount++;\n              }\n            }\n            if (arc.nextFinalOutput != NO_OUTPUT) {\n              outputs.write(arc.nextFinalOutput, writer);\n            }\n\n            if (doWriteTarget) {\n\n              int delta = newNodeAddress[arc.target] + addressError - writer.posWrite;\n              if (delta < 0) {\n                anyNegDelta = true;\n                //System.out.println(\"neg: \" + delta);\n                delta = 0;\n              }\n\n              if (flag(flags, BIT_TARGET_DELTA)) {\n                //System.out.println(\"        delta\");\n                writer.writeVInt(delta);\n                if (!retry) {\n                  deltaCount++;\n                }\n              } else {\n                /*\n                if (ptr != null) {\n                  System.out.println(\"        deref\");\n                } else {\n                  System.out.println(\"        abs\");\n                }\n                */\n                writer.writeVInt(absPtr);\n                if (!retry) {\n                  if (absPtr >= topNodeMap.size()) {\n                    absCount++;\n                  } else {\n                    topCount++;\n                  }\n                }\n              }\n            }\n\n            if (useArcArray) {\n              final int arcBytes = writer.posWrite - arcStartPos;\n              //System.out.println(\"  \" + arcBytes + \" bytes\");\n              maxBytesPerArc = Math.max(maxBytesPerArc, arcBytes);\n              // NOTE: this may in fact go \"backwards\", if\n              // somehow (rarely, possibly never) we use\n              // more bytesPerArc in this rewrite than the\n              // incoming FST did... but in this case we\n              // will retry (below) so it's OK to ovewrite\n              // bytes:\n              //wasted += bytesPerArc - arcBytes;\n              writer.setPosWrite(arcStartPos + bytesPerArc);\n            }\n\n            if (arc.isLast()) {\n              break;\n            }\n\n            readNextRealArc(arc, r);\n          }\n\n          if (useArcArray) {\n            if (maxBytesPerArc == bytesPerArc || (retry && maxBytesPerArc <= bytesPerArc)) {\n              // converged\n              //System.out.println(\"  bba=\" + bytesPerArc + \" wasted=\" + wasted);\n              //totWasted += wasted;\n              break;\n            }\n          } else {\n            break;\n          }\n\n          //System.out.println(\"  retry this node maxBytesPerArc=\" + maxBytesPerArc + \" vs \" + bytesPerArc);\n\n          // Retry:\n          bytesPerArc = maxBytesPerArc;\n          writer.posWrite = address;\n          nodeArcCount = 0;\n          retry = true;\n          anyNegDelta = false;\n        }\n        negDelta |= anyNegDelta;\n\n        fst.arcCount += nodeArcCount;\n      }\n\n      if (!changed) {\n        // We don't renumber the nodes (just reverse their\n        // order) so nodes should only point forward to\n        // other nodes because we only produce acyclic FSTs\n        // w/ nodes only pointing \"forwards\":\n        assert !negDelta;\n        //System.out.println(\"TOT wasted=\" + totWasted);\n        // Converged!\n        break;\n      }\n      //System.out.println(\"  \" + changedCount + \" of \" + fst.nodeCount + \" changed; retry\");\n    }\n\n    for(Map.Entry<Integer,Integer> ent : topNodeMap.entrySet()) {\n      nodeRefToAddressIn[ent.getValue()] = newNodeAddress[ent.getKey()];\n    }\n\n    fst.startNode = newNodeAddress[startNode];\n    //System.out.println(\"new startNode=\" + fst.startNode + \" old startNode=\" + startNode);\n\n    if (emptyOutput != null) {\n      fst.setEmptyOutput(emptyOutput);\n    }\n\n    assert fst.nodeCount == nodeCount: \"fst.nodeCount=\" + fst.nodeCount + \" nodeCount=\" + nodeCount;\n    assert fst.arcCount == arcCount;\n    assert fst.arcWithOutputCount == arcWithOutputCount: \"fst.arcWithOutputCount=\" + fst.arcWithOutputCount + \" arcWithOutputCount=\" + arcWithOutputCount;\n    \n    final byte[] finalBytes = new byte[writer.posWrite];\n    //System.out.println(\"resize \" + fst.bytes.length + \" down to \" + writer.posWrite);\n    System.arraycopy(fst.bytes, 0, finalBytes, 0, writer.posWrite);\n    fst.bytes = finalBytes;\n    fst.cacheRootArcs();\n\n    //final int size = fst.sizeInBytes();\n    //System.out.println(\"nextCount=\" + nextCount + \" topCount=\" + topCount + \" deltaCount=\" + deltaCount + \" absCount=\" + absCount);\n\n    return fst;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b26194bf4449ad4f480a19cd5e745f64e3430b64","date":1339594558,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#pack(int,int,float).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#pack(int,int,float).mjava","sourceNew":"  /** Expert: creates an FST by packing this one.  This\n   *  process requires substantial additional RAM (currently\n   *  up to ~8 bytes per node depending on\n   *  <code>acceptableOverheadRatio</code>), but then should\n   *  produce a smaller FST.\n   *\n   *  <p>The implementation of this method uses ideas from\n   *  <a target=\"_blank\" href=\"http://www.cs.put.poznan.pl/dweiss/site/publications/download/fsacomp.pdf\">Smaller Representation of Finite State Automata</a>,\n   *  which describes techniques to reduce the size of a FST.\n   *  However, this is not a strict implementation of the\n   *  algorithms described in this paper.\n   */\n  public FST<T> pack(int minInCountDeref, int maxDerefNodes, float acceptableOverheadRatio) throws IOException {\n\n    // TODO: other things to try\n    //   - renumber the nodes to get more next / better locality?\n    //   - allow multiple input labels on an arc, so\n    //     singular chain of inputs can take one arc (on\n    //     wikipedia terms this could save another ~6%)\n    //   - in the ord case, the output '1' is presumably\n    //     very common (after NO_OUTPUT)... maybe use a bit\n    //     for it..?\n    //   - use spare bits in flags.... for top few labels /\n    //     outputs / targets\n\n    if (nodeAddress == null) {\n      throw new IllegalArgumentException(\"this FST was not built with willPackFST=true\");\n    }\n\n    Arc<T> arc = new Arc<T>();\n\n    final BytesReader r = getBytesReader(0);\n\n    final int topN = Math.min(maxDerefNodes, inCounts.size());\n\n    // Find top nodes with highest number of incoming arcs:\n    NodeQueue q = new NodeQueue(topN);\n\n    // TODO: we could use more RAM efficient selection algo here...\n    NodeAndInCount bottom = null;\n    for(int node=0; node<inCounts.size(); node++) {\n      if (inCounts.get(node) >= minInCountDeref) {\n        if (bottom == null) {\n          q.add(new NodeAndInCount(node, (int) inCounts.get(node)));\n          if (q.size() == topN) {\n            bottom = q.top();\n          }\n        } else if (inCounts.get(node) > bottom.count) {\n          q.insertWithOverflow(new NodeAndInCount(node, (int) inCounts.get(node)));\n        }\n      }\n    }\n\n    // Free up RAM:\n    inCounts = null;\n\n    final Map<Integer,Integer> topNodeMap = new HashMap<Integer,Integer>();\n    for(int downTo=q.size()-1;downTo>=0;downTo--) {\n      NodeAndInCount n = q.pop();\n      topNodeMap.put(n.node, downTo);\n      //System.out.println(\"map node=\" + n.node + \" inCount=\" + n.count + \" to newID=\" + downTo);\n    }\n\n    final FST<T> fst = new FST<T>(inputType, null, outputs);\n\n    final BytesWriter writer = fst.writer;\n\n    // +1 because node ords start at 1 (0 is reserved as stop node):\n    final GrowableWriter newNodeAddress = new GrowableWriter(\n        PackedInts.bitsRequired(bytes.length), 1 + nodeCount, acceptableOverheadRatio);\n\n    // Fill initial coarse guess:\n    for(int node=1;node<=nodeCount;node++) {\n      newNodeAddress.set(node, 1 + bytes.length - nodeAddress.get(node));\n    }\n\n    int absCount;\n    int deltaCount;\n    int topCount;\n    int nextCount;\n\n    // Iterate until we converge:\n    while(true) {\n\n      //System.out.println(\"\\nITER\");\n      boolean changed = false;\n\n      // for assert:\n      boolean negDelta = false;\n\n      writer.posWrite = 0;\n      // Skip 0 byte since 0 is reserved target:\n      writer.writeByte((byte) 0);\n\n      fst.arcWithOutputCount = 0;\n      fst.nodeCount = 0;\n      fst.arcCount = 0;\n\n      absCount = deltaCount = topCount = nextCount = 0;\n\n      int changedCount = 0;\n\n      int addressError = 0;\n\n      //int totWasted = 0;\n\n      // Since we re-reverse the bytes, we now write the\n      // nodes backwards, so that BIT_TARGET_NEXT is\n      // unchanged:\n      for(int node=nodeCount;node>=1;node--) {\n        fst.nodeCount++;\n        final int address = writer.posWrite;\n        //System.out.println(\"  node: \" + node + \" address=\" + address);\n        if (address != newNodeAddress.get(node)) {\n          addressError = address - (int) newNodeAddress.get(node);\n          //System.out.println(\"    change: \" + (address - newNodeAddress[node]));\n          changed = true;\n          newNodeAddress.set(node, address);\n          changedCount++;\n        }\n\n        int nodeArcCount = 0;\n        int bytesPerArc = 0;\n\n        boolean retry = false;\n\n        // for assert:\n        boolean anyNegDelta = false;\n\n        // Retry loop: possibly iterate more than once, if\n        // this is an array'd node and bytesPerArc changes:\n        writeNode:\n        while(true) { // retry writing this node\n\n          readFirstRealTargetArc(node, arc, r);\n\n          final boolean useArcArray = arc.bytesPerArc != 0;\n          if (useArcArray) {\n            // Write false first arc:\n            if (bytesPerArc == 0) {\n              bytesPerArc = arc.bytesPerArc;\n            }\n            writer.writeByte(ARCS_AS_FIXED_ARRAY);\n            writer.writeVInt(arc.numArcs);\n            writer.writeVInt(bytesPerArc);\n            //System.out.println(\"node \" + node + \": \" + arc.numArcs + \" arcs\");\n          }\n\n          int maxBytesPerArc = 0;\n          //int wasted = 0;\n          while(true) {  // iterate over all arcs for this node\n\n            //System.out.println(\"    arc label=\" + arc.label + \" target=\" + arc.target + \" pos=\" + writer.posWrite);\n            final int arcStartPos = writer.posWrite;\n            nodeArcCount++;\n\n            byte flags = 0;\n\n            if (arc.isLast()) {\n              flags += BIT_LAST_ARC;\n            }\n            /*\n            if (!useArcArray && nodeUpto < nodes.length-1 && arc.target == nodes[nodeUpto+1]) {\n              flags += BIT_TARGET_NEXT;\n            }\n            */\n            if (!useArcArray && node != 1 && arc.target == node-1) {\n              flags += BIT_TARGET_NEXT;\n              if (!retry) {\n                nextCount++;\n              }\n            }\n            if (arc.isFinal()) {\n              flags += BIT_FINAL_ARC;\n              if (arc.nextFinalOutput != NO_OUTPUT) {\n                flags += BIT_ARC_HAS_FINAL_OUTPUT;\n              }\n            } else {\n              assert arc.nextFinalOutput == NO_OUTPUT;\n            }\n            if (!targetHasArcs(arc)) {\n              flags += BIT_STOP_NODE;\n            }\n\n            if (arc.output != NO_OUTPUT) {\n              flags += BIT_ARC_HAS_OUTPUT;\n            }\n\n            final Integer ptr;\n            final int absPtr;\n            final boolean doWriteTarget = targetHasArcs(arc) && (flags & BIT_TARGET_NEXT) == 0;\n            if (doWriteTarget) {\n\n              ptr = topNodeMap.get(arc.target);\n              if (ptr != null) {\n                absPtr = ptr;\n              } else {\n                absPtr = topNodeMap.size() + (int) newNodeAddress.get(arc.target) + addressError;\n              }\n\n              int delta = (int) newNodeAddress.get(arc.target) + addressError - writer.posWrite - 2;\n              if (delta < 0) {\n                //System.out.println(\"neg: \" + delta);\n                anyNegDelta = true;\n                delta = 0;\n              }\n\n              if (delta < absPtr) {\n                flags |= BIT_TARGET_DELTA;\n              }\n            } else {\n              ptr = null;\n              absPtr = 0;\n            }\n\n            writer.writeByte(flags);\n            fst.writeLabel(arc.label);\n\n            if (arc.output != NO_OUTPUT) {\n              outputs.write(arc.output, writer);\n              if (!retry) {\n                fst.arcWithOutputCount++;\n              }\n            }\n            if (arc.nextFinalOutput != NO_OUTPUT) {\n              outputs.write(arc.nextFinalOutput, writer);\n            }\n\n            if (doWriteTarget) {\n\n              int delta = (int) newNodeAddress.get(arc.target) + addressError - writer.posWrite;\n              if (delta < 0) {\n                anyNegDelta = true;\n                //System.out.println(\"neg: \" + delta);\n                delta = 0;\n              }\n\n              if (flag(flags, BIT_TARGET_DELTA)) {\n                //System.out.println(\"        delta\");\n                writer.writeVInt(delta);\n                if (!retry) {\n                  deltaCount++;\n                }\n              } else {\n                /*\n                if (ptr != null) {\n                  System.out.println(\"        deref\");\n                } else {\n                  System.out.println(\"        abs\");\n                }\n                */\n                writer.writeVInt(absPtr);\n                if (!retry) {\n                  if (absPtr >= topNodeMap.size()) {\n                    absCount++;\n                  } else {\n                    topCount++;\n                  }\n                }\n              }\n            }\n\n            if (useArcArray) {\n              final int arcBytes = writer.posWrite - arcStartPos;\n              //System.out.println(\"  \" + arcBytes + \" bytes\");\n              maxBytesPerArc = Math.max(maxBytesPerArc, arcBytes);\n              // NOTE: this may in fact go \"backwards\", if\n              // somehow (rarely, possibly never) we use\n              // more bytesPerArc in this rewrite than the\n              // incoming FST did... but in this case we\n              // will retry (below) so it's OK to ovewrite\n              // bytes:\n              //wasted += bytesPerArc - arcBytes;\n              writer.setPosWrite(arcStartPos + bytesPerArc);\n            }\n\n            if (arc.isLast()) {\n              break;\n            }\n\n            readNextRealArc(arc, r);\n          }\n\n          if (useArcArray) {\n            if (maxBytesPerArc == bytesPerArc || (retry && maxBytesPerArc <= bytesPerArc)) {\n              // converged\n              //System.out.println(\"  bba=\" + bytesPerArc + \" wasted=\" + wasted);\n              //totWasted += wasted;\n              break;\n            }\n          } else {\n            break;\n          }\n\n          //System.out.println(\"  retry this node maxBytesPerArc=\" + maxBytesPerArc + \" vs \" + bytesPerArc);\n\n          // Retry:\n          bytesPerArc = maxBytesPerArc;\n          writer.posWrite = address;\n          nodeArcCount = 0;\n          retry = true;\n          anyNegDelta = false;\n        }\n        negDelta |= anyNegDelta;\n\n        fst.arcCount += nodeArcCount;\n      }\n\n      if (!changed) {\n        // We don't renumber the nodes (just reverse their\n        // order) so nodes should only point forward to\n        // other nodes because we only produce acyclic FSTs\n        // w/ nodes only pointing \"forwards\":\n        assert !negDelta;\n        //System.out.println(\"TOT wasted=\" + totWasted);\n        // Converged!\n        break;\n      }\n      //System.out.println(\"  \" + changedCount + \" of \" + fst.nodeCount + \" changed; retry\");\n    }\n\n    long maxAddress = 0;\n    for (int key : topNodeMap.keySet()) {\n      maxAddress = Math.max(maxAddress, newNodeAddress.get(key));\n    }\n\n    PackedInts.Mutable nodeRefToAddressIn = PackedInts.getMutable(topNodeMap.size(),\n        PackedInts.bitsRequired(maxAddress), acceptableOverheadRatio);\n    for(Map.Entry<Integer,Integer> ent : topNodeMap.entrySet()) {\n      nodeRefToAddressIn.set(ent.getValue(), newNodeAddress.get(ent.getKey()));\n    }\n    fst.nodeRefToAddress = nodeRefToAddressIn;\n    \n\n    fst.startNode = (int) newNodeAddress.get(startNode);\n    //System.out.println(\"new startNode=\" + fst.startNode + \" old startNode=\" + startNode);\n\n    if (emptyOutput != null) {\n      fst.setEmptyOutput(emptyOutput);\n    }\n\n    assert fst.nodeCount == nodeCount: \"fst.nodeCount=\" + fst.nodeCount + \" nodeCount=\" + nodeCount;\n    assert fst.arcCount == arcCount;\n    assert fst.arcWithOutputCount == arcWithOutputCount: \"fst.arcWithOutputCount=\" + fst.arcWithOutputCount + \" arcWithOutputCount=\" + arcWithOutputCount;\n    \n    final byte[] finalBytes = new byte[writer.posWrite];\n    //System.out.println(\"resize \" + fst.bytes.length + \" down to \" + writer.posWrite);\n    System.arraycopy(fst.bytes, 0, finalBytes, 0, writer.posWrite);\n    fst.bytes = finalBytes;\n    fst.cacheRootArcs();\n\n    //final int size = fst.sizeInBytes();\n    //System.out.println(\"nextCount=\" + nextCount + \" topCount=\" + topCount + \" deltaCount=\" + deltaCount + \" absCount=\" + absCount);\n\n    return fst;\n  }\n\n","sourceOld":"  /** Expert: creates an FST by packing this one.  This\n   *  process requires substantial additional RAM (currently\n   *  up to ~8 bytes per node depending on\n   *  <code>acceptableOverheadRatio</code>), but then should\n   *  produce a smaller FST. */\n  public FST<T> pack(int minInCountDeref, int maxDerefNodes, float acceptableOverheadRatio) throws IOException {\n\n    // TODO: other things to try\n    //   - renumber the nodes to get more next / better locality?\n    //   - allow multiple input labels on an arc, so\n    //     singular chain of inputs can take one arc (on\n    //     wikipedia terms this could save another ~6%)\n    //   - in the ord case, the output '1' is presumably\n    //     very common (after NO_OUTPUT)... maybe use a bit\n    //     for it..?\n    //   - use spare bits in flags.... for top few labels /\n    //     outputs / targets\n\n    if (nodeAddress == null) {\n      throw new IllegalArgumentException(\"this FST was not built with willPackFST=true\");\n    }\n\n    Arc<T> arc = new Arc<T>();\n\n    final BytesReader r = getBytesReader(0);\n\n    final int topN = Math.min(maxDerefNodes, inCounts.size());\n\n    // Find top nodes with highest number of incoming arcs:\n    NodeQueue q = new NodeQueue(topN);\n\n    // TODO: we could use more RAM efficient selection algo here...\n    NodeAndInCount bottom = null;\n    for(int node=0; node<inCounts.size(); node++) {\n      if (inCounts.get(node) >= minInCountDeref) {\n        if (bottom == null) {\n          q.add(new NodeAndInCount(node, (int) inCounts.get(node)));\n          if (q.size() == topN) {\n            bottom = q.top();\n          }\n        } else if (inCounts.get(node) > bottom.count) {\n          q.insertWithOverflow(new NodeAndInCount(node, (int) inCounts.get(node)));\n        }\n      }\n    }\n\n    // Free up RAM:\n    inCounts = null;\n\n    final Map<Integer,Integer> topNodeMap = new HashMap<Integer,Integer>();\n    for(int downTo=q.size()-1;downTo>=0;downTo--) {\n      NodeAndInCount n = q.pop();\n      topNodeMap.put(n.node, downTo);\n      //System.out.println(\"map node=\" + n.node + \" inCount=\" + n.count + \" to newID=\" + downTo);\n    }\n\n    final FST<T> fst = new FST<T>(inputType, null, outputs);\n\n    final BytesWriter writer = fst.writer;\n\n    // +1 because node ords start at 1 (0 is reserved as stop node):\n    final GrowableWriter newNodeAddress = new GrowableWriter(\n        PackedInts.bitsRequired(bytes.length), 1 + nodeCount, acceptableOverheadRatio);\n\n    // Fill initial coarse guess:\n    for(int node=1;node<=nodeCount;node++) {\n      newNodeAddress.set(node, 1 + bytes.length - nodeAddress.get(node));\n    }\n\n    int absCount;\n    int deltaCount;\n    int topCount;\n    int nextCount;\n\n    // Iterate until we converge:\n    while(true) {\n\n      //System.out.println(\"\\nITER\");\n      boolean changed = false;\n\n      // for assert:\n      boolean negDelta = false;\n\n      writer.posWrite = 0;\n      // Skip 0 byte since 0 is reserved target:\n      writer.writeByte((byte) 0);\n\n      fst.arcWithOutputCount = 0;\n      fst.nodeCount = 0;\n      fst.arcCount = 0;\n\n      absCount = deltaCount = topCount = nextCount = 0;\n\n      int changedCount = 0;\n\n      int addressError = 0;\n\n      //int totWasted = 0;\n\n      // Since we re-reverse the bytes, we now write the\n      // nodes backwards, so that BIT_TARGET_NEXT is\n      // unchanged:\n      for(int node=nodeCount;node>=1;node--) {\n        fst.nodeCount++;\n        final int address = writer.posWrite;\n        //System.out.println(\"  node: \" + node + \" address=\" + address);\n        if (address != newNodeAddress.get(node)) {\n          addressError = address - (int) newNodeAddress.get(node);\n          //System.out.println(\"    change: \" + (address - newNodeAddress[node]));\n          changed = true;\n          newNodeAddress.set(node, address);\n          changedCount++;\n        }\n\n        int nodeArcCount = 0;\n        int bytesPerArc = 0;\n\n        boolean retry = false;\n\n        // for assert:\n        boolean anyNegDelta = false;\n\n        // Retry loop: possibly iterate more than once, if\n        // this is an array'd node and bytesPerArc changes:\n        writeNode:\n        while(true) { // retry writing this node\n\n          readFirstRealTargetArc(node, arc, r);\n\n          final boolean useArcArray = arc.bytesPerArc != 0;\n          if (useArcArray) {\n            // Write false first arc:\n            if (bytesPerArc == 0) {\n              bytesPerArc = arc.bytesPerArc;\n            }\n            writer.writeByte(ARCS_AS_FIXED_ARRAY);\n            writer.writeVInt(arc.numArcs);\n            writer.writeVInt(bytesPerArc);\n            //System.out.println(\"node \" + node + \": \" + arc.numArcs + \" arcs\");\n          }\n\n          int maxBytesPerArc = 0;\n          //int wasted = 0;\n          while(true) {  // iterate over all arcs for this node\n\n            //System.out.println(\"    arc label=\" + arc.label + \" target=\" + arc.target + \" pos=\" + writer.posWrite);\n            final int arcStartPos = writer.posWrite;\n            nodeArcCount++;\n\n            byte flags = 0;\n\n            if (arc.isLast()) {\n              flags += BIT_LAST_ARC;\n            }\n            /*\n            if (!useArcArray && nodeUpto < nodes.length-1 && arc.target == nodes[nodeUpto+1]) {\n              flags += BIT_TARGET_NEXT;\n            }\n            */\n            if (!useArcArray && node != 1 && arc.target == node-1) {\n              flags += BIT_TARGET_NEXT;\n              if (!retry) {\n                nextCount++;\n              }\n            }\n            if (arc.isFinal()) {\n              flags += BIT_FINAL_ARC;\n              if (arc.nextFinalOutput != NO_OUTPUT) {\n                flags += BIT_ARC_HAS_FINAL_OUTPUT;\n              }\n            } else {\n              assert arc.nextFinalOutput == NO_OUTPUT;\n            }\n            if (!targetHasArcs(arc)) {\n              flags += BIT_STOP_NODE;\n            }\n\n            if (arc.output != NO_OUTPUT) {\n              flags += BIT_ARC_HAS_OUTPUT;\n            }\n\n            final Integer ptr;\n            final int absPtr;\n            final boolean doWriteTarget = targetHasArcs(arc) && (flags & BIT_TARGET_NEXT) == 0;\n            if (doWriteTarget) {\n\n              ptr = topNodeMap.get(arc.target);\n              if (ptr != null) {\n                absPtr = ptr;\n              } else {\n                absPtr = topNodeMap.size() + (int) newNodeAddress.get(arc.target) + addressError;\n              }\n\n              int delta = (int) newNodeAddress.get(arc.target) + addressError - writer.posWrite - 2;\n              if (delta < 0) {\n                //System.out.println(\"neg: \" + delta);\n                anyNegDelta = true;\n                delta = 0;\n              }\n\n              if (delta < absPtr) {\n                flags |= BIT_TARGET_DELTA;\n              }\n            } else {\n              ptr = null;\n              absPtr = 0;\n            }\n\n            writer.writeByte(flags);\n            fst.writeLabel(arc.label);\n\n            if (arc.output != NO_OUTPUT) {\n              outputs.write(arc.output, writer);\n              if (!retry) {\n                fst.arcWithOutputCount++;\n              }\n            }\n            if (arc.nextFinalOutput != NO_OUTPUT) {\n              outputs.write(arc.nextFinalOutput, writer);\n            }\n\n            if (doWriteTarget) {\n\n              int delta = (int) newNodeAddress.get(arc.target) + addressError - writer.posWrite;\n              if (delta < 0) {\n                anyNegDelta = true;\n                //System.out.println(\"neg: \" + delta);\n                delta = 0;\n              }\n\n              if (flag(flags, BIT_TARGET_DELTA)) {\n                //System.out.println(\"        delta\");\n                writer.writeVInt(delta);\n                if (!retry) {\n                  deltaCount++;\n                }\n              } else {\n                /*\n                if (ptr != null) {\n                  System.out.println(\"        deref\");\n                } else {\n                  System.out.println(\"        abs\");\n                }\n                */\n                writer.writeVInt(absPtr);\n                if (!retry) {\n                  if (absPtr >= topNodeMap.size()) {\n                    absCount++;\n                  } else {\n                    topCount++;\n                  }\n                }\n              }\n            }\n\n            if (useArcArray) {\n              final int arcBytes = writer.posWrite - arcStartPos;\n              //System.out.println(\"  \" + arcBytes + \" bytes\");\n              maxBytesPerArc = Math.max(maxBytesPerArc, arcBytes);\n              // NOTE: this may in fact go \"backwards\", if\n              // somehow (rarely, possibly never) we use\n              // more bytesPerArc in this rewrite than the\n              // incoming FST did... but in this case we\n              // will retry (below) so it's OK to ovewrite\n              // bytes:\n              //wasted += bytesPerArc - arcBytes;\n              writer.setPosWrite(arcStartPos + bytesPerArc);\n            }\n\n            if (arc.isLast()) {\n              break;\n            }\n\n            readNextRealArc(arc, r);\n          }\n\n          if (useArcArray) {\n            if (maxBytesPerArc == bytesPerArc || (retry && maxBytesPerArc <= bytesPerArc)) {\n              // converged\n              //System.out.println(\"  bba=\" + bytesPerArc + \" wasted=\" + wasted);\n              //totWasted += wasted;\n              break;\n            }\n          } else {\n            break;\n          }\n\n          //System.out.println(\"  retry this node maxBytesPerArc=\" + maxBytesPerArc + \" vs \" + bytesPerArc);\n\n          // Retry:\n          bytesPerArc = maxBytesPerArc;\n          writer.posWrite = address;\n          nodeArcCount = 0;\n          retry = true;\n          anyNegDelta = false;\n        }\n        negDelta |= anyNegDelta;\n\n        fst.arcCount += nodeArcCount;\n      }\n\n      if (!changed) {\n        // We don't renumber the nodes (just reverse their\n        // order) so nodes should only point forward to\n        // other nodes because we only produce acyclic FSTs\n        // w/ nodes only pointing \"forwards\":\n        assert !negDelta;\n        //System.out.println(\"TOT wasted=\" + totWasted);\n        // Converged!\n        break;\n      }\n      //System.out.println(\"  \" + changedCount + \" of \" + fst.nodeCount + \" changed; retry\");\n    }\n\n    long maxAddress = 0;\n    for (int key : topNodeMap.keySet()) {\n      maxAddress = Math.max(maxAddress, newNodeAddress.get(key));\n    }\n\n    PackedInts.Mutable nodeRefToAddressIn = PackedInts.getMutable(topNodeMap.size(),\n        PackedInts.bitsRequired(maxAddress), acceptableOverheadRatio);\n    for(Map.Entry<Integer,Integer> ent : topNodeMap.entrySet()) {\n      nodeRefToAddressIn.set(ent.getValue(), newNodeAddress.get(ent.getKey()));\n    }\n    fst.nodeRefToAddress = nodeRefToAddressIn;\n    \n\n    fst.startNode = (int) newNodeAddress.get(startNode);\n    //System.out.println(\"new startNode=\" + fst.startNode + \" old startNode=\" + startNode);\n\n    if (emptyOutput != null) {\n      fst.setEmptyOutput(emptyOutput);\n    }\n\n    assert fst.nodeCount == nodeCount: \"fst.nodeCount=\" + fst.nodeCount + \" nodeCount=\" + nodeCount;\n    assert fst.arcCount == arcCount;\n    assert fst.arcWithOutputCount == arcWithOutputCount: \"fst.arcWithOutputCount=\" + fst.arcWithOutputCount + \" arcWithOutputCount=\" + arcWithOutputCount;\n    \n    final byte[] finalBytes = new byte[writer.posWrite];\n    //System.out.println(\"resize \" + fst.bytes.length + \" down to \" + writer.posWrite);\n    System.arraycopy(fst.bytes, 0, finalBytes, 0, writer.posWrite);\n    fst.bytes = finalBytes;\n    fst.cacheRootArcs();\n\n    //final int size = fst.sizeInBytes();\n    //System.out.println(\"nextCount=\" + nextCount + \" topCount=\" + topCount + \" deltaCount=\" + deltaCount + \" absCount=\" + absCount);\n\n    return fst;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5ebe14aae60589c9bb6423f3cce02d5f599e1540","date":1348361556,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#pack(int,int,float).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#pack(int,int,float).mjava","sourceNew":"  /** Expert: creates an FST by packing this one.  This\n   *  process requires substantial additional RAM (currently\n   *  up to ~8 bytes per node depending on\n   *  <code>acceptableOverheadRatio</code>), but then should\n   *  produce a smaller FST.\n   *\n   *  <p>The implementation of this method uses ideas from\n   *  <a target=\"_blank\" href=\"http://www.cs.put.poznan.pl/dweiss/site/publications/download/fsacomp.pdf\">Smaller Representation of Finite State Automata</a>,\n   *  which describes techniques to reduce the size of a FST.\n   *  However, this is not a strict implementation of the\n   *  algorithms described in this paper.\n   */\n  public FST<T> pack(int minInCountDeref, int maxDerefNodes, float acceptableOverheadRatio) throws IOException {\n\n    // TODO: other things to try\n    //   - renumber the nodes to get more next / better locality?\n    //   - allow multiple input labels on an arc, so\n    //     singular chain of inputs can take one arc (on\n    //     wikipedia terms this could save another ~6%)\n    //   - in the ord case, the output '1' is presumably\n    //     very common (after NO_OUTPUT)... maybe use a bit\n    //     for it..?\n    //   - use spare bits in flags.... for top few labels /\n    //     outputs / targets\n\n    if (nodeAddress == null) {\n      throw new IllegalArgumentException(\"this FST was not built with willPackFST=true\");\n    }\n\n    Arc<T> arc = new Arc<T>();\n\n    final BytesReader r = getBytesReader(0);\n\n    final int topN = Math.min(maxDerefNodes, inCounts.size());\n\n    // Find top nodes with highest number of incoming arcs:\n    NodeQueue q = new NodeQueue(topN);\n\n    // TODO: we could use more RAM efficient selection algo here...\n    NodeAndInCount bottom = null;\n    for(int node=0; node<inCounts.size(); node++) {\n      if (inCounts.get(node) >= minInCountDeref) {\n        if (bottom == null) {\n          q.add(new NodeAndInCount(node, (int) inCounts.get(node)));\n          if (q.size() == topN) {\n            bottom = q.top();\n          }\n        } else if (inCounts.get(node) > bottom.count) {\n          q.insertWithOverflow(new NodeAndInCount(node, (int) inCounts.get(node)));\n        }\n      }\n    }\n\n    // Free up RAM:\n    inCounts = null;\n\n    final Map<Integer,Integer> topNodeMap = new HashMap<Integer,Integer>();\n    for(int downTo=q.size()-1;downTo>=0;downTo--) {\n      NodeAndInCount n = q.pop();\n      topNodeMap.put(n.node, downTo);\n      //System.out.println(\"map node=\" + n.node + \" inCount=\" + n.count + \" to newID=\" + downTo);\n    }\n\n    final FST<T> fst = new FST<T>(inputType, null, outputs);\n\n    final BytesWriter writer = fst.writer;\n\n    // +1 because node ords start at 1 (0 is reserved as stop node):\n    final GrowableWriter newNodeAddress = new GrowableWriter(\n        PackedInts.bitsRequired(bytes.length), 1 + nodeCount, acceptableOverheadRatio);\n\n    // Fill initial coarse guess:\n    for(int node=1;node<=nodeCount;node++) {\n      newNodeAddress.set(node, 1 + bytes.length - nodeAddress.get(node));\n    }\n\n    int absCount;\n    int deltaCount;\n    int topCount;\n    int nextCount;\n\n    // Iterate until we converge:\n    while(true) {\n\n      //System.out.println(\"\\nITER\");\n      boolean changed = false;\n\n      // for assert:\n      boolean negDelta = false;\n\n      writer.posWrite = 0;\n      // Skip 0 byte since 0 is reserved target:\n      writer.writeByte((byte) 0);\n\n      fst.arcWithOutputCount = 0;\n      fst.nodeCount = 0;\n      fst.arcCount = 0;\n\n      absCount = deltaCount = topCount = nextCount = 0;\n\n      int changedCount = 0;\n\n      int addressError = 0;\n\n      //int totWasted = 0;\n\n      // Since we re-reverse the bytes, we now write the\n      // nodes backwards, so that BIT_TARGET_NEXT is\n      // unchanged:\n      for(int node=nodeCount;node>=1;node--) {\n        fst.nodeCount++;\n        final int address = writer.posWrite;\n        //System.out.println(\"  node: \" + node + \" address=\" + address);\n        if (address != newNodeAddress.get(node)) {\n          addressError = address - (int) newNodeAddress.get(node);\n          //System.out.println(\"    change: \" + (address - newNodeAddress[node]));\n          changed = true;\n          newNodeAddress.set(node, address);\n          changedCount++;\n        }\n\n        int nodeArcCount = 0;\n        int bytesPerArc = 0;\n\n        boolean retry = false;\n\n        // for assert:\n        boolean anyNegDelta = false;\n\n        // Retry loop: possibly iterate more than once, if\n        // this is an array'd node and bytesPerArc changes:\n        writeNode:\n        while(true) { // retry writing this node\n\n          readFirstRealTargetArc(node, arc, r);\n\n          final boolean useArcArray = arc.bytesPerArc != 0;\n          if (useArcArray) {\n            // Write false first arc:\n            if (bytesPerArc == 0) {\n              bytesPerArc = arc.bytesPerArc;\n            }\n            writer.writeByte(ARCS_AS_FIXED_ARRAY);\n            writer.writeVInt(arc.numArcs);\n            writer.writeVInt(bytesPerArc);\n            //System.out.println(\"node \" + node + \": \" + arc.numArcs + \" arcs\");\n          }\n\n          int maxBytesPerArc = 0;\n          //int wasted = 0;\n          while(true) {  // iterate over all arcs for this node\n\n            //System.out.println(\"    arc label=\" + arc.label + \" target=\" + arc.target + \" pos=\" + writer.posWrite);\n            final int arcStartPos = writer.posWrite;\n            nodeArcCount++;\n\n            byte flags = 0;\n\n            if (arc.isLast()) {\n              flags += BIT_LAST_ARC;\n            }\n            /*\n            if (!useArcArray && nodeUpto < nodes.length-1 && arc.target == nodes[nodeUpto+1]) {\n              flags += BIT_TARGET_NEXT;\n            }\n            */\n            if (!useArcArray && node != 1 && arc.target == node-1) {\n              flags += BIT_TARGET_NEXT;\n              if (!retry) {\n                nextCount++;\n              }\n            }\n            if (arc.isFinal()) {\n              flags += BIT_FINAL_ARC;\n              if (arc.nextFinalOutput != NO_OUTPUT) {\n                flags += BIT_ARC_HAS_FINAL_OUTPUT;\n              }\n            } else {\n              assert arc.nextFinalOutput == NO_OUTPUT;\n            }\n            if (!targetHasArcs(arc)) {\n              flags += BIT_STOP_NODE;\n            }\n\n            if (arc.output != NO_OUTPUT) {\n              flags += BIT_ARC_HAS_OUTPUT;\n            }\n\n            final Integer ptr;\n            final int absPtr;\n            final boolean doWriteTarget = targetHasArcs(arc) && (flags & BIT_TARGET_NEXT) == 0;\n            if (doWriteTarget) {\n\n              ptr = topNodeMap.get(arc.target);\n              if (ptr != null) {\n                absPtr = ptr;\n              } else {\n                absPtr = topNodeMap.size() + (int) newNodeAddress.get(arc.target) + addressError;\n              }\n\n              int delta = (int) newNodeAddress.get(arc.target) + addressError - writer.posWrite - 2;\n              if (delta < 0) {\n                //System.out.println(\"neg: \" + delta);\n                anyNegDelta = true;\n                delta = 0;\n              }\n\n              if (delta < absPtr) {\n                flags |= BIT_TARGET_DELTA;\n              }\n            } else {\n              ptr = null;\n              absPtr = 0;\n            }\n\n            writer.writeByte(flags);\n            fst.writeLabel(arc.label);\n\n            if (arc.output != NO_OUTPUT) {\n              outputs.write(arc.output, writer);\n              if (!retry) {\n                fst.arcWithOutputCount++;\n              }\n            }\n            if (arc.nextFinalOutput != NO_OUTPUT) {\n              outputs.writeFinalOutput(arc.nextFinalOutput, writer);\n            }\n\n            if (doWriteTarget) {\n\n              int delta = (int) newNodeAddress.get(arc.target) + addressError - writer.posWrite;\n              if (delta < 0) {\n                anyNegDelta = true;\n                //System.out.println(\"neg: \" + delta);\n                delta = 0;\n              }\n\n              if (flag(flags, BIT_TARGET_DELTA)) {\n                //System.out.println(\"        delta\");\n                writer.writeVInt(delta);\n                if (!retry) {\n                  deltaCount++;\n                }\n              } else {\n                /*\n                if (ptr != null) {\n                  System.out.println(\"        deref\");\n                } else {\n                  System.out.println(\"        abs\");\n                }\n                */\n                writer.writeVInt(absPtr);\n                if (!retry) {\n                  if (absPtr >= topNodeMap.size()) {\n                    absCount++;\n                  } else {\n                    topCount++;\n                  }\n                }\n              }\n            }\n\n            if (useArcArray) {\n              final int arcBytes = writer.posWrite - arcStartPos;\n              //System.out.println(\"  \" + arcBytes + \" bytes\");\n              maxBytesPerArc = Math.max(maxBytesPerArc, arcBytes);\n              // NOTE: this may in fact go \"backwards\", if\n              // somehow (rarely, possibly never) we use\n              // more bytesPerArc in this rewrite than the\n              // incoming FST did... but in this case we\n              // will retry (below) so it's OK to ovewrite\n              // bytes:\n              //wasted += bytesPerArc - arcBytes;\n              writer.setPosWrite(arcStartPos + bytesPerArc);\n            }\n\n            if (arc.isLast()) {\n              break;\n            }\n\n            readNextRealArc(arc, r);\n          }\n\n          if (useArcArray) {\n            if (maxBytesPerArc == bytesPerArc || (retry && maxBytesPerArc <= bytesPerArc)) {\n              // converged\n              //System.out.println(\"  bba=\" + bytesPerArc + \" wasted=\" + wasted);\n              //totWasted += wasted;\n              break;\n            }\n          } else {\n            break;\n          }\n\n          //System.out.println(\"  retry this node maxBytesPerArc=\" + maxBytesPerArc + \" vs \" + bytesPerArc);\n\n          // Retry:\n          bytesPerArc = maxBytesPerArc;\n          writer.posWrite = address;\n          nodeArcCount = 0;\n          retry = true;\n          anyNegDelta = false;\n        }\n        negDelta |= anyNegDelta;\n\n        fst.arcCount += nodeArcCount;\n      }\n\n      if (!changed) {\n        // We don't renumber the nodes (just reverse their\n        // order) so nodes should only point forward to\n        // other nodes because we only produce acyclic FSTs\n        // w/ nodes only pointing \"forwards\":\n        assert !negDelta;\n        //System.out.println(\"TOT wasted=\" + totWasted);\n        // Converged!\n        break;\n      }\n      //System.out.println(\"  \" + changedCount + \" of \" + fst.nodeCount + \" changed; retry\");\n    }\n\n    long maxAddress = 0;\n    for (int key : topNodeMap.keySet()) {\n      maxAddress = Math.max(maxAddress, newNodeAddress.get(key));\n    }\n\n    PackedInts.Mutable nodeRefToAddressIn = PackedInts.getMutable(topNodeMap.size(),\n        PackedInts.bitsRequired(maxAddress), acceptableOverheadRatio);\n    for(Map.Entry<Integer,Integer> ent : topNodeMap.entrySet()) {\n      nodeRefToAddressIn.set(ent.getValue(), newNodeAddress.get(ent.getKey()));\n    }\n    fst.nodeRefToAddress = nodeRefToAddressIn;\n    \n\n    fst.startNode = (int) newNodeAddress.get(startNode);\n    //System.out.println(\"new startNode=\" + fst.startNode + \" old startNode=\" + startNode);\n\n    if (emptyOutput != null) {\n      fst.setEmptyOutput(emptyOutput);\n    }\n\n    assert fst.nodeCount == nodeCount: \"fst.nodeCount=\" + fst.nodeCount + \" nodeCount=\" + nodeCount;\n    assert fst.arcCount == arcCount;\n    assert fst.arcWithOutputCount == arcWithOutputCount: \"fst.arcWithOutputCount=\" + fst.arcWithOutputCount + \" arcWithOutputCount=\" + arcWithOutputCount;\n    \n    final byte[] finalBytes = new byte[writer.posWrite];\n    //System.out.println(\"resize \" + fst.bytes.length + \" down to \" + writer.posWrite);\n    System.arraycopy(fst.bytes, 0, finalBytes, 0, writer.posWrite);\n    fst.bytes = finalBytes;\n    fst.cacheRootArcs();\n\n    //final int size = fst.sizeInBytes();\n    //System.out.println(\"nextCount=\" + nextCount + \" topCount=\" + topCount + \" deltaCount=\" + deltaCount + \" absCount=\" + absCount);\n\n    return fst;\n  }\n\n","sourceOld":"  /** Expert: creates an FST by packing this one.  This\n   *  process requires substantial additional RAM (currently\n   *  up to ~8 bytes per node depending on\n   *  <code>acceptableOverheadRatio</code>), but then should\n   *  produce a smaller FST.\n   *\n   *  <p>The implementation of this method uses ideas from\n   *  <a target=\"_blank\" href=\"http://www.cs.put.poznan.pl/dweiss/site/publications/download/fsacomp.pdf\">Smaller Representation of Finite State Automata</a>,\n   *  which describes techniques to reduce the size of a FST.\n   *  However, this is not a strict implementation of the\n   *  algorithms described in this paper.\n   */\n  public FST<T> pack(int minInCountDeref, int maxDerefNodes, float acceptableOverheadRatio) throws IOException {\n\n    // TODO: other things to try\n    //   - renumber the nodes to get more next / better locality?\n    //   - allow multiple input labels on an arc, so\n    //     singular chain of inputs can take one arc (on\n    //     wikipedia terms this could save another ~6%)\n    //   - in the ord case, the output '1' is presumably\n    //     very common (after NO_OUTPUT)... maybe use a bit\n    //     for it..?\n    //   - use spare bits in flags.... for top few labels /\n    //     outputs / targets\n\n    if (nodeAddress == null) {\n      throw new IllegalArgumentException(\"this FST was not built with willPackFST=true\");\n    }\n\n    Arc<T> arc = new Arc<T>();\n\n    final BytesReader r = getBytesReader(0);\n\n    final int topN = Math.min(maxDerefNodes, inCounts.size());\n\n    // Find top nodes with highest number of incoming arcs:\n    NodeQueue q = new NodeQueue(topN);\n\n    // TODO: we could use more RAM efficient selection algo here...\n    NodeAndInCount bottom = null;\n    for(int node=0; node<inCounts.size(); node++) {\n      if (inCounts.get(node) >= minInCountDeref) {\n        if (bottom == null) {\n          q.add(new NodeAndInCount(node, (int) inCounts.get(node)));\n          if (q.size() == topN) {\n            bottom = q.top();\n          }\n        } else if (inCounts.get(node) > bottom.count) {\n          q.insertWithOverflow(new NodeAndInCount(node, (int) inCounts.get(node)));\n        }\n      }\n    }\n\n    // Free up RAM:\n    inCounts = null;\n\n    final Map<Integer,Integer> topNodeMap = new HashMap<Integer,Integer>();\n    for(int downTo=q.size()-1;downTo>=0;downTo--) {\n      NodeAndInCount n = q.pop();\n      topNodeMap.put(n.node, downTo);\n      //System.out.println(\"map node=\" + n.node + \" inCount=\" + n.count + \" to newID=\" + downTo);\n    }\n\n    final FST<T> fst = new FST<T>(inputType, null, outputs);\n\n    final BytesWriter writer = fst.writer;\n\n    // +1 because node ords start at 1 (0 is reserved as stop node):\n    final GrowableWriter newNodeAddress = new GrowableWriter(\n        PackedInts.bitsRequired(bytes.length), 1 + nodeCount, acceptableOverheadRatio);\n\n    // Fill initial coarse guess:\n    for(int node=1;node<=nodeCount;node++) {\n      newNodeAddress.set(node, 1 + bytes.length - nodeAddress.get(node));\n    }\n\n    int absCount;\n    int deltaCount;\n    int topCount;\n    int nextCount;\n\n    // Iterate until we converge:\n    while(true) {\n\n      //System.out.println(\"\\nITER\");\n      boolean changed = false;\n\n      // for assert:\n      boolean negDelta = false;\n\n      writer.posWrite = 0;\n      // Skip 0 byte since 0 is reserved target:\n      writer.writeByte((byte) 0);\n\n      fst.arcWithOutputCount = 0;\n      fst.nodeCount = 0;\n      fst.arcCount = 0;\n\n      absCount = deltaCount = topCount = nextCount = 0;\n\n      int changedCount = 0;\n\n      int addressError = 0;\n\n      //int totWasted = 0;\n\n      // Since we re-reverse the bytes, we now write the\n      // nodes backwards, so that BIT_TARGET_NEXT is\n      // unchanged:\n      for(int node=nodeCount;node>=1;node--) {\n        fst.nodeCount++;\n        final int address = writer.posWrite;\n        //System.out.println(\"  node: \" + node + \" address=\" + address);\n        if (address != newNodeAddress.get(node)) {\n          addressError = address - (int) newNodeAddress.get(node);\n          //System.out.println(\"    change: \" + (address - newNodeAddress[node]));\n          changed = true;\n          newNodeAddress.set(node, address);\n          changedCount++;\n        }\n\n        int nodeArcCount = 0;\n        int bytesPerArc = 0;\n\n        boolean retry = false;\n\n        // for assert:\n        boolean anyNegDelta = false;\n\n        // Retry loop: possibly iterate more than once, if\n        // this is an array'd node and bytesPerArc changes:\n        writeNode:\n        while(true) { // retry writing this node\n\n          readFirstRealTargetArc(node, arc, r);\n\n          final boolean useArcArray = arc.bytesPerArc != 0;\n          if (useArcArray) {\n            // Write false first arc:\n            if (bytesPerArc == 0) {\n              bytesPerArc = arc.bytesPerArc;\n            }\n            writer.writeByte(ARCS_AS_FIXED_ARRAY);\n            writer.writeVInt(arc.numArcs);\n            writer.writeVInt(bytesPerArc);\n            //System.out.println(\"node \" + node + \": \" + arc.numArcs + \" arcs\");\n          }\n\n          int maxBytesPerArc = 0;\n          //int wasted = 0;\n          while(true) {  // iterate over all arcs for this node\n\n            //System.out.println(\"    arc label=\" + arc.label + \" target=\" + arc.target + \" pos=\" + writer.posWrite);\n            final int arcStartPos = writer.posWrite;\n            nodeArcCount++;\n\n            byte flags = 0;\n\n            if (arc.isLast()) {\n              flags += BIT_LAST_ARC;\n            }\n            /*\n            if (!useArcArray && nodeUpto < nodes.length-1 && arc.target == nodes[nodeUpto+1]) {\n              flags += BIT_TARGET_NEXT;\n            }\n            */\n            if (!useArcArray && node != 1 && arc.target == node-1) {\n              flags += BIT_TARGET_NEXT;\n              if (!retry) {\n                nextCount++;\n              }\n            }\n            if (arc.isFinal()) {\n              flags += BIT_FINAL_ARC;\n              if (arc.nextFinalOutput != NO_OUTPUT) {\n                flags += BIT_ARC_HAS_FINAL_OUTPUT;\n              }\n            } else {\n              assert arc.nextFinalOutput == NO_OUTPUT;\n            }\n            if (!targetHasArcs(arc)) {\n              flags += BIT_STOP_NODE;\n            }\n\n            if (arc.output != NO_OUTPUT) {\n              flags += BIT_ARC_HAS_OUTPUT;\n            }\n\n            final Integer ptr;\n            final int absPtr;\n            final boolean doWriteTarget = targetHasArcs(arc) && (flags & BIT_TARGET_NEXT) == 0;\n            if (doWriteTarget) {\n\n              ptr = topNodeMap.get(arc.target);\n              if (ptr != null) {\n                absPtr = ptr;\n              } else {\n                absPtr = topNodeMap.size() + (int) newNodeAddress.get(arc.target) + addressError;\n              }\n\n              int delta = (int) newNodeAddress.get(arc.target) + addressError - writer.posWrite - 2;\n              if (delta < 0) {\n                //System.out.println(\"neg: \" + delta);\n                anyNegDelta = true;\n                delta = 0;\n              }\n\n              if (delta < absPtr) {\n                flags |= BIT_TARGET_DELTA;\n              }\n            } else {\n              ptr = null;\n              absPtr = 0;\n            }\n\n            writer.writeByte(flags);\n            fst.writeLabel(arc.label);\n\n            if (arc.output != NO_OUTPUT) {\n              outputs.write(arc.output, writer);\n              if (!retry) {\n                fst.arcWithOutputCount++;\n              }\n            }\n            if (arc.nextFinalOutput != NO_OUTPUT) {\n              outputs.write(arc.nextFinalOutput, writer);\n            }\n\n            if (doWriteTarget) {\n\n              int delta = (int) newNodeAddress.get(arc.target) + addressError - writer.posWrite;\n              if (delta < 0) {\n                anyNegDelta = true;\n                //System.out.println(\"neg: \" + delta);\n                delta = 0;\n              }\n\n              if (flag(flags, BIT_TARGET_DELTA)) {\n                //System.out.println(\"        delta\");\n                writer.writeVInt(delta);\n                if (!retry) {\n                  deltaCount++;\n                }\n              } else {\n                /*\n                if (ptr != null) {\n                  System.out.println(\"        deref\");\n                } else {\n                  System.out.println(\"        abs\");\n                }\n                */\n                writer.writeVInt(absPtr);\n                if (!retry) {\n                  if (absPtr >= topNodeMap.size()) {\n                    absCount++;\n                  } else {\n                    topCount++;\n                  }\n                }\n              }\n            }\n\n            if (useArcArray) {\n              final int arcBytes = writer.posWrite - arcStartPos;\n              //System.out.println(\"  \" + arcBytes + \" bytes\");\n              maxBytesPerArc = Math.max(maxBytesPerArc, arcBytes);\n              // NOTE: this may in fact go \"backwards\", if\n              // somehow (rarely, possibly never) we use\n              // more bytesPerArc in this rewrite than the\n              // incoming FST did... but in this case we\n              // will retry (below) so it's OK to ovewrite\n              // bytes:\n              //wasted += bytesPerArc - arcBytes;\n              writer.setPosWrite(arcStartPos + bytesPerArc);\n            }\n\n            if (arc.isLast()) {\n              break;\n            }\n\n            readNextRealArc(arc, r);\n          }\n\n          if (useArcArray) {\n            if (maxBytesPerArc == bytesPerArc || (retry && maxBytesPerArc <= bytesPerArc)) {\n              // converged\n              //System.out.println(\"  bba=\" + bytesPerArc + \" wasted=\" + wasted);\n              //totWasted += wasted;\n              break;\n            }\n          } else {\n            break;\n          }\n\n          //System.out.println(\"  retry this node maxBytesPerArc=\" + maxBytesPerArc + \" vs \" + bytesPerArc);\n\n          // Retry:\n          bytesPerArc = maxBytesPerArc;\n          writer.posWrite = address;\n          nodeArcCount = 0;\n          retry = true;\n          anyNegDelta = false;\n        }\n        negDelta |= anyNegDelta;\n\n        fst.arcCount += nodeArcCount;\n      }\n\n      if (!changed) {\n        // We don't renumber the nodes (just reverse their\n        // order) so nodes should only point forward to\n        // other nodes because we only produce acyclic FSTs\n        // w/ nodes only pointing \"forwards\":\n        assert !negDelta;\n        //System.out.println(\"TOT wasted=\" + totWasted);\n        // Converged!\n        break;\n      }\n      //System.out.println(\"  \" + changedCount + \" of \" + fst.nodeCount + \" changed; retry\");\n    }\n\n    long maxAddress = 0;\n    for (int key : topNodeMap.keySet()) {\n      maxAddress = Math.max(maxAddress, newNodeAddress.get(key));\n    }\n\n    PackedInts.Mutable nodeRefToAddressIn = PackedInts.getMutable(topNodeMap.size(),\n        PackedInts.bitsRequired(maxAddress), acceptableOverheadRatio);\n    for(Map.Entry<Integer,Integer> ent : topNodeMap.entrySet()) {\n      nodeRefToAddressIn.set(ent.getValue(), newNodeAddress.get(ent.getKey()));\n    }\n    fst.nodeRefToAddress = nodeRefToAddressIn;\n    \n\n    fst.startNode = (int) newNodeAddress.get(startNode);\n    //System.out.println(\"new startNode=\" + fst.startNode + \" old startNode=\" + startNode);\n\n    if (emptyOutput != null) {\n      fst.setEmptyOutput(emptyOutput);\n    }\n\n    assert fst.nodeCount == nodeCount: \"fst.nodeCount=\" + fst.nodeCount + \" nodeCount=\" + nodeCount;\n    assert fst.arcCount == arcCount;\n    assert fst.arcWithOutputCount == arcWithOutputCount: \"fst.arcWithOutputCount=\" + fst.arcWithOutputCount + \" arcWithOutputCount=\" + arcWithOutputCount;\n    \n    final byte[] finalBytes = new byte[writer.posWrite];\n    //System.out.println(\"resize \" + fst.bytes.length + \" down to \" + writer.posWrite);\n    System.arraycopy(fst.bytes, 0, finalBytes, 0, writer.posWrite);\n    fst.bytes = finalBytes;\n    fst.cacheRootArcs();\n\n    //final int size = fst.sizeInBytes();\n    //System.out.println(\"nextCount=\" + nextCount + \" topCount=\" + topCount + \" deltaCount=\" + deltaCount + \" absCount=\" + absCount);\n\n    return fst;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cb27634f76319b68d6d8fd11a7104d20294722c5","date":1355210077,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#pack(int,int,float).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#pack(int,int,float).mjava","sourceNew":"  /** Expert: creates an FST by packing this one.  This\n   *  process requires substantial additional RAM (currently\n   *  up to ~8 bytes per node depending on\n   *  <code>acceptableOverheadRatio</code>), but then should\n   *  produce a smaller FST.\n   *\n   *  <p>The implementation of this method uses ideas from\n   *  <a target=\"_blank\" href=\"http://www.cs.put.poznan.pl/dweiss/site/publications/download/fsacomp.pdf\">Smaller Representation of Finite State Automata</a>,\n   *  which describes techniques to reduce the size of a FST.\n   *  However, this is not a strict implementation of the\n   *  algorithms described in this paper.\n   */\n  public FST<T> pack(int minInCountDeref, int maxDerefNodes, float acceptableOverheadRatio) throws IOException {\n\n    // TODO: other things to try\n    //   - renumber the nodes to get more next / better locality?\n    //   - allow multiple input labels on an arc, so\n    //     singular chain of inputs can take one arc (on\n    //     wikipedia terms this could save another ~6%)\n    //   - in the ord case, the output '1' is presumably\n    //     very common (after NO_OUTPUT)... maybe use a bit\n    //     for it..?\n    //   - use spare bits in flags.... for top few labels /\n    //     outputs / targets\n\n    if (nodeAddress == null) {\n      throw new IllegalArgumentException(\"this FST was not built with willPackFST=true\");\n    }\n\n    Arc<T> arc = new Arc<T>();\n\n    final BytesReader r = getBytesReader(0);\n\n    final int topN = Math.min(maxDerefNodes, inCounts.size());\n\n    // Find top nodes with highest number of incoming arcs:\n    NodeQueue q = new NodeQueue(topN);\n\n    // TODO: we could use more RAM efficient selection algo here...\n    NodeAndInCount bottom = null;\n    for(int node=0; node<inCounts.size(); node++) {\n      if (inCounts.get(node) >= minInCountDeref) {\n        if (bottom == null) {\n          q.add(new NodeAndInCount(node, (int) inCounts.get(node)));\n          if (q.size() == topN) {\n            bottom = q.top();\n          }\n        } else if (inCounts.get(node) > bottom.count) {\n          q.insertWithOverflow(new NodeAndInCount(node, (int) inCounts.get(node)));\n        }\n      }\n    }\n\n    // Free up RAM:\n    inCounts = null;\n\n    final Map<Integer,Integer> topNodeMap = new HashMap<Integer,Integer>();\n    for(int downTo=q.size()-1;downTo>=0;downTo--) {\n      NodeAndInCount n = q.pop();\n      topNodeMap.put(n.node, downTo);\n      //System.out.println(\"map node=\" + n.node + \" inCount=\" + n.count + \" to newID=\" + downTo);\n    }\n\n    final FST<T> fst = new FST<T>(inputType, null, outputs);\n\n    final BytesWriter writer = fst.writer;\n\n    // +1 because node ords start at 1 (0 is reserved as stop node):\n    final GrowableWriter newNodeAddress = new GrowableWriter(\n        PackedInts.bitsRequired(bytes.length), 1 + nodeCount, acceptableOverheadRatio);\n\n    // Fill initial coarse guess:\n    for(int node=1;node<=nodeCount;node++) {\n      newNodeAddress.set(node, 1 + bytes.length - nodeAddress.get(node));\n    }\n\n    int absCount;\n    int deltaCount;\n    int topCount;\n    int nextCount;\n\n    // Iterate until we converge:\n    while(true) {\n\n      //System.out.println(\"\\nITER\");\n      boolean changed = false;\n\n      // for assert:\n      boolean negDelta = false;\n\n      writer.setPosition(0);\n      // Skip 0 byte since 0 is reserved target:\n      writer.writeByte((byte) 0);\n\n      fst.arcWithOutputCount = 0;\n      fst.nodeCount = 0;\n      fst.arcCount = 0;\n\n      absCount = deltaCount = topCount = nextCount = 0;\n\n      int changedCount = 0;\n\n      int addressError = 0;\n\n      //int totWasted = 0;\n\n      // Since we re-reverse the bytes, we now write the\n      // nodes backwards, so that BIT_TARGET_NEXT is\n      // unchanged:\n      for(int node=nodeCount;node>=1;node--) {\n        fst.nodeCount++;\n        final int address = writer.getPosition();\n        //System.out.println(\"  node: \" + node + \" address=\" + address);\n        if (address != newNodeAddress.get(node)) {\n          addressError = address - (int) newNodeAddress.get(node);\n          //System.out.println(\"    change: \" + (address - newNodeAddress[node]));\n          changed = true;\n          newNodeAddress.set(node, address);\n          changedCount++;\n        }\n\n        int nodeArcCount = 0;\n        int bytesPerArc = 0;\n\n        boolean retry = false;\n\n        // for assert:\n        boolean anyNegDelta = false;\n\n        // Retry loop: possibly iterate more than once, if\n        // this is an array'd node and bytesPerArc changes:\n        writeNode:\n        while(true) { // retry writing this node\n\n          readFirstRealTargetArc(node, arc, r);\n\n          final boolean useArcArray = arc.bytesPerArc != 0;\n          if (useArcArray) {\n            // Write false first arc:\n            if (bytesPerArc == 0) {\n              bytesPerArc = arc.bytesPerArc;\n            }\n            writer.writeByte(ARCS_AS_FIXED_ARRAY);\n            writer.writeVInt(arc.numArcs);\n            writer.writeVInt(bytesPerArc);\n            //System.out.println(\"node \" + node + \": \" + arc.numArcs + \" arcs\");\n          }\n\n          int maxBytesPerArc = 0;\n          //int wasted = 0;\n          while(true) {  // iterate over all arcs for this node\n\n            //System.out.println(\"    arc label=\" + arc.label + \" target=\" + arc.target + \" pos=\" + writer.posWrite);\n            final int arcStartPos = writer.getPosition();\n            nodeArcCount++;\n\n            byte flags = 0;\n\n            if (arc.isLast()) {\n              flags += BIT_LAST_ARC;\n            }\n            /*\n            if (!useArcArray && nodeUpto < nodes.length-1 && arc.target == nodes[nodeUpto+1]) {\n              flags += BIT_TARGET_NEXT;\n            }\n            */\n            if (!useArcArray && node != 1 && arc.target == node-1) {\n              flags += BIT_TARGET_NEXT;\n              if (!retry) {\n                nextCount++;\n              }\n            }\n            if (arc.isFinal()) {\n              flags += BIT_FINAL_ARC;\n              if (arc.nextFinalOutput != NO_OUTPUT) {\n                flags += BIT_ARC_HAS_FINAL_OUTPUT;\n              }\n            } else {\n              assert arc.nextFinalOutput == NO_OUTPUT;\n            }\n            if (!targetHasArcs(arc)) {\n              flags += BIT_STOP_NODE;\n            }\n\n            if (arc.output != NO_OUTPUT) {\n              flags += BIT_ARC_HAS_OUTPUT;\n            }\n\n            final Integer ptr;\n            final int absPtr;\n            final boolean doWriteTarget = targetHasArcs(arc) && (flags & BIT_TARGET_NEXT) == 0;\n            if (doWriteTarget) {\n\n              ptr = topNodeMap.get(arc.target);\n              if (ptr != null) {\n                absPtr = ptr;\n              } else {\n                absPtr = topNodeMap.size() + (int) newNodeAddress.get(arc.target) + addressError;\n              }\n\n              int delta = (int) newNodeAddress.get(arc.target) + addressError - writer.getPosition() - 2;\n              if (delta < 0) {\n                //System.out.println(\"neg: \" + delta);\n                anyNegDelta = true;\n                delta = 0;\n              }\n\n              if (delta < absPtr) {\n                flags |= BIT_TARGET_DELTA;\n              }\n            } else {\n              ptr = null;\n              absPtr = 0;\n            }\n\n            writer.writeByte(flags);\n            fst.writeLabel(arc.label);\n\n            if (arc.output != NO_OUTPUT) {\n              outputs.write(arc.output, writer);\n              if (!retry) {\n                fst.arcWithOutputCount++;\n              }\n            }\n            if (arc.nextFinalOutput != NO_OUTPUT) {\n              outputs.writeFinalOutput(arc.nextFinalOutput, writer);\n            }\n\n            if (doWriteTarget) {\n\n              int delta = (int) newNodeAddress.get(arc.target) + addressError - writer.getPosition();\n              if (delta < 0) {\n                anyNegDelta = true;\n                //System.out.println(\"neg: \" + delta);\n                delta = 0;\n              }\n\n              if (flag(flags, BIT_TARGET_DELTA)) {\n                //System.out.println(\"        delta\");\n                writer.writeVInt(delta);\n                if (!retry) {\n                  deltaCount++;\n                }\n              } else {\n                /*\n                if (ptr != null) {\n                  System.out.println(\"        deref\");\n                } else {\n                  System.out.println(\"        abs\");\n                }\n                */\n                writer.writeVInt(absPtr);\n                if (!retry) {\n                  if (absPtr >= topNodeMap.size()) {\n                    absCount++;\n                  } else {\n                    topCount++;\n                  }\n                }\n              }\n            }\n\n            if (useArcArray) {\n              final int arcBytes = writer.getPosition() - arcStartPos;\n              //System.out.println(\"  \" + arcBytes + \" bytes\");\n              maxBytesPerArc = Math.max(maxBytesPerArc, arcBytes);\n              // NOTE: this may in fact go \"backwards\", if\n              // somehow (rarely, possibly never) we use\n              // more bytesPerArc in this rewrite than the\n              // incoming FST did... but in this case we\n              // will retry (below) so it's OK to ovewrite\n              // bytes:\n              //wasted += bytesPerArc - arcBytes;\n              writer.setPosition(arcStartPos + bytesPerArc);\n            }\n\n            if (arc.isLast()) {\n              break;\n            }\n\n            readNextRealArc(arc, r);\n          }\n\n          if (useArcArray) {\n            if (maxBytesPerArc == bytesPerArc || (retry && maxBytesPerArc <= bytesPerArc)) {\n              // converged\n              //System.out.println(\"  bba=\" + bytesPerArc + \" wasted=\" + wasted);\n              //totWasted += wasted;\n              break;\n            }\n          } else {\n            break;\n          }\n\n          //System.out.println(\"  retry this node maxBytesPerArc=\" + maxBytesPerArc + \" vs \" + bytesPerArc);\n\n          // Retry:\n          bytesPerArc = maxBytesPerArc;\n          writer.setPosition(address);\n          nodeArcCount = 0;\n          retry = true;\n          anyNegDelta = false;\n        }\n        negDelta |= anyNegDelta;\n\n        fst.arcCount += nodeArcCount;\n      }\n\n      if (!changed) {\n        // We don't renumber the nodes (just reverse their\n        // order) so nodes should only point forward to\n        // other nodes because we only produce acyclic FSTs\n        // w/ nodes only pointing \"forwards\":\n        assert !negDelta;\n        //System.out.println(\"TOT wasted=\" + totWasted);\n        // Converged!\n        break;\n      }\n      //System.out.println(\"  \" + changedCount + \" of \" + fst.nodeCount + \" changed; retry\");\n    }\n\n    long maxAddress = 0;\n    for (int key : topNodeMap.keySet()) {\n      maxAddress = Math.max(maxAddress, newNodeAddress.get(key));\n    }\n\n    PackedInts.Mutable nodeRefToAddressIn = PackedInts.getMutable(topNodeMap.size(),\n        PackedInts.bitsRequired(maxAddress), acceptableOverheadRatio);\n    for(Map.Entry<Integer,Integer> ent : topNodeMap.entrySet()) {\n      nodeRefToAddressIn.set(ent.getValue(), newNodeAddress.get(ent.getKey()));\n    }\n    fst.nodeRefToAddress = nodeRefToAddressIn;\n    \n\n    fst.startNode = (int) newNodeAddress.get(startNode);\n    //System.out.println(\"new startNode=\" + fst.startNode + \" old startNode=\" + startNode);\n\n    if (emptyOutput != null) {\n      fst.setEmptyOutput(emptyOutput);\n    }\n\n    assert fst.nodeCount == nodeCount: \"fst.nodeCount=\" + fst.nodeCount + \" nodeCount=\" + nodeCount;\n    assert fst.arcCount == arcCount;\n    assert fst.arcWithOutputCount == arcWithOutputCount: \"fst.arcWithOutputCount=\" + fst.arcWithOutputCount + \" arcWithOutputCount=\" + arcWithOutputCount;\n    \n    final byte[] finalBytes = new byte[writer.getPosition()];\n    //System.out.println(\"resize \" + fst.bytes.length + \" down to \" + writer.posWrite);\n    System.arraycopy(fst.bytes, 0, finalBytes, 0, writer.getPosition());\n    fst.bytes = finalBytes;\n    fst.cacheRootArcs();\n\n    //final int size = fst.sizeInBytes();\n    //System.out.println(\"nextCount=\" + nextCount + \" topCount=\" + topCount + \" deltaCount=\" + deltaCount + \" absCount=\" + absCount);\n\n    return fst;\n  }\n\n","sourceOld":"  /** Expert: creates an FST by packing this one.  This\n   *  process requires substantial additional RAM (currently\n   *  up to ~8 bytes per node depending on\n   *  <code>acceptableOverheadRatio</code>), but then should\n   *  produce a smaller FST.\n   *\n   *  <p>The implementation of this method uses ideas from\n   *  <a target=\"_blank\" href=\"http://www.cs.put.poznan.pl/dweiss/site/publications/download/fsacomp.pdf\">Smaller Representation of Finite State Automata</a>,\n   *  which describes techniques to reduce the size of a FST.\n   *  However, this is not a strict implementation of the\n   *  algorithms described in this paper.\n   */\n  public FST<T> pack(int minInCountDeref, int maxDerefNodes, float acceptableOverheadRatio) throws IOException {\n\n    // TODO: other things to try\n    //   - renumber the nodes to get more next / better locality?\n    //   - allow multiple input labels on an arc, so\n    //     singular chain of inputs can take one arc (on\n    //     wikipedia terms this could save another ~6%)\n    //   - in the ord case, the output '1' is presumably\n    //     very common (after NO_OUTPUT)... maybe use a bit\n    //     for it..?\n    //   - use spare bits in flags.... for top few labels /\n    //     outputs / targets\n\n    if (nodeAddress == null) {\n      throw new IllegalArgumentException(\"this FST was not built with willPackFST=true\");\n    }\n\n    Arc<T> arc = new Arc<T>();\n\n    final BytesReader r = getBytesReader(0);\n\n    final int topN = Math.min(maxDerefNodes, inCounts.size());\n\n    // Find top nodes with highest number of incoming arcs:\n    NodeQueue q = new NodeQueue(topN);\n\n    // TODO: we could use more RAM efficient selection algo here...\n    NodeAndInCount bottom = null;\n    for(int node=0; node<inCounts.size(); node++) {\n      if (inCounts.get(node) >= minInCountDeref) {\n        if (bottom == null) {\n          q.add(new NodeAndInCount(node, (int) inCounts.get(node)));\n          if (q.size() == topN) {\n            bottom = q.top();\n          }\n        } else if (inCounts.get(node) > bottom.count) {\n          q.insertWithOverflow(new NodeAndInCount(node, (int) inCounts.get(node)));\n        }\n      }\n    }\n\n    // Free up RAM:\n    inCounts = null;\n\n    final Map<Integer,Integer> topNodeMap = new HashMap<Integer,Integer>();\n    for(int downTo=q.size()-1;downTo>=0;downTo--) {\n      NodeAndInCount n = q.pop();\n      topNodeMap.put(n.node, downTo);\n      //System.out.println(\"map node=\" + n.node + \" inCount=\" + n.count + \" to newID=\" + downTo);\n    }\n\n    final FST<T> fst = new FST<T>(inputType, null, outputs);\n\n    final BytesWriter writer = fst.writer;\n\n    // +1 because node ords start at 1 (0 is reserved as stop node):\n    final GrowableWriter newNodeAddress = new GrowableWriter(\n        PackedInts.bitsRequired(bytes.length), 1 + nodeCount, acceptableOverheadRatio);\n\n    // Fill initial coarse guess:\n    for(int node=1;node<=nodeCount;node++) {\n      newNodeAddress.set(node, 1 + bytes.length - nodeAddress.get(node));\n    }\n\n    int absCount;\n    int deltaCount;\n    int topCount;\n    int nextCount;\n\n    // Iterate until we converge:\n    while(true) {\n\n      //System.out.println(\"\\nITER\");\n      boolean changed = false;\n\n      // for assert:\n      boolean negDelta = false;\n\n      writer.posWrite = 0;\n      // Skip 0 byte since 0 is reserved target:\n      writer.writeByte((byte) 0);\n\n      fst.arcWithOutputCount = 0;\n      fst.nodeCount = 0;\n      fst.arcCount = 0;\n\n      absCount = deltaCount = topCount = nextCount = 0;\n\n      int changedCount = 0;\n\n      int addressError = 0;\n\n      //int totWasted = 0;\n\n      // Since we re-reverse the bytes, we now write the\n      // nodes backwards, so that BIT_TARGET_NEXT is\n      // unchanged:\n      for(int node=nodeCount;node>=1;node--) {\n        fst.nodeCount++;\n        final int address = writer.posWrite;\n        //System.out.println(\"  node: \" + node + \" address=\" + address);\n        if (address != newNodeAddress.get(node)) {\n          addressError = address - (int) newNodeAddress.get(node);\n          //System.out.println(\"    change: \" + (address - newNodeAddress[node]));\n          changed = true;\n          newNodeAddress.set(node, address);\n          changedCount++;\n        }\n\n        int nodeArcCount = 0;\n        int bytesPerArc = 0;\n\n        boolean retry = false;\n\n        // for assert:\n        boolean anyNegDelta = false;\n\n        // Retry loop: possibly iterate more than once, if\n        // this is an array'd node and bytesPerArc changes:\n        writeNode:\n        while(true) { // retry writing this node\n\n          readFirstRealTargetArc(node, arc, r);\n\n          final boolean useArcArray = arc.bytesPerArc != 0;\n          if (useArcArray) {\n            // Write false first arc:\n            if (bytesPerArc == 0) {\n              bytesPerArc = arc.bytesPerArc;\n            }\n            writer.writeByte(ARCS_AS_FIXED_ARRAY);\n            writer.writeVInt(arc.numArcs);\n            writer.writeVInt(bytesPerArc);\n            //System.out.println(\"node \" + node + \": \" + arc.numArcs + \" arcs\");\n          }\n\n          int maxBytesPerArc = 0;\n          //int wasted = 0;\n          while(true) {  // iterate over all arcs for this node\n\n            //System.out.println(\"    arc label=\" + arc.label + \" target=\" + arc.target + \" pos=\" + writer.posWrite);\n            final int arcStartPos = writer.posWrite;\n            nodeArcCount++;\n\n            byte flags = 0;\n\n            if (arc.isLast()) {\n              flags += BIT_LAST_ARC;\n            }\n            /*\n            if (!useArcArray && nodeUpto < nodes.length-1 && arc.target == nodes[nodeUpto+1]) {\n              flags += BIT_TARGET_NEXT;\n            }\n            */\n            if (!useArcArray && node != 1 && arc.target == node-1) {\n              flags += BIT_TARGET_NEXT;\n              if (!retry) {\n                nextCount++;\n              }\n            }\n            if (arc.isFinal()) {\n              flags += BIT_FINAL_ARC;\n              if (arc.nextFinalOutput != NO_OUTPUT) {\n                flags += BIT_ARC_HAS_FINAL_OUTPUT;\n              }\n            } else {\n              assert arc.nextFinalOutput == NO_OUTPUT;\n            }\n            if (!targetHasArcs(arc)) {\n              flags += BIT_STOP_NODE;\n            }\n\n            if (arc.output != NO_OUTPUT) {\n              flags += BIT_ARC_HAS_OUTPUT;\n            }\n\n            final Integer ptr;\n            final int absPtr;\n            final boolean doWriteTarget = targetHasArcs(arc) && (flags & BIT_TARGET_NEXT) == 0;\n            if (doWriteTarget) {\n\n              ptr = topNodeMap.get(arc.target);\n              if (ptr != null) {\n                absPtr = ptr;\n              } else {\n                absPtr = topNodeMap.size() + (int) newNodeAddress.get(arc.target) + addressError;\n              }\n\n              int delta = (int) newNodeAddress.get(arc.target) + addressError - writer.posWrite - 2;\n              if (delta < 0) {\n                //System.out.println(\"neg: \" + delta);\n                anyNegDelta = true;\n                delta = 0;\n              }\n\n              if (delta < absPtr) {\n                flags |= BIT_TARGET_DELTA;\n              }\n            } else {\n              ptr = null;\n              absPtr = 0;\n            }\n\n            writer.writeByte(flags);\n            fst.writeLabel(arc.label);\n\n            if (arc.output != NO_OUTPUT) {\n              outputs.write(arc.output, writer);\n              if (!retry) {\n                fst.arcWithOutputCount++;\n              }\n            }\n            if (arc.nextFinalOutput != NO_OUTPUT) {\n              outputs.writeFinalOutput(arc.nextFinalOutput, writer);\n            }\n\n            if (doWriteTarget) {\n\n              int delta = (int) newNodeAddress.get(arc.target) + addressError - writer.posWrite;\n              if (delta < 0) {\n                anyNegDelta = true;\n                //System.out.println(\"neg: \" + delta);\n                delta = 0;\n              }\n\n              if (flag(flags, BIT_TARGET_DELTA)) {\n                //System.out.println(\"        delta\");\n                writer.writeVInt(delta);\n                if (!retry) {\n                  deltaCount++;\n                }\n              } else {\n                /*\n                if (ptr != null) {\n                  System.out.println(\"        deref\");\n                } else {\n                  System.out.println(\"        abs\");\n                }\n                */\n                writer.writeVInt(absPtr);\n                if (!retry) {\n                  if (absPtr >= topNodeMap.size()) {\n                    absCount++;\n                  } else {\n                    topCount++;\n                  }\n                }\n              }\n            }\n\n            if (useArcArray) {\n              final int arcBytes = writer.posWrite - arcStartPos;\n              //System.out.println(\"  \" + arcBytes + \" bytes\");\n              maxBytesPerArc = Math.max(maxBytesPerArc, arcBytes);\n              // NOTE: this may in fact go \"backwards\", if\n              // somehow (rarely, possibly never) we use\n              // more bytesPerArc in this rewrite than the\n              // incoming FST did... but in this case we\n              // will retry (below) so it's OK to ovewrite\n              // bytes:\n              //wasted += bytesPerArc - arcBytes;\n              writer.setPosWrite(arcStartPos + bytesPerArc);\n            }\n\n            if (arc.isLast()) {\n              break;\n            }\n\n            readNextRealArc(arc, r);\n          }\n\n          if (useArcArray) {\n            if (maxBytesPerArc == bytesPerArc || (retry && maxBytesPerArc <= bytesPerArc)) {\n              // converged\n              //System.out.println(\"  bba=\" + bytesPerArc + \" wasted=\" + wasted);\n              //totWasted += wasted;\n              break;\n            }\n          } else {\n            break;\n          }\n\n          //System.out.println(\"  retry this node maxBytesPerArc=\" + maxBytesPerArc + \" vs \" + bytesPerArc);\n\n          // Retry:\n          bytesPerArc = maxBytesPerArc;\n          writer.posWrite = address;\n          nodeArcCount = 0;\n          retry = true;\n          anyNegDelta = false;\n        }\n        negDelta |= anyNegDelta;\n\n        fst.arcCount += nodeArcCount;\n      }\n\n      if (!changed) {\n        // We don't renumber the nodes (just reverse their\n        // order) so nodes should only point forward to\n        // other nodes because we only produce acyclic FSTs\n        // w/ nodes only pointing \"forwards\":\n        assert !negDelta;\n        //System.out.println(\"TOT wasted=\" + totWasted);\n        // Converged!\n        break;\n      }\n      //System.out.println(\"  \" + changedCount + \" of \" + fst.nodeCount + \" changed; retry\");\n    }\n\n    long maxAddress = 0;\n    for (int key : topNodeMap.keySet()) {\n      maxAddress = Math.max(maxAddress, newNodeAddress.get(key));\n    }\n\n    PackedInts.Mutable nodeRefToAddressIn = PackedInts.getMutable(topNodeMap.size(),\n        PackedInts.bitsRequired(maxAddress), acceptableOverheadRatio);\n    for(Map.Entry<Integer,Integer> ent : topNodeMap.entrySet()) {\n      nodeRefToAddressIn.set(ent.getValue(), newNodeAddress.get(ent.getKey()));\n    }\n    fst.nodeRefToAddress = nodeRefToAddressIn;\n    \n\n    fst.startNode = (int) newNodeAddress.get(startNode);\n    //System.out.println(\"new startNode=\" + fst.startNode + \" old startNode=\" + startNode);\n\n    if (emptyOutput != null) {\n      fst.setEmptyOutput(emptyOutput);\n    }\n\n    assert fst.nodeCount == nodeCount: \"fst.nodeCount=\" + fst.nodeCount + \" nodeCount=\" + nodeCount;\n    assert fst.arcCount == arcCount;\n    assert fst.arcWithOutputCount == arcWithOutputCount: \"fst.arcWithOutputCount=\" + fst.arcWithOutputCount + \" arcWithOutputCount=\" + arcWithOutputCount;\n    \n    final byte[] finalBytes = new byte[writer.posWrite];\n    //System.out.println(\"resize \" + fst.bytes.length + \" down to \" + writer.posWrite);\n    System.arraycopy(fst.bytes, 0, finalBytes, 0, writer.posWrite);\n    fst.bytes = finalBytes;\n    fst.cacheRootArcs();\n\n    //final int size = fst.sizeInBytes();\n    //System.out.println(\"nextCount=\" + nextCount + \" topCount=\" + topCount + \" deltaCount=\" + deltaCount + \" absCount=\" + absCount);\n\n    return fst;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"49f4d9c4e29f2345e789073801e7945431a23ca3","date":1355344131,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#pack(int,int,float).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#pack(int,int,float).mjava","sourceNew":"  /** Expert: creates an FST by packing this one.  This\n   *  process requires substantial additional RAM (currently\n   *  up to ~8 bytes per node depending on\n   *  <code>acceptableOverheadRatio</code>), but then should\n   *  produce a smaller FST.\n   *\n   *  <p>The implementation of this method uses ideas from\n   *  <a target=\"_blank\" href=\"http://www.cs.put.poznan.pl/dweiss/site/publications/download/fsacomp.pdf\">Smaller Representation of Finite State Automata</a>,\n   *  which describes techniques to reduce the size of a FST.\n   *  However, this is not a strict implementation of the\n   *  algorithms described in this paper.\n   */\n  FST<T> pack(int minInCountDeref, int maxDerefNodes, float acceptableOverheadRatio) throws IOException {\n\n    // TODO: other things to try\n    //   - renumber the nodes to get more next / better locality?\n    //   - allow multiple input labels on an arc, so\n    //     singular chain of inputs can take one arc (on\n    //     wikipedia terms this could save another ~6%)\n    //   - in the ord case, the output '1' is presumably\n    //     very common (after NO_OUTPUT)... maybe use a bit\n    //     for it..?\n    //   - use spare bits in flags.... for top few labels /\n    //     outputs / targets\n\n    if (nodeAddress == null) {\n      throw new IllegalArgumentException(\"this FST was not built with willPackFST=true\");\n    }\n\n    Arc<T> arc = new Arc<T>();\n\n    final BytesReader r = getBytesReader(0);\n\n    final int topN = Math.min(maxDerefNodes, inCounts.size());\n\n    // Find top nodes with highest number of incoming arcs:\n    NodeQueue q = new NodeQueue(topN);\n\n    // TODO: we could use more RAM efficient selection algo here...\n    NodeAndInCount bottom = null;\n    for(int node=0; node<inCounts.size(); node++) {\n      if (inCounts.get(node) >= minInCountDeref) {\n        if (bottom == null) {\n          q.add(new NodeAndInCount(node, (int) inCounts.get(node)));\n          if (q.size() == topN) {\n            bottom = q.top();\n          }\n        } else if (inCounts.get(node) > bottom.count) {\n          q.insertWithOverflow(new NodeAndInCount(node, (int) inCounts.get(node)));\n        }\n      }\n    }\n\n    // Free up RAM:\n    inCounts = null;\n\n    final Map<Integer,Integer> topNodeMap = new HashMap<Integer,Integer>();\n    for(int downTo=q.size()-1;downTo>=0;downTo--) {\n      NodeAndInCount n = q.pop();\n      topNodeMap.put(n.node, downTo);\n      //System.out.println(\"map node=\" + n.node + \" inCount=\" + n.count + \" to newID=\" + downTo);\n    }\n\n    final FST<T> fst = new FST<T>(inputType, null, outputs);\n\n    final BytesWriter writer = fst.writer;\n\n    // +1 because node ords start at 1 (0 is reserved as stop node):\n    final GrowableWriter newNodeAddress = new GrowableWriter(\n        PackedInts.bitsRequired(bytes.length), 1 + nodeCount, acceptableOverheadRatio);\n\n    // Fill initial coarse guess:\n    for(int node=1;node<=nodeCount;node++) {\n      newNodeAddress.set(node, 1 + bytes.length - nodeAddress.get(node));\n    }\n\n    int absCount;\n    int deltaCount;\n    int topCount;\n    int nextCount;\n\n    // Iterate until we converge:\n    while(true) {\n\n      //System.out.println(\"\\nITER\");\n      boolean changed = false;\n\n      // for assert:\n      boolean negDelta = false;\n\n      writer.setPosition(0);\n      // Skip 0 byte since 0 is reserved target:\n      writer.writeByte((byte) 0);\n\n      fst.arcWithOutputCount = 0;\n      fst.nodeCount = 0;\n      fst.arcCount = 0;\n\n      absCount = deltaCount = topCount = nextCount = 0;\n\n      int changedCount = 0;\n\n      int addressError = 0;\n\n      //int totWasted = 0;\n\n      // Since we re-reverse the bytes, we now write the\n      // nodes backwards, so that BIT_TARGET_NEXT is\n      // unchanged:\n      for(int node=nodeCount;node>=1;node--) {\n        fst.nodeCount++;\n        final int address = writer.getPosition();\n        //System.out.println(\"  node: \" + node + \" address=\" + address);\n        if (address != newNodeAddress.get(node)) {\n          addressError = address - (int) newNodeAddress.get(node);\n          //System.out.println(\"    change: \" + (address - newNodeAddress[node]));\n          changed = true;\n          newNodeAddress.set(node, address);\n          changedCount++;\n        }\n\n        int nodeArcCount = 0;\n        int bytesPerArc = 0;\n\n        boolean retry = false;\n\n        // for assert:\n        boolean anyNegDelta = false;\n\n        // Retry loop: possibly iterate more than once, if\n        // this is an array'd node and bytesPerArc changes:\n        writeNode:\n        while(true) { // retry writing this node\n\n          readFirstRealTargetArc(node, arc, r);\n\n          final boolean useArcArray = arc.bytesPerArc != 0;\n          if (useArcArray) {\n            // Write false first arc:\n            if (bytesPerArc == 0) {\n              bytesPerArc = arc.bytesPerArc;\n            }\n            writer.writeByte(ARCS_AS_FIXED_ARRAY);\n            writer.writeVInt(arc.numArcs);\n            writer.writeVInt(bytesPerArc);\n            //System.out.println(\"node \" + node + \": \" + arc.numArcs + \" arcs\");\n          }\n\n          int maxBytesPerArc = 0;\n          //int wasted = 0;\n          while(true) {  // iterate over all arcs for this node\n\n            //System.out.println(\"    arc label=\" + arc.label + \" target=\" + arc.target + \" pos=\" + writer.posWrite);\n            final int arcStartPos = writer.getPosition();\n            nodeArcCount++;\n\n            byte flags = 0;\n\n            if (arc.isLast()) {\n              flags += BIT_LAST_ARC;\n            }\n            /*\n            if (!useArcArray && nodeUpto < nodes.length-1 && arc.target == nodes[nodeUpto+1]) {\n              flags += BIT_TARGET_NEXT;\n            }\n            */\n            if (!useArcArray && node != 1 && arc.target == node-1) {\n              flags += BIT_TARGET_NEXT;\n              if (!retry) {\n                nextCount++;\n              }\n            }\n            if (arc.isFinal()) {\n              flags += BIT_FINAL_ARC;\n              if (arc.nextFinalOutput != NO_OUTPUT) {\n                flags += BIT_ARC_HAS_FINAL_OUTPUT;\n              }\n            } else {\n              assert arc.nextFinalOutput == NO_OUTPUT;\n            }\n            if (!targetHasArcs(arc)) {\n              flags += BIT_STOP_NODE;\n            }\n\n            if (arc.output != NO_OUTPUT) {\n              flags += BIT_ARC_HAS_OUTPUT;\n            }\n\n            final Integer ptr;\n            final int absPtr;\n            final boolean doWriteTarget = targetHasArcs(arc) && (flags & BIT_TARGET_NEXT) == 0;\n            if (doWriteTarget) {\n\n              ptr = topNodeMap.get(arc.target);\n              if (ptr != null) {\n                absPtr = ptr;\n              } else {\n                absPtr = topNodeMap.size() + (int) newNodeAddress.get(arc.target) + addressError;\n              }\n\n              int delta = (int) newNodeAddress.get(arc.target) + addressError - writer.getPosition() - 2;\n              if (delta < 0) {\n                //System.out.println(\"neg: \" + delta);\n                anyNegDelta = true;\n                delta = 0;\n              }\n\n              if (delta < absPtr) {\n                flags |= BIT_TARGET_DELTA;\n              }\n            } else {\n              ptr = null;\n              absPtr = 0;\n            }\n\n            writer.writeByte(flags);\n            fst.writeLabel(arc.label);\n\n            if (arc.output != NO_OUTPUT) {\n              outputs.write(arc.output, writer);\n              if (!retry) {\n                fst.arcWithOutputCount++;\n              }\n            }\n            if (arc.nextFinalOutput != NO_OUTPUT) {\n              outputs.writeFinalOutput(arc.nextFinalOutput, writer);\n            }\n\n            if (doWriteTarget) {\n\n              int delta = (int) newNodeAddress.get(arc.target) + addressError - writer.getPosition();\n              if (delta < 0) {\n                anyNegDelta = true;\n                //System.out.println(\"neg: \" + delta);\n                delta = 0;\n              }\n\n              if (flag(flags, BIT_TARGET_DELTA)) {\n                //System.out.println(\"        delta\");\n                writer.writeVInt(delta);\n                if (!retry) {\n                  deltaCount++;\n                }\n              } else {\n                /*\n                if (ptr != null) {\n                  System.out.println(\"        deref\");\n                } else {\n                  System.out.println(\"        abs\");\n                }\n                */\n                writer.writeVInt(absPtr);\n                if (!retry) {\n                  if (absPtr >= topNodeMap.size()) {\n                    absCount++;\n                  } else {\n                    topCount++;\n                  }\n                }\n              }\n            }\n\n            if (useArcArray) {\n              final int arcBytes = writer.getPosition() - arcStartPos;\n              //System.out.println(\"  \" + arcBytes + \" bytes\");\n              maxBytesPerArc = Math.max(maxBytesPerArc, arcBytes);\n              // NOTE: this may in fact go \"backwards\", if\n              // somehow (rarely, possibly never) we use\n              // more bytesPerArc in this rewrite than the\n              // incoming FST did... but in this case we\n              // will retry (below) so it's OK to ovewrite\n              // bytes:\n              //wasted += bytesPerArc - arcBytes;\n              writer.setPosition(arcStartPos + bytesPerArc);\n            }\n\n            if (arc.isLast()) {\n              break;\n            }\n\n            readNextRealArc(arc, r);\n          }\n\n          if (useArcArray) {\n            if (maxBytesPerArc == bytesPerArc || (retry && maxBytesPerArc <= bytesPerArc)) {\n              // converged\n              //System.out.println(\"  bba=\" + bytesPerArc + \" wasted=\" + wasted);\n              //totWasted += wasted;\n              break;\n            }\n          } else {\n            break;\n          }\n\n          //System.out.println(\"  retry this node maxBytesPerArc=\" + maxBytesPerArc + \" vs \" + bytesPerArc);\n\n          // Retry:\n          bytesPerArc = maxBytesPerArc;\n          writer.setPosition(address);\n          nodeArcCount = 0;\n          retry = true;\n          anyNegDelta = false;\n        }\n        negDelta |= anyNegDelta;\n\n        fst.arcCount += nodeArcCount;\n      }\n\n      if (!changed) {\n        // We don't renumber the nodes (just reverse their\n        // order) so nodes should only point forward to\n        // other nodes because we only produce acyclic FSTs\n        // w/ nodes only pointing \"forwards\":\n        assert !negDelta;\n        //System.out.println(\"TOT wasted=\" + totWasted);\n        // Converged!\n        break;\n      }\n      //System.out.println(\"  \" + changedCount + \" of \" + fst.nodeCount + \" changed; retry\");\n    }\n\n    long maxAddress = 0;\n    for (int key : topNodeMap.keySet()) {\n      maxAddress = Math.max(maxAddress, newNodeAddress.get(key));\n    }\n\n    PackedInts.Mutable nodeRefToAddressIn = PackedInts.getMutable(topNodeMap.size(),\n        PackedInts.bitsRequired(maxAddress), acceptableOverheadRatio);\n    for(Map.Entry<Integer,Integer> ent : topNodeMap.entrySet()) {\n      nodeRefToAddressIn.set(ent.getValue(), newNodeAddress.get(ent.getKey()));\n    }\n    fst.nodeRefToAddress = nodeRefToAddressIn;\n    \n\n    fst.startNode = (int) newNodeAddress.get(startNode);\n    //System.out.println(\"new startNode=\" + fst.startNode + \" old startNode=\" + startNode);\n\n    if (emptyOutput != null) {\n      fst.setEmptyOutput(emptyOutput);\n    }\n\n    assert fst.nodeCount == nodeCount: \"fst.nodeCount=\" + fst.nodeCount + \" nodeCount=\" + nodeCount;\n    assert fst.arcCount == arcCount;\n    assert fst.arcWithOutputCount == arcWithOutputCount: \"fst.arcWithOutputCount=\" + fst.arcWithOutputCount + \" arcWithOutputCount=\" + arcWithOutputCount;\n    \n    final byte[] finalBytes = new byte[writer.getPosition()];\n    //System.out.println(\"resize \" + fst.bytes.length + \" down to \" + writer.posWrite);\n    System.arraycopy(fst.bytes, 0, finalBytes, 0, writer.getPosition());\n    fst.bytes = finalBytes;\n    fst.cacheRootArcs();\n\n    //final int size = fst.sizeInBytes();\n    //System.out.println(\"nextCount=\" + nextCount + \" topCount=\" + topCount + \" deltaCount=\" + deltaCount + \" absCount=\" + absCount);\n\n    return fst;\n  }\n\n","sourceOld":"  /** Expert: creates an FST by packing this one.  This\n   *  process requires substantial additional RAM (currently\n   *  up to ~8 bytes per node depending on\n   *  <code>acceptableOverheadRatio</code>), but then should\n   *  produce a smaller FST.\n   *\n   *  <p>The implementation of this method uses ideas from\n   *  <a target=\"_blank\" href=\"http://www.cs.put.poznan.pl/dweiss/site/publications/download/fsacomp.pdf\">Smaller Representation of Finite State Automata</a>,\n   *  which describes techniques to reduce the size of a FST.\n   *  However, this is not a strict implementation of the\n   *  algorithms described in this paper.\n   */\n  public FST<T> pack(int minInCountDeref, int maxDerefNodes, float acceptableOverheadRatio) throws IOException {\n\n    // TODO: other things to try\n    //   - renumber the nodes to get more next / better locality?\n    //   - allow multiple input labels on an arc, so\n    //     singular chain of inputs can take one arc (on\n    //     wikipedia terms this could save another ~6%)\n    //   - in the ord case, the output '1' is presumably\n    //     very common (after NO_OUTPUT)... maybe use a bit\n    //     for it..?\n    //   - use spare bits in flags.... for top few labels /\n    //     outputs / targets\n\n    if (nodeAddress == null) {\n      throw new IllegalArgumentException(\"this FST was not built with willPackFST=true\");\n    }\n\n    Arc<T> arc = new Arc<T>();\n\n    final BytesReader r = getBytesReader(0);\n\n    final int topN = Math.min(maxDerefNodes, inCounts.size());\n\n    // Find top nodes with highest number of incoming arcs:\n    NodeQueue q = new NodeQueue(topN);\n\n    // TODO: we could use more RAM efficient selection algo here...\n    NodeAndInCount bottom = null;\n    for(int node=0; node<inCounts.size(); node++) {\n      if (inCounts.get(node) >= minInCountDeref) {\n        if (bottom == null) {\n          q.add(new NodeAndInCount(node, (int) inCounts.get(node)));\n          if (q.size() == topN) {\n            bottom = q.top();\n          }\n        } else if (inCounts.get(node) > bottom.count) {\n          q.insertWithOverflow(new NodeAndInCount(node, (int) inCounts.get(node)));\n        }\n      }\n    }\n\n    // Free up RAM:\n    inCounts = null;\n\n    final Map<Integer,Integer> topNodeMap = new HashMap<Integer,Integer>();\n    for(int downTo=q.size()-1;downTo>=0;downTo--) {\n      NodeAndInCount n = q.pop();\n      topNodeMap.put(n.node, downTo);\n      //System.out.println(\"map node=\" + n.node + \" inCount=\" + n.count + \" to newID=\" + downTo);\n    }\n\n    final FST<T> fst = new FST<T>(inputType, null, outputs);\n\n    final BytesWriter writer = fst.writer;\n\n    // +1 because node ords start at 1 (0 is reserved as stop node):\n    final GrowableWriter newNodeAddress = new GrowableWriter(\n        PackedInts.bitsRequired(bytes.length), 1 + nodeCount, acceptableOverheadRatio);\n\n    // Fill initial coarse guess:\n    for(int node=1;node<=nodeCount;node++) {\n      newNodeAddress.set(node, 1 + bytes.length - nodeAddress.get(node));\n    }\n\n    int absCount;\n    int deltaCount;\n    int topCount;\n    int nextCount;\n\n    // Iterate until we converge:\n    while(true) {\n\n      //System.out.println(\"\\nITER\");\n      boolean changed = false;\n\n      // for assert:\n      boolean negDelta = false;\n\n      writer.setPosition(0);\n      // Skip 0 byte since 0 is reserved target:\n      writer.writeByte((byte) 0);\n\n      fst.arcWithOutputCount = 0;\n      fst.nodeCount = 0;\n      fst.arcCount = 0;\n\n      absCount = deltaCount = topCount = nextCount = 0;\n\n      int changedCount = 0;\n\n      int addressError = 0;\n\n      //int totWasted = 0;\n\n      // Since we re-reverse the bytes, we now write the\n      // nodes backwards, so that BIT_TARGET_NEXT is\n      // unchanged:\n      for(int node=nodeCount;node>=1;node--) {\n        fst.nodeCount++;\n        final int address = writer.getPosition();\n        //System.out.println(\"  node: \" + node + \" address=\" + address);\n        if (address != newNodeAddress.get(node)) {\n          addressError = address - (int) newNodeAddress.get(node);\n          //System.out.println(\"    change: \" + (address - newNodeAddress[node]));\n          changed = true;\n          newNodeAddress.set(node, address);\n          changedCount++;\n        }\n\n        int nodeArcCount = 0;\n        int bytesPerArc = 0;\n\n        boolean retry = false;\n\n        // for assert:\n        boolean anyNegDelta = false;\n\n        // Retry loop: possibly iterate more than once, if\n        // this is an array'd node and bytesPerArc changes:\n        writeNode:\n        while(true) { // retry writing this node\n\n          readFirstRealTargetArc(node, arc, r);\n\n          final boolean useArcArray = arc.bytesPerArc != 0;\n          if (useArcArray) {\n            // Write false first arc:\n            if (bytesPerArc == 0) {\n              bytesPerArc = arc.bytesPerArc;\n            }\n            writer.writeByte(ARCS_AS_FIXED_ARRAY);\n            writer.writeVInt(arc.numArcs);\n            writer.writeVInt(bytesPerArc);\n            //System.out.println(\"node \" + node + \": \" + arc.numArcs + \" arcs\");\n          }\n\n          int maxBytesPerArc = 0;\n          //int wasted = 0;\n          while(true) {  // iterate over all arcs for this node\n\n            //System.out.println(\"    arc label=\" + arc.label + \" target=\" + arc.target + \" pos=\" + writer.posWrite);\n            final int arcStartPos = writer.getPosition();\n            nodeArcCount++;\n\n            byte flags = 0;\n\n            if (arc.isLast()) {\n              flags += BIT_LAST_ARC;\n            }\n            /*\n            if (!useArcArray && nodeUpto < nodes.length-1 && arc.target == nodes[nodeUpto+1]) {\n              flags += BIT_TARGET_NEXT;\n            }\n            */\n            if (!useArcArray && node != 1 && arc.target == node-1) {\n              flags += BIT_TARGET_NEXT;\n              if (!retry) {\n                nextCount++;\n              }\n            }\n            if (arc.isFinal()) {\n              flags += BIT_FINAL_ARC;\n              if (arc.nextFinalOutput != NO_OUTPUT) {\n                flags += BIT_ARC_HAS_FINAL_OUTPUT;\n              }\n            } else {\n              assert arc.nextFinalOutput == NO_OUTPUT;\n            }\n            if (!targetHasArcs(arc)) {\n              flags += BIT_STOP_NODE;\n            }\n\n            if (arc.output != NO_OUTPUT) {\n              flags += BIT_ARC_HAS_OUTPUT;\n            }\n\n            final Integer ptr;\n            final int absPtr;\n            final boolean doWriteTarget = targetHasArcs(arc) && (flags & BIT_TARGET_NEXT) == 0;\n            if (doWriteTarget) {\n\n              ptr = topNodeMap.get(arc.target);\n              if (ptr != null) {\n                absPtr = ptr;\n              } else {\n                absPtr = topNodeMap.size() + (int) newNodeAddress.get(arc.target) + addressError;\n              }\n\n              int delta = (int) newNodeAddress.get(arc.target) + addressError - writer.getPosition() - 2;\n              if (delta < 0) {\n                //System.out.println(\"neg: \" + delta);\n                anyNegDelta = true;\n                delta = 0;\n              }\n\n              if (delta < absPtr) {\n                flags |= BIT_TARGET_DELTA;\n              }\n            } else {\n              ptr = null;\n              absPtr = 0;\n            }\n\n            writer.writeByte(flags);\n            fst.writeLabel(arc.label);\n\n            if (arc.output != NO_OUTPUT) {\n              outputs.write(arc.output, writer);\n              if (!retry) {\n                fst.arcWithOutputCount++;\n              }\n            }\n            if (arc.nextFinalOutput != NO_OUTPUT) {\n              outputs.writeFinalOutput(arc.nextFinalOutput, writer);\n            }\n\n            if (doWriteTarget) {\n\n              int delta = (int) newNodeAddress.get(arc.target) + addressError - writer.getPosition();\n              if (delta < 0) {\n                anyNegDelta = true;\n                //System.out.println(\"neg: \" + delta);\n                delta = 0;\n              }\n\n              if (flag(flags, BIT_TARGET_DELTA)) {\n                //System.out.println(\"        delta\");\n                writer.writeVInt(delta);\n                if (!retry) {\n                  deltaCount++;\n                }\n              } else {\n                /*\n                if (ptr != null) {\n                  System.out.println(\"        deref\");\n                } else {\n                  System.out.println(\"        abs\");\n                }\n                */\n                writer.writeVInt(absPtr);\n                if (!retry) {\n                  if (absPtr >= topNodeMap.size()) {\n                    absCount++;\n                  } else {\n                    topCount++;\n                  }\n                }\n              }\n            }\n\n            if (useArcArray) {\n              final int arcBytes = writer.getPosition() - arcStartPos;\n              //System.out.println(\"  \" + arcBytes + \" bytes\");\n              maxBytesPerArc = Math.max(maxBytesPerArc, arcBytes);\n              // NOTE: this may in fact go \"backwards\", if\n              // somehow (rarely, possibly never) we use\n              // more bytesPerArc in this rewrite than the\n              // incoming FST did... but in this case we\n              // will retry (below) so it's OK to ovewrite\n              // bytes:\n              //wasted += bytesPerArc - arcBytes;\n              writer.setPosition(arcStartPos + bytesPerArc);\n            }\n\n            if (arc.isLast()) {\n              break;\n            }\n\n            readNextRealArc(arc, r);\n          }\n\n          if (useArcArray) {\n            if (maxBytesPerArc == bytesPerArc || (retry && maxBytesPerArc <= bytesPerArc)) {\n              // converged\n              //System.out.println(\"  bba=\" + bytesPerArc + \" wasted=\" + wasted);\n              //totWasted += wasted;\n              break;\n            }\n          } else {\n            break;\n          }\n\n          //System.out.println(\"  retry this node maxBytesPerArc=\" + maxBytesPerArc + \" vs \" + bytesPerArc);\n\n          // Retry:\n          bytesPerArc = maxBytesPerArc;\n          writer.setPosition(address);\n          nodeArcCount = 0;\n          retry = true;\n          anyNegDelta = false;\n        }\n        negDelta |= anyNegDelta;\n\n        fst.arcCount += nodeArcCount;\n      }\n\n      if (!changed) {\n        // We don't renumber the nodes (just reverse their\n        // order) so nodes should only point forward to\n        // other nodes because we only produce acyclic FSTs\n        // w/ nodes only pointing \"forwards\":\n        assert !negDelta;\n        //System.out.println(\"TOT wasted=\" + totWasted);\n        // Converged!\n        break;\n      }\n      //System.out.println(\"  \" + changedCount + \" of \" + fst.nodeCount + \" changed; retry\");\n    }\n\n    long maxAddress = 0;\n    for (int key : topNodeMap.keySet()) {\n      maxAddress = Math.max(maxAddress, newNodeAddress.get(key));\n    }\n\n    PackedInts.Mutable nodeRefToAddressIn = PackedInts.getMutable(topNodeMap.size(),\n        PackedInts.bitsRequired(maxAddress), acceptableOverheadRatio);\n    for(Map.Entry<Integer,Integer> ent : topNodeMap.entrySet()) {\n      nodeRefToAddressIn.set(ent.getValue(), newNodeAddress.get(ent.getKey()));\n    }\n    fst.nodeRefToAddress = nodeRefToAddressIn;\n    \n\n    fst.startNode = (int) newNodeAddress.get(startNode);\n    //System.out.println(\"new startNode=\" + fst.startNode + \" old startNode=\" + startNode);\n\n    if (emptyOutput != null) {\n      fst.setEmptyOutput(emptyOutput);\n    }\n\n    assert fst.nodeCount == nodeCount: \"fst.nodeCount=\" + fst.nodeCount + \" nodeCount=\" + nodeCount;\n    assert fst.arcCount == arcCount;\n    assert fst.arcWithOutputCount == arcWithOutputCount: \"fst.arcWithOutputCount=\" + fst.arcWithOutputCount + \" arcWithOutputCount=\" + arcWithOutputCount;\n    \n    final byte[] finalBytes = new byte[writer.getPosition()];\n    //System.out.println(\"resize \" + fst.bytes.length + \" down to \" + writer.posWrite);\n    System.arraycopy(fst.bytes, 0, finalBytes, 0, writer.getPosition());\n    fst.bytes = finalBytes;\n    fst.cacheRootArcs();\n\n    //final int size = fst.sizeInBytes();\n    //System.out.println(\"nextCount=\" + nextCount + \" topCount=\" + topCount + \" deltaCount=\" + deltaCount + \" absCount=\" + absCount);\n\n    return fst;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#pack(int,int,float).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#pack(int,int,float).mjava","sourceNew":"  /** Expert: creates an FST by packing this one.  This\n   *  process requires substantial additional RAM (currently\n   *  up to ~8 bytes per node depending on\n   *  <code>acceptableOverheadRatio</code>), but then should\n   *  produce a smaller FST.\n   *\n   *  <p>The implementation of this method uses ideas from\n   *  <a target=\"_blank\" href=\"http://www.cs.put.poznan.pl/dweiss/site/publications/download/fsacomp.pdf\">Smaller Representation of Finite State Automata</a>,\n   *  which describes techniques to reduce the size of a FST.\n   *  However, this is not a strict implementation of the\n   *  algorithms described in this paper.\n   */\n  FST<T> pack(int minInCountDeref, int maxDerefNodes, float acceptableOverheadRatio) throws IOException {\n\n    // TODO: other things to try\n    //   - renumber the nodes to get more next / better locality?\n    //   - allow multiple input labels on an arc, so\n    //     singular chain of inputs can take one arc (on\n    //     wikipedia terms this could save another ~6%)\n    //   - in the ord case, the output '1' is presumably\n    //     very common (after NO_OUTPUT)... maybe use a bit\n    //     for it..?\n    //   - use spare bits in flags.... for top few labels /\n    //     outputs / targets\n\n    if (nodeAddress == null) {\n      throw new IllegalArgumentException(\"this FST was not built with willPackFST=true\");\n    }\n\n    Arc<T> arc = new Arc<T>();\n\n    final BytesReader r = getBytesReader(0);\n\n    final int topN = Math.min(maxDerefNodes, inCounts.size());\n\n    // Find top nodes with highest number of incoming arcs:\n    NodeQueue q = new NodeQueue(topN);\n\n    // TODO: we could use more RAM efficient selection algo here...\n    NodeAndInCount bottom = null;\n    for(int node=0; node<inCounts.size(); node++) {\n      if (inCounts.get(node) >= minInCountDeref) {\n        if (bottom == null) {\n          q.add(new NodeAndInCount(node, (int) inCounts.get(node)));\n          if (q.size() == topN) {\n            bottom = q.top();\n          }\n        } else if (inCounts.get(node) > bottom.count) {\n          q.insertWithOverflow(new NodeAndInCount(node, (int) inCounts.get(node)));\n        }\n      }\n    }\n\n    // Free up RAM:\n    inCounts = null;\n\n    final Map<Integer,Integer> topNodeMap = new HashMap<Integer,Integer>();\n    for(int downTo=q.size()-1;downTo>=0;downTo--) {\n      NodeAndInCount n = q.pop();\n      topNodeMap.put(n.node, downTo);\n      //System.out.println(\"map node=\" + n.node + \" inCount=\" + n.count + \" to newID=\" + downTo);\n    }\n\n    final FST<T> fst = new FST<T>(inputType, null, outputs);\n\n    final BytesWriter writer = fst.writer;\n\n    // +1 because node ords start at 1 (0 is reserved as stop node):\n    final GrowableWriter newNodeAddress = new GrowableWriter(\n        PackedInts.bitsRequired(bytes.length), 1 + nodeCount, acceptableOverheadRatio);\n\n    // Fill initial coarse guess:\n    for(int node=1;node<=nodeCount;node++) {\n      newNodeAddress.set(node, 1 + bytes.length - nodeAddress.get(node));\n    }\n\n    int absCount;\n    int deltaCount;\n    int topCount;\n    int nextCount;\n\n    // Iterate until we converge:\n    while(true) {\n\n      //System.out.println(\"\\nITER\");\n      boolean changed = false;\n\n      // for assert:\n      boolean negDelta = false;\n\n      writer.setPosition(0);\n      // Skip 0 byte since 0 is reserved target:\n      writer.writeByte((byte) 0);\n\n      fst.arcWithOutputCount = 0;\n      fst.nodeCount = 0;\n      fst.arcCount = 0;\n\n      absCount = deltaCount = topCount = nextCount = 0;\n\n      int changedCount = 0;\n\n      int addressError = 0;\n\n      //int totWasted = 0;\n\n      // Since we re-reverse the bytes, we now write the\n      // nodes backwards, so that BIT_TARGET_NEXT is\n      // unchanged:\n      for(int node=nodeCount;node>=1;node--) {\n        fst.nodeCount++;\n        final int address = writer.getPosition();\n        //System.out.println(\"  node: \" + node + \" address=\" + address);\n        if (address != newNodeAddress.get(node)) {\n          addressError = address - (int) newNodeAddress.get(node);\n          //System.out.println(\"    change: \" + (address - newNodeAddress[node]));\n          changed = true;\n          newNodeAddress.set(node, address);\n          changedCount++;\n        }\n\n        int nodeArcCount = 0;\n        int bytesPerArc = 0;\n\n        boolean retry = false;\n\n        // for assert:\n        boolean anyNegDelta = false;\n\n        // Retry loop: possibly iterate more than once, if\n        // this is an array'd node and bytesPerArc changes:\n        writeNode:\n        while(true) { // retry writing this node\n\n          readFirstRealTargetArc(node, arc, r);\n\n          final boolean useArcArray = arc.bytesPerArc != 0;\n          if (useArcArray) {\n            // Write false first arc:\n            if (bytesPerArc == 0) {\n              bytesPerArc = arc.bytesPerArc;\n            }\n            writer.writeByte(ARCS_AS_FIXED_ARRAY);\n            writer.writeVInt(arc.numArcs);\n            writer.writeVInt(bytesPerArc);\n            //System.out.println(\"node \" + node + \": \" + arc.numArcs + \" arcs\");\n          }\n\n          int maxBytesPerArc = 0;\n          //int wasted = 0;\n          while(true) {  // iterate over all arcs for this node\n\n            //System.out.println(\"    arc label=\" + arc.label + \" target=\" + arc.target + \" pos=\" + writer.posWrite);\n            final int arcStartPos = writer.getPosition();\n            nodeArcCount++;\n\n            byte flags = 0;\n\n            if (arc.isLast()) {\n              flags += BIT_LAST_ARC;\n            }\n            /*\n            if (!useArcArray && nodeUpto < nodes.length-1 && arc.target == nodes[nodeUpto+1]) {\n              flags += BIT_TARGET_NEXT;\n            }\n            */\n            if (!useArcArray && node != 1 && arc.target == node-1) {\n              flags += BIT_TARGET_NEXT;\n              if (!retry) {\n                nextCount++;\n              }\n            }\n            if (arc.isFinal()) {\n              flags += BIT_FINAL_ARC;\n              if (arc.nextFinalOutput != NO_OUTPUT) {\n                flags += BIT_ARC_HAS_FINAL_OUTPUT;\n              }\n            } else {\n              assert arc.nextFinalOutput == NO_OUTPUT;\n            }\n            if (!targetHasArcs(arc)) {\n              flags += BIT_STOP_NODE;\n            }\n\n            if (arc.output != NO_OUTPUT) {\n              flags += BIT_ARC_HAS_OUTPUT;\n            }\n\n            final Integer ptr;\n            final int absPtr;\n            final boolean doWriteTarget = targetHasArcs(arc) && (flags & BIT_TARGET_NEXT) == 0;\n            if (doWriteTarget) {\n\n              ptr = topNodeMap.get(arc.target);\n              if (ptr != null) {\n                absPtr = ptr;\n              } else {\n                absPtr = topNodeMap.size() + (int) newNodeAddress.get(arc.target) + addressError;\n              }\n\n              int delta = (int) newNodeAddress.get(arc.target) + addressError - writer.getPosition() - 2;\n              if (delta < 0) {\n                //System.out.println(\"neg: \" + delta);\n                anyNegDelta = true;\n                delta = 0;\n              }\n\n              if (delta < absPtr) {\n                flags |= BIT_TARGET_DELTA;\n              }\n            } else {\n              ptr = null;\n              absPtr = 0;\n            }\n\n            writer.writeByte(flags);\n            fst.writeLabel(arc.label);\n\n            if (arc.output != NO_OUTPUT) {\n              outputs.write(arc.output, writer);\n              if (!retry) {\n                fst.arcWithOutputCount++;\n              }\n            }\n            if (arc.nextFinalOutput != NO_OUTPUT) {\n              outputs.writeFinalOutput(arc.nextFinalOutput, writer);\n            }\n\n            if (doWriteTarget) {\n\n              int delta = (int) newNodeAddress.get(arc.target) + addressError - writer.getPosition();\n              if (delta < 0) {\n                anyNegDelta = true;\n                //System.out.println(\"neg: \" + delta);\n                delta = 0;\n              }\n\n              if (flag(flags, BIT_TARGET_DELTA)) {\n                //System.out.println(\"        delta\");\n                writer.writeVInt(delta);\n                if (!retry) {\n                  deltaCount++;\n                }\n              } else {\n                /*\n                if (ptr != null) {\n                  System.out.println(\"        deref\");\n                } else {\n                  System.out.println(\"        abs\");\n                }\n                */\n                writer.writeVInt(absPtr);\n                if (!retry) {\n                  if (absPtr >= topNodeMap.size()) {\n                    absCount++;\n                  } else {\n                    topCount++;\n                  }\n                }\n              }\n            }\n\n            if (useArcArray) {\n              final int arcBytes = writer.getPosition() - arcStartPos;\n              //System.out.println(\"  \" + arcBytes + \" bytes\");\n              maxBytesPerArc = Math.max(maxBytesPerArc, arcBytes);\n              // NOTE: this may in fact go \"backwards\", if\n              // somehow (rarely, possibly never) we use\n              // more bytesPerArc in this rewrite than the\n              // incoming FST did... but in this case we\n              // will retry (below) so it's OK to ovewrite\n              // bytes:\n              //wasted += bytesPerArc - arcBytes;\n              writer.setPosition(arcStartPos + bytesPerArc);\n            }\n\n            if (arc.isLast()) {\n              break;\n            }\n\n            readNextRealArc(arc, r);\n          }\n\n          if (useArcArray) {\n            if (maxBytesPerArc == bytesPerArc || (retry && maxBytesPerArc <= bytesPerArc)) {\n              // converged\n              //System.out.println(\"  bba=\" + bytesPerArc + \" wasted=\" + wasted);\n              //totWasted += wasted;\n              break;\n            }\n          } else {\n            break;\n          }\n\n          //System.out.println(\"  retry this node maxBytesPerArc=\" + maxBytesPerArc + \" vs \" + bytesPerArc);\n\n          // Retry:\n          bytesPerArc = maxBytesPerArc;\n          writer.setPosition(address);\n          nodeArcCount = 0;\n          retry = true;\n          anyNegDelta = false;\n        }\n        negDelta |= anyNegDelta;\n\n        fst.arcCount += nodeArcCount;\n      }\n\n      if (!changed) {\n        // We don't renumber the nodes (just reverse their\n        // order) so nodes should only point forward to\n        // other nodes because we only produce acyclic FSTs\n        // w/ nodes only pointing \"forwards\":\n        assert !negDelta;\n        //System.out.println(\"TOT wasted=\" + totWasted);\n        // Converged!\n        break;\n      }\n      //System.out.println(\"  \" + changedCount + \" of \" + fst.nodeCount + \" changed; retry\");\n    }\n\n    long maxAddress = 0;\n    for (int key : topNodeMap.keySet()) {\n      maxAddress = Math.max(maxAddress, newNodeAddress.get(key));\n    }\n\n    PackedInts.Mutable nodeRefToAddressIn = PackedInts.getMutable(topNodeMap.size(),\n        PackedInts.bitsRequired(maxAddress), acceptableOverheadRatio);\n    for(Map.Entry<Integer,Integer> ent : topNodeMap.entrySet()) {\n      nodeRefToAddressIn.set(ent.getValue(), newNodeAddress.get(ent.getKey()));\n    }\n    fst.nodeRefToAddress = nodeRefToAddressIn;\n    \n\n    fst.startNode = (int) newNodeAddress.get(startNode);\n    //System.out.println(\"new startNode=\" + fst.startNode + \" old startNode=\" + startNode);\n\n    if (emptyOutput != null) {\n      fst.setEmptyOutput(emptyOutput);\n    }\n\n    assert fst.nodeCount == nodeCount: \"fst.nodeCount=\" + fst.nodeCount + \" nodeCount=\" + nodeCount;\n    assert fst.arcCount == arcCount;\n    assert fst.arcWithOutputCount == arcWithOutputCount: \"fst.arcWithOutputCount=\" + fst.arcWithOutputCount + \" arcWithOutputCount=\" + arcWithOutputCount;\n    \n    final byte[] finalBytes = new byte[writer.getPosition()];\n    //System.out.println(\"resize \" + fst.bytes.length + \" down to \" + writer.posWrite);\n    System.arraycopy(fst.bytes, 0, finalBytes, 0, writer.getPosition());\n    fst.bytes = finalBytes;\n    fst.cacheRootArcs();\n\n    //final int size = fst.sizeInBytes();\n    //System.out.println(\"nextCount=\" + nextCount + \" topCount=\" + topCount + \" deltaCount=\" + deltaCount + \" absCount=\" + absCount);\n\n    return fst;\n  }\n\n","sourceOld":"  /** Expert: creates an FST by packing this one.  This\n   *  process requires substantial additional RAM (currently\n   *  up to ~8 bytes per node depending on\n   *  <code>acceptableOverheadRatio</code>), but then should\n   *  produce a smaller FST.\n   *\n   *  <p>The implementation of this method uses ideas from\n   *  <a target=\"_blank\" href=\"http://www.cs.put.poznan.pl/dweiss/site/publications/download/fsacomp.pdf\">Smaller Representation of Finite State Automata</a>,\n   *  which describes techniques to reduce the size of a FST.\n   *  However, this is not a strict implementation of the\n   *  algorithms described in this paper.\n   */\n  public FST<T> pack(int minInCountDeref, int maxDerefNodes, float acceptableOverheadRatio) throws IOException {\n\n    // TODO: other things to try\n    //   - renumber the nodes to get more next / better locality?\n    //   - allow multiple input labels on an arc, so\n    //     singular chain of inputs can take one arc (on\n    //     wikipedia terms this could save another ~6%)\n    //   - in the ord case, the output '1' is presumably\n    //     very common (after NO_OUTPUT)... maybe use a bit\n    //     for it..?\n    //   - use spare bits in flags.... for top few labels /\n    //     outputs / targets\n\n    if (nodeAddress == null) {\n      throw new IllegalArgumentException(\"this FST was not built with willPackFST=true\");\n    }\n\n    Arc<T> arc = new Arc<T>();\n\n    final BytesReader r = getBytesReader(0);\n\n    final int topN = Math.min(maxDerefNodes, inCounts.size());\n\n    // Find top nodes with highest number of incoming arcs:\n    NodeQueue q = new NodeQueue(topN);\n\n    // TODO: we could use more RAM efficient selection algo here...\n    NodeAndInCount bottom = null;\n    for(int node=0; node<inCounts.size(); node++) {\n      if (inCounts.get(node) >= minInCountDeref) {\n        if (bottom == null) {\n          q.add(new NodeAndInCount(node, (int) inCounts.get(node)));\n          if (q.size() == topN) {\n            bottom = q.top();\n          }\n        } else if (inCounts.get(node) > bottom.count) {\n          q.insertWithOverflow(new NodeAndInCount(node, (int) inCounts.get(node)));\n        }\n      }\n    }\n\n    // Free up RAM:\n    inCounts = null;\n\n    final Map<Integer,Integer> topNodeMap = new HashMap<Integer,Integer>();\n    for(int downTo=q.size()-1;downTo>=0;downTo--) {\n      NodeAndInCount n = q.pop();\n      topNodeMap.put(n.node, downTo);\n      //System.out.println(\"map node=\" + n.node + \" inCount=\" + n.count + \" to newID=\" + downTo);\n    }\n\n    final FST<T> fst = new FST<T>(inputType, null, outputs);\n\n    final BytesWriter writer = fst.writer;\n\n    // +1 because node ords start at 1 (0 is reserved as stop node):\n    final GrowableWriter newNodeAddress = new GrowableWriter(\n        PackedInts.bitsRequired(bytes.length), 1 + nodeCount, acceptableOverheadRatio);\n\n    // Fill initial coarse guess:\n    for(int node=1;node<=nodeCount;node++) {\n      newNodeAddress.set(node, 1 + bytes.length - nodeAddress.get(node));\n    }\n\n    int absCount;\n    int deltaCount;\n    int topCount;\n    int nextCount;\n\n    // Iterate until we converge:\n    while(true) {\n\n      //System.out.println(\"\\nITER\");\n      boolean changed = false;\n\n      // for assert:\n      boolean negDelta = false;\n\n      writer.posWrite = 0;\n      // Skip 0 byte since 0 is reserved target:\n      writer.writeByte((byte) 0);\n\n      fst.arcWithOutputCount = 0;\n      fst.nodeCount = 0;\n      fst.arcCount = 0;\n\n      absCount = deltaCount = topCount = nextCount = 0;\n\n      int changedCount = 0;\n\n      int addressError = 0;\n\n      //int totWasted = 0;\n\n      // Since we re-reverse the bytes, we now write the\n      // nodes backwards, so that BIT_TARGET_NEXT is\n      // unchanged:\n      for(int node=nodeCount;node>=1;node--) {\n        fst.nodeCount++;\n        final int address = writer.posWrite;\n        //System.out.println(\"  node: \" + node + \" address=\" + address);\n        if (address != newNodeAddress.get(node)) {\n          addressError = address - (int) newNodeAddress.get(node);\n          //System.out.println(\"    change: \" + (address - newNodeAddress[node]));\n          changed = true;\n          newNodeAddress.set(node, address);\n          changedCount++;\n        }\n\n        int nodeArcCount = 0;\n        int bytesPerArc = 0;\n\n        boolean retry = false;\n\n        // for assert:\n        boolean anyNegDelta = false;\n\n        // Retry loop: possibly iterate more than once, if\n        // this is an array'd node and bytesPerArc changes:\n        writeNode:\n        while(true) { // retry writing this node\n\n          readFirstRealTargetArc(node, arc, r);\n\n          final boolean useArcArray = arc.bytesPerArc != 0;\n          if (useArcArray) {\n            // Write false first arc:\n            if (bytesPerArc == 0) {\n              bytesPerArc = arc.bytesPerArc;\n            }\n            writer.writeByte(ARCS_AS_FIXED_ARRAY);\n            writer.writeVInt(arc.numArcs);\n            writer.writeVInt(bytesPerArc);\n            //System.out.println(\"node \" + node + \": \" + arc.numArcs + \" arcs\");\n          }\n\n          int maxBytesPerArc = 0;\n          //int wasted = 0;\n          while(true) {  // iterate over all arcs for this node\n\n            //System.out.println(\"    arc label=\" + arc.label + \" target=\" + arc.target + \" pos=\" + writer.posWrite);\n            final int arcStartPos = writer.posWrite;\n            nodeArcCount++;\n\n            byte flags = 0;\n\n            if (arc.isLast()) {\n              flags += BIT_LAST_ARC;\n            }\n            /*\n            if (!useArcArray && nodeUpto < nodes.length-1 && arc.target == nodes[nodeUpto+1]) {\n              flags += BIT_TARGET_NEXT;\n            }\n            */\n            if (!useArcArray && node != 1 && arc.target == node-1) {\n              flags += BIT_TARGET_NEXT;\n              if (!retry) {\n                nextCount++;\n              }\n            }\n            if (arc.isFinal()) {\n              flags += BIT_FINAL_ARC;\n              if (arc.nextFinalOutput != NO_OUTPUT) {\n                flags += BIT_ARC_HAS_FINAL_OUTPUT;\n              }\n            } else {\n              assert arc.nextFinalOutput == NO_OUTPUT;\n            }\n            if (!targetHasArcs(arc)) {\n              flags += BIT_STOP_NODE;\n            }\n\n            if (arc.output != NO_OUTPUT) {\n              flags += BIT_ARC_HAS_OUTPUT;\n            }\n\n            final Integer ptr;\n            final int absPtr;\n            final boolean doWriteTarget = targetHasArcs(arc) && (flags & BIT_TARGET_NEXT) == 0;\n            if (doWriteTarget) {\n\n              ptr = topNodeMap.get(arc.target);\n              if (ptr != null) {\n                absPtr = ptr;\n              } else {\n                absPtr = topNodeMap.size() + (int) newNodeAddress.get(arc.target) + addressError;\n              }\n\n              int delta = (int) newNodeAddress.get(arc.target) + addressError - writer.posWrite - 2;\n              if (delta < 0) {\n                //System.out.println(\"neg: \" + delta);\n                anyNegDelta = true;\n                delta = 0;\n              }\n\n              if (delta < absPtr) {\n                flags |= BIT_TARGET_DELTA;\n              }\n            } else {\n              ptr = null;\n              absPtr = 0;\n            }\n\n            writer.writeByte(flags);\n            fst.writeLabel(arc.label);\n\n            if (arc.output != NO_OUTPUT) {\n              outputs.write(arc.output, writer);\n              if (!retry) {\n                fst.arcWithOutputCount++;\n              }\n            }\n            if (arc.nextFinalOutput != NO_OUTPUT) {\n              outputs.writeFinalOutput(arc.nextFinalOutput, writer);\n            }\n\n            if (doWriteTarget) {\n\n              int delta = (int) newNodeAddress.get(arc.target) + addressError - writer.posWrite;\n              if (delta < 0) {\n                anyNegDelta = true;\n                //System.out.println(\"neg: \" + delta);\n                delta = 0;\n              }\n\n              if (flag(flags, BIT_TARGET_DELTA)) {\n                //System.out.println(\"        delta\");\n                writer.writeVInt(delta);\n                if (!retry) {\n                  deltaCount++;\n                }\n              } else {\n                /*\n                if (ptr != null) {\n                  System.out.println(\"        deref\");\n                } else {\n                  System.out.println(\"        abs\");\n                }\n                */\n                writer.writeVInt(absPtr);\n                if (!retry) {\n                  if (absPtr >= topNodeMap.size()) {\n                    absCount++;\n                  } else {\n                    topCount++;\n                  }\n                }\n              }\n            }\n\n            if (useArcArray) {\n              final int arcBytes = writer.posWrite - arcStartPos;\n              //System.out.println(\"  \" + arcBytes + \" bytes\");\n              maxBytesPerArc = Math.max(maxBytesPerArc, arcBytes);\n              // NOTE: this may in fact go \"backwards\", if\n              // somehow (rarely, possibly never) we use\n              // more bytesPerArc in this rewrite than the\n              // incoming FST did... but in this case we\n              // will retry (below) so it's OK to ovewrite\n              // bytes:\n              //wasted += bytesPerArc - arcBytes;\n              writer.setPosWrite(arcStartPos + bytesPerArc);\n            }\n\n            if (arc.isLast()) {\n              break;\n            }\n\n            readNextRealArc(arc, r);\n          }\n\n          if (useArcArray) {\n            if (maxBytesPerArc == bytesPerArc || (retry && maxBytesPerArc <= bytesPerArc)) {\n              // converged\n              //System.out.println(\"  bba=\" + bytesPerArc + \" wasted=\" + wasted);\n              //totWasted += wasted;\n              break;\n            }\n          } else {\n            break;\n          }\n\n          //System.out.println(\"  retry this node maxBytesPerArc=\" + maxBytesPerArc + \" vs \" + bytesPerArc);\n\n          // Retry:\n          bytesPerArc = maxBytesPerArc;\n          writer.posWrite = address;\n          nodeArcCount = 0;\n          retry = true;\n          anyNegDelta = false;\n        }\n        negDelta |= anyNegDelta;\n\n        fst.arcCount += nodeArcCount;\n      }\n\n      if (!changed) {\n        // We don't renumber the nodes (just reverse their\n        // order) so nodes should only point forward to\n        // other nodes because we only produce acyclic FSTs\n        // w/ nodes only pointing \"forwards\":\n        assert !negDelta;\n        //System.out.println(\"TOT wasted=\" + totWasted);\n        // Converged!\n        break;\n      }\n      //System.out.println(\"  \" + changedCount + \" of \" + fst.nodeCount + \" changed; retry\");\n    }\n\n    long maxAddress = 0;\n    for (int key : topNodeMap.keySet()) {\n      maxAddress = Math.max(maxAddress, newNodeAddress.get(key));\n    }\n\n    PackedInts.Mutable nodeRefToAddressIn = PackedInts.getMutable(topNodeMap.size(),\n        PackedInts.bitsRequired(maxAddress), acceptableOverheadRatio);\n    for(Map.Entry<Integer,Integer> ent : topNodeMap.entrySet()) {\n      nodeRefToAddressIn.set(ent.getValue(), newNodeAddress.get(ent.getKey()));\n    }\n    fst.nodeRefToAddress = nodeRefToAddressIn;\n    \n\n    fst.startNode = (int) newNodeAddress.get(startNode);\n    //System.out.println(\"new startNode=\" + fst.startNode + \" old startNode=\" + startNode);\n\n    if (emptyOutput != null) {\n      fst.setEmptyOutput(emptyOutput);\n    }\n\n    assert fst.nodeCount == nodeCount: \"fst.nodeCount=\" + fst.nodeCount + \" nodeCount=\" + nodeCount;\n    assert fst.arcCount == arcCount;\n    assert fst.arcWithOutputCount == arcWithOutputCount: \"fst.arcWithOutputCount=\" + fst.arcWithOutputCount + \" arcWithOutputCount=\" + arcWithOutputCount;\n    \n    final byte[] finalBytes = new byte[writer.posWrite];\n    //System.out.println(\"resize \" + fst.bytes.length + \" down to \" + writer.posWrite);\n    System.arraycopy(fst.bytes, 0, finalBytes, 0, writer.posWrite);\n    fst.bytes = finalBytes;\n    fst.cacheRootArcs();\n\n    //final int size = fst.sizeInBytes();\n    //System.out.println(\"nextCount=\" + nextCount + \" topCount=\" + topCount + \" deltaCount=\" + deltaCount + \" absCount=\" + absCount);\n\n    return fst;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"87e78f3c129251e74ecc2ff73a32de0f27cf09d5","date":1358006150,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#pack(int,int,float).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#pack(int,int,float).mjava","sourceNew":"  /** Expert: creates an FST by packing this one.  This\n   *  process requires substantial additional RAM (currently\n   *  up to ~8 bytes per node depending on\n   *  <code>acceptableOverheadRatio</code>), but then should\n   *  produce a smaller FST.\n   *\n   *  <p>The implementation of this method uses ideas from\n   *  <a target=\"_blank\" href=\"http://www.cs.put.poznan.pl/dweiss/site/publications/download/fsacomp.pdf\">Smaller Representation of Finite State Automata</a>,\n   *  which describes techniques to reduce the size of a FST.\n   *  However, this is not a strict implementation of the\n   *  algorithms described in this paper.\n   */\n  FST<T> pack(int minInCountDeref, int maxDerefNodes, float acceptableOverheadRatio) throws IOException {\n\n    // TODO: other things to try\n    //   - renumber the nodes to get more next / better locality?\n    //   - allow multiple input labels on an arc, so\n    //     singular chain of inputs can take one arc (on\n    //     wikipedia terms this could save another ~6%)\n    //   - in the ord case, the output '1' is presumably\n    //     very common (after NO_OUTPUT)... maybe use a bit\n    //     for it..?\n    //   - use spare bits in flags.... for top few labels /\n    //     outputs / targets\n\n    if (nodeAddress == null) {\n      throw new IllegalArgumentException(\"this FST was not built with willPackFST=true\");\n    }\n\n    final RAMOutputStream buffer = new RAMOutputStream();\n    byte[] bufferBytes = new byte[64];\n\n    Arc<T> arc = new Arc<T>();\n\n    final BytesReader r = getBytesReader(0);\n\n    final int topN = Math.min(maxDerefNodes, inCounts.size());\n\n    // Find top nodes with highest number of incoming arcs:\n    NodeQueue q = new NodeQueue(topN);\n\n    // TODO: we could use more RAM efficient selection algo here...\n    NodeAndInCount bottom = null;\n    for(int node=0; node<inCounts.size(); node++) {\n      if (inCounts.get(node) >= minInCountDeref) {\n        if (bottom == null) {\n          q.add(new NodeAndInCount(node, (int) inCounts.get(node)));\n          if (q.size() == topN) {\n            bottom = q.top();\n          }\n        } else if (inCounts.get(node) > bottom.count) {\n          q.insertWithOverflow(new NodeAndInCount(node, (int) inCounts.get(node)));\n        }\n      }\n    }\n\n    // Free up RAM:\n    inCounts = null;\n\n    final Map<Integer,Integer> topNodeMap = new HashMap<Integer,Integer>();\n    for(int downTo=q.size()-1;downTo>=0;downTo--) {\n      NodeAndInCount n = q.pop();\n      topNodeMap.put(n.node, downTo);\n      //System.out.println(\"map node=\" + n.node + \" inCount=\" + n.count + \" to newID=\" + downTo);\n    }\n\n    // +1 because node ords start at 1 (0 is reserved as stop node):\n    final GrowableWriter newNodeAddress = new GrowableWriter(\n                    PackedInts.bitsRequired(this.bytes.getPosition()), 1 + nodeCount, acceptableOverheadRatio);\n\n    // Fill initial coarse guess:\n    for(int node=1;node<=nodeCount;node++) {\n      newNodeAddress.set(node, 1 + this.bytes.getPosition() - nodeAddress.get(node));\n    }\n\n    int absCount;\n    int deltaCount;\n    int topCount;\n    int nextCount;\n\n    FST<T> fst;\n\n    // Iterate until we converge:\n    while(true) {\n\n      //System.out.println(\"\\nITER\");\n      boolean changed = false;\n\n      // for assert:\n      boolean negDelta = false;\n\n      fst = new FST<T>(inputType, outputs);\n      \n      final BytesStore writer = fst.bytes;\n\n      // Skip 0 byte since 0 is reserved target:\n      writer.writeByte((byte) 0);\n\n      fst.arcWithOutputCount = 0;\n      fst.nodeCount = 0;\n      fst.arcCount = 0;\n\n      absCount = deltaCount = topCount = nextCount = 0;\n\n      int changedCount = 0;\n\n      int addressError = 0;\n\n      //int totWasted = 0;\n\n      // Since we re-reverse the bytes, we now write the\n      // nodes backwards, so that BIT_TARGET_NEXT is\n      // unchanged:\n      for(int node=nodeCount;node>=1;node--) {\n        fst.nodeCount++;\n        final int address = writer.getPosition();\n\n        //System.out.println(\"  node: \" + node + \" address=\" + address);\n        if (address != newNodeAddress.get(node)) {\n          addressError = address - (int) newNodeAddress.get(node);\n          //System.out.println(\"    change: \" + (address - newNodeAddress[node]));\n          changed = true;\n          newNodeAddress.set(node, address);\n          changedCount++;\n        }\n\n        int nodeArcCount = 0;\n        int bytesPerArc = 0;\n\n        boolean retry = false;\n\n        // for assert:\n        boolean anyNegDelta = false;\n\n        // Retry loop: possibly iterate more than once, if\n        // this is an array'd node and bytesPerArc changes:\n        writeNode:\n        while(true) { // retry writing this node\n          assert buffer.getFilePointer() == 0;\n          //System.out.println(\"  cycle: retry\");\n          readFirstRealTargetArc(node, arc, r);\n\n          final boolean useArcArray = arc.bytesPerArc != 0;\n          if (useArcArray) {\n            // Write false first arc:\n            if (bytesPerArc == 0) {\n              bytesPerArc = arc.bytesPerArc;\n            }\n            buffer.writeByte(ARCS_AS_FIXED_ARRAY);\n            buffer.writeVInt(arc.numArcs);\n            buffer.writeVInt(bytesPerArc);\n            //System.out.println(\"node \" + node + \": \" + arc.numArcs + \" arcs\");\n          }\n\n          int maxBytesPerArc = 0;\n          //int wasted = 0;\n          while(true) {  // iterate over all arcs for this node\n            //System.out.println(\"    cycle next arc\");\n\n            final int arcStartPos = (int) buffer.getFilePointer();\n            nodeArcCount++;\n\n            byte flags = 0;\n\n            if (arc.isLast()) {\n              flags += BIT_LAST_ARC;\n            }\n            /*\n            if (!useArcArray && nodeUpto < nodes.length-1 && arc.target == nodes[nodeUpto+1]) {\n              flags += BIT_TARGET_NEXT;\n            }\n            */\n            if (!useArcArray && node != 1 && arc.target == node-1) {\n              flags += BIT_TARGET_NEXT;\n              if (!retry) {\n                nextCount++;\n              }\n            }\n            if (arc.isFinal()) {\n              flags += BIT_FINAL_ARC;\n              if (arc.nextFinalOutput != NO_OUTPUT) {\n                flags += BIT_ARC_HAS_FINAL_OUTPUT;\n              }\n            } else {\n              assert arc.nextFinalOutput == NO_OUTPUT;\n            }\n            if (!targetHasArcs(arc)) {\n              flags += BIT_STOP_NODE;\n            }\n\n            if (arc.output != NO_OUTPUT) {\n              flags += BIT_ARC_HAS_OUTPUT;\n            }\n\n            final Integer ptr;\n            final int absPtr;\n            final boolean doWriteTarget = targetHasArcs(arc) && (flags & BIT_TARGET_NEXT) == 0;\n            if (doWriteTarget) {\n\n              ptr = topNodeMap.get(arc.target);\n              if (ptr != null) {\n                absPtr = ptr;\n              } else {\n                absPtr = topNodeMap.size() + (int) newNodeAddress.get(arc.target) + addressError;\n              }\n\n              int delta = (int) (newNodeAddress.get(arc.target) + addressError - buffer.getFilePointer() - address - 2);\n              if (delta < 0) {\n                //System.out.println(\"neg: \" + delta);\n                anyNegDelta = true;\n                delta = 0;\n              }\n\n              if (delta < absPtr) {\n                flags |= BIT_TARGET_DELTA;\n              }\n            } else {\n              ptr = null;\n              absPtr = 0;\n            }\n\n            buffer.writeByte(flags);\n            fst.writeLabel(buffer, arc.label);\n\n            if (arc.output != NO_OUTPUT) {\n              outputs.write(arc.output, buffer);\n              if (!retry) {\n                fst.arcWithOutputCount++;\n              }\n            }\n            if (arc.nextFinalOutput != NO_OUTPUT) {\n              outputs.writeFinalOutput(arc.nextFinalOutput, buffer);\n            }\n\n            if (doWriteTarget) {\n\n              int delta = (int) (newNodeAddress.get(arc.target) + addressError - buffer.getFilePointer() - address);\n              if (delta < 0) {\n                anyNegDelta = true;\n                //System.out.println(\"neg: \" + delta);\n                delta = 0;\n              }\n\n              if (flag(flags, BIT_TARGET_DELTA)) {\n                //System.out.println(\"        delta\");\n                buffer.writeVInt(delta);\n                if (!retry) {\n                  deltaCount++;\n                }\n              } else {\n                /*\n                if (ptr != null) {\n                  System.out.println(\"        deref\");\n                } else {\n                  System.out.println(\"        abs\");\n                }\n                */\n                buffer.writeVInt(absPtr);\n                if (!retry) {\n                  if (absPtr >= topNodeMap.size()) {\n                    absCount++;\n                  } else {\n                    topCount++;\n                  }\n                }\n              }\n            }\n\n            if (useArcArray) {\n              final int arcBytes = (int) (buffer.getFilePointer() - arcStartPos);\n              //System.out.println(\"  \" + arcBytes + \" bytes\");\n              maxBytesPerArc = Math.max(maxBytesPerArc, arcBytes);\n              // NOTE: this may in fact go \"backwards\", if\n              // somehow (rarely, possibly never) we use\n              // more bytesPerArc in this rewrite than the\n              // incoming FST did... but in this case we\n              // will retry (below) so it's OK to ovewrite\n              // bytes:\n              //wasted += bytesPerArc - arcBytes;\n              int skip = (int) (arcStartPos + bytesPerArc - buffer.getFilePointer());\n              while(skip > 0) {\n                buffer.writeByte((byte) 0);\n                skip--;\n              }\n            }\n\n            if (arc.isLast()) {\n              break;\n            }\n\n            readNextRealArc(arc, r);\n          }\n\n          if (useArcArray) {\n            if (maxBytesPerArc == bytesPerArc || (retry && maxBytesPerArc <= bytesPerArc)) {\n              // converged\n              //System.out.println(\"  bba=\" + bytesPerArc + \" wasted=\" + wasted);\n              //totWasted += wasted;\n              break;\n            }\n          } else {\n            break;\n          }\n\n          //System.out.println(\"  retry this node maxBytesPerArc=\" + maxBytesPerArc + \" vs \" + bytesPerArc);\n\n          // Retry:\n          bytesPerArc = maxBytesPerArc;\n          buffer.reset();\n          nodeArcCount = 0;\n          retry = true;\n          anyNegDelta = false;\n        }\n\n        if (bufferBytes.length < (int) buffer.getFilePointer()) {\n          bufferBytes = ArrayUtil.grow(bufferBytes, (int) buffer.getFilePointer());\n        }\n        buffer.writeTo(bufferBytes, 0);\n        writer.writeBytes(bufferBytes, 0, (int) buffer.getFilePointer());\n        buffer.reset();\n\n        negDelta |= anyNegDelta;\n\n        fst.arcCount += nodeArcCount;\n      }\n\n      if (!changed) {\n        // We don't renumber the nodes (just reverse their\n        // order) so nodes should only point forward to\n        // other nodes because we only produce acyclic FSTs\n        // w/ nodes only pointing \"forwards\":\n        assert !negDelta;\n        //System.out.println(\"TOT wasted=\" + totWasted);\n        // Converged!\n        break;\n      }\n      //System.out.println(\"  \" + changedCount + \" of \" + fst.nodeCount + \" changed; retry\");\n    }\n\n    long maxAddress = 0;\n    for (int key : topNodeMap.keySet()) {\n      maxAddress = Math.max(maxAddress, newNodeAddress.get(key));\n    }\n\n    PackedInts.Mutable nodeRefToAddressIn = PackedInts.getMutable(topNodeMap.size(),\n        PackedInts.bitsRequired(maxAddress), acceptableOverheadRatio);\n    for(Map.Entry<Integer,Integer> ent : topNodeMap.entrySet()) {\n      nodeRefToAddressIn.set(ent.getValue(), newNodeAddress.get(ent.getKey()));\n    }\n    fst.nodeRefToAddress = nodeRefToAddressIn;\n    \n    fst.startNode = (int) newNodeAddress.get(startNode);\n    //System.out.println(\"new startNode=\" + fst.startNode + \" old startNode=\" + startNode);\n\n    if (emptyOutput != null) {\n      fst.setEmptyOutput(emptyOutput);\n    }\n\n    assert fst.nodeCount == nodeCount: \"fst.nodeCount=\" + fst.nodeCount + \" nodeCount=\" + nodeCount;\n    assert fst.arcCount == arcCount;\n    assert fst.arcWithOutputCount == arcWithOutputCount: \"fst.arcWithOutputCount=\" + fst.arcWithOutputCount + \" arcWithOutputCount=\" + arcWithOutputCount;\n\n    fst.bytes.finish();\n    fst.cacheRootArcs();\n\n    //final int size = fst.sizeInBytes();\n    //System.out.println(\"nextCount=\" + nextCount + \" topCount=\" + topCount + \" deltaCount=\" + deltaCount + \" absCount=\" + absCount);\n\n    return fst;\n  }\n\n","sourceOld":"  /** Expert: creates an FST by packing this one.  This\n   *  process requires substantial additional RAM (currently\n   *  up to ~8 bytes per node depending on\n   *  <code>acceptableOverheadRatio</code>), but then should\n   *  produce a smaller FST.\n   *\n   *  <p>The implementation of this method uses ideas from\n   *  <a target=\"_blank\" href=\"http://www.cs.put.poznan.pl/dweiss/site/publications/download/fsacomp.pdf\">Smaller Representation of Finite State Automata</a>,\n   *  which describes techniques to reduce the size of a FST.\n   *  However, this is not a strict implementation of the\n   *  algorithms described in this paper.\n   */\n  FST<T> pack(int minInCountDeref, int maxDerefNodes, float acceptableOverheadRatio) throws IOException {\n\n    // TODO: other things to try\n    //   - renumber the nodes to get more next / better locality?\n    //   - allow multiple input labels on an arc, so\n    //     singular chain of inputs can take one arc (on\n    //     wikipedia terms this could save another ~6%)\n    //   - in the ord case, the output '1' is presumably\n    //     very common (after NO_OUTPUT)... maybe use a bit\n    //     for it..?\n    //   - use spare bits in flags.... for top few labels /\n    //     outputs / targets\n\n    if (nodeAddress == null) {\n      throw new IllegalArgumentException(\"this FST was not built with willPackFST=true\");\n    }\n\n    Arc<T> arc = new Arc<T>();\n\n    final BytesReader r = getBytesReader(0);\n\n    final int topN = Math.min(maxDerefNodes, inCounts.size());\n\n    // Find top nodes with highest number of incoming arcs:\n    NodeQueue q = new NodeQueue(topN);\n\n    // TODO: we could use more RAM efficient selection algo here...\n    NodeAndInCount bottom = null;\n    for(int node=0; node<inCounts.size(); node++) {\n      if (inCounts.get(node) >= minInCountDeref) {\n        if (bottom == null) {\n          q.add(new NodeAndInCount(node, (int) inCounts.get(node)));\n          if (q.size() == topN) {\n            bottom = q.top();\n          }\n        } else if (inCounts.get(node) > bottom.count) {\n          q.insertWithOverflow(new NodeAndInCount(node, (int) inCounts.get(node)));\n        }\n      }\n    }\n\n    // Free up RAM:\n    inCounts = null;\n\n    final Map<Integer,Integer> topNodeMap = new HashMap<Integer,Integer>();\n    for(int downTo=q.size()-1;downTo>=0;downTo--) {\n      NodeAndInCount n = q.pop();\n      topNodeMap.put(n.node, downTo);\n      //System.out.println(\"map node=\" + n.node + \" inCount=\" + n.count + \" to newID=\" + downTo);\n    }\n\n    final FST<T> fst = new FST<T>(inputType, null, outputs);\n\n    final BytesWriter writer = fst.writer;\n\n    // +1 because node ords start at 1 (0 is reserved as stop node):\n    final GrowableWriter newNodeAddress = new GrowableWriter(\n        PackedInts.bitsRequired(bytes.length), 1 + nodeCount, acceptableOverheadRatio);\n\n    // Fill initial coarse guess:\n    for(int node=1;node<=nodeCount;node++) {\n      newNodeAddress.set(node, 1 + bytes.length - nodeAddress.get(node));\n    }\n\n    int absCount;\n    int deltaCount;\n    int topCount;\n    int nextCount;\n\n    // Iterate until we converge:\n    while(true) {\n\n      //System.out.println(\"\\nITER\");\n      boolean changed = false;\n\n      // for assert:\n      boolean negDelta = false;\n\n      writer.setPosition(0);\n      // Skip 0 byte since 0 is reserved target:\n      writer.writeByte((byte) 0);\n\n      fst.arcWithOutputCount = 0;\n      fst.nodeCount = 0;\n      fst.arcCount = 0;\n\n      absCount = deltaCount = topCount = nextCount = 0;\n\n      int changedCount = 0;\n\n      int addressError = 0;\n\n      //int totWasted = 0;\n\n      // Since we re-reverse the bytes, we now write the\n      // nodes backwards, so that BIT_TARGET_NEXT is\n      // unchanged:\n      for(int node=nodeCount;node>=1;node--) {\n        fst.nodeCount++;\n        final int address = writer.getPosition();\n        //System.out.println(\"  node: \" + node + \" address=\" + address);\n        if (address != newNodeAddress.get(node)) {\n          addressError = address - (int) newNodeAddress.get(node);\n          //System.out.println(\"    change: \" + (address - newNodeAddress[node]));\n          changed = true;\n          newNodeAddress.set(node, address);\n          changedCount++;\n        }\n\n        int nodeArcCount = 0;\n        int bytesPerArc = 0;\n\n        boolean retry = false;\n\n        // for assert:\n        boolean anyNegDelta = false;\n\n        // Retry loop: possibly iterate more than once, if\n        // this is an array'd node and bytesPerArc changes:\n        writeNode:\n        while(true) { // retry writing this node\n\n          readFirstRealTargetArc(node, arc, r);\n\n          final boolean useArcArray = arc.bytesPerArc != 0;\n          if (useArcArray) {\n            // Write false first arc:\n            if (bytesPerArc == 0) {\n              bytesPerArc = arc.bytesPerArc;\n            }\n            writer.writeByte(ARCS_AS_FIXED_ARRAY);\n            writer.writeVInt(arc.numArcs);\n            writer.writeVInt(bytesPerArc);\n            //System.out.println(\"node \" + node + \": \" + arc.numArcs + \" arcs\");\n          }\n\n          int maxBytesPerArc = 0;\n          //int wasted = 0;\n          while(true) {  // iterate over all arcs for this node\n\n            //System.out.println(\"    arc label=\" + arc.label + \" target=\" + arc.target + \" pos=\" + writer.posWrite);\n            final int arcStartPos = writer.getPosition();\n            nodeArcCount++;\n\n            byte flags = 0;\n\n            if (arc.isLast()) {\n              flags += BIT_LAST_ARC;\n            }\n            /*\n            if (!useArcArray && nodeUpto < nodes.length-1 && arc.target == nodes[nodeUpto+1]) {\n              flags += BIT_TARGET_NEXT;\n            }\n            */\n            if (!useArcArray && node != 1 && arc.target == node-1) {\n              flags += BIT_TARGET_NEXT;\n              if (!retry) {\n                nextCount++;\n              }\n            }\n            if (arc.isFinal()) {\n              flags += BIT_FINAL_ARC;\n              if (arc.nextFinalOutput != NO_OUTPUT) {\n                flags += BIT_ARC_HAS_FINAL_OUTPUT;\n              }\n            } else {\n              assert arc.nextFinalOutput == NO_OUTPUT;\n            }\n            if (!targetHasArcs(arc)) {\n              flags += BIT_STOP_NODE;\n            }\n\n            if (arc.output != NO_OUTPUT) {\n              flags += BIT_ARC_HAS_OUTPUT;\n            }\n\n            final Integer ptr;\n            final int absPtr;\n            final boolean doWriteTarget = targetHasArcs(arc) && (flags & BIT_TARGET_NEXT) == 0;\n            if (doWriteTarget) {\n\n              ptr = topNodeMap.get(arc.target);\n              if (ptr != null) {\n                absPtr = ptr;\n              } else {\n                absPtr = topNodeMap.size() + (int) newNodeAddress.get(arc.target) + addressError;\n              }\n\n              int delta = (int) newNodeAddress.get(arc.target) + addressError - writer.getPosition() - 2;\n              if (delta < 0) {\n                //System.out.println(\"neg: \" + delta);\n                anyNegDelta = true;\n                delta = 0;\n              }\n\n              if (delta < absPtr) {\n                flags |= BIT_TARGET_DELTA;\n              }\n            } else {\n              ptr = null;\n              absPtr = 0;\n            }\n\n            writer.writeByte(flags);\n            fst.writeLabel(arc.label);\n\n            if (arc.output != NO_OUTPUT) {\n              outputs.write(arc.output, writer);\n              if (!retry) {\n                fst.arcWithOutputCount++;\n              }\n            }\n            if (arc.nextFinalOutput != NO_OUTPUT) {\n              outputs.writeFinalOutput(arc.nextFinalOutput, writer);\n            }\n\n            if (doWriteTarget) {\n\n              int delta = (int) newNodeAddress.get(arc.target) + addressError - writer.getPosition();\n              if (delta < 0) {\n                anyNegDelta = true;\n                //System.out.println(\"neg: \" + delta);\n                delta = 0;\n              }\n\n              if (flag(flags, BIT_TARGET_DELTA)) {\n                //System.out.println(\"        delta\");\n                writer.writeVInt(delta);\n                if (!retry) {\n                  deltaCount++;\n                }\n              } else {\n                /*\n                if (ptr != null) {\n                  System.out.println(\"        deref\");\n                } else {\n                  System.out.println(\"        abs\");\n                }\n                */\n                writer.writeVInt(absPtr);\n                if (!retry) {\n                  if (absPtr >= topNodeMap.size()) {\n                    absCount++;\n                  } else {\n                    topCount++;\n                  }\n                }\n              }\n            }\n\n            if (useArcArray) {\n              final int arcBytes = writer.getPosition() - arcStartPos;\n              //System.out.println(\"  \" + arcBytes + \" bytes\");\n              maxBytesPerArc = Math.max(maxBytesPerArc, arcBytes);\n              // NOTE: this may in fact go \"backwards\", if\n              // somehow (rarely, possibly never) we use\n              // more bytesPerArc in this rewrite than the\n              // incoming FST did... but in this case we\n              // will retry (below) so it's OK to ovewrite\n              // bytes:\n              //wasted += bytesPerArc - arcBytes;\n              writer.setPosition(arcStartPos + bytesPerArc);\n            }\n\n            if (arc.isLast()) {\n              break;\n            }\n\n            readNextRealArc(arc, r);\n          }\n\n          if (useArcArray) {\n            if (maxBytesPerArc == bytesPerArc || (retry && maxBytesPerArc <= bytesPerArc)) {\n              // converged\n              //System.out.println(\"  bba=\" + bytesPerArc + \" wasted=\" + wasted);\n              //totWasted += wasted;\n              break;\n            }\n          } else {\n            break;\n          }\n\n          //System.out.println(\"  retry this node maxBytesPerArc=\" + maxBytesPerArc + \" vs \" + bytesPerArc);\n\n          // Retry:\n          bytesPerArc = maxBytesPerArc;\n          writer.setPosition(address);\n          nodeArcCount = 0;\n          retry = true;\n          anyNegDelta = false;\n        }\n        negDelta |= anyNegDelta;\n\n        fst.arcCount += nodeArcCount;\n      }\n\n      if (!changed) {\n        // We don't renumber the nodes (just reverse their\n        // order) so nodes should only point forward to\n        // other nodes because we only produce acyclic FSTs\n        // w/ nodes only pointing \"forwards\":\n        assert !negDelta;\n        //System.out.println(\"TOT wasted=\" + totWasted);\n        // Converged!\n        break;\n      }\n      //System.out.println(\"  \" + changedCount + \" of \" + fst.nodeCount + \" changed; retry\");\n    }\n\n    long maxAddress = 0;\n    for (int key : topNodeMap.keySet()) {\n      maxAddress = Math.max(maxAddress, newNodeAddress.get(key));\n    }\n\n    PackedInts.Mutable nodeRefToAddressIn = PackedInts.getMutable(topNodeMap.size(),\n        PackedInts.bitsRequired(maxAddress), acceptableOverheadRatio);\n    for(Map.Entry<Integer,Integer> ent : topNodeMap.entrySet()) {\n      nodeRefToAddressIn.set(ent.getValue(), newNodeAddress.get(ent.getKey()));\n    }\n    fst.nodeRefToAddress = nodeRefToAddressIn;\n    \n\n    fst.startNode = (int) newNodeAddress.get(startNode);\n    //System.out.println(\"new startNode=\" + fst.startNode + \" old startNode=\" + startNode);\n\n    if (emptyOutput != null) {\n      fst.setEmptyOutput(emptyOutput);\n    }\n\n    assert fst.nodeCount == nodeCount: \"fst.nodeCount=\" + fst.nodeCount + \" nodeCount=\" + nodeCount;\n    assert fst.arcCount == arcCount;\n    assert fst.arcWithOutputCount == arcWithOutputCount: \"fst.arcWithOutputCount=\" + fst.arcWithOutputCount + \" arcWithOutputCount=\" + arcWithOutputCount;\n    \n    final byte[] finalBytes = new byte[writer.getPosition()];\n    //System.out.println(\"resize \" + fst.bytes.length + \" down to \" + writer.posWrite);\n    System.arraycopy(fst.bytes, 0, finalBytes, 0, writer.getPosition());\n    fst.bytes = finalBytes;\n    fst.cacheRootArcs();\n\n    //final int size = fst.sizeInBytes();\n    //System.out.println(\"nextCount=\" + nextCount + \" topCount=\" + topCount + \" deltaCount=\" + deltaCount + \" absCount=\" + absCount);\n\n    return fst;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d5cf2203ec06da56386fb6f0054d7b11e456caed","date":1358008787,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#pack(int,int,float).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#pack(int,int,float).mjava","sourceNew":"  /** Expert: creates an FST by packing this one.  This\n   *  process requires substantial additional RAM (currently\n   *  up to ~8 bytes per node depending on\n   *  <code>acceptableOverheadRatio</code>), but then should\n   *  produce a smaller FST.\n   *\n   *  <p>The implementation of this method uses ideas from\n   *  <a target=\"_blank\" href=\"http://www.cs.put.poznan.pl/dweiss/site/publications/download/fsacomp.pdf\">Smaller Representation of Finite State Automata</a>,\n   *  which describes techniques to reduce the size of a FST.\n   *  However, this is not a strict implementation of the\n   *  algorithms described in this paper.\n   */\n  FST<T> pack(int minInCountDeref, int maxDerefNodes, float acceptableOverheadRatio) throws IOException {\n\n    // TODO: other things to try\n    //   - renumber the nodes to get more next / better locality?\n    //   - allow multiple input labels on an arc, so\n    //     singular chain of inputs can take one arc (on\n    //     wikipedia terms this could save another ~6%)\n    //   - in the ord case, the output '1' is presumably\n    //     very common (after NO_OUTPUT)... maybe use a bit\n    //     for it..?\n    //   - use spare bits in flags.... for top few labels /\n    //     outputs / targets\n\n    if (nodeAddress == null) {\n      throw new IllegalArgumentException(\"this FST was not built with willPackFST=true\");\n    }\n\n    final RAMOutputStream buffer = new RAMOutputStream();\n    byte[] bufferBytes = new byte[64];\n\n    Arc<T> arc = new Arc<T>();\n\n    final BytesReader r = getBytesReader(0);\n\n    final int topN = Math.min(maxDerefNodes, inCounts.size());\n\n    // Find top nodes with highest number of incoming arcs:\n    NodeQueue q = new NodeQueue(topN);\n\n    // TODO: we could use more RAM efficient selection algo here...\n    NodeAndInCount bottom = null;\n    for(int node=0; node<inCounts.size(); node++) {\n      if (inCounts.get(node) >= minInCountDeref) {\n        if (bottom == null) {\n          q.add(new NodeAndInCount(node, (int) inCounts.get(node)));\n          if (q.size() == topN) {\n            bottom = q.top();\n          }\n        } else if (inCounts.get(node) > bottom.count) {\n          q.insertWithOverflow(new NodeAndInCount(node, (int) inCounts.get(node)));\n        }\n      }\n    }\n\n    // Free up RAM:\n    inCounts = null;\n\n    final Map<Integer,Integer> topNodeMap = new HashMap<Integer,Integer>();\n    for(int downTo=q.size()-1;downTo>=0;downTo--) {\n      NodeAndInCount n = q.pop();\n      topNodeMap.put(n.node, downTo);\n      //System.out.println(\"map node=\" + n.node + \" inCount=\" + n.count + \" to newID=\" + downTo);\n    }\n\n    // +1 because node ords start at 1 (0 is reserved as stop node):\n    final GrowableWriter newNodeAddress = new GrowableWriter(\n                    PackedInts.bitsRequired(this.bytes.getPosition()), 1 + nodeCount, acceptableOverheadRatio);\n\n    // Fill initial coarse guess:\n    for(int node=1;node<=nodeCount;node++) {\n      newNodeAddress.set(node, 1 + this.bytes.getPosition() - nodeAddress.get(node));\n    }\n\n    int absCount;\n    int deltaCount;\n    int topCount;\n    int nextCount;\n\n    FST<T> fst;\n\n    // Iterate until we converge:\n    while(true) {\n\n      //System.out.println(\"\\nITER\");\n      boolean changed = false;\n\n      // for assert:\n      boolean negDelta = false;\n\n      fst = new FST<T>(inputType, outputs);\n      \n      final BytesStore writer = fst.bytes;\n\n      // Skip 0 byte since 0 is reserved target:\n      writer.writeByte((byte) 0);\n\n      fst.arcWithOutputCount = 0;\n      fst.nodeCount = 0;\n      fst.arcCount = 0;\n\n      absCount = deltaCount = topCount = nextCount = 0;\n\n      int changedCount = 0;\n\n      int addressError = 0;\n\n      //int totWasted = 0;\n\n      // Since we re-reverse the bytes, we now write the\n      // nodes backwards, so that BIT_TARGET_NEXT is\n      // unchanged:\n      for(int node=nodeCount;node>=1;node--) {\n        fst.nodeCount++;\n        final int address = writer.getPosition();\n\n        //System.out.println(\"  node: \" + node + \" address=\" + address);\n        if (address != newNodeAddress.get(node)) {\n          addressError = address - (int) newNodeAddress.get(node);\n          //System.out.println(\"    change: \" + (address - newNodeAddress[node]));\n          changed = true;\n          newNodeAddress.set(node, address);\n          changedCount++;\n        }\n\n        int nodeArcCount = 0;\n        int bytesPerArc = 0;\n\n        boolean retry = false;\n\n        // for assert:\n        boolean anyNegDelta = false;\n\n        // Retry loop: possibly iterate more than once, if\n        // this is an array'd node and bytesPerArc changes:\n        writeNode:\n        while(true) { // retry writing this node\n          assert buffer.getFilePointer() == 0;\n          //System.out.println(\"  cycle: retry\");\n          readFirstRealTargetArc(node, arc, r);\n\n          final boolean useArcArray = arc.bytesPerArc != 0;\n          if (useArcArray) {\n            // Write false first arc:\n            if (bytesPerArc == 0) {\n              bytesPerArc = arc.bytesPerArc;\n            }\n            buffer.writeByte(ARCS_AS_FIXED_ARRAY);\n            buffer.writeVInt(arc.numArcs);\n            buffer.writeVInt(bytesPerArc);\n            //System.out.println(\"node \" + node + \": \" + arc.numArcs + \" arcs\");\n          }\n\n          int maxBytesPerArc = 0;\n          //int wasted = 0;\n          while(true) {  // iterate over all arcs for this node\n            //System.out.println(\"    cycle next arc\");\n\n            final int arcStartPos = (int) buffer.getFilePointer();\n            nodeArcCount++;\n\n            byte flags = 0;\n\n            if (arc.isLast()) {\n              flags += BIT_LAST_ARC;\n            }\n            /*\n            if (!useArcArray && nodeUpto < nodes.length-1 && arc.target == nodes[nodeUpto+1]) {\n              flags += BIT_TARGET_NEXT;\n            }\n            */\n            if (!useArcArray && node != 1 && arc.target == node-1) {\n              flags += BIT_TARGET_NEXT;\n              if (!retry) {\n                nextCount++;\n              }\n            }\n            if (arc.isFinal()) {\n              flags += BIT_FINAL_ARC;\n              if (arc.nextFinalOutput != NO_OUTPUT) {\n                flags += BIT_ARC_HAS_FINAL_OUTPUT;\n              }\n            } else {\n              assert arc.nextFinalOutput == NO_OUTPUT;\n            }\n            if (!targetHasArcs(arc)) {\n              flags += BIT_STOP_NODE;\n            }\n\n            if (arc.output != NO_OUTPUT) {\n              flags += BIT_ARC_HAS_OUTPUT;\n            }\n\n            final Integer ptr;\n            final int absPtr;\n            final boolean doWriteTarget = targetHasArcs(arc) && (flags & BIT_TARGET_NEXT) == 0;\n            if (doWriteTarget) {\n\n              ptr = topNodeMap.get(arc.target);\n              if (ptr != null) {\n                absPtr = ptr;\n              } else {\n                absPtr = topNodeMap.size() + (int) newNodeAddress.get(arc.target) + addressError;\n              }\n\n              int delta = (int) (newNodeAddress.get(arc.target) + addressError - buffer.getFilePointer() - address - 2);\n              if (delta < 0) {\n                //System.out.println(\"neg: \" + delta);\n                anyNegDelta = true;\n                delta = 0;\n              }\n\n              if (delta < absPtr) {\n                flags |= BIT_TARGET_DELTA;\n              }\n            } else {\n              ptr = null;\n              absPtr = 0;\n            }\n\n            assert flags != ARCS_AS_FIXED_ARRAY;\n            buffer.writeByte(flags);\n\n            fst.writeLabel(buffer, arc.label);\n\n            if (arc.output != NO_OUTPUT) {\n              outputs.write(arc.output, buffer);\n              if (!retry) {\n                fst.arcWithOutputCount++;\n              }\n            }\n            if (arc.nextFinalOutput != NO_OUTPUT) {\n              outputs.writeFinalOutput(arc.nextFinalOutput, buffer);\n            }\n\n            if (doWriteTarget) {\n\n              int delta = (int) (newNodeAddress.get(arc.target) + addressError - buffer.getFilePointer() - address);\n              if (delta < 0) {\n                anyNegDelta = true;\n                //System.out.println(\"neg: \" + delta);\n                delta = 0;\n              }\n\n              if (flag(flags, BIT_TARGET_DELTA)) {\n                //System.out.println(\"        delta\");\n                buffer.writeVInt(delta);\n                if (!retry) {\n                  deltaCount++;\n                }\n              } else {\n                /*\n                if (ptr != null) {\n                  System.out.println(\"        deref\");\n                } else {\n                  System.out.println(\"        abs\");\n                }\n                */\n                buffer.writeVInt(absPtr);\n                if (!retry) {\n                  if (absPtr >= topNodeMap.size()) {\n                    absCount++;\n                  } else {\n                    topCount++;\n                  }\n                }\n              }\n            }\n\n            if (useArcArray) {\n              final int arcBytes = (int) (buffer.getFilePointer() - arcStartPos);\n              //System.out.println(\"  \" + arcBytes + \" bytes\");\n              maxBytesPerArc = Math.max(maxBytesPerArc, arcBytes);\n              // NOTE: this may in fact go \"backwards\", if\n              // somehow (rarely, possibly never) we use\n              // more bytesPerArc in this rewrite than the\n              // incoming FST did... but in this case we\n              // will retry (below) so it's OK to ovewrite\n              // bytes:\n              //wasted += bytesPerArc - arcBytes;\n              int skip = (int) (arcStartPos + bytesPerArc - buffer.getFilePointer());\n              while(skip > 0) {\n                buffer.writeByte((byte) 0);\n                skip--;\n              }\n            }\n\n            if (arc.isLast()) {\n              break;\n            }\n\n            readNextRealArc(arc, r);\n          }\n\n          if (useArcArray) {\n            if (maxBytesPerArc == bytesPerArc || (retry && maxBytesPerArc <= bytesPerArc)) {\n              // converged\n              //System.out.println(\"  bba=\" + bytesPerArc + \" wasted=\" + wasted);\n              //totWasted += wasted;\n              break;\n            }\n          } else {\n            break;\n          }\n\n          //System.out.println(\"  retry this node maxBytesPerArc=\" + maxBytesPerArc + \" vs \" + bytesPerArc);\n\n          // Retry:\n          bytesPerArc = maxBytesPerArc;\n          buffer.reset();\n          nodeArcCount = 0;\n          retry = true;\n          anyNegDelta = false;\n        }\n\n        if (bufferBytes.length < (int) buffer.getFilePointer()) {\n          bufferBytes = ArrayUtil.grow(bufferBytes, (int) buffer.getFilePointer());\n        }\n        buffer.writeTo(bufferBytes, 0);\n        writer.writeBytes(bufferBytes, 0, (int) buffer.getFilePointer());\n        buffer.reset();\n\n        negDelta |= anyNegDelta;\n\n        fst.arcCount += nodeArcCount;\n      }\n\n      if (!changed) {\n        // We don't renumber the nodes (just reverse their\n        // order) so nodes should only point forward to\n        // other nodes because we only produce acyclic FSTs\n        // w/ nodes only pointing \"forwards\":\n        assert !negDelta;\n        //System.out.println(\"TOT wasted=\" + totWasted);\n        // Converged!\n        break;\n      }\n      //System.out.println(\"  \" + changedCount + \" of \" + fst.nodeCount + \" changed; retry\");\n    }\n\n    long maxAddress = 0;\n    for (int key : topNodeMap.keySet()) {\n      maxAddress = Math.max(maxAddress, newNodeAddress.get(key));\n    }\n\n    PackedInts.Mutable nodeRefToAddressIn = PackedInts.getMutable(topNodeMap.size(),\n        PackedInts.bitsRequired(maxAddress), acceptableOverheadRatio);\n    for(Map.Entry<Integer,Integer> ent : topNodeMap.entrySet()) {\n      nodeRefToAddressIn.set(ent.getValue(), newNodeAddress.get(ent.getKey()));\n    }\n    fst.nodeRefToAddress = nodeRefToAddressIn;\n    \n    fst.startNode = (int) newNodeAddress.get(startNode);\n    //System.out.println(\"new startNode=\" + fst.startNode + \" old startNode=\" + startNode);\n\n    if (emptyOutput != null) {\n      fst.setEmptyOutput(emptyOutput);\n    }\n\n    assert fst.nodeCount == nodeCount: \"fst.nodeCount=\" + fst.nodeCount + \" nodeCount=\" + nodeCount;\n    assert fst.arcCount == arcCount;\n    assert fst.arcWithOutputCount == arcWithOutputCount: \"fst.arcWithOutputCount=\" + fst.arcWithOutputCount + \" arcWithOutputCount=\" + arcWithOutputCount;\n\n    fst.bytes.finish();\n    fst.cacheRootArcs();\n\n    //final int size = fst.sizeInBytes();\n    //System.out.println(\"nextCount=\" + nextCount + \" topCount=\" + topCount + \" deltaCount=\" + deltaCount + \" absCount=\" + absCount);\n\n    return fst;\n  }\n\n","sourceOld":"  /** Expert: creates an FST by packing this one.  This\n   *  process requires substantial additional RAM (currently\n   *  up to ~8 bytes per node depending on\n   *  <code>acceptableOverheadRatio</code>), but then should\n   *  produce a smaller FST.\n   *\n   *  <p>The implementation of this method uses ideas from\n   *  <a target=\"_blank\" href=\"http://www.cs.put.poznan.pl/dweiss/site/publications/download/fsacomp.pdf\">Smaller Representation of Finite State Automata</a>,\n   *  which describes techniques to reduce the size of a FST.\n   *  However, this is not a strict implementation of the\n   *  algorithms described in this paper.\n   */\n  FST<T> pack(int minInCountDeref, int maxDerefNodes, float acceptableOverheadRatio) throws IOException {\n\n    // TODO: other things to try\n    //   - renumber the nodes to get more next / better locality?\n    //   - allow multiple input labels on an arc, so\n    //     singular chain of inputs can take one arc (on\n    //     wikipedia terms this could save another ~6%)\n    //   - in the ord case, the output '1' is presumably\n    //     very common (after NO_OUTPUT)... maybe use a bit\n    //     for it..?\n    //   - use spare bits in flags.... for top few labels /\n    //     outputs / targets\n\n    if (nodeAddress == null) {\n      throw new IllegalArgumentException(\"this FST was not built with willPackFST=true\");\n    }\n\n    final RAMOutputStream buffer = new RAMOutputStream();\n    byte[] bufferBytes = new byte[64];\n\n    Arc<T> arc = new Arc<T>();\n\n    final BytesReader r = getBytesReader(0);\n\n    final int topN = Math.min(maxDerefNodes, inCounts.size());\n\n    // Find top nodes with highest number of incoming arcs:\n    NodeQueue q = new NodeQueue(topN);\n\n    // TODO: we could use more RAM efficient selection algo here...\n    NodeAndInCount bottom = null;\n    for(int node=0; node<inCounts.size(); node++) {\n      if (inCounts.get(node) >= minInCountDeref) {\n        if (bottom == null) {\n          q.add(new NodeAndInCount(node, (int) inCounts.get(node)));\n          if (q.size() == topN) {\n            bottom = q.top();\n          }\n        } else if (inCounts.get(node) > bottom.count) {\n          q.insertWithOverflow(new NodeAndInCount(node, (int) inCounts.get(node)));\n        }\n      }\n    }\n\n    // Free up RAM:\n    inCounts = null;\n\n    final Map<Integer,Integer> topNodeMap = new HashMap<Integer,Integer>();\n    for(int downTo=q.size()-1;downTo>=0;downTo--) {\n      NodeAndInCount n = q.pop();\n      topNodeMap.put(n.node, downTo);\n      //System.out.println(\"map node=\" + n.node + \" inCount=\" + n.count + \" to newID=\" + downTo);\n    }\n\n    // +1 because node ords start at 1 (0 is reserved as stop node):\n    final GrowableWriter newNodeAddress = new GrowableWriter(\n                    PackedInts.bitsRequired(this.bytes.getPosition()), 1 + nodeCount, acceptableOverheadRatio);\n\n    // Fill initial coarse guess:\n    for(int node=1;node<=nodeCount;node++) {\n      newNodeAddress.set(node, 1 + this.bytes.getPosition() - nodeAddress.get(node));\n    }\n\n    int absCount;\n    int deltaCount;\n    int topCount;\n    int nextCount;\n\n    FST<T> fst;\n\n    // Iterate until we converge:\n    while(true) {\n\n      //System.out.println(\"\\nITER\");\n      boolean changed = false;\n\n      // for assert:\n      boolean negDelta = false;\n\n      fst = new FST<T>(inputType, outputs);\n      \n      final BytesStore writer = fst.bytes;\n\n      // Skip 0 byte since 0 is reserved target:\n      writer.writeByte((byte) 0);\n\n      fst.arcWithOutputCount = 0;\n      fst.nodeCount = 0;\n      fst.arcCount = 0;\n\n      absCount = deltaCount = topCount = nextCount = 0;\n\n      int changedCount = 0;\n\n      int addressError = 0;\n\n      //int totWasted = 0;\n\n      // Since we re-reverse the bytes, we now write the\n      // nodes backwards, so that BIT_TARGET_NEXT is\n      // unchanged:\n      for(int node=nodeCount;node>=1;node--) {\n        fst.nodeCount++;\n        final int address = writer.getPosition();\n\n        //System.out.println(\"  node: \" + node + \" address=\" + address);\n        if (address != newNodeAddress.get(node)) {\n          addressError = address - (int) newNodeAddress.get(node);\n          //System.out.println(\"    change: \" + (address - newNodeAddress[node]));\n          changed = true;\n          newNodeAddress.set(node, address);\n          changedCount++;\n        }\n\n        int nodeArcCount = 0;\n        int bytesPerArc = 0;\n\n        boolean retry = false;\n\n        // for assert:\n        boolean anyNegDelta = false;\n\n        // Retry loop: possibly iterate more than once, if\n        // this is an array'd node and bytesPerArc changes:\n        writeNode:\n        while(true) { // retry writing this node\n          assert buffer.getFilePointer() == 0;\n          //System.out.println(\"  cycle: retry\");\n          readFirstRealTargetArc(node, arc, r);\n\n          final boolean useArcArray = arc.bytesPerArc != 0;\n          if (useArcArray) {\n            // Write false first arc:\n            if (bytesPerArc == 0) {\n              bytesPerArc = arc.bytesPerArc;\n            }\n            buffer.writeByte(ARCS_AS_FIXED_ARRAY);\n            buffer.writeVInt(arc.numArcs);\n            buffer.writeVInt(bytesPerArc);\n            //System.out.println(\"node \" + node + \": \" + arc.numArcs + \" arcs\");\n          }\n\n          int maxBytesPerArc = 0;\n          //int wasted = 0;\n          while(true) {  // iterate over all arcs for this node\n            //System.out.println(\"    cycle next arc\");\n\n            final int arcStartPos = (int) buffer.getFilePointer();\n            nodeArcCount++;\n\n            byte flags = 0;\n\n            if (arc.isLast()) {\n              flags += BIT_LAST_ARC;\n            }\n            /*\n            if (!useArcArray && nodeUpto < nodes.length-1 && arc.target == nodes[nodeUpto+1]) {\n              flags += BIT_TARGET_NEXT;\n            }\n            */\n            if (!useArcArray && node != 1 && arc.target == node-1) {\n              flags += BIT_TARGET_NEXT;\n              if (!retry) {\n                nextCount++;\n              }\n            }\n            if (arc.isFinal()) {\n              flags += BIT_FINAL_ARC;\n              if (arc.nextFinalOutput != NO_OUTPUT) {\n                flags += BIT_ARC_HAS_FINAL_OUTPUT;\n              }\n            } else {\n              assert arc.nextFinalOutput == NO_OUTPUT;\n            }\n            if (!targetHasArcs(arc)) {\n              flags += BIT_STOP_NODE;\n            }\n\n            if (arc.output != NO_OUTPUT) {\n              flags += BIT_ARC_HAS_OUTPUT;\n            }\n\n            final Integer ptr;\n            final int absPtr;\n            final boolean doWriteTarget = targetHasArcs(arc) && (flags & BIT_TARGET_NEXT) == 0;\n            if (doWriteTarget) {\n\n              ptr = topNodeMap.get(arc.target);\n              if (ptr != null) {\n                absPtr = ptr;\n              } else {\n                absPtr = topNodeMap.size() + (int) newNodeAddress.get(arc.target) + addressError;\n              }\n\n              int delta = (int) (newNodeAddress.get(arc.target) + addressError - buffer.getFilePointer() - address - 2);\n              if (delta < 0) {\n                //System.out.println(\"neg: \" + delta);\n                anyNegDelta = true;\n                delta = 0;\n              }\n\n              if (delta < absPtr) {\n                flags |= BIT_TARGET_DELTA;\n              }\n            } else {\n              ptr = null;\n              absPtr = 0;\n            }\n\n            buffer.writeByte(flags);\n            fst.writeLabel(buffer, arc.label);\n\n            if (arc.output != NO_OUTPUT) {\n              outputs.write(arc.output, buffer);\n              if (!retry) {\n                fst.arcWithOutputCount++;\n              }\n            }\n            if (arc.nextFinalOutput != NO_OUTPUT) {\n              outputs.writeFinalOutput(arc.nextFinalOutput, buffer);\n            }\n\n            if (doWriteTarget) {\n\n              int delta = (int) (newNodeAddress.get(arc.target) + addressError - buffer.getFilePointer() - address);\n              if (delta < 0) {\n                anyNegDelta = true;\n                //System.out.println(\"neg: \" + delta);\n                delta = 0;\n              }\n\n              if (flag(flags, BIT_TARGET_DELTA)) {\n                //System.out.println(\"        delta\");\n                buffer.writeVInt(delta);\n                if (!retry) {\n                  deltaCount++;\n                }\n              } else {\n                /*\n                if (ptr != null) {\n                  System.out.println(\"        deref\");\n                } else {\n                  System.out.println(\"        abs\");\n                }\n                */\n                buffer.writeVInt(absPtr);\n                if (!retry) {\n                  if (absPtr >= topNodeMap.size()) {\n                    absCount++;\n                  } else {\n                    topCount++;\n                  }\n                }\n              }\n            }\n\n            if (useArcArray) {\n              final int arcBytes = (int) (buffer.getFilePointer() - arcStartPos);\n              //System.out.println(\"  \" + arcBytes + \" bytes\");\n              maxBytesPerArc = Math.max(maxBytesPerArc, arcBytes);\n              // NOTE: this may in fact go \"backwards\", if\n              // somehow (rarely, possibly never) we use\n              // more bytesPerArc in this rewrite than the\n              // incoming FST did... but in this case we\n              // will retry (below) so it's OK to ovewrite\n              // bytes:\n              //wasted += bytesPerArc - arcBytes;\n              int skip = (int) (arcStartPos + bytesPerArc - buffer.getFilePointer());\n              while(skip > 0) {\n                buffer.writeByte((byte) 0);\n                skip--;\n              }\n            }\n\n            if (arc.isLast()) {\n              break;\n            }\n\n            readNextRealArc(arc, r);\n          }\n\n          if (useArcArray) {\n            if (maxBytesPerArc == bytesPerArc || (retry && maxBytesPerArc <= bytesPerArc)) {\n              // converged\n              //System.out.println(\"  bba=\" + bytesPerArc + \" wasted=\" + wasted);\n              //totWasted += wasted;\n              break;\n            }\n          } else {\n            break;\n          }\n\n          //System.out.println(\"  retry this node maxBytesPerArc=\" + maxBytesPerArc + \" vs \" + bytesPerArc);\n\n          // Retry:\n          bytesPerArc = maxBytesPerArc;\n          buffer.reset();\n          nodeArcCount = 0;\n          retry = true;\n          anyNegDelta = false;\n        }\n\n        if (bufferBytes.length < (int) buffer.getFilePointer()) {\n          bufferBytes = ArrayUtil.grow(bufferBytes, (int) buffer.getFilePointer());\n        }\n        buffer.writeTo(bufferBytes, 0);\n        writer.writeBytes(bufferBytes, 0, (int) buffer.getFilePointer());\n        buffer.reset();\n\n        negDelta |= anyNegDelta;\n\n        fst.arcCount += nodeArcCount;\n      }\n\n      if (!changed) {\n        // We don't renumber the nodes (just reverse their\n        // order) so nodes should only point forward to\n        // other nodes because we only produce acyclic FSTs\n        // w/ nodes only pointing \"forwards\":\n        assert !negDelta;\n        //System.out.println(\"TOT wasted=\" + totWasted);\n        // Converged!\n        break;\n      }\n      //System.out.println(\"  \" + changedCount + \" of \" + fst.nodeCount + \" changed; retry\");\n    }\n\n    long maxAddress = 0;\n    for (int key : topNodeMap.keySet()) {\n      maxAddress = Math.max(maxAddress, newNodeAddress.get(key));\n    }\n\n    PackedInts.Mutable nodeRefToAddressIn = PackedInts.getMutable(topNodeMap.size(),\n        PackedInts.bitsRequired(maxAddress), acceptableOverheadRatio);\n    for(Map.Entry<Integer,Integer> ent : topNodeMap.entrySet()) {\n      nodeRefToAddressIn.set(ent.getValue(), newNodeAddress.get(ent.getKey()));\n    }\n    fst.nodeRefToAddress = nodeRefToAddressIn;\n    \n    fst.startNode = (int) newNodeAddress.get(startNode);\n    //System.out.println(\"new startNode=\" + fst.startNode + \" old startNode=\" + startNode);\n\n    if (emptyOutput != null) {\n      fst.setEmptyOutput(emptyOutput);\n    }\n\n    assert fst.nodeCount == nodeCount: \"fst.nodeCount=\" + fst.nodeCount + \" nodeCount=\" + nodeCount;\n    assert fst.arcCount == arcCount;\n    assert fst.arcWithOutputCount == arcWithOutputCount: \"fst.arcWithOutputCount=\" + fst.arcWithOutputCount + \" arcWithOutputCount=\" + arcWithOutputCount;\n\n    fst.bytes.finish();\n    fst.cacheRootArcs();\n\n    //final int size = fst.sizeInBytes();\n    //System.out.println(\"nextCount=\" + nextCount + \" topCount=\" + topCount + \" deltaCount=\" + deltaCount + \" absCount=\" + absCount);\n\n    return fst;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"73e44327cb5401cc5098da2f488c899954c9bfbc","date":1358092175,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#pack(int,int,float).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#pack(int,int,float).mjava","sourceNew":"  /** Expert: creates an FST by packing this one.  This\n   *  process requires substantial additional RAM (currently\n   *  up to ~8 bytes per node depending on\n   *  <code>acceptableOverheadRatio</code>), but then should\n   *  produce a smaller FST.\n   *\n   *  <p>The implementation of this method uses ideas from\n   *  <a target=\"_blank\" href=\"http://www.cs.put.poznan.pl/dweiss/site/publications/download/fsacomp.pdf\">Smaller Representation of Finite State Automata</a>,\n   *  which describes techniques to reduce the size of a FST.\n   *  However, this is not a strict implementation of the\n   *  algorithms described in this paper.\n   */\n  FST<T> pack(int minInCountDeref, int maxDerefNodes, float acceptableOverheadRatio) throws IOException {\n\n    // TODO: other things to try\n    //   - renumber the nodes to get more next / better locality?\n    //   - allow multiple input labels on an arc, so\n    //     singular chain of inputs can take one arc (on\n    //     wikipedia terms this could save another ~6%)\n    //   - in the ord case, the output '1' is presumably\n    //     very common (after NO_OUTPUT)... maybe use a bit\n    //     for it..?\n    //   - use spare bits in flags.... for top few labels /\n    //     outputs / targets\n\n    if (nodeAddress == null) {\n      throw new IllegalArgumentException(\"this FST was not built with willPackFST=true\");\n    }\n\n    Arc<T> arc = new Arc<T>();\n\n    final BytesReader r = getBytesReader(0);\n\n    final int topN = Math.min(maxDerefNodes, inCounts.size());\n\n    // Find top nodes with highest number of incoming arcs:\n    NodeQueue q = new NodeQueue(topN);\n\n    // TODO: we could use more RAM efficient selection algo here...\n    NodeAndInCount bottom = null;\n    for(int node=0; node<inCounts.size(); node++) {\n      if (inCounts.get(node) >= minInCountDeref) {\n        if (bottom == null) {\n          q.add(new NodeAndInCount(node, (int) inCounts.get(node)));\n          if (q.size() == topN) {\n            bottom = q.top();\n          }\n        } else if (inCounts.get(node) > bottom.count) {\n          q.insertWithOverflow(new NodeAndInCount(node, (int) inCounts.get(node)));\n        }\n      }\n    }\n\n    // Free up RAM:\n    inCounts = null;\n\n    final Map<Integer,Integer> topNodeMap = new HashMap<Integer,Integer>();\n    for(int downTo=q.size()-1;downTo>=0;downTo--) {\n      NodeAndInCount n = q.pop();\n      topNodeMap.put(n.node, downTo);\n      //System.out.println(\"map node=\" + n.node + \" inCount=\" + n.count + \" to newID=\" + downTo);\n    }\n\n    // +1 because node ords start at 1 (0 is reserved as stop node):\n    final GrowableWriter newNodeAddress = new GrowableWriter(\n                    PackedInts.bitsRequired(this.bytes.getPosition()), 1 + nodeCount, acceptableOverheadRatio);\n\n    // Fill initial coarse guess:\n    for(int node=1;node<=nodeCount;node++) {\n      newNodeAddress.set(node, 1 + this.bytes.getPosition() - nodeAddress.get(node));\n    }\n\n    int absCount;\n    int deltaCount;\n    int topCount;\n    int nextCount;\n\n    FST<T> fst;\n\n    // Iterate until we converge:\n    while(true) {\n\n      //System.out.println(\"\\nITER\");\n      boolean changed = false;\n\n      // for assert:\n      boolean negDelta = false;\n\n      fst = new FST<T>(inputType, outputs);\n      \n      final BytesStore writer = fst.bytes;\n\n      // Skip 0 byte since 0 is reserved target:\n      writer.writeByte((byte) 0);\n\n      fst.arcWithOutputCount = 0;\n      fst.nodeCount = 0;\n      fst.arcCount = 0;\n\n      absCount = deltaCount = topCount = nextCount = 0;\n\n      int changedCount = 0;\n\n      int addressError = 0;\n\n      //int totWasted = 0;\n\n      // Since we re-reverse the bytes, we now write the\n      // nodes backwards, so that BIT_TARGET_NEXT is\n      // unchanged:\n      for(int node=nodeCount;node>=1;node--) {\n        fst.nodeCount++;\n        final int address = writer.getPosition();\n\n        //System.out.println(\"  node: \" + node + \" address=\" + address);\n        if (address != newNodeAddress.get(node)) {\n          addressError = address - (int) newNodeAddress.get(node);\n          //System.out.println(\"    change: \" + (address - newNodeAddress[node]));\n          changed = true;\n          newNodeAddress.set(node, address);\n          changedCount++;\n        }\n\n        int nodeArcCount = 0;\n        int bytesPerArc = 0;\n\n        boolean retry = false;\n\n        // for assert:\n        boolean anyNegDelta = false;\n\n        // Retry loop: possibly iterate more than once, if\n        // this is an array'd node and bytesPerArc changes:\n        writeNode:\n        while(true) { // retry writing this node\n\n          //System.out.println(\"  cycle: retry\");\n          readFirstRealTargetArc(node, arc, r);\n\n          final boolean useArcArray = arc.bytesPerArc != 0;\n          if (useArcArray) {\n            // Write false first arc:\n            if (bytesPerArc == 0) {\n              bytesPerArc = arc.bytesPerArc;\n            }\n            writer.writeByte(ARCS_AS_FIXED_ARRAY);\n            writer.writeVInt(arc.numArcs);\n            writer.writeVInt(bytesPerArc);\n            //System.out.println(\"node \" + node + \": \" + arc.numArcs + \" arcs\");\n          }\n\n          int maxBytesPerArc = 0;\n          //int wasted = 0;\n          while(true) {  // iterate over all arcs for this node\n            //System.out.println(\"    cycle next arc\");\n\n            final int arcStartPos = writer.getPosition();\n            nodeArcCount++;\n\n            byte flags = 0;\n\n            if (arc.isLast()) {\n              flags += BIT_LAST_ARC;\n            }\n            /*\n            if (!useArcArray && nodeUpto < nodes.length-1 && arc.target == nodes[nodeUpto+1]) {\n              flags += BIT_TARGET_NEXT;\n            }\n            */\n            if (!useArcArray && node != 1 && arc.target == node-1) {\n              flags += BIT_TARGET_NEXT;\n              if (!retry) {\n                nextCount++;\n              }\n            }\n            if (arc.isFinal()) {\n              flags += BIT_FINAL_ARC;\n              if (arc.nextFinalOutput != NO_OUTPUT) {\n                flags += BIT_ARC_HAS_FINAL_OUTPUT;\n              }\n            } else {\n              assert arc.nextFinalOutput == NO_OUTPUT;\n            }\n            if (!targetHasArcs(arc)) {\n              flags += BIT_STOP_NODE;\n            }\n\n            if (arc.output != NO_OUTPUT) {\n              flags += BIT_ARC_HAS_OUTPUT;\n            }\n\n            final Integer ptr;\n            final int absPtr;\n            final boolean doWriteTarget = targetHasArcs(arc) && (flags & BIT_TARGET_NEXT) == 0;\n            if (doWriteTarget) {\n\n              ptr = topNodeMap.get(arc.target);\n              if (ptr != null) {\n                absPtr = ptr;\n              } else {\n                absPtr = topNodeMap.size() + (int) newNodeAddress.get(arc.target) + addressError;\n              }\n\n              int delta = (int) (newNodeAddress.get(arc.target) + addressError - writer.getPosition() - 2);\n              if (delta < 0) {\n                //System.out.println(\"neg: \" + delta);\n                anyNegDelta = true;\n                delta = 0;\n              }\n\n              if (delta < absPtr) {\n                flags |= BIT_TARGET_DELTA;\n              }\n            } else {\n              ptr = null;\n              absPtr = 0;\n            }\n\n            assert flags != ARCS_AS_FIXED_ARRAY;\n            writer.writeByte(flags);\n\n            fst.writeLabel(writer, arc.label);\n\n            if (arc.output != NO_OUTPUT) {\n              outputs.write(arc.output, writer);\n              if (!retry) {\n                fst.arcWithOutputCount++;\n              }\n            }\n            if (arc.nextFinalOutput != NO_OUTPUT) {\n              outputs.writeFinalOutput(arc.nextFinalOutput, writer);\n            }\n\n            if (doWriteTarget) {\n\n              int delta = (int) (newNodeAddress.get(arc.target) + addressError - writer.getPosition());\n              if (delta < 0) {\n                anyNegDelta = true;\n                //System.out.println(\"neg: \" + delta);\n                delta = 0;\n              }\n\n              if (flag(flags, BIT_TARGET_DELTA)) {\n                //System.out.println(\"        delta\");\n                writer.writeVInt(delta);\n                if (!retry) {\n                  deltaCount++;\n                }\n              } else {\n                /*\n                if (ptr != null) {\n                  System.out.println(\"        deref\");\n                } else {\n                  System.out.println(\"        abs\");\n                }\n                */\n                writer.writeVInt(absPtr);\n                if (!retry) {\n                  if (absPtr >= topNodeMap.size()) {\n                    absCount++;\n                  } else {\n                    topCount++;\n                  }\n                }\n              }\n            }\n\n            if (useArcArray) {\n              final int arcBytes = writer.getPosition() - arcStartPos;\n              //System.out.println(\"  \" + arcBytes + \" bytes\");\n              maxBytesPerArc = Math.max(maxBytesPerArc, arcBytes);\n              // NOTE: this may in fact go \"backwards\", if\n              // somehow (rarely, possibly never) we use\n              // more bytesPerArc in this rewrite than the\n              // incoming FST did... but in this case we\n              // will retry (below) so it's OK to ovewrite\n              // bytes:\n              //wasted += bytesPerArc - arcBytes;\n              writer.skipBytes(arcStartPos + bytesPerArc - writer.getPosition());\n            }\n\n            if (arc.isLast()) {\n              break;\n            }\n\n            readNextRealArc(arc, r);\n          }\n\n          if (useArcArray) {\n            if (maxBytesPerArc == bytesPerArc || (retry && maxBytesPerArc <= bytesPerArc)) {\n              // converged\n              //System.out.println(\"  bba=\" + bytesPerArc + \" wasted=\" + wasted);\n              //totWasted += wasted;\n              break;\n            }\n          } else {\n            break;\n          }\n\n          //System.out.println(\"  retry this node maxBytesPerArc=\" + maxBytesPerArc + \" vs \" + bytesPerArc);\n\n          // Retry:\n          bytesPerArc = maxBytesPerArc;\n          writer.truncate(address);\n          nodeArcCount = 0;\n          retry = true;\n          anyNegDelta = false;\n        }\n\n        negDelta |= anyNegDelta;\n\n        fst.arcCount += nodeArcCount;\n      }\n\n      if (!changed) {\n        // We don't renumber the nodes (just reverse their\n        // order) so nodes should only point forward to\n        // other nodes because we only produce acyclic FSTs\n        // w/ nodes only pointing \"forwards\":\n        assert !negDelta;\n        //System.out.println(\"TOT wasted=\" + totWasted);\n        // Converged!\n        break;\n      }\n      //System.out.println(\"  \" + changedCount + \" of \" + fst.nodeCount + \" changed; retry\");\n    }\n\n    long maxAddress = 0;\n    for (int key : topNodeMap.keySet()) {\n      maxAddress = Math.max(maxAddress, newNodeAddress.get(key));\n    }\n\n    PackedInts.Mutable nodeRefToAddressIn = PackedInts.getMutable(topNodeMap.size(),\n        PackedInts.bitsRequired(maxAddress), acceptableOverheadRatio);\n    for(Map.Entry<Integer,Integer> ent : topNodeMap.entrySet()) {\n      nodeRefToAddressIn.set(ent.getValue(), newNodeAddress.get(ent.getKey()));\n    }\n    fst.nodeRefToAddress = nodeRefToAddressIn;\n    \n    fst.startNode = (int) newNodeAddress.get(startNode);\n    //System.out.println(\"new startNode=\" + fst.startNode + \" old startNode=\" + startNode);\n\n    if (emptyOutput != null) {\n      fst.setEmptyOutput(emptyOutput);\n    }\n\n    assert fst.nodeCount == nodeCount: \"fst.nodeCount=\" + fst.nodeCount + \" nodeCount=\" + nodeCount;\n    assert fst.arcCount == arcCount;\n    assert fst.arcWithOutputCount == arcWithOutputCount: \"fst.arcWithOutputCount=\" + fst.arcWithOutputCount + \" arcWithOutputCount=\" + arcWithOutputCount;\n\n    fst.bytes.finish();\n    fst.cacheRootArcs();\n\n    //final int size = fst.sizeInBytes();\n    //System.out.println(\"nextCount=\" + nextCount + \" topCount=\" + topCount + \" deltaCount=\" + deltaCount + \" absCount=\" + absCount);\n\n    return fst;\n  }\n\n","sourceOld":"  /** Expert: creates an FST by packing this one.  This\n   *  process requires substantial additional RAM (currently\n   *  up to ~8 bytes per node depending on\n   *  <code>acceptableOverheadRatio</code>), but then should\n   *  produce a smaller FST.\n   *\n   *  <p>The implementation of this method uses ideas from\n   *  <a target=\"_blank\" href=\"http://www.cs.put.poznan.pl/dweiss/site/publications/download/fsacomp.pdf\">Smaller Representation of Finite State Automata</a>,\n   *  which describes techniques to reduce the size of a FST.\n   *  However, this is not a strict implementation of the\n   *  algorithms described in this paper.\n   */\n  FST<T> pack(int minInCountDeref, int maxDerefNodes, float acceptableOverheadRatio) throws IOException {\n\n    // TODO: other things to try\n    //   - renumber the nodes to get more next / better locality?\n    //   - allow multiple input labels on an arc, so\n    //     singular chain of inputs can take one arc (on\n    //     wikipedia terms this could save another ~6%)\n    //   - in the ord case, the output '1' is presumably\n    //     very common (after NO_OUTPUT)... maybe use a bit\n    //     for it..?\n    //   - use spare bits in flags.... for top few labels /\n    //     outputs / targets\n\n    if (nodeAddress == null) {\n      throw new IllegalArgumentException(\"this FST was not built with willPackFST=true\");\n    }\n\n    final RAMOutputStream buffer = new RAMOutputStream();\n    byte[] bufferBytes = new byte[64];\n\n    Arc<T> arc = new Arc<T>();\n\n    final BytesReader r = getBytesReader(0);\n\n    final int topN = Math.min(maxDerefNodes, inCounts.size());\n\n    // Find top nodes with highest number of incoming arcs:\n    NodeQueue q = new NodeQueue(topN);\n\n    // TODO: we could use more RAM efficient selection algo here...\n    NodeAndInCount bottom = null;\n    for(int node=0; node<inCounts.size(); node++) {\n      if (inCounts.get(node) >= minInCountDeref) {\n        if (bottom == null) {\n          q.add(new NodeAndInCount(node, (int) inCounts.get(node)));\n          if (q.size() == topN) {\n            bottom = q.top();\n          }\n        } else if (inCounts.get(node) > bottom.count) {\n          q.insertWithOverflow(new NodeAndInCount(node, (int) inCounts.get(node)));\n        }\n      }\n    }\n\n    // Free up RAM:\n    inCounts = null;\n\n    final Map<Integer,Integer> topNodeMap = new HashMap<Integer,Integer>();\n    for(int downTo=q.size()-1;downTo>=0;downTo--) {\n      NodeAndInCount n = q.pop();\n      topNodeMap.put(n.node, downTo);\n      //System.out.println(\"map node=\" + n.node + \" inCount=\" + n.count + \" to newID=\" + downTo);\n    }\n\n    // +1 because node ords start at 1 (0 is reserved as stop node):\n    final GrowableWriter newNodeAddress = new GrowableWriter(\n                    PackedInts.bitsRequired(this.bytes.getPosition()), 1 + nodeCount, acceptableOverheadRatio);\n\n    // Fill initial coarse guess:\n    for(int node=1;node<=nodeCount;node++) {\n      newNodeAddress.set(node, 1 + this.bytes.getPosition() - nodeAddress.get(node));\n    }\n\n    int absCount;\n    int deltaCount;\n    int topCount;\n    int nextCount;\n\n    FST<T> fst;\n\n    // Iterate until we converge:\n    while(true) {\n\n      //System.out.println(\"\\nITER\");\n      boolean changed = false;\n\n      // for assert:\n      boolean negDelta = false;\n\n      fst = new FST<T>(inputType, outputs);\n      \n      final BytesStore writer = fst.bytes;\n\n      // Skip 0 byte since 0 is reserved target:\n      writer.writeByte((byte) 0);\n\n      fst.arcWithOutputCount = 0;\n      fst.nodeCount = 0;\n      fst.arcCount = 0;\n\n      absCount = deltaCount = topCount = nextCount = 0;\n\n      int changedCount = 0;\n\n      int addressError = 0;\n\n      //int totWasted = 0;\n\n      // Since we re-reverse the bytes, we now write the\n      // nodes backwards, so that BIT_TARGET_NEXT is\n      // unchanged:\n      for(int node=nodeCount;node>=1;node--) {\n        fst.nodeCount++;\n        final int address = writer.getPosition();\n\n        //System.out.println(\"  node: \" + node + \" address=\" + address);\n        if (address != newNodeAddress.get(node)) {\n          addressError = address - (int) newNodeAddress.get(node);\n          //System.out.println(\"    change: \" + (address - newNodeAddress[node]));\n          changed = true;\n          newNodeAddress.set(node, address);\n          changedCount++;\n        }\n\n        int nodeArcCount = 0;\n        int bytesPerArc = 0;\n\n        boolean retry = false;\n\n        // for assert:\n        boolean anyNegDelta = false;\n\n        // Retry loop: possibly iterate more than once, if\n        // this is an array'd node and bytesPerArc changes:\n        writeNode:\n        while(true) { // retry writing this node\n          assert buffer.getFilePointer() == 0;\n          //System.out.println(\"  cycle: retry\");\n          readFirstRealTargetArc(node, arc, r);\n\n          final boolean useArcArray = arc.bytesPerArc != 0;\n          if (useArcArray) {\n            // Write false first arc:\n            if (bytesPerArc == 0) {\n              bytesPerArc = arc.bytesPerArc;\n            }\n            buffer.writeByte(ARCS_AS_FIXED_ARRAY);\n            buffer.writeVInt(arc.numArcs);\n            buffer.writeVInt(bytesPerArc);\n            //System.out.println(\"node \" + node + \": \" + arc.numArcs + \" arcs\");\n          }\n\n          int maxBytesPerArc = 0;\n          //int wasted = 0;\n          while(true) {  // iterate over all arcs for this node\n            //System.out.println(\"    cycle next arc\");\n\n            final int arcStartPos = (int) buffer.getFilePointer();\n            nodeArcCount++;\n\n            byte flags = 0;\n\n            if (arc.isLast()) {\n              flags += BIT_LAST_ARC;\n            }\n            /*\n            if (!useArcArray && nodeUpto < nodes.length-1 && arc.target == nodes[nodeUpto+1]) {\n              flags += BIT_TARGET_NEXT;\n            }\n            */\n            if (!useArcArray && node != 1 && arc.target == node-1) {\n              flags += BIT_TARGET_NEXT;\n              if (!retry) {\n                nextCount++;\n              }\n            }\n            if (arc.isFinal()) {\n              flags += BIT_FINAL_ARC;\n              if (arc.nextFinalOutput != NO_OUTPUT) {\n                flags += BIT_ARC_HAS_FINAL_OUTPUT;\n              }\n            } else {\n              assert arc.nextFinalOutput == NO_OUTPUT;\n            }\n            if (!targetHasArcs(arc)) {\n              flags += BIT_STOP_NODE;\n            }\n\n            if (arc.output != NO_OUTPUT) {\n              flags += BIT_ARC_HAS_OUTPUT;\n            }\n\n            final Integer ptr;\n            final int absPtr;\n            final boolean doWriteTarget = targetHasArcs(arc) && (flags & BIT_TARGET_NEXT) == 0;\n            if (doWriteTarget) {\n\n              ptr = topNodeMap.get(arc.target);\n              if (ptr != null) {\n                absPtr = ptr;\n              } else {\n                absPtr = topNodeMap.size() + (int) newNodeAddress.get(arc.target) + addressError;\n              }\n\n              int delta = (int) (newNodeAddress.get(arc.target) + addressError - buffer.getFilePointer() - address - 2);\n              if (delta < 0) {\n                //System.out.println(\"neg: \" + delta);\n                anyNegDelta = true;\n                delta = 0;\n              }\n\n              if (delta < absPtr) {\n                flags |= BIT_TARGET_DELTA;\n              }\n            } else {\n              ptr = null;\n              absPtr = 0;\n            }\n\n            assert flags != ARCS_AS_FIXED_ARRAY;\n            buffer.writeByte(flags);\n\n            fst.writeLabel(buffer, arc.label);\n\n            if (arc.output != NO_OUTPUT) {\n              outputs.write(arc.output, buffer);\n              if (!retry) {\n                fst.arcWithOutputCount++;\n              }\n            }\n            if (arc.nextFinalOutput != NO_OUTPUT) {\n              outputs.writeFinalOutput(arc.nextFinalOutput, buffer);\n            }\n\n            if (doWriteTarget) {\n\n              int delta = (int) (newNodeAddress.get(arc.target) + addressError - buffer.getFilePointer() - address);\n              if (delta < 0) {\n                anyNegDelta = true;\n                //System.out.println(\"neg: \" + delta);\n                delta = 0;\n              }\n\n              if (flag(flags, BIT_TARGET_DELTA)) {\n                //System.out.println(\"        delta\");\n                buffer.writeVInt(delta);\n                if (!retry) {\n                  deltaCount++;\n                }\n              } else {\n                /*\n                if (ptr != null) {\n                  System.out.println(\"        deref\");\n                } else {\n                  System.out.println(\"        abs\");\n                }\n                */\n                buffer.writeVInt(absPtr);\n                if (!retry) {\n                  if (absPtr >= topNodeMap.size()) {\n                    absCount++;\n                  } else {\n                    topCount++;\n                  }\n                }\n              }\n            }\n\n            if (useArcArray) {\n              final int arcBytes = (int) (buffer.getFilePointer() - arcStartPos);\n              //System.out.println(\"  \" + arcBytes + \" bytes\");\n              maxBytesPerArc = Math.max(maxBytesPerArc, arcBytes);\n              // NOTE: this may in fact go \"backwards\", if\n              // somehow (rarely, possibly never) we use\n              // more bytesPerArc in this rewrite than the\n              // incoming FST did... but in this case we\n              // will retry (below) so it's OK to ovewrite\n              // bytes:\n              //wasted += bytesPerArc - arcBytes;\n              int skip = (int) (arcStartPos + bytesPerArc - buffer.getFilePointer());\n              while(skip > 0) {\n                buffer.writeByte((byte) 0);\n                skip--;\n              }\n            }\n\n            if (arc.isLast()) {\n              break;\n            }\n\n            readNextRealArc(arc, r);\n          }\n\n          if (useArcArray) {\n            if (maxBytesPerArc == bytesPerArc || (retry && maxBytesPerArc <= bytesPerArc)) {\n              // converged\n              //System.out.println(\"  bba=\" + bytesPerArc + \" wasted=\" + wasted);\n              //totWasted += wasted;\n              break;\n            }\n          } else {\n            break;\n          }\n\n          //System.out.println(\"  retry this node maxBytesPerArc=\" + maxBytesPerArc + \" vs \" + bytesPerArc);\n\n          // Retry:\n          bytesPerArc = maxBytesPerArc;\n          buffer.reset();\n          nodeArcCount = 0;\n          retry = true;\n          anyNegDelta = false;\n        }\n\n        if (bufferBytes.length < (int) buffer.getFilePointer()) {\n          bufferBytes = ArrayUtil.grow(bufferBytes, (int) buffer.getFilePointer());\n        }\n        buffer.writeTo(bufferBytes, 0);\n        writer.writeBytes(bufferBytes, 0, (int) buffer.getFilePointer());\n        buffer.reset();\n\n        negDelta |= anyNegDelta;\n\n        fst.arcCount += nodeArcCount;\n      }\n\n      if (!changed) {\n        // We don't renumber the nodes (just reverse their\n        // order) so nodes should only point forward to\n        // other nodes because we only produce acyclic FSTs\n        // w/ nodes only pointing \"forwards\":\n        assert !negDelta;\n        //System.out.println(\"TOT wasted=\" + totWasted);\n        // Converged!\n        break;\n      }\n      //System.out.println(\"  \" + changedCount + \" of \" + fst.nodeCount + \" changed; retry\");\n    }\n\n    long maxAddress = 0;\n    for (int key : topNodeMap.keySet()) {\n      maxAddress = Math.max(maxAddress, newNodeAddress.get(key));\n    }\n\n    PackedInts.Mutable nodeRefToAddressIn = PackedInts.getMutable(topNodeMap.size(),\n        PackedInts.bitsRequired(maxAddress), acceptableOverheadRatio);\n    for(Map.Entry<Integer,Integer> ent : topNodeMap.entrySet()) {\n      nodeRefToAddressIn.set(ent.getValue(), newNodeAddress.get(ent.getKey()));\n    }\n    fst.nodeRefToAddress = nodeRefToAddressIn;\n    \n    fst.startNode = (int) newNodeAddress.get(startNode);\n    //System.out.println(\"new startNode=\" + fst.startNode + \" old startNode=\" + startNode);\n\n    if (emptyOutput != null) {\n      fst.setEmptyOutput(emptyOutput);\n    }\n\n    assert fst.nodeCount == nodeCount: \"fst.nodeCount=\" + fst.nodeCount + \" nodeCount=\" + nodeCount;\n    assert fst.arcCount == arcCount;\n    assert fst.arcWithOutputCount == arcWithOutputCount: \"fst.arcWithOutputCount=\" + fst.arcWithOutputCount + \" arcWithOutputCount=\" + arcWithOutputCount;\n\n    fst.bytes.finish();\n    fst.cacheRootArcs();\n\n    //final int size = fst.sizeInBytes();\n    //System.out.println(\"nextCount=\" + nextCount + \" topCount=\" + topCount + \" deltaCount=\" + deltaCount + \" absCount=\" + absCount);\n\n    return fst;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3c397b1515e745d8b12d70edfc0e17cb7eac7f0","date":1358188277,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#pack(int,int,float).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#pack(int,int,float).mjava","sourceNew":"  /** Expert: creates an FST by packing this one.  This\n   *  process requires substantial additional RAM (currently\n   *  up to ~8 bytes per node depending on\n   *  <code>acceptableOverheadRatio</code>), but then should\n   *  produce a smaller FST.\n   *\n   *  <p>The implementation of this method uses ideas from\n   *  <a target=\"_blank\" href=\"http://www.cs.put.poznan.pl/dweiss/site/publications/download/fsacomp.pdf\">Smaller Representation of Finite State Automata</a>,\n   *  which describes techniques to reduce the size of a FST.\n   *  However, this is not a strict implementation of the\n   *  algorithms described in this paper.\n   */\n  FST<T> pack(int minInCountDeref, int maxDerefNodes, float acceptableOverheadRatio) throws IOException {\n\n    // NOTE: maxDerefNodes is intentionally int: we cannot\n    // support > 2.1B deref nodes\n\n    // TODO: other things to try\n    //   - renumber the nodes to get more next / better locality?\n    //   - allow multiple input labels on an arc, so\n    //     singular chain of inputs can take one arc (on\n    //     wikipedia terms this could save another ~6%)\n    //   - in the ord case, the output '1' is presumably\n    //     very common (after NO_OUTPUT)... maybe use a bit\n    //     for it..?\n    //   - use spare bits in flags.... for top few labels /\n    //     outputs / targets\n\n    if (nodeAddress == null) {\n      throw new IllegalArgumentException(\"this FST was not built with willPackFST=true\");\n    }\n\n    Arc<T> arc = new Arc<T>();\n\n    final BytesReader r = getBytesReader(0);\n\n    final int topN = Math.min(maxDerefNodes, inCounts.size());\n\n    // Find top nodes with highest number of incoming arcs:\n    NodeQueue q = new NodeQueue(topN);\n\n    // TODO: we could use more RAM efficient selection algo here...\n    NodeAndInCount bottom = null;\n    for(int node=0; node<inCounts.size(); node++) {\n      if (inCounts.get(node) >= minInCountDeref) {\n        if (bottom == null) {\n          q.add(new NodeAndInCount(node, (int) inCounts.get(node)));\n          if (q.size() == topN) {\n            bottom = q.top();\n          }\n        } else if (inCounts.get(node) > bottom.count) {\n          q.insertWithOverflow(new NodeAndInCount(node, (int) inCounts.get(node)));\n        }\n      }\n    }\n\n    // Free up RAM:\n    inCounts = null;\n\n    final Map<Integer,Integer> topNodeMap = new HashMap<Integer,Integer>();\n    for(int downTo=q.size()-1;downTo>=0;downTo--) {\n      NodeAndInCount n = q.pop();\n      topNodeMap.put(n.node, downTo);\n      //System.out.println(\"map node=\" + n.node + \" inCount=\" + n.count + \" to newID=\" + downTo);\n    }\n\n    // +1 because node ords start at 1 (0 is reserved as stop node):\n    final GrowableWriter newNodeAddress = new GrowableWriter(\n                       PackedInts.bitsRequired(this.bytes.getPosition()), (int) (1 + nodeCount), acceptableOverheadRatio);\n\n    // Fill initial coarse guess:\n    for(int node=1;node<=nodeCount;node++) {\n      newNodeAddress.set(node, 1 + this.bytes.getPosition() - nodeAddress.get(node));\n    }\n\n    int absCount;\n    int deltaCount;\n    int topCount;\n    int nextCount;\n\n    FST<T> fst;\n\n    // Iterate until we converge:\n    while(true) {\n\n      //System.out.println(\"\\nITER\");\n      boolean changed = false;\n\n      // for assert:\n      boolean negDelta = false;\n\n      fst = new FST<T>(inputType, outputs, bytes.getBlockBits());\n      \n      final BytesStore writer = fst.bytes;\n\n      // Skip 0 byte since 0 is reserved target:\n      writer.writeByte((byte) 0);\n\n      fst.arcWithOutputCount = 0;\n      fst.nodeCount = 0;\n      fst.arcCount = 0;\n\n      absCount = deltaCount = topCount = nextCount = 0;\n\n      int changedCount = 0;\n\n      long addressError = 0;\n\n      //int totWasted = 0;\n\n      // Since we re-reverse the bytes, we now write the\n      // nodes backwards, so that BIT_TARGET_NEXT is\n      // unchanged:\n      for(int node=(int)nodeCount;node>=1;node--) {\n        fst.nodeCount++;\n        final long address = writer.getPosition();\n\n        //System.out.println(\"  node: \" + node + \" address=\" + address);\n        if (address != newNodeAddress.get(node)) {\n          addressError = address - newNodeAddress.get(node);\n          //System.out.println(\"    change: \" + (address - newNodeAddress[node]));\n          changed = true;\n          newNodeAddress.set(node, address);\n          changedCount++;\n        }\n\n        int nodeArcCount = 0;\n        int bytesPerArc = 0;\n\n        boolean retry = false;\n\n        // for assert:\n        boolean anyNegDelta = false;\n\n        // Retry loop: possibly iterate more than once, if\n        // this is an array'd node and bytesPerArc changes:\n        writeNode:\n        while(true) { // retry writing this node\n\n          //System.out.println(\"  cycle: retry\");\n          readFirstRealTargetArc(node, arc, r);\n\n          final boolean useArcArray = arc.bytesPerArc != 0;\n          if (useArcArray) {\n            // Write false first arc:\n            if (bytesPerArc == 0) {\n              bytesPerArc = arc.bytesPerArc;\n            }\n            writer.writeByte(ARCS_AS_FIXED_ARRAY);\n            writer.writeVInt(arc.numArcs);\n            writer.writeVInt(bytesPerArc);\n            //System.out.println(\"node \" + node + \": \" + arc.numArcs + \" arcs\");\n          }\n\n          int maxBytesPerArc = 0;\n          //int wasted = 0;\n          while(true) {  // iterate over all arcs for this node\n            //System.out.println(\"    cycle next arc\");\n\n            final long arcStartPos = writer.getPosition();\n            nodeArcCount++;\n\n            byte flags = 0;\n\n            if (arc.isLast()) {\n              flags += BIT_LAST_ARC;\n            }\n            /*\n            if (!useArcArray && nodeUpto < nodes.length-1 && arc.target == nodes[nodeUpto+1]) {\n              flags += BIT_TARGET_NEXT;\n            }\n            */\n            if (!useArcArray && node != 1 && arc.target == node-1) {\n              flags += BIT_TARGET_NEXT;\n              if (!retry) {\n                nextCount++;\n              }\n            }\n            if (arc.isFinal()) {\n              flags += BIT_FINAL_ARC;\n              if (arc.nextFinalOutput != NO_OUTPUT) {\n                flags += BIT_ARC_HAS_FINAL_OUTPUT;\n              }\n            } else {\n              assert arc.nextFinalOutput == NO_OUTPUT;\n            }\n            if (!targetHasArcs(arc)) {\n              flags += BIT_STOP_NODE;\n            }\n\n            if (arc.output != NO_OUTPUT) {\n              flags += BIT_ARC_HAS_OUTPUT;\n            }\n\n            final long absPtr;\n            final boolean doWriteTarget = targetHasArcs(arc) && (flags & BIT_TARGET_NEXT) == 0;\n            if (doWriteTarget) {\n\n              final Integer ptr = topNodeMap.get(arc.target);\n              if (ptr != null) {\n                absPtr = ptr;\n              } else {\n                absPtr = topNodeMap.size() + newNodeAddress.get((int) arc.target) + addressError;\n              }\n\n              long delta = newNodeAddress.get((int) arc.target) + addressError - writer.getPosition() - 2;\n              if (delta < 0) {\n                //System.out.println(\"neg: \" + delta);\n                anyNegDelta = true;\n                delta = 0;\n              }\n\n              if (delta < absPtr) {\n                flags |= BIT_TARGET_DELTA;\n              }\n            } else {\n              absPtr = 0;\n            }\n\n            assert flags != ARCS_AS_FIXED_ARRAY;\n            writer.writeByte(flags);\n\n            fst.writeLabel(writer, arc.label);\n\n            if (arc.output != NO_OUTPUT) {\n              outputs.write(arc.output, writer);\n              if (!retry) {\n                fst.arcWithOutputCount++;\n              }\n            }\n            if (arc.nextFinalOutput != NO_OUTPUT) {\n              outputs.writeFinalOutput(arc.nextFinalOutput, writer);\n            }\n\n            if (doWriteTarget) {\n\n              long delta = newNodeAddress.get((int) arc.target) + addressError - writer.getPosition();\n              if (delta < 0) {\n                anyNegDelta = true;\n                //System.out.println(\"neg: \" + delta);\n                delta = 0;\n              }\n\n              if (flag(flags, BIT_TARGET_DELTA)) {\n                //System.out.println(\"        delta\");\n                writer.writeVLong(delta);\n                if (!retry) {\n                  deltaCount++;\n                }\n              } else {\n                /*\n                if (ptr != null) {\n                  System.out.println(\"        deref\");\n                } else {\n                  System.out.println(\"        abs\");\n                }\n                */\n                writer.writeVLong(absPtr);\n                if (!retry) {\n                  if (absPtr >= topNodeMap.size()) {\n                    absCount++;\n                  } else {\n                    topCount++;\n                  }\n                }\n              }\n            }\n\n            if (useArcArray) {\n              final int arcBytes = (int) (writer.getPosition() - arcStartPos);\n              //System.out.println(\"  \" + arcBytes + \" bytes\");\n              maxBytesPerArc = Math.max(maxBytesPerArc, arcBytes);\n              // NOTE: this may in fact go \"backwards\", if\n              // somehow (rarely, possibly never) we use\n              // more bytesPerArc in this rewrite than the\n              // incoming FST did... but in this case we\n              // will retry (below) so it's OK to ovewrite\n              // bytes:\n              //wasted += bytesPerArc - arcBytes;\n              writer.skipBytes((int) (arcStartPos + bytesPerArc - writer.getPosition()));\n            }\n\n            if (arc.isLast()) {\n              break;\n            }\n\n            readNextRealArc(arc, r);\n          }\n\n          if (useArcArray) {\n            if (maxBytesPerArc == bytesPerArc || (retry && maxBytesPerArc <= bytesPerArc)) {\n              // converged\n              //System.out.println(\"  bba=\" + bytesPerArc + \" wasted=\" + wasted);\n              //totWasted += wasted;\n              break;\n            }\n          } else {\n            break;\n          }\n\n          //System.out.println(\"  retry this node maxBytesPerArc=\" + maxBytesPerArc + \" vs \" + bytesPerArc);\n\n          // Retry:\n          bytesPerArc = maxBytesPerArc;\n          writer.truncate(address);\n          nodeArcCount = 0;\n          retry = true;\n          anyNegDelta = false;\n        }\n\n        negDelta |= anyNegDelta;\n\n        fst.arcCount += nodeArcCount;\n      }\n\n      if (!changed) {\n        // We don't renumber the nodes (just reverse their\n        // order) so nodes should only point forward to\n        // other nodes because we only produce acyclic FSTs\n        // w/ nodes only pointing \"forwards\":\n        assert !negDelta;\n        //System.out.println(\"TOT wasted=\" + totWasted);\n        // Converged!\n        break;\n      }\n      //System.out.println(\"  \" + changedCount + \" of \" + fst.nodeCount + \" changed; retry\");\n    }\n\n    long maxAddress = 0;\n    for (long key : topNodeMap.keySet()) {\n      maxAddress = Math.max(maxAddress, newNodeAddress.get((int) key));\n    }\n\n    PackedInts.Mutable nodeRefToAddressIn = PackedInts.getMutable(topNodeMap.size(),\n        PackedInts.bitsRequired(maxAddress), acceptableOverheadRatio);\n    for(Map.Entry<Integer,Integer> ent : topNodeMap.entrySet()) {\n      nodeRefToAddressIn.set(ent.getValue(), newNodeAddress.get(ent.getKey()));\n    }\n    fst.nodeRefToAddress = nodeRefToAddressIn;\n    \n    fst.startNode = newNodeAddress.get((int) startNode);\n    //System.out.println(\"new startNode=\" + fst.startNode + \" old startNode=\" + startNode);\n\n    if (emptyOutput != null) {\n      fst.setEmptyOutput(emptyOutput);\n    }\n\n    assert fst.nodeCount == nodeCount: \"fst.nodeCount=\" + fst.nodeCount + \" nodeCount=\" + nodeCount;\n    assert fst.arcCount == arcCount;\n    assert fst.arcWithOutputCount == arcWithOutputCount: \"fst.arcWithOutputCount=\" + fst.arcWithOutputCount + \" arcWithOutputCount=\" + arcWithOutputCount;\n\n    fst.bytes.finish();\n    fst.cacheRootArcs();\n\n    //final int size = fst.sizeInBytes();\n    //System.out.println(\"nextCount=\" + nextCount + \" topCount=\" + topCount + \" deltaCount=\" + deltaCount + \" absCount=\" + absCount);\n\n    return fst;\n  }\n\n","sourceOld":"  /** Expert: creates an FST by packing this one.  This\n   *  process requires substantial additional RAM (currently\n   *  up to ~8 bytes per node depending on\n   *  <code>acceptableOverheadRatio</code>), but then should\n   *  produce a smaller FST.\n   *\n   *  <p>The implementation of this method uses ideas from\n   *  <a target=\"_blank\" href=\"http://www.cs.put.poznan.pl/dweiss/site/publications/download/fsacomp.pdf\">Smaller Representation of Finite State Automata</a>,\n   *  which describes techniques to reduce the size of a FST.\n   *  However, this is not a strict implementation of the\n   *  algorithms described in this paper.\n   */\n  FST<T> pack(int minInCountDeref, int maxDerefNodes, float acceptableOverheadRatio) throws IOException {\n\n    // TODO: other things to try\n    //   - renumber the nodes to get more next / better locality?\n    //   - allow multiple input labels on an arc, so\n    //     singular chain of inputs can take one arc (on\n    //     wikipedia terms this could save another ~6%)\n    //   - in the ord case, the output '1' is presumably\n    //     very common (after NO_OUTPUT)... maybe use a bit\n    //     for it..?\n    //   - use spare bits in flags.... for top few labels /\n    //     outputs / targets\n\n    if (nodeAddress == null) {\n      throw new IllegalArgumentException(\"this FST was not built with willPackFST=true\");\n    }\n\n    Arc<T> arc = new Arc<T>();\n\n    final BytesReader r = getBytesReader(0);\n\n    final int topN = Math.min(maxDerefNodes, inCounts.size());\n\n    // Find top nodes with highest number of incoming arcs:\n    NodeQueue q = new NodeQueue(topN);\n\n    // TODO: we could use more RAM efficient selection algo here...\n    NodeAndInCount bottom = null;\n    for(int node=0; node<inCounts.size(); node++) {\n      if (inCounts.get(node) >= minInCountDeref) {\n        if (bottom == null) {\n          q.add(new NodeAndInCount(node, (int) inCounts.get(node)));\n          if (q.size() == topN) {\n            bottom = q.top();\n          }\n        } else if (inCounts.get(node) > bottom.count) {\n          q.insertWithOverflow(new NodeAndInCount(node, (int) inCounts.get(node)));\n        }\n      }\n    }\n\n    // Free up RAM:\n    inCounts = null;\n\n    final Map<Integer,Integer> topNodeMap = new HashMap<Integer,Integer>();\n    for(int downTo=q.size()-1;downTo>=0;downTo--) {\n      NodeAndInCount n = q.pop();\n      topNodeMap.put(n.node, downTo);\n      //System.out.println(\"map node=\" + n.node + \" inCount=\" + n.count + \" to newID=\" + downTo);\n    }\n\n    // +1 because node ords start at 1 (0 is reserved as stop node):\n    final GrowableWriter newNodeAddress = new GrowableWriter(\n                    PackedInts.bitsRequired(this.bytes.getPosition()), 1 + nodeCount, acceptableOverheadRatio);\n\n    // Fill initial coarse guess:\n    for(int node=1;node<=nodeCount;node++) {\n      newNodeAddress.set(node, 1 + this.bytes.getPosition() - nodeAddress.get(node));\n    }\n\n    int absCount;\n    int deltaCount;\n    int topCount;\n    int nextCount;\n\n    FST<T> fst;\n\n    // Iterate until we converge:\n    while(true) {\n\n      //System.out.println(\"\\nITER\");\n      boolean changed = false;\n\n      // for assert:\n      boolean negDelta = false;\n\n      fst = new FST<T>(inputType, outputs);\n      \n      final BytesStore writer = fst.bytes;\n\n      // Skip 0 byte since 0 is reserved target:\n      writer.writeByte((byte) 0);\n\n      fst.arcWithOutputCount = 0;\n      fst.nodeCount = 0;\n      fst.arcCount = 0;\n\n      absCount = deltaCount = topCount = nextCount = 0;\n\n      int changedCount = 0;\n\n      int addressError = 0;\n\n      //int totWasted = 0;\n\n      // Since we re-reverse the bytes, we now write the\n      // nodes backwards, so that BIT_TARGET_NEXT is\n      // unchanged:\n      for(int node=nodeCount;node>=1;node--) {\n        fst.nodeCount++;\n        final int address = writer.getPosition();\n\n        //System.out.println(\"  node: \" + node + \" address=\" + address);\n        if (address != newNodeAddress.get(node)) {\n          addressError = address - (int) newNodeAddress.get(node);\n          //System.out.println(\"    change: \" + (address - newNodeAddress[node]));\n          changed = true;\n          newNodeAddress.set(node, address);\n          changedCount++;\n        }\n\n        int nodeArcCount = 0;\n        int bytesPerArc = 0;\n\n        boolean retry = false;\n\n        // for assert:\n        boolean anyNegDelta = false;\n\n        // Retry loop: possibly iterate more than once, if\n        // this is an array'd node and bytesPerArc changes:\n        writeNode:\n        while(true) { // retry writing this node\n\n          //System.out.println(\"  cycle: retry\");\n          readFirstRealTargetArc(node, arc, r);\n\n          final boolean useArcArray = arc.bytesPerArc != 0;\n          if (useArcArray) {\n            // Write false first arc:\n            if (bytesPerArc == 0) {\n              bytesPerArc = arc.bytesPerArc;\n            }\n            writer.writeByte(ARCS_AS_FIXED_ARRAY);\n            writer.writeVInt(arc.numArcs);\n            writer.writeVInt(bytesPerArc);\n            //System.out.println(\"node \" + node + \": \" + arc.numArcs + \" arcs\");\n          }\n\n          int maxBytesPerArc = 0;\n          //int wasted = 0;\n          while(true) {  // iterate over all arcs for this node\n            //System.out.println(\"    cycle next arc\");\n\n            final int arcStartPos = writer.getPosition();\n            nodeArcCount++;\n\n            byte flags = 0;\n\n            if (arc.isLast()) {\n              flags += BIT_LAST_ARC;\n            }\n            /*\n            if (!useArcArray && nodeUpto < nodes.length-1 && arc.target == nodes[nodeUpto+1]) {\n              flags += BIT_TARGET_NEXT;\n            }\n            */\n            if (!useArcArray && node != 1 && arc.target == node-1) {\n              flags += BIT_TARGET_NEXT;\n              if (!retry) {\n                nextCount++;\n              }\n            }\n            if (arc.isFinal()) {\n              flags += BIT_FINAL_ARC;\n              if (arc.nextFinalOutput != NO_OUTPUT) {\n                flags += BIT_ARC_HAS_FINAL_OUTPUT;\n              }\n            } else {\n              assert arc.nextFinalOutput == NO_OUTPUT;\n            }\n            if (!targetHasArcs(arc)) {\n              flags += BIT_STOP_NODE;\n            }\n\n            if (arc.output != NO_OUTPUT) {\n              flags += BIT_ARC_HAS_OUTPUT;\n            }\n\n            final Integer ptr;\n            final int absPtr;\n            final boolean doWriteTarget = targetHasArcs(arc) && (flags & BIT_TARGET_NEXT) == 0;\n            if (doWriteTarget) {\n\n              ptr = topNodeMap.get(arc.target);\n              if (ptr != null) {\n                absPtr = ptr;\n              } else {\n                absPtr = topNodeMap.size() + (int) newNodeAddress.get(arc.target) + addressError;\n              }\n\n              int delta = (int) (newNodeAddress.get(arc.target) + addressError - writer.getPosition() - 2);\n              if (delta < 0) {\n                //System.out.println(\"neg: \" + delta);\n                anyNegDelta = true;\n                delta = 0;\n              }\n\n              if (delta < absPtr) {\n                flags |= BIT_TARGET_DELTA;\n              }\n            } else {\n              ptr = null;\n              absPtr = 0;\n            }\n\n            assert flags != ARCS_AS_FIXED_ARRAY;\n            writer.writeByte(flags);\n\n            fst.writeLabel(writer, arc.label);\n\n            if (arc.output != NO_OUTPUT) {\n              outputs.write(arc.output, writer);\n              if (!retry) {\n                fst.arcWithOutputCount++;\n              }\n            }\n            if (arc.nextFinalOutput != NO_OUTPUT) {\n              outputs.writeFinalOutput(arc.nextFinalOutput, writer);\n            }\n\n            if (doWriteTarget) {\n\n              int delta = (int) (newNodeAddress.get(arc.target) + addressError - writer.getPosition());\n              if (delta < 0) {\n                anyNegDelta = true;\n                //System.out.println(\"neg: \" + delta);\n                delta = 0;\n              }\n\n              if (flag(flags, BIT_TARGET_DELTA)) {\n                //System.out.println(\"        delta\");\n                writer.writeVInt(delta);\n                if (!retry) {\n                  deltaCount++;\n                }\n              } else {\n                /*\n                if (ptr != null) {\n                  System.out.println(\"        deref\");\n                } else {\n                  System.out.println(\"        abs\");\n                }\n                */\n                writer.writeVInt(absPtr);\n                if (!retry) {\n                  if (absPtr >= topNodeMap.size()) {\n                    absCount++;\n                  } else {\n                    topCount++;\n                  }\n                }\n              }\n            }\n\n            if (useArcArray) {\n              final int arcBytes = writer.getPosition() - arcStartPos;\n              //System.out.println(\"  \" + arcBytes + \" bytes\");\n              maxBytesPerArc = Math.max(maxBytesPerArc, arcBytes);\n              // NOTE: this may in fact go \"backwards\", if\n              // somehow (rarely, possibly never) we use\n              // more bytesPerArc in this rewrite than the\n              // incoming FST did... but in this case we\n              // will retry (below) so it's OK to ovewrite\n              // bytes:\n              //wasted += bytesPerArc - arcBytes;\n              writer.skipBytes(arcStartPos + bytesPerArc - writer.getPosition());\n            }\n\n            if (arc.isLast()) {\n              break;\n            }\n\n            readNextRealArc(arc, r);\n          }\n\n          if (useArcArray) {\n            if (maxBytesPerArc == bytesPerArc || (retry && maxBytesPerArc <= bytesPerArc)) {\n              // converged\n              //System.out.println(\"  bba=\" + bytesPerArc + \" wasted=\" + wasted);\n              //totWasted += wasted;\n              break;\n            }\n          } else {\n            break;\n          }\n\n          //System.out.println(\"  retry this node maxBytesPerArc=\" + maxBytesPerArc + \" vs \" + bytesPerArc);\n\n          // Retry:\n          bytesPerArc = maxBytesPerArc;\n          writer.truncate(address);\n          nodeArcCount = 0;\n          retry = true;\n          anyNegDelta = false;\n        }\n\n        negDelta |= anyNegDelta;\n\n        fst.arcCount += nodeArcCount;\n      }\n\n      if (!changed) {\n        // We don't renumber the nodes (just reverse their\n        // order) so nodes should only point forward to\n        // other nodes because we only produce acyclic FSTs\n        // w/ nodes only pointing \"forwards\":\n        assert !negDelta;\n        //System.out.println(\"TOT wasted=\" + totWasted);\n        // Converged!\n        break;\n      }\n      //System.out.println(\"  \" + changedCount + \" of \" + fst.nodeCount + \" changed; retry\");\n    }\n\n    long maxAddress = 0;\n    for (int key : topNodeMap.keySet()) {\n      maxAddress = Math.max(maxAddress, newNodeAddress.get(key));\n    }\n\n    PackedInts.Mutable nodeRefToAddressIn = PackedInts.getMutable(topNodeMap.size(),\n        PackedInts.bitsRequired(maxAddress), acceptableOverheadRatio);\n    for(Map.Entry<Integer,Integer> ent : topNodeMap.entrySet()) {\n      nodeRefToAddressIn.set(ent.getValue(), newNodeAddress.get(ent.getKey()));\n    }\n    fst.nodeRefToAddress = nodeRefToAddressIn;\n    \n    fst.startNode = (int) newNodeAddress.get(startNode);\n    //System.out.println(\"new startNode=\" + fst.startNode + \" old startNode=\" + startNode);\n\n    if (emptyOutput != null) {\n      fst.setEmptyOutput(emptyOutput);\n    }\n\n    assert fst.nodeCount == nodeCount: \"fst.nodeCount=\" + fst.nodeCount + \" nodeCount=\" + nodeCount;\n    assert fst.arcCount == arcCount;\n    assert fst.arcWithOutputCount == arcWithOutputCount: \"fst.arcWithOutputCount=\" + fst.arcWithOutputCount + \" arcWithOutputCount=\" + arcWithOutputCount;\n\n    fst.bytes.finish();\n    fst.cacheRootArcs();\n\n    //final int size = fst.sizeInBytes();\n    //System.out.println(\"nextCount=\" + nextCount + \" topCount=\" + topCount + \" deltaCount=\" + deltaCount + \" absCount=\" + absCount);\n\n    return fst;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8917bfede3b4ca30f4305c1e391e9218959cd723","date":1358189662,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#pack(int,int,float).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#pack(int,int,float).mjava","sourceNew":"  /** Expert: creates an FST by packing this one.  This\n   *  process requires substantial additional RAM (currently\n   *  up to ~8 bytes per node depending on\n   *  <code>acceptableOverheadRatio</code>), but then should\n   *  produce a smaller FST.\n   *\n   *  <p>The implementation of this method uses ideas from\n   *  <a target=\"_blank\" href=\"http://www.cs.put.poznan.pl/dweiss/site/publications/download/fsacomp.pdf\">Smaller Representation of Finite State Automata</a>,\n   *  which describes techniques to reduce the size of a FST.\n   *  However, this is not a strict implementation of the\n   *  algorithms described in this paper.\n   */\n  FST<T> pack(int minInCountDeref, int maxDerefNodes, float acceptableOverheadRatio) throws IOException {\n\n    // NOTE: maxDerefNodes is intentionally int: we cannot\n    // support > 2.1B deref nodes\n\n    // TODO: other things to try\n    //   - renumber the nodes to get more next / better locality?\n    //   - allow multiple input labels on an arc, so\n    //     singular chain of inputs can take one arc (on\n    //     wikipedia terms this could save another ~6%)\n    //   - in the ord case, the output '1' is presumably\n    //     very common (after NO_OUTPUT)... maybe use a bit\n    //     for it..?\n    //   - use spare bits in flags.... for top few labels /\n    //     outputs / targets\n\n    if (nodeAddress == null) {\n      throw new IllegalArgumentException(\"this FST was not built with willPackFST=true\");\n    }\n\n    Arc<T> arc = new Arc<T>();\n\n    final BytesReader r = getBytesReader(0);\n\n    final int topN = Math.min(maxDerefNodes, inCounts.size());\n\n    // Find top nodes with highest number of incoming arcs:\n    NodeQueue q = new NodeQueue(topN);\n\n    // TODO: we could use more RAM efficient selection algo here...\n    NodeAndInCount bottom = null;\n    for(int node=0; node<inCounts.size(); node++) {\n      if (inCounts.get(node) >= minInCountDeref) {\n        if (bottom == null) {\n          q.add(new NodeAndInCount(node, (int) inCounts.get(node)));\n          if (q.size() == topN) {\n            bottom = q.top();\n          }\n        } else if (inCounts.get(node) > bottom.count) {\n          q.insertWithOverflow(new NodeAndInCount(node, (int) inCounts.get(node)));\n        }\n      }\n    }\n\n    // Free up RAM:\n    inCounts = null;\n\n    final Map<Integer,Integer> topNodeMap = new HashMap<Integer,Integer>();\n    for(int downTo=q.size()-1;downTo>=0;downTo--) {\n      NodeAndInCount n = q.pop();\n      topNodeMap.put(n.node, downTo);\n      //System.out.println(\"map node=\" + n.node + \" inCount=\" + n.count + \" to newID=\" + downTo);\n    }\n\n    // +1 because node ords start at 1 (0 is reserved as stop node):\n    final GrowableWriter newNodeAddress = new GrowableWriter(\n                       PackedInts.bitsRequired(this.bytes.getPosition()), (int) (1 + nodeCount), acceptableOverheadRatio);\n\n    // Fill initial coarse guess:\n    for(int node=1;node<=nodeCount;node++) {\n      newNodeAddress.set(node, 1 + this.bytes.getPosition() - nodeAddress.get(node));\n    }\n\n    int absCount;\n    int deltaCount;\n    int topCount;\n    int nextCount;\n\n    FST<T> fst;\n\n    // Iterate until we converge:\n    while(true) {\n\n      //System.out.println(\"\\nITER\");\n      boolean changed = false;\n\n      // for assert:\n      boolean negDelta = false;\n\n      fst = new FST<T>(inputType, outputs, bytes.getBlockBits());\n      \n      final BytesStore writer = fst.bytes;\n\n      // Skip 0 byte since 0 is reserved target:\n      writer.writeByte((byte) 0);\n\n      fst.arcWithOutputCount = 0;\n      fst.nodeCount = 0;\n      fst.arcCount = 0;\n\n      absCount = deltaCount = topCount = nextCount = 0;\n\n      int changedCount = 0;\n\n      long addressError = 0;\n\n      //int totWasted = 0;\n\n      // Since we re-reverse the bytes, we now write the\n      // nodes backwards, so that BIT_TARGET_NEXT is\n      // unchanged:\n      for(int node=(int)nodeCount;node>=1;node--) {\n        fst.nodeCount++;\n        final long address = writer.getPosition();\n\n        //System.out.println(\"  node: \" + node + \" address=\" + address);\n        if (address != newNodeAddress.get(node)) {\n          addressError = address - newNodeAddress.get(node);\n          //System.out.println(\"    change: \" + (address - newNodeAddress[node]));\n          changed = true;\n          newNodeAddress.set(node, address);\n          changedCount++;\n        }\n\n        int nodeArcCount = 0;\n        int bytesPerArc = 0;\n\n        boolean retry = false;\n\n        // for assert:\n        boolean anyNegDelta = false;\n\n        // Retry loop: possibly iterate more than once, if\n        // this is an array'd node and bytesPerArc changes:\n        writeNode:\n        while(true) { // retry writing this node\n\n          //System.out.println(\"  cycle: retry\");\n          readFirstRealTargetArc(node, arc, r);\n\n          final boolean useArcArray = arc.bytesPerArc != 0;\n          if (useArcArray) {\n            // Write false first arc:\n            if (bytesPerArc == 0) {\n              bytesPerArc = arc.bytesPerArc;\n            }\n            writer.writeByte(ARCS_AS_FIXED_ARRAY);\n            writer.writeVInt(arc.numArcs);\n            writer.writeVInt(bytesPerArc);\n            //System.out.println(\"node \" + node + \": \" + arc.numArcs + \" arcs\");\n          }\n\n          int maxBytesPerArc = 0;\n          //int wasted = 0;\n          while(true) {  // iterate over all arcs for this node\n            //System.out.println(\"    cycle next arc\");\n\n            final long arcStartPos = writer.getPosition();\n            nodeArcCount++;\n\n            byte flags = 0;\n\n            if (arc.isLast()) {\n              flags += BIT_LAST_ARC;\n            }\n            /*\n            if (!useArcArray && nodeUpto < nodes.length-1 && arc.target == nodes[nodeUpto+1]) {\n              flags += BIT_TARGET_NEXT;\n            }\n            */\n            if (!useArcArray && node != 1 && arc.target == node-1) {\n              flags += BIT_TARGET_NEXT;\n              if (!retry) {\n                nextCount++;\n              }\n            }\n            if (arc.isFinal()) {\n              flags += BIT_FINAL_ARC;\n              if (arc.nextFinalOutput != NO_OUTPUT) {\n                flags += BIT_ARC_HAS_FINAL_OUTPUT;\n              }\n            } else {\n              assert arc.nextFinalOutput == NO_OUTPUT;\n            }\n            if (!targetHasArcs(arc)) {\n              flags += BIT_STOP_NODE;\n            }\n\n            if (arc.output != NO_OUTPUT) {\n              flags += BIT_ARC_HAS_OUTPUT;\n            }\n\n            final long absPtr;\n            final boolean doWriteTarget = targetHasArcs(arc) && (flags & BIT_TARGET_NEXT) == 0;\n            if (doWriteTarget) {\n\n              final Integer ptr = topNodeMap.get(arc.target);\n              if (ptr != null) {\n                absPtr = ptr;\n              } else {\n                absPtr = topNodeMap.size() + newNodeAddress.get((int) arc.target) + addressError;\n              }\n\n              long delta = newNodeAddress.get((int) arc.target) + addressError - writer.getPosition() - 2;\n              if (delta < 0) {\n                //System.out.println(\"neg: \" + delta);\n                anyNegDelta = true;\n                delta = 0;\n              }\n\n              if (delta < absPtr) {\n                flags |= BIT_TARGET_DELTA;\n              }\n            } else {\n              absPtr = 0;\n            }\n\n            assert flags != ARCS_AS_FIXED_ARRAY;\n            writer.writeByte(flags);\n\n            fst.writeLabel(writer, arc.label);\n\n            if (arc.output != NO_OUTPUT) {\n              outputs.write(arc.output, writer);\n              if (!retry) {\n                fst.arcWithOutputCount++;\n              }\n            }\n            if (arc.nextFinalOutput != NO_OUTPUT) {\n              outputs.writeFinalOutput(arc.nextFinalOutput, writer);\n            }\n\n            if (doWriteTarget) {\n\n              long delta = newNodeAddress.get((int) arc.target) + addressError - writer.getPosition();\n              if (delta < 0) {\n                anyNegDelta = true;\n                //System.out.println(\"neg: \" + delta);\n                delta = 0;\n              }\n\n              if (flag(flags, BIT_TARGET_DELTA)) {\n                //System.out.println(\"        delta\");\n                writer.writeVLong(delta);\n                if (!retry) {\n                  deltaCount++;\n                }\n              } else {\n                /*\n                if (ptr != null) {\n                  System.out.println(\"        deref\");\n                } else {\n                  System.out.println(\"        abs\");\n                }\n                */\n                writer.writeVLong(absPtr);\n                if (!retry) {\n                  if (absPtr >= topNodeMap.size()) {\n                    absCount++;\n                  } else {\n                    topCount++;\n                  }\n                }\n              }\n            }\n\n            if (useArcArray) {\n              final int arcBytes = (int) (writer.getPosition() - arcStartPos);\n              //System.out.println(\"  \" + arcBytes + \" bytes\");\n              maxBytesPerArc = Math.max(maxBytesPerArc, arcBytes);\n              // NOTE: this may in fact go \"backwards\", if\n              // somehow (rarely, possibly never) we use\n              // more bytesPerArc in this rewrite than the\n              // incoming FST did... but in this case we\n              // will retry (below) so it's OK to ovewrite\n              // bytes:\n              //wasted += bytesPerArc - arcBytes;\n              writer.skipBytes((int) (arcStartPos + bytesPerArc - writer.getPosition()));\n            }\n\n            if (arc.isLast()) {\n              break;\n            }\n\n            readNextRealArc(arc, r);\n          }\n\n          if (useArcArray) {\n            if (maxBytesPerArc == bytesPerArc || (retry && maxBytesPerArc <= bytesPerArc)) {\n              // converged\n              //System.out.println(\"  bba=\" + bytesPerArc + \" wasted=\" + wasted);\n              //totWasted += wasted;\n              break;\n            }\n          } else {\n            break;\n          }\n\n          //System.out.println(\"  retry this node maxBytesPerArc=\" + maxBytesPerArc + \" vs \" + bytesPerArc);\n\n          // Retry:\n          bytesPerArc = maxBytesPerArc;\n          writer.truncate(address);\n          nodeArcCount = 0;\n          retry = true;\n          anyNegDelta = false;\n        }\n\n        negDelta |= anyNegDelta;\n\n        fst.arcCount += nodeArcCount;\n      }\n\n      if (!changed) {\n        // We don't renumber the nodes (just reverse their\n        // order) so nodes should only point forward to\n        // other nodes because we only produce acyclic FSTs\n        // w/ nodes only pointing \"forwards\":\n        assert !negDelta;\n        //System.out.println(\"TOT wasted=\" + totWasted);\n        // Converged!\n        break;\n      }\n      //System.out.println(\"  \" + changedCount + \" of \" + fst.nodeCount + \" changed; retry\");\n    }\n\n    long maxAddress = 0;\n    for (long key : topNodeMap.keySet()) {\n      maxAddress = Math.max(maxAddress, newNodeAddress.get((int) key));\n    }\n\n    PackedInts.Mutable nodeRefToAddressIn = PackedInts.getMutable(topNodeMap.size(),\n        PackedInts.bitsRequired(maxAddress), acceptableOverheadRatio);\n    for(Map.Entry<Integer,Integer> ent : topNodeMap.entrySet()) {\n      nodeRefToAddressIn.set(ent.getValue(), newNodeAddress.get(ent.getKey()));\n    }\n    fst.nodeRefToAddress = nodeRefToAddressIn;\n    \n    fst.startNode = newNodeAddress.get((int) startNode);\n    //System.out.println(\"new startNode=\" + fst.startNode + \" old startNode=\" + startNode);\n\n    if (emptyOutput != null) {\n      fst.setEmptyOutput(emptyOutput);\n    }\n\n    assert fst.nodeCount == nodeCount: \"fst.nodeCount=\" + fst.nodeCount + \" nodeCount=\" + nodeCount;\n    assert fst.arcCount == arcCount;\n    assert fst.arcWithOutputCount == arcWithOutputCount: \"fst.arcWithOutputCount=\" + fst.arcWithOutputCount + \" arcWithOutputCount=\" + arcWithOutputCount;\n\n    fst.bytes.finish();\n    fst.cacheRootArcs();\n\n    //final int size = fst.sizeInBytes();\n    //System.out.println(\"nextCount=\" + nextCount + \" topCount=\" + topCount + \" deltaCount=\" + deltaCount + \" absCount=\" + absCount);\n\n    return fst;\n  }\n\n","sourceOld":"  /** Expert: creates an FST by packing this one.  This\n   *  process requires substantial additional RAM (currently\n   *  up to ~8 bytes per node depending on\n   *  <code>acceptableOverheadRatio</code>), but then should\n   *  produce a smaller FST.\n   *\n   *  <p>The implementation of this method uses ideas from\n   *  <a target=\"_blank\" href=\"http://www.cs.put.poznan.pl/dweiss/site/publications/download/fsacomp.pdf\">Smaller Representation of Finite State Automata</a>,\n   *  which describes techniques to reduce the size of a FST.\n   *  However, this is not a strict implementation of the\n   *  algorithms described in this paper.\n   */\n  FST<T> pack(int minInCountDeref, int maxDerefNodes, float acceptableOverheadRatio) throws IOException {\n\n    // TODO: other things to try\n    //   - renumber the nodes to get more next / better locality?\n    //   - allow multiple input labels on an arc, so\n    //     singular chain of inputs can take one arc (on\n    //     wikipedia terms this could save another ~6%)\n    //   - in the ord case, the output '1' is presumably\n    //     very common (after NO_OUTPUT)... maybe use a bit\n    //     for it..?\n    //   - use spare bits in flags.... for top few labels /\n    //     outputs / targets\n\n    if (nodeAddress == null) {\n      throw new IllegalArgumentException(\"this FST was not built with willPackFST=true\");\n    }\n\n    Arc<T> arc = new Arc<T>();\n\n    final BytesReader r = getBytesReader(0);\n\n    final int topN = Math.min(maxDerefNodes, inCounts.size());\n\n    // Find top nodes with highest number of incoming arcs:\n    NodeQueue q = new NodeQueue(topN);\n\n    // TODO: we could use more RAM efficient selection algo here...\n    NodeAndInCount bottom = null;\n    for(int node=0; node<inCounts.size(); node++) {\n      if (inCounts.get(node) >= minInCountDeref) {\n        if (bottom == null) {\n          q.add(new NodeAndInCount(node, (int) inCounts.get(node)));\n          if (q.size() == topN) {\n            bottom = q.top();\n          }\n        } else if (inCounts.get(node) > bottom.count) {\n          q.insertWithOverflow(new NodeAndInCount(node, (int) inCounts.get(node)));\n        }\n      }\n    }\n\n    // Free up RAM:\n    inCounts = null;\n\n    final Map<Integer,Integer> topNodeMap = new HashMap<Integer,Integer>();\n    for(int downTo=q.size()-1;downTo>=0;downTo--) {\n      NodeAndInCount n = q.pop();\n      topNodeMap.put(n.node, downTo);\n      //System.out.println(\"map node=\" + n.node + \" inCount=\" + n.count + \" to newID=\" + downTo);\n    }\n\n    final FST<T> fst = new FST<T>(inputType, null, outputs);\n\n    final BytesWriter writer = fst.writer;\n\n    // +1 because node ords start at 1 (0 is reserved as stop node):\n    final GrowableWriter newNodeAddress = new GrowableWriter(\n        PackedInts.bitsRequired(bytes.length), 1 + nodeCount, acceptableOverheadRatio);\n\n    // Fill initial coarse guess:\n    for(int node=1;node<=nodeCount;node++) {\n      newNodeAddress.set(node, 1 + bytes.length - nodeAddress.get(node));\n    }\n\n    int absCount;\n    int deltaCount;\n    int topCount;\n    int nextCount;\n\n    // Iterate until we converge:\n    while(true) {\n\n      //System.out.println(\"\\nITER\");\n      boolean changed = false;\n\n      // for assert:\n      boolean negDelta = false;\n\n      writer.setPosition(0);\n      // Skip 0 byte since 0 is reserved target:\n      writer.writeByte((byte) 0);\n\n      fst.arcWithOutputCount = 0;\n      fst.nodeCount = 0;\n      fst.arcCount = 0;\n\n      absCount = deltaCount = topCount = nextCount = 0;\n\n      int changedCount = 0;\n\n      int addressError = 0;\n\n      //int totWasted = 0;\n\n      // Since we re-reverse the bytes, we now write the\n      // nodes backwards, so that BIT_TARGET_NEXT is\n      // unchanged:\n      for(int node=nodeCount;node>=1;node--) {\n        fst.nodeCount++;\n        final int address = writer.getPosition();\n        //System.out.println(\"  node: \" + node + \" address=\" + address);\n        if (address != newNodeAddress.get(node)) {\n          addressError = address - (int) newNodeAddress.get(node);\n          //System.out.println(\"    change: \" + (address - newNodeAddress[node]));\n          changed = true;\n          newNodeAddress.set(node, address);\n          changedCount++;\n        }\n\n        int nodeArcCount = 0;\n        int bytesPerArc = 0;\n\n        boolean retry = false;\n\n        // for assert:\n        boolean anyNegDelta = false;\n\n        // Retry loop: possibly iterate more than once, if\n        // this is an array'd node and bytesPerArc changes:\n        writeNode:\n        while(true) { // retry writing this node\n\n          readFirstRealTargetArc(node, arc, r);\n\n          final boolean useArcArray = arc.bytesPerArc != 0;\n          if (useArcArray) {\n            // Write false first arc:\n            if (bytesPerArc == 0) {\n              bytesPerArc = arc.bytesPerArc;\n            }\n            writer.writeByte(ARCS_AS_FIXED_ARRAY);\n            writer.writeVInt(arc.numArcs);\n            writer.writeVInt(bytesPerArc);\n            //System.out.println(\"node \" + node + \": \" + arc.numArcs + \" arcs\");\n          }\n\n          int maxBytesPerArc = 0;\n          //int wasted = 0;\n          while(true) {  // iterate over all arcs for this node\n\n            //System.out.println(\"    arc label=\" + arc.label + \" target=\" + arc.target + \" pos=\" + writer.posWrite);\n            final int arcStartPos = writer.getPosition();\n            nodeArcCount++;\n\n            byte flags = 0;\n\n            if (arc.isLast()) {\n              flags += BIT_LAST_ARC;\n            }\n            /*\n            if (!useArcArray && nodeUpto < nodes.length-1 && arc.target == nodes[nodeUpto+1]) {\n              flags += BIT_TARGET_NEXT;\n            }\n            */\n            if (!useArcArray && node != 1 && arc.target == node-1) {\n              flags += BIT_TARGET_NEXT;\n              if (!retry) {\n                nextCount++;\n              }\n            }\n            if (arc.isFinal()) {\n              flags += BIT_FINAL_ARC;\n              if (arc.nextFinalOutput != NO_OUTPUT) {\n                flags += BIT_ARC_HAS_FINAL_OUTPUT;\n              }\n            } else {\n              assert arc.nextFinalOutput == NO_OUTPUT;\n            }\n            if (!targetHasArcs(arc)) {\n              flags += BIT_STOP_NODE;\n            }\n\n            if (arc.output != NO_OUTPUT) {\n              flags += BIT_ARC_HAS_OUTPUT;\n            }\n\n            final Integer ptr;\n            final int absPtr;\n            final boolean doWriteTarget = targetHasArcs(arc) && (flags & BIT_TARGET_NEXT) == 0;\n            if (doWriteTarget) {\n\n              ptr = topNodeMap.get(arc.target);\n              if (ptr != null) {\n                absPtr = ptr;\n              } else {\n                absPtr = topNodeMap.size() + (int) newNodeAddress.get(arc.target) + addressError;\n              }\n\n              int delta = (int) newNodeAddress.get(arc.target) + addressError - writer.getPosition() - 2;\n              if (delta < 0) {\n                //System.out.println(\"neg: \" + delta);\n                anyNegDelta = true;\n                delta = 0;\n              }\n\n              if (delta < absPtr) {\n                flags |= BIT_TARGET_DELTA;\n              }\n            } else {\n              ptr = null;\n              absPtr = 0;\n            }\n\n            writer.writeByte(flags);\n            fst.writeLabel(arc.label);\n\n            if (arc.output != NO_OUTPUT) {\n              outputs.write(arc.output, writer);\n              if (!retry) {\n                fst.arcWithOutputCount++;\n              }\n            }\n            if (arc.nextFinalOutput != NO_OUTPUT) {\n              outputs.writeFinalOutput(arc.nextFinalOutput, writer);\n            }\n\n            if (doWriteTarget) {\n\n              int delta = (int) newNodeAddress.get(arc.target) + addressError - writer.getPosition();\n              if (delta < 0) {\n                anyNegDelta = true;\n                //System.out.println(\"neg: \" + delta);\n                delta = 0;\n              }\n\n              if (flag(flags, BIT_TARGET_DELTA)) {\n                //System.out.println(\"        delta\");\n                writer.writeVInt(delta);\n                if (!retry) {\n                  deltaCount++;\n                }\n              } else {\n                /*\n                if (ptr != null) {\n                  System.out.println(\"        deref\");\n                } else {\n                  System.out.println(\"        abs\");\n                }\n                */\n                writer.writeVInt(absPtr);\n                if (!retry) {\n                  if (absPtr >= topNodeMap.size()) {\n                    absCount++;\n                  } else {\n                    topCount++;\n                  }\n                }\n              }\n            }\n\n            if (useArcArray) {\n              final int arcBytes = writer.getPosition() - arcStartPos;\n              //System.out.println(\"  \" + arcBytes + \" bytes\");\n              maxBytesPerArc = Math.max(maxBytesPerArc, arcBytes);\n              // NOTE: this may in fact go \"backwards\", if\n              // somehow (rarely, possibly never) we use\n              // more bytesPerArc in this rewrite than the\n              // incoming FST did... but in this case we\n              // will retry (below) so it's OK to ovewrite\n              // bytes:\n              //wasted += bytesPerArc - arcBytes;\n              writer.setPosition(arcStartPos + bytesPerArc);\n            }\n\n            if (arc.isLast()) {\n              break;\n            }\n\n            readNextRealArc(arc, r);\n          }\n\n          if (useArcArray) {\n            if (maxBytesPerArc == bytesPerArc || (retry && maxBytesPerArc <= bytesPerArc)) {\n              // converged\n              //System.out.println(\"  bba=\" + bytesPerArc + \" wasted=\" + wasted);\n              //totWasted += wasted;\n              break;\n            }\n          } else {\n            break;\n          }\n\n          //System.out.println(\"  retry this node maxBytesPerArc=\" + maxBytesPerArc + \" vs \" + bytesPerArc);\n\n          // Retry:\n          bytesPerArc = maxBytesPerArc;\n          writer.setPosition(address);\n          nodeArcCount = 0;\n          retry = true;\n          anyNegDelta = false;\n        }\n        negDelta |= anyNegDelta;\n\n        fst.arcCount += nodeArcCount;\n      }\n\n      if (!changed) {\n        // We don't renumber the nodes (just reverse their\n        // order) so nodes should only point forward to\n        // other nodes because we only produce acyclic FSTs\n        // w/ nodes only pointing \"forwards\":\n        assert !negDelta;\n        //System.out.println(\"TOT wasted=\" + totWasted);\n        // Converged!\n        break;\n      }\n      //System.out.println(\"  \" + changedCount + \" of \" + fst.nodeCount + \" changed; retry\");\n    }\n\n    long maxAddress = 0;\n    for (int key : topNodeMap.keySet()) {\n      maxAddress = Math.max(maxAddress, newNodeAddress.get(key));\n    }\n\n    PackedInts.Mutable nodeRefToAddressIn = PackedInts.getMutable(topNodeMap.size(),\n        PackedInts.bitsRequired(maxAddress), acceptableOverheadRatio);\n    for(Map.Entry<Integer,Integer> ent : topNodeMap.entrySet()) {\n      nodeRefToAddressIn.set(ent.getValue(), newNodeAddress.get(ent.getKey()));\n    }\n    fst.nodeRefToAddress = nodeRefToAddressIn;\n    \n\n    fst.startNode = (int) newNodeAddress.get(startNode);\n    //System.out.println(\"new startNode=\" + fst.startNode + \" old startNode=\" + startNode);\n\n    if (emptyOutput != null) {\n      fst.setEmptyOutput(emptyOutput);\n    }\n\n    assert fst.nodeCount == nodeCount: \"fst.nodeCount=\" + fst.nodeCount + \" nodeCount=\" + nodeCount;\n    assert fst.arcCount == arcCount;\n    assert fst.arcWithOutputCount == arcWithOutputCount: \"fst.arcWithOutputCount=\" + fst.arcWithOutputCount + \" arcWithOutputCount=\" + arcWithOutputCount;\n    \n    final byte[] finalBytes = new byte[writer.getPosition()];\n    //System.out.println(\"resize \" + fst.bytes.length + \" down to \" + writer.posWrite);\n    System.arraycopy(fst.bytes, 0, finalBytes, 0, writer.getPosition());\n    fst.bytes = finalBytes;\n    fst.cacheRootArcs();\n\n    //final int size = fst.sizeInBytes();\n    //System.out.println(\"nextCount=\" + nextCount + \" topCount=\" + topCount + \" deltaCount=\" + deltaCount + \" absCount=\" + absCount);\n\n    return fst;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"82557a475db3e0849171dc0be5b02e3ae0745ddb","date":1358195918,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#pack(int,int,float).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#pack(int,int,float).mjava","sourceNew":"  /** Expert: creates an FST by packing this one.  This\n   *  process requires substantial additional RAM (currently\n   *  up to ~8 bytes per node depending on\n   *  <code>acceptableOverheadRatio</code>), but then should\n   *  produce a smaller FST.\n   *\n   *  <p>The implementation of this method uses ideas from\n   *  <a target=\"_blank\" href=\"http://www.cs.put.poznan.pl/dweiss/site/publications/download/fsacomp.pdf\">Smaller Representation of Finite State Automata</a>,\n   *  which describes techniques to reduce the size of a FST.\n   *  However, this is not a strict implementation of the\n   *  algorithms described in this paper.\n   */\n  FST<T> pack(int minInCountDeref, int maxDerefNodes, float acceptableOverheadRatio) throws IOException {\n\n    // NOTE: maxDerefNodes is intentionally int: we cannot\n    // support > 2.1B deref nodes\n\n    // TODO: other things to try\n    //   - renumber the nodes to get more next / better locality?\n    //   - allow multiple input labels on an arc, so\n    //     singular chain of inputs can take one arc (on\n    //     wikipedia terms this could save another ~6%)\n    //   - in the ord case, the output '1' is presumably\n    //     very common (after NO_OUTPUT)... maybe use a bit\n    //     for it..?\n    //   - use spare bits in flags.... for top few labels /\n    //     outputs / targets\n\n    if (nodeAddress == null) {\n      throw new IllegalArgumentException(\"this FST was not built with willPackFST=true\");\n    }\n\n    Arc<T> arc = new Arc<T>();\n\n    final BytesReader r = getBytesReader();\n\n    final int topN = Math.min(maxDerefNodes, inCounts.size());\n\n    // Find top nodes with highest number of incoming arcs:\n    NodeQueue q = new NodeQueue(topN);\n\n    // TODO: we could use more RAM efficient selection algo here...\n    NodeAndInCount bottom = null;\n    for(int node=0; node<inCounts.size(); node++) {\n      if (inCounts.get(node) >= minInCountDeref) {\n        if (bottom == null) {\n          q.add(new NodeAndInCount(node, (int) inCounts.get(node)));\n          if (q.size() == topN) {\n            bottom = q.top();\n          }\n        } else if (inCounts.get(node) > bottom.count) {\n          q.insertWithOverflow(new NodeAndInCount(node, (int) inCounts.get(node)));\n        }\n      }\n    }\n\n    // Free up RAM:\n    inCounts = null;\n\n    final Map<Integer,Integer> topNodeMap = new HashMap<Integer,Integer>();\n    for(int downTo=q.size()-1;downTo>=0;downTo--) {\n      NodeAndInCount n = q.pop();\n      topNodeMap.put(n.node, downTo);\n      //System.out.println(\"map node=\" + n.node + \" inCount=\" + n.count + \" to newID=\" + downTo);\n    }\n\n    // +1 because node ords start at 1 (0 is reserved as stop node):\n    final GrowableWriter newNodeAddress = new GrowableWriter(\n                       PackedInts.bitsRequired(this.bytes.getPosition()), (int) (1 + nodeCount), acceptableOverheadRatio);\n\n    // Fill initial coarse guess:\n    for(int node=1;node<=nodeCount;node++) {\n      newNodeAddress.set(node, 1 + this.bytes.getPosition() - nodeAddress.get(node));\n    }\n\n    int absCount;\n    int deltaCount;\n    int topCount;\n    int nextCount;\n\n    FST<T> fst;\n\n    // Iterate until we converge:\n    while(true) {\n\n      //System.out.println(\"\\nITER\");\n      boolean changed = false;\n\n      // for assert:\n      boolean negDelta = false;\n\n      fst = new FST<T>(inputType, outputs, bytes.getBlockBits());\n      \n      final BytesStore writer = fst.bytes;\n\n      // Skip 0 byte since 0 is reserved target:\n      writer.writeByte((byte) 0);\n\n      fst.arcWithOutputCount = 0;\n      fst.nodeCount = 0;\n      fst.arcCount = 0;\n\n      absCount = deltaCount = topCount = nextCount = 0;\n\n      int changedCount = 0;\n\n      long addressError = 0;\n\n      //int totWasted = 0;\n\n      // Since we re-reverse the bytes, we now write the\n      // nodes backwards, so that BIT_TARGET_NEXT is\n      // unchanged:\n      for(int node=(int)nodeCount;node>=1;node--) {\n        fst.nodeCount++;\n        final long address = writer.getPosition();\n\n        //System.out.println(\"  node: \" + node + \" address=\" + address);\n        if (address != newNodeAddress.get(node)) {\n          addressError = address - newNodeAddress.get(node);\n          //System.out.println(\"    change: \" + (address - newNodeAddress[node]));\n          changed = true;\n          newNodeAddress.set(node, address);\n          changedCount++;\n        }\n\n        int nodeArcCount = 0;\n        int bytesPerArc = 0;\n\n        boolean retry = false;\n\n        // for assert:\n        boolean anyNegDelta = false;\n\n        // Retry loop: possibly iterate more than once, if\n        // this is an array'd node and bytesPerArc changes:\n        writeNode:\n        while(true) { // retry writing this node\n\n          //System.out.println(\"  cycle: retry\");\n          readFirstRealTargetArc(node, arc, r);\n\n          final boolean useArcArray = arc.bytesPerArc != 0;\n          if (useArcArray) {\n            // Write false first arc:\n            if (bytesPerArc == 0) {\n              bytesPerArc = arc.bytesPerArc;\n            }\n            writer.writeByte(ARCS_AS_FIXED_ARRAY);\n            writer.writeVInt(arc.numArcs);\n            writer.writeVInt(bytesPerArc);\n            //System.out.println(\"node \" + node + \": \" + arc.numArcs + \" arcs\");\n          }\n\n          int maxBytesPerArc = 0;\n          //int wasted = 0;\n          while(true) {  // iterate over all arcs for this node\n            //System.out.println(\"    cycle next arc\");\n\n            final long arcStartPos = writer.getPosition();\n            nodeArcCount++;\n\n            byte flags = 0;\n\n            if (arc.isLast()) {\n              flags += BIT_LAST_ARC;\n            }\n            /*\n            if (!useArcArray && nodeUpto < nodes.length-1 && arc.target == nodes[nodeUpto+1]) {\n              flags += BIT_TARGET_NEXT;\n            }\n            */\n            if (!useArcArray && node != 1 && arc.target == node-1) {\n              flags += BIT_TARGET_NEXT;\n              if (!retry) {\n                nextCount++;\n              }\n            }\n            if (arc.isFinal()) {\n              flags += BIT_FINAL_ARC;\n              if (arc.nextFinalOutput != NO_OUTPUT) {\n                flags += BIT_ARC_HAS_FINAL_OUTPUT;\n              }\n            } else {\n              assert arc.nextFinalOutput == NO_OUTPUT;\n            }\n            if (!targetHasArcs(arc)) {\n              flags += BIT_STOP_NODE;\n            }\n\n            if (arc.output != NO_OUTPUT) {\n              flags += BIT_ARC_HAS_OUTPUT;\n            }\n\n            final long absPtr;\n            final boolean doWriteTarget = targetHasArcs(arc) && (flags & BIT_TARGET_NEXT) == 0;\n            if (doWriteTarget) {\n\n              final Integer ptr = topNodeMap.get(arc.target);\n              if (ptr != null) {\n                absPtr = ptr;\n              } else {\n                absPtr = topNodeMap.size() + newNodeAddress.get((int) arc.target) + addressError;\n              }\n\n              long delta = newNodeAddress.get((int) arc.target) + addressError - writer.getPosition() - 2;\n              if (delta < 0) {\n                //System.out.println(\"neg: \" + delta);\n                anyNegDelta = true;\n                delta = 0;\n              }\n\n              if (delta < absPtr) {\n                flags |= BIT_TARGET_DELTA;\n              }\n            } else {\n              absPtr = 0;\n            }\n\n            assert flags != ARCS_AS_FIXED_ARRAY;\n            writer.writeByte(flags);\n\n            fst.writeLabel(writer, arc.label);\n\n            if (arc.output != NO_OUTPUT) {\n              outputs.write(arc.output, writer);\n              if (!retry) {\n                fst.arcWithOutputCount++;\n              }\n            }\n            if (arc.nextFinalOutput != NO_OUTPUT) {\n              outputs.writeFinalOutput(arc.nextFinalOutput, writer);\n            }\n\n            if (doWriteTarget) {\n\n              long delta = newNodeAddress.get((int) arc.target) + addressError - writer.getPosition();\n              if (delta < 0) {\n                anyNegDelta = true;\n                //System.out.println(\"neg: \" + delta);\n                delta = 0;\n              }\n\n              if (flag(flags, BIT_TARGET_DELTA)) {\n                //System.out.println(\"        delta\");\n                writer.writeVLong(delta);\n                if (!retry) {\n                  deltaCount++;\n                }\n              } else {\n                /*\n                if (ptr != null) {\n                  System.out.println(\"        deref\");\n                } else {\n                  System.out.println(\"        abs\");\n                }\n                */\n                writer.writeVLong(absPtr);\n                if (!retry) {\n                  if (absPtr >= topNodeMap.size()) {\n                    absCount++;\n                  } else {\n                    topCount++;\n                  }\n                }\n              }\n            }\n\n            if (useArcArray) {\n              final int arcBytes = (int) (writer.getPosition() - arcStartPos);\n              //System.out.println(\"  \" + arcBytes + \" bytes\");\n              maxBytesPerArc = Math.max(maxBytesPerArc, arcBytes);\n              // NOTE: this may in fact go \"backwards\", if\n              // somehow (rarely, possibly never) we use\n              // more bytesPerArc in this rewrite than the\n              // incoming FST did... but in this case we\n              // will retry (below) so it's OK to ovewrite\n              // bytes:\n              //wasted += bytesPerArc - arcBytes;\n              writer.skipBytes((int) (arcStartPos + bytesPerArc - writer.getPosition()));\n            }\n\n            if (arc.isLast()) {\n              break;\n            }\n\n            readNextRealArc(arc, r);\n          }\n\n          if (useArcArray) {\n            if (maxBytesPerArc == bytesPerArc || (retry && maxBytesPerArc <= bytesPerArc)) {\n              // converged\n              //System.out.println(\"  bba=\" + bytesPerArc + \" wasted=\" + wasted);\n              //totWasted += wasted;\n              break;\n            }\n          } else {\n            break;\n          }\n\n          //System.out.println(\"  retry this node maxBytesPerArc=\" + maxBytesPerArc + \" vs \" + bytesPerArc);\n\n          // Retry:\n          bytesPerArc = maxBytesPerArc;\n          writer.truncate(address);\n          nodeArcCount = 0;\n          retry = true;\n          anyNegDelta = false;\n        }\n\n        negDelta |= anyNegDelta;\n\n        fst.arcCount += nodeArcCount;\n      }\n\n      if (!changed) {\n        // We don't renumber the nodes (just reverse their\n        // order) so nodes should only point forward to\n        // other nodes because we only produce acyclic FSTs\n        // w/ nodes only pointing \"forwards\":\n        assert !negDelta;\n        //System.out.println(\"TOT wasted=\" + totWasted);\n        // Converged!\n        break;\n      }\n      //System.out.println(\"  \" + changedCount + \" of \" + fst.nodeCount + \" changed; retry\");\n    }\n\n    long maxAddress = 0;\n    for (long key : topNodeMap.keySet()) {\n      maxAddress = Math.max(maxAddress, newNodeAddress.get((int) key));\n    }\n\n    PackedInts.Mutable nodeRefToAddressIn = PackedInts.getMutable(topNodeMap.size(),\n        PackedInts.bitsRequired(maxAddress), acceptableOverheadRatio);\n    for(Map.Entry<Integer,Integer> ent : topNodeMap.entrySet()) {\n      nodeRefToAddressIn.set(ent.getValue(), newNodeAddress.get(ent.getKey()));\n    }\n    fst.nodeRefToAddress = nodeRefToAddressIn;\n    \n    fst.startNode = newNodeAddress.get((int) startNode);\n    //System.out.println(\"new startNode=\" + fst.startNode + \" old startNode=\" + startNode);\n\n    if (emptyOutput != null) {\n      fst.setEmptyOutput(emptyOutput);\n    }\n\n    assert fst.nodeCount == nodeCount: \"fst.nodeCount=\" + fst.nodeCount + \" nodeCount=\" + nodeCount;\n    assert fst.arcCount == arcCount;\n    assert fst.arcWithOutputCount == arcWithOutputCount: \"fst.arcWithOutputCount=\" + fst.arcWithOutputCount + \" arcWithOutputCount=\" + arcWithOutputCount;\n\n    fst.bytes.finish();\n    fst.cacheRootArcs();\n\n    //final int size = fst.sizeInBytes();\n    //System.out.println(\"nextCount=\" + nextCount + \" topCount=\" + topCount + \" deltaCount=\" + deltaCount + \" absCount=\" + absCount);\n\n    return fst;\n  }\n\n","sourceOld":"  /** Expert: creates an FST by packing this one.  This\n   *  process requires substantial additional RAM (currently\n   *  up to ~8 bytes per node depending on\n   *  <code>acceptableOverheadRatio</code>), but then should\n   *  produce a smaller FST.\n   *\n   *  <p>The implementation of this method uses ideas from\n   *  <a target=\"_blank\" href=\"http://www.cs.put.poznan.pl/dweiss/site/publications/download/fsacomp.pdf\">Smaller Representation of Finite State Automata</a>,\n   *  which describes techniques to reduce the size of a FST.\n   *  However, this is not a strict implementation of the\n   *  algorithms described in this paper.\n   */\n  FST<T> pack(int minInCountDeref, int maxDerefNodes, float acceptableOverheadRatio) throws IOException {\n\n    // NOTE: maxDerefNodes is intentionally int: we cannot\n    // support > 2.1B deref nodes\n\n    // TODO: other things to try\n    //   - renumber the nodes to get more next / better locality?\n    //   - allow multiple input labels on an arc, so\n    //     singular chain of inputs can take one arc (on\n    //     wikipedia terms this could save another ~6%)\n    //   - in the ord case, the output '1' is presumably\n    //     very common (after NO_OUTPUT)... maybe use a bit\n    //     for it..?\n    //   - use spare bits in flags.... for top few labels /\n    //     outputs / targets\n\n    if (nodeAddress == null) {\n      throw new IllegalArgumentException(\"this FST was not built with willPackFST=true\");\n    }\n\n    Arc<T> arc = new Arc<T>();\n\n    final BytesReader r = getBytesReader(0);\n\n    final int topN = Math.min(maxDerefNodes, inCounts.size());\n\n    // Find top nodes with highest number of incoming arcs:\n    NodeQueue q = new NodeQueue(topN);\n\n    // TODO: we could use more RAM efficient selection algo here...\n    NodeAndInCount bottom = null;\n    for(int node=0; node<inCounts.size(); node++) {\n      if (inCounts.get(node) >= minInCountDeref) {\n        if (bottom == null) {\n          q.add(new NodeAndInCount(node, (int) inCounts.get(node)));\n          if (q.size() == topN) {\n            bottom = q.top();\n          }\n        } else if (inCounts.get(node) > bottom.count) {\n          q.insertWithOverflow(new NodeAndInCount(node, (int) inCounts.get(node)));\n        }\n      }\n    }\n\n    // Free up RAM:\n    inCounts = null;\n\n    final Map<Integer,Integer> topNodeMap = new HashMap<Integer,Integer>();\n    for(int downTo=q.size()-1;downTo>=0;downTo--) {\n      NodeAndInCount n = q.pop();\n      topNodeMap.put(n.node, downTo);\n      //System.out.println(\"map node=\" + n.node + \" inCount=\" + n.count + \" to newID=\" + downTo);\n    }\n\n    // +1 because node ords start at 1 (0 is reserved as stop node):\n    final GrowableWriter newNodeAddress = new GrowableWriter(\n                       PackedInts.bitsRequired(this.bytes.getPosition()), (int) (1 + nodeCount), acceptableOverheadRatio);\n\n    // Fill initial coarse guess:\n    for(int node=1;node<=nodeCount;node++) {\n      newNodeAddress.set(node, 1 + this.bytes.getPosition() - nodeAddress.get(node));\n    }\n\n    int absCount;\n    int deltaCount;\n    int topCount;\n    int nextCount;\n\n    FST<T> fst;\n\n    // Iterate until we converge:\n    while(true) {\n\n      //System.out.println(\"\\nITER\");\n      boolean changed = false;\n\n      // for assert:\n      boolean negDelta = false;\n\n      fst = new FST<T>(inputType, outputs, bytes.getBlockBits());\n      \n      final BytesStore writer = fst.bytes;\n\n      // Skip 0 byte since 0 is reserved target:\n      writer.writeByte((byte) 0);\n\n      fst.arcWithOutputCount = 0;\n      fst.nodeCount = 0;\n      fst.arcCount = 0;\n\n      absCount = deltaCount = topCount = nextCount = 0;\n\n      int changedCount = 0;\n\n      long addressError = 0;\n\n      //int totWasted = 0;\n\n      // Since we re-reverse the bytes, we now write the\n      // nodes backwards, so that BIT_TARGET_NEXT is\n      // unchanged:\n      for(int node=(int)nodeCount;node>=1;node--) {\n        fst.nodeCount++;\n        final long address = writer.getPosition();\n\n        //System.out.println(\"  node: \" + node + \" address=\" + address);\n        if (address != newNodeAddress.get(node)) {\n          addressError = address - newNodeAddress.get(node);\n          //System.out.println(\"    change: \" + (address - newNodeAddress[node]));\n          changed = true;\n          newNodeAddress.set(node, address);\n          changedCount++;\n        }\n\n        int nodeArcCount = 0;\n        int bytesPerArc = 0;\n\n        boolean retry = false;\n\n        // for assert:\n        boolean anyNegDelta = false;\n\n        // Retry loop: possibly iterate more than once, if\n        // this is an array'd node and bytesPerArc changes:\n        writeNode:\n        while(true) { // retry writing this node\n\n          //System.out.println(\"  cycle: retry\");\n          readFirstRealTargetArc(node, arc, r);\n\n          final boolean useArcArray = arc.bytesPerArc != 0;\n          if (useArcArray) {\n            // Write false first arc:\n            if (bytesPerArc == 0) {\n              bytesPerArc = arc.bytesPerArc;\n            }\n            writer.writeByte(ARCS_AS_FIXED_ARRAY);\n            writer.writeVInt(arc.numArcs);\n            writer.writeVInt(bytesPerArc);\n            //System.out.println(\"node \" + node + \": \" + arc.numArcs + \" arcs\");\n          }\n\n          int maxBytesPerArc = 0;\n          //int wasted = 0;\n          while(true) {  // iterate over all arcs for this node\n            //System.out.println(\"    cycle next arc\");\n\n            final long arcStartPos = writer.getPosition();\n            nodeArcCount++;\n\n            byte flags = 0;\n\n            if (arc.isLast()) {\n              flags += BIT_LAST_ARC;\n            }\n            /*\n            if (!useArcArray && nodeUpto < nodes.length-1 && arc.target == nodes[nodeUpto+1]) {\n              flags += BIT_TARGET_NEXT;\n            }\n            */\n            if (!useArcArray && node != 1 && arc.target == node-1) {\n              flags += BIT_TARGET_NEXT;\n              if (!retry) {\n                nextCount++;\n              }\n            }\n            if (arc.isFinal()) {\n              flags += BIT_FINAL_ARC;\n              if (arc.nextFinalOutput != NO_OUTPUT) {\n                flags += BIT_ARC_HAS_FINAL_OUTPUT;\n              }\n            } else {\n              assert arc.nextFinalOutput == NO_OUTPUT;\n            }\n            if (!targetHasArcs(arc)) {\n              flags += BIT_STOP_NODE;\n            }\n\n            if (arc.output != NO_OUTPUT) {\n              flags += BIT_ARC_HAS_OUTPUT;\n            }\n\n            final long absPtr;\n            final boolean doWriteTarget = targetHasArcs(arc) && (flags & BIT_TARGET_NEXT) == 0;\n            if (doWriteTarget) {\n\n              final Integer ptr = topNodeMap.get(arc.target);\n              if (ptr != null) {\n                absPtr = ptr;\n              } else {\n                absPtr = topNodeMap.size() + newNodeAddress.get((int) arc.target) + addressError;\n              }\n\n              long delta = newNodeAddress.get((int) arc.target) + addressError - writer.getPosition() - 2;\n              if (delta < 0) {\n                //System.out.println(\"neg: \" + delta);\n                anyNegDelta = true;\n                delta = 0;\n              }\n\n              if (delta < absPtr) {\n                flags |= BIT_TARGET_DELTA;\n              }\n            } else {\n              absPtr = 0;\n            }\n\n            assert flags != ARCS_AS_FIXED_ARRAY;\n            writer.writeByte(flags);\n\n            fst.writeLabel(writer, arc.label);\n\n            if (arc.output != NO_OUTPUT) {\n              outputs.write(arc.output, writer);\n              if (!retry) {\n                fst.arcWithOutputCount++;\n              }\n            }\n            if (arc.nextFinalOutput != NO_OUTPUT) {\n              outputs.writeFinalOutput(arc.nextFinalOutput, writer);\n            }\n\n            if (doWriteTarget) {\n\n              long delta = newNodeAddress.get((int) arc.target) + addressError - writer.getPosition();\n              if (delta < 0) {\n                anyNegDelta = true;\n                //System.out.println(\"neg: \" + delta);\n                delta = 0;\n              }\n\n              if (flag(flags, BIT_TARGET_DELTA)) {\n                //System.out.println(\"        delta\");\n                writer.writeVLong(delta);\n                if (!retry) {\n                  deltaCount++;\n                }\n              } else {\n                /*\n                if (ptr != null) {\n                  System.out.println(\"        deref\");\n                } else {\n                  System.out.println(\"        abs\");\n                }\n                */\n                writer.writeVLong(absPtr);\n                if (!retry) {\n                  if (absPtr >= topNodeMap.size()) {\n                    absCount++;\n                  } else {\n                    topCount++;\n                  }\n                }\n              }\n            }\n\n            if (useArcArray) {\n              final int arcBytes = (int) (writer.getPosition() - arcStartPos);\n              //System.out.println(\"  \" + arcBytes + \" bytes\");\n              maxBytesPerArc = Math.max(maxBytesPerArc, arcBytes);\n              // NOTE: this may in fact go \"backwards\", if\n              // somehow (rarely, possibly never) we use\n              // more bytesPerArc in this rewrite than the\n              // incoming FST did... but in this case we\n              // will retry (below) so it's OK to ovewrite\n              // bytes:\n              //wasted += bytesPerArc - arcBytes;\n              writer.skipBytes((int) (arcStartPos + bytesPerArc - writer.getPosition()));\n            }\n\n            if (arc.isLast()) {\n              break;\n            }\n\n            readNextRealArc(arc, r);\n          }\n\n          if (useArcArray) {\n            if (maxBytesPerArc == bytesPerArc || (retry && maxBytesPerArc <= bytesPerArc)) {\n              // converged\n              //System.out.println(\"  bba=\" + bytesPerArc + \" wasted=\" + wasted);\n              //totWasted += wasted;\n              break;\n            }\n          } else {\n            break;\n          }\n\n          //System.out.println(\"  retry this node maxBytesPerArc=\" + maxBytesPerArc + \" vs \" + bytesPerArc);\n\n          // Retry:\n          bytesPerArc = maxBytesPerArc;\n          writer.truncate(address);\n          nodeArcCount = 0;\n          retry = true;\n          anyNegDelta = false;\n        }\n\n        negDelta |= anyNegDelta;\n\n        fst.arcCount += nodeArcCount;\n      }\n\n      if (!changed) {\n        // We don't renumber the nodes (just reverse their\n        // order) so nodes should only point forward to\n        // other nodes because we only produce acyclic FSTs\n        // w/ nodes only pointing \"forwards\":\n        assert !negDelta;\n        //System.out.println(\"TOT wasted=\" + totWasted);\n        // Converged!\n        break;\n      }\n      //System.out.println(\"  \" + changedCount + \" of \" + fst.nodeCount + \" changed; retry\");\n    }\n\n    long maxAddress = 0;\n    for (long key : topNodeMap.keySet()) {\n      maxAddress = Math.max(maxAddress, newNodeAddress.get((int) key));\n    }\n\n    PackedInts.Mutable nodeRefToAddressIn = PackedInts.getMutable(topNodeMap.size(),\n        PackedInts.bitsRequired(maxAddress), acceptableOverheadRatio);\n    for(Map.Entry<Integer,Integer> ent : topNodeMap.entrySet()) {\n      nodeRefToAddressIn.set(ent.getValue(), newNodeAddress.get(ent.getKey()));\n    }\n    fst.nodeRefToAddress = nodeRefToAddressIn;\n    \n    fst.startNode = newNodeAddress.get((int) startNode);\n    //System.out.println(\"new startNode=\" + fst.startNode + \" old startNode=\" + startNode);\n\n    if (emptyOutput != null) {\n      fst.setEmptyOutput(emptyOutput);\n    }\n\n    assert fst.nodeCount == nodeCount: \"fst.nodeCount=\" + fst.nodeCount + \" nodeCount=\" + nodeCount;\n    assert fst.arcCount == arcCount;\n    assert fst.arcWithOutputCount == arcWithOutputCount: \"fst.arcWithOutputCount=\" + fst.arcWithOutputCount + \" arcWithOutputCount=\" + arcWithOutputCount;\n\n    fst.bytes.finish();\n    fst.cacheRootArcs();\n\n    //final int size = fst.sizeInBytes();\n    //System.out.println(\"nextCount=\" + nextCount + \" topCount=\" + topCount + \" deltaCount=\" + deltaCount + \" absCount=\" + absCount);\n\n    return fst;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c4015cd39dff8d4dec562d909f9766debac53aa6","date":1358548736,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#pack(int,int,float).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#pack(int,int,float).mjava","sourceNew":"  /** Expert: creates an FST by packing this one.  This\n   *  process requires substantial additional RAM (currently\n   *  up to ~8 bytes per node depending on\n   *  <code>acceptableOverheadRatio</code>), but then should\n   *  produce a smaller FST.\n   *\n   *  <p>The implementation of this method uses ideas from\n   *  <a target=\"_blank\" href=\"http://www.cs.put.poznan.pl/dweiss/site/publications/download/fsacomp.pdf\">Smaller Representation of Finite State Automata</a>,\n   *  which describes techniques to reduce the size of a FST.\n   *  However, this is not a strict implementation of the\n   *  algorithms described in this paper.\n   */\n  FST<T> pack(int minInCountDeref, int maxDerefNodes, float acceptableOverheadRatio) throws IOException {\n\n    // NOTE: maxDerefNodes is intentionally int: we cannot\n    // support > 2.1B deref nodes\n\n    // TODO: other things to try\n    //   - renumber the nodes to get more next / better locality?\n    //   - allow multiple input labels on an arc, so\n    //     singular chain of inputs can take one arc (on\n    //     wikipedia terms this could save another ~6%)\n    //   - in the ord case, the output '1' is presumably\n    //     very common (after NO_OUTPUT)... maybe use a bit\n    //     for it..?\n    //   - use spare bits in flags.... for top few labels /\n    //     outputs / targets\n\n    if (nodeAddress == null) {\n      throw new IllegalArgumentException(\"this FST was not built with willPackFST=true\");\n    }\n\n    Arc<T> arc = new Arc<T>();\n\n    final BytesReader r = getBytesReader();\n\n    final int topN = Math.min(maxDerefNodes, inCounts.size());\n\n    // Find top nodes with highest number of incoming arcs:\n    NodeQueue q = new NodeQueue(topN);\n\n    // TODO: we could use more RAM efficient selection algo here...\n    NodeAndInCount bottom = null;\n    for(int node=0; node<inCounts.size(); node++) {\n      if (inCounts.get(node) >= minInCountDeref) {\n        if (bottom == null) {\n          q.add(new NodeAndInCount(node, (int) inCounts.get(node)));\n          if (q.size() == topN) {\n            bottom = q.top();\n          }\n        } else if (inCounts.get(node) > bottom.count) {\n          q.insertWithOverflow(new NodeAndInCount(node, (int) inCounts.get(node)));\n        }\n      }\n    }\n\n    // Free up RAM:\n    inCounts = null;\n\n    final Map<Integer,Integer> topNodeMap = new HashMap<Integer,Integer>();\n    for(int downTo=q.size()-1;downTo>=0;downTo--) {\n      NodeAndInCount n = q.pop();\n      topNodeMap.put(n.node, downTo);\n      //System.out.println(\"map node=\" + n.node + \" inCount=\" + n.count + \" to newID=\" + downTo);\n    }\n\n    // +1 because node ords start at 1 (0 is reserved as stop node):\n    final GrowableWriter newNodeAddress = new GrowableWriter(\n                       PackedInts.bitsRequired(this.bytes.getPosition()), (int) (1 + nodeCount), acceptableOverheadRatio);\n\n    // Fill initial coarse guess:\n    for(int node=1;node<=nodeCount;node++) {\n      newNodeAddress.set(node, 1 + this.bytes.getPosition() - nodeAddress.get(node));\n    }\n\n    int absCount;\n    int deltaCount;\n    int topCount;\n    int nextCount;\n\n    FST<T> fst;\n\n    // Iterate until we converge:\n    while(true) {\n\n      //System.out.println(\"\\nITER\");\n      boolean changed = false;\n\n      // for assert:\n      boolean negDelta = false;\n\n      fst = new FST<T>(inputType, outputs, bytes.getBlockBits());\n      \n      final BytesStore writer = fst.bytes;\n\n      // Skip 0 byte since 0 is reserved target:\n      writer.writeByte((byte) 0);\n\n      fst.arcWithOutputCount = 0;\n      fst.nodeCount = 0;\n      fst.arcCount = 0;\n\n      absCount = deltaCount = topCount = nextCount = 0;\n\n      int changedCount = 0;\n\n      long addressError = 0;\n\n      //int totWasted = 0;\n\n      // Since we re-reverse the bytes, we now write the\n      // nodes backwards, so that BIT_TARGET_NEXT is\n      // unchanged:\n      for(int node=(int)nodeCount;node>=1;node--) {\n        fst.nodeCount++;\n        final long address = writer.getPosition();\n\n        //System.out.println(\"  node: \" + node + \" address=\" + address);\n        if (address != newNodeAddress.get(node)) {\n          addressError = address - newNodeAddress.get(node);\n          //System.out.println(\"    change: \" + (address - newNodeAddress[node]));\n          changed = true;\n          newNodeAddress.set(node, address);\n          changedCount++;\n        }\n\n        int nodeArcCount = 0;\n        int bytesPerArc = 0;\n\n        boolean retry = false;\n\n        // for assert:\n        boolean anyNegDelta = false;\n\n        // Retry loop: possibly iterate more than once, if\n        // this is an array'd node and bytesPerArc changes:\n        writeNode:\n        while(true) { // retry writing this node\n\n          //System.out.println(\"  cycle: retry\");\n          readFirstRealTargetArc(node, arc, r);\n\n          final boolean useArcArray = arc.bytesPerArc != 0;\n          if (useArcArray) {\n            // Write false first arc:\n            if (bytesPerArc == 0) {\n              bytesPerArc = arc.bytesPerArc;\n            }\n            writer.writeByte(ARCS_AS_FIXED_ARRAY);\n            writer.writeVInt(arc.numArcs);\n            writer.writeVInt(bytesPerArc);\n            //System.out.println(\"node \" + node + \": \" + arc.numArcs + \" arcs\");\n          }\n\n          int maxBytesPerArc = 0;\n          //int wasted = 0;\n          while(true) {  // iterate over all arcs for this node\n            //System.out.println(\"    cycle next arc\");\n\n            final long arcStartPos = writer.getPosition();\n            nodeArcCount++;\n\n            byte flags = 0;\n\n            if (arc.isLast()) {\n              flags += BIT_LAST_ARC;\n            }\n            /*\n            if (!useArcArray && nodeUpto < nodes.length-1 && arc.target == nodes[nodeUpto+1]) {\n              flags += BIT_TARGET_NEXT;\n            }\n            */\n            if (!useArcArray && node != 1 && arc.target == node-1) {\n              flags += BIT_TARGET_NEXT;\n              if (!retry) {\n                nextCount++;\n              }\n            }\n            if (arc.isFinal()) {\n              flags += BIT_FINAL_ARC;\n              if (arc.nextFinalOutput != NO_OUTPUT) {\n                flags += BIT_ARC_HAS_FINAL_OUTPUT;\n              }\n            } else {\n              assert arc.nextFinalOutput == NO_OUTPUT;\n            }\n            if (!targetHasArcs(arc)) {\n              flags += BIT_STOP_NODE;\n            }\n\n            if (arc.output != NO_OUTPUT) {\n              flags += BIT_ARC_HAS_OUTPUT;\n            }\n\n            final long absPtr;\n            final boolean doWriteTarget = targetHasArcs(arc) && (flags & BIT_TARGET_NEXT) == 0;\n            if (doWriteTarget) {\n\n              final Integer ptr = topNodeMap.get(arc.target);\n              if (ptr != null) {\n                absPtr = ptr;\n              } else {\n                absPtr = topNodeMap.size() + newNodeAddress.get((int) arc.target) + addressError;\n              }\n\n              long delta = newNodeAddress.get((int) arc.target) + addressError - writer.getPosition() - 2;\n              if (delta < 0) {\n                //System.out.println(\"neg: \" + delta);\n                anyNegDelta = true;\n                delta = 0;\n              }\n\n              if (delta < absPtr) {\n                flags |= BIT_TARGET_DELTA;\n              }\n            } else {\n              absPtr = 0;\n            }\n\n            assert flags != ARCS_AS_FIXED_ARRAY;\n            writer.writeByte(flags);\n\n            fst.writeLabel(writer, arc.label);\n\n            if (arc.output != NO_OUTPUT) {\n              outputs.write(arc.output, writer);\n              if (!retry) {\n                fst.arcWithOutputCount++;\n              }\n            }\n            if (arc.nextFinalOutput != NO_OUTPUT) {\n              outputs.writeFinalOutput(arc.nextFinalOutput, writer);\n            }\n\n            if (doWriteTarget) {\n\n              long delta = newNodeAddress.get((int) arc.target) + addressError - writer.getPosition();\n              if (delta < 0) {\n                anyNegDelta = true;\n                //System.out.println(\"neg: \" + delta);\n                delta = 0;\n              }\n\n              if (flag(flags, BIT_TARGET_DELTA)) {\n                //System.out.println(\"        delta\");\n                writer.writeVLong(delta);\n                if (!retry) {\n                  deltaCount++;\n                }\n              } else {\n                /*\n                if (ptr != null) {\n                  System.out.println(\"        deref\");\n                } else {\n                  System.out.println(\"        abs\");\n                }\n                */\n                writer.writeVLong(absPtr);\n                if (!retry) {\n                  if (absPtr >= topNodeMap.size()) {\n                    absCount++;\n                  } else {\n                    topCount++;\n                  }\n                }\n              }\n            }\n\n            if (useArcArray) {\n              final int arcBytes = (int) (writer.getPosition() - arcStartPos);\n              //System.out.println(\"  \" + arcBytes + \" bytes\");\n              maxBytesPerArc = Math.max(maxBytesPerArc, arcBytes);\n              // NOTE: this may in fact go \"backwards\", if\n              // somehow (rarely, possibly never) we use\n              // more bytesPerArc in this rewrite than the\n              // incoming FST did... but in this case we\n              // will retry (below) so it's OK to ovewrite\n              // bytes:\n              //wasted += bytesPerArc - arcBytes;\n              writer.skipBytes((int) (arcStartPos + bytesPerArc - writer.getPosition()));\n            }\n\n            if (arc.isLast()) {\n              break;\n            }\n\n            readNextRealArc(arc, r);\n          }\n\n          if (useArcArray) {\n            if (maxBytesPerArc == bytesPerArc || (retry && maxBytesPerArc <= bytesPerArc)) {\n              // converged\n              //System.out.println(\"  bba=\" + bytesPerArc + \" wasted=\" + wasted);\n              //totWasted += wasted;\n              break;\n            }\n          } else {\n            break;\n          }\n\n          //System.out.println(\"  retry this node maxBytesPerArc=\" + maxBytesPerArc + \" vs \" + bytesPerArc);\n\n          // Retry:\n          bytesPerArc = maxBytesPerArc;\n          writer.truncate(address);\n          nodeArcCount = 0;\n          retry = true;\n          anyNegDelta = false;\n        }\n\n        negDelta |= anyNegDelta;\n\n        fst.arcCount += nodeArcCount;\n      }\n\n      if (!changed) {\n        // We don't renumber the nodes (just reverse their\n        // order) so nodes should only point forward to\n        // other nodes because we only produce acyclic FSTs\n        // w/ nodes only pointing \"forwards\":\n        assert !negDelta;\n        //System.out.println(\"TOT wasted=\" + totWasted);\n        // Converged!\n        break;\n      }\n      //System.out.println(\"  \" + changedCount + \" of \" + fst.nodeCount + \" changed; retry\");\n    }\n\n    long maxAddress = 0;\n    for (long key : topNodeMap.keySet()) {\n      maxAddress = Math.max(maxAddress, newNodeAddress.get((int) key));\n    }\n\n    PackedInts.Mutable nodeRefToAddressIn = PackedInts.getMutable(topNodeMap.size(),\n        PackedInts.bitsRequired(maxAddress), acceptableOverheadRatio);\n    for(Map.Entry<Integer,Integer> ent : topNodeMap.entrySet()) {\n      nodeRefToAddressIn.set(ent.getValue(), newNodeAddress.get(ent.getKey()));\n    }\n    fst.nodeRefToAddress = nodeRefToAddressIn;\n    \n    fst.startNode = newNodeAddress.get((int) startNode);\n    //System.out.println(\"new startNode=\" + fst.startNode + \" old startNode=\" + startNode);\n\n    if (emptyOutput != null) {\n      fst.setEmptyOutput(emptyOutput);\n    }\n\n    assert fst.nodeCount == nodeCount: \"fst.nodeCount=\" + fst.nodeCount + \" nodeCount=\" + nodeCount;\n    assert fst.arcCount == arcCount;\n    assert fst.arcWithOutputCount == arcWithOutputCount: \"fst.arcWithOutputCount=\" + fst.arcWithOutputCount + \" arcWithOutputCount=\" + arcWithOutputCount;\n\n    fst.bytes.finish();\n    fst.cacheRootArcs();\n\n    //final int size = fst.sizeInBytes();\n    //System.out.println(\"nextCount=\" + nextCount + \" topCount=\" + topCount + \" deltaCount=\" + deltaCount + \" absCount=\" + absCount);\n\n    return fst;\n  }\n\n","sourceOld":"  /** Expert: creates an FST by packing this one.  This\n   *  process requires substantial additional RAM (currently\n   *  up to ~8 bytes per node depending on\n   *  <code>acceptableOverheadRatio</code>), but then should\n   *  produce a smaller FST.\n   *\n   *  <p>The implementation of this method uses ideas from\n   *  <a target=\"_blank\" href=\"http://www.cs.put.poznan.pl/dweiss/site/publications/download/fsacomp.pdf\">Smaller Representation of Finite State Automata</a>,\n   *  which describes techniques to reduce the size of a FST.\n   *  However, this is not a strict implementation of the\n   *  algorithms described in this paper.\n   */\n  FST<T> pack(int minInCountDeref, int maxDerefNodes, float acceptableOverheadRatio) throws IOException {\n\n    // NOTE: maxDerefNodes is intentionally int: we cannot\n    // support > 2.1B deref nodes\n\n    // TODO: other things to try\n    //   - renumber the nodes to get more next / better locality?\n    //   - allow multiple input labels on an arc, so\n    //     singular chain of inputs can take one arc (on\n    //     wikipedia terms this could save another ~6%)\n    //   - in the ord case, the output '1' is presumably\n    //     very common (after NO_OUTPUT)... maybe use a bit\n    //     for it..?\n    //   - use spare bits in flags.... for top few labels /\n    //     outputs / targets\n\n    if (nodeAddress == null) {\n      throw new IllegalArgumentException(\"this FST was not built with willPackFST=true\");\n    }\n\n    Arc<T> arc = new Arc<T>();\n\n    final BytesReader r = getBytesReader(0);\n\n    final int topN = Math.min(maxDerefNodes, inCounts.size());\n\n    // Find top nodes with highest number of incoming arcs:\n    NodeQueue q = new NodeQueue(topN);\n\n    // TODO: we could use more RAM efficient selection algo here...\n    NodeAndInCount bottom = null;\n    for(int node=0; node<inCounts.size(); node++) {\n      if (inCounts.get(node) >= minInCountDeref) {\n        if (bottom == null) {\n          q.add(new NodeAndInCount(node, (int) inCounts.get(node)));\n          if (q.size() == topN) {\n            bottom = q.top();\n          }\n        } else if (inCounts.get(node) > bottom.count) {\n          q.insertWithOverflow(new NodeAndInCount(node, (int) inCounts.get(node)));\n        }\n      }\n    }\n\n    // Free up RAM:\n    inCounts = null;\n\n    final Map<Integer,Integer> topNodeMap = new HashMap<Integer,Integer>();\n    for(int downTo=q.size()-1;downTo>=0;downTo--) {\n      NodeAndInCount n = q.pop();\n      topNodeMap.put(n.node, downTo);\n      //System.out.println(\"map node=\" + n.node + \" inCount=\" + n.count + \" to newID=\" + downTo);\n    }\n\n    // +1 because node ords start at 1 (0 is reserved as stop node):\n    final GrowableWriter newNodeAddress = new GrowableWriter(\n                       PackedInts.bitsRequired(this.bytes.getPosition()), (int) (1 + nodeCount), acceptableOverheadRatio);\n\n    // Fill initial coarse guess:\n    for(int node=1;node<=nodeCount;node++) {\n      newNodeAddress.set(node, 1 + this.bytes.getPosition() - nodeAddress.get(node));\n    }\n\n    int absCount;\n    int deltaCount;\n    int topCount;\n    int nextCount;\n\n    FST<T> fst;\n\n    // Iterate until we converge:\n    while(true) {\n\n      //System.out.println(\"\\nITER\");\n      boolean changed = false;\n\n      // for assert:\n      boolean negDelta = false;\n\n      fst = new FST<T>(inputType, outputs, bytes.getBlockBits());\n      \n      final BytesStore writer = fst.bytes;\n\n      // Skip 0 byte since 0 is reserved target:\n      writer.writeByte((byte) 0);\n\n      fst.arcWithOutputCount = 0;\n      fst.nodeCount = 0;\n      fst.arcCount = 0;\n\n      absCount = deltaCount = topCount = nextCount = 0;\n\n      int changedCount = 0;\n\n      long addressError = 0;\n\n      //int totWasted = 0;\n\n      // Since we re-reverse the bytes, we now write the\n      // nodes backwards, so that BIT_TARGET_NEXT is\n      // unchanged:\n      for(int node=(int)nodeCount;node>=1;node--) {\n        fst.nodeCount++;\n        final long address = writer.getPosition();\n\n        //System.out.println(\"  node: \" + node + \" address=\" + address);\n        if (address != newNodeAddress.get(node)) {\n          addressError = address - newNodeAddress.get(node);\n          //System.out.println(\"    change: \" + (address - newNodeAddress[node]));\n          changed = true;\n          newNodeAddress.set(node, address);\n          changedCount++;\n        }\n\n        int nodeArcCount = 0;\n        int bytesPerArc = 0;\n\n        boolean retry = false;\n\n        // for assert:\n        boolean anyNegDelta = false;\n\n        // Retry loop: possibly iterate more than once, if\n        // this is an array'd node and bytesPerArc changes:\n        writeNode:\n        while(true) { // retry writing this node\n\n          //System.out.println(\"  cycle: retry\");\n          readFirstRealTargetArc(node, arc, r);\n\n          final boolean useArcArray = arc.bytesPerArc != 0;\n          if (useArcArray) {\n            // Write false first arc:\n            if (bytesPerArc == 0) {\n              bytesPerArc = arc.bytesPerArc;\n            }\n            writer.writeByte(ARCS_AS_FIXED_ARRAY);\n            writer.writeVInt(arc.numArcs);\n            writer.writeVInt(bytesPerArc);\n            //System.out.println(\"node \" + node + \": \" + arc.numArcs + \" arcs\");\n          }\n\n          int maxBytesPerArc = 0;\n          //int wasted = 0;\n          while(true) {  // iterate over all arcs for this node\n            //System.out.println(\"    cycle next arc\");\n\n            final long arcStartPos = writer.getPosition();\n            nodeArcCount++;\n\n            byte flags = 0;\n\n            if (arc.isLast()) {\n              flags += BIT_LAST_ARC;\n            }\n            /*\n            if (!useArcArray && nodeUpto < nodes.length-1 && arc.target == nodes[nodeUpto+1]) {\n              flags += BIT_TARGET_NEXT;\n            }\n            */\n            if (!useArcArray && node != 1 && arc.target == node-1) {\n              flags += BIT_TARGET_NEXT;\n              if (!retry) {\n                nextCount++;\n              }\n            }\n            if (arc.isFinal()) {\n              flags += BIT_FINAL_ARC;\n              if (arc.nextFinalOutput != NO_OUTPUT) {\n                flags += BIT_ARC_HAS_FINAL_OUTPUT;\n              }\n            } else {\n              assert arc.nextFinalOutput == NO_OUTPUT;\n            }\n            if (!targetHasArcs(arc)) {\n              flags += BIT_STOP_NODE;\n            }\n\n            if (arc.output != NO_OUTPUT) {\n              flags += BIT_ARC_HAS_OUTPUT;\n            }\n\n            final long absPtr;\n            final boolean doWriteTarget = targetHasArcs(arc) && (flags & BIT_TARGET_NEXT) == 0;\n            if (doWriteTarget) {\n\n              final Integer ptr = topNodeMap.get(arc.target);\n              if (ptr != null) {\n                absPtr = ptr;\n              } else {\n                absPtr = topNodeMap.size() + newNodeAddress.get((int) arc.target) + addressError;\n              }\n\n              long delta = newNodeAddress.get((int) arc.target) + addressError - writer.getPosition() - 2;\n              if (delta < 0) {\n                //System.out.println(\"neg: \" + delta);\n                anyNegDelta = true;\n                delta = 0;\n              }\n\n              if (delta < absPtr) {\n                flags |= BIT_TARGET_DELTA;\n              }\n            } else {\n              absPtr = 0;\n            }\n\n            assert flags != ARCS_AS_FIXED_ARRAY;\n            writer.writeByte(flags);\n\n            fst.writeLabel(writer, arc.label);\n\n            if (arc.output != NO_OUTPUT) {\n              outputs.write(arc.output, writer);\n              if (!retry) {\n                fst.arcWithOutputCount++;\n              }\n            }\n            if (arc.nextFinalOutput != NO_OUTPUT) {\n              outputs.writeFinalOutput(arc.nextFinalOutput, writer);\n            }\n\n            if (doWriteTarget) {\n\n              long delta = newNodeAddress.get((int) arc.target) + addressError - writer.getPosition();\n              if (delta < 0) {\n                anyNegDelta = true;\n                //System.out.println(\"neg: \" + delta);\n                delta = 0;\n              }\n\n              if (flag(flags, BIT_TARGET_DELTA)) {\n                //System.out.println(\"        delta\");\n                writer.writeVLong(delta);\n                if (!retry) {\n                  deltaCount++;\n                }\n              } else {\n                /*\n                if (ptr != null) {\n                  System.out.println(\"        deref\");\n                } else {\n                  System.out.println(\"        abs\");\n                }\n                */\n                writer.writeVLong(absPtr);\n                if (!retry) {\n                  if (absPtr >= topNodeMap.size()) {\n                    absCount++;\n                  } else {\n                    topCount++;\n                  }\n                }\n              }\n            }\n\n            if (useArcArray) {\n              final int arcBytes = (int) (writer.getPosition() - arcStartPos);\n              //System.out.println(\"  \" + arcBytes + \" bytes\");\n              maxBytesPerArc = Math.max(maxBytesPerArc, arcBytes);\n              // NOTE: this may in fact go \"backwards\", if\n              // somehow (rarely, possibly never) we use\n              // more bytesPerArc in this rewrite than the\n              // incoming FST did... but in this case we\n              // will retry (below) so it's OK to ovewrite\n              // bytes:\n              //wasted += bytesPerArc - arcBytes;\n              writer.skipBytes((int) (arcStartPos + bytesPerArc - writer.getPosition()));\n            }\n\n            if (arc.isLast()) {\n              break;\n            }\n\n            readNextRealArc(arc, r);\n          }\n\n          if (useArcArray) {\n            if (maxBytesPerArc == bytesPerArc || (retry && maxBytesPerArc <= bytesPerArc)) {\n              // converged\n              //System.out.println(\"  bba=\" + bytesPerArc + \" wasted=\" + wasted);\n              //totWasted += wasted;\n              break;\n            }\n          } else {\n            break;\n          }\n\n          //System.out.println(\"  retry this node maxBytesPerArc=\" + maxBytesPerArc + \" vs \" + bytesPerArc);\n\n          // Retry:\n          bytesPerArc = maxBytesPerArc;\n          writer.truncate(address);\n          nodeArcCount = 0;\n          retry = true;\n          anyNegDelta = false;\n        }\n\n        negDelta |= anyNegDelta;\n\n        fst.arcCount += nodeArcCount;\n      }\n\n      if (!changed) {\n        // We don't renumber the nodes (just reverse their\n        // order) so nodes should only point forward to\n        // other nodes because we only produce acyclic FSTs\n        // w/ nodes only pointing \"forwards\":\n        assert !negDelta;\n        //System.out.println(\"TOT wasted=\" + totWasted);\n        // Converged!\n        break;\n      }\n      //System.out.println(\"  \" + changedCount + \" of \" + fst.nodeCount + \" changed; retry\");\n    }\n\n    long maxAddress = 0;\n    for (long key : topNodeMap.keySet()) {\n      maxAddress = Math.max(maxAddress, newNodeAddress.get((int) key));\n    }\n\n    PackedInts.Mutable nodeRefToAddressIn = PackedInts.getMutable(topNodeMap.size(),\n        PackedInts.bitsRequired(maxAddress), acceptableOverheadRatio);\n    for(Map.Entry<Integer,Integer> ent : topNodeMap.entrySet()) {\n      nodeRefToAddressIn.set(ent.getValue(), newNodeAddress.get(ent.getKey()));\n    }\n    fst.nodeRefToAddress = nodeRefToAddressIn;\n    \n    fst.startNode = newNodeAddress.get((int) startNode);\n    //System.out.println(\"new startNode=\" + fst.startNode + \" old startNode=\" + startNode);\n\n    if (emptyOutput != null) {\n      fst.setEmptyOutput(emptyOutput);\n    }\n\n    assert fst.nodeCount == nodeCount: \"fst.nodeCount=\" + fst.nodeCount + \" nodeCount=\" + nodeCount;\n    assert fst.arcCount == arcCount;\n    assert fst.arcWithOutputCount == arcWithOutputCount: \"fst.arcWithOutputCount=\" + fst.arcWithOutputCount + \" arcWithOutputCount=\" + arcWithOutputCount;\n\n    fst.bytes.finish();\n    fst.cacheRootArcs();\n\n    //final int size = fst.sizeInBytes();\n    //System.out.println(\"nextCount=\" + nextCount + \" topCount=\" + topCount + \" deltaCount=\" + deltaCount + \" absCount=\" + absCount);\n\n    return fst;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#pack(int,int,float).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#pack(int,int,float).mjava","sourceNew":"  /** Expert: creates an FST by packing this one.  This\n   *  process requires substantial additional RAM (currently\n   *  up to ~8 bytes per node depending on\n   *  <code>acceptableOverheadRatio</code>), but then should\n   *  produce a smaller FST.\n   *\n   *  <p>The implementation of this method uses ideas from\n   *  <a target=\"_blank\" href=\"http://www.cs.put.poznan.pl/dweiss/site/publications/download/fsacomp.pdf\">Smaller Representation of Finite State Automata</a>,\n   *  which describes techniques to reduce the size of a FST.\n   *  However, this is not a strict implementation of the\n   *  algorithms described in this paper.\n   */\n  FST<T> pack(int minInCountDeref, int maxDerefNodes, float acceptableOverheadRatio) throws IOException {\n\n    // NOTE: maxDerefNodes is intentionally int: we cannot\n    // support > 2.1B deref nodes\n\n    // TODO: other things to try\n    //   - renumber the nodes to get more next / better locality?\n    //   - allow multiple input labels on an arc, so\n    //     singular chain of inputs can take one arc (on\n    //     wikipedia terms this could save another ~6%)\n    //   - in the ord case, the output '1' is presumably\n    //     very common (after NO_OUTPUT)... maybe use a bit\n    //     for it..?\n    //   - use spare bits in flags.... for top few labels /\n    //     outputs / targets\n\n    if (nodeAddress == null) {\n      throw new IllegalArgumentException(\"this FST was not built with willPackFST=true\");\n    }\n\n    Arc<T> arc = new Arc<>();\n\n    final BytesReader r = getBytesReader();\n\n    final int topN = Math.min(maxDerefNodes, inCounts.size());\n\n    // Find top nodes with highest number of incoming arcs:\n    NodeQueue q = new NodeQueue(topN);\n\n    // TODO: we could use more RAM efficient selection algo here...\n    NodeAndInCount bottom = null;\n    for(int node=0; node<inCounts.size(); node++) {\n      if (inCounts.get(node) >= minInCountDeref) {\n        if (bottom == null) {\n          q.add(new NodeAndInCount(node, (int) inCounts.get(node)));\n          if (q.size() == topN) {\n            bottom = q.top();\n          }\n        } else if (inCounts.get(node) > bottom.count) {\n          q.insertWithOverflow(new NodeAndInCount(node, (int) inCounts.get(node)));\n        }\n      }\n    }\n\n    // Free up RAM:\n    inCounts = null;\n\n    final Map<Integer,Integer> topNodeMap = new HashMap<>();\n    for(int downTo=q.size()-1;downTo>=0;downTo--) {\n      NodeAndInCount n = q.pop();\n      topNodeMap.put(n.node, downTo);\n      //System.out.println(\"map node=\" + n.node + \" inCount=\" + n.count + \" to newID=\" + downTo);\n    }\n\n    // +1 because node ords start at 1 (0 is reserved as stop node):\n    final GrowableWriter newNodeAddress = new GrowableWriter(\n                       PackedInts.bitsRequired(this.bytes.getPosition()), (int) (1 + nodeCount), acceptableOverheadRatio);\n\n    // Fill initial coarse guess:\n    for(int node=1;node<=nodeCount;node++) {\n      newNodeAddress.set(node, 1 + this.bytes.getPosition() - nodeAddress.get(node));\n    }\n\n    int absCount;\n    int deltaCount;\n    int topCount;\n    int nextCount;\n\n    FST<T> fst;\n\n    // Iterate until we converge:\n    while(true) {\n\n      //System.out.println(\"\\nITER\");\n      boolean changed = false;\n\n      // for assert:\n      boolean negDelta = false;\n\n      fst = new FST<>(inputType, outputs, bytes.getBlockBits());\n      \n      final BytesStore writer = fst.bytes;\n\n      // Skip 0 byte since 0 is reserved target:\n      writer.writeByte((byte) 0);\n\n      fst.arcWithOutputCount = 0;\n      fst.nodeCount = 0;\n      fst.arcCount = 0;\n\n      absCount = deltaCount = topCount = nextCount = 0;\n\n      int changedCount = 0;\n\n      long addressError = 0;\n\n      //int totWasted = 0;\n\n      // Since we re-reverse the bytes, we now write the\n      // nodes backwards, so that BIT_TARGET_NEXT is\n      // unchanged:\n      for(int node=(int)nodeCount;node>=1;node--) {\n        fst.nodeCount++;\n        final long address = writer.getPosition();\n\n        //System.out.println(\"  node: \" + node + \" address=\" + address);\n        if (address != newNodeAddress.get(node)) {\n          addressError = address - newNodeAddress.get(node);\n          //System.out.println(\"    change: \" + (address - newNodeAddress[node]));\n          changed = true;\n          newNodeAddress.set(node, address);\n          changedCount++;\n        }\n\n        int nodeArcCount = 0;\n        int bytesPerArc = 0;\n\n        boolean retry = false;\n\n        // for assert:\n        boolean anyNegDelta = false;\n\n        // Retry loop: possibly iterate more than once, if\n        // this is an array'd node and bytesPerArc changes:\n        writeNode:\n        while(true) { // retry writing this node\n\n          //System.out.println(\"  cycle: retry\");\n          readFirstRealTargetArc(node, arc, r);\n\n          final boolean useArcArray = arc.bytesPerArc != 0;\n          if (useArcArray) {\n            // Write false first arc:\n            if (bytesPerArc == 0) {\n              bytesPerArc = arc.bytesPerArc;\n            }\n            writer.writeByte(ARCS_AS_FIXED_ARRAY);\n            writer.writeVInt(arc.numArcs);\n            writer.writeVInt(bytesPerArc);\n            //System.out.println(\"node \" + node + \": \" + arc.numArcs + \" arcs\");\n          }\n\n          int maxBytesPerArc = 0;\n          //int wasted = 0;\n          while(true) {  // iterate over all arcs for this node\n            //System.out.println(\"    cycle next arc\");\n\n            final long arcStartPos = writer.getPosition();\n            nodeArcCount++;\n\n            byte flags = 0;\n\n            if (arc.isLast()) {\n              flags += BIT_LAST_ARC;\n            }\n            /*\n            if (!useArcArray && nodeUpto < nodes.length-1 && arc.target == nodes[nodeUpto+1]) {\n              flags += BIT_TARGET_NEXT;\n            }\n            */\n            if (!useArcArray && node != 1 && arc.target == node-1) {\n              flags += BIT_TARGET_NEXT;\n              if (!retry) {\n                nextCount++;\n              }\n            }\n            if (arc.isFinal()) {\n              flags += BIT_FINAL_ARC;\n              if (arc.nextFinalOutput != NO_OUTPUT) {\n                flags += BIT_ARC_HAS_FINAL_OUTPUT;\n              }\n            } else {\n              assert arc.nextFinalOutput == NO_OUTPUT;\n            }\n            if (!targetHasArcs(arc)) {\n              flags += BIT_STOP_NODE;\n            }\n\n            if (arc.output != NO_OUTPUT) {\n              flags += BIT_ARC_HAS_OUTPUT;\n            }\n\n            final long absPtr;\n            final boolean doWriteTarget = targetHasArcs(arc) && (flags & BIT_TARGET_NEXT) == 0;\n            if (doWriteTarget) {\n\n              final Integer ptr = topNodeMap.get(arc.target);\n              if (ptr != null) {\n                absPtr = ptr;\n              } else {\n                absPtr = topNodeMap.size() + newNodeAddress.get((int) arc.target) + addressError;\n              }\n\n              long delta = newNodeAddress.get((int) arc.target) + addressError - writer.getPosition() - 2;\n              if (delta < 0) {\n                //System.out.println(\"neg: \" + delta);\n                anyNegDelta = true;\n                delta = 0;\n              }\n\n              if (delta < absPtr) {\n                flags |= BIT_TARGET_DELTA;\n              }\n            } else {\n              absPtr = 0;\n            }\n\n            assert flags != ARCS_AS_FIXED_ARRAY;\n            writer.writeByte(flags);\n\n            fst.writeLabel(writer, arc.label);\n\n            if (arc.output != NO_OUTPUT) {\n              outputs.write(arc.output, writer);\n              if (!retry) {\n                fst.arcWithOutputCount++;\n              }\n            }\n            if (arc.nextFinalOutput != NO_OUTPUT) {\n              outputs.writeFinalOutput(arc.nextFinalOutput, writer);\n            }\n\n            if (doWriteTarget) {\n\n              long delta = newNodeAddress.get((int) arc.target) + addressError - writer.getPosition();\n              if (delta < 0) {\n                anyNegDelta = true;\n                //System.out.println(\"neg: \" + delta);\n                delta = 0;\n              }\n\n              if (flag(flags, BIT_TARGET_DELTA)) {\n                //System.out.println(\"        delta\");\n                writer.writeVLong(delta);\n                if (!retry) {\n                  deltaCount++;\n                }\n              } else {\n                /*\n                if (ptr != null) {\n                  System.out.println(\"        deref\");\n                } else {\n                  System.out.println(\"        abs\");\n                }\n                */\n                writer.writeVLong(absPtr);\n                if (!retry) {\n                  if (absPtr >= topNodeMap.size()) {\n                    absCount++;\n                  } else {\n                    topCount++;\n                  }\n                }\n              }\n            }\n\n            if (useArcArray) {\n              final int arcBytes = (int) (writer.getPosition() - arcStartPos);\n              //System.out.println(\"  \" + arcBytes + \" bytes\");\n              maxBytesPerArc = Math.max(maxBytesPerArc, arcBytes);\n              // NOTE: this may in fact go \"backwards\", if\n              // somehow (rarely, possibly never) we use\n              // more bytesPerArc in this rewrite than the\n              // incoming FST did... but in this case we\n              // will retry (below) so it's OK to ovewrite\n              // bytes:\n              //wasted += bytesPerArc - arcBytes;\n              writer.skipBytes((int) (arcStartPos + bytesPerArc - writer.getPosition()));\n            }\n\n            if (arc.isLast()) {\n              break;\n            }\n\n            readNextRealArc(arc, r);\n          }\n\n          if (useArcArray) {\n            if (maxBytesPerArc == bytesPerArc || (retry && maxBytesPerArc <= bytesPerArc)) {\n              // converged\n              //System.out.println(\"  bba=\" + bytesPerArc + \" wasted=\" + wasted);\n              //totWasted += wasted;\n              break;\n            }\n          } else {\n            break;\n          }\n\n          //System.out.println(\"  retry this node maxBytesPerArc=\" + maxBytesPerArc + \" vs \" + bytesPerArc);\n\n          // Retry:\n          bytesPerArc = maxBytesPerArc;\n          writer.truncate(address);\n          nodeArcCount = 0;\n          retry = true;\n          anyNegDelta = false;\n        }\n\n        negDelta |= anyNegDelta;\n\n        fst.arcCount += nodeArcCount;\n      }\n\n      if (!changed) {\n        // We don't renumber the nodes (just reverse their\n        // order) so nodes should only point forward to\n        // other nodes because we only produce acyclic FSTs\n        // w/ nodes only pointing \"forwards\":\n        assert !negDelta;\n        //System.out.println(\"TOT wasted=\" + totWasted);\n        // Converged!\n        break;\n      }\n      //System.out.println(\"  \" + changedCount + \" of \" + fst.nodeCount + \" changed; retry\");\n    }\n\n    long maxAddress = 0;\n    for (long key : topNodeMap.keySet()) {\n      maxAddress = Math.max(maxAddress, newNodeAddress.get((int) key));\n    }\n\n    PackedInts.Mutable nodeRefToAddressIn = PackedInts.getMutable(topNodeMap.size(),\n        PackedInts.bitsRequired(maxAddress), acceptableOverheadRatio);\n    for(Map.Entry<Integer,Integer> ent : topNodeMap.entrySet()) {\n      nodeRefToAddressIn.set(ent.getValue(), newNodeAddress.get(ent.getKey()));\n    }\n    fst.nodeRefToAddress = nodeRefToAddressIn;\n    \n    fst.startNode = newNodeAddress.get((int) startNode);\n    //System.out.println(\"new startNode=\" + fst.startNode + \" old startNode=\" + startNode);\n\n    if (emptyOutput != null) {\n      fst.setEmptyOutput(emptyOutput);\n    }\n\n    assert fst.nodeCount == nodeCount: \"fst.nodeCount=\" + fst.nodeCount + \" nodeCount=\" + nodeCount;\n    assert fst.arcCount == arcCount;\n    assert fst.arcWithOutputCount == arcWithOutputCount: \"fst.arcWithOutputCount=\" + fst.arcWithOutputCount + \" arcWithOutputCount=\" + arcWithOutputCount;\n\n    fst.bytes.finish();\n    fst.cacheRootArcs();\n\n    //final int size = fst.sizeInBytes();\n    //System.out.println(\"nextCount=\" + nextCount + \" topCount=\" + topCount + \" deltaCount=\" + deltaCount + \" absCount=\" + absCount);\n\n    return fst;\n  }\n\n","sourceOld":"  /** Expert: creates an FST by packing this one.  This\n   *  process requires substantial additional RAM (currently\n   *  up to ~8 bytes per node depending on\n   *  <code>acceptableOverheadRatio</code>), but then should\n   *  produce a smaller FST.\n   *\n   *  <p>The implementation of this method uses ideas from\n   *  <a target=\"_blank\" href=\"http://www.cs.put.poznan.pl/dweiss/site/publications/download/fsacomp.pdf\">Smaller Representation of Finite State Automata</a>,\n   *  which describes techniques to reduce the size of a FST.\n   *  However, this is not a strict implementation of the\n   *  algorithms described in this paper.\n   */\n  FST<T> pack(int minInCountDeref, int maxDerefNodes, float acceptableOverheadRatio) throws IOException {\n\n    // NOTE: maxDerefNodes is intentionally int: we cannot\n    // support > 2.1B deref nodes\n\n    // TODO: other things to try\n    //   - renumber the nodes to get more next / better locality?\n    //   - allow multiple input labels on an arc, so\n    //     singular chain of inputs can take one arc (on\n    //     wikipedia terms this could save another ~6%)\n    //   - in the ord case, the output '1' is presumably\n    //     very common (after NO_OUTPUT)... maybe use a bit\n    //     for it..?\n    //   - use spare bits in flags.... for top few labels /\n    //     outputs / targets\n\n    if (nodeAddress == null) {\n      throw new IllegalArgumentException(\"this FST was not built with willPackFST=true\");\n    }\n\n    Arc<T> arc = new Arc<T>();\n\n    final BytesReader r = getBytesReader();\n\n    final int topN = Math.min(maxDerefNodes, inCounts.size());\n\n    // Find top nodes with highest number of incoming arcs:\n    NodeQueue q = new NodeQueue(topN);\n\n    // TODO: we could use more RAM efficient selection algo here...\n    NodeAndInCount bottom = null;\n    for(int node=0; node<inCounts.size(); node++) {\n      if (inCounts.get(node) >= minInCountDeref) {\n        if (bottom == null) {\n          q.add(new NodeAndInCount(node, (int) inCounts.get(node)));\n          if (q.size() == topN) {\n            bottom = q.top();\n          }\n        } else if (inCounts.get(node) > bottom.count) {\n          q.insertWithOverflow(new NodeAndInCount(node, (int) inCounts.get(node)));\n        }\n      }\n    }\n\n    // Free up RAM:\n    inCounts = null;\n\n    final Map<Integer,Integer> topNodeMap = new HashMap<Integer,Integer>();\n    for(int downTo=q.size()-1;downTo>=0;downTo--) {\n      NodeAndInCount n = q.pop();\n      topNodeMap.put(n.node, downTo);\n      //System.out.println(\"map node=\" + n.node + \" inCount=\" + n.count + \" to newID=\" + downTo);\n    }\n\n    // +1 because node ords start at 1 (0 is reserved as stop node):\n    final GrowableWriter newNodeAddress = new GrowableWriter(\n                       PackedInts.bitsRequired(this.bytes.getPosition()), (int) (1 + nodeCount), acceptableOverheadRatio);\n\n    // Fill initial coarse guess:\n    for(int node=1;node<=nodeCount;node++) {\n      newNodeAddress.set(node, 1 + this.bytes.getPosition() - nodeAddress.get(node));\n    }\n\n    int absCount;\n    int deltaCount;\n    int topCount;\n    int nextCount;\n\n    FST<T> fst;\n\n    // Iterate until we converge:\n    while(true) {\n\n      //System.out.println(\"\\nITER\");\n      boolean changed = false;\n\n      // for assert:\n      boolean negDelta = false;\n\n      fst = new FST<T>(inputType, outputs, bytes.getBlockBits());\n      \n      final BytesStore writer = fst.bytes;\n\n      // Skip 0 byte since 0 is reserved target:\n      writer.writeByte((byte) 0);\n\n      fst.arcWithOutputCount = 0;\n      fst.nodeCount = 0;\n      fst.arcCount = 0;\n\n      absCount = deltaCount = topCount = nextCount = 0;\n\n      int changedCount = 0;\n\n      long addressError = 0;\n\n      //int totWasted = 0;\n\n      // Since we re-reverse the bytes, we now write the\n      // nodes backwards, so that BIT_TARGET_NEXT is\n      // unchanged:\n      for(int node=(int)nodeCount;node>=1;node--) {\n        fst.nodeCount++;\n        final long address = writer.getPosition();\n\n        //System.out.println(\"  node: \" + node + \" address=\" + address);\n        if (address != newNodeAddress.get(node)) {\n          addressError = address - newNodeAddress.get(node);\n          //System.out.println(\"    change: \" + (address - newNodeAddress[node]));\n          changed = true;\n          newNodeAddress.set(node, address);\n          changedCount++;\n        }\n\n        int nodeArcCount = 0;\n        int bytesPerArc = 0;\n\n        boolean retry = false;\n\n        // for assert:\n        boolean anyNegDelta = false;\n\n        // Retry loop: possibly iterate more than once, if\n        // this is an array'd node and bytesPerArc changes:\n        writeNode:\n        while(true) { // retry writing this node\n\n          //System.out.println(\"  cycle: retry\");\n          readFirstRealTargetArc(node, arc, r);\n\n          final boolean useArcArray = arc.bytesPerArc != 0;\n          if (useArcArray) {\n            // Write false first arc:\n            if (bytesPerArc == 0) {\n              bytesPerArc = arc.bytesPerArc;\n            }\n            writer.writeByte(ARCS_AS_FIXED_ARRAY);\n            writer.writeVInt(arc.numArcs);\n            writer.writeVInt(bytesPerArc);\n            //System.out.println(\"node \" + node + \": \" + arc.numArcs + \" arcs\");\n          }\n\n          int maxBytesPerArc = 0;\n          //int wasted = 0;\n          while(true) {  // iterate over all arcs for this node\n            //System.out.println(\"    cycle next arc\");\n\n            final long arcStartPos = writer.getPosition();\n            nodeArcCount++;\n\n            byte flags = 0;\n\n            if (arc.isLast()) {\n              flags += BIT_LAST_ARC;\n            }\n            /*\n            if (!useArcArray && nodeUpto < nodes.length-1 && arc.target == nodes[nodeUpto+1]) {\n              flags += BIT_TARGET_NEXT;\n            }\n            */\n            if (!useArcArray && node != 1 && arc.target == node-1) {\n              flags += BIT_TARGET_NEXT;\n              if (!retry) {\n                nextCount++;\n              }\n            }\n            if (arc.isFinal()) {\n              flags += BIT_FINAL_ARC;\n              if (arc.nextFinalOutput != NO_OUTPUT) {\n                flags += BIT_ARC_HAS_FINAL_OUTPUT;\n              }\n            } else {\n              assert arc.nextFinalOutput == NO_OUTPUT;\n            }\n            if (!targetHasArcs(arc)) {\n              flags += BIT_STOP_NODE;\n            }\n\n            if (arc.output != NO_OUTPUT) {\n              flags += BIT_ARC_HAS_OUTPUT;\n            }\n\n            final long absPtr;\n            final boolean doWriteTarget = targetHasArcs(arc) && (flags & BIT_TARGET_NEXT) == 0;\n            if (doWriteTarget) {\n\n              final Integer ptr = topNodeMap.get(arc.target);\n              if (ptr != null) {\n                absPtr = ptr;\n              } else {\n                absPtr = topNodeMap.size() + newNodeAddress.get((int) arc.target) + addressError;\n              }\n\n              long delta = newNodeAddress.get((int) arc.target) + addressError - writer.getPosition() - 2;\n              if (delta < 0) {\n                //System.out.println(\"neg: \" + delta);\n                anyNegDelta = true;\n                delta = 0;\n              }\n\n              if (delta < absPtr) {\n                flags |= BIT_TARGET_DELTA;\n              }\n            } else {\n              absPtr = 0;\n            }\n\n            assert flags != ARCS_AS_FIXED_ARRAY;\n            writer.writeByte(flags);\n\n            fst.writeLabel(writer, arc.label);\n\n            if (arc.output != NO_OUTPUT) {\n              outputs.write(arc.output, writer);\n              if (!retry) {\n                fst.arcWithOutputCount++;\n              }\n            }\n            if (arc.nextFinalOutput != NO_OUTPUT) {\n              outputs.writeFinalOutput(arc.nextFinalOutput, writer);\n            }\n\n            if (doWriteTarget) {\n\n              long delta = newNodeAddress.get((int) arc.target) + addressError - writer.getPosition();\n              if (delta < 0) {\n                anyNegDelta = true;\n                //System.out.println(\"neg: \" + delta);\n                delta = 0;\n              }\n\n              if (flag(flags, BIT_TARGET_DELTA)) {\n                //System.out.println(\"        delta\");\n                writer.writeVLong(delta);\n                if (!retry) {\n                  deltaCount++;\n                }\n              } else {\n                /*\n                if (ptr != null) {\n                  System.out.println(\"        deref\");\n                } else {\n                  System.out.println(\"        abs\");\n                }\n                */\n                writer.writeVLong(absPtr);\n                if (!retry) {\n                  if (absPtr >= topNodeMap.size()) {\n                    absCount++;\n                  } else {\n                    topCount++;\n                  }\n                }\n              }\n            }\n\n            if (useArcArray) {\n              final int arcBytes = (int) (writer.getPosition() - arcStartPos);\n              //System.out.println(\"  \" + arcBytes + \" bytes\");\n              maxBytesPerArc = Math.max(maxBytesPerArc, arcBytes);\n              // NOTE: this may in fact go \"backwards\", if\n              // somehow (rarely, possibly never) we use\n              // more bytesPerArc in this rewrite than the\n              // incoming FST did... but in this case we\n              // will retry (below) so it's OK to ovewrite\n              // bytes:\n              //wasted += bytesPerArc - arcBytes;\n              writer.skipBytes((int) (arcStartPos + bytesPerArc - writer.getPosition()));\n            }\n\n            if (arc.isLast()) {\n              break;\n            }\n\n            readNextRealArc(arc, r);\n          }\n\n          if (useArcArray) {\n            if (maxBytesPerArc == bytesPerArc || (retry && maxBytesPerArc <= bytesPerArc)) {\n              // converged\n              //System.out.println(\"  bba=\" + bytesPerArc + \" wasted=\" + wasted);\n              //totWasted += wasted;\n              break;\n            }\n          } else {\n            break;\n          }\n\n          //System.out.println(\"  retry this node maxBytesPerArc=\" + maxBytesPerArc + \" vs \" + bytesPerArc);\n\n          // Retry:\n          bytesPerArc = maxBytesPerArc;\n          writer.truncate(address);\n          nodeArcCount = 0;\n          retry = true;\n          anyNegDelta = false;\n        }\n\n        negDelta |= anyNegDelta;\n\n        fst.arcCount += nodeArcCount;\n      }\n\n      if (!changed) {\n        // We don't renumber the nodes (just reverse their\n        // order) so nodes should only point forward to\n        // other nodes because we only produce acyclic FSTs\n        // w/ nodes only pointing \"forwards\":\n        assert !negDelta;\n        //System.out.println(\"TOT wasted=\" + totWasted);\n        // Converged!\n        break;\n      }\n      //System.out.println(\"  \" + changedCount + \" of \" + fst.nodeCount + \" changed; retry\");\n    }\n\n    long maxAddress = 0;\n    for (long key : topNodeMap.keySet()) {\n      maxAddress = Math.max(maxAddress, newNodeAddress.get((int) key));\n    }\n\n    PackedInts.Mutable nodeRefToAddressIn = PackedInts.getMutable(topNodeMap.size(),\n        PackedInts.bitsRequired(maxAddress), acceptableOverheadRatio);\n    for(Map.Entry<Integer,Integer> ent : topNodeMap.entrySet()) {\n      nodeRefToAddressIn.set(ent.getValue(), newNodeAddress.get(ent.getKey()));\n    }\n    fst.nodeRefToAddress = nodeRefToAddressIn;\n    \n    fst.startNode = newNodeAddress.get((int) startNode);\n    //System.out.println(\"new startNode=\" + fst.startNode + \" old startNode=\" + startNode);\n\n    if (emptyOutput != null) {\n      fst.setEmptyOutput(emptyOutput);\n    }\n\n    assert fst.nodeCount == nodeCount: \"fst.nodeCount=\" + fst.nodeCount + \" nodeCount=\" + nodeCount;\n    assert fst.arcCount == arcCount;\n    assert fst.arcWithOutputCount == arcWithOutputCount: \"fst.arcWithOutputCount=\" + fst.arcWithOutputCount + \" arcWithOutputCount=\" + arcWithOutputCount;\n\n    fst.bytes.finish();\n    fst.cacheRootArcs();\n\n    //final int size = fst.sizeInBytes();\n    //System.out.println(\"nextCount=\" + nextCount + \" topCount=\" + topCount + \" deltaCount=\" + deltaCount + \" absCount=\" + absCount);\n\n    return fst;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1abb939fb41b2fe4f89fd518f3da288c0213341d","date":1435657417,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#pack(Builder[T],int,int,float).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#pack(int,int,float).mjava","sourceNew":"  /** Expert: creates an FST by packing this one.  This\n   *  process requires substantial additional RAM (currently\n   *  up to ~8 bytes per node depending on\n   *  <code>acceptableOverheadRatio</code>), but then should\n   *  produce a smaller FST.\n   *\n   *  <p>The implementation of this method uses ideas from\n   *  <a target=\"_blank\" href=\"http://www.cs.put.poznan.pl/dweiss/site/publications/download/fsacomp.pdf\">Smaller Representation of Finite State Automata</a>,\n   *  which describes techniques to reduce the size of a FST.\n   *  However, this is not a strict implementation of the\n   *  algorithms described in this paper.\n   */\n  FST<T> pack(Builder<T> builder, int minInCountDeref, int maxDerefNodes, float acceptableOverheadRatio) throws IOException {\n\n    // NOTE: maxDerefNodes is intentionally int: we cannot\n    // support > 2.1B deref nodes\n\n    // TODO: other things to try\n    //   - renumber the nodes to get more next / better locality?\n    //   - allow multiple input labels on an arc, so\n    //     singular chain of inputs can take one arc (on\n    //     wikipedia terms this could save another ~6%)\n    //   - in the ord case, the output '1' is presumably\n    //     very common (after NO_OUTPUT)... maybe use a bit\n    //     for it..?\n    //   - use spare bits in flags.... for top few labels /\n    //     outputs / targets\n\n    if (nodeAddress == null) {\n      throw new IllegalArgumentException(\"this FST was not built with willPackFST=true\");\n    }\n\n    T NO_OUTPUT = outputs.getNoOutput();\n\n    Arc<T> arc = new Arc<>();\n\n    final BytesReader r = getBytesReader();\n\n    final int topN = Math.min(maxDerefNodes, inCounts.size());\n\n    // Find top nodes with highest number of incoming arcs:\n    NodeQueue q = new NodeQueue(topN);\n\n    // TODO: we could use more RAM efficient selection algo here...\n    NodeAndInCount bottom = null;\n    for(int node=0; node<inCounts.size(); node++) {\n      if (inCounts.get(node) >= minInCountDeref) {\n        if (bottom == null) {\n          q.add(new NodeAndInCount(node, (int) inCounts.get(node)));\n          if (q.size() == topN) {\n            bottom = q.top();\n          }\n        } else if (inCounts.get(node) > bottom.count) {\n          q.insertWithOverflow(new NodeAndInCount(node, (int) inCounts.get(node)));\n        }\n      }\n    }\n\n    // Free up RAM:\n    inCounts = null;\n\n    final Map<Integer,Integer> topNodeMap = new HashMap<>();\n    for(int downTo=q.size()-1;downTo>=0;downTo--) {\n      NodeAndInCount n = q.pop();\n      topNodeMap.put(n.node, downTo);\n      //System.out.println(\"map node=\" + n.node + \" inCount=\" + n.count + \" to newID=\" + downTo);\n    }\n\n    // +1 because node ords start at 1 (0 is reserved as stop node):\n    final GrowableWriter newNodeAddress = new GrowableWriter(\n                                                             PackedInts.bitsRequired(builder.bytes.getPosition()), (int) (1 + builder.nodeCount), acceptableOverheadRatio);\n\n    // Fill initial coarse guess:\n    for(int node=1;node<=builder.nodeCount;node++) {\n      newNodeAddress.set(node, 1 + builder.bytes.getPosition() - nodeAddress.get(node));\n    }\n\n    int absCount;\n    int deltaCount;\n    int topCount;\n    int nextCount;\n\n    FST<T> fst;\n\n    // Iterate until we converge:\n    while(true) {\n\n      //System.out.println(\"\\nITER\");\n      boolean changed = false;\n\n      // for assert:\n      boolean negDelta = false;\n\n      fst = new FST<>(inputType, outputs, builder.bytes.getBlockBits());\n      \n      final BytesStore writer = fst.bytes;\n\n      // Skip 0 byte since 0 is reserved target:\n      writer.writeByte((byte) 0);\n\n      absCount = deltaCount = topCount = nextCount = 0;\n\n      int changedCount = 0;\n\n      long addressError = 0;\n\n      //int totWasted = 0;\n\n      // Since we re-reverse the bytes, we now write the\n      // nodes backwards, so that BIT_TARGET_NEXT is\n      // unchanged:\n      for(int node=(int) builder.nodeCount;node>=1;node--) {\n        final long address = writer.getPosition();\n\n        //System.out.println(\"  node: \" + node + \" address=\" + address);\n        if (address != newNodeAddress.get(node)) {\n          addressError = address - newNodeAddress.get(node);\n          //System.out.println(\"    change: \" + (address - newNodeAddress[node]));\n          changed = true;\n          newNodeAddress.set(node, address);\n          changedCount++;\n        }\n\n        int nodeArcCount = 0;\n        int bytesPerArc = 0;\n\n        boolean retry = false;\n\n        // for assert:\n        boolean anyNegDelta = false;\n\n        // Retry loop: possibly iterate more than once, if\n        // this is an array'd node and bytesPerArc changes:\n        writeNode:\n        while(true) { // retry writing this node\n\n          //System.out.println(\"  cycle: retry\");\n          readFirstRealTargetArc(node, arc, r);\n\n          final boolean useArcArray = arc.bytesPerArc != 0;\n          if (useArcArray) {\n            // Write false first arc:\n            if (bytesPerArc == 0) {\n              bytesPerArc = arc.bytesPerArc;\n            }\n            writer.writeByte(ARCS_AS_FIXED_ARRAY);\n            writer.writeVInt(arc.numArcs);\n            writer.writeVInt(bytesPerArc);\n            //System.out.println(\"node \" + node + \": \" + arc.numArcs + \" arcs\");\n          }\n\n          int maxBytesPerArc = 0;\n          //int wasted = 0;\n          while(true) {  // iterate over all arcs for this node\n            //System.out.println(\"    cycle next arc\");\n\n            final long arcStartPos = writer.getPosition();\n            nodeArcCount++;\n\n            byte flags = 0;\n\n            if (arc.isLast()) {\n              flags += BIT_LAST_ARC;\n            }\n            /*\n            if (!useArcArray && nodeUpto < nodes.length-1 && arc.target == nodes[nodeUpto+1]) {\n              flags += BIT_TARGET_NEXT;\n            }\n            */\n            if (!useArcArray && node != 1 && arc.target == node-1) {\n              flags += BIT_TARGET_NEXT;\n              if (!retry) {\n                nextCount++;\n              }\n            }\n            if (arc.isFinal()) {\n              flags += BIT_FINAL_ARC;\n              if (arc.nextFinalOutput != NO_OUTPUT) {\n                flags += BIT_ARC_HAS_FINAL_OUTPUT;\n              }\n            } else {\n              assert arc.nextFinalOutput == NO_OUTPUT;\n            }\n            if (!targetHasArcs(arc)) {\n              flags += BIT_STOP_NODE;\n            }\n\n            if (arc.output != NO_OUTPUT) {\n              flags += BIT_ARC_HAS_OUTPUT;\n            }\n\n            final long absPtr;\n            final boolean doWriteTarget = targetHasArcs(arc) && (flags & BIT_TARGET_NEXT) == 0;\n            if (doWriteTarget) {\n\n              final Integer ptr = topNodeMap.get(arc.target);\n              if (ptr != null) {\n                absPtr = ptr;\n              } else {\n                absPtr = topNodeMap.size() + newNodeAddress.get((int) arc.target) + addressError;\n              }\n\n              long delta = newNodeAddress.get((int) arc.target) + addressError - writer.getPosition() - 2;\n              if (delta < 0) {\n                //System.out.println(\"neg: \" + delta);\n                anyNegDelta = true;\n                delta = 0;\n              }\n\n              if (delta < absPtr) {\n                flags |= BIT_TARGET_DELTA;\n              }\n            } else {\n              absPtr = 0;\n            }\n\n            assert flags != ARCS_AS_FIXED_ARRAY;\n            writer.writeByte(flags);\n\n            fst.writeLabel(writer, arc.label);\n\n            if (arc.output != NO_OUTPUT) {\n              outputs.write(arc.output, writer);\n            }\n            if (arc.nextFinalOutput != NO_OUTPUT) {\n              outputs.writeFinalOutput(arc.nextFinalOutput, writer);\n            }\n\n            if (doWriteTarget) {\n\n              long delta = newNodeAddress.get((int) arc.target) + addressError - writer.getPosition();\n              if (delta < 0) {\n                anyNegDelta = true;\n                //System.out.println(\"neg: \" + delta);\n                delta = 0;\n              }\n\n              if (flag(flags, BIT_TARGET_DELTA)) {\n                //System.out.println(\"        delta\");\n                writer.writeVLong(delta);\n                if (!retry) {\n                  deltaCount++;\n                }\n              } else {\n                /*\n                if (ptr != null) {\n                  System.out.println(\"        deref\");\n                } else {\n                  System.out.println(\"        abs\");\n                }\n                */\n                writer.writeVLong(absPtr);\n                if (!retry) {\n                  if (absPtr >= topNodeMap.size()) {\n                    absCount++;\n                  } else {\n                    topCount++;\n                  }\n                }\n              }\n            }\n\n            if (useArcArray) {\n              final int arcBytes = (int) (writer.getPosition() - arcStartPos);\n              //System.out.println(\"  \" + arcBytes + \" bytes\");\n              maxBytesPerArc = Math.max(maxBytesPerArc, arcBytes);\n              // NOTE: this may in fact go \"backwards\", if\n              // somehow (rarely, possibly never) we use\n              // more bytesPerArc in this rewrite than the\n              // incoming FST did... but in this case we\n              // will retry (below) so it's OK to ovewrite\n              // bytes:\n              //wasted += bytesPerArc - arcBytes;\n              writer.skipBytes((int) (arcStartPos + bytesPerArc - writer.getPosition()));\n            }\n\n            if (arc.isLast()) {\n              break;\n            }\n\n            readNextRealArc(arc, r);\n          }\n\n          if (useArcArray) {\n            if (maxBytesPerArc == bytesPerArc || (retry && maxBytesPerArc <= bytesPerArc)) {\n              // converged\n              //System.out.println(\"  bba=\" + bytesPerArc + \" wasted=\" + wasted);\n              //totWasted += wasted;\n              break;\n            }\n          } else {\n            break;\n          }\n\n          //System.out.println(\"  retry this node maxBytesPerArc=\" + maxBytesPerArc + \" vs \" + bytesPerArc);\n\n          // Retry:\n          bytesPerArc = maxBytesPerArc;\n          writer.truncate(address);\n          nodeArcCount = 0;\n          retry = true;\n          anyNegDelta = false;\n        }\n\n        negDelta |= anyNegDelta;\n      }\n\n      if (!changed) {\n        // We don't renumber the nodes (just reverse their\n        // order) so nodes should only point forward to\n        // other nodes because we only produce acyclic FSTs\n        // w/ nodes only pointing \"forwards\":\n        assert !negDelta;\n        //System.out.println(\"TOT wasted=\" + totWasted);\n        // Converged!\n        break;\n      }\n    }\n\n    long maxAddress = 0;\n    for (long key : topNodeMap.keySet()) {\n      maxAddress = Math.max(maxAddress, newNodeAddress.get((int) key));\n    }\n\n    PackedInts.Mutable nodeRefToAddressIn = PackedInts.getMutable(topNodeMap.size(),\n        PackedInts.bitsRequired(maxAddress), acceptableOverheadRatio);\n    for(Map.Entry<Integer,Integer> ent : topNodeMap.entrySet()) {\n      nodeRefToAddressIn.set(ent.getValue(), newNodeAddress.get(ent.getKey()));\n    }\n    fst.nodeRefToAddress = nodeRefToAddressIn;\n    \n    fst.startNode = newNodeAddress.get((int) startNode);\n    //System.out.println(\"new startNode=\" + fst.startNode + \" old startNode=\" + startNode);\n\n    if (emptyOutput != null) {\n      fst.setEmptyOutput(emptyOutput);\n    }\n\n    fst.bytes.finish();\n    fst.cacheRootArcs();\n\n    //final int size = fst.sizeInBytes();\n    //System.out.println(\"nextCount=\" + nextCount + \" topCount=\" + topCount + \" deltaCount=\" + deltaCount + \" absCount=\" + absCount);\n\n    return fst;\n  }\n\n","sourceOld":"  /** Expert: creates an FST by packing this one.  This\n   *  process requires substantial additional RAM (currently\n   *  up to ~8 bytes per node depending on\n   *  <code>acceptableOverheadRatio</code>), but then should\n   *  produce a smaller FST.\n   *\n   *  <p>The implementation of this method uses ideas from\n   *  <a target=\"_blank\" href=\"http://www.cs.put.poznan.pl/dweiss/site/publications/download/fsacomp.pdf\">Smaller Representation of Finite State Automata</a>,\n   *  which describes techniques to reduce the size of a FST.\n   *  However, this is not a strict implementation of the\n   *  algorithms described in this paper.\n   */\n  FST<T> pack(int minInCountDeref, int maxDerefNodes, float acceptableOverheadRatio) throws IOException {\n\n    // NOTE: maxDerefNodes is intentionally int: we cannot\n    // support > 2.1B deref nodes\n\n    // TODO: other things to try\n    //   - renumber the nodes to get more next / better locality?\n    //   - allow multiple input labels on an arc, so\n    //     singular chain of inputs can take one arc (on\n    //     wikipedia terms this could save another ~6%)\n    //   - in the ord case, the output '1' is presumably\n    //     very common (after NO_OUTPUT)... maybe use a bit\n    //     for it..?\n    //   - use spare bits in flags.... for top few labels /\n    //     outputs / targets\n\n    if (nodeAddress == null) {\n      throw new IllegalArgumentException(\"this FST was not built with willPackFST=true\");\n    }\n\n    Arc<T> arc = new Arc<>();\n\n    final BytesReader r = getBytesReader();\n\n    final int topN = Math.min(maxDerefNodes, inCounts.size());\n\n    // Find top nodes with highest number of incoming arcs:\n    NodeQueue q = new NodeQueue(topN);\n\n    // TODO: we could use more RAM efficient selection algo here...\n    NodeAndInCount bottom = null;\n    for(int node=0; node<inCounts.size(); node++) {\n      if (inCounts.get(node) >= minInCountDeref) {\n        if (bottom == null) {\n          q.add(new NodeAndInCount(node, (int) inCounts.get(node)));\n          if (q.size() == topN) {\n            bottom = q.top();\n          }\n        } else if (inCounts.get(node) > bottom.count) {\n          q.insertWithOverflow(new NodeAndInCount(node, (int) inCounts.get(node)));\n        }\n      }\n    }\n\n    // Free up RAM:\n    inCounts = null;\n\n    final Map<Integer,Integer> topNodeMap = new HashMap<>();\n    for(int downTo=q.size()-1;downTo>=0;downTo--) {\n      NodeAndInCount n = q.pop();\n      topNodeMap.put(n.node, downTo);\n      //System.out.println(\"map node=\" + n.node + \" inCount=\" + n.count + \" to newID=\" + downTo);\n    }\n\n    // +1 because node ords start at 1 (0 is reserved as stop node):\n    final GrowableWriter newNodeAddress = new GrowableWriter(\n                       PackedInts.bitsRequired(this.bytes.getPosition()), (int) (1 + nodeCount), acceptableOverheadRatio);\n\n    // Fill initial coarse guess:\n    for(int node=1;node<=nodeCount;node++) {\n      newNodeAddress.set(node, 1 + this.bytes.getPosition() - nodeAddress.get(node));\n    }\n\n    int absCount;\n    int deltaCount;\n    int topCount;\n    int nextCount;\n\n    FST<T> fst;\n\n    // Iterate until we converge:\n    while(true) {\n\n      //System.out.println(\"\\nITER\");\n      boolean changed = false;\n\n      // for assert:\n      boolean negDelta = false;\n\n      fst = new FST<>(inputType, outputs, bytes.getBlockBits());\n      \n      final BytesStore writer = fst.bytes;\n\n      // Skip 0 byte since 0 is reserved target:\n      writer.writeByte((byte) 0);\n\n      fst.arcWithOutputCount = 0;\n      fst.nodeCount = 0;\n      fst.arcCount = 0;\n\n      absCount = deltaCount = topCount = nextCount = 0;\n\n      int changedCount = 0;\n\n      long addressError = 0;\n\n      //int totWasted = 0;\n\n      // Since we re-reverse the bytes, we now write the\n      // nodes backwards, so that BIT_TARGET_NEXT is\n      // unchanged:\n      for(int node=(int)nodeCount;node>=1;node--) {\n        fst.nodeCount++;\n        final long address = writer.getPosition();\n\n        //System.out.println(\"  node: \" + node + \" address=\" + address);\n        if (address != newNodeAddress.get(node)) {\n          addressError = address - newNodeAddress.get(node);\n          //System.out.println(\"    change: \" + (address - newNodeAddress[node]));\n          changed = true;\n          newNodeAddress.set(node, address);\n          changedCount++;\n        }\n\n        int nodeArcCount = 0;\n        int bytesPerArc = 0;\n\n        boolean retry = false;\n\n        // for assert:\n        boolean anyNegDelta = false;\n\n        // Retry loop: possibly iterate more than once, if\n        // this is an array'd node and bytesPerArc changes:\n        writeNode:\n        while(true) { // retry writing this node\n\n          //System.out.println(\"  cycle: retry\");\n          readFirstRealTargetArc(node, arc, r);\n\n          final boolean useArcArray = arc.bytesPerArc != 0;\n          if (useArcArray) {\n            // Write false first arc:\n            if (bytesPerArc == 0) {\n              bytesPerArc = arc.bytesPerArc;\n            }\n            writer.writeByte(ARCS_AS_FIXED_ARRAY);\n            writer.writeVInt(arc.numArcs);\n            writer.writeVInt(bytesPerArc);\n            //System.out.println(\"node \" + node + \": \" + arc.numArcs + \" arcs\");\n          }\n\n          int maxBytesPerArc = 0;\n          //int wasted = 0;\n          while(true) {  // iterate over all arcs for this node\n            //System.out.println(\"    cycle next arc\");\n\n            final long arcStartPos = writer.getPosition();\n            nodeArcCount++;\n\n            byte flags = 0;\n\n            if (arc.isLast()) {\n              flags += BIT_LAST_ARC;\n            }\n            /*\n            if (!useArcArray && nodeUpto < nodes.length-1 && arc.target == nodes[nodeUpto+1]) {\n              flags += BIT_TARGET_NEXT;\n            }\n            */\n            if (!useArcArray && node != 1 && arc.target == node-1) {\n              flags += BIT_TARGET_NEXT;\n              if (!retry) {\n                nextCount++;\n              }\n            }\n            if (arc.isFinal()) {\n              flags += BIT_FINAL_ARC;\n              if (arc.nextFinalOutput != NO_OUTPUT) {\n                flags += BIT_ARC_HAS_FINAL_OUTPUT;\n              }\n            } else {\n              assert arc.nextFinalOutput == NO_OUTPUT;\n            }\n            if (!targetHasArcs(arc)) {\n              flags += BIT_STOP_NODE;\n            }\n\n            if (arc.output != NO_OUTPUT) {\n              flags += BIT_ARC_HAS_OUTPUT;\n            }\n\n            final long absPtr;\n            final boolean doWriteTarget = targetHasArcs(arc) && (flags & BIT_TARGET_NEXT) == 0;\n            if (doWriteTarget) {\n\n              final Integer ptr = topNodeMap.get(arc.target);\n              if (ptr != null) {\n                absPtr = ptr;\n              } else {\n                absPtr = topNodeMap.size() + newNodeAddress.get((int) arc.target) + addressError;\n              }\n\n              long delta = newNodeAddress.get((int) arc.target) + addressError - writer.getPosition() - 2;\n              if (delta < 0) {\n                //System.out.println(\"neg: \" + delta);\n                anyNegDelta = true;\n                delta = 0;\n              }\n\n              if (delta < absPtr) {\n                flags |= BIT_TARGET_DELTA;\n              }\n            } else {\n              absPtr = 0;\n            }\n\n            assert flags != ARCS_AS_FIXED_ARRAY;\n            writer.writeByte(flags);\n\n            fst.writeLabel(writer, arc.label);\n\n            if (arc.output != NO_OUTPUT) {\n              outputs.write(arc.output, writer);\n              if (!retry) {\n                fst.arcWithOutputCount++;\n              }\n            }\n            if (arc.nextFinalOutput != NO_OUTPUT) {\n              outputs.writeFinalOutput(arc.nextFinalOutput, writer);\n            }\n\n            if (doWriteTarget) {\n\n              long delta = newNodeAddress.get((int) arc.target) + addressError - writer.getPosition();\n              if (delta < 0) {\n                anyNegDelta = true;\n                //System.out.println(\"neg: \" + delta);\n                delta = 0;\n              }\n\n              if (flag(flags, BIT_TARGET_DELTA)) {\n                //System.out.println(\"        delta\");\n                writer.writeVLong(delta);\n                if (!retry) {\n                  deltaCount++;\n                }\n              } else {\n                /*\n                if (ptr != null) {\n                  System.out.println(\"        deref\");\n                } else {\n                  System.out.println(\"        abs\");\n                }\n                */\n                writer.writeVLong(absPtr);\n                if (!retry) {\n                  if (absPtr >= topNodeMap.size()) {\n                    absCount++;\n                  } else {\n                    topCount++;\n                  }\n                }\n              }\n            }\n\n            if (useArcArray) {\n              final int arcBytes = (int) (writer.getPosition() - arcStartPos);\n              //System.out.println(\"  \" + arcBytes + \" bytes\");\n              maxBytesPerArc = Math.max(maxBytesPerArc, arcBytes);\n              // NOTE: this may in fact go \"backwards\", if\n              // somehow (rarely, possibly never) we use\n              // more bytesPerArc in this rewrite than the\n              // incoming FST did... but in this case we\n              // will retry (below) so it's OK to ovewrite\n              // bytes:\n              //wasted += bytesPerArc - arcBytes;\n              writer.skipBytes((int) (arcStartPos + bytesPerArc - writer.getPosition()));\n            }\n\n            if (arc.isLast()) {\n              break;\n            }\n\n            readNextRealArc(arc, r);\n          }\n\n          if (useArcArray) {\n            if (maxBytesPerArc == bytesPerArc || (retry && maxBytesPerArc <= bytesPerArc)) {\n              // converged\n              //System.out.println(\"  bba=\" + bytesPerArc + \" wasted=\" + wasted);\n              //totWasted += wasted;\n              break;\n            }\n          } else {\n            break;\n          }\n\n          //System.out.println(\"  retry this node maxBytesPerArc=\" + maxBytesPerArc + \" vs \" + bytesPerArc);\n\n          // Retry:\n          bytesPerArc = maxBytesPerArc;\n          writer.truncate(address);\n          nodeArcCount = 0;\n          retry = true;\n          anyNegDelta = false;\n        }\n\n        negDelta |= anyNegDelta;\n\n        fst.arcCount += nodeArcCount;\n      }\n\n      if (!changed) {\n        // We don't renumber the nodes (just reverse their\n        // order) so nodes should only point forward to\n        // other nodes because we only produce acyclic FSTs\n        // w/ nodes only pointing \"forwards\":\n        assert !negDelta;\n        //System.out.println(\"TOT wasted=\" + totWasted);\n        // Converged!\n        break;\n      }\n      //System.out.println(\"  \" + changedCount + \" of \" + fst.nodeCount + \" changed; retry\");\n    }\n\n    long maxAddress = 0;\n    for (long key : topNodeMap.keySet()) {\n      maxAddress = Math.max(maxAddress, newNodeAddress.get((int) key));\n    }\n\n    PackedInts.Mutable nodeRefToAddressIn = PackedInts.getMutable(topNodeMap.size(),\n        PackedInts.bitsRequired(maxAddress), acceptableOverheadRatio);\n    for(Map.Entry<Integer,Integer> ent : topNodeMap.entrySet()) {\n      nodeRefToAddressIn.set(ent.getValue(), newNodeAddress.get(ent.getKey()));\n    }\n    fst.nodeRefToAddress = nodeRefToAddressIn;\n    \n    fst.startNode = newNodeAddress.get((int) startNode);\n    //System.out.println(\"new startNode=\" + fst.startNode + \" old startNode=\" + startNode);\n\n    if (emptyOutput != null) {\n      fst.setEmptyOutput(emptyOutput);\n    }\n\n    assert fst.nodeCount == nodeCount: \"fst.nodeCount=\" + fst.nodeCount + \" nodeCount=\" + nodeCount;\n    assert fst.arcCount == arcCount;\n    assert fst.arcWithOutputCount == arcWithOutputCount: \"fst.arcWithOutputCount=\" + fst.arcWithOutputCount + \" arcWithOutputCount=\" + arcWithOutputCount;\n\n    fst.bytes.finish();\n    fst.cacheRootArcs();\n\n    //final int size = fst.sizeInBytes();\n    //System.out.println(\"nextCount=\" + nextCount + \" topCount=\" + topCount + \" deltaCount=\" + deltaCount + \" absCount=\" + absCount);\n\n    return fst;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1abb939fb41b2fe4f89fd518f3da288c0213341d":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["5ebe14aae60589c9bb6423f3cce02d5f599e1540","49f4d9c4e29f2345e789073801e7945431a23ca3"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["82557a475db3e0849171dc0be5b02e3ae0745ddb"],"82557a475db3e0849171dc0be5b02e3ae0745ddb":["d3c397b1515e745d8b12d70edfc0e17cb7eac7f0"],"c4015cd39dff8d4dec562d909f9766debac53aa6":["8917bfede3b4ca30f4305c1e391e9218959cd723","82557a475db3e0849171dc0be5b02e3ae0745ddb"],"d3c397b1515e745d8b12d70edfc0e17cb7eac7f0":["73e44327cb5401cc5098da2f488c899954c9bfbc"],"8917bfede3b4ca30f4305c1e391e9218959cd723":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","d3c397b1515e745d8b12d70edfc0e17cb7eac7f0"],"87e78f3c129251e74ecc2ff73a32de0f27cf09d5":["49f4d9c4e29f2345e789073801e7945431a23ca3"],"cb27634f76319b68d6d8fd11a7104d20294722c5":["5ebe14aae60589c9bb6423f3cce02d5f599e1540"],"b26194bf4449ad4f480a19cd5e745f64e3430b64":["edb74c83fff94196b864e08ca033d92823252cb7"],"73e44327cb5401cc5098da2f488c899954c9bfbc":["d5cf2203ec06da56386fb6f0054d7b11e456caed"],"d5cf2203ec06da56386fb6f0054d7b11e456caed":["87e78f3c129251e74ecc2ff73a32de0f27cf09d5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"edb74c83fff94196b864e08ca033d92823252cb7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5ebe14aae60589c9bb6423f3cce02d5f599e1540":["b26194bf4449ad4f480a19cd5e745f64e3430b64"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1abb939fb41b2fe4f89fd518f3da288c0213341d"],"49f4d9c4e29f2345e789073801e7945431a23ca3":["cb27634f76319b68d6d8fd11a7104d20294722c5"]},"commit2Childs":{"1abb939fb41b2fe4f89fd518f3da288c0213341d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["8917bfede3b4ca30f4305c1e391e9218959cd723"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["1abb939fb41b2fe4f89fd518f3da288c0213341d"],"82557a475db3e0849171dc0be5b02e3ae0745ddb":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","c4015cd39dff8d4dec562d909f9766debac53aa6"],"c4015cd39dff8d4dec562d909f9766debac53aa6":[],"d3c397b1515e745d8b12d70edfc0e17cb7eac7f0":["82557a475db3e0849171dc0be5b02e3ae0745ddb","8917bfede3b4ca30f4305c1e391e9218959cd723"],"8917bfede3b4ca30f4305c1e391e9218959cd723":["c4015cd39dff8d4dec562d909f9766debac53aa6"],"87e78f3c129251e74ecc2ff73a32de0f27cf09d5":["d5cf2203ec06da56386fb6f0054d7b11e456caed"],"cb27634f76319b68d6d8fd11a7104d20294722c5":["49f4d9c4e29f2345e789073801e7945431a23ca3"],"b26194bf4449ad4f480a19cd5e745f64e3430b64":["5ebe14aae60589c9bb6423f3cce02d5f599e1540"],"73e44327cb5401cc5098da2f488c899954c9bfbc":["d3c397b1515e745d8b12d70edfc0e17cb7eac7f0"],"d5cf2203ec06da56386fb6f0054d7b11e456caed":["73e44327cb5401cc5098da2f488c899954c9bfbc"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["edb74c83fff94196b864e08ca033d92823252cb7"],"edb74c83fff94196b864e08ca033d92823252cb7":["b26194bf4449ad4f480a19cd5e745f64e3430b64"],"5ebe14aae60589c9bb6423f3cce02d5f599e1540":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","cb27634f76319b68d6d8fd11a7104d20294722c5"],"49f4d9c4e29f2345e789073801e7945431a23ca3":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","87e78f3c129251e74ecc2ff73a32de0f27cf09d5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c4015cd39dff8d4dec562d909f9766debac53aa6","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}