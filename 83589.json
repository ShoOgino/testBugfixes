{"path":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","commits":[{"id":"aa62c79a7afa4d7f22e1f71b883659f3213d7db1","date":1435334422,"type":1,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,DocSet).mjava","sourceNew":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n    String contains = params.getFieldParam(field, FacetParams.FACET_CONTAINS);\n    boolean ignoreCase = params.getFieldBool(field, FacetParams.FACET_CONTAINS_IGNORE_CASE, false);\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    FacetMethod method = null;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      method = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      method = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.ENUM && TrieField.getMainValuePrefix(ft) != null) {\n      // enum can't deal with trie fields that index several terms per value\n      method = sf.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n    }\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      method = FacetMethod.ENUM;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n    \n    if (ft.getNumericType() != null && !sf.multiValued()) {\n      // the per-segment approach is optimal for numeric field types since there\n      // are no global ords to merge and no need to create an expensive\n      // top-level reader\n      method = FacetMethod.FCS;\n    }\n\n    if (method == null) {\n      // TODO: default to per-segment or not?\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.FCS && multiToken) {\n      // only fc knows how to deal with multi-token fields\n      method = FacetMethod.FC;\n    }\n    \n    if (method == FacetMethod.ENUM && sf.hasDocValues()) {\n      // only fc can handle docvalues types\n      method = FacetMethod.FC;\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n    } else {\n      assert method != null;\n      switch (method) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, contains, ignoreCase);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumericType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (contains != null && !contains.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_CONTAINS + \" is not supported on numeric types\");\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, contains, ignoreCase);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, DocSet base) throws IOException {\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n    String contains = params.getFieldParam(field, FacetParams.FACET_CONTAINS);\n    boolean ignoreCase = params.getFieldBool(field, FacetParams.FACET_CONTAINS_IGNORE_CASE, false);\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    FacetMethod method = null;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      method = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      method = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.ENUM && TrieField.getMainValuePrefix(ft) != null) {\n      // enum can't deal with trie fields that index several terms per value\n      method = sf.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n    }\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      method = FacetMethod.ENUM;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n    \n    if (ft.getNumericType() != null && !sf.multiValued()) {\n      // the per-segment approach is optimal for numeric field types since there\n      // are no global ords to merge and no need to create an expensive\n      // top-level reader\n      method = FacetMethod.FCS;\n    }\n\n    if (method == null) {\n      // TODO: default to per-segment or not?\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.FCS && multiToken) {\n      // only fc knows how to deal with multi-token fields\n      method = FacetMethod.FC;\n    }\n    \n    if (method == FacetMethod.ENUM && sf.hasDocValues()) {\n      // only fc can handle docvalues types\n      method = FacetMethod.FC;\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, base, field, multiToken, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n    } else {\n      assert method != null;\n      switch (method) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, base, field, offset, limit, mincount, missing, sort, prefix, contains, ignoreCase);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumericType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (contains != null && !contains.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_CONTAINS + \" is not supported on numeric types\");\n            }\n            counts = NumericFacets.getCounts(searcher, base, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, base, field, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, base, field, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"22d0a81a05eba47d5e18976f17d88306b218cc22","date":1436341569,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","sourceNew":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n    String contains = params.getFieldParam(field, FacetParams.FACET_CONTAINS);\n    boolean ignoreCase = params.getFieldBool(field, FacetParams.FACET_CONTAINS_IGNORE_CASE, false);\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    FacetMethod method = null;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      method = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      method = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.ENUM && TrieField.getMainValuePrefix(ft) != null) {\n      // enum can't deal with trie fields that index several terms per value\n      method = sf.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n    }\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      method = FacetMethod.ENUM;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n    \n    if (ft.getNumericType() != null && !sf.multiValued()) {\n      // the per-segment approach is optimal for numeric field types since there\n      // are no global ords to merge and no need to create an expensive\n      // top-level reader\n      method = FacetMethod.FCS;\n    }\n\n    if (method == null) {\n      // TODO: default to per-segment or not?\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.FCS && multiToken) {\n      // only fc knows how to deal with multi-token fields\n      method = FacetMethod.FC;\n    }\n    \n    if (method == FacetMethod.ENUM && sf.hasDocValues()) {\n      // only fc can handle docvalues types\n      method = FacetMethod.FC;\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n    } else {\n      assert method != null;\n      switch (method) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, contains, ignoreCase, params);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumericType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (contains != null && !contains.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_CONTAINS + \" is not supported on numeric types\");\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, contains, ignoreCase);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n    String contains = params.getFieldParam(field, FacetParams.FACET_CONTAINS);\n    boolean ignoreCase = params.getFieldBool(field, FacetParams.FACET_CONTAINS_IGNORE_CASE, false);\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    FacetMethod method = null;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      method = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      method = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.ENUM && TrieField.getMainValuePrefix(ft) != null) {\n      // enum can't deal with trie fields that index several terms per value\n      method = sf.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n    }\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      method = FacetMethod.ENUM;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n    \n    if (ft.getNumericType() != null && !sf.multiValued()) {\n      // the per-segment approach is optimal for numeric field types since there\n      // are no global ords to merge and no need to create an expensive\n      // top-level reader\n      method = FacetMethod.FCS;\n    }\n\n    if (method == null) {\n      // TODO: default to per-segment or not?\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.FCS && multiToken) {\n      // only fc knows how to deal with multi-token fields\n      method = FacetMethod.FC;\n    }\n    \n    if (method == FacetMethod.ENUM && sf.hasDocValues()) {\n      // only fc can handle docvalues types\n      method = FacetMethod.FC;\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n    } else {\n      assert method != null;\n      switch (method) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, contains, ignoreCase);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumericType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (contains != null && !contains.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_CONTAINS + \" is not supported on numeric types\");\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, contains, ignoreCase);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3802d95c3a31be21ea2971945049b711d95ef8d5","date":1455055616,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","sourceNew":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n    String contains = params.getFieldParam(field, FacetParams.FACET_CONTAINS);\n    boolean ignoreCase = params.getFieldBool(field, FacetParams.FACET_CONTAINS_IGNORE_CASE, false);\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    FacetMethod method = null;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      method = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      method = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      method = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      method = FacetMethod.UIF;\n    }\n\n    if (method == FacetMethod.ENUM && TrieField.getMainValuePrefix(ft) != null) {\n      // enum can't deal with trie fields that index several terms per value\n      method = sf.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n    }\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      method = FacetMethod.ENUM;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n    \n    if (ft.getNumericType() != null && !sf.multiValued()) {\n      // the per-segment approach is optimal for numeric field types since there\n      // are no global ords to merge and no need to create an expensive\n      // top-level reader\n      method = FacetMethod.FCS;\n    }\n\n    if (method == null) {\n      // TODO: default to per-segment or not?\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.FCS && multiToken) {\n      // only fc knows how to deal with multi-token fields\n      method = FacetMethod.FC;\n    }\n    \n    if (method == FacetMethod.ENUM && sf.hasDocValues()) {\n      // only fc can handle docvalues types\n      method = FacetMethod.FC;\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n    } else {\n      assert method != null;\n      switch (method) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, contains, ignoreCase, params);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumericType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (contains != null && !contains.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_CONTAINS + \" is not supported on numeric types\");\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, contains, ignoreCase);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            \n            if (prefix!=null) {\n              // presumably it supports single-value, but at least now returns wrong results on multi-value\n              throw new SolrException (\n                  SolrException.ErrorCode.BAD_REQUEST,\n                  FacetParams.FACET_PREFIX+\"=\"+prefix+\n                  \" are not supported by \"+FacetParams.FACET_METHOD+\"=\"+FacetParams.FACET_METHOD_uif+\n                  \" for field:\"+ field\n                  //jsonFacet.put(\"prefix\", prefix);\n              );\n            }\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(\"sort\", sortVal );\n\n            Map<String, Object> topLevel = new HashMap<>();\n            topLevel.put(field, jsonFacet);\n              \n            topLevel.put(\"processEmpty\", true);\n\n            FacetProcessor fproc = FacetProcessor.createProcessor(rb.req, topLevel, // rb.getResults().docSet\n                                                                    docs );\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n            fproc.process();\n\n            //Go through the response to build the expected output for SimpleFacets\n            Object res = fproc.getResponse();\n            counts = new NamedList<Integer>();\n            if(res != null) {\n              SimpleOrderedMap<Object> som = (SimpleOrderedMap<Object>)res;\n              SimpleOrderedMap<Object> asdf = (SimpleOrderedMap<Object>) som.get(field);\n\n              List<SimpleOrderedMap<Object>> buckets = (List<SimpleOrderedMap<Object>>)asdf.get(\"buckets\");\n              for(SimpleOrderedMap<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                SimpleOrderedMap<Object> missingCounts = (SimpleOrderedMap<Object>) asdf.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n    String contains = params.getFieldParam(field, FacetParams.FACET_CONTAINS);\n    boolean ignoreCase = params.getFieldBool(field, FacetParams.FACET_CONTAINS_IGNORE_CASE, false);\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    FacetMethod method = null;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      method = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      method = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.ENUM && TrieField.getMainValuePrefix(ft) != null) {\n      // enum can't deal with trie fields that index several terms per value\n      method = sf.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n    }\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      method = FacetMethod.ENUM;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n    \n    if (ft.getNumericType() != null && !sf.multiValued()) {\n      // the per-segment approach is optimal for numeric field types since there\n      // are no global ords to merge and no need to create an expensive\n      // top-level reader\n      method = FacetMethod.FCS;\n    }\n\n    if (method == null) {\n      // TODO: default to per-segment or not?\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.FCS && multiToken) {\n      // only fc knows how to deal with multi-token fields\n      method = FacetMethod.FC;\n    }\n    \n    if (method == FacetMethod.ENUM && sf.hasDocValues()) {\n      // only fc can handle docvalues types\n      method = FacetMethod.FC;\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n    } else {\n      assert method != null;\n      switch (method) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, contains, ignoreCase, params);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumericType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (contains != null && !contains.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_CONTAINS + \" is not supported on numeric types\");\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, contains, ignoreCase);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":["1c841e27891873cab110ebeb89f124a8ec470176","550bbe5ffcdb614551686767f4d5a6ee38ef3e85","275f40e1400de0b5ab5e33051ac11e8973813a2c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3c64189697927b548f74ba66dfa5051548662938","date":1455059336,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","sourceNew":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n    String contains = params.getFieldParam(field, FacetParams.FACET_CONTAINS);\n    boolean ignoreCase = params.getFieldBool(field, FacetParams.FACET_CONTAINS_IGNORE_CASE, false);\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    FacetMethod method = null;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      method = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      method = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      method = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      method = FacetMethod.UIF;\n    }\n\n    if (method == FacetMethod.ENUM && TrieField.getMainValuePrefix(ft) != null) {\n      // enum can't deal with trie fields that index several terms per value\n      method = sf.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n    }\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      method = FacetMethod.ENUM;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n    \n    if (ft.getNumericType() != null && !sf.multiValued()) {\n      // the per-segment approach is optimal for numeric field types since there\n      // are no global ords to merge and no need to create an expensive\n      // top-level reader\n      method = FacetMethod.FCS;\n    }\n\n    if (method == null) {\n      // TODO: default to per-segment or not?\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.FCS && multiToken) {\n      // only fc knows how to deal with multi-token fields\n      method = FacetMethod.FC;\n    }\n    \n    if (method == FacetMethod.ENUM && sf.hasDocValues()) {\n      // only fc can handle docvalues types\n      method = FacetMethod.FC;\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n    } else {\n      assert method != null;\n      switch (method) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, contains, ignoreCase, params);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumericType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (contains != null && !contains.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_CONTAINS + \" is not supported on numeric types\");\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, contains, ignoreCase);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            \n            if (prefix!=null) {\n              // presumably it supports single-value, but at least now returns wrong results on multi-value\n              throw new SolrException (\n                  SolrException.ErrorCode.BAD_REQUEST,\n                  FacetParams.FACET_PREFIX+\"=\"+prefix+\n                  \" are not supported by \"+FacetParams.FACET_METHOD+\"=\"+FacetParams.FACET_METHOD_uif+\n                  \" for field:\"+ field\n                  //jsonFacet.put(\"prefix\", prefix);\n              );\n            }\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(\"sort\", sortVal );\n\n            Map<String, Object> topLevel = new HashMap<>();\n            topLevel.put(field, jsonFacet);\n              \n            topLevel.put(\"processEmpty\", true);\n\n            FacetProcessor fproc = FacetProcessor.createProcessor(rb.req, topLevel, // rb.getResults().docSet\n                                                                    docs );\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n            fproc.process();\n\n            //Go through the response to build the expected output for SimpleFacets\n            Object res = fproc.getResponse();\n            counts = new NamedList<Integer>();\n            if(res != null) {\n              SimpleOrderedMap<Object> som = (SimpleOrderedMap<Object>)res;\n              SimpleOrderedMap<Object> asdf = (SimpleOrderedMap<Object>) som.get(field);\n\n              List<SimpleOrderedMap<Object>> buckets = (List<SimpleOrderedMap<Object>>)asdf.get(\"buckets\");\n              for(SimpleOrderedMap<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                SimpleOrderedMap<Object> missingCounts = (SimpleOrderedMap<Object>) asdf.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n    String contains = params.getFieldParam(field, FacetParams.FACET_CONTAINS);\n    boolean ignoreCase = params.getFieldBool(field, FacetParams.FACET_CONTAINS_IGNORE_CASE, false);\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    FacetMethod method = null;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      method = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      method = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.ENUM && TrieField.getMainValuePrefix(ft) != null) {\n      // enum can't deal with trie fields that index several terms per value\n      method = sf.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n    }\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      method = FacetMethod.ENUM;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n    \n    if (ft.getNumericType() != null && !sf.multiValued()) {\n      // the per-segment approach is optimal for numeric field types since there\n      // are no global ords to merge and no need to create an expensive\n      // top-level reader\n      method = FacetMethod.FCS;\n    }\n\n    if (method == null) {\n      // TODO: default to per-segment or not?\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.FCS && multiToken) {\n      // only fc knows how to deal with multi-token fields\n      method = FacetMethod.FC;\n    }\n    \n    if (method == FacetMethod.ENUM && sf.hasDocValues()) {\n      // only fc can handle docvalues types\n      method = FacetMethod.FC;\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n    } else {\n      assert method != null;\n      switch (method) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, contains, ignoreCase, params);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumericType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (contains != null && !contains.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_CONTAINS + \" is not supported on numeric types\");\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, contains, ignoreCase);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"550bbe5ffcdb614551686767f4d5a6ee38ef3e85","date":1457221653,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","sourceNew":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n    String contains = params.getFieldParam(field, FacetParams.FACET_CONTAINS);\n    boolean ignoreCase = params.getFieldBool(field, FacetParams.FACET_CONTAINS_IGNORE_CASE, false);\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    FacetMethod method = null;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      method = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      method = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      method = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      method = FacetMethod.UIF;\n    }\n\n    if (method == FacetMethod.ENUM && TrieField.getMainValuePrefix(ft) != null) {\n      // enum can't deal with trie fields that index several terms per value\n      method = sf.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n    }\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      method = FacetMethod.ENUM;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n    \n    if (ft.getNumericType() != null && !sf.multiValued()) {\n      // the per-segment approach is optimal for numeric field types since there\n      // are no global ords to merge and no need to create an expensive\n      // top-level reader\n      method = FacetMethod.FCS;\n    }\n\n    if (method == null) {\n      // TODO: default to per-segment or not?\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.FCS && multiToken) {\n      // only fc knows how to deal with multi-token fields\n      method = FacetMethod.FC;\n    }\n    \n    if (method == FacetMethod.ENUM && sf.hasDocValues()) {\n      // only fc can handle docvalues types\n      method = FacetMethod.FC;\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n    } else {\n      assert method != null;\n      switch (method) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, contains, ignoreCase, params);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumericType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (contains != null && !contains.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_CONTAINS + \" is not supported on numeric types\");\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, contains, ignoreCase);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(\"sort\", sortVal );\n\n            Map<String, Object> topLevel = new HashMap<>();\n            topLevel.put(field, jsonFacet);\n              \n            topLevel.put(\"processEmpty\", true);\n\n            FacetProcessor fproc = FacetProcessor.createProcessor(rb.req, topLevel, // rb.getResults().docSet\n                                                                    docs );\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n            fproc.process();\n\n            //Go through the response to build the expected output for SimpleFacets\n            Object res = fproc.getResponse();\n            counts = new NamedList<Integer>();\n            if(res != null) {\n              SimpleOrderedMap<Object> som = (SimpleOrderedMap<Object>)res;\n              SimpleOrderedMap<Object> asdf = (SimpleOrderedMap<Object>) som.get(field);\n\n              List<SimpleOrderedMap<Object>> buckets = (List<SimpleOrderedMap<Object>>)asdf.get(\"buckets\");\n              for(SimpleOrderedMap<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                SimpleOrderedMap<Object> missingCounts = (SimpleOrderedMap<Object>) asdf.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n    String contains = params.getFieldParam(field, FacetParams.FACET_CONTAINS);\n    boolean ignoreCase = params.getFieldBool(field, FacetParams.FACET_CONTAINS_IGNORE_CASE, false);\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    FacetMethod method = null;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      method = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      method = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      method = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      method = FacetMethod.UIF;\n    }\n\n    if (method == FacetMethod.ENUM && TrieField.getMainValuePrefix(ft) != null) {\n      // enum can't deal with trie fields that index several terms per value\n      method = sf.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n    }\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      method = FacetMethod.ENUM;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n    \n    if (ft.getNumericType() != null && !sf.multiValued()) {\n      // the per-segment approach is optimal for numeric field types since there\n      // are no global ords to merge and no need to create an expensive\n      // top-level reader\n      method = FacetMethod.FCS;\n    }\n\n    if (method == null) {\n      // TODO: default to per-segment or not?\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.FCS && multiToken) {\n      // only fc knows how to deal with multi-token fields\n      method = FacetMethod.FC;\n    }\n    \n    if (method == FacetMethod.ENUM && sf.hasDocValues()) {\n      // only fc can handle docvalues types\n      method = FacetMethod.FC;\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n    } else {\n      assert method != null;\n      switch (method) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, contains, ignoreCase, params);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumericType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (contains != null && !contains.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_CONTAINS + \" is not supported on numeric types\");\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, contains, ignoreCase);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            \n            if (prefix!=null) {\n              // presumably it supports single-value, but at least now returns wrong results on multi-value\n              throw new SolrException (\n                  SolrException.ErrorCode.BAD_REQUEST,\n                  FacetParams.FACET_PREFIX+\"=\"+prefix+\n                  \" are not supported by \"+FacetParams.FACET_METHOD+\"=\"+FacetParams.FACET_METHOD_uif+\n                  \" for field:\"+ field\n                  //jsonFacet.put(\"prefix\", prefix);\n              );\n            }\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(\"sort\", sortVal );\n\n            Map<String, Object> topLevel = new HashMap<>();\n            topLevel.put(field, jsonFacet);\n              \n            topLevel.put(\"processEmpty\", true);\n\n            FacetProcessor fproc = FacetProcessor.createProcessor(rb.req, topLevel, // rb.getResults().docSet\n                                                                    docs );\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n            fproc.process();\n\n            //Go through the response to build the expected output for SimpleFacets\n            Object res = fproc.getResponse();\n            counts = new NamedList<Integer>();\n            if(res != null) {\n              SimpleOrderedMap<Object> som = (SimpleOrderedMap<Object>)res;\n              SimpleOrderedMap<Object> asdf = (SimpleOrderedMap<Object>) som.get(field);\n\n              List<SimpleOrderedMap<Object>> buckets = (List<SimpleOrderedMap<Object>>)asdf.get(\"buckets\");\n              for(SimpleOrderedMap<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                SimpleOrderedMap<Object> missingCounts = (SimpleOrderedMap<Object>) asdf.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    return counts;\n  }\n\n","bugFix":["3802d95c3a31be21ea2971945049b711d95ef8d5"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3e5f469d206ae27a1d59e654e70a1413ffcec765","date":1462661221,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","sourceNew":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n    String contains = params.getFieldParam(field, FacetParams.FACET_CONTAINS);\n    boolean ignoreCase = params.getFieldBool(field, FacetParams.FACET_CONTAINS_IGNORE_CASE, false);\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    FacetMethod method = null;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      method = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      method = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      method = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      method = FacetMethod.UIF;\n    }\n\n    if (method == FacetMethod.ENUM && TrieField.getMainValuePrefix(ft) != null) {\n      // enum can't deal with trie fields that index several terms per value\n      method = sf.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n    }\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      method = FacetMethod.ENUM;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n    \n    if (ft.getNumericType() != null && !sf.multiValued()) {\n      // the per-segment approach is optimal for numeric field types since there\n      // are no global ords to merge and no need to create an expensive\n      // top-level reader\n      method = FacetMethod.FCS;\n    }\n\n    if (method == null) {\n      // TODO: default to per-segment or not?\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.FCS && multiToken) {\n      // only fc knows how to deal with multi-token fields\n      method = FacetMethod.FC;\n    }\n    \n    if (method == FacetMethod.ENUM && sf.hasDocValues()) {\n      // only fc can handle docvalues types\n      method = FacetMethod.FC;\n    }\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"method\", method.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n    } else {\n      assert method != null;\n      switch (method) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, contains, ignoreCase, params);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumericType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (contains != null && !contains.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_CONTAINS + \" is not supported on numeric types\");\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, contains, ignoreCase);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(\"sort\", sortVal );\n\n            Map<String, Object> topLevel = new HashMap<>();\n            topLevel.put(field, jsonFacet);\n              \n            topLevel.put(\"processEmpty\", true);\n\n            FacetProcessor fproc = FacetProcessor.createProcessor(rb.req, topLevel, // rb.getResults().docSet\n                                                                    docs );\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n            fproc.process();\n\n            //Go through the response to build the expected output for SimpleFacets\n            Object res = fproc.getResponse();\n            counts = new NamedList<Integer>();\n            if(res != null) {\n              SimpleOrderedMap<Object> som = (SimpleOrderedMap<Object>)res;\n              SimpleOrderedMap<Object> asdf = (SimpleOrderedMap<Object>) som.get(field);\n\n              List<SimpleOrderedMap<Object>> buckets = (List<SimpleOrderedMap<Object>>)asdf.get(\"buckets\");\n              for(SimpleOrderedMap<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                SimpleOrderedMap<Object> missingCounts = (SimpleOrderedMap<Object>) asdf.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n    String contains = params.getFieldParam(field, FacetParams.FACET_CONTAINS);\n    boolean ignoreCase = params.getFieldBool(field, FacetParams.FACET_CONTAINS_IGNORE_CASE, false);\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    FacetMethod method = null;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      method = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      method = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      method = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      method = FacetMethod.UIF;\n    }\n\n    if (method == FacetMethod.ENUM && TrieField.getMainValuePrefix(ft) != null) {\n      // enum can't deal with trie fields that index several terms per value\n      method = sf.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n    }\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      method = FacetMethod.ENUM;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n    \n    if (ft.getNumericType() != null && !sf.multiValued()) {\n      // the per-segment approach is optimal for numeric field types since there\n      // are no global ords to merge and no need to create an expensive\n      // top-level reader\n      method = FacetMethod.FCS;\n    }\n\n    if (method == null) {\n      // TODO: default to per-segment or not?\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.FCS && multiToken) {\n      // only fc knows how to deal with multi-token fields\n      method = FacetMethod.FC;\n    }\n    \n    if (method == FacetMethod.ENUM && sf.hasDocValues()) {\n      // only fc can handle docvalues types\n      method = FacetMethod.FC;\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n    } else {\n      assert method != null;\n      switch (method) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, contains, ignoreCase, params);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumericType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (contains != null && !contains.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_CONTAINS + \" is not supported on numeric types\");\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, contains, ignoreCase);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(\"sort\", sortVal );\n\n            Map<String, Object> topLevel = new HashMap<>();\n            topLevel.put(field, jsonFacet);\n              \n            topLevel.put(\"processEmpty\", true);\n\n            FacetProcessor fproc = FacetProcessor.createProcessor(rb.req, topLevel, // rb.getResults().docSet\n                                                                    docs );\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n            fproc.process();\n\n            //Go through the response to build the expected output for SimpleFacets\n            Object res = fproc.getResponse();\n            counts = new NamedList<Integer>();\n            if(res != null) {\n              SimpleOrderedMap<Object> som = (SimpleOrderedMap<Object>)res;\n              SimpleOrderedMap<Object> asdf = (SimpleOrderedMap<Object>) som.get(field);\n\n              List<SimpleOrderedMap<Object>> buckets = (List<SimpleOrderedMap<Object>>)asdf.get(\"buckets\");\n              for(SimpleOrderedMap<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                SimpleOrderedMap<Object> missingCounts = (SimpleOrderedMap<Object>) asdf.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":["275f40e1400de0b5ab5e33051ac11e8973813a2c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e66a459d38c1c4a2f97128433dab546f683a9fed","date":1462873476,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","sourceNew":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n    String contains = params.getFieldParam(field, FacetParams.FACET_CONTAINS);\n    boolean ignoreCase = params.getFieldBool(field, FacetParams.FACET_CONTAINS_IGNORE_CASE, false);\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    FacetMethod method = null;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      method = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      method = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      method = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      method = FacetMethod.UIF;\n    }\n\n    if (method == FacetMethod.ENUM && TrieField.getMainValuePrefix(ft) != null) {\n      // enum can't deal with trie fields that index several terms per value\n      method = sf.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n    }\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      method = FacetMethod.ENUM;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n    \n    if (ft.getNumericType() != null && !sf.multiValued()) {\n      // the per-segment approach is optimal for numeric field types since there\n      // are no global ords to merge and no need to create an expensive\n      // top-level reader\n      method = FacetMethod.FCS;\n    }\n\n    if (method == null) {\n      // TODO: default to per-segment or not?\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.FCS && multiToken) {\n      // only fc knows how to deal with multi-token fields\n      method = FacetMethod.FC;\n    }\n    \n    if (method == FacetMethod.ENUM && sf.hasDocValues()) {\n      // only fc can handle docvalues types\n      method = FacetMethod.FC;\n    }\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"method\", method.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n    } else {\n      assert method != null;\n      switch (method) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, contains, ignoreCase, params);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumericType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (contains != null && !contains.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_CONTAINS + \" is not supported on numeric types\");\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, contains, ignoreCase);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(\"sort\", sortVal );\n\n            Map<String, Object> topLevel = new HashMap<>();\n            topLevel.put(field, jsonFacet);\n              \n            topLevel.put(\"processEmpty\", true);\n\n            FacetProcessor fproc = FacetProcessor.createProcessor(rb.req, topLevel, // rb.getResults().docSet\n                                                                    docs );\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n            fproc.process();\n\n            //Go through the response to build the expected output for SimpleFacets\n            Object res = fproc.getResponse();\n            counts = new NamedList<Integer>();\n            if(res != null) {\n              SimpleOrderedMap<Object> som = (SimpleOrderedMap<Object>)res;\n              SimpleOrderedMap<Object> asdf = (SimpleOrderedMap<Object>) som.get(field);\n\n              List<SimpleOrderedMap<Object>> buckets = (List<SimpleOrderedMap<Object>>)asdf.get(\"buckets\");\n              for(SimpleOrderedMap<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                SimpleOrderedMap<Object> missingCounts = (SimpleOrderedMap<Object>) asdf.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n    String contains = params.getFieldParam(field, FacetParams.FACET_CONTAINS);\n    boolean ignoreCase = params.getFieldBool(field, FacetParams.FACET_CONTAINS_IGNORE_CASE, false);\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    FacetMethod method = null;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      method = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      method = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      method = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      method = FacetMethod.UIF;\n    }\n\n    if (method == FacetMethod.ENUM && TrieField.getMainValuePrefix(ft) != null) {\n      // enum can't deal with trie fields that index several terms per value\n      method = sf.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n    }\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      method = FacetMethod.ENUM;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n    \n    if (ft.getNumericType() != null && !sf.multiValued()) {\n      // the per-segment approach is optimal for numeric field types since there\n      // are no global ords to merge and no need to create an expensive\n      // top-level reader\n      method = FacetMethod.FCS;\n    }\n\n    if (method == null) {\n      // TODO: default to per-segment or not?\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.FCS && multiToken) {\n      // only fc knows how to deal with multi-token fields\n      method = FacetMethod.FC;\n    }\n    \n    if (method == FacetMethod.ENUM && sf.hasDocValues()) {\n      // only fc can handle docvalues types\n      method = FacetMethod.FC;\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n    } else {\n      assert method != null;\n      switch (method) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, contains, ignoreCase, params);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumericType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (contains != null && !contains.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_CONTAINS + \" is not supported on numeric types\");\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, contains, ignoreCase);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(\"sort\", sortVal );\n\n            Map<String, Object> topLevel = new HashMap<>();\n            topLevel.put(field, jsonFacet);\n              \n            topLevel.put(\"processEmpty\", true);\n\n            FacetProcessor fproc = FacetProcessor.createProcessor(rb.req, topLevel, // rb.getResults().docSet\n                                                                    docs );\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n            fproc.process();\n\n            //Go through the response to build the expected output for SimpleFacets\n            Object res = fproc.getResponse();\n            counts = new NamedList<Integer>();\n            if(res != null) {\n              SimpleOrderedMap<Object> som = (SimpleOrderedMap<Object>)res;\n              SimpleOrderedMap<Object> asdf = (SimpleOrderedMap<Object>) som.get(field);\n\n              List<SimpleOrderedMap<Object>> buckets = (List<SimpleOrderedMap<Object>>)asdf.get(\"buckets\");\n              for(SimpleOrderedMap<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                SimpleOrderedMap<Object> missingCounts = (SimpleOrderedMap<Object>) asdf.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"275f40e1400de0b5ab5e33051ac11e8973813a2c","date":1465569625,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","sourceNew":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n    String contains = params.getFieldParam(field, FacetParams.FACET_CONTAINS);\n    boolean ignoreCase = params.getFieldBool(field, FacetParams.FACET_CONTAINS_IGNORE_CASE, false);\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    final FacetMethod requestedMethod;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      requestedMethod = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      requestedMethod = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      requestedMethod = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      requestedMethod = FacetMethod.UIF;\n    }else{\n      requestedMethod=null;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    FacetMethod appliedFacetMethod = selectFacetMethod(sf, requestedMethod, mincount);\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"requestedMethod\", requestedMethod==null?\"not specified\":requestedMethod.name());\n       fdebug.putInfoItem(\"appliedMethod\", appliedFacetMethod.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n    } else {\n      assert appliedFacetMethod != null;\n      switch (appliedFacetMethod) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, contains, ignoreCase, params);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumericType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (contains != null && !contains.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_CONTAINS + \" is not supported on numeric types\");\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, contains, ignoreCase);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(\"sort\", sortVal );\n\n            Map<String, Object> topLevel = new HashMap<>();\n            topLevel.put(field, jsonFacet);\n              \n            topLevel.put(\"processEmpty\", true);\n\n            FacetProcessor fproc = FacetProcessor.createProcessor(rb.req, topLevel, // rb.getResults().docSet\n                                                                    docs );\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n            fproc.process();\n\n            //Go through the response to build the expected output for SimpleFacets\n            Object res = fproc.getResponse();\n            counts = new NamedList<Integer>();\n            if(res != null) {\n              SimpleOrderedMap<Object> som = (SimpleOrderedMap<Object>)res;\n              SimpleOrderedMap<Object> asdf = (SimpleOrderedMap<Object>) som.get(field);\n\n              List<SimpleOrderedMap<Object>> buckets = (List<SimpleOrderedMap<Object>>)asdf.get(\"buckets\");\n              for(SimpleOrderedMap<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                SimpleOrderedMap<Object> missingCounts = (SimpleOrderedMap<Object>) asdf.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n    String contains = params.getFieldParam(field, FacetParams.FACET_CONTAINS);\n    boolean ignoreCase = params.getFieldBool(field, FacetParams.FACET_CONTAINS_IGNORE_CASE, false);\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    FacetMethod method = null;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      method = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      method = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      method = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      method = FacetMethod.UIF;\n    }\n\n    if (method == FacetMethod.ENUM && TrieField.getMainValuePrefix(ft) != null) {\n      // enum can't deal with trie fields that index several terms per value\n      method = sf.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n    }\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      method = FacetMethod.ENUM;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n    \n    if (ft.getNumericType() != null && !sf.multiValued()) {\n      // the per-segment approach is optimal for numeric field types since there\n      // are no global ords to merge and no need to create an expensive\n      // top-level reader\n      method = FacetMethod.FCS;\n    }\n\n    if (method == null) {\n      // TODO: default to per-segment or not?\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.FCS && multiToken) {\n      // only fc knows how to deal with multi-token fields\n      method = FacetMethod.FC;\n    }\n    \n    if (method == FacetMethod.ENUM && sf.hasDocValues()) {\n      // only fc can handle docvalues types\n      method = FacetMethod.FC;\n    }\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"method\", method.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n    } else {\n      assert method != null;\n      switch (method) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, contains, ignoreCase, params);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumericType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (contains != null && !contains.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_CONTAINS + \" is not supported on numeric types\");\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, contains, ignoreCase);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(\"sort\", sortVal );\n\n            Map<String, Object> topLevel = new HashMap<>();\n            topLevel.put(field, jsonFacet);\n              \n            topLevel.put(\"processEmpty\", true);\n\n            FacetProcessor fproc = FacetProcessor.createProcessor(rb.req, topLevel, // rb.getResults().docSet\n                                                                    docs );\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n            fproc.process();\n\n            //Go through the response to build the expected output for SimpleFacets\n            Object res = fproc.getResponse();\n            counts = new NamedList<Integer>();\n            if(res != null) {\n              SimpleOrderedMap<Object> som = (SimpleOrderedMap<Object>)res;\n              SimpleOrderedMap<Object> asdf = (SimpleOrderedMap<Object>) som.get(field);\n\n              List<SimpleOrderedMap<Object>> buckets = (List<SimpleOrderedMap<Object>>)asdf.get(\"buckets\");\n              for(SimpleOrderedMap<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                SimpleOrderedMap<Object> missingCounts = (SimpleOrderedMap<Object>) asdf.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","bugFix":["3802d95c3a31be21ea2971945049b711d95ef8d5","3e5f469d206ae27a1d59e654e70a1413ffcec765","92751ba9273251eab6a2e379ec42a1697a32ff96"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"39342cb658ac11dfcbf4459807fb00eb9ada0218","date":1472876688,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","sourceNew":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n    String contains = params.getFieldParam(field, FacetParams.FACET_CONTAINS);\n    boolean ignoreCase = params.getFieldBool(field, FacetParams.FACET_CONTAINS_IGNORE_CASE, false);\n    boolean exists = params.getFieldBool(field, FacetParams.FACET_EXISTS, false);\n    \n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    final FacetMethod requestedMethod;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      requestedMethod = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      requestedMethod = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      requestedMethod = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      requestedMethod = FacetMethod.UIF;\n    } else {\n      requestedMethod=null;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    FacetMethod appliedFacetMethod = selectFacetMethod(field,\n                                sf, requestedMethod, mincount,\n                                exists);\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"requestedMethod\", requestedMethod==null?\"not specified\":requestedMethod.name());\n       fdebug.putInfoItem(\"appliedMethod\", appliedFacetMethod.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n    } else {\n      assert appliedFacetMethod != null;\n      switch (appliedFacetMethod) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, contains, ignoreCase, \n                                          exists);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumericType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (contains != null && !contains.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_CONTAINS + \" is not supported on numeric types\");\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, contains, ignoreCase);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(\"sort\", sortVal );\n\n            Map<String, Object> topLevel = new HashMap<>();\n            topLevel.put(field, jsonFacet);\n              \n            topLevel.put(\"processEmpty\", true);\n\n            FacetProcessor fproc = FacetProcessor.createProcessor(rb.req, topLevel, // rb.getResults().docSet\n                                                                    docs );\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n            fproc.process();\n\n            //Go through the response to build the expected output for SimpleFacets\n            Object res = fproc.getResponse();\n            counts = new NamedList<Integer>();\n            if(res != null) {\n              SimpleOrderedMap<Object> som = (SimpleOrderedMap<Object>)res;\n              SimpleOrderedMap<Object> asdf = (SimpleOrderedMap<Object>) som.get(field);\n\n              List<SimpleOrderedMap<Object>> buckets = (List<SimpleOrderedMap<Object>>)asdf.get(\"buckets\");\n              for(SimpleOrderedMap<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                SimpleOrderedMap<Object> missingCounts = (SimpleOrderedMap<Object>) asdf.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n    String contains = params.getFieldParam(field, FacetParams.FACET_CONTAINS);\n    boolean ignoreCase = params.getFieldBool(field, FacetParams.FACET_CONTAINS_IGNORE_CASE, false);\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    final FacetMethod requestedMethod;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      requestedMethod = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      requestedMethod = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      requestedMethod = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      requestedMethod = FacetMethod.UIF;\n    }else{\n      requestedMethod=null;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    FacetMethod appliedFacetMethod = selectFacetMethod(sf, requestedMethod, mincount);\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"requestedMethod\", requestedMethod==null?\"not specified\":requestedMethod.name());\n       fdebug.putInfoItem(\"appliedMethod\", appliedFacetMethod.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n    } else {\n      assert appliedFacetMethod != null;\n      switch (appliedFacetMethod) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, contains, ignoreCase, params);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumericType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (contains != null && !contains.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_CONTAINS + \" is not supported on numeric types\");\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, contains, ignoreCase);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(\"sort\", sortVal );\n\n            Map<String, Object> topLevel = new HashMap<>();\n            topLevel.put(field, jsonFacet);\n              \n            topLevel.put(\"processEmpty\", true);\n\n            FacetProcessor fproc = FacetProcessor.createProcessor(rb.req, topLevel, // rb.getResults().docSet\n                                                                    docs );\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n            fproc.process();\n\n            //Go through the response to build the expected output for SimpleFacets\n            Object res = fproc.getResponse();\n            counts = new NamedList<Integer>();\n            if(res != null) {\n              SimpleOrderedMap<Object> som = (SimpleOrderedMap<Object>)res;\n              SimpleOrderedMap<Object> asdf = (SimpleOrderedMap<Object>) som.get(field);\n\n              List<SimpleOrderedMap<Object>> buckets = (List<SimpleOrderedMap<Object>>)asdf.get(\"buckets\");\n              for(SimpleOrderedMap<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                SimpleOrderedMap<Object> missingCounts = (SimpleOrderedMap<Object>) asdf.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bc8f206328a706450934717bec7ccc22ad166fc0","date":1473142172,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","sourceNew":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n    String contains = params.getFieldParam(field, FacetParams.FACET_CONTAINS);\n    boolean ignoreCase = params.getFieldBool(field, FacetParams.FACET_CONTAINS_IGNORE_CASE, false);\n    boolean exists = params.getFieldBool(field, FacetParams.FACET_EXISTS, false);\n    \n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    final FacetMethod requestedMethod;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      requestedMethod = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      requestedMethod = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      requestedMethod = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      requestedMethod = FacetMethod.UIF;\n    } else {\n      requestedMethod=null;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    FacetMethod appliedFacetMethod = selectFacetMethod(field,\n                                sf, requestedMethod, mincount,\n                                exists);\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"requestedMethod\", requestedMethod==null?\"not specified\":requestedMethod.name());\n       fdebug.putInfoItem(\"appliedMethod\", appliedFacetMethod.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n    } else {\n      assert appliedFacetMethod != null;\n      switch (appliedFacetMethod) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, contains, ignoreCase, \n                                          exists);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumericType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (contains != null && !contains.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_CONTAINS + \" is not supported on numeric types\");\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, contains, ignoreCase);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(\"sort\", sortVal );\n\n            Map<String, Object> topLevel = new HashMap<>();\n            topLevel.put(field, jsonFacet);\n              \n            topLevel.put(\"processEmpty\", true);\n\n            FacetProcessor fproc = FacetProcessor.createProcessor(rb.req, topLevel, // rb.getResults().docSet\n                                                                    docs );\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n            fproc.process();\n\n            //Go through the response to build the expected output for SimpleFacets\n            Object res = fproc.getResponse();\n            counts = new NamedList<Integer>();\n            if(res != null) {\n              SimpleOrderedMap<Object> som = (SimpleOrderedMap<Object>)res;\n              SimpleOrderedMap<Object> asdf = (SimpleOrderedMap<Object>) som.get(field);\n\n              List<SimpleOrderedMap<Object>> buckets = (List<SimpleOrderedMap<Object>>)asdf.get(\"buckets\");\n              for(SimpleOrderedMap<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                SimpleOrderedMap<Object> missingCounts = (SimpleOrderedMap<Object>) asdf.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n    String contains = params.getFieldParam(field, FacetParams.FACET_CONTAINS);\n    boolean ignoreCase = params.getFieldBool(field, FacetParams.FACET_CONTAINS_IGNORE_CASE, false);\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    final FacetMethod requestedMethod;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      requestedMethod = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      requestedMethod = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      requestedMethod = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      requestedMethod = FacetMethod.UIF;\n    }else{\n      requestedMethod=null;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    FacetMethod appliedFacetMethod = selectFacetMethod(sf, requestedMethod, mincount);\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"requestedMethod\", requestedMethod==null?\"not specified\":requestedMethod.name());\n       fdebug.putInfoItem(\"appliedMethod\", appliedFacetMethod.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n    } else {\n      assert appliedFacetMethod != null;\n      switch (appliedFacetMethod) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, contains, ignoreCase, params);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumericType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (contains != null && !contains.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_CONTAINS + \" is not supported on numeric types\");\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, contains, ignoreCase);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(\"sort\", sortVal );\n\n            Map<String, Object> topLevel = new HashMap<>();\n            topLevel.put(field, jsonFacet);\n              \n            topLevel.put(\"processEmpty\", true);\n\n            FacetProcessor fproc = FacetProcessor.createProcessor(rb.req, topLevel, // rb.getResults().docSet\n                                                                    docs );\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n            fproc.process();\n\n            //Go through the response to build the expected output for SimpleFacets\n            Object res = fproc.getResponse();\n            counts = new NamedList<Integer>();\n            if(res != null) {\n              SimpleOrderedMap<Object> som = (SimpleOrderedMap<Object>)res;\n              SimpleOrderedMap<Object> asdf = (SimpleOrderedMap<Object>) som.get(field);\n\n              List<SimpleOrderedMap<Object>> buckets = (List<SimpleOrderedMap<Object>>)asdf.get(\"buckets\");\n              for(SimpleOrderedMap<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                SimpleOrderedMap<Object> missingCounts = (SimpleOrderedMap<Object>) asdf.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"89424def13674ea17829b41c5883c54ecc31a132","date":1473767373,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","sourceNew":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n    String contains = params.getFieldParam(field, FacetParams.FACET_CONTAINS);\n    boolean ignoreCase = params.getFieldBool(field, FacetParams.FACET_CONTAINS_IGNORE_CASE, false);\n    boolean exists = params.getFieldBool(field, FacetParams.FACET_EXISTS, false);\n    \n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    final FacetMethod requestedMethod;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      requestedMethod = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      requestedMethod = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      requestedMethod = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      requestedMethod = FacetMethod.UIF;\n    } else {\n      requestedMethod=null;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    FacetMethod appliedFacetMethod = selectFacetMethod(field,\n                                sf, requestedMethod, mincount,\n                                exists);\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"requestedMethod\", requestedMethod==null?\"not specified\":requestedMethod.name());\n       fdebug.putInfoItem(\"appliedMethod\", appliedFacetMethod.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n    } else {\n      assert appliedFacetMethod != null;\n      switch (appliedFacetMethod) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, contains, ignoreCase, \n                                          exists);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumericType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (contains != null && !contains.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_CONTAINS + \" is not supported on numeric types\");\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, contains, ignoreCase);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(\"sort\", sortVal );\n\n            Map<String, Object> topLevel = new HashMap<>();\n            topLevel.put(field, jsonFacet);\n              \n            topLevel.put(\"processEmpty\", true);\n\n            FacetProcessor fproc = FacetProcessor.createProcessor(rb.req, topLevel, // rb.getResults().docSet\n                                                                    docs );\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n            fproc.process();\n\n            //Go through the response to build the expected output for SimpleFacets\n            Object res = fproc.getResponse();\n            counts = new NamedList<Integer>();\n            if(res != null) {\n              SimpleOrderedMap<Object> som = (SimpleOrderedMap<Object>)res;\n              SimpleOrderedMap<Object> asdf = (SimpleOrderedMap<Object>) som.get(field);\n\n              List<SimpleOrderedMap<Object>> buckets = (List<SimpleOrderedMap<Object>>)asdf.get(\"buckets\");\n              for(SimpleOrderedMap<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                SimpleOrderedMap<Object> missingCounts = (SimpleOrderedMap<Object>) asdf.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n    String contains = params.getFieldParam(field, FacetParams.FACET_CONTAINS);\n    boolean ignoreCase = params.getFieldBool(field, FacetParams.FACET_CONTAINS_IGNORE_CASE, false);\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    final FacetMethod requestedMethod;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      requestedMethod = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      requestedMethod = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      requestedMethod = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      requestedMethod = FacetMethod.UIF;\n    }else{\n      requestedMethod=null;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    FacetMethod appliedFacetMethod = selectFacetMethod(sf, requestedMethod, mincount);\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"requestedMethod\", requestedMethod==null?\"not specified\":requestedMethod.name());\n       fdebug.putInfoItem(\"appliedMethod\", appliedFacetMethod.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n    } else {\n      assert appliedFacetMethod != null;\n      switch (appliedFacetMethod) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, contains, ignoreCase, params);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumericType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (contains != null && !contains.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_CONTAINS + \" is not supported on numeric types\");\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, contains, ignoreCase);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(\"sort\", sortVal );\n\n            Map<String, Object> topLevel = new HashMap<>();\n            topLevel.put(field, jsonFacet);\n              \n            topLevel.put(\"processEmpty\", true);\n\n            FacetProcessor fproc = FacetProcessor.createProcessor(rb.req, topLevel, // rb.getResults().docSet\n                                                                    docs );\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n            fproc.process();\n\n            //Go through the response to build the expected output for SimpleFacets\n            Object res = fproc.getResponse();\n            counts = new NamedList<Integer>();\n            if(res != null) {\n              SimpleOrderedMap<Object> som = (SimpleOrderedMap<Object>)res;\n              SimpleOrderedMap<Object> asdf = (SimpleOrderedMap<Object>) som.get(field);\n\n              List<SimpleOrderedMap<Object>> buckets = (List<SimpleOrderedMap<Object>>)asdf.get(\"buckets\");\n              for(SimpleOrderedMap<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                SimpleOrderedMap<Object> missingCounts = (SimpleOrderedMap<Object>) asdf.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","sourceNew":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n    String contains = params.getFieldParam(field, FacetParams.FACET_CONTAINS);\n    boolean ignoreCase = params.getFieldBool(field, FacetParams.FACET_CONTAINS_IGNORE_CASE, false);\n    boolean exists = params.getFieldBool(field, FacetParams.FACET_EXISTS, false);\n    \n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    final FacetMethod requestedMethod;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      requestedMethod = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      requestedMethod = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      requestedMethod = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      requestedMethod = FacetMethod.UIF;\n    } else {\n      requestedMethod=null;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    FacetMethod appliedFacetMethod = selectFacetMethod(field,\n                                sf, requestedMethod, mincount,\n                                exists);\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"requestedMethod\", requestedMethod==null?\"not specified\":requestedMethod.name());\n       fdebug.putInfoItem(\"appliedMethod\", appliedFacetMethod.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n    } else {\n      assert appliedFacetMethod != null;\n      switch (appliedFacetMethod) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, contains, ignoreCase, \n                                          exists);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumericType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (contains != null && !contains.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_CONTAINS + \" is not supported on numeric types\");\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, contains, ignoreCase);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(\"sort\", sortVal );\n\n            Map<String, Object> topLevel = new HashMap<>();\n            topLevel.put(field, jsonFacet);\n              \n            topLevel.put(\"processEmpty\", true);\n\n            FacetProcessor fproc = FacetProcessor.createProcessor(rb.req, topLevel, // rb.getResults().docSet\n                                                                    docs );\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n            fproc.process();\n\n            //Go through the response to build the expected output for SimpleFacets\n            Object res = fproc.getResponse();\n            counts = new NamedList<Integer>();\n            if(res != null) {\n              SimpleOrderedMap<Object> som = (SimpleOrderedMap<Object>)res;\n              SimpleOrderedMap<Object> asdf = (SimpleOrderedMap<Object>) som.get(field);\n\n              List<SimpleOrderedMap<Object>> buckets = (List<SimpleOrderedMap<Object>>)asdf.get(\"buckets\");\n              for(SimpleOrderedMap<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                SimpleOrderedMap<Object> missingCounts = (SimpleOrderedMap<Object>) asdf.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n    String contains = params.getFieldParam(field, FacetParams.FACET_CONTAINS);\n    boolean ignoreCase = params.getFieldBool(field, FacetParams.FACET_CONTAINS_IGNORE_CASE, false);\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    final FacetMethod requestedMethod;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      requestedMethod = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      requestedMethod = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      requestedMethod = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      requestedMethod = FacetMethod.UIF;\n    }else{\n      requestedMethod=null;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    FacetMethod appliedFacetMethod = selectFacetMethod(sf, requestedMethod, mincount);\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"requestedMethod\", requestedMethod==null?\"not specified\":requestedMethod.name());\n       fdebug.putInfoItem(\"appliedMethod\", appliedFacetMethod.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n    } else {\n      assert appliedFacetMethod != null;\n      switch (appliedFacetMethod) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, contains, ignoreCase, params);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumericType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (contains != null && !contains.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_CONTAINS + \" is not supported on numeric types\");\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, contains, ignoreCase);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(\"sort\", sortVal );\n\n            Map<String, Object> topLevel = new HashMap<>();\n            topLevel.put(field, jsonFacet);\n              \n            topLevel.put(\"processEmpty\", true);\n\n            FacetProcessor fproc = FacetProcessor.createProcessor(rb.req, topLevel, // rb.getResults().docSet\n                                                                    docs );\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n            fproc.process();\n\n            //Go through the response to build the expected output for SimpleFacets\n            Object res = fproc.getResponse();\n            counts = new NamedList<Integer>();\n            if(res != null) {\n              SimpleOrderedMap<Object> som = (SimpleOrderedMap<Object>)res;\n              SimpleOrderedMap<Object> asdf = (SimpleOrderedMap<Object>) som.get(field);\n\n              List<SimpleOrderedMap<Object>> buckets = (List<SimpleOrderedMap<Object>>)asdf.get(\"buckets\");\n              for(SimpleOrderedMap<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                SimpleOrderedMap<Object> missingCounts = (SimpleOrderedMap<Object>) asdf.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","sourceNew":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n    String contains = params.getFieldParam(field, FacetParams.FACET_CONTAINS);\n    boolean ignoreCase = params.getFieldBool(field, FacetParams.FACET_CONTAINS_IGNORE_CASE, false);\n    boolean exists = params.getFieldBool(field, FacetParams.FACET_EXISTS, false);\n    \n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    final FacetMethod requestedMethod;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      requestedMethod = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      requestedMethod = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      requestedMethod = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      requestedMethod = FacetMethod.UIF;\n    } else {\n      requestedMethod=null;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    FacetMethod appliedFacetMethod = selectFacetMethod(field,\n                                sf, requestedMethod, mincount,\n                                exists);\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"requestedMethod\", requestedMethod==null?\"not specified\":requestedMethod.name());\n       fdebug.putInfoItem(\"appliedMethod\", appliedFacetMethod.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n    } else {\n      assert appliedFacetMethod != null;\n      switch (appliedFacetMethod) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, contains, ignoreCase, \n                                          exists);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumericType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (contains != null && !contains.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_CONTAINS + \" is not supported on numeric types\");\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, contains, ignoreCase);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(\"sort\", sortVal );\n\n            Map<String, Object> topLevel = new HashMap<>();\n            topLevel.put(field, jsonFacet);\n              \n            topLevel.put(\"processEmpty\", true);\n\n            FacetProcessor fproc = FacetProcessor.createProcessor(rb.req, topLevel, // rb.getResults().docSet\n                                                                    docs );\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n            fproc.process();\n\n            //Go through the response to build the expected output for SimpleFacets\n            Object res = fproc.getResponse();\n            counts = new NamedList<Integer>();\n            if(res != null) {\n              SimpleOrderedMap<Object> som = (SimpleOrderedMap<Object>)res;\n              SimpleOrderedMap<Object> asdf = (SimpleOrderedMap<Object>) som.get(field);\n\n              List<SimpleOrderedMap<Object>> buckets = (List<SimpleOrderedMap<Object>>)asdf.get(\"buckets\");\n              for(SimpleOrderedMap<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                SimpleOrderedMap<Object> missingCounts = (SimpleOrderedMap<Object>) asdf.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n    String contains = params.getFieldParam(field, FacetParams.FACET_CONTAINS);\n    boolean ignoreCase = params.getFieldBool(field, FacetParams.FACET_CONTAINS_IGNORE_CASE, false);\n\n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    FacetMethod method = null;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      method = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      method = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      method = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      method = FacetMethod.UIF;\n    }\n\n    if (method == FacetMethod.ENUM && TrieField.getMainValuePrefix(ft) != null) {\n      // enum can't deal with trie fields that index several terms per value\n      method = sf.multiValued() ? FacetMethod.FC : FacetMethod.FCS;\n    }\n\n    if (method == null && ft instanceof BoolField) {\n      // Always use filters for booleans... we know the number of values is very small.\n      method = FacetMethod.ENUM;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n    \n    if (ft.getNumericType() != null && !sf.multiValued()) {\n      // the per-segment approach is optimal for numeric field types since there\n      // are no global ords to merge and no need to create an expensive\n      // top-level reader\n      method = FacetMethod.FCS;\n    }\n\n    if (method == null) {\n      // TODO: default to per-segment or not?\n      method = FacetMethod.FC;\n    }\n\n    if (method == FacetMethod.FCS && multiToken) {\n      // only fc knows how to deal with multi-token fields\n      method = FacetMethod.FC;\n    }\n    \n    if (method == FacetMethod.ENUM && sf.hasDocValues()) {\n      // only fc can handle docvalues types\n      method = FacetMethod.FC;\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n    } else {\n      assert method != null;\n      switch (method) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, contains, ignoreCase, params);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumericType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (contains != null && !contains.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_CONTAINS + \" is not supported on numeric types\");\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, contains, ignoreCase);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(\"sort\", sortVal );\n\n            Map<String, Object> topLevel = new HashMap<>();\n            topLevel.put(field, jsonFacet);\n              \n            topLevel.put(\"processEmpty\", true);\n\n            FacetProcessor fproc = FacetProcessor.createProcessor(rb.req, topLevel, // rb.getResults().docSet\n                                                                    docs );\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n            fproc.process();\n\n            //Go through the response to build the expected output for SimpleFacets\n            Object res = fproc.getResponse();\n            counts = new NamedList<Integer>();\n            if(res != null) {\n              SimpleOrderedMap<Object> som = (SimpleOrderedMap<Object>)res;\n              SimpleOrderedMap<Object> asdf = (SimpleOrderedMap<Object>) som.get(field);\n\n              List<SimpleOrderedMap<Object>> buckets = (List<SimpleOrderedMap<Object>>)asdf.get(\"buckets\");\n              for(SimpleOrderedMap<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                SimpleOrderedMap<Object> missingCounts = (SimpleOrderedMap<Object>) asdf.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"46dc9ac8b3e748407baaef82453138ff3974480c","date":1484789241,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","sourceNew":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n    String contains = params.getFieldParam(field, FacetParams.FACET_CONTAINS);\n    boolean ignoreCase = params.getFieldBool(field, FacetParams.FACET_CONTAINS_IGNORE_CASE, false);\n    boolean exists = params.getFieldBool(field, FacetParams.FACET_EXISTS, false);\n    \n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    if (sf.getType().isPointField() && !sf.hasDocValues()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \n          \"Can't facet on a PointField without docValues\");\n    }\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    final FacetMethod requestedMethod;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      requestedMethod = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      requestedMethod = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      requestedMethod = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      requestedMethod = FacetMethod.UIF;\n    } else {\n      requestedMethod=null;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    FacetMethod appliedFacetMethod = selectFacetMethod(field,\n                                sf, requestedMethod, mincount,\n                                exists);\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"requestedMethod\", requestedMethod==null?\"not specified\":requestedMethod.name());\n       fdebug.putInfoItem(\"appliedMethod\", appliedFacetMethod.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n    } else {\n      assert appliedFacetMethod != null;\n      switch (appliedFacetMethod) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, contains, ignoreCase, \n                                          exists);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumericType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (contains != null && !contains.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_CONTAINS + \" is not supported on numeric types\");\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, contains, ignoreCase);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(\"sort\", sortVal );\n\n            Map<String, Object> topLevel = new HashMap<>();\n            topLevel.put(field, jsonFacet);\n              \n            topLevel.put(\"processEmpty\", true);\n\n            FacetProcessor fproc = FacetProcessor.createProcessor(rb.req, topLevel, // rb.getResults().docSet\n                                                                    docs );\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n            fproc.process();\n\n            //Go through the response to build the expected output for SimpleFacets\n            Object res = fproc.getResponse();\n            counts = new NamedList<Integer>();\n            if(res != null) {\n              SimpleOrderedMap<Object> som = (SimpleOrderedMap<Object>)res;\n              SimpleOrderedMap<Object> asdf = (SimpleOrderedMap<Object>) som.get(field);\n\n              List<SimpleOrderedMap<Object>> buckets = (List<SimpleOrderedMap<Object>>)asdf.get(\"buckets\");\n              for(SimpleOrderedMap<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                SimpleOrderedMap<Object> missingCounts = (SimpleOrderedMap<Object>) asdf.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n    String contains = params.getFieldParam(field, FacetParams.FACET_CONTAINS);\n    boolean ignoreCase = params.getFieldBool(field, FacetParams.FACET_CONTAINS_IGNORE_CASE, false);\n    boolean exists = params.getFieldBool(field, FacetParams.FACET_EXISTS, false);\n    \n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    final FacetMethod requestedMethod;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      requestedMethod = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      requestedMethod = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      requestedMethod = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      requestedMethod = FacetMethod.UIF;\n    } else {\n      requestedMethod=null;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    FacetMethod appliedFacetMethod = selectFacetMethod(field,\n                                sf, requestedMethod, mincount,\n                                exists);\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"requestedMethod\", requestedMethod==null?\"not specified\":requestedMethod.name());\n       fdebug.putInfoItem(\"appliedMethod\", appliedFacetMethod.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n    } else {\n      assert appliedFacetMethod != null;\n      switch (appliedFacetMethod) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, contains, ignoreCase, \n                                          exists);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumericType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (contains != null && !contains.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_CONTAINS + \" is not supported on numeric types\");\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, contains, ignoreCase);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(\"sort\", sortVal );\n\n            Map<String, Object> topLevel = new HashMap<>();\n            topLevel.put(field, jsonFacet);\n              \n            topLevel.put(\"processEmpty\", true);\n\n            FacetProcessor fproc = FacetProcessor.createProcessor(rb.req, topLevel, // rb.getResults().docSet\n                                                                    docs );\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n            fproc.process();\n\n            //Go through the response to build the expected output for SimpleFacets\n            Object res = fproc.getResponse();\n            counts = new NamedList<Integer>();\n            if(res != null) {\n              SimpleOrderedMap<Object> som = (SimpleOrderedMap<Object>)res;\n              SimpleOrderedMap<Object> asdf = (SimpleOrderedMap<Object>) som.get(field);\n\n              List<SimpleOrderedMap<Object>> buckets = (List<SimpleOrderedMap<Object>>)asdf.get(\"buckets\");\n              for(SimpleOrderedMap<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                SimpleOrderedMap<Object> missingCounts = (SimpleOrderedMap<Object>) asdf.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"90a682dc1bfd188ef61cc28373c7f5d700b4ac75","date":1485186128,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","sourceNew":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n    String contains = params.getFieldParam(field, FacetParams.FACET_CONTAINS);\n    boolean ignoreCase = params.getFieldBool(field, FacetParams.FACET_CONTAINS_IGNORE_CASE, false);\n    boolean exists = params.getFieldBool(field, FacetParams.FACET_EXISTS, false);\n    \n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    if (sf.getType().isPointField() && !sf.hasDocValues()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \n          \"Can't facet on a PointField without docValues\");\n    }\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    final FacetMethod requestedMethod;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      requestedMethod = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      requestedMethod = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      requestedMethod = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      requestedMethod = FacetMethod.UIF;\n    } else {\n      requestedMethod=null;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    FacetMethod appliedFacetMethod = selectFacetMethod(field,\n                                sf, requestedMethod, mincount,\n                                exists);\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"requestedMethod\", requestedMethod==null?\"not specified\":requestedMethod.name());\n       fdebug.putInfoItem(\"appliedMethod\", appliedFacetMethod.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n    } else {\n      assert appliedFacetMethod != null;\n      switch (appliedFacetMethod) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, contains, ignoreCase, \n                                          exists);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumericType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (contains != null && !contains.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_CONTAINS + \" is not supported on numeric types\");\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, contains, ignoreCase);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(\"sort\", sortVal );\n\n            Map<String, Object> topLevel = new HashMap<>();\n            topLevel.put(field, jsonFacet);\n              \n            topLevel.put(\"processEmpty\", true);\n\n            FacetProcessor fproc = FacetProcessor.createProcessor(rb.req, topLevel, // rb.getResults().docSet\n                                                                    docs );\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n            fproc.process();\n\n            //Go through the response to build the expected output for SimpleFacets\n            Object res = fproc.getResponse();\n            counts = new NamedList<Integer>();\n            if(res != null) {\n              SimpleOrderedMap<Object> som = (SimpleOrderedMap<Object>)res;\n              SimpleOrderedMap<Object> asdf = (SimpleOrderedMap<Object>) som.get(field);\n\n              List<SimpleOrderedMap<Object>> buckets = (List<SimpleOrderedMap<Object>>)asdf.get(\"buckets\");\n              for(SimpleOrderedMap<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                SimpleOrderedMap<Object> missingCounts = (SimpleOrderedMap<Object>) asdf.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n    String contains = params.getFieldParam(field, FacetParams.FACET_CONTAINS);\n    boolean ignoreCase = params.getFieldBool(field, FacetParams.FACET_CONTAINS_IGNORE_CASE, false);\n    boolean exists = params.getFieldBool(field, FacetParams.FACET_EXISTS, false);\n    \n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    final FacetMethod requestedMethod;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      requestedMethod = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      requestedMethod = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      requestedMethod = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      requestedMethod = FacetMethod.UIF;\n    } else {\n      requestedMethod=null;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    FacetMethod appliedFacetMethod = selectFacetMethod(field,\n                                sf, requestedMethod, mincount,\n                                exists);\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"requestedMethod\", requestedMethod==null?\"not specified\":requestedMethod.name());\n       fdebug.putInfoItem(\"appliedMethod\", appliedFacetMethod.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n    } else {\n      assert appliedFacetMethod != null;\n      switch (appliedFacetMethod) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, contains, ignoreCase, \n                                          exists);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumericType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (contains != null && !contains.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_CONTAINS + \" is not supported on numeric types\");\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, contains, ignoreCase);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(\"sort\", sortVal );\n\n            Map<String, Object> topLevel = new HashMap<>();\n            topLevel.put(field, jsonFacet);\n              \n            topLevel.put(\"processEmpty\", true);\n\n            FacetProcessor fproc = FacetProcessor.createProcessor(rb.req, topLevel, // rb.getResults().docSet\n                                                                    docs );\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n            fproc.process();\n\n            //Go through the response to build the expected output for SimpleFacets\n            Object res = fproc.getResponse();\n            counts = new NamedList<Integer>();\n            if(res != null) {\n              SimpleOrderedMap<Object> som = (SimpleOrderedMap<Object>)res;\n              SimpleOrderedMap<Object> asdf = (SimpleOrderedMap<Object>) som.get(field);\n\n              List<SimpleOrderedMap<Object>> buckets = (List<SimpleOrderedMap<Object>>)asdf.get(\"buckets\");\n              for(SimpleOrderedMap<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                SimpleOrderedMap<Object> missingCounts = (SimpleOrderedMap<Object>) asdf.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3d81baa64023bbb9b43f6d929ee168b105940d30","date":1486492702,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","sourceNew":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n    String contains = params.getFieldParam(field, FacetParams.FACET_CONTAINS);\n    boolean ignoreCase = params.getFieldBool(field, FacetParams.FACET_CONTAINS_IGNORE_CASE, false);\n    boolean exists = params.getFieldBool(field, FacetParams.FACET_EXISTS, false);\n    \n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    if (sf.getType().isPointField() && !sf.hasDocValues()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \n          \"Can't facet on a PointField without docValues\");\n    }\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    final FacetMethod requestedMethod;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      requestedMethod = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      requestedMethod = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      requestedMethod = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      requestedMethod = FacetMethod.UIF;\n    } else {\n      requestedMethod=null;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    FacetMethod appliedFacetMethod = selectFacetMethod(field,\n                                sf, requestedMethod, mincount,\n                                exists);\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"requestedMethod\", requestedMethod==null?\"not specified\":requestedMethod.name());\n       fdebug.putInfoItem(\"appliedMethod\", appliedFacetMethod.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n    } else {\n      assert appliedFacetMethod != null;\n      switch (appliedFacetMethod) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, contains, ignoreCase, \n                                          exists);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumberType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (contains != null && !contains.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_CONTAINS + \" is not supported on numeric types\");\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, contains, ignoreCase);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(\"sort\", sortVal );\n\n            Map<String, Object> topLevel = new HashMap<>();\n            topLevel.put(field, jsonFacet);\n              \n            topLevel.put(\"processEmpty\", true);\n\n            FacetProcessor fproc = FacetProcessor.createProcessor(rb.req, topLevel, // rb.getResults().docSet\n                                                                    docs );\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n            fproc.process();\n\n            //Go through the response to build the expected output for SimpleFacets\n            Object res = fproc.getResponse();\n            counts = new NamedList<Integer>();\n            if(res != null) {\n              SimpleOrderedMap<Object> som = (SimpleOrderedMap<Object>)res;\n              SimpleOrderedMap<Object> asdf = (SimpleOrderedMap<Object>) som.get(field);\n\n              List<SimpleOrderedMap<Object>> buckets = (List<SimpleOrderedMap<Object>>)asdf.get(\"buckets\");\n              for(SimpleOrderedMap<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                SimpleOrderedMap<Object> missingCounts = (SimpleOrderedMap<Object>) asdf.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n    String contains = params.getFieldParam(field, FacetParams.FACET_CONTAINS);\n    boolean ignoreCase = params.getFieldBool(field, FacetParams.FACET_CONTAINS_IGNORE_CASE, false);\n    boolean exists = params.getFieldBool(field, FacetParams.FACET_EXISTS, false);\n    \n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    if (sf.getType().isPointField() && !sf.hasDocValues()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \n          \"Can't facet on a PointField without docValues\");\n    }\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    final FacetMethod requestedMethod;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      requestedMethod = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      requestedMethod = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      requestedMethod = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      requestedMethod = FacetMethod.UIF;\n    } else {\n      requestedMethod=null;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    FacetMethod appliedFacetMethod = selectFacetMethod(field,\n                                sf, requestedMethod, mincount,\n                                exists);\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"requestedMethod\", requestedMethod==null?\"not specified\":requestedMethod.name());\n       fdebug.putInfoItem(\"appliedMethod\", appliedFacetMethod.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n    } else {\n      assert appliedFacetMethod != null;\n      switch (appliedFacetMethod) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, contains, ignoreCase, \n                                          exists);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumericType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (contains != null && !contains.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_CONTAINS + \" is not supported on numeric types\");\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, contains, ignoreCase);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(\"sort\", sortVal );\n\n            Map<String, Object> topLevel = new HashMap<>();\n            topLevel.put(field, jsonFacet);\n              \n            topLevel.put(\"processEmpty\", true);\n\n            FacetProcessor fproc = FacetProcessor.createProcessor(rb.req, topLevel, // rb.getResults().docSet\n                                                                    docs );\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n            fproc.process();\n\n            //Go through the response to build the expected output for SimpleFacets\n            Object res = fproc.getResponse();\n            counts = new NamedList<Integer>();\n            if(res != null) {\n              SimpleOrderedMap<Object> som = (SimpleOrderedMap<Object>)res;\n              SimpleOrderedMap<Object> asdf = (SimpleOrderedMap<Object>) som.get(field);\n\n              List<SimpleOrderedMap<Object>> buckets = (List<SimpleOrderedMap<Object>>)asdf.get(\"buckets\");\n              for(SimpleOrderedMap<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                SimpleOrderedMap<Object> missingCounts = (SimpleOrderedMap<Object>) asdf.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"862ed062e72c1c01ecd8593b17804ac02b69cf0e","date":1486641184,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","sourceNew":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n\n    final Predicate<BytesRef> termFilter = newBytesRefFilter(field, params);\n\n    boolean exists = params.getFieldBool(field, FacetParams.FACET_EXISTS, false);\n    \n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    if (sf.getType().isPointField() && !sf.hasDocValues()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \n          \"Can't facet on a PointField without docValues\");\n    }\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    final FacetMethod requestedMethod;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      requestedMethod = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      requestedMethod = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      requestedMethod = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      requestedMethod = FacetMethod.UIF;\n    } else {\n      requestedMethod=null;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    FacetMethod appliedFacetMethod = selectFacetMethod(field,\n                                sf, requestedMethod, mincount,\n                                exists);\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"requestedMethod\", requestedMethod==null?\"not specified\":requestedMethod.name());\n       fdebug.putInfoItem(\"appliedMethod\", appliedFacetMethod.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, termFilter);\n    } else {\n      assert appliedFacetMethod != null;\n      switch (appliedFacetMethod) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, termFilter, exists);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumberType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (termFilter != null) {\n              final boolean supportedOperation = (termFilter instanceof SubstringBytesRefFilter) && ((SubstringBytesRefFilter) termFilter).substring().isEmpty();\n              if (!supportedOperation) {\n                throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_CONTAINS + \" is not supported on numeric types\");\n              }\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, termFilter);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(\"sort\", sortVal );\n\n            Map<String, Object> topLevel = new HashMap<>();\n            topLevel.put(field, jsonFacet);\n              \n            topLevel.put(\"processEmpty\", true);\n\n            FacetProcessor fproc = FacetProcessor.createProcessor(rb.req, topLevel, // rb.getResults().docSet\n                                                                    docs );\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n            fproc.process();\n\n            //Go through the response to build the expected output for SimpleFacets\n            Object res = fproc.getResponse();\n            counts = new NamedList<Integer>();\n            if(res != null) {\n              SimpleOrderedMap<Object> som = (SimpleOrderedMap<Object>)res;\n              SimpleOrderedMap<Object> asdf = (SimpleOrderedMap<Object>) som.get(field);\n\n              List<SimpleOrderedMap<Object>> buckets = (List<SimpleOrderedMap<Object>>)asdf.get(\"buckets\");\n              for(SimpleOrderedMap<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                SimpleOrderedMap<Object> missingCounts = (SimpleOrderedMap<Object>) asdf.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, termFilter, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n    String contains = params.getFieldParam(field, FacetParams.FACET_CONTAINS);\n    boolean ignoreCase = params.getFieldBool(field, FacetParams.FACET_CONTAINS_IGNORE_CASE, false);\n    boolean exists = params.getFieldBool(field, FacetParams.FACET_EXISTS, false);\n    \n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    if (sf.getType().isPointField() && !sf.hasDocValues()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \n          \"Can't facet on a PointField without docValues\");\n    }\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    final FacetMethod requestedMethod;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      requestedMethod = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      requestedMethod = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      requestedMethod = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      requestedMethod = FacetMethod.UIF;\n    } else {\n      requestedMethod=null;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    FacetMethod appliedFacetMethod = selectFacetMethod(field,\n                                sf, requestedMethod, mincount,\n                                exists);\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"requestedMethod\", requestedMethod==null?\"not specified\":requestedMethod.name());\n       fdebug.putInfoItem(\"appliedMethod\", appliedFacetMethod.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase);\n    } else {\n      assert appliedFacetMethod != null;\n      switch (appliedFacetMethod) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, contains, ignoreCase, \n                                          exists);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumberType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (contains != null && !contains.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_CONTAINS + \" is not supported on numeric types\");\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, contains, ignoreCase);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(\"sort\", sortVal );\n\n            Map<String, Object> topLevel = new HashMap<>();\n            topLevel.put(field, jsonFacet);\n              \n            topLevel.put(\"processEmpty\", true);\n\n            FacetProcessor fproc = FacetProcessor.createProcessor(rb.req, topLevel, // rb.getResults().docSet\n                                                                    docs );\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n            fproc.process();\n\n            //Go through the response to build the expected output for SimpleFacets\n            Object res = fproc.getResponse();\n            counts = new NamedList<Integer>();\n            if(res != null) {\n              SimpleOrderedMap<Object> som = (SimpleOrderedMap<Object>)res;\n              SimpleOrderedMap<Object> asdf = (SimpleOrderedMap<Object>) som.get(field);\n\n              List<SimpleOrderedMap<Object>> buckets = (List<SimpleOrderedMap<Object>>)asdf.get(\"buckets\");\n              for(SimpleOrderedMap<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                SimpleOrderedMap<Object> missingCounts = (SimpleOrderedMap<Object>) asdf.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, contains, ignoreCase, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"744b111b17d15d490a648eb021bfa240e7f11556","date":1487008069,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","sourceNew":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n\n    final Predicate<BytesRef> termFilter = newBytesRefFilter(field, params);\n\n    boolean exists = params.getFieldBool(field, FacetParams.FACET_EXISTS, false);\n    \n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    if (sf.getType().isPointField() && !sf.hasDocValues()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \n          \"Can't facet on a PointField without docValues\");\n    }\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    final FacetMethod requestedMethod;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      requestedMethod = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      requestedMethod = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      requestedMethod = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      requestedMethod = FacetMethod.UIF;\n    } else {\n      requestedMethod=null;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    FacetMethod appliedFacetMethod = selectFacetMethod(field,\n                                sf, requestedMethod, mincount,\n                                exists);\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"requestedMethod\", requestedMethod==null?\"not specified\":requestedMethod.name());\n       fdebug.putInfoItem(\"appliedMethod\", appliedFacetMethod.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, termFilter);\n    } else {\n      assert appliedFacetMethod != null;\n      switch (appliedFacetMethod) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, termFilter, exists);\n          break;\n        case FCS:\n          assert ft.isPointField() || !multiToken;\n          if (ft.isPointField() || (ft.getNumberType() != null && !sf.multiValued())) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (termFilter != null) {\n              final boolean supportedOperation = (termFilter instanceof SubstringBytesRefFilter) && ((SubstringBytesRefFilter) termFilter).substring().isEmpty();\n              if (!supportedOperation) {\n                throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_CONTAINS + \" is not supported on numeric types\");\n              }\n            }\n//            We should do this, but mincount=0 is currently the default\n//            if (ft.isPointField() && mincount <= 0) {\n//              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_MINCOUNT + \" <= 0 is not supported on point types\");\n//            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, termFilter);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(\"sort\", sortVal );\n\n            Map<String, Object> topLevel = new HashMap<>();\n            topLevel.put(field, jsonFacet);\n              \n            topLevel.put(\"processEmpty\", true);\n\n            FacetProcessor fproc = FacetProcessor.createProcessor(rb.req, topLevel, // rb.getResults().docSet\n                                                                    docs );\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n            fproc.process();\n\n            //Go through the response to build the expected output for SimpleFacets\n            Object res = fproc.getResponse();\n            counts = new NamedList<Integer>();\n            if(res != null) {\n              SimpleOrderedMap<Object> som = (SimpleOrderedMap<Object>)res;\n              SimpleOrderedMap<Object> asdf = (SimpleOrderedMap<Object>) som.get(field);\n\n              List<SimpleOrderedMap<Object>> buckets = (List<SimpleOrderedMap<Object>>)asdf.get(\"buckets\");\n              for(SimpleOrderedMap<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                SimpleOrderedMap<Object> missingCounts = (SimpleOrderedMap<Object>) asdf.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, termFilter, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n\n    final Predicate<BytesRef> termFilter = newBytesRefFilter(field, params);\n\n    boolean exists = params.getFieldBool(field, FacetParams.FACET_EXISTS, false);\n    \n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    if (sf.getType().isPointField() && !sf.hasDocValues()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \n          \"Can't facet on a PointField without docValues\");\n    }\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    final FacetMethod requestedMethod;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      requestedMethod = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      requestedMethod = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      requestedMethod = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      requestedMethod = FacetMethod.UIF;\n    } else {\n      requestedMethod=null;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    FacetMethod appliedFacetMethod = selectFacetMethod(field,\n                                sf, requestedMethod, mincount,\n                                exists);\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"requestedMethod\", requestedMethod==null?\"not specified\":requestedMethod.name());\n       fdebug.putInfoItem(\"appliedMethod\", appliedFacetMethod.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, termFilter);\n    } else {\n      assert appliedFacetMethod != null;\n      switch (appliedFacetMethod) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, termFilter, exists);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumberType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (termFilter != null) {\n              final boolean supportedOperation = (termFilter instanceof SubstringBytesRefFilter) && ((SubstringBytesRefFilter) termFilter).substring().isEmpty();\n              if (!supportedOperation) {\n                throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_CONTAINS + \" is not supported on numeric types\");\n              }\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, termFilter);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(\"sort\", sortVal );\n\n            Map<String, Object> topLevel = new HashMap<>();\n            topLevel.put(field, jsonFacet);\n              \n            topLevel.put(\"processEmpty\", true);\n\n            FacetProcessor fproc = FacetProcessor.createProcessor(rb.req, topLevel, // rb.getResults().docSet\n                                                                    docs );\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n            fproc.process();\n\n            //Go through the response to build the expected output for SimpleFacets\n            Object res = fproc.getResponse();\n            counts = new NamedList<Integer>();\n            if(res != null) {\n              SimpleOrderedMap<Object> som = (SimpleOrderedMap<Object>)res;\n              SimpleOrderedMap<Object> asdf = (SimpleOrderedMap<Object>) som.get(field);\n\n              List<SimpleOrderedMap<Object>> buckets = (List<SimpleOrderedMap<Object>>)asdf.get(\"buckets\");\n              for(SimpleOrderedMap<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                SimpleOrderedMap<Object> missingCounts = (SimpleOrderedMap<Object>) asdf.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, termFilter, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"022a4de90e0479b604264ca9c2e134c996454ab3","date":1487118265,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","sourceNew":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n\n    final Predicate<BytesRef> termFilter = newBytesRefFilter(field, params);\n\n    boolean exists = params.getFieldBool(field, FacetParams.FACET_EXISTS, false);\n    \n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    if (sf.getType().isPointField() && !sf.hasDocValues()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \n          \"Can't facet on a PointField without docValues\");\n    }\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    final FacetMethod requestedMethod;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      requestedMethod = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      requestedMethod = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      requestedMethod = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      requestedMethod = FacetMethod.UIF;\n    } else {\n      requestedMethod=null;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    FacetMethod appliedFacetMethod = selectFacetMethod(field,\n                                sf, requestedMethod, mincount,\n                                exists);\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"requestedMethod\", requestedMethod==null?\"not specified\":requestedMethod.name());\n       fdebug.putInfoItem(\"appliedMethod\", appliedFacetMethod.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, termFilter);\n    } else {\n      assert appliedFacetMethod != null;\n      switch (appliedFacetMethod) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, termFilter, exists);\n          break;\n        case FCS:\n          assert ft.isPointField() || !multiToken;\n          if (ft.isPointField() || (ft.getNumberType() != null && !sf.multiValued())) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (termFilter != null) {\n              final boolean supportedOperation = (termFilter instanceof SubstringBytesRefFilter) && ((SubstringBytesRefFilter) termFilter).substring().isEmpty();\n              if (!supportedOperation) {\n                throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_CONTAINS + \" is not supported on numeric types\");\n              }\n            }\n//            We should do this, but mincount=0 is currently the default\n//            if (ft.isPointField() && mincount <= 0) {\n//              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_MINCOUNT + \" <= 0 is not supported on point types\");\n//            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, termFilter);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(\"sort\", sortVal );\n\n            Map<String, Object> topLevel = new HashMap<>();\n            topLevel.put(field, jsonFacet);\n              \n            topLevel.put(\"processEmpty\", true);\n\n            FacetProcessor fproc = FacetProcessor.createProcessor(rb.req, topLevel, // rb.getResults().docSet\n                                                                    docs );\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n            fproc.process();\n\n            //Go through the response to build the expected output for SimpleFacets\n            Object res = fproc.getResponse();\n            counts = new NamedList<Integer>();\n            if(res != null) {\n              SimpleOrderedMap<Object> som = (SimpleOrderedMap<Object>)res;\n              SimpleOrderedMap<Object> asdf = (SimpleOrderedMap<Object>) som.get(field);\n\n              List<SimpleOrderedMap<Object>> buckets = (List<SimpleOrderedMap<Object>>)asdf.get(\"buckets\");\n              for(SimpleOrderedMap<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                SimpleOrderedMap<Object> missingCounts = (SimpleOrderedMap<Object>) asdf.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, termFilter, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n\n    final Predicate<BytesRef> termFilter = newBytesRefFilter(field, params);\n\n    boolean exists = params.getFieldBool(field, FacetParams.FACET_EXISTS, false);\n    \n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    if (sf.getType().isPointField() && !sf.hasDocValues()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \n          \"Can't facet on a PointField without docValues\");\n    }\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    final FacetMethod requestedMethod;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      requestedMethod = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      requestedMethod = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      requestedMethod = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      requestedMethod = FacetMethod.UIF;\n    } else {\n      requestedMethod=null;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    FacetMethod appliedFacetMethod = selectFacetMethod(field,\n                                sf, requestedMethod, mincount,\n                                exists);\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"requestedMethod\", requestedMethod==null?\"not specified\":requestedMethod.name());\n       fdebug.putInfoItem(\"appliedMethod\", appliedFacetMethod.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, termFilter);\n    } else {\n      assert appliedFacetMethod != null;\n      switch (appliedFacetMethod) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, termFilter, exists);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumberType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (termFilter != null) {\n              final boolean supportedOperation = (termFilter instanceof SubstringBytesRefFilter) && ((SubstringBytesRefFilter) termFilter).substring().isEmpty();\n              if (!supportedOperation) {\n                throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_CONTAINS + \" is not supported on numeric types\");\n              }\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, termFilter);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(\"sort\", sortVal );\n\n            Map<String, Object> topLevel = new HashMap<>();\n            topLevel.put(field, jsonFacet);\n              \n            topLevel.put(\"processEmpty\", true);\n\n            FacetProcessor fproc = FacetProcessor.createProcessor(rb.req, topLevel, // rb.getResults().docSet\n                                                                    docs );\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n            fproc.process();\n\n            //Go through the response to build the expected output for SimpleFacets\n            Object res = fproc.getResponse();\n            counts = new NamedList<Integer>();\n            if(res != null) {\n              SimpleOrderedMap<Object> som = (SimpleOrderedMap<Object>)res;\n              SimpleOrderedMap<Object> asdf = (SimpleOrderedMap<Object>) som.get(field);\n\n              List<SimpleOrderedMap<Object>> buckets = (List<SimpleOrderedMap<Object>>)asdf.get(\"buckets\");\n              for(SimpleOrderedMap<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                SimpleOrderedMap<Object> missingCounts = (SimpleOrderedMap<Object>) asdf.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, termFilter, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b49c0eb9ef7bc25609a89e7986ce7e6eeb9c9d96","date":1487122334,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","sourceNew":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n\n    final Predicate<BytesRef> termFilter = newBytesRefFilter(field, params);\n\n    boolean exists = params.getFieldBool(field, FacetParams.FACET_EXISTS, false);\n    \n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    if (sf.getType().isPointField() && !sf.hasDocValues()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \n          \"Can't facet on a PointField without docValues\");\n    }\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    final FacetMethod requestedMethod;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      requestedMethod = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      requestedMethod = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      requestedMethod = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      requestedMethod = FacetMethod.UIF;\n    } else {\n      requestedMethod=null;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    FacetMethod appliedFacetMethod = selectFacetMethod(field,\n                                sf, requestedMethod, mincount,\n                                exists);\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"requestedMethod\", requestedMethod==null?\"not specified\":requestedMethod.name());\n       fdebug.putInfoItem(\"appliedMethod\", appliedFacetMethod.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, termFilter);\n    } else {\n      assert appliedFacetMethod != null;\n      switch (appliedFacetMethod) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, termFilter, exists);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumberType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (termFilter != null) {\n              final boolean supportedOperation = (termFilter instanceof SubstringBytesRefFilter) && ((SubstringBytesRefFilter) termFilter).substring().isEmpty();\n              if (!supportedOperation) {\n                throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_CONTAINS + \" is not supported on numeric types\");\n              }\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, termFilter);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(\"sort\", sortVal );\n\n            Map<String, Object> topLevel = new HashMap<>();\n            topLevel.put(field, jsonFacet);\n              \n            topLevel.put(\"processEmpty\", true);\n\n            FacetProcessor fproc = FacetProcessor.createProcessor(rb.req, topLevel, // rb.getResults().docSet\n                                                                    docs );\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n            fproc.process();\n\n            //Go through the response to build the expected output for SimpleFacets\n            Object res = fproc.getResponse();\n            counts = new NamedList<Integer>();\n            if(res != null) {\n              SimpleOrderedMap<Object> som = (SimpleOrderedMap<Object>)res;\n              SimpleOrderedMap<Object> asdf = (SimpleOrderedMap<Object>) som.get(field);\n\n              List<SimpleOrderedMap<Object>> buckets = (List<SimpleOrderedMap<Object>>)asdf.get(\"buckets\");\n              for(SimpleOrderedMap<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                SimpleOrderedMap<Object> missingCounts = (SimpleOrderedMap<Object>) asdf.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, termFilter, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n\n    final Predicate<BytesRef> termFilter = newBytesRefFilter(field, params);\n\n    boolean exists = params.getFieldBool(field, FacetParams.FACET_EXISTS, false);\n    \n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    if (sf.getType().isPointField() && !sf.hasDocValues()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \n          \"Can't facet on a PointField without docValues\");\n    }\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    final FacetMethod requestedMethod;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      requestedMethod = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      requestedMethod = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      requestedMethod = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      requestedMethod = FacetMethod.UIF;\n    } else {\n      requestedMethod=null;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    FacetMethod appliedFacetMethod = selectFacetMethod(field,\n                                sf, requestedMethod, mincount,\n                                exists);\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"requestedMethod\", requestedMethod==null?\"not specified\":requestedMethod.name());\n       fdebug.putInfoItem(\"appliedMethod\", appliedFacetMethod.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, termFilter);\n    } else {\n      assert appliedFacetMethod != null;\n      switch (appliedFacetMethod) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, termFilter, exists);\n          break;\n        case FCS:\n          assert ft.isPointField() || !multiToken;\n          if (ft.isPointField() || (ft.getNumberType() != null && !sf.multiValued())) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (termFilter != null) {\n              final boolean supportedOperation = (termFilter instanceof SubstringBytesRefFilter) && ((SubstringBytesRefFilter) termFilter).substring().isEmpty();\n              if (!supportedOperation) {\n                throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_CONTAINS + \" is not supported on numeric types\");\n              }\n            }\n//            We should do this, but mincount=0 is currently the default\n//            if (ft.isPointField() && mincount <= 0) {\n//              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_MINCOUNT + \" <= 0 is not supported on point types\");\n//            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, termFilter);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(\"sort\", sortVal );\n\n            Map<String, Object> topLevel = new HashMap<>();\n            topLevel.put(field, jsonFacet);\n              \n            topLevel.put(\"processEmpty\", true);\n\n            FacetProcessor fproc = FacetProcessor.createProcessor(rb.req, topLevel, // rb.getResults().docSet\n                                                                    docs );\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n            fproc.process();\n\n            //Go through the response to build the expected output for SimpleFacets\n            Object res = fproc.getResponse();\n            counts = new NamedList<Integer>();\n            if(res != null) {\n              SimpleOrderedMap<Object> som = (SimpleOrderedMap<Object>)res;\n              SimpleOrderedMap<Object> asdf = (SimpleOrderedMap<Object>) som.get(field);\n\n              List<SimpleOrderedMap<Object>> buckets = (List<SimpleOrderedMap<Object>>)asdf.get(\"buckets\");\n              for(SimpleOrderedMap<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                SimpleOrderedMap<Object> missingCounts = (SimpleOrderedMap<Object>) asdf.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, termFilter, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"897b06b1364bd1f658a8be7591e43f0851458e7f","date":1487123008,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","sourceNew":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n\n    final Predicate<BytesRef> termFilter = newBytesRefFilter(field, params);\n\n    boolean exists = params.getFieldBool(field, FacetParams.FACET_EXISTS, false);\n    \n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    if (sf.getType().isPointField() && !sf.hasDocValues()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \n          \"Can't facet on a PointField without docValues\");\n    }\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    final FacetMethod requestedMethod;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      requestedMethod = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      requestedMethod = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      requestedMethod = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      requestedMethod = FacetMethod.UIF;\n    } else {\n      requestedMethod=null;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    FacetMethod appliedFacetMethod = selectFacetMethod(field,\n                                sf, requestedMethod, mincount,\n                                exists);\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"requestedMethod\", requestedMethod==null?\"not specified\":requestedMethod.name());\n       fdebug.putInfoItem(\"appliedMethod\", appliedFacetMethod.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, termFilter);\n    } else {\n      assert appliedFacetMethod != null;\n      switch (appliedFacetMethod) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, termFilter, exists);\n          break;\n        case FCS:\n          assert ft.isPointField() || !multiToken;\n          if (ft.isPointField() || (ft.getNumberType() != null && !sf.multiValued())) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (termFilter != null) {\n              final boolean supportedOperation = (termFilter instanceof SubstringBytesRefFilter) && ((SubstringBytesRefFilter) termFilter).substring().isEmpty();\n              if (!supportedOperation) {\n                throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_CONTAINS + \" is not supported on numeric types\");\n              }\n            }\n//            We should do this, but mincount=0 is currently the default\n//            if (ft.isPointField() && mincount <= 0) {\n//              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_MINCOUNT + \" <= 0 is not supported on point types\");\n//            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, termFilter);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(\"sort\", sortVal );\n\n            Map<String, Object> topLevel = new HashMap<>();\n            topLevel.put(field, jsonFacet);\n              \n            topLevel.put(\"processEmpty\", true);\n\n            FacetProcessor fproc = FacetProcessor.createProcessor(rb.req, topLevel, // rb.getResults().docSet\n                                                                    docs );\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n            fproc.process();\n\n            //Go through the response to build the expected output for SimpleFacets\n            Object res = fproc.getResponse();\n            counts = new NamedList<Integer>();\n            if(res != null) {\n              SimpleOrderedMap<Object> som = (SimpleOrderedMap<Object>)res;\n              SimpleOrderedMap<Object> asdf = (SimpleOrderedMap<Object>) som.get(field);\n\n              List<SimpleOrderedMap<Object>> buckets = (List<SimpleOrderedMap<Object>>)asdf.get(\"buckets\");\n              for(SimpleOrderedMap<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                SimpleOrderedMap<Object> missingCounts = (SimpleOrderedMap<Object>) asdf.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, termFilter, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n\n    final Predicate<BytesRef> termFilter = newBytesRefFilter(field, params);\n\n    boolean exists = params.getFieldBool(field, FacetParams.FACET_EXISTS, false);\n    \n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    if (sf.getType().isPointField() && !sf.hasDocValues()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \n          \"Can't facet on a PointField without docValues\");\n    }\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    final FacetMethod requestedMethod;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      requestedMethod = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      requestedMethod = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      requestedMethod = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      requestedMethod = FacetMethod.UIF;\n    } else {\n      requestedMethod=null;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    FacetMethod appliedFacetMethod = selectFacetMethod(field,\n                                sf, requestedMethod, mincount,\n                                exists);\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"requestedMethod\", requestedMethod==null?\"not specified\":requestedMethod.name());\n       fdebug.putInfoItem(\"appliedMethod\", appliedFacetMethod.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, termFilter);\n    } else {\n      assert appliedFacetMethod != null;\n      switch (appliedFacetMethod) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, termFilter, exists);\n          break;\n        case FCS:\n          assert !multiToken;\n          if (ft.getNumberType() != null && !sf.multiValued()) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (termFilter != null) {\n              final boolean supportedOperation = (termFilter instanceof SubstringBytesRefFilter) && ((SubstringBytesRefFilter) termFilter).substring().isEmpty();\n              if (!supportedOperation) {\n                throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_CONTAINS + \" is not supported on numeric types\");\n              }\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, termFilter);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(\"sort\", sortVal );\n\n            Map<String, Object> topLevel = new HashMap<>();\n            topLevel.put(field, jsonFacet);\n              \n            topLevel.put(\"processEmpty\", true);\n\n            FacetProcessor fproc = FacetProcessor.createProcessor(rb.req, topLevel, // rb.getResults().docSet\n                                                                    docs );\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n            fproc.process();\n\n            //Go through the response to build the expected output for SimpleFacets\n            Object res = fproc.getResponse();\n            counts = new NamedList<Integer>();\n            if(res != null) {\n              SimpleOrderedMap<Object> som = (SimpleOrderedMap<Object>)res;\n              SimpleOrderedMap<Object> asdf = (SimpleOrderedMap<Object>) som.get(field);\n\n              List<SimpleOrderedMap<Object>> buckets = (List<SimpleOrderedMap<Object>>)asdf.get(\"buckets\");\n              for(SimpleOrderedMap<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                SimpleOrderedMap<Object> missingCounts = (SimpleOrderedMap<Object>) asdf.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, termFilter, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1c1d8a5912a6d0e6639e4720a9dc63d048ade073","date":1488542621,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","sourceNew":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n\n    final Predicate<BytesRef> termFilter = newBytesRefFilter(field, params);\n\n    boolean exists = params.getFieldBool(field, FacetParams.FACET_EXISTS, false);\n    \n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    if (sf.getType().isPointField() && !sf.hasDocValues()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \n          \"Can't facet on a PointField without docValues\");\n    }\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    final FacetMethod requestedMethod;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      requestedMethod = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      requestedMethod = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      requestedMethod = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      requestedMethod = FacetMethod.UIF;\n    } else {\n      requestedMethod=null;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    FacetMethod appliedFacetMethod = selectFacetMethod(field,\n                                sf, requestedMethod, mincount,\n                                exists);\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"requestedMethod\", requestedMethod==null?\"not specified\":requestedMethod.name());\n       fdebug.putInfoItem(\"appliedMethod\", appliedFacetMethod.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, termFilter);\n    } else {\n      assert appliedFacetMethod != null;\n      switch (appliedFacetMethod) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, termFilter, exists);\n          break;\n        case FCS:\n          assert ft.isPointField() || !multiToken;\n          if (ft.isPointField() || (ft.getNumberType() != null && !sf.multiValued())) {\n            if (prefix != null) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (termFilter != null) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, \"BytesRef term filters (\"\n                      + FacetParams.FACET_CONTAINS + \", \"\n                      + FacetParams.FACET_EXCLUDETERMS + \") are not supported on numeric types\");\n            }\n//            We should do this, but mincount=0 is currently the default\n//            if (ft.isPointField() && mincount <= 0) {\n//              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_MINCOUNT + \" <= 0 is not supported on point types\");\n//            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, termFilter);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(\"sort\", sortVal );\n\n            Map<String, Object> topLevel = new HashMap<>();\n            topLevel.put(field, jsonFacet);\n              \n            topLevel.put(\"processEmpty\", true);\n\n            FacetProcessor fproc = FacetProcessor.createProcessor(rb.req, topLevel, // rb.getResults().docSet\n                                                                    docs );\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n            fproc.process();\n\n            //Go through the response to build the expected output for SimpleFacets\n            Object res = fproc.getResponse();\n            counts = new NamedList<Integer>();\n            if(res != null) {\n              SimpleOrderedMap<Object> som = (SimpleOrderedMap<Object>)res;\n              SimpleOrderedMap<Object> asdf = (SimpleOrderedMap<Object>) som.get(field);\n\n              List<SimpleOrderedMap<Object>> buckets = (List<SimpleOrderedMap<Object>>)asdf.get(\"buckets\");\n              for(SimpleOrderedMap<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                SimpleOrderedMap<Object> missingCounts = (SimpleOrderedMap<Object>) asdf.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, termFilter, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n\n    final Predicate<BytesRef> termFilter = newBytesRefFilter(field, params);\n\n    boolean exists = params.getFieldBool(field, FacetParams.FACET_EXISTS, false);\n    \n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    if (sf.getType().isPointField() && !sf.hasDocValues()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \n          \"Can't facet on a PointField without docValues\");\n    }\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    final FacetMethod requestedMethod;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      requestedMethod = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      requestedMethod = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      requestedMethod = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      requestedMethod = FacetMethod.UIF;\n    } else {\n      requestedMethod=null;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    FacetMethod appliedFacetMethod = selectFacetMethod(field,\n                                sf, requestedMethod, mincount,\n                                exists);\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"requestedMethod\", requestedMethod==null?\"not specified\":requestedMethod.name());\n       fdebug.putInfoItem(\"appliedMethod\", appliedFacetMethod.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, termFilter);\n    } else {\n      assert appliedFacetMethod != null;\n      switch (appliedFacetMethod) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, termFilter, exists);\n          break;\n        case FCS:\n          assert ft.isPointField() || !multiToken;\n          if (ft.isPointField() || (ft.getNumberType() != null && !sf.multiValued())) {\n            // force numeric faceting\n            if (prefix != null && !prefix.isEmpty()) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (termFilter != null) {\n              final boolean supportedOperation = (termFilter instanceof SubstringBytesRefFilter) && ((SubstringBytesRefFilter) termFilter).substring().isEmpty();\n              if (!supportedOperation) {\n                throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_CONTAINS + \" is not supported on numeric types\");\n              }\n            }\n//            We should do this, but mincount=0 is currently the default\n//            if (ft.isPointField() && mincount <= 0) {\n//              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_MINCOUNT + \" <= 0 is not supported on point types\");\n//            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, termFilter);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(\"sort\", sortVal );\n\n            Map<String, Object> topLevel = new HashMap<>();\n            topLevel.put(field, jsonFacet);\n              \n            topLevel.put(\"processEmpty\", true);\n\n            FacetProcessor fproc = FacetProcessor.createProcessor(rb.req, topLevel, // rb.getResults().docSet\n                                                                    docs );\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n            fproc.process();\n\n            //Go through the response to build the expected output for SimpleFacets\n            Object res = fproc.getResponse();\n            counts = new NamedList<Integer>();\n            if(res != null) {\n              SimpleOrderedMap<Object> som = (SimpleOrderedMap<Object>)res;\n              SimpleOrderedMap<Object> asdf = (SimpleOrderedMap<Object>) som.get(field);\n\n              List<SimpleOrderedMap<Object>> buckets = (List<SimpleOrderedMap<Object>>)asdf.get(\"buckets\");\n              for(SimpleOrderedMap<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                SimpleOrderedMap<Object> missingCounts = (SimpleOrderedMap<Object>) asdf.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, termFilter, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"01624b85de12fb02335810bdf325124e59040772","date":1490254940,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","sourceNew":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n\n    final Predicate<BytesRef> termFilter = newBytesRefFilter(field, params);\n\n    boolean exists = params.getFieldBool(field, FacetParams.FACET_EXISTS, false);\n    \n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    if (sf.getType().isPointField() && !sf.hasDocValues()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \n          \"Can't facet on a PointField without docValues\");\n    }\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    final FacetMethod requestedMethod;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      requestedMethod = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      requestedMethod = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      requestedMethod = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      requestedMethod = FacetMethod.UIF;\n    } else {\n      requestedMethod=null;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    FacetMethod appliedFacetMethod = selectFacetMethod(field,\n                                sf, requestedMethod, mincount,\n                                exists);\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"requestedMethod\", requestedMethod==null?\"not specified\":requestedMethod.name());\n       fdebug.putInfoItem(\"appliedMethod\", appliedFacetMethod.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, termFilter);\n    } else {\n      assert appliedFacetMethod != null;\n      switch (appliedFacetMethod) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, termFilter, exists);\n          break;\n        case FCS:\n          assert ft.isPointField() || !multiToken;\n          if (ft.isPointField() || (ft.getNumberType() != null && !sf.multiValued())) {\n            if (prefix != null) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (termFilter != null) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, \"BytesRef term filters (\"\n                      + FacetParams.FACET_CONTAINS + \", \"\n                      + FacetParams.FACET_EXCLUDETERMS + \") are not supported on numeric types\");\n            }\n//            We should do this, but mincount=0 is currently the default\n//            if (ft.isPointField() && mincount <= 0) {\n//              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_MINCOUNT + \" <= 0 is not supported on point types\");\n//            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, termFilter);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(SORT, sortVal );\n\n            Map<String, Object> topLevel = new HashMap<>();\n            topLevel.put(field, jsonFacet);\n              \n            topLevel.put(\"processEmpty\", true);\n\n            FacetProcessor fproc = FacetProcessor.createProcessor(rb.req, topLevel, // rb.getResults().docSet\n                                                                    docs );\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n            fproc.process();\n\n            //Go through the response to build the expected output for SimpleFacets\n            Object res = fproc.getResponse();\n            counts = new NamedList<Integer>();\n            if(res != null) {\n              SimpleOrderedMap<Object> som = (SimpleOrderedMap<Object>)res;\n              SimpleOrderedMap<Object> asdf = (SimpleOrderedMap<Object>) som.get(field);\n\n              List<SimpleOrderedMap<Object>> buckets = (List<SimpleOrderedMap<Object>>)asdf.get(\"buckets\");\n              for(SimpleOrderedMap<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                SimpleOrderedMap<Object> missingCounts = (SimpleOrderedMap<Object>) asdf.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, termFilter, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n\n    final Predicate<BytesRef> termFilter = newBytesRefFilter(field, params);\n\n    boolean exists = params.getFieldBool(field, FacetParams.FACET_EXISTS, false);\n    \n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    if (sf.getType().isPointField() && !sf.hasDocValues()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \n          \"Can't facet on a PointField without docValues\");\n    }\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    final FacetMethod requestedMethod;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      requestedMethod = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      requestedMethod = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      requestedMethod = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      requestedMethod = FacetMethod.UIF;\n    } else {\n      requestedMethod=null;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    FacetMethod appliedFacetMethod = selectFacetMethod(field,\n                                sf, requestedMethod, mincount,\n                                exists);\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"requestedMethod\", requestedMethod==null?\"not specified\":requestedMethod.name());\n       fdebug.putInfoItem(\"appliedMethod\", appliedFacetMethod.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, termFilter);\n    } else {\n      assert appliedFacetMethod != null;\n      switch (appliedFacetMethod) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, termFilter, exists);\n          break;\n        case FCS:\n          assert ft.isPointField() || !multiToken;\n          if (ft.isPointField() || (ft.getNumberType() != null && !sf.multiValued())) {\n            if (prefix != null) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (termFilter != null) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, \"BytesRef term filters (\"\n                      + FacetParams.FACET_CONTAINS + \", \"\n                      + FacetParams.FACET_EXCLUDETERMS + \") are not supported on numeric types\");\n            }\n//            We should do this, but mincount=0 is currently the default\n//            if (ft.isPointField() && mincount <= 0) {\n//              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_MINCOUNT + \" <= 0 is not supported on point types\");\n//            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, termFilter);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(\"sort\", sortVal );\n\n            Map<String, Object> topLevel = new HashMap<>();\n            topLevel.put(field, jsonFacet);\n              \n            topLevel.put(\"processEmpty\", true);\n\n            FacetProcessor fproc = FacetProcessor.createProcessor(rb.req, topLevel, // rb.getResults().docSet\n                                                                    docs );\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n            fproc.process();\n\n            //Go through the response to build the expected output for SimpleFacets\n            Object res = fproc.getResponse();\n            counts = new NamedList<Integer>();\n            if(res != null) {\n              SimpleOrderedMap<Object> som = (SimpleOrderedMap<Object>)res;\n              SimpleOrderedMap<Object> asdf = (SimpleOrderedMap<Object>) som.get(field);\n\n              List<SimpleOrderedMap<Object>> buckets = (List<SimpleOrderedMap<Object>>)asdf.get(\"buckets\");\n              for(SimpleOrderedMap<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                SimpleOrderedMap<Object> missingCounts = (SimpleOrderedMap<Object>) asdf.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, termFilter, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6f4c5d3859373c3a74734e85efa122b17514e3e8","date":1490280013,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","sourceNew":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n\n    final Predicate<BytesRef> termFilter = newBytesRefFilter(field, params);\n\n    boolean exists = params.getFieldBool(field, FacetParams.FACET_EXISTS, false);\n    \n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    if (sf.getType().isPointField() && !sf.hasDocValues()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \n          \"Can't facet on a PointField without docValues\");\n    }\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    final FacetMethod requestedMethod;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      requestedMethod = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      requestedMethod = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      requestedMethod = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      requestedMethod = FacetMethod.UIF;\n    } else {\n      requestedMethod=null;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    FacetMethod appliedFacetMethod = selectFacetMethod(field,\n                                sf, requestedMethod, mincount,\n                                exists);\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"requestedMethod\", requestedMethod==null?\"not specified\":requestedMethod.name());\n       fdebug.putInfoItem(\"appliedMethod\", appliedFacetMethod.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, termFilter);\n    } else {\n      assert appliedFacetMethod != null;\n      switch (appliedFacetMethod) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, termFilter, exists);\n          break;\n        case FCS:\n          assert ft.isPointField() || !multiToken;\n          if (ft.isPointField() || (ft.getNumberType() != null && !sf.multiValued())) {\n            if (prefix != null) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (termFilter != null) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, \"BytesRef term filters (\"\n                      + FacetParams.FACET_CONTAINS + \", \"\n                      + FacetParams.FACET_EXCLUDETERMS + \") are not supported on numeric types\");\n            }\n//            We should do this, but mincount=0 is currently the default\n//            if (ft.isPointField() && mincount <= 0) {\n//              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_MINCOUNT + \" <= 0 is not supported on point types\");\n//            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, termFilter);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(SORT, sortVal );\n\n            Map<String, Object> topLevel = new HashMap<>();\n            topLevel.put(field, jsonFacet);\n              \n            topLevel.put(\"processEmpty\", true);\n\n            FacetProcessor fproc = FacetProcessor.createProcessor(rb.req, topLevel, // rb.getResults().docSet\n                                                                    docs );\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n            fproc.process();\n\n            //Go through the response to build the expected output for SimpleFacets\n            Object res = fproc.getResponse();\n            counts = new NamedList<Integer>();\n            if(res != null) {\n              SimpleOrderedMap<Object> som = (SimpleOrderedMap<Object>)res;\n              SimpleOrderedMap<Object> asdf = (SimpleOrderedMap<Object>) som.get(field);\n\n              List<SimpleOrderedMap<Object>> buckets = (List<SimpleOrderedMap<Object>>)asdf.get(\"buckets\");\n              for(SimpleOrderedMap<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                SimpleOrderedMap<Object> missingCounts = (SimpleOrderedMap<Object>) asdf.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, termFilter, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n\n    final Predicate<BytesRef> termFilter = newBytesRefFilter(field, params);\n\n    boolean exists = params.getFieldBool(field, FacetParams.FACET_EXISTS, false);\n    \n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    if (sf.getType().isPointField() && !sf.hasDocValues()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \n          \"Can't facet on a PointField without docValues\");\n    }\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    final FacetMethod requestedMethod;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      requestedMethod = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      requestedMethod = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      requestedMethod = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      requestedMethod = FacetMethod.UIF;\n    } else {\n      requestedMethod=null;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    FacetMethod appliedFacetMethod = selectFacetMethod(field,\n                                sf, requestedMethod, mincount,\n                                exists);\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"requestedMethod\", requestedMethod==null?\"not specified\":requestedMethod.name());\n       fdebug.putInfoItem(\"appliedMethod\", appliedFacetMethod.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, termFilter);\n    } else {\n      assert appliedFacetMethod != null;\n      switch (appliedFacetMethod) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, termFilter, exists);\n          break;\n        case FCS:\n          assert ft.isPointField() || !multiToken;\n          if (ft.isPointField() || (ft.getNumberType() != null && !sf.multiValued())) {\n            if (prefix != null) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (termFilter != null) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, \"BytesRef term filters (\"\n                      + FacetParams.FACET_CONTAINS + \", \"\n                      + FacetParams.FACET_EXCLUDETERMS + \") are not supported on numeric types\");\n            }\n//            We should do this, but mincount=0 is currently the default\n//            if (ft.isPointField() && mincount <= 0) {\n//              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_MINCOUNT + \" <= 0 is not supported on point types\");\n//            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, termFilter);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(\"sort\", sortVal );\n\n            Map<String, Object> topLevel = new HashMap<>();\n            topLevel.put(field, jsonFacet);\n              \n            topLevel.put(\"processEmpty\", true);\n\n            FacetProcessor fproc = FacetProcessor.createProcessor(rb.req, topLevel, // rb.getResults().docSet\n                                                                    docs );\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n            fproc.process();\n\n            //Go through the response to build the expected output for SimpleFacets\n            Object res = fproc.getResponse();\n            counts = new NamedList<Integer>();\n            if(res != null) {\n              SimpleOrderedMap<Object> som = (SimpleOrderedMap<Object>)res;\n              SimpleOrderedMap<Object> asdf = (SimpleOrderedMap<Object>) som.get(field);\n\n              List<SimpleOrderedMap<Object>> buckets = (List<SimpleOrderedMap<Object>>)asdf.get(\"buckets\");\n              for(SimpleOrderedMap<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                SimpleOrderedMap<Object> missingCounts = (SimpleOrderedMap<Object>) asdf.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, termFilter, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"36294de1b3009c52225da73c7d7e5ad8cf7ab100","date":1501615974,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","sourceNew":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n\n    final Predicate<BytesRef> termFilter = newBytesRefFilter(field, params);\n\n    boolean exists = params.getFieldBool(field, FacetParams.FACET_EXISTS, false);\n    \n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    if (sf.getType().isPointField() && !sf.hasDocValues()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \n          \"Can't facet on a PointField without docValues\");\n    }\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    final FacetMethod requestedMethod;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      requestedMethod = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      requestedMethod = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      requestedMethod = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      requestedMethod = FacetMethod.UIF;\n    } else {\n      requestedMethod=null;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    FacetMethod appliedFacetMethod = selectFacetMethod(field,\n                                sf, requestedMethod, mincount,\n                                exists);\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"requestedMethod\", requestedMethod==null?\"not specified\":requestedMethod.name());\n       fdebug.putInfoItem(\"appliedMethod\", appliedFacetMethod.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, termFilter);\n    } else {\n      assert appliedFacetMethod != null;\n      switch (appliedFacetMethod) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, termFilter, exists);\n          break;\n        case FCS:\n          assert ft.isPointField() || !multiToken;\n          if (ft.isPointField() || (ft.getNumberType() != null && !sf.multiValued())) {\n            if (prefix != null) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (termFilter != null) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, \"BytesRef term filters (\"\n                      + FacetParams.FACET_CONTAINS + \", \"\n                      + FacetParams.FACET_EXCLUDETERMS + \") are not supported on numeric types\");\n            }\n            if (ft.isPointField() && mincount <= 0) { // default is mincount=0.  See SOLR-10033 & SOLR-11174.\n              LOG.warn(\"Raising facet.mincount from \" + mincount + \" to 1, because field \" + field + \" is Points-based.\");\n              mincount = 1;\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, termFilter);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(SORT, sortVal );\n\n            Map<String, Object> topLevel = new HashMap<>();\n            topLevel.put(field, jsonFacet);\n              \n            topLevel.put(\"processEmpty\", true);\n\n            FacetProcessor fproc = FacetProcessor.createProcessor(rb.req, topLevel, // rb.getResults().docSet\n                                                                    docs );\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n            fproc.process();\n\n            //Go through the response to build the expected output for SimpleFacets\n            Object res = fproc.getResponse();\n            counts = new NamedList<Integer>();\n            if(res != null) {\n              SimpleOrderedMap<Object> som = (SimpleOrderedMap<Object>)res;\n              SimpleOrderedMap<Object> asdf = (SimpleOrderedMap<Object>) som.get(field);\n\n              List<SimpleOrderedMap<Object>> buckets = (List<SimpleOrderedMap<Object>>)asdf.get(\"buckets\");\n              for(SimpleOrderedMap<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                SimpleOrderedMap<Object> missingCounts = (SimpleOrderedMap<Object>) asdf.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, termFilter, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n\n    final Predicate<BytesRef> termFilter = newBytesRefFilter(field, params);\n\n    boolean exists = params.getFieldBool(field, FacetParams.FACET_EXISTS, false);\n    \n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    if (sf.getType().isPointField() && !sf.hasDocValues()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \n          \"Can't facet on a PointField without docValues\");\n    }\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    final FacetMethod requestedMethod;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      requestedMethod = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      requestedMethod = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      requestedMethod = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      requestedMethod = FacetMethod.UIF;\n    } else {\n      requestedMethod=null;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    FacetMethod appliedFacetMethod = selectFacetMethod(field,\n                                sf, requestedMethod, mincount,\n                                exists);\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"requestedMethod\", requestedMethod==null?\"not specified\":requestedMethod.name());\n       fdebug.putInfoItem(\"appliedMethod\", appliedFacetMethod.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, termFilter);\n    } else {\n      assert appliedFacetMethod != null;\n      switch (appliedFacetMethod) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, termFilter, exists);\n          break;\n        case FCS:\n          assert ft.isPointField() || !multiToken;\n          if (ft.isPointField() || (ft.getNumberType() != null && !sf.multiValued())) {\n            if (prefix != null) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (termFilter != null) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, \"BytesRef term filters (\"\n                      + FacetParams.FACET_CONTAINS + \", \"\n                      + FacetParams.FACET_EXCLUDETERMS + \") are not supported on numeric types\");\n            }\n//            We should do this, but mincount=0 is currently the default\n//            if (ft.isPointField() && mincount <= 0) {\n//              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_MINCOUNT + \" <= 0 is not supported on point types\");\n//            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, termFilter);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(SORT, sortVal );\n\n            Map<String, Object> topLevel = new HashMap<>();\n            topLevel.put(field, jsonFacet);\n              \n            topLevel.put(\"processEmpty\", true);\n\n            FacetProcessor fproc = FacetProcessor.createProcessor(rb.req, topLevel, // rb.getResults().docSet\n                                                                    docs );\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n            fproc.process();\n\n            //Go through the response to build the expected output for SimpleFacets\n            Object res = fproc.getResponse();\n            counts = new NamedList<Integer>();\n            if(res != null) {\n              SimpleOrderedMap<Object> som = (SimpleOrderedMap<Object>)res;\n              SimpleOrderedMap<Object> asdf = (SimpleOrderedMap<Object>) som.get(field);\n\n              List<SimpleOrderedMap<Object>> buckets = (List<SimpleOrderedMap<Object>>)asdf.get(\"buckets\");\n              for(SimpleOrderedMap<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                SimpleOrderedMap<Object> missingCounts = (SimpleOrderedMap<Object>) asdf.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, termFilter, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ebff2e24a6d2f84582ff6315d8d377380941b23e","date":1501630388,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","sourceNew":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n\n    final Predicate<BytesRef> termFilter = newBytesRefFilter(field, params);\n\n    boolean exists = params.getFieldBool(field, FacetParams.FACET_EXISTS, false);\n    \n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    if (sf.getType().isPointField() && !sf.hasDocValues()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \n          \"Can't facet on a PointField without docValues\");\n    }\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    final FacetMethod requestedMethod;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      requestedMethod = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      requestedMethod = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      requestedMethod = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      requestedMethod = FacetMethod.UIF;\n    } else {\n      requestedMethod=null;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    FacetMethod appliedFacetMethod = selectFacetMethod(field,\n                                sf, requestedMethod, mincount,\n                                exists);\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"requestedMethod\", requestedMethod==null?\"not specified\":requestedMethod.name());\n       fdebug.putInfoItem(\"appliedMethod\", appliedFacetMethod.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, termFilter);\n    } else {\n      assert appliedFacetMethod != null;\n      switch (appliedFacetMethod) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, termFilter, exists);\n          break;\n        case FCS:\n          assert ft.isPointField() || !multiToken;\n          if (ft.isPointField() || (ft.getNumberType() != null && !sf.multiValued())) {\n            if (prefix != null) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (termFilter != null) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, \"BytesRef term filters (\"\n                      + FacetParams.FACET_CONTAINS + \", \"\n                      + FacetParams.FACET_EXCLUDETERMS + \") are not supported on numeric types\");\n            }\n            if (ft.isPointField() && mincount <= 0) { // default is mincount=0.  See SOLR-10033 & SOLR-11174.\n              String warningMessage \n                  = \"Raising facet.mincount from \" + mincount + \" to 1, because field \" + field + \" is Points-based.\";\n              LOG.warn(warningMessage);\n              List<String> warnings = (List<String>)rb.rsp.getResponseHeader().get(\"warnings\");\n              if (null == warnings) {\n                warnings = new ArrayList<>();\n                rb.rsp.getResponseHeader().add(\"warnings\", warnings);\n              }\n              warnings.add(warningMessage);\n\n              mincount = 1;\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, termFilter);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(SORT, sortVal );\n\n            Map<String, Object> topLevel = new HashMap<>();\n            topLevel.put(field, jsonFacet);\n              \n            topLevel.put(\"processEmpty\", true);\n\n            FacetProcessor fproc = FacetProcessor.createProcessor(rb.req, topLevel, // rb.getResults().docSet\n                                                                    docs );\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n            fproc.process();\n\n            //Go through the response to build the expected output for SimpleFacets\n            Object res = fproc.getResponse();\n            counts = new NamedList<Integer>();\n            if(res != null) {\n              SimpleOrderedMap<Object> som = (SimpleOrderedMap<Object>)res;\n              SimpleOrderedMap<Object> asdf = (SimpleOrderedMap<Object>) som.get(field);\n\n              List<SimpleOrderedMap<Object>> buckets = (List<SimpleOrderedMap<Object>>)asdf.get(\"buckets\");\n              for(SimpleOrderedMap<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                SimpleOrderedMap<Object> missingCounts = (SimpleOrderedMap<Object>) asdf.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, termFilter, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n\n    final Predicate<BytesRef> termFilter = newBytesRefFilter(field, params);\n\n    boolean exists = params.getFieldBool(field, FacetParams.FACET_EXISTS, false);\n    \n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    if (sf.getType().isPointField() && !sf.hasDocValues()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \n          \"Can't facet on a PointField without docValues\");\n    }\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    final FacetMethod requestedMethod;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      requestedMethod = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      requestedMethod = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      requestedMethod = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      requestedMethod = FacetMethod.UIF;\n    } else {\n      requestedMethod=null;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    FacetMethod appliedFacetMethod = selectFacetMethod(field,\n                                sf, requestedMethod, mincount,\n                                exists);\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"requestedMethod\", requestedMethod==null?\"not specified\":requestedMethod.name());\n       fdebug.putInfoItem(\"appliedMethod\", appliedFacetMethod.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, termFilter);\n    } else {\n      assert appliedFacetMethod != null;\n      switch (appliedFacetMethod) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, termFilter, exists);\n          break;\n        case FCS:\n          assert ft.isPointField() || !multiToken;\n          if (ft.isPointField() || (ft.getNumberType() != null && !sf.multiValued())) {\n            if (prefix != null) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (termFilter != null) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, \"BytesRef term filters (\"\n                      + FacetParams.FACET_CONTAINS + \", \"\n                      + FacetParams.FACET_EXCLUDETERMS + \") are not supported on numeric types\");\n            }\n            if (ft.isPointField() && mincount <= 0) { // default is mincount=0.  See SOLR-10033 & SOLR-11174.\n              LOG.warn(\"Raising facet.mincount from \" + mincount + \" to 1, because field \" + field + \" is Points-based.\");\n              mincount = 1;\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, termFilter);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(SORT, sortVal );\n\n            Map<String, Object> topLevel = new HashMap<>();\n            topLevel.put(field, jsonFacet);\n              \n            topLevel.put(\"processEmpty\", true);\n\n            FacetProcessor fproc = FacetProcessor.createProcessor(rb.req, topLevel, // rb.getResults().docSet\n                                                                    docs );\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n            fproc.process();\n\n            //Go through the response to build the expected output for SimpleFacets\n            Object res = fproc.getResponse();\n            counts = new NamedList<Integer>();\n            if(res != null) {\n              SimpleOrderedMap<Object> som = (SimpleOrderedMap<Object>)res;\n              SimpleOrderedMap<Object> asdf = (SimpleOrderedMap<Object>) som.get(field);\n\n              List<SimpleOrderedMap<Object>> buckets = (List<SimpleOrderedMap<Object>>)asdf.get(\"buckets\");\n              for(SimpleOrderedMap<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                SimpleOrderedMap<Object> missingCounts = (SimpleOrderedMap<Object>) asdf.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, termFilter, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","date":1502192746,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","sourceNew":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n\n    final Predicate<BytesRef> termFilter = newBytesRefFilter(field, params);\n\n    boolean exists = params.getFieldBool(field, FacetParams.FACET_EXISTS, false);\n    \n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    if (sf.getType().isPointField() && !sf.hasDocValues()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \n          \"Can't facet on a PointField without docValues\");\n    }\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    final FacetMethod requestedMethod;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      requestedMethod = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      requestedMethod = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      requestedMethod = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      requestedMethod = FacetMethod.UIF;\n    } else {\n      requestedMethod=null;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    FacetMethod appliedFacetMethod = selectFacetMethod(field,\n                                sf, requestedMethod, mincount,\n                                exists);\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"requestedMethod\", requestedMethod==null?\"not specified\":requestedMethod.name());\n       fdebug.putInfoItem(\"appliedMethod\", appliedFacetMethod.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, termFilter);\n    } else {\n      assert appliedFacetMethod != null;\n      switch (appliedFacetMethod) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, termFilter, exists);\n          break;\n        case FCS:\n          assert ft.isPointField() || !multiToken;\n          if (ft.isPointField() || (ft.getNumberType() != null && !sf.multiValued())) {\n            if (prefix != null) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (termFilter != null) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, \"BytesRef term filters (\"\n                      + FacetParams.FACET_CONTAINS + \", \"\n                      + FacetParams.FACET_EXCLUDETERMS + \") are not supported on numeric types\");\n            }\n            if (ft.isPointField() && mincount <= 0) { // default is mincount=0.  See SOLR-10033 & SOLR-11174.\n              String warningMessage \n                  = \"Raising facet.mincount from \" + mincount + \" to 1, because field \" + field + \" is Points-based.\";\n              LOG.warn(warningMessage);\n              List<String> warnings = (List<String>)rb.rsp.getResponseHeader().get(\"warnings\");\n              if (null == warnings) {\n                warnings = new ArrayList<>();\n                rb.rsp.getResponseHeader().add(\"warnings\", warnings);\n              }\n              warnings.add(warningMessage);\n\n              mincount = 1;\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, termFilter);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(SORT, sortVal );\n\n            Map<String, Object> topLevel = new HashMap<>();\n            topLevel.put(field, jsonFacet);\n              \n            topLevel.put(\"processEmpty\", true);\n\n            FacetProcessor fproc = FacetProcessor.createProcessor(rb.req, topLevel, // rb.getResults().docSet\n                                                                    docs );\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n            fproc.process();\n\n            //Go through the response to build the expected output for SimpleFacets\n            Object res = fproc.getResponse();\n            counts = new NamedList<Integer>();\n            if(res != null) {\n              SimpleOrderedMap<Object> som = (SimpleOrderedMap<Object>)res;\n              SimpleOrderedMap<Object> asdf = (SimpleOrderedMap<Object>) som.get(field);\n\n              List<SimpleOrderedMap<Object>> buckets = (List<SimpleOrderedMap<Object>>)asdf.get(\"buckets\");\n              for(SimpleOrderedMap<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                SimpleOrderedMap<Object> missingCounts = (SimpleOrderedMap<Object>) asdf.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, termFilter, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n\n    final Predicate<BytesRef> termFilter = newBytesRefFilter(field, params);\n\n    boolean exists = params.getFieldBool(field, FacetParams.FACET_EXISTS, false);\n    \n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    if (sf.getType().isPointField() && !sf.hasDocValues()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \n          \"Can't facet on a PointField without docValues\");\n    }\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    final FacetMethod requestedMethod;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      requestedMethod = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      requestedMethod = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      requestedMethod = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      requestedMethod = FacetMethod.UIF;\n    } else {\n      requestedMethod=null;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    FacetMethod appliedFacetMethod = selectFacetMethod(field,\n                                sf, requestedMethod, mincount,\n                                exists);\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"requestedMethod\", requestedMethod==null?\"not specified\":requestedMethod.name());\n       fdebug.putInfoItem(\"appliedMethod\", appliedFacetMethod.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, termFilter);\n    } else {\n      assert appliedFacetMethod != null;\n      switch (appliedFacetMethod) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, termFilter, exists);\n          break;\n        case FCS:\n          assert ft.isPointField() || !multiToken;\n          if (ft.isPointField() || (ft.getNumberType() != null && !sf.multiValued())) {\n            if (prefix != null) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (termFilter != null) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, \"BytesRef term filters (\"\n                      + FacetParams.FACET_CONTAINS + \", \"\n                      + FacetParams.FACET_EXCLUDETERMS + \") are not supported on numeric types\");\n            }\n//            We should do this, but mincount=0 is currently the default\n//            if (ft.isPointField() && mincount <= 0) {\n//              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_MINCOUNT + \" <= 0 is not supported on point types\");\n//            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, termFilter);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(SORT, sortVal );\n\n            Map<String, Object> topLevel = new HashMap<>();\n            topLevel.put(field, jsonFacet);\n              \n            topLevel.put(\"processEmpty\", true);\n\n            FacetProcessor fproc = FacetProcessor.createProcessor(rb.req, topLevel, // rb.getResults().docSet\n                                                                    docs );\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n            fproc.process();\n\n            //Go through the response to build the expected output for SimpleFacets\n            Object res = fproc.getResponse();\n            counts = new NamedList<Integer>();\n            if(res != null) {\n              SimpleOrderedMap<Object> som = (SimpleOrderedMap<Object>)res;\n              SimpleOrderedMap<Object> asdf = (SimpleOrderedMap<Object>) som.get(field);\n\n              List<SimpleOrderedMap<Object>> buckets = (List<SimpleOrderedMap<Object>>)asdf.get(\"buckets\");\n              for(SimpleOrderedMap<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                SimpleOrderedMap<Object> missingCounts = (SimpleOrderedMap<Object>) asdf.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, termFilter, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f59e5a034782f8d1b0eec0ec9a74be9b713764f4","date":1509386605,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","sourceNew":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n\n    final Predicate<BytesRef> termFilter = newBytesRefFilter(field, params);\n\n    boolean exists = params.getFieldBool(field, FacetParams.FACET_EXISTS, false);\n    \n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    if (sf.getType().isPointField() && !sf.hasDocValues()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \n          \"Can't facet on a PointField without docValues\");\n    }\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    final FacetMethod requestedMethod;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      requestedMethod = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      requestedMethod = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      requestedMethod = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      requestedMethod = FacetMethod.UIF;\n    } else {\n      requestedMethod=null;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    FacetMethod appliedFacetMethod = selectFacetMethod(field,\n                                sf, requestedMethod, mincount,\n                                exists);\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"requestedMethod\", requestedMethod==null?\"not specified\":requestedMethod.name());\n       fdebug.putInfoItem(\"appliedMethod\", appliedFacetMethod.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, termFilter);\n    } else {\n      assert appliedFacetMethod != null;\n      switch (appliedFacetMethod) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, termFilter, exists);\n          break;\n        case FCS:\n          assert ft.isPointField() || !multiToken;\n          if (ft.isPointField() || (ft.getNumberType() != null && !sf.multiValued())) {\n            if (prefix != null) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (termFilter != null) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, \"BytesRef term filters (\"\n                      + FacetParams.FACET_MATCHES + \", \"\n                      + FacetParams.FACET_CONTAINS + \", \"\n                      + FacetParams.FACET_EXCLUDETERMS + \") are not supported on numeric types\");\n            }\n            if (ft.isPointField() && mincount <= 0) { // default is mincount=0.  See SOLR-10033 & SOLR-11174.\n              String warningMessage \n                  = \"Raising facet.mincount from \" + mincount + \" to 1, because field \" + field + \" is Points-based.\";\n              LOG.warn(warningMessage);\n              List<String> warnings = (List<String>)rb.rsp.getResponseHeader().get(\"warnings\");\n              if (null == warnings) {\n                warnings = new ArrayList<>();\n                rb.rsp.getResponseHeader().add(\"warnings\", warnings);\n              }\n              warnings.add(warningMessage);\n\n              mincount = 1;\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, termFilter);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(SORT, sortVal );\n\n            Map<String, Object> topLevel = new HashMap<>();\n            topLevel.put(field, jsonFacet);\n              \n            topLevel.put(\"processEmpty\", true);\n\n            FacetProcessor fproc = FacetProcessor.createProcessor(rb.req, topLevel, // rb.getResults().docSet\n                                                                    docs );\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n            fproc.process();\n\n            //Go through the response to build the expected output for SimpleFacets\n            Object res = fproc.getResponse();\n            counts = new NamedList<Integer>();\n            if(res != null) {\n              SimpleOrderedMap<Object> som = (SimpleOrderedMap<Object>)res;\n              SimpleOrderedMap<Object> asdf = (SimpleOrderedMap<Object>) som.get(field);\n\n              List<SimpleOrderedMap<Object>> buckets = (List<SimpleOrderedMap<Object>>)asdf.get(\"buckets\");\n              for(SimpleOrderedMap<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                SimpleOrderedMap<Object> missingCounts = (SimpleOrderedMap<Object>) asdf.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, termFilter, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n\n    final Predicate<BytesRef> termFilter = newBytesRefFilter(field, params);\n\n    boolean exists = params.getFieldBool(field, FacetParams.FACET_EXISTS, false);\n    \n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    if (sf.getType().isPointField() && !sf.hasDocValues()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \n          \"Can't facet on a PointField without docValues\");\n    }\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    final FacetMethod requestedMethod;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      requestedMethod = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      requestedMethod = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      requestedMethod = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      requestedMethod = FacetMethod.UIF;\n    } else {\n      requestedMethod=null;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    FacetMethod appliedFacetMethod = selectFacetMethod(field,\n                                sf, requestedMethod, mincount,\n                                exists);\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"requestedMethod\", requestedMethod==null?\"not specified\":requestedMethod.name());\n       fdebug.putInfoItem(\"appliedMethod\", appliedFacetMethod.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, termFilter);\n    } else {\n      assert appliedFacetMethod != null;\n      switch (appliedFacetMethod) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, termFilter, exists);\n          break;\n        case FCS:\n          assert ft.isPointField() || !multiToken;\n          if (ft.isPointField() || (ft.getNumberType() != null && !sf.multiValued())) {\n            if (prefix != null) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (termFilter != null) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, \"BytesRef term filters (\"\n                      + FacetParams.FACET_CONTAINS + \", \"\n                      + FacetParams.FACET_EXCLUDETERMS + \") are not supported on numeric types\");\n            }\n            if (ft.isPointField() && mincount <= 0) { // default is mincount=0.  See SOLR-10033 & SOLR-11174.\n              String warningMessage \n                  = \"Raising facet.mincount from \" + mincount + \" to 1, because field \" + field + \" is Points-based.\";\n              LOG.warn(warningMessage);\n              List<String> warnings = (List<String>)rb.rsp.getResponseHeader().get(\"warnings\");\n              if (null == warnings) {\n                warnings = new ArrayList<>();\n                rb.rsp.getResponseHeader().add(\"warnings\", warnings);\n              }\n              warnings.add(warningMessage);\n\n              mincount = 1;\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, termFilter);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(SORT, sortVal );\n\n            Map<String, Object> topLevel = new HashMap<>();\n            topLevel.put(field, jsonFacet);\n              \n            topLevel.put(\"processEmpty\", true);\n\n            FacetProcessor fproc = FacetProcessor.createProcessor(rb.req, topLevel, // rb.getResults().docSet\n                                                                    docs );\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n            fproc.process();\n\n            //Go through the response to build the expected output for SimpleFacets\n            Object res = fproc.getResponse();\n            counts = new NamedList<Integer>();\n            if(res != null) {\n              SimpleOrderedMap<Object> som = (SimpleOrderedMap<Object>)res;\n              SimpleOrderedMap<Object> asdf = (SimpleOrderedMap<Object>) som.get(field);\n\n              List<SimpleOrderedMap<Object>> buckets = (List<SimpleOrderedMap<Object>>)asdf.get(\"buckets\");\n              for(SimpleOrderedMap<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                SimpleOrderedMap<Object> missingCounts = (SimpleOrderedMap<Object>) asdf.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, termFilter, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2ab027bdfe663227636ccbeda13ae82add302939","date":1529980633,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","sourceNew":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n\n    final Predicate<BytesRef> termFilter = newBytesRefFilter(field, params);\n\n    boolean exists = params.getFieldBool(field, FacetParams.FACET_EXISTS, false);\n    \n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    if (sf.getType().isPointField() && !sf.hasDocValues()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \n          \"Can't facet on a PointField without docValues\");\n    }\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    final FacetMethod requestedMethod;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      requestedMethod = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      requestedMethod = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      requestedMethod = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      requestedMethod = FacetMethod.UIF;\n    } else {\n      requestedMethod=null;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    FacetMethod appliedFacetMethod = selectFacetMethod(field,\n                                sf, requestedMethod, mincount,\n                                exists);\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"requestedMethod\", requestedMethod==null?\"not specified\":requestedMethod.name());\n       fdebug.putInfoItem(\"appliedMethod\", appliedFacetMethod.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, termFilter);\n    } else {\n      assert appliedFacetMethod != null;\n      switch (appliedFacetMethod) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, termFilter, exists);\n          break;\n        case FCS:\n          assert ft.isPointField() || !multiToken;\n          if (ft.isPointField() || (ft.getNumberType() != null && !sf.multiValued())) {\n            if (prefix != null) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (termFilter != null) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, \"BytesRef term filters (\"\n                      + FacetParams.FACET_MATCHES + \", \"\n                      + FacetParams.FACET_CONTAINS + \", \"\n                      + FacetParams.FACET_EXCLUDETERMS + \") are not supported on numeric types\");\n            }\n            if (ft.isPointField() && mincount <= 0) { // default is mincount=0.  See SOLR-10033 & SOLR-11174.\n              String warningMessage \n                  = \"Raising facet.mincount from \" + mincount + \" to 1, because field \" + field + \" is Points-based.\";\n              LOG.warn(warningMessage);\n              List<String> warnings = (List<String>)rb.rsp.getResponseHeader().get(\"warnings\");\n              if (null == warnings) {\n                warnings = new ArrayList<>();\n                rb.rsp.getResponseHeader().add(\"warnings\", warnings);\n              }\n              warnings.add(warningMessage);\n\n              mincount = 1;\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, termFilter);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(SORT, sortVal );\n\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n\n            Object resObj = FacetRequest.parseOneFacetReq(req, jsonFacet).process(req, docs);\n            //Go through the response to build the expected output for SimpleFacets\n            counts = new NamedList<>();\n            if(resObj != null) {\n              NamedList<Object> res = (NamedList<Object>) resObj;\n\n              List<NamedList<Object>> buckets = (List<NamedList<Object>>)res.get(\"buckets\");\n              for(NamedList<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                NamedList<Object> missingCounts = (NamedList<Object>) res.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, termFilter, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n\n    final Predicate<BytesRef> termFilter = newBytesRefFilter(field, params);\n\n    boolean exists = params.getFieldBool(field, FacetParams.FACET_EXISTS, false);\n    \n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    if (sf.getType().isPointField() && !sf.hasDocValues()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \n          \"Can't facet on a PointField without docValues\");\n    }\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    final FacetMethod requestedMethod;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      requestedMethod = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      requestedMethod = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      requestedMethod = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      requestedMethod = FacetMethod.UIF;\n    } else {\n      requestedMethod=null;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    FacetMethod appliedFacetMethod = selectFacetMethod(field,\n                                sf, requestedMethod, mincount,\n                                exists);\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"requestedMethod\", requestedMethod==null?\"not specified\":requestedMethod.name());\n       fdebug.putInfoItem(\"appliedMethod\", appliedFacetMethod.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, termFilter);\n    } else {\n      assert appliedFacetMethod != null;\n      switch (appliedFacetMethod) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, termFilter, exists);\n          break;\n        case FCS:\n          assert ft.isPointField() || !multiToken;\n          if (ft.isPointField() || (ft.getNumberType() != null && !sf.multiValued())) {\n            if (prefix != null) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (termFilter != null) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, \"BytesRef term filters (\"\n                      + FacetParams.FACET_MATCHES + \", \"\n                      + FacetParams.FACET_CONTAINS + \", \"\n                      + FacetParams.FACET_EXCLUDETERMS + \") are not supported on numeric types\");\n            }\n            if (ft.isPointField() && mincount <= 0) { // default is mincount=0.  See SOLR-10033 & SOLR-11174.\n              String warningMessage \n                  = \"Raising facet.mincount from \" + mincount + \" to 1, because field \" + field + \" is Points-based.\";\n              LOG.warn(warningMessage);\n              List<String> warnings = (List<String>)rb.rsp.getResponseHeader().get(\"warnings\");\n              if (null == warnings) {\n                warnings = new ArrayList<>();\n                rb.rsp.getResponseHeader().add(\"warnings\", warnings);\n              }\n              warnings.add(warningMessage);\n\n              mincount = 1;\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, termFilter);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(SORT, sortVal );\n\n            Map<String, Object> topLevel = new HashMap<>();\n            topLevel.put(field, jsonFacet);\n              \n            topLevel.put(\"processEmpty\", true);\n\n            FacetProcessor fproc = FacetProcessor.createProcessor(rb.req, topLevel, // rb.getResults().docSet\n                                                                    docs );\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n            fproc.process();\n\n            //Go through the response to build the expected output for SimpleFacets\n            Object res = fproc.getResponse();\n            counts = new NamedList<Integer>();\n            if(res != null) {\n              SimpleOrderedMap<Object> som = (SimpleOrderedMap<Object>)res;\n              SimpleOrderedMap<Object> asdf = (SimpleOrderedMap<Object>) som.get(field);\n\n              List<SimpleOrderedMap<Object>> buckets = (List<SimpleOrderedMap<Object>>)asdf.get(\"buckets\");\n              for(SimpleOrderedMap<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                SimpleOrderedMap<Object> missingCounts = (SimpleOrderedMap<Object>) asdf.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, termFilter, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","sourceNew":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n\n    final Predicate<BytesRef> termFilter = newBytesRefFilter(field, params);\n\n    boolean exists = params.getFieldBool(field, FacetParams.FACET_EXISTS, false);\n    \n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    if (sf.getType().isPointField() && !sf.hasDocValues()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \n          \"Can't facet on a PointField without docValues\");\n    }\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    final FacetMethod requestedMethod;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      requestedMethod = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      requestedMethod = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      requestedMethod = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      requestedMethod = FacetMethod.UIF;\n    } else {\n      requestedMethod=null;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    FacetMethod appliedFacetMethod = selectFacetMethod(field,\n                                sf, requestedMethod, mincount,\n                                exists);\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"requestedMethod\", requestedMethod==null?\"not specified\":requestedMethod.name());\n       fdebug.putInfoItem(\"appliedMethod\", appliedFacetMethod.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, termFilter);\n    } else {\n      assert appliedFacetMethod != null;\n      switch (appliedFacetMethod) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, termFilter, exists);\n          break;\n        case FCS:\n          assert ft.isPointField() || !multiToken;\n          if (ft.isPointField() || (ft.getNumberType() != null && !sf.multiValued())) {\n            if (prefix != null) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (termFilter != null) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, \"BytesRef term filters (\"\n                      + FacetParams.FACET_MATCHES + \", \"\n                      + FacetParams.FACET_CONTAINS + \", \"\n                      + FacetParams.FACET_EXCLUDETERMS + \") are not supported on numeric types\");\n            }\n            if (ft.isPointField() && mincount <= 0) { // default is mincount=0.  See SOLR-10033 & SOLR-11174.\n              String warningMessage \n                  = \"Raising facet.mincount from \" + mincount + \" to 1, because field \" + field + \" is Points-based.\";\n              LOG.warn(warningMessage);\n              List<String> warnings = (List<String>)rb.rsp.getResponseHeader().get(\"warnings\");\n              if (null == warnings) {\n                warnings = new ArrayList<>();\n                rb.rsp.getResponseHeader().add(\"warnings\", warnings);\n              }\n              warnings.add(warningMessage);\n\n              mincount = 1;\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, termFilter);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(SORT, sortVal );\n\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n\n            Object resObj = FacetRequest.parseOneFacetReq(req, jsonFacet).process(req, docs);\n            //Go through the response to build the expected output for SimpleFacets\n            counts = new NamedList<>();\n            if(resObj != null) {\n              NamedList<Object> res = (NamedList<Object>) resObj;\n\n              List<NamedList<Object>> buckets = (List<NamedList<Object>>)res.get(\"buckets\");\n              for(NamedList<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                NamedList<Object> missingCounts = (NamedList<Object>) res.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, termFilter, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n\n    final Predicate<BytesRef> termFilter = newBytesRefFilter(field, params);\n\n    boolean exists = params.getFieldBool(field, FacetParams.FACET_EXISTS, false);\n    \n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    if (sf.getType().isPointField() && !sf.hasDocValues()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \n          \"Can't facet on a PointField without docValues\");\n    }\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    final FacetMethod requestedMethod;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      requestedMethod = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      requestedMethod = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      requestedMethod = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      requestedMethod = FacetMethod.UIF;\n    } else {\n      requestedMethod=null;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    FacetMethod appliedFacetMethod = selectFacetMethod(field,\n                                sf, requestedMethod, mincount,\n                                exists);\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"requestedMethod\", requestedMethod==null?\"not specified\":requestedMethod.name());\n       fdebug.putInfoItem(\"appliedMethod\", appliedFacetMethod.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, termFilter);\n    } else {\n      assert appliedFacetMethod != null;\n      switch (appliedFacetMethod) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, termFilter, exists);\n          break;\n        case FCS:\n          assert ft.isPointField() || !multiToken;\n          if (ft.isPointField() || (ft.getNumberType() != null && !sf.multiValued())) {\n            if (prefix != null) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (termFilter != null) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, \"BytesRef term filters (\"\n                      + FacetParams.FACET_MATCHES + \", \"\n                      + FacetParams.FACET_CONTAINS + \", \"\n                      + FacetParams.FACET_EXCLUDETERMS + \") are not supported on numeric types\");\n            }\n            if (ft.isPointField() && mincount <= 0) { // default is mincount=0.  See SOLR-10033 & SOLR-11174.\n              String warningMessage \n                  = \"Raising facet.mincount from \" + mincount + \" to 1, because field \" + field + \" is Points-based.\";\n              LOG.warn(warningMessage);\n              List<String> warnings = (List<String>)rb.rsp.getResponseHeader().get(\"warnings\");\n              if (null == warnings) {\n                warnings = new ArrayList<>();\n                rb.rsp.getResponseHeader().add(\"warnings\", warnings);\n              }\n              warnings.add(warningMessage);\n\n              mincount = 1;\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, termFilter);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(SORT, sortVal );\n\n            Map<String, Object> topLevel = new HashMap<>();\n            topLevel.put(field, jsonFacet);\n              \n            topLevel.put(\"processEmpty\", true);\n\n            FacetProcessor fproc = FacetProcessor.createProcessor(rb.req, topLevel, // rb.getResults().docSet\n                                                                    docs );\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n            fproc.process();\n\n            //Go through the response to build the expected output for SimpleFacets\n            Object res = fproc.getResponse();\n            counts = new NamedList<Integer>();\n            if(res != null) {\n              SimpleOrderedMap<Object> som = (SimpleOrderedMap<Object>)res;\n              SimpleOrderedMap<Object> asdf = (SimpleOrderedMap<Object>) som.get(field);\n\n              List<SimpleOrderedMap<Object>> buckets = (List<SimpleOrderedMap<Object>>)asdf.get(\"buckets\");\n              for(SimpleOrderedMap<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                SimpleOrderedMap<Object> missingCounts = (SimpleOrderedMap<Object>) asdf.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, termFilter, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","sourceNew":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n\n    final Predicate<BytesRef> termFilter = newBytesRefFilter(field, params);\n\n    boolean exists = params.getFieldBool(field, FacetParams.FACET_EXISTS, false);\n    \n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    if (sf.getType().isPointField() && !sf.hasDocValues()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \n          \"Can't facet on a PointField without docValues\");\n    }\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    final FacetMethod requestedMethod;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      requestedMethod = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      requestedMethod = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      requestedMethod = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      requestedMethod = FacetMethod.UIF;\n    } else {\n      requestedMethod=null;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    FacetMethod appliedFacetMethod = selectFacetMethod(field,\n                                sf, requestedMethod, mincount,\n                                exists);\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"requestedMethod\", requestedMethod==null?\"not specified\":requestedMethod.name());\n       fdebug.putInfoItem(\"appliedMethod\", appliedFacetMethod.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, termFilter);\n    } else {\n      assert appliedFacetMethod != null;\n      switch (appliedFacetMethod) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, termFilter, exists);\n          break;\n        case FCS:\n          assert ft.isPointField() || !multiToken;\n          if (ft.isPointField() || (ft.getNumberType() != null && !sf.multiValued())) {\n            if (prefix != null) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (termFilter != null) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, \"BytesRef term filters (\"\n                      + FacetParams.FACET_MATCHES + \", \"\n                      + FacetParams.FACET_CONTAINS + \", \"\n                      + FacetParams.FACET_EXCLUDETERMS + \") are not supported on numeric types\");\n            }\n            if (ft.isPointField() && mincount <= 0) { // default is mincount=0.  See SOLR-10033 & SOLR-11174.\n              String warningMessage \n                  = \"Raising facet.mincount from \" + mincount + \" to 1, because field \" + field + \" is Points-based.\";\n              LOG.warn(warningMessage);\n              List<String> warnings = (List<String>)rb.rsp.getResponseHeader().get(\"warnings\");\n              if (null == warnings) {\n                warnings = new ArrayList<>();\n                rb.rsp.getResponseHeader().add(\"warnings\", warnings);\n              }\n              warnings.add(warningMessage);\n\n              mincount = 1;\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, termFilter);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(SORT, sortVal );\n\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n\n            Object resObj = FacetRequest.parseOneFacetReq(req, jsonFacet).process(req, docs);\n            //Go through the response to build the expected output for SimpleFacets\n            counts = new NamedList<>();\n            if(resObj != null) {\n              NamedList<Object> res = (NamedList<Object>) resObj;\n\n              List<NamedList<Object>> buckets = (List<NamedList<Object>>)res.get(\"buckets\");\n              for(NamedList<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                NamedList<Object> missingCounts = (NamedList<Object>) res.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, termFilter, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n\n    final Predicate<BytesRef> termFilter = newBytesRefFilter(field, params);\n\n    boolean exists = params.getFieldBool(field, FacetParams.FACET_EXISTS, false);\n    \n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    if (sf.getType().isPointField() && !sf.hasDocValues()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \n          \"Can't facet on a PointField without docValues\");\n    }\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    final FacetMethod requestedMethod;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      requestedMethod = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      requestedMethod = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      requestedMethod = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      requestedMethod = FacetMethod.UIF;\n    } else {\n      requestedMethod=null;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    FacetMethod appliedFacetMethod = selectFacetMethod(field,\n                                sf, requestedMethod, mincount,\n                                exists);\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"requestedMethod\", requestedMethod==null?\"not specified\":requestedMethod.name());\n       fdebug.putInfoItem(\"appliedMethod\", appliedFacetMethod.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, termFilter);\n    } else {\n      assert appliedFacetMethod != null;\n      switch (appliedFacetMethod) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, termFilter, exists);\n          break;\n        case FCS:\n          assert ft.isPointField() || !multiToken;\n          if (ft.isPointField() || (ft.getNumberType() != null && !sf.multiValued())) {\n            if (prefix != null) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (termFilter != null) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, \"BytesRef term filters (\"\n                      + FacetParams.FACET_MATCHES + \", \"\n                      + FacetParams.FACET_CONTAINS + \", \"\n                      + FacetParams.FACET_EXCLUDETERMS + \") are not supported on numeric types\");\n            }\n            if (ft.isPointField() && mincount <= 0) { // default is mincount=0.  See SOLR-10033 & SOLR-11174.\n              String warningMessage \n                  = \"Raising facet.mincount from \" + mincount + \" to 1, because field \" + field + \" is Points-based.\";\n              LOG.warn(warningMessage);\n              List<String> warnings = (List<String>)rb.rsp.getResponseHeader().get(\"warnings\");\n              if (null == warnings) {\n                warnings = new ArrayList<>();\n                rb.rsp.getResponseHeader().add(\"warnings\", warnings);\n              }\n              warnings.add(warningMessage);\n\n              mincount = 1;\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, termFilter);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(SORT, sortVal );\n\n            Map<String, Object> topLevel = new HashMap<>();\n            topLevel.put(field, jsonFacet);\n              \n            topLevel.put(\"processEmpty\", true);\n\n            FacetProcessor fproc = FacetProcessor.createProcessor(rb.req, topLevel, // rb.getResults().docSet\n                                                                    docs );\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n            fproc.process();\n\n            //Go through the response to build the expected output for SimpleFacets\n            Object res = fproc.getResponse();\n            counts = new NamedList<Integer>();\n            if(res != null) {\n              SimpleOrderedMap<Object> som = (SimpleOrderedMap<Object>)res;\n              SimpleOrderedMap<Object> asdf = (SimpleOrderedMap<Object>) som.get(field);\n\n              List<SimpleOrderedMap<Object>> buckets = (List<SimpleOrderedMap<Object>>)asdf.get(\"buckets\");\n              for(SimpleOrderedMap<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                SimpleOrderedMap<Object> missingCounts = (SimpleOrderedMap<Object>) asdf.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, termFilter, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd","date":1534976797,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","sourceNew":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n\n    final Predicate<BytesRef> termFilter = newBytesRefFilter(field, params);\n\n    boolean exists = params.getFieldBool(field, FacetParams.FACET_EXISTS, false);\n    \n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    if (sf.getType().isPointField() && !sf.hasDocValues()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \n          \"Can't facet on a PointField without docValues\");\n    }\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    final FacetMethod requestedMethod;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      requestedMethod = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      requestedMethod = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      requestedMethod = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      requestedMethod = FacetMethod.UIF;\n    } else {\n      requestedMethod=null;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    FacetMethod appliedFacetMethod = selectFacetMethod(field,\n                                sf, requestedMethod, mincount,\n                                exists);\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"requestedMethod\", requestedMethod==null?\"not specified\":requestedMethod.name());\n       fdebug.putInfoItem(\"appliedMethod\", appliedFacetMethod.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, termFilter);\n    } else {\n      assert appliedFacetMethod != null;\n      switch (appliedFacetMethod) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, termFilter, exists);\n          break;\n        case FCS:\n          assert ft.isPointField() || !multiToken;\n          if (ft.isPointField() || (ft.getNumberType() != null && !sf.multiValued())) {\n            if (prefix != null) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (termFilter != null) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, \"BytesRef term filters (\"\n                      + FacetParams.FACET_MATCHES + \", \"\n                      + FacetParams.FACET_CONTAINS + \", \"\n                      + FacetParams.FACET_EXCLUDETERMS + \") are not supported on numeric types\");\n            }\n            if (ft.isPointField() && mincount <= 0) { // default is mincount=0.  See SOLR-10033 & SOLR-11174.\n              String warningMessage \n                  = \"Raising facet.mincount from \" + mincount + \" to 1, because field \" + field + \" is Points-based.\";\n              log.warn(warningMessage);\n              List<String> warnings = (List<String>)rb.rsp.getResponseHeader().get(\"warnings\");\n              if (null == warnings) {\n                warnings = new ArrayList<>();\n                rb.rsp.getResponseHeader().add(\"warnings\", warnings);\n              }\n              warnings.add(warningMessage);\n\n              mincount = 1;\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, termFilter);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(SORT, sortVal );\n\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n\n            Object resObj = FacetRequest.parseOneFacetReq(req, jsonFacet).process(req, docs);\n            //Go through the response to build the expected output for SimpleFacets\n            counts = new NamedList<>();\n            if(resObj != null) {\n              NamedList<Object> res = (NamedList<Object>) resObj;\n\n              List<NamedList<Object>> buckets = (List<NamedList<Object>>)res.get(\"buckets\");\n              for(NamedList<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                NamedList<Object> missingCounts = (NamedList<Object>) res.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, termFilter, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n\n    final Predicate<BytesRef> termFilter = newBytesRefFilter(field, params);\n\n    boolean exists = params.getFieldBool(field, FacetParams.FACET_EXISTS, false);\n    \n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    if (sf.getType().isPointField() && !sf.hasDocValues()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \n          \"Can't facet on a PointField without docValues\");\n    }\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    final FacetMethod requestedMethod;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      requestedMethod = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      requestedMethod = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      requestedMethod = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      requestedMethod = FacetMethod.UIF;\n    } else {\n      requestedMethod=null;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    FacetMethod appliedFacetMethod = selectFacetMethod(field,\n                                sf, requestedMethod, mincount,\n                                exists);\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"requestedMethod\", requestedMethod==null?\"not specified\":requestedMethod.name());\n       fdebug.putInfoItem(\"appliedMethod\", appliedFacetMethod.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, termFilter);\n    } else {\n      assert appliedFacetMethod != null;\n      switch (appliedFacetMethod) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, termFilter, exists);\n          break;\n        case FCS:\n          assert ft.isPointField() || !multiToken;\n          if (ft.isPointField() || (ft.getNumberType() != null && !sf.multiValued())) {\n            if (prefix != null) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (termFilter != null) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, \"BytesRef term filters (\"\n                      + FacetParams.FACET_MATCHES + \", \"\n                      + FacetParams.FACET_CONTAINS + \", \"\n                      + FacetParams.FACET_EXCLUDETERMS + \") are not supported on numeric types\");\n            }\n            if (ft.isPointField() && mincount <= 0) { // default is mincount=0.  See SOLR-10033 & SOLR-11174.\n              String warningMessage \n                  = \"Raising facet.mincount from \" + mincount + \" to 1, because field \" + field + \" is Points-based.\";\n              LOG.warn(warningMessage);\n              List<String> warnings = (List<String>)rb.rsp.getResponseHeader().get(\"warnings\");\n              if (null == warnings) {\n                warnings = new ArrayList<>();\n                rb.rsp.getResponseHeader().add(\"warnings\", warnings);\n              }\n              warnings.add(warningMessage);\n\n              mincount = 1;\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, termFilter);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(SORT, sortVal );\n\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n\n            Object resObj = FacetRequest.parseOneFacetReq(req, jsonFacet).process(req, docs);\n            //Go through the response to build the expected output for SimpleFacets\n            counts = new NamedList<>();\n            if(resObj != null) {\n              NamedList<Object> res = (NamedList<Object>) resObj;\n\n              List<NamedList<Object>> buckets = (List<NamedList<Object>>)res.get(\"buckets\");\n              for(NamedList<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                NamedList<Object> missingCounts = (NamedList<Object>) res.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, termFilter, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7679cc7d5b465ec8936979698cedf5fdbd71c95c","date":1566227764,"type":3,"author":"Munendra S N","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","sourceNew":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n\n    // when limit=0 and missing=false then return empty list\n    if (limit == 0 && !missing) return new NamedList<>();\n\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n\n    final Predicate<BytesRef> termFilter = newBytesRefFilter(field, params);\n\n    boolean exists = params.getFieldBool(field, FacetParams.FACET_EXISTS, false);\n    \n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    if (sf.getType().isPointField() && !sf.hasDocValues()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \n          \"Can't facet on a PointField without docValues\");\n    }\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    final FacetMethod requestedMethod;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      requestedMethod = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      requestedMethod = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      requestedMethod = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      requestedMethod = FacetMethod.UIF;\n    } else {\n      requestedMethod=null;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    FacetMethod appliedFacetMethod = selectFacetMethod(field,\n                                sf, requestedMethod, mincount,\n                                exists);\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"requestedMethod\", requestedMethod==null?\"not specified\":requestedMethod.name());\n       fdebug.putInfoItem(\"appliedMethod\", appliedFacetMethod.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, termFilter);\n    } else {\n      assert appliedFacetMethod != null;\n      switch (appliedFacetMethod) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, termFilter, exists);\n          break;\n        case FCS:\n          assert ft.isPointField() || !multiToken;\n          if (ft.isPointField() || (ft.getNumberType() != null && !sf.multiValued())) {\n            if (prefix != null) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (termFilter != null) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, \"BytesRef term filters (\"\n                      + FacetParams.FACET_MATCHES + \", \"\n                      + FacetParams.FACET_CONTAINS + \", \"\n                      + FacetParams.FACET_EXCLUDETERMS + \") are not supported on numeric types\");\n            }\n            if (ft.isPointField() && mincount <= 0) { // default is mincount=0.  See SOLR-10033 & SOLR-11174.\n              String warningMessage \n                  = \"Raising facet.mincount from \" + mincount + \" to 1, because field \" + field + \" is Points-based.\";\n              log.warn(warningMessage);\n              List<String> warnings = (List<String>)rb.rsp.getResponseHeader().get(\"warnings\");\n              if (null == warnings) {\n                warnings = new ArrayList<>();\n                rb.rsp.getResponseHeader().add(\"warnings\", warnings);\n              }\n              warnings.add(warningMessage);\n\n              mincount = 1;\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, termFilter);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(SORT, sortVal );\n\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n\n            Object resObj = FacetRequest.parseOneFacetReq(req, jsonFacet).process(req, docs);\n            //Go through the response to build the expected output for SimpleFacets\n            counts = new NamedList<>();\n            if(resObj != null) {\n              NamedList<Object> res = (NamedList<Object>) resObj;\n\n              List<NamedList<Object>> buckets = (List<NamedList<Object>>)res.get(\"buckets\");\n              for(NamedList<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                NamedList<Object> missingCounts = (NamedList<Object>) res.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, termFilter, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    if (limit == 0) return new NamedList<>();\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n\n    final Predicate<BytesRef> termFilter = newBytesRefFilter(field, params);\n\n    boolean exists = params.getFieldBool(field, FacetParams.FACET_EXISTS, false);\n    \n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    if (sf.getType().isPointField() && !sf.hasDocValues()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \n          \"Can't facet on a PointField without docValues\");\n    }\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    final FacetMethod requestedMethod;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      requestedMethod = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      requestedMethod = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      requestedMethod = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      requestedMethod = FacetMethod.UIF;\n    } else {\n      requestedMethod=null;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    FacetMethod appliedFacetMethod = selectFacetMethod(field,\n                                sf, requestedMethod, mincount,\n                                exists);\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"requestedMethod\", requestedMethod==null?\"not specified\":requestedMethod.name());\n       fdebug.putInfoItem(\"appliedMethod\", appliedFacetMethod.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, termFilter);\n    } else {\n      assert appliedFacetMethod != null;\n      switch (appliedFacetMethod) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, termFilter, exists);\n          break;\n        case FCS:\n          assert ft.isPointField() || !multiToken;\n          if (ft.isPointField() || (ft.getNumberType() != null && !sf.multiValued())) {\n            if (prefix != null) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (termFilter != null) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, \"BytesRef term filters (\"\n                      + FacetParams.FACET_MATCHES + \", \"\n                      + FacetParams.FACET_CONTAINS + \", \"\n                      + FacetParams.FACET_EXCLUDETERMS + \") are not supported on numeric types\");\n            }\n            if (ft.isPointField() && mincount <= 0) { // default is mincount=0.  See SOLR-10033 & SOLR-11174.\n              String warningMessage \n                  = \"Raising facet.mincount from \" + mincount + \" to 1, because field \" + field + \" is Points-based.\";\n              log.warn(warningMessage);\n              List<String> warnings = (List<String>)rb.rsp.getResponseHeader().get(\"warnings\");\n              if (null == warnings) {\n                warnings = new ArrayList<>();\n                rb.rsp.getResponseHeader().add(\"warnings\", warnings);\n              }\n              warnings.add(warningMessage);\n\n              mincount = 1;\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, termFilter);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(SORT, sortVal );\n\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n\n            Object resObj = FacetRequest.parseOneFacetReq(req, jsonFacet).process(req, docs);\n            //Go through the response to build the expected output for SimpleFacets\n            counts = new NamedList<>();\n            if(resObj != null) {\n              NamedList<Object> res = (NamedList<Object>) resObj;\n\n              List<NamedList<Object>> buckets = (List<NamedList<Object>>)res.get(\"buckets\");\n              for(NamedList<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                NamedList<Object> missingCounts = (NamedList<Object>) res.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, termFilter, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","bugFix":["92751ba9273251eab6a2e379ec42a1697a32ff96"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1c841e27891873cab110ebeb89f124a8ec470176","date":1586527220,"type":3,"author":"Munendra S N","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","sourceNew":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n\n    // when limit=0 and missing=false then return empty list\n    if (limit == 0 && !missing) return new NamedList<>();\n\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n\n    final Predicate<BytesRef> termFilter = newBytesRefFilter(field, params);\n\n    boolean exists = params.getFieldBool(field, FacetParams.FACET_EXISTS, false);\n    \n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    if (sf.getType().isPointField() && !sf.hasDocValues()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \n          \"Can't facet on a PointField without docValues\");\n    }\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    final FacetMethod requestedMethod;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      requestedMethod = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      requestedMethod = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      requestedMethod = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      requestedMethod = FacetMethod.UIF;\n    } else {\n      requestedMethod=null;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    FacetMethod appliedFacetMethod = selectFacetMethod(field,\n                                sf, requestedMethod, mincount,\n                                exists);\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"requestedMethod\", requestedMethod==null?\"not specified\":requestedMethod.name());\n       fdebug.putInfoItem(\"appliedMethod\", appliedFacetMethod.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, termFilter);\n    } else {\n      assert appliedFacetMethod != null;\n      switch (appliedFacetMethod) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, termFilter, exists);\n          break;\n        case FCS:\n          assert ft.isPointField() || !multiToken;\n          if (ft.isPointField() || (ft.getNumberType() != null && !sf.multiValued())) {\n            if (prefix != null) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (termFilter != null) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, \"BytesRef term filters (\"\n                      + FacetParams.FACET_MATCHES + \", \"\n                      + FacetParams.FACET_CONTAINS + \", \"\n                      + FacetParams.FACET_EXCLUDETERMS + \") are not supported on numeric types\");\n            }\n            if (ft.isPointField() && mincount <= 0) { // default is mincount=0.  See SOLR-10033 & SOLR-11174.\n              String warningMessage \n                  = \"Raising facet.mincount from \" + mincount + \" to 1, because field \" + field + \" is Points-based.\";\n              log.warn(warningMessage);\n              List<String> warnings = (List<String>)rb.rsp.getResponseHeader().get(\"warnings\");\n              if (null == warnings) {\n                warnings = new ArrayList<>();\n                rb.rsp.getResponseHeader().add(\"warnings\", warnings);\n              }\n              warnings.add(warningMessage);\n\n              mincount = 1;\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, termFilter);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(SORT, sortVal );\n\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n\n            Object resObj = FacetRequest.parseOneFacetReq(req, jsonFacet).process(req, docs);\n            //Go through the response to build the expected output for SimpleFacets\n            counts = new NamedList<>();\n            if(resObj != null) {\n              NamedList<Object> res = (NamedList<Object>) resObj;\n\n              List<NamedList<Object>> buckets = (List<NamedList<Object>>)res.get(\"buckets\");\n              for(NamedList<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), ((Number)b.get(\"count\")).intValue());\n              }\n              if(missing) {\n                NamedList<Object> missingCounts = (NamedList<Object>) res.get(\"missing\");\n                counts.add(null, ((Number)missingCounts.get(\"count\")).intValue());\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, termFilter, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n\n    // when limit=0 and missing=false then return empty list\n    if (limit == 0 && !missing) return new NamedList<>();\n\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n\n    final Predicate<BytesRef> termFilter = newBytesRefFilter(field, params);\n\n    boolean exists = params.getFieldBool(field, FacetParams.FACET_EXISTS, false);\n    \n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    if (sf.getType().isPointField() && !sf.hasDocValues()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \n          \"Can't facet on a PointField without docValues\");\n    }\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    final FacetMethod requestedMethod;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      requestedMethod = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      requestedMethod = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      requestedMethod = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      requestedMethod = FacetMethod.UIF;\n    } else {\n      requestedMethod=null;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    FacetMethod appliedFacetMethod = selectFacetMethod(field,\n                                sf, requestedMethod, mincount,\n                                exists);\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"requestedMethod\", requestedMethod==null?\"not specified\":requestedMethod.name());\n       fdebug.putInfoItem(\"appliedMethod\", appliedFacetMethod.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, termFilter);\n    } else {\n      assert appliedFacetMethod != null;\n      switch (appliedFacetMethod) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, termFilter, exists);\n          break;\n        case FCS:\n          assert ft.isPointField() || !multiToken;\n          if (ft.isPointField() || (ft.getNumberType() != null && !sf.multiValued())) {\n            if (prefix != null) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (termFilter != null) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, \"BytesRef term filters (\"\n                      + FacetParams.FACET_MATCHES + \", \"\n                      + FacetParams.FACET_CONTAINS + \", \"\n                      + FacetParams.FACET_EXCLUDETERMS + \") are not supported on numeric types\");\n            }\n            if (ft.isPointField() && mincount <= 0) { // default is mincount=0.  See SOLR-10033 & SOLR-11174.\n              String warningMessage \n                  = \"Raising facet.mincount from \" + mincount + \" to 1, because field \" + field + \" is Points-based.\";\n              log.warn(warningMessage);\n              List<String> warnings = (List<String>)rb.rsp.getResponseHeader().get(\"warnings\");\n              if (null == warnings) {\n                warnings = new ArrayList<>();\n                rb.rsp.getResponseHeader().add(\"warnings\", warnings);\n              }\n              warnings.add(warningMessage);\n\n              mincount = 1;\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, termFilter);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(SORT, sortVal );\n\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n\n            Object resObj = FacetRequest.parseOneFacetReq(req, jsonFacet).process(req, docs);\n            //Go through the response to build the expected output for SimpleFacets\n            counts = new NamedList<>();\n            if(resObj != null) {\n              NamedList<Object> res = (NamedList<Object>) resObj;\n\n              List<NamedList<Object>> buckets = (List<NamedList<Object>>)res.get(\"buckets\");\n              for(NamedList<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), (Integer)b.get(\"count\"));\n              }\n              if(missing) {\n                NamedList<Object> missingCounts = (NamedList<Object>) res.get(\"missing\");\n                counts.add(null, (Integer)missingCounts.get(\"count\"));\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, termFilter, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","bugFix":["3802d95c3a31be21ea2971945049b711d95ef8d5"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bd25fa3647fa73152703b8dccb4fb5f43633de20","date":1592060458,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getTermCounts(String,Integer,ParsedParams).mjava","sourceNew":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n\n    // when limit=0 and missing=false then return empty list\n    if (limit == 0 && !missing) return new NamedList<>();\n\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n\n    final Predicate<BytesRef> termFilter = newBytesRefFilter(field, params);\n\n    boolean exists = params.getFieldBool(field, FacetParams.FACET_EXISTS, false);\n    \n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    if (sf.getType().isPointField() && !sf.hasDocValues()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \n          \"Can't facet on a PointField without docValues\");\n    }\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    final FacetMethod requestedMethod;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      requestedMethod = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      requestedMethod = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      requestedMethod = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      requestedMethod = FacetMethod.UIF;\n    } else {\n      requestedMethod=null;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    FacetMethod appliedFacetMethod = selectFacetMethod(field,\n                                sf, requestedMethod, mincount,\n                                exists);\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"requestedMethod\", requestedMethod==null?\"not specified\":requestedMethod.name());\n       fdebug.putInfoItem(\"appliedMethod\", appliedFacetMethod.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, termFilter);\n    } else {\n      assert appliedFacetMethod != null;\n      switch (appliedFacetMethod) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, termFilter, exists);\n          break;\n        case FCS:\n          assert ft.isPointField() || !multiToken;\n          if (ft.isPointField() || (ft.getNumberType() != null && !sf.multiValued())) {\n            if (prefix != null) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (termFilter != null) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, \"BytesRef term filters (\"\n                      + FacetParams.FACET_MATCHES + \", \"\n                      + FacetParams.FACET_CONTAINS + \", \"\n                      + FacetParams.FACET_EXCLUDETERMS + \") are not supported on numeric types\");\n            }\n            if (ft.isPointField() && mincount <= 0) { // default is mincount=0.  See SOLR-10033 & SOLR-11174.\n              String warningMessage \n                  = \"Raising facet.mincount from \" + mincount + \" to 1, because field \" + field + \" is Points-based.\";\n              log.warn(warningMessage);\n              @SuppressWarnings({\"unchecked\"})\n              List<String> warnings = (List<String>)rb.rsp.getResponseHeader().get(\"warnings\");\n              if (null == warnings) {\n                warnings = new ArrayList<>();\n                rb.rsp.getResponseHeader().add(\"warnings\", warnings);\n              }\n              warnings.add(warningMessage);\n\n              mincount = 1;\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, termFilter);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(SORT, sortVal );\n\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n\n            Object resObj = FacetRequest.parseOneFacetReq(req, jsonFacet).process(req, docs);\n            //Go through the response to build the expected output for SimpleFacets\n            counts = new NamedList<>();\n            if(resObj != null) {\n              @SuppressWarnings({\"unchecked\"})\n              NamedList<Object> res = (NamedList<Object>) resObj;\n\n              @SuppressWarnings({\"unchecked\"})\n              List<NamedList<Object>> buckets = (List<NamedList<Object>>)res.get(\"buckets\");\n              for(NamedList<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), ((Number)b.get(\"count\")).intValue());\n              }\n              if(missing) {\n                @SuppressWarnings({\"unchecked\"})\n                NamedList<Object> missingCounts = (NamedList<Object>) res.get(\"missing\");\n                counts.add(null, ((Number)missingCounts.get(\"count\")).intValue());\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, termFilter, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","sourceOld":"  /**\n   * Term counts for use in field faceting that resepcts the specified mincount - \n   * if mincount is null, the \"zeros\" param is consulted for the appropriate backcompat \n   * default\n   *\n   * @see FacetParams#FACET_ZEROS\n   */\n  private NamedList<Integer> getTermCounts(String field, Integer mincount, ParsedParams parsed) throws IOException {\n    final SolrParams params = parsed.params;\n    final DocSet docs = parsed.docs;\n    final int threads = parsed.threads;\n    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);\n    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);\n    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);\n\n    // when limit=0 and missing=false then return empty list\n    if (limit == 0 && !missing) return new NamedList<>();\n\n    if (mincount==null) {\n      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);\n      // mincount = (zeros!=null && zeros) ? 0 : 1;\n      mincount = (zeros!=null && !zeros) ? 1 : 0;\n      // current default is to include zeros.\n    }\n\n    // default to sorting if there is a limit.\n    String sort = params.getFieldParam(field, FacetParams.FACET_SORT, limit>0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);\n    String prefix = params.getFieldParam(field, FacetParams.FACET_PREFIX);\n\n    final Predicate<BytesRef> termFilter = newBytesRefFilter(field, params);\n\n    boolean exists = params.getFieldBool(field, FacetParams.FACET_EXISTS, false);\n    \n    NamedList<Integer> counts;\n    SchemaField sf = searcher.getSchema().getField(field);\n    if (sf.getType().isPointField() && !sf.hasDocValues()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \n          \"Can't facet on a PointField without docValues\");\n    }\n    FieldType ft = sf.getType();\n\n    // determine what type of faceting method to use\n    final String methodStr = params.getFieldParam(field, FacetParams.FACET_METHOD);\n    final FacetMethod requestedMethod;\n    if (FacetParams.FACET_METHOD_enum.equals(methodStr)) {\n      requestedMethod = FacetMethod.ENUM;\n    } else if (FacetParams.FACET_METHOD_fcs.equals(methodStr)) {\n      requestedMethod = FacetMethod.FCS;\n    } else if (FacetParams.FACET_METHOD_fc.equals(methodStr)) {\n      requestedMethod = FacetMethod.FC;\n    } else if(FacetParams.FACET_METHOD_uif.equals(methodStr)) {\n      requestedMethod = FacetMethod.UIF;\n    } else {\n      requestedMethod=null;\n    }\n\n    final boolean multiToken = sf.multiValued() || ft.multiValuedFieldCache();\n\n    FacetMethod appliedFacetMethod = selectFacetMethod(field,\n                                sf, requestedMethod, mincount,\n                                exists);\n\n    RTimer timer = null;\n    if (fdebug != null) {\n       fdebug.putInfoItem(\"requestedMethod\", requestedMethod==null?\"not specified\":requestedMethod.name());\n       fdebug.putInfoItem(\"appliedMethod\", appliedFacetMethod.name());\n       fdebug.putInfoItem(\"inputDocSetSize\", docs.size());\n       fdebug.putInfoItem(\"field\", field);\n       timer = new RTimer();\n    }\n\n    if (params.getFieldBool(field, GroupParams.GROUP_FACET, false)) {\n      counts = getGroupedCounts(searcher, docs, field, multiToken, offset,limit, mincount, missing, sort, prefix, termFilter);\n    } else {\n      assert appliedFacetMethod != null;\n      switch (appliedFacetMethod) {\n        case ENUM:\n          assert TrieField.getMainValuePrefix(ft) == null;\n          counts = getFacetTermEnumCounts(searcher, docs, field, offset, limit, mincount,missing,sort,prefix, termFilter, exists);\n          break;\n        case FCS:\n          assert ft.isPointField() || !multiToken;\n          if (ft.isPointField() || (ft.getNumberType() != null && !sf.multiValued())) {\n            if (prefix != null) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, FacetParams.FACET_PREFIX + \" is not supported on numeric types\");\n            }\n            if (termFilter != null) {\n              throw new SolrException(ErrorCode.BAD_REQUEST, \"BytesRef term filters (\"\n                      + FacetParams.FACET_MATCHES + \", \"\n                      + FacetParams.FACET_CONTAINS + \", \"\n                      + FacetParams.FACET_EXCLUDETERMS + \") are not supported on numeric types\");\n            }\n            if (ft.isPointField() && mincount <= 0) { // default is mincount=0.  See SOLR-10033 & SOLR-11174.\n              String warningMessage \n                  = \"Raising facet.mincount from \" + mincount + \" to 1, because field \" + field + \" is Points-based.\";\n              log.warn(warningMessage);\n              List<String> warnings = (List<String>)rb.rsp.getResponseHeader().get(\"warnings\");\n              if (null == warnings) {\n                warnings = new ArrayList<>();\n                rb.rsp.getResponseHeader().add(\"warnings\", warnings);\n              }\n              warnings.add(warningMessage);\n\n              mincount = 1;\n            }\n            counts = NumericFacets.getCounts(searcher, docs, field, offset, limit, mincount, missing, sort);\n          } else {\n            PerSegmentSingleValuedFaceting ps = new PerSegmentSingleValuedFaceting(searcher, docs, field, offset, limit, mincount, missing, sort, prefix, termFilter);\n            Executor executor = threads == 0 ? directExecutor : facetExecutor;\n            ps.setNumThreads(threads);\n            counts = ps.getFacetCounts(executor);\n          }\n          break;\n        case UIF:\n            //Emulate the JSON Faceting structure so we can use the same parsing classes\n            Map<String, Object> jsonFacet = new HashMap<>(13);\n            jsonFacet.put(\"type\", \"terms\");\n            jsonFacet.put(\"field\", field);\n            jsonFacet.put(\"offset\", offset);\n            jsonFacet.put(\"limit\", limit);\n            jsonFacet.put(\"mincount\", mincount);\n            jsonFacet.put(\"missing\", missing);\n            jsonFacet.put(\"prefix\", prefix);\n            jsonFacet.put(\"numBuckets\", params.getFieldBool(field, \"numBuckets\", false));\n            jsonFacet.put(\"allBuckets\", params.getFieldBool(field, \"allBuckets\", false));\n            jsonFacet.put(\"method\", \"uif\");\n            jsonFacet.put(\"cacheDf\", 0);\n            jsonFacet.put(\"perSeg\", false);\n            \n            final String sortVal;\n            switch(sort){\n              case FacetParams.FACET_SORT_COUNT_LEGACY:\n                sortVal = FacetParams.FACET_SORT_COUNT;\n              break;\n              case FacetParams.FACET_SORT_INDEX_LEGACY:\n                sortVal = FacetParams.FACET_SORT_INDEX;\n              break;\n              default:\n                sortVal = sort;\n            }\n            jsonFacet.put(SORT, sortVal );\n\n            //TODO do we handle debug?  Should probably already be handled by the legacy code\n\n            Object resObj = FacetRequest.parseOneFacetReq(req, jsonFacet).process(req, docs);\n            //Go through the response to build the expected output for SimpleFacets\n            counts = new NamedList<>();\n            if(resObj != null) {\n              NamedList<Object> res = (NamedList<Object>) resObj;\n\n              List<NamedList<Object>> buckets = (List<NamedList<Object>>)res.get(\"buckets\");\n              for(NamedList<Object> b : buckets) {\n                counts.add(b.get(\"val\").toString(), ((Number)b.get(\"count\")).intValue());\n              }\n              if(missing) {\n                NamedList<Object> missingCounts = (NamedList<Object>) res.get(\"missing\");\n                counts.add(null, ((Number)missingCounts.get(\"count\")).intValue());\n              }\n            }\n          break;\n        case FC:\n          counts = DocValuesFacets.getCounts(searcher, docs, field, offset,limit, mincount, missing, sort, prefix, termFilter, fdebug);\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    if (fdebug != null) {\n      long timeElapsed = (long) timer.getTime();\n      fdebug.setElapse(timeElapsed);\n    }\n\n    return counts;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"2ab027bdfe663227636ccbeda13ae82add302939":["f59e5a034782f8d1b0eec0ec9a74be9b713764f4"],"36294de1b3009c52225da73c7d7e5ad8cf7ab100":["01624b85de12fb02335810bdf325124e59040772"],"ebff2e24a6d2f84582ff6315d8d377380941b23e":["36294de1b3009c52225da73c7d7e5ad8cf7ab100"],"7679cc7d5b465ec8936979698cedf5fdbd71c95c":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"3c64189697927b548f74ba66dfa5051548662938":["22d0a81a05eba47d5e18976f17d88306b218cc22","3802d95c3a31be21ea2971945049b711d95ef8d5"],"bc8f206328a706450934717bec7ccc22ad166fc0":["275f40e1400de0b5ab5e33051ac11e8973813a2c","39342cb658ac11dfcbf4459807fb00eb9ada0218"],"39342cb658ac11dfcbf4459807fb00eb9ada0218":["275f40e1400de0b5ab5e33051ac11e8973813a2c"],"01624b85de12fb02335810bdf325124e59040772":["1c1d8a5912a6d0e6639e4720a9dc63d048ade073"],"89424def13674ea17829b41c5883c54ecc31a132":["275f40e1400de0b5ab5e33051ac11e8973813a2c","bc8f206328a706450934717bec7ccc22ad166fc0"],"1c841e27891873cab110ebeb89f124a8ec470176":["7679cc7d5b465ec8936979698cedf5fdbd71c95c"],"022a4de90e0479b604264ca9c2e134c996454ab3":["862ed062e72c1c01ecd8593b17804ac02b69cf0e","744b111b17d15d490a648eb021bfa240e7f11556"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["f59e5a034782f8d1b0eec0ec9a74be9b713764f4","2ab027bdfe663227636ccbeda13ae82add302939"],"862ed062e72c1c01ecd8593b17804ac02b69cf0e":["3d81baa64023bbb9b43f6d929ee168b105940d30"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["275f40e1400de0b5ab5e33051ac11e8973813a2c","89424def13674ea17829b41c5883c54ecc31a132"],"e66a459d38c1c4a2f97128433dab546f683a9fed":["550bbe5ffcdb614551686767f4d5a6ee38ef3e85","3e5f469d206ae27a1d59e654e70a1413ffcec765"],"bd25fa3647fa73152703b8dccb4fb5f43633de20":["1c841e27891873cab110ebeb89f124a8ec470176"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["2ab027bdfe663227636ccbeda13ae82add302939"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["f59e5a034782f8d1b0eec0ec9a74be9b713764f4","2ab027bdfe663227636ccbeda13ae82add302939"],"897b06b1364bd1f658a8be7591e43f0851458e7f":["b49c0eb9ef7bc25609a89e7986ce7e6eeb9c9d96"],"46dc9ac8b3e748407baaef82453138ff3974480c":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"6f4c5d3859373c3a74734e85efa122b17514e3e8":["1c1d8a5912a6d0e6639e4720a9dc63d048ade073"],"550bbe5ffcdb614551686767f4d5a6ee38ef3e85":["3c64189697927b548f74ba66dfa5051548662938"],"aa62c79a7afa4d7f22e1f71b883659f3213d7db1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["550bbe5ffcdb614551686767f4d5a6ee38ef3e85","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"90a682dc1bfd188ef61cc28373c7f5d700b4ac75":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","46dc9ac8b3e748407baaef82453138ff3974480c"],"b49c0eb9ef7bc25609a89e7986ce7e6eeb9c9d96":["022a4de90e0479b604264ca9c2e134c996454ab3"],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":["6f4c5d3859373c3a74734e85efa122b17514e3e8","ebff2e24a6d2f84582ff6315d8d377380941b23e"],"3d81baa64023bbb9b43f6d929ee168b105940d30":["46dc9ac8b3e748407baaef82453138ff3974480c"],"3e5f469d206ae27a1d59e654e70a1413ffcec765":["550bbe5ffcdb614551686767f4d5a6ee38ef3e85"],"22d0a81a05eba47d5e18976f17d88306b218cc22":["aa62c79a7afa4d7f22e1f71b883659f3213d7db1"],"f59e5a034782f8d1b0eec0ec9a74be9b713764f4":["ebff2e24a6d2f84582ff6315d8d377380941b23e"],"744b111b17d15d490a648eb021bfa240e7f11556":["862ed062e72c1c01ecd8593b17804ac02b69cf0e"],"1c1d8a5912a6d0e6639e4720a9dc63d048ade073":["897b06b1364bd1f658a8be7591e43f0851458e7f"],"275f40e1400de0b5ab5e33051ac11e8973813a2c":["3e5f469d206ae27a1d59e654e70a1413ffcec765"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bd25fa3647fa73152703b8dccb4fb5f43633de20"],"3802d95c3a31be21ea2971945049b711d95ef8d5":["22d0a81a05eba47d5e18976f17d88306b218cc22"]},"commit2Childs":{"2ab027bdfe663227636ccbeda13ae82add302939":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","e9c81f7e703d7ccca5bc78beb61253f0a8a22afd","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"36294de1b3009c52225da73c7d7e5ad8cf7ab100":["ebff2e24a6d2f84582ff6315d8d377380941b23e"],"ebff2e24a6d2f84582ff6315d8d377380941b23e":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","f59e5a034782f8d1b0eec0ec9a74be9b713764f4"],"7679cc7d5b465ec8936979698cedf5fdbd71c95c":["1c841e27891873cab110ebeb89f124a8ec470176"],"3c64189697927b548f74ba66dfa5051548662938":["550bbe5ffcdb614551686767f4d5a6ee38ef3e85"],"bc8f206328a706450934717bec7ccc22ad166fc0":["89424def13674ea17829b41c5883c54ecc31a132"],"39342cb658ac11dfcbf4459807fb00eb9ada0218":["bc8f206328a706450934717bec7ccc22ad166fc0"],"01624b85de12fb02335810bdf325124e59040772":["36294de1b3009c52225da73c7d7e5ad8cf7ab100"],"89424def13674ea17829b41c5883c54ecc31a132":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"1c841e27891873cab110ebeb89f124a8ec470176":["bd25fa3647fa73152703b8dccb4fb5f43633de20"],"022a4de90e0479b604264ca9c2e134c996454ab3":["b49c0eb9ef7bc25609a89e7986ce7e6eeb9c9d96"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"862ed062e72c1c01ecd8593b17804ac02b69cf0e":["022a4de90e0479b604264ca9c2e134c996454ab3","744b111b17d15d490a648eb021bfa240e7f11556"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["aa62c79a7afa4d7f22e1f71b883659f3213d7db1"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["46dc9ac8b3e748407baaef82453138ff3974480c","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"e66a459d38c1c4a2f97128433dab546f683a9fed":[],"bd25fa3647fa73152703b8dccb4fb5f43633de20":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["7679cc7d5b465ec8936979698cedf5fdbd71c95c"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[],"897b06b1364bd1f658a8be7591e43f0851458e7f":["1c1d8a5912a6d0e6639e4720a9dc63d048ade073"],"46dc9ac8b3e748407baaef82453138ff3974480c":["90a682dc1bfd188ef61cc28373c7f5d700b4ac75","3d81baa64023bbb9b43f6d929ee168b105940d30"],"6f4c5d3859373c3a74734e85efa122b17514e3e8":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac"],"550bbe5ffcdb614551686767f4d5a6ee38ef3e85":["e66a459d38c1c4a2f97128433dab546f683a9fed","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","3e5f469d206ae27a1d59e654e70a1413ffcec765"],"aa62c79a7afa4d7f22e1f71b883659f3213d7db1":["22d0a81a05eba47d5e18976f17d88306b218cc22"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["90a682dc1bfd188ef61cc28373c7f5d700b4ac75"],"90a682dc1bfd188ef61cc28373c7f5d700b4ac75":[],"b49c0eb9ef7bc25609a89e7986ce7e6eeb9c9d96":["897b06b1364bd1f658a8be7591e43f0851458e7f"],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":[],"3d81baa64023bbb9b43f6d929ee168b105940d30":["862ed062e72c1c01ecd8593b17804ac02b69cf0e"],"3e5f469d206ae27a1d59e654e70a1413ffcec765":["e66a459d38c1c4a2f97128433dab546f683a9fed","275f40e1400de0b5ab5e33051ac11e8973813a2c"],"22d0a81a05eba47d5e18976f17d88306b218cc22":["3c64189697927b548f74ba66dfa5051548662938","3802d95c3a31be21ea2971945049b711d95ef8d5"],"f59e5a034782f8d1b0eec0ec9a74be9b713764f4":["2ab027bdfe663227636ccbeda13ae82add302939","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"744b111b17d15d490a648eb021bfa240e7f11556":["022a4de90e0479b604264ca9c2e134c996454ab3"],"275f40e1400de0b5ab5e33051ac11e8973813a2c":["bc8f206328a706450934717bec7ccc22ad166fc0","39342cb658ac11dfcbf4459807fb00eb9ada0218","89424def13674ea17829b41c5883c54ecc31a132","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"1c1d8a5912a6d0e6639e4720a9dc63d048ade073":["01624b85de12fb02335810bdf325124e59040772","6f4c5d3859373c3a74734e85efa122b17514e3e8"],"3802d95c3a31be21ea2971945049b711d95ef8d5":["3c64189697927b548f74ba66dfa5051548662938"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","e66a459d38c1c4a2f97128433dab546f683a9fed","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","90a682dc1bfd188ef61cc28373c7f5d700b4ac75","7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}