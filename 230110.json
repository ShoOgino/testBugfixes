{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory.EdgeBuffer#EdgeBuffer(List[GeoPoint],int,int,SidedPlane,boolean).mjava","commits":[{"id":"40aa98241c87d86a0077beb8023713d93a0becfe","date":1459784560,"type":0,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory.EdgeBuffer#EdgeBuffer(List[GeoPoint],int,int,SidedPlane,boolean).mjava","pathOld":"/dev/null","sourceNew":"    public EdgeBuffer(final List<GeoPoint> pointList, final int startPlaneStartIndex, final int startPlaneEndIndex, final SidedPlane startPlane, final boolean startPlaneIsInternal) {\n      /*\n      System.out.println(\"Initial points:\");\n      for (final GeoPoint p : pointList) {\n        System.out.println(\" \"+p);\n      }\n      System.out.println(\"For start plane, the following points are in/out:\");\n      for (final GeoPoint p: pointList) {\n        System.out.println(\" \"+p+\" is: \"+(startPlane.isWithin(p)?\"in\":\"out\"));\n      }\n      */\n      \n      final Edge startEdge = new Edge(pointList.get(startPlaneStartIndex), pointList.get(startPlaneEndIndex), startPlane, startPlaneIsInternal);\n      // Fill in the EdgeBuffer by walking around creating more stuff\n      Edge currentEdge = startEdge;\n      int startIndex = startPlaneStartIndex;\n      int endIndex = startPlaneEndIndex;\n      boolean isInternal = startPlaneIsInternal;\n      while (true) {\n        // Compute the next edge\n        startIndex = endIndex;\n        endIndex++;\n        if (endIndex >= pointList.size()) {\n          endIndex -= pointList.size();\n        }\n        // Get the next point\n        final GeoPoint newPoint = pointList.get(endIndex);\n        // Build the new edge\n        final boolean isNewPointWithin = currentEdge.plane.isWithin(newPoint);\n        final SidedPlane newPlane = new SidedPlane(currentEdge.startPoint, isNewPointWithin, pointList.get(startIndex), newPoint);\n        /*\n        System.out.println(\"For next plane, the following points are in/out:\");\n        for (final GeoPoint p: pointList) {\n          System.out.println(\" \"+p+\" is: \"+(newPlane.isWithin(p)?\"in\":\"out\"));\n        }\n        */\n        final Edge newEdge = new Edge(pointList.get(startIndex), pointList.get(endIndex), newPlane, false);\n        \n        // Link it in\n        previousEdges.put(newEdge, currentEdge);\n        nextEdges.put(currentEdge, newEdge);\n        edges.add(newEdge);\n        currentEdge = newEdge;\n\n        if (currentEdge.endPoint == startEdge.startPoint) {\n          // We finish here.  Link the current edge to the start edge, and exit\n          previousEdges.put(startEdge, currentEdge);\n          nextEdges.put(currentEdge, startEdge);\n          edges.add(startEdge);\n          break;\n        }\n      }\n      \n      oneEdge = startEdge;\n      \n      // Verify the structure. \n      //verify();\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["fa76b98015a97f0eca94f0f11fd1b6975838c3ee"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"edc0b3370cd3844691fb46de50cbc79c2449617e","date":1459791826,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory.EdgeBuffer#EdgeBuffer(List[GeoPoint],int,int,SidedPlane,boolean).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory.EdgeBuffer#EdgeBuffer(List[GeoPoint],int,int,SidedPlane,boolean).mjava","sourceNew":"    /** Constructor.\n      * @param pointList is the list of points.\n      * @param startPlaneStartIndex is the index of the startPlane's starting point\n      * @param startPlaneEndIndex is the index of the startPlane's ending point\n      * @param startPlane is the starting plane\n      * @param startPlaneIsInternal signals whether the startPlane is an internal edge\n      */\n    public EdgeBuffer(final List<GeoPoint> pointList, final int startPlaneStartIndex, final int startPlaneEndIndex, final SidedPlane startPlane, final boolean startPlaneIsInternal) {\n      /*\n      System.out.println(\"Initial points:\");\n      for (final GeoPoint p : pointList) {\n        System.out.println(\" \"+p);\n      }\n      System.out.println(\"For start plane, the following points are in/out:\");\n      for (final GeoPoint p: pointList) {\n        System.out.println(\" \"+p+\" is: \"+(startPlane.isWithin(p)?\"in\":\"out\"));\n      }\n      */\n      \n      final Edge startEdge = new Edge(pointList.get(startPlaneStartIndex), pointList.get(startPlaneEndIndex), startPlane, startPlaneIsInternal);\n      // Fill in the EdgeBuffer by walking around creating more stuff\n      Edge currentEdge = startEdge;\n      int startIndex = startPlaneStartIndex;\n      int endIndex = startPlaneEndIndex;\n      boolean isInternal = startPlaneIsInternal;\n      while (true) {\n        // Compute the next edge\n        startIndex = endIndex;\n        endIndex++;\n        if (endIndex >= pointList.size()) {\n          endIndex -= pointList.size();\n        }\n        // Get the next point\n        final GeoPoint newPoint = pointList.get(endIndex);\n        // Build the new edge\n        final boolean isNewPointWithin = currentEdge.plane.isWithin(newPoint);\n        final SidedPlane newPlane = new SidedPlane(currentEdge.startPoint, isNewPointWithin, pointList.get(startIndex), newPoint);\n        /*\n        System.out.println(\"For next plane, the following points are in/out:\");\n        for (final GeoPoint p: pointList) {\n          System.out.println(\" \"+p+\" is: \"+(newPlane.isWithin(p)?\"in\":\"out\"));\n        }\n        */\n        final Edge newEdge = new Edge(pointList.get(startIndex), pointList.get(endIndex), newPlane, false);\n        \n        // Link it in\n        previousEdges.put(newEdge, currentEdge);\n        nextEdges.put(currentEdge, newEdge);\n        edges.add(newEdge);\n        currentEdge = newEdge;\n\n        if (currentEdge.endPoint == startEdge.startPoint) {\n          // We finish here.  Link the current edge to the start edge, and exit\n          previousEdges.put(startEdge, currentEdge);\n          nextEdges.put(currentEdge, startEdge);\n          edges.add(startEdge);\n          break;\n        }\n      }\n      \n      oneEdge = startEdge;\n      \n      // Verify the structure. \n      //verify();\n    }\n\n","sourceOld":"    public EdgeBuffer(final List<GeoPoint> pointList, final int startPlaneStartIndex, final int startPlaneEndIndex, final SidedPlane startPlane, final boolean startPlaneIsInternal) {\n      /*\n      System.out.println(\"Initial points:\");\n      for (final GeoPoint p : pointList) {\n        System.out.println(\" \"+p);\n      }\n      System.out.println(\"For start plane, the following points are in/out:\");\n      for (final GeoPoint p: pointList) {\n        System.out.println(\" \"+p+\" is: \"+(startPlane.isWithin(p)?\"in\":\"out\"));\n      }\n      */\n      \n      final Edge startEdge = new Edge(pointList.get(startPlaneStartIndex), pointList.get(startPlaneEndIndex), startPlane, startPlaneIsInternal);\n      // Fill in the EdgeBuffer by walking around creating more stuff\n      Edge currentEdge = startEdge;\n      int startIndex = startPlaneStartIndex;\n      int endIndex = startPlaneEndIndex;\n      boolean isInternal = startPlaneIsInternal;\n      while (true) {\n        // Compute the next edge\n        startIndex = endIndex;\n        endIndex++;\n        if (endIndex >= pointList.size()) {\n          endIndex -= pointList.size();\n        }\n        // Get the next point\n        final GeoPoint newPoint = pointList.get(endIndex);\n        // Build the new edge\n        final boolean isNewPointWithin = currentEdge.plane.isWithin(newPoint);\n        final SidedPlane newPlane = new SidedPlane(currentEdge.startPoint, isNewPointWithin, pointList.get(startIndex), newPoint);\n        /*\n        System.out.println(\"For next plane, the following points are in/out:\");\n        for (final GeoPoint p: pointList) {\n          System.out.println(\" \"+p+\" is: \"+(newPlane.isWithin(p)?\"in\":\"out\"));\n        }\n        */\n        final Edge newEdge = new Edge(pointList.get(startIndex), pointList.get(endIndex), newPlane, false);\n        \n        // Link it in\n        previousEdges.put(newEdge, currentEdge);\n        nextEdges.put(currentEdge, newEdge);\n        edges.add(newEdge);\n        currentEdge = newEdge;\n\n        if (currentEdge.endPoint == startEdge.startPoint) {\n          // We finish here.  Link the current edge to the start edge, and exit\n          previousEdges.put(startEdge, currentEdge);\n          nextEdges.put(currentEdge, startEdge);\n          edges.add(startEdge);\n          break;\n        }\n      }\n      \n      oneEdge = startEdge;\n      \n      // Verify the structure. \n      //verify();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"09af2c9610ce53a4b25fd99344299b40318a4a1a","date":1459876565,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory.EdgeBuffer#EdgeBuffer(List[GeoPoint],int,int,SidedPlane,boolean).mjava","pathOld":"/dev/null","sourceNew":"    /** Constructor.\n      * @param pointList is the list of points.\n      * @param startPlaneStartIndex is the index of the startPlane's starting point\n      * @param startPlaneEndIndex is the index of the startPlane's ending point\n      * @param startPlane is the starting plane\n      * @param startPlaneIsInternal signals whether the startPlane is an internal edge\n      */\n    public EdgeBuffer(final List<GeoPoint> pointList, final int startPlaneStartIndex, final int startPlaneEndIndex, final SidedPlane startPlane, final boolean startPlaneIsInternal) {\n      /*\n      System.out.println(\"Initial points:\");\n      for (final GeoPoint p : pointList) {\n        System.out.println(\" \"+p);\n      }\n      System.out.println(\"For start plane, the following points are in/out:\");\n      for (final GeoPoint p: pointList) {\n        System.out.println(\" \"+p+\" is: \"+(startPlane.isWithin(p)?\"in\":\"out\"));\n      }\n      */\n      \n      final Edge startEdge = new Edge(pointList.get(startPlaneStartIndex), pointList.get(startPlaneEndIndex), startPlane, startPlaneIsInternal);\n      // Fill in the EdgeBuffer by walking around creating more stuff\n      Edge currentEdge = startEdge;\n      int startIndex = startPlaneStartIndex;\n      int endIndex = startPlaneEndIndex;\n      boolean isInternal = startPlaneIsInternal;\n      while (true) {\n        // Compute the next edge\n        startIndex = endIndex;\n        endIndex++;\n        if (endIndex >= pointList.size()) {\n          endIndex -= pointList.size();\n        }\n        // Get the next point\n        final GeoPoint newPoint = pointList.get(endIndex);\n        // Build the new edge\n        final boolean isNewPointWithin = currentEdge.plane.isWithin(newPoint);\n        final SidedPlane newPlane = new SidedPlane(currentEdge.startPoint, isNewPointWithin, pointList.get(startIndex), newPoint);\n        /*\n        System.out.println(\"For next plane, the following points are in/out:\");\n        for (final GeoPoint p: pointList) {\n          System.out.println(\" \"+p+\" is: \"+(newPlane.isWithin(p)?\"in\":\"out\"));\n        }\n        */\n        final Edge newEdge = new Edge(pointList.get(startIndex), pointList.get(endIndex), newPlane, false);\n        \n        // Link it in\n        previousEdges.put(newEdge, currentEdge);\n        nextEdges.put(currentEdge, newEdge);\n        edges.add(newEdge);\n        currentEdge = newEdge;\n\n        if (currentEdge.endPoint == startEdge.startPoint) {\n          // We finish here.  Link the current edge to the start edge, and exit\n          previousEdges.put(startEdge, currentEdge);\n          nextEdges.put(currentEdge, startEdge);\n          edges.add(startEdge);\n          break;\n        }\n      }\n      \n      oneEdge = startEdge;\n      \n      // Verify the structure. \n      //verify();\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a75c862521bb895a29958e7bc5cb188597205a08","date":1459977470,"type":5,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory.EdgeBuffer#EdgeBuffer(List[GeoPoint],BitSet,int,int,SidedPlane).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory.EdgeBuffer#EdgeBuffer(List[GeoPoint],int,int,SidedPlane,boolean).mjava","sourceNew":"    /** Constructor.\n      * @param pointList is the list of points.\n      * @param internalEdges is the list of edges that are internal (includes return edge)\n      * @param startPlaneStartIndex is the index of the startPlane's starting point\n      * @param startPlaneEndIndex is the index of the startPlane's ending point\n      * @param startPlane is the starting plane\n      */\n    public EdgeBuffer(final List<GeoPoint> pointList, final BitSet internalEdges, final int startPlaneStartIndex, final int startPlaneEndIndex, final SidedPlane startPlane) {\n      /*\n      System.out.println(\"Initial points:\");\n      for (final GeoPoint p : pointList) {\n        System.out.println(\" \"+p);\n      }\n      */\n      \n      final Edge startEdge = new Edge(pointList.get(startPlaneStartIndex), pointList.get(startPlaneEndIndex), startPlane, internalEdges.get(startPlaneStartIndex));\n      // Fill in the EdgeBuffer by walking around creating more stuff\n      Edge currentEdge = startEdge;\n      int startIndex = startPlaneStartIndex;\n      int endIndex = startPlaneEndIndex;\n      while (true) {\n        // Compute the next edge\n        startIndex = endIndex;\n        endIndex++;\n        if (endIndex >= pointList.size()) {\n          endIndex -= pointList.size();\n        }\n        // Get the next point\n        final GeoPoint newPoint = pointList.get(endIndex);\n        // Build the new edge\n        final boolean isNewPointWithin = currentEdge.plane.isWithin(newPoint);\n        final SidedPlane newPlane = new SidedPlane(currentEdge.startPoint, isNewPointWithin, pointList.get(startIndex), newPoint);\n        /*\n        System.out.println(\"For next plane, the following points are in/out:\");\n        for (final GeoPoint p: pointList) {\n          System.out.println(\" \"+p+\" is: \"+(newPlane.isWithin(p)?\"in\":\"out\"));\n        }\n        */\n        final Edge newEdge = new Edge(pointList.get(startIndex), pointList.get(endIndex), newPlane, internalEdges.get(startIndex));\n        \n        // Link it in\n        previousEdges.put(newEdge, currentEdge);\n        nextEdges.put(currentEdge, newEdge);\n        edges.add(newEdge);\n        currentEdge = newEdge;\n\n        if (currentEdge.endPoint == startEdge.startPoint) {\n          // We finish here.  Link the current edge to the start edge, and exit\n          previousEdges.put(startEdge, currentEdge);\n          nextEdges.put(currentEdge, startEdge);\n          edges.add(startEdge);\n          break;\n        }\n      }\n      \n      oneEdge = startEdge;\n      \n      // Verify the structure. \n      //verify();\n    }\n\n","sourceOld":"    /** Constructor.\n      * @param pointList is the list of points.\n      * @param startPlaneStartIndex is the index of the startPlane's starting point\n      * @param startPlaneEndIndex is the index of the startPlane's ending point\n      * @param startPlane is the starting plane\n      * @param startPlaneIsInternal signals whether the startPlane is an internal edge\n      */\n    public EdgeBuffer(final List<GeoPoint> pointList, final int startPlaneStartIndex, final int startPlaneEndIndex, final SidedPlane startPlane, final boolean startPlaneIsInternal) {\n      /*\n      System.out.println(\"Initial points:\");\n      for (final GeoPoint p : pointList) {\n        System.out.println(\" \"+p);\n      }\n      System.out.println(\"For start plane, the following points are in/out:\");\n      for (final GeoPoint p: pointList) {\n        System.out.println(\" \"+p+\" is: \"+(startPlane.isWithin(p)?\"in\":\"out\"));\n      }\n      */\n      \n      final Edge startEdge = new Edge(pointList.get(startPlaneStartIndex), pointList.get(startPlaneEndIndex), startPlane, startPlaneIsInternal);\n      // Fill in the EdgeBuffer by walking around creating more stuff\n      Edge currentEdge = startEdge;\n      int startIndex = startPlaneStartIndex;\n      int endIndex = startPlaneEndIndex;\n      boolean isInternal = startPlaneIsInternal;\n      while (true) {\n        // Compute the next edge\n        startIndex = endIndex;\n        endIndex++;\n        if (endIndex >= pointList.size()) {\n          endIndex -= pointList.size();\n        }\n        // Get the next point\n        final GeoPoint newPoint = pointList.get(endIndex);\n        // Build the new edge\n        final boolean isNewPointWithin = currentEdge.plane.isWithin(newPoint);\n        final SidedPlane newPlane = new SidedPlane(currentEdge.startPoint, isNewPointWithin, pointList.get(startIndex), newPoint);\n        /*\n        System.out.println(\"For next plane, the following points are in/out:\");\n        for (final GeoPoint p: pointList) {\n          System.out.println(\" \"+p+\" is: \"+(newPlane.isWithin(p)?\"in\":\"out\"));\n        }\n        */\n        final Edge newEdge = new Edge(pointList.get(startIndex), pointList.get(endIndex), newPlane, false);\n        \n        // Link it in\n        previousEdges.put(newEdge, currentEdge);\n        nextEdges.put(currentEdge, newEdge);\n        edges.add(newEdge);\n        currentEdge = newEdge;\n\n        if (currentEdge.endPoint == startEdge.startPoint) {\n          // We finish here.  Link the current edge to the start edge, and exit\n          previousEdges.put(startEdge, currentEdge);\n          nextEdges.put(currentEdge, startEdge);\n          edges.add(startEdge);\n          break;\n        }\n      }\n      \n      oneEdge = startEdge;\n      \n      // Verify the structure. \n      //verify();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"09af2c9610ce53a4b25fd99344299b40318a4a1a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","edc0b3370cd3844691fb46de50cbc79c2449617e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"40aa98241c87d86a0077beb8023713d93a0becfe":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a75c862521bb895a29958e7bc5cb188597205a08"],"a75c862521bb895a29958e7bc5cb188597205a08":["edc0b3370cd3844691fb46de50cbc79c2449617e"],"edc0b3370cd3844691fb46de50cbc79c2449617e":["40aa98241c87d86a0077beb8023713d93a0becfe"]},"commit2Childs":{"09af2c9610ce53a4b25fd99344299b40318a4a1a":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["09af2c9610ce53a4b25fd99344299b40318a4a1a","40aa98241c87d86a0077beb8023713d93a0becfe"],"40aa98241c87d86a0077beb8023713d93a0becfe":["edc0b3370cd3844691fb46de50cbc79c2449617e"],"edc0b3370cd3844691fb46de50cbc79c2449617e":["09af2c9610ce53a4b25fd99344299b40318a4a1a","a75c862521bb895a29958e7bc5cb188597205a08"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"a75c862521bb895a29958e7bc5cb188597205a08":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["09af2c9610ce53a4b25fd99344299b40318a4a1a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}