{"path":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionMessageHandler#getClusterStatus(ClusterState,ZkNodeProps,NamedList).mjava","commits":[{"id":"e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac","date":1438841252,"type":1,"author":"Gregory Chanan","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionMessageHandler#getClusterStatus(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#getClusterStatus(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  private void getClusterStatus(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) Utils.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = Utils.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) Utils.fromJSON(bytes);\n\n    Set<String> collections = new HashSet<>();\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    if (collection == null) {\n      collections = new HashSet<>(clusterState.getCollections());\n    } else  {\n      collections = Collections.singleton(collection);\n    }\n\n    NamedList<Object> collectionProps = new SimpleOrderedMap<Object>();\n\n    for (String name : collections) {\n      Map<String, Object> collectionStatus = null;\n      DocCollection clusterStateCollection = clusterState.getCollection(name);\n\n      Set<String> requestedShards = new HashSet<>();\n      if (routeKey != null) {\n        DocRouter router = clusterStateCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, clusterStateCollection);\n        for (Slice slice : slices) {\n          requestedShards.add(slice.getName());\n        }\n      }\n      if (shard != null) {\n        requestedShards.add(shard);\n      }\n\n      if (clusterStateCollection.getStateFormat() > 1) {\n        bytes = Utils.toJSON(clusterStateCollection);\n        Map<String, Object> docCollection = (Map<String, Object>) Utils.fromJSON(bytes);\n        collectionStatus = getCollectionStatus(docCollection, name, requestedShards);\n      } else {\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, requestedShards);\n      }\n\n      collectionStatus.put(\"znodeVersion\", clusterStateCollection.getZNodeVersion());\n      if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty()) {\n        collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n      }\n      String configName = zkStateReader.readConfigName(name);\n      collectionStatus.put(\"configName\", configName);\n      collectionProps.add(name, collectionStatus);\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProps();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  private void getClusterStatus(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) Utils.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = Utils.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) Utils.fromJSON(bytes);\n\n    Set<String> collections = new HashSet<>();\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    if (collection == null) {\n      collections = new HashSet<>(clusterState.getCollections());\n    } else  {\n      collections = Collections.singleton(collection);\n    }\n\n    NamedList<Object> collectionProps = new SimpleOrderedMap<Object>();\n\n    for (String name : collections) {\n      Map<String, Object> collectionStatus = null;\n      DocCollection clusterStateCollection = clusterState.getCollection(name);\n\n      Set<String> requestedShards = new HashSet<>();\n      if (routeKey != null) {\n        DocRouter router = clusterStateCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, clusterStateCollection);\n        for (Slice slice : slices) {\n          requestedShards.add(slice.getName());\n        }\n      }\n      if (shard != null) {\n        requestedShards.add(shard);\n      }\n\n      if (clusterStateCollection.getStateFormat() > 1) {\n        bytes = Utils.toJSON(clusterStateCollection);\n        Map<String, Object> docCollection = (Map<String, Object>) Utils.fromJSON(bytes);\n        collectionStatus = getCollectionStatus(docCollection, name, requestedShards);\n      } else {\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, requestedShards);\n      }\n\n      collectionStatus.put(\"znodeVersion\", clusterStateCollection.getZNodeVersion());\n      if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty()) {\n        collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n      }\n      String configName = zkStateReader.readConfigName(name);\n      collectionStatus.put(\"configName\", configName);\n      collectionProps.add(name, collectionStatus);\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProps();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae719a20842b7bdcc71e1e12f14f72044c835047","date":1457006827,"type":4,"author":"Varun Thacker","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionMessageHandler#getClusterStatus(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":null,"sourceOld":"  @SuppressWarnings(\"unchecked\")\n  private void getClusterStatus(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) Utils.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = Utils.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) Utils.fromJSON(bytes);\n\n    Set<String> collections = new HashSet<>();\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    if (collection == null) {\n      collections = new HashSet<>(clusterState.getCollections());\n    } else  {\n      collections = Collections.singleton(collection);\n    }\n\n    NamedList<Object> collectionProps = new SimpleOrderedMap<Object>();\n\n    for (String name : collections) {\n      Map<String, Object> collectionStatus = null;\n      DocCollection clusterStateCollection = clusterState.getCollection(name);\n\n      Set<String> requestedShards = new HashSet<>();\n      if (routeKey != null) {\n        DocRouter router = clusterStateCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, clusterStateCollection);\n        for (Slice slice : slices) {\n          requestedShards.add(slice.getName());\n        }\n      }\n      if (shard != null) {\n        requestedShards.add(shard);\n      }\n\n      if (clusterStateCollection.getStateFormat() > 1) {\n        bytes = Utils.toJSON(clusterStateCollection);\n        Map<String, Object> docCollection = (Map<String, Object>) Utils.fromJSON(bytes);\n        collectionStatus = getCollectionStatus(docCollection, name, requestedShards);\n      } else {\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, requestedShards);\n      }\n\n      collectionStatus.put(\"znodeVersion\", clusterStateCollection.getZNodeVersion());\n      if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty()) {\n        collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n      }\n      String configName = zkStateReader.readConfigName(name);\n      collectionStatus.put(\"configName\", configName);\n      collectionProps.add(name, collectionStatus);\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProps();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cf1a614098b46c9c22afebd7b898ae4d1d2fc273","date":1457088850,"type":4,"author":"Noble Paul","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionMessageHandler#getClusterStatus(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":null,"sourceOld":"  @SuppressWarnings(\"unchecked\")\n  private void getClusterStatus(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n\n    // read aliases\n    Aliases aliases = zkStateReader.getAliases();\n    Map<String, List<String>> collectionVsAliases = new HashMap<>();\n    Map<String, String> aliasVsCollections = aliases.getCollectionAliasMap();\n    if (aliasVsCollections != null) {\n      for (Map.Entry<String, String> entry : aliasVsCollections.entrySet()) {\n        List<String> colls = StrUtils.splitSmart(entry.getValue(), ',');\n        String alias = entry.getKey();\n        for (String coll : colls) {\n          if (collection == null || collection.equals(coll))  {\n            List<String> list = collectionVsAliases.get(coll);\n            if (list == null) {\n              list = new ArrayList<>();\n              collectionVsAliases.put(coll, list);\n            }\n            list.add(alias);\n          }\n        }\n      }\n    }\n\n    Map roles = null;\n    if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {\n      roles = (Map) Utils.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));\n    }\n\n    // convert cluster state into a map of writable types\n    byte[] bytes = Utils.toJSON(clusterState);\n    Map<String, Object> stateMap = (Map<String,Object>) Utils.fromJSON(bytes);\n\n    Set<String> collections = new HashSet<>();\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String shard = message.getStr(ZkStateReader.SHARD_ID_PROP);\n    if (collection == null) {\n      collections = new HashSet<>(clusterState.getCollections());\n    } else  {\n      collections = Collections.singleton(collection);\n    }\n\n    NamedList<Object> collectionProps = new SimpleOrderedMap<Object>();\n\n    for (String name : collections) {\n      Map<String, Object> collectionStatus = null;\n      DocCollection clusterStateCollection = clusterState.getCollection(name);\n\n      Set<String> requestedShards = new HashSet<>();\n      if (routeKey != null) {\n        DocRouter router = clusterStateCollection.getRouter();\n        Collection<Slice> slices = router.getSearchSlices(routeKey, null, clusterStateCollection);\n        for (Slice slice : slices) {\n          requestedShards.add(slice.getName());\n        }\n      }\n      if (shard != null) {\n        requestedShards.add(shard);\n      }\n\n      if (clusterStateCollection.getStateFormat() > 1) {\n        bytes = Utils.toJSON(clusterStateCollection);\n        Map<String, Object> docCollection = (Map<String, Object>) Utils.fromJSON(bytes);\n        collectionStatus = getCollectionStatus(docCollection, name, requestedShards);\n      } else {\n        collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, requestedShards);\n      }\n\n      collectionStatus.put(\"znodeVersion\", clusterStateCollection.getZNodeVersion());\n      if (collectionVsAliases.containsKey(name) && !collectionVsAliases.get(name).isEmpty()) {\n        collectionStatus.put(\"aliases\", collectionVsAliases.get(name));\n      }\n      String configName = zkStateReader.readConfigName(name);\n      collectionStatus.put(\"configName\", configName);\n      collectionProps.add(name, collectionStatus);\n    }\n\n    List<String> liveNodes = zkStateReader.getZkClient().getChildren(ZkStateReader.LIVE_NODES_ZKNODE, null, true);\n\n    // now we need to walk the collectionProps tree to cross-check replica state with live nodes\n    crossCheckReplicaStateWithLiveNodes(liveNodes, collectionProps);\n\n    NamedList<Object> clusterStatus = new SimpleOrderedMap<>();\n    clusterStatus.add(\"collections\", collectionProps);\n\n    // read cluster properties\n    Map clusterProps = zkStateReader.getClusterProps();\n    if (clusterProps != null && !clusterProps.isEmpty())  {\n      clusterStatus.add(\"properties\", clusterProps);\n    }\n\n    // add the alias map too\n    if (aliasVsCollections != null && !aliasVsCollections.isEmpty())  {\n      clusterStatus.add(\"aliases\", aliasVsCollections);\n    }\n\n    // add the roles map\n    if (roles != null)  {\n      clusterStatus.add(\"roles\", roles);\n    }\n\n    // add live_nodes\n    clusterStatus.add(\"live_nodes\", liveNodes);\n\n    results.add(\"cluster\", clusterStatus);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ae719a20842b7bdcc71e1e12f14f72044c835047":["e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac"],"e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac","ae719a20842b7bdcc71e1e12f14f72044c835047"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"]},"commit2Childs":{"ae719a20842b7bdcc71e1e12f14f72044c835047":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac":["ae719a20842b7bdcc71e1e12f14f72044c835047","cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}