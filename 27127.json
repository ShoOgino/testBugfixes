{"path":"lucene/src/test/org/apache/lucene/index/values/TestIndexValues#runTestNumerics(IndexWriterConfig,boolean).mjava","commits":[{"id":"01f60198ece724a6e96cd0b45f289cf42ff83d4f","date":1286864103,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestIndexValues#runTestNumerics(IndexWriterConfig,boolean).mjava","pathOld":"/dev/null","sourceNew":"  public void runTestNumerics(IndexWriterConfig cfg,\n      boolean withDeletions) throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 350;\n    final List<Values> numVariantList = new ArrayList<Values>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (Values val : numVariantList) {\n      OpenBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w);\n      final int numRemainingValues = (int) (numValues - deleted.cardinality());\n      final int base = r.numDocs() - numRemainingValues;\n      switch (val) {\n      case PACKED_INTS:\n      case PACKED_INTS_FIXED: {\n        Reader intsReader = r.getIndexValues(val.name());\n        Source ints = intsReader.load();\n        ValuesEnum intsEnum = intsReader.getEnum();\n        assertNotNull(intsEnum);\n        LongsRef enumRef = intsEnum.addAttribute(ValuesAttribute.class).ints();\n        for (int i = 0; i < base; i++) {\n          assertEquals(0, ints.ints(i));\n          assertEquals(val.name() + \" base: \" + base + \" index: \" + i, i, random.nextBoolean()?intsEnum.advance(i): intsEnum.nextDoc());\n          assertEquals(0, enumRef.get());\n        }\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs() + \" docs\", i, intsEnum.advance(i));\n          assertEquals(expected, ints.ints(i));\n          assertEquals(expected, enumRef.get());\n\n        }\n      }\n        break;\n      case SIMPLE_FLOAT_4BYTE:\n      case SIMPLE_FLOAT_8BYTE: {\n        Reader floatReader = r.getIndexValues(val.name());\n        Source floats = floatReader.load();\n        ValuesEnum floatEnum = floatReader.getEnum();\n        assertNotNull(floatEnum);\n        FloatsRef enumRef = floatEnum.addAttribute(ValuesAttribute.class).floats();\n\n        for (int i = 0; i < base; i++) {\n          assertEquals(0.0d, floats.floats(i), 0.0d);\n          assertEquals(i, random.nextBoolean()?floatEnum.advance(i): floatEnum.nextDoc());\n          assertEquals(\"index \" + i, 0.0 ,enumRef.get(), 0.0);\n        }\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs() + \" docs base:\" + base, i, floatEnum.advance(i));\n          assertEquals(\"index \" + i, 2.0 * expected ,enumRef.get() , 0.00001);\n          assertEquals(\"index \" + i, 2.0 * expected, floats.floats(i), 0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0e28c49f1fb6215a550fdadcf3805aa629b63ec0","date":1288081775,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestIndexValues#runTestNumerics(IndexWriterConfig,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestIndexValues#runTestNumerics(IndexWriterConfig,boolean).mjava","sourceNew":"  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 350;\n    final List<Values> numVariantList = new ArrayList<Values>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (Values val : numVariantList) {\n      OpenBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w);\n      final int numRemainingValues = (int) (numValues - deleted.cardinality());\n      final int base = r.numDocs() - numRemainingValues;\n      switch (val) {\n      case PACKED_INTS:\n      case PACKED_INTS_FIXED: {\n        DocValues intsReader = getDocValues(r, val.name());\n        Source ints = intsReader.load();\n        ValuesEnum intsEnum = intsReader.getEnum();\n        assertNotNull(intsEnum);\n        LongsRef enumRef = intsEnum.addAttribute(ValuesAttribute.class).ints();\n        for (int i = 0; i < base; i++) {\n          assertEquals(0, ints.ints(i));\n          assertEquals(val.name() + \" base: \" + base + \" index: \" + i, i,\n              random.nextBoolean() ? intsEnum.advance(i) : intsEnum.nextDoc());\n          assertEquals(0, enumRef.get());\n        }\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs\", i, intsEnum.advance(i));\n          assertEquals(expected, ints.ints(i));\n          assertEquals(expected, enumRef.get());\n\n        }\n      }\n        break;\n      case SIMPLE_FLOAT_4BYTE:\n      case SIMPLE_FLOAT_8BYTE: {\n        DocValues floatReader = getDocValues(r, val.name());\n        Source floats = floatReader.load();\n        ValuesEnum floatEnum = floatReader.getEnum();\n        assertNotNull(floatEnum);\n        FloatsRef enumRef = floatEnum.addAttribute(ValuesAttribute.class)\n            .floats();\n\n        for (int i = 0; i < base; i++) {\n          assertEquals(0.0d, floats.floats(i), 0.0d);\n          assertEquals(i, random.nextBoolean() ? floatEnum.advance(i)\n              : floatEnum.nextDoc());\n          assertEquals(\"index \" + i, 0.0, enumRef.get(), 0.0);\n        }\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs base:\" + base, i, floatEnum.advance(i));\n          assertEquals(\"index \" + i, 2.0 * expected, enumRef.get(), 0.00001);\n          assertEquals(\"index \" + i, 2.0 * expected, floats.floats(i), 0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","sourceOld":"  public void runTestNumerics(IndexWriterConfig cfg,\n      boolean withDeletions) throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 350;\n    final List<Values> numVariantList = new ArrayList<Values>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (Values val : numVariantList) {\n      OpenBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w);\n      final int numRemainingValues = (int) (numValues - deleted.cardinality());\n      final int base = r.numDocs() - numRemainingValues;\n      switch (val) {\n      case PACKED_INTS:\n      case PACKED_INTS_FIXED: {\n        Reader intsReader = r.getIndexValues(val.name());\n        Source ints = intsReader.load();\n        ValuesEnum intsEnum = intsReader.getEnum();\n        assertNotNull(intsEnum);\n        LongsRef enumRef = intsEnum.addAttribute(ValuesAttribute.class).ints();\n        for (int i = 0; i < base; i++) {\n          assertEquals(0, ints.ints(i));\n          assertEquals(val.name() + \" base: \" + base + \" index: \" + i, i, random.nextBoolean()?intsEnum.advance(i): intsEnum.nextDoc());\n          assertEquals(0, enumRef.get());\n        }\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs() + \" docs\", i, intsEnum.advance(i));\n          assertEquals(expected, ints.ints(i));\n          assertEquals(expected, enumRef.get());\n\n        }\n      }\n        break;\n      case SIMPLE_FLOAT_4BYTE:\n      case SIMPLE_FLOAT_8BYTE: {\n        Reader floatReader = r.getIndexValues(val.name());\n        Source floats = floatReader.load();\n        ValuesEnum floatEnum = floatReader.getEnum();\n        assertNotNull(floatEnum);\n        FloatsRef enumRef = floatEnum.addAttribute(ValuesAttribute.class).floats();\n\n        for (int i = 0; i < base; i++) {\n          assertEquals(0.0d, floats.floats(i), 0.0d);\n          assertEquals(i, random.nextBoolean()?floatEnum.advance(i): floatEnum.nextDoc());\n          assertEquals(\"index \" + i, 0.0 ,enumRef.get(), 0.0);\n        }\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs() + \" docs base:\" + base, i, floatEnum.advance(i));\n          assertEquals(\"index \" + i, 2.0 * expected ,enumRef.get() , 0.00001);\n          assertEquals(\"index \" + i, 2.0 * expected, floats.floats(i), 0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"39f3757037aa8f710c0cbf9a76a332de735f58b0","date":1288384416,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestIndexValues#runTestNumerics(IndexWriterConfig,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestIndexValues#runTestNumerics(IndexWriterConfig,boolean).mjava","sourceNew":"  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 350;\n    final List<Values> numVariantList = new ArrayList<Values>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (Values val : numVariantList) {\n      OpenBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w);\n      final int numRemainingValues = (int) (numValues - deleted.cardinality());\n      final int base = r.numDocs() - numRemainingValues;\n      switch (val) {\n      case PACKED_INTS:\n      case PACKED_INTS_FIXED: {\n        DocValues intsReader = getDocValues(r, val.name());\n        Source ints = getSource(intsReader);\n        ValuesEnum intsEnum = intsReader.getEnum();\n        assertNotNull(intsEnum);\n        LongsRef enumRef = intsEnum.addAttribute(ValuesAttribute.class).ints();\n        for (int i = 0; i < base; i++) {\n          assertEquals(0, ints.getInt(i));\n          assertEquals(val.name() + \" base: \" + base + \" index: \" + i, i,\n              random.nextBoolean() ? intsEnum.advance(i) : intsEnum.nextDoc());\n          assertEquals(0, enumRef.get());\n        }\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs\", i, intsEnum.advance(i));\n          assertEquals(expected, enumRef.get());\n          assertEquals(expected, ints.getInt(i));\n\n        }\n      }\n        break;\n      case SIMPLE_FLOAT_4BYTE:\n      case SIMPLE_FLOAT_8BYTE: {\n        DocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        ValuesEnum floatEnum = floatReader.getEnum();\n        assertNotNull(floatEnum);\n        FloatsRef enumRef = floatEnum.addAttribute(ValuesAttribute.class)\n            .floats();\n\n        for (int i = 0; i < base; i++) {\n          assertEquals(\" floats failed for doc: \" + i + \" base: \" + base, 0.0d,\n              floats.getFloat(i), 0.0d);\n          assertEquals(i, random.nextBoolean() ? floatEnum.advance(i)\n              : floatEnum.nextDoc());\n          assertEquals(\"index \" + i, 0.0, enumRef.get(), 0.0);\n        }\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs base:\" + base, i, floatEnum.advance(i));\n          assertEquals(\"index \" + i, 2.0 * expected, enumRef.get(), 0.00001);\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","sourceOld":"  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 350;\n    final List<Values> numVariantList = new ArrayList<Values>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (Values val : numVariantList) {\n      OpenBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w);\n      final int numRemainingValues = (int) (numValues - deleted.cardinality());\n      final int base = r.numDocs() - numRemainingValues;\n      switch (val) {\n      case PACKED_INTS:\n      case PACKED_INTS_FIXED: {\n        DocValues intsReader = getDocValues(r, val.name());\n        Source ints = intsReader.load();\n        ValuesEnum intsEnum = intsReader.getEnum();\n        assertNotNull(intsEnum);\n        LongsRef enumRef = intsEnum.addAttribute(ValuesAttribute.class).ints();\n        for (int i = 0; i < base; i++) {\n          assertEquals(0, ints.ints(i));\n          assertEquals(val.name() + \" base: \" + base + \" index: \" + i, i,\n              random.nextBoolean() ? intsEnum.advance(i) : intsEnum.nextDoc());\n          assertEquals(0, enumRef.get());\n        }\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs\", i, intsEnum.advance(i));\n          assertEquals(expected, ints.ints(i));\n          assertEquals(expected, enumRef.get());\n\n        }\n      }\n        break;\n      case SIMPLE_FLOAT_4BYTE:\n      case SIMPLE_FLOAT_8BYTE: {\n        DocValues floatReader = getDocValues(r, val.name());\n        Source floats = floatReader.load();\n        ValuesEnum floatEnum = floatReader.getEnum();\n        assertNotNull(floatEnum);\n        FloatsRef enumRef = floatEnum.addAttribute(ValuesAttribute.class)\n            .floats();\n\n        for (int i = 0; i < base; i++) {\n          assertEquals(0.0d, floats.floats(i), 0.0d);\n          assertEquals(i, random.nextBoolean() ? floatEnum.advance(i)\n              : floatEnum.nextDoc());\n          assertEquals(\"index \" + i, 0.0, enumRef.get(), 0.0);\n        }\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs base:\" + base, i, floatEnum.advance(i));\n          assertEquals(\"index \" + i, 2.0 * expected, enumRef.get(), 0.00001);\n          assertEquals(\"index \" + i, 2.0 * expected, floats.floats(i), 0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0637f89202e27b25802435a9cf789fc0890c8a67","date":1288436161,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestIndexValues#runTestNumerics(IndexWriterConfig,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestIndexValues#runTestNumerics(IndexWriterConfig,boolean).mjava","sourceNew":"  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 350;\n    final List<Values> numVariantList = new ArrayList<Values>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (Values val : numVariantList) {\n      OpenBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w);\n      final int numRemainingValues = (int) (numValues - deleted.cardinality());\n      final int base = r.numDocs() - numRemainingValues;\n      switch (val) {\n      case PACKED_INTS:\n      case PACKED_INTS_FIXED: {\n        if(val == Values.PACKED_INTS_FIXED)\n          getDocValues(r, val.name());\n        DocValues intsReader = getDocValues(r, val.name());\n        Source ints = getSource(intsReader);\n        \n        ValuesEnum intsEnum = intsReader.getEnum();\n        assertNotNull(intsEnum);\n        LongsRef enumRef = intsEnum.addAttribute(ValuesAttribute.class).ints();\n        for (int i = 0; i < base; i++) {\n          assertEquals(\"index \" + i, 0, ints.getInt(i));\n          assertEquals(val.name() + \" base: \" + base + \" index: \" + i, i,\n              random.nextBoolean() ? intsEnum.advance(i) : intsEnum.nextDoc());\n          assertEquals(0, enumRef.get());\n        }\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs\", i, intsEnum.advance(i));\n          assertEquals(expected, enumRef.get());\n          assertEquals(expected, ints.getInt(i));\n\n        }\n      }\n        break;\n      case SIMPLE_FLOAT_4BYTE:\n      case SIMPLE_FLOAT_8BYTE: {\n        DocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        ValuesEnum floatEnum = floatReader.getEnum();\n        assertNotNull(floatEnum);\n        FloatsRef enumRef = floatEnum.addAttribute(ValuesAttribute.class)\n            .floats();\n\n        for (int i = 0; i < base; i++) {\n          assertEquals(\" floats failed for doc: \" + i + \" base: \" + base, 0.0d,\n              floats.getFloat(i), 0.0d);\n          assertEquals(i, random.nextBoolean() ? floatEnum.advance(i)\n              : floatEnum.nextDoc());\n          assertEquals(\"index \" + i, 0.0, enumRef.get(), 0.0);\n        }\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs base:\" + base, i, floatEnum.advance(i));\n          assertEquals(\"index \" + i, 2.0 * expected, enumRef.get(), 0.00001);\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","sourceOld":"  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 350;\n    final List<Values> numVariantList = new ArrayList<Values>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (Values val : numVariantList) {\n      OpenBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w);\n      final int numRemainingValues = (int) (numValues - deleted.cardinality());\n      final int base = r.numDocs() - numRemainingValues;\n      switch (val) {\n      case PACKED_INTS:\n      case PACKED_INTS_FIXED: {\n        DocValues intsReader = getDocValues(r, val.name());\n        Source ints = getSource(intsReader);\n        ValuesEnum intsEnum = intsReader.getEnum();\n        assertNotNull(intsEnum);\n        LongsRef enumRef = intsEnum.addAttribute(ValuesAttribute.class).ints();\n        for (int i = 0; i < base; i++) {\n          assertEquals(0, ints.getInt(i));\n          assertEquals(val.name() + \" base: \" + base + \" index: \" + i, i,\n              random.nextBoolean() ? intsEnum.advance(i) : intsEnum.nextDoc());\n          assertEquals(0, enumRef.get());\n        }\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs\", i, intsEnum.advance(i));\n          assertEquals(expected, enumRef.get());\n          assertEquals(expected, ints.getInt(i));\n\n        }\n      }\n        break;\n      case SIMPLE_FLOAT_4BYTE:\n      case SIMPLE_FLOAT_8BYTE: {\n        DocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        ValuesEnum floatEnum = floatReader.getEnum();\n        assertNotNull(floatEnum);\n        FloatsRef enumRef = floatEnum.addAttribute(ValuesAttribute.class)\n            .floats();\n\n        for (int i = 0; i < base; i++) {\n          assertEquals(\" floats failed for doc: \" + i + \" base: \" + base, 0.0d,\n              floats.getFloat(i), 0.0d);\n          assertEquals(i, random.nextBoolean() ? floatEnum.advance(i)\n              : floatEnum.nextDoc());\n          assertEquals(\"index \" + i, 0.0, enumRef.get(), 0.0);\n        }\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs base:\" + base, i, floatEnum.advance(i));\n          assertEquals(\"index \" + i, 2.0 * expected, enumRef.get(), 0.00001);\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"85a883878c0af761245ab048babc63d099f835f3","date":1289553330,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestIndexValues#runTestNumerics(IndexWriterConfig,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestIndexValues#runTestNumerics(IndexWriterConfig,boolean).mjava","sourceNew":"  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 350;\n    final List<Values> numVariantList = new ArrayList<Values>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (Values val : numVariantList) {\n      OpenBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w);\n      final int numRemainingValues = (int) (numValues - deleted.cardinality());\n      final int base = r.numDocs() - numRemainingValues;\n      switch (val) {\n      case PACKED_INTS:\n      case PACKED_INTS_FIXED: {\n        DocValues intsReader = getDocValues(r, val.name());\n        assertNotNull(intsReader);\n\n        Source ints = getSource(intsReader);\n        \n        ValuesEnum intsEnum = intsReader.getEnum();\n        assertNotNull(intsEnum);\n        LongsRef enumRef = intsEnum.addAttribute(ValuesAttribute.class).ints();\n        for (int i = 0; i < base; i++) {\n          assertEquals(\"index \" + i, 0, ints.getInt(i));\n          assertEquals(val.name() + \" base: \" + base + \" index: \" + i, i,\n              random.nextBoolean() ? intsEnum.advance(i) : intsEnum.nextDoc());\n          assertEquals(0, enumRef.get());\n        }\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs\", i, intsEnum.advance(i));\n          assertEquals(expected, enumRef.get());\n          assertEquals(expected, ints.getInt(i));\n\n        }\n      }\n        break;\n      case SIMPLE_FLOAT_4BYTE:\n      case SIMPLE_FLOAT_8BYTE: {\n        DocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        ValuesEnum floatEnum = floatReader.getEnum();\n        assertNotNull(floatEnum);\n        FloatsRef enumRef = floatEnum.addAttribute(ValuesAttribute.class)\n            .floats();\n\n        for (int i = 0; i < base; i++) {\n          assertEquals(\" floats failed for doc: \" + i + \" base: \" + base, 0.0d,\n              floats.getFloat(i), 0.0d);\n          assertEquals(i, random.nextBoolean() ? floatEnum.advance(i)\n              : floatEnum.nextDoc());\n          assertEquals(\"index \" + i, 0.0, enumRef.get(), 0.0);\n        }\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs base:\" + base, i, floatEnum.advance(i));\n          assertEquals(\"index \" + i, 2.0 * expected, enumRef.get(), 0.00001);\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","sourceOld":"  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 350;\n    final List<Values> numVariantList = new ArrayList<Values>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (Values val : numVariantList) {\n      OpenBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w);\n      final int numRemainingValues = (int) (numValues - deleted.cardinality());\n      final int base = r.numDocs() - numRemainingValues;\n      switch (val) {\n      case PACKED_INTS:\n      case PACKED_INTS_FIXED: {\n        if(val == Values.PACKED_INTS_FIXED)\n          getDocValues(r, val.name());\n        DocValues intsReader = getDocValues(r, val.name());\n        Source ints = getSource(intsReader);\n        \n        ValuesEnum intsEnum = intsReader.getEnum();\n        assertNotNull(intsEnum);\n        LongsRef enumRef = intsEnum.addAttribute(ValuesAttribute.class).ints();\n        for (int i = 0; i < base; i++) {\n          assertEquals(\"index \" + i, 0, ints.getInt(i));\n          assertEquals(val.name() + \" base: \" + base + \" index: \" + i, i,\n              random.nextBoolean() ? intsEnum.advance(i) : intsEnum.nextDoc());\n          assertEquals(0, enumRef.get());\n        }\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs\", i, intsEnum.advance(i));\n          assertEquals(expected, enumRef.get());\n          assertEquals(expected, ints.getInt(i));\n\n        }\n      }\n        break;\n      case SIMPLE_FLOAT_4BYTE:\n      case SIMPLE_FLOAT_8BYTE: {\n        DocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        ValuesEnum floatEnum = floatReader.getEnum();\n        assertNotNull(floatEnum);\n        FloatsRef enumRef = floatEnum.addAttribute(ValuesAttribute.class)\n            .floats();\n\n        for (int i = 0; i < base; i++) {\n          assertEquals(\" floats failed for doc: \" + i + \" base: \" + base, 0.0d,\n              floats.getFloat(i), 0.0d);\n          assertEquals(i, random.nextBoolean() ? floatEnum.advance(i)\n              : floatEnum.nextDoc());\n          assertEquals(\"index \" + i, 0.0, enumRef.get(), 0.0);\n        }\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs base:\" + base, i, floatEnum.advance(i));\n          assertEquals(\"index \" + i, 2.0 * expected, enumRef.get(), 0.00001);\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b5c559c875836474bafae7243263d93b1b1965db","date":1289581659,"type":5,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#runTestNumerics(IndexWriterConfig,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestIndexValues#runTestNumerics(IndexWriterConfig,boolean).mjava","sourceNew":"  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 350;\n    final List<Values> numVariantList = new ArrayList<Values>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (Values val : numVariantList) {\n      OpenBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w);\n      final int numRemainingValues = (int) (numValues - deleted.cardinality());\n      final int base = r.numDocs() - numRemainingValues;\n      switch (val) {\n      case PACKED_INTS:\n      case PACKED_INTS_FIXED: {\n        DocValues intsReader = getDocValues(r, val.name());\n        assertNotNull(intsReader);\n\n        Source ints = getSource(intsReader);\n\n        ValuesEnum intsEnum = intsReader.getEnum();\n        assertNotNull(intsEnum);\n        LongsRef enumRef = intsEnum.addAttribute(ValuesAttribute.class).ints();\n        for (int i = 0; i < base; i++) {\n          assertEquals(\"index \" + i, 0, ints.getInt(i));\n          assertEquals(val.name() + \" base: \" + base + \" index: \" + i, i,\n              random.nextBoolean() ? intsEnum.advance(i) : intsEnum.nextDoc());\n          assertEquals(0, enumRef.get());\n        }\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs\", i, intsEnum.advance(i));\n          assertEquals(expected, enumRef.get());\n          assertEquals(expected, ints.getInt(i));\n\n        }\n      }\n        break;\n      case SIMPLE_FLOAT_4BYTE:\n      case SIMPLE_FLOAT_8BYTE: {\n        DocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        ValuesEnum floatEnum = floatReader.getEnum();\n        assertNotNull(floatEnum);\n        FloatsRef enumRef = floatEnum.addAttribute(ValuesAttribute.class)\n            .floats();\n\n        for (int i = 0; i < base; i++) {\n          assertEquals(\" floats failed for doc: \" + i + \" base: \" + base, 0.0d,\n              floats.getFloat(i), 0.0d);\n          assertEquals(i, random.nextBoolean() ? floatEnum.advance(i)\n              : floatEnum.nextDoc());\n          assertEquals(\"index \" + i, 0.0, enumRef.get(), 0.0);\n        }\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs base:\" + base, i, floatEnum.advance(i));\n          assertEquals(\"index \" + i, 2.0 * expected, enumRef.get(), 0.00001);\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","sourceOld":"  public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)\n      throws IOException {\n    Directory d = newDirectory();\n    IndexWriter w = new IndexWriter(d, cfg);\n    final int numValues = 350;\n    final List<Values> numVariantList = new ArrayList<Values>(NUMERICS);\n\n    // run in random order to test if fill works correctly during merges\n    Collections.shuffle(numVariantList, random);\n    for (Values val : numVariantList) {\n      OpenBitSet deleted = indexValues(w, numValues, val, numVariantList,\n          withDeletions, 7);\n      List<Closeable> closeables = new ArrayList<Closeable>();\n      IndexReader r = IndexReader.open(w);\n      final int numRemainingValues = (int) (numValues - deleted.cardinality());\n      final int base = r.numDocs() - numRemainingValues;\n      switch (val) {\n      case PACKED_INTS:\n      case PACKED_INTS_FIXED: {\n        DocValues intsReader = getDocValues(r, val.name());\n        assertNotNull(intsReader);\n\n        Source ints = getSource(intsReader);\n        \n        ValuesEnum intsEnum = intsReader.getEnum();\n        assertNotNull(intsEnum);\n        LongsRef enumRef = intsEnum.addAttribute(ValuesAttribute.class).ints();\n        for (int i = 0; i < base; i++) {\n          assertEquals(\"index \" + i, 0, ints.getInt(i));\n          assertEquals(val.name() + \" base: \" + base + \" index: \" + i, i,\n              random.nextBoolean() ? intsEnum.advance(i) : intsEnum.nextDoc());\n          assertEquals(0, enumRef.get());\n        }\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs\", i, intsEnum.advance(i));\n          assertEquals(expected, enumRef.get());\n          assertEquals(expected, ints.getInt(i));\n\n        }\n      }\n        break;\n      case SIMPLE_FLOAT_4BYTE:\n      case SIMPLE_FLOAT_8BYTE: {\n        DocValues floatReader = getDocValues(r, val.name());\n        assertNotNull(floatReader);\n        Source floats = getSource(floatReader);\n        ValuesEnum floatEnum = floatReader.getEnum();\n        assertNotNull(floatEnum);\n        FloatsRef enumRef = floatEnum.addAttribute(ValuesAttribute.class)\n            .floats();\n\n        for (int i = 0; i < base; i++) {\n          assertEquals(\" floats failed for doc: \" + i + \" base: \" + base, 0.0d,\n              floats.getFloat(i), 0.0d);\n          assertEquals(i, random.nextBoolean() ? floatEnum.advance(i)\n              : floatEnum.nextDoc());\n          assertEquals(\"index \" + i, 0.0, enumRef.get(), 0.0);\n        }\n        int expected = 0;\n        for (int i = base; i < r.numDocs(); i++, expected++) {\n          while (deleted.get(expected)) {\n            expected++;\n          }\n          assertEquals(\"advance failed at index: \" + i + \" of \" + r.numDocs()\n              + \" docs base:\" + base, i, floatEnum.advance(i));\n          assertEquals(\"index \" + i, 2.0 * expected, enumRef.get(), 0.00001);\n          assertEquals(\"index \" + i, 2.0 * expected, floats.getFloat(i),\n              0.00001);\n        }\n      }\n        break;\n      default:\n        fail(\"unexpected value \" + val);\n      }\n\n      closeables.add(r);\n      for (Closeable toClose : closeables) {\n        toClose.close();\n      }\n    }\n    w.close();\n    d.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"39f3757037aa8f710c0cbf9a76a332de735f58b0":["0e28c49f1fb6215a550fdadcf3805aa629b63ec0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"85a883878c0af761245ab048babc63d099f835f3":["0637f89202e27b25802435a9cf789fc0890c8a67","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0637f89202e27b25802435a9cf789fc0890c8a67":["39f3757037aa8f710c0cbf9a76a332de735f58b0"],"0e28c49f1fb6215a550fdadcf3805aa629b63ec0":["01f60198ece724a6e96cd0b45f289cf42ff83d4f"],"01f60198ece724a6e96cd0b45f289cf42ff83d4f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b5c559c875836474bafae7243263d93b1b1965db":["85a883878c0af761245ab048babc63d099f835f3"]},"commit2Childs":{"39f3757037aa8f710c0cbf9a76a332de735f58b0":["0637f89202e27b25802435a9cf789fc0890c8a67"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["85a883878c0af761245ab048babc63d099f835f3","01f60198ece724a6e96cd0b45f289cf42ff83d4f","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"85a883878c0af761245ab048babc63d099f835f3":["b5c559c875836474bafae7243263d93b1b1965db"],"0e28c49f1fb6215a550fdadcf3805aa629b63ec0":["39f3757037aa8f710c0cbf9a76a332de735f58b0"],"0637f89202e27b25802435a9cf789fc0890c8a67":["85a883878c0af761245ab048babc63d099f835f3"],"01f60198ece724a6e96cd0b45f289cf42ff83d4f":["0e28c49f1fb6215a550fdadcf3805aa629b63ec0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b5c559c875836474bafae7243263d93b1b1965db":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","b5c559c875836474bafae7243263d93b1b1965db"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}