{"path":"solr/core/src/java/org/apache/solr/util/ConcurrentLRUCache#markAndSweep().mjava","commits":[{"id":"cf0b1b21012d341c80a1f3975cf88823f0fe95a9","date":1316016056,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/ConcurrentLRUCache#markAndSweep().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/util/ConcurrentLRUCache#markAndSweep().mjava","sourceNew":"  /**\n   * Removes items from the cache to bring the size down\n   * to an acceptable value ('acceptableWaterMark').\n   * <p/>\n   * It is done in two stages. In the first stage, least recently used items are evicted.\n   * If, after the first stage, the cache size is still greater than 'acceptableSize'\n   * config parameter, the second stage takes over.\n   * <p/>\n   * The second stage is more intensive and tries to bring down the cache size\n   * to the 'lowerWaterMark' config parameter.\n   */\n  private void markAndSweep() {\n    // if we want to keep at least 1000 entries, then timestamps of\n    // current through current-1000 are guaranteed not to be the oldest (but that does\n    // not mean there are 1000 entries in that group... it's acutally anywhere between\n    // 1 and 1000).\n    // Also, if we want to remove 500 entries, then\n    // oldestEntry through oldestEntry+500 are guaranteed to be\n    // removed (however many there are there).\n\n    if (!markAndSweepLock.tryLock()) return;\n    try {\n      long oldestEntry = this.oldestEntry;\n      isCleaning = true;\n      this.oldestEntry = oldestEntry;     // volatile write to make isCleaning visible\n\n      long timeCurrent = stats.accessCounter.get();\n      int sz = stats.size.get();\n\n      int numRemoved = 0;\n      int numKept = 0;\n      long newestEntry = timeCurrent;\n      long newNewestEntry = -1;\n      long newOldestEntry = Long.MAX_VALUE;\n\n      int wantToKeep = lowerWaterMark;\n      int wantToRemove = sz - lowerWaterMark;\n\n      @SuppressWarnings(\"unchecked\") // generic array's are anoying\n      CacheEntry<K,V>[] eset = new CacheEntry[sz];\n      int eSize = 0;\n\n      // System.out.println(\"newestEntry=\"+newestEntry + \" oldestEntry=\"+oldestEntry);\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n\n      for (CacheEntry<K,V> ce : map.values()) {\n        // set lastAccessedCopy to avoid more volatile reads\n        ce.lastAccessedCopy = ce.lastAccessed;\n        long thisEntry = ce.lastAccessedCopy;\n\n        // since the wantToKeep group is likely to be bigger than wantToRemove, check it first\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing.\n          numKept++;\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it from the map.\n          evictEntry(ce.key);\n          numRemoved++;\n        } else {\n          // This entry *could* be in the bottom group.\n          // Collect these entries to avoid another full pass... this is wasted\n          // effort if enough entries are normally removed in this first pass.\n          // An alternate impl could make a full second pass.\n          if (eSize < eset.length-1) {\n            eset[eSize++] = ce;\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n      }\n\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      // TODO: allow this to be customized in the constructor?\n      int numPasses=1; // maximum number of linear passes over the data\n\n      // if we didn't remove enough entries, then make more passes\n      // over the values we collected, with updated min and max values.\n      while (sz - numRemoved > acceptableWaterMark && --numPasses>=0) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        // iterate backward to make it easy to remove items.\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // remove the entry by moving the last element to it's position\n            eset[i] = eset[eSize-1];\n            eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it from the map.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // remove the entry by moving the last element to it's position\n            eset[i] = eset[eSize-1];\n            eSize--;\n          } else {\n            // This entry *could* be in the bottom group, so keep it in the eset,\n            // and update the stats.\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n\n\n      // if we still didn't remove enough entries, then make another pass while\n      // inserting into a priority queue\n      if (sz - numRemoved > acceptableWaterMark) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        PQueue<K,V> queue = new PQueue<K,V>(wantToRemove);\n\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) {  // entry in bottom group?\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n          } else {\n            // This entry *could* be in the bottom group.\n            // add it to the priority queue\n\n            // everything in the priority queue will be removed, so keep track of\n            // the lowest value that ever comes back out of the queue.\n\n            // first reduce the size of the priority queue to account for\n            // the number of items we have already removed while executing\n            // this loop so far.\n            queue.myMaxSize = sz - lowerWaterMark - numRemoved;\n            while (queue.size() > queue.myMaxSize && queue.size() > 0) {\n              CacheEntry otherEntry = (CacheEntry) queue.pop();\n              newOldestEntry = Math.min(otherEntry.lastAccessedCopy, newOldestEntry);\n            }\n            if (queue.myMaxSize <= 0) break;\n\n            Object o = queue.myInsertWithOverflow(ce);\n            if (o != null) {\n              newOldestEntry = Math.min(((CacheEntry)o).lastAccessedCopy, newOldestEntry);\n            }\n          }\n        }\n\n        // Now delete everything in the priority queue.\n        // avoid using pop() since order doesn't matter anymore\n        for (CacheEntry<K,V> ce : queue.getValues()) {\n          if (ce==null) continue;\n          evictEntry(ce.key);\n          numRemoved++;\n        }\n\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" initialQueueSize=\"+ wantToRemove + \" finalQueueSize=\" + queue.size() + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n      oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n      this.oldestEntry = oldestEntry;\n    } finally {\n      isCleaning = false;  // set before markAndSweep.unlock() for visibility\n      markAndSweepLock.unlock();\n    }\n  }\n\n","sourceOld":"  /**\n   * Removes items from the cache to bring the size down\n   * to an acceptable value ('acceptableWaterMark').\n   * <p/>\n   * It is done in two stages. In the first stage, least recently used items are evicted.\n   * If, after the first stage, the cache size is still greater than 'acceptableSize'\n   * config parameter, the second stage takes over.\n   * <p/>\n   * The second stage is more intensive and tries to bring down the cache size\n   * to the 'lowerWaterMark' config parameter.\n   */\n  private void markAndSweep() {\n    // if we want to keep at least 1000 entries, then timestamps of\n    // current through current-1000 are guaranteed not to be the oldest (but that does\n    // not mean there are 1000 entries in that group... it's acutally anywhere between\n    // 1 and 1000).\n    // Also, if we want to remove 500 entries, then\n    // oldestEntry through oldestEntry+500 are guaranteed to be\n    // removed (however many there are there).\n\n    if (!markAndSweepLock.tryLock()) return;\n    try {\n      long oldestEntry = this.oldestEntry;\n      isCleaning = true;\n      this.oldestEntry = oldestEntry;     // volatile write to make isCleaning visible\n\n      long timeCurrent = stats.accessCounter.get();\n      int sz = stats.size.get();\n\n      int numRemoved = 0;\n      int numKept = 0;\n      long newestEntry = timeCurrent;\n      long newNewestEntry = -1;\n      long newOldestEntry = Long.MAX_VALUE;\n\n      int wantToKeep = lowerWaterMark;\n      int wantToRemove = sz - lowerWaterMark;\n\n      @SuppressWarnings(\"unchecked\") // generic array's are anoying\n      CacheEntry<K,V>[] eset = new CacheEntry[sz];\n      int eSize = 0;\n\n      // System.out.println(\"newestEntry=\"+newestEntry + \" oldestEntry=\"+oldestEntry);\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n\n      for (CacheEntry<K,V> ce : map.values()) {\n        // set lastAccessedCopy to avoid more volatile reads\n        ce.lastAccessedCopy = ce.lastAccessed;\n        long thisEntry = ce.lastAccessedCopy;\n\n        // since the wantToKeep group is likely to be bigger than wantToRemove, check it first\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing.\n          numKept++;\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it from the map.\n          evictEntry(ce.key);\n          numRemoved++;\n        } else {\n          // This entry *could* be in the bottom group.\n          // Collect these entries to avoid another full pass... this is wasted\n          // effort if enough entries are normally removed in this first pass.\n          // An alternate impl could make a full second pass.\n          if (eSize < eset.length-1) {\n            eset[eSize++] = ce;\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n      }\n\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      // TODO: allow this to be customized in the constructor?\n      int numPasses=1; // maximum number of linear passes over the data\n\n      // if we didn't remove enough entries, then make more passes\n      // over the values we collected, with updated min and max values.\n      while (sz - numRemoved > acceptableWaterMark && --numPasses>=0) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        // iterate backward to make it easy to remove items.\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // remove the entry by moving the last element to it's position\n            eset[i] = eset[eSize-1];\n            eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it from the map.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // remove the entry by moving the last element to it's position\n            eset[i] = eset[eSize-1];\n            eSize--;\n          } else {\n            // This entry *could* be in the bottom group, so keep it in the eset,\n            // and update the stats.\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n\n\n      // if we still didn't remove enough entries, then make another pass while\n      // inserting into a priority queue\n      if (sz - numRemoved > acceptableWaterMark) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        PQueue<K,V> queue = new PQueue<K,V>(wantToRemove);\n\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) {  // entry in bottom group?\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n          } else {\n            // This entry *could* be in the bottom group.\n            // add it to the priority queue\n\n            // everything in the priority queue will be removed, so keep track of\n            // the lowest value that ever comes back out of the queue.\n\n            // first reduce the size of the priority queue to account for\n            // the number of items we have already removed while executing\n            // this loop so far.\n            queue.myMaxSize = sz - lowerWaterMark - numRemoved;\n            while (queue.size() > queue.myMaxSize && queue.size() > 0) {\n              CacheEntry otherEntry = (CacheEntry) queue.pop();\n              newOldestEntry = Math.min(otherEntry.lastAccessedCopy, newOldestEntry);\n            }\n            if (queue.myMaxSize <= 0) break;\n\n            Object o = queue.myInsertWithOverflow(ce);\n            if (o != null) {\n              newOldestEntry = Math.min(((CacheEntry)o).lastAccessedCopy, newOldestEntry);\n            }\n          }\n        }\n\n        // Now delete everything in the priority queue.\n        // avoid using pop() since order doesn't matter anymore\n        for (CacheEntry<K,V> ce : queue.getValues()) {\n          if (ce==null) continue;\n          evictEntry(ce.key);\n          numRemoved++;\n        }\n\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" initialQueueSize=\"+ wantToRemove + \" finalQueueSize=\" + queue.size() + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n      oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n      this.oldestEntry = oldestEntry;\n    } finally {\n      isCleaning = false;  // set before markAndSweep.unlock() for visibility\n      markAndSweepLock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"399d5903979ca52514d2bc7e3a362e1c45885c94","date":1333042474,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/ConcurrentLRUCache#markAndSweep().mjava","pathOld":"solr/core/src/java/org/apache/solr/util/ConcurrentLRUCache#markAndSweep().mjava","sourceNew":"  /**\n   * Removes items from the cache to bring the size down\n   * to an acceptable value ('acceptableWaterMark').\n   * <p/>\n   * It is done in two stages. In the first stage, least recently used items are evicted.\n   * If, after the first stage, the cache size is still greater than 'acceptableSize'\n   * config parameter, the second stage takes over.\n   * <p/>\n   * The second stage is more intensive and tries to bring down the cache size\n   * to the 'lowerWaterMark' config parameter.\n   */\n  private void markAndSweep() {\n    // if we want to keep at least 1000 entries, then timestamps of\n    // current through current-1000 are guaranteed not to be the oldest (but that does\n    // not mean there are 1000 entries in that group... it's acutally anywhere between\n    // 1 and 1000).\n    // Also, if we want to remove 500 entries, then\n    // oldestEntry through oldestEntry+500 are guaranteed to be\n    // removed (however many there are there).\n\n    if (!markAndSweepLock.tryLock()) return;\n    try {\n      long oldestEntry = this.oldestEntry;\n      isCleaning = true;\n      this.oldestEntry = oldestEntry;     // volatile write to make isCleaning visible\n\n      long timeCurrent = stats.accessCounter.get();\n      int sz = stats.size.get();\n\n      int numRemoved = 0;\n      int numKept = 0;\n      long newestEntry = timeCurrent;\n      long newNewestEntry = -1;\n      long newOldestEntry = Long.MAX_VALUE;\n\n      int wantToKeep = lowerWaterMark;\n      int wantToRemove = sz - lowerWaterMark;\n\n      @SuppressWarnings(\"unchecked\") // generic array's are anoying\n      CacheEntry<K,V>[] eset = new CacheEntry[sz];\n      int eSize = 0;\n\n      // System.out.println(\"newestEntry=\"+newestEntry + \" oldestEntry=\"+oldestEntry);\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n\n      for (CacheEntry<K,V> ce : map.values()) {\n        // set lastAccessedCopy to avoid more volatile reads\n        ce.lastAccessedCopy = ce.lastAccessed;\n        long thisEntry = ce.lastAccessedCopy;\n\n        // since the wantToKeep group is likely to be bigger than wantToRemove, check it first\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing.\n          numKept++;\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it from the map.\n          evictEntry(ce.key);\n          numRemoved++;\n        } else {\n          // This entry *could* be in the bottom group.\n          // Collect these entries to avoid another full pass... this is wasted\n          // effort if enough entries are normally removed in this first pass.\n          // An alternate impl could make a full second pass.\n          if (eSize < eset.length-1) {\n            eset[eSize++] = ce;\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n      }\n\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      // TODO: allow this to be customized in the constructor?\n      int numPasses=1; // maximum number of linear passes over the data\n\n      // if we didn't remove enough entries, then make more passes\n      // over the values we collected, with updated min and max values.\n      while (sz - numRemoved > acceptableWaterMark && --numPasses>=0) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        // iterate backward to make it easy to remove items.\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // remove the entry by moving the last element to it's position\n            eset[i] = eset[eSize-1];\n            eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it from the map.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // remove the entry by moving the last element to it's position\n            eset[i] = eset[eSize-1];\n            eSize--;\n          } else {\n            // This entry *could* be in the bottom group, so keep it in the eset,\n            // and update the stats.\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n\n\n      // if we still didn't remove enough entries, then make another pass while\n      // inserting into a priority queue\n      if (sz - numRemoved > acceptableWaterMark) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        PQueue<K,V> queue = new PQueue<K,V>(wantToRemove);\n\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) {  // entry in bottom group?\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n          } else {\n            // This entry *could* be in the bottom group.\n            // add it to the priority queue\n\n            // everything in the priority queue will be removed, so keep track of\n            // the lowest value that ever comes back out of the queue.\n\n            // first reduce the size of the priority queue to account for\n            // the number of items we have already removed while executing\n            // this loop so far.\n            queue.myMaxSize = sz - lowerWaterMark - numRemoved;\n            while (queue.size() > queue.myMaxSize && queue.size() > 0) {\n              CacheEntry otherEntry = queue.pop();\n              newOldestEntry = Math.min(otherEntry.lastAccessedCopy, newOldestEntry);\n            }\n            if (queue.myMaxSize <= 0) break;\n\n            Object o = queue.myInsertWithOverflow(ce);\n            if (o != null) {\n              newOldestEntry = Math.min(((CacheEntry)o).lastAccessedCopy, newOldestEntry);\n            }\n          }\n        }\n\n        // Now delete everything in the priority queue.\n        // avoid using pop() since order doesn't matter anymore\n        for (CacheEntry<K,V> ce : queue.getValues()) {\n          if (ce==null) continue;\n          evictEntry(ce.key);\n          numRemoved++;\n        }\n\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" initialQueueSize=\"+ wantToRemove + \" finalQueueSize=\" + queue.size() + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n      oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n      this.oldestEntry = oldestEntry;\n    } finally {\n      isCleaning = false;  // set before markAndSweep.unlock() for visibility\n      markAndSweepLock.unlock();\n    }\n  }\n\n","sourceOld":"  /**\n   * Removes items from the cache to bring the size down\n   * to an acceptable value ('acceptableWaterMark').\n   * <p/>\n   * It is done in two stages. In the first stage, least recently used items are evicted.\n   * If, after the first stage, the cache size is still greater than 'acceptableSize'\n   * config parameter, the second stage takes over.\n   * <p/>\n   * The second stage is more intensive and tries to bring down the cache size\n   * to the 'lowerWaterMark' config parameter.\n   */\n  private void markAndSweep() {\n    // if we want to keep at least 1000 entries, then timestamps of\n    // current through current-1000 are guaranteed not to be the oldest (but that does\n    // not mean there are 1000 entries in that group... it's acutally anywhere between\n    // 1 and 1000).\n    // Also, if we want to remove 500 entries, then\n    // oldestEntry through oldestEntry+500 are guaranteed to be\n    // removed (however many there are there).\n\n    if (!markAndSweepLock.tryLock()) return;\n    try {\n      long oldestEntry = this.oldestEntry;\n      isCleaning = true;\n      this.oldestEntry = oldestEntry;     // volatile write to make isCleaning visible\n\n      long timeCurrent = stats.accessCounter.get();\n      int sz = stats.size.get();\n\n      int numRemoved = 0;\n      int numKept = 0;\n      long newestEntry = timeCurrent;\n      long newNewestEntry = -1;\n      long newOldestEntry = Long.MAX_VALUE;\n\n      int wantToKeep = lowerWaterMark;\n      int wantToRemove = sz - lowerWaterMark;\n\n      @SuppressWarnings(\"unchecked\") // generic array's are anoying\n      CacheEntry<K,V>[] eset = new CacheEntry[sz];\n      int eSize = 0;\n\n      // System.out.println(\"newestEntry=\"+newestEntry + \" oldestEntry=\"+oldestEntry);\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n\n      for (CacheEntry<K,V> ce : map.values()) {\n        // set lastAccessedCopy to avoid more volatile reads\n        ce.lastAccessedCopy = ce.lastAccessed;\n        long thisEntry = ce.lastAccessedCopy;\n\n        // since the wantToKeep group is likely to be bigger than wantToRemove, check it first\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing.\n          numKept++;\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it from the map.\n          evictEntry(ce.key);\n          numRemoved++;\n        } else {\n          // This entry *could* be in the bottom group.\n          // Collect these entries to avoid another full pass... this is wasted\n          // effort if enough entries are normally removed in this first pass.\n          // An alternate impl could make a full second pass.\n          if (eSize < eset.length-1) {\n            eset[eSize++] = ce;\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n      }\n\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      // TODO: allow this to be customized in the constructor?\n      int numPasses=1; // maximum number of linear passes over the data\n\n      // if we didn't remove enough entries, then make more passes\n      // over the values we collected, with updated min and max values.\n      while (sz - numRemoved > acceptableWaterMark && --numPasses>=0) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        // iterate backward to make it easy to remove items.\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // remove the entry by moving the last element to it's position\n            eset[i] = eset[eSize-1];\n            eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it from the map.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // remove the entry by moving the last element to it's position\n            eset[i] = eset[eSize-1];\n            eSize--;\n          } else {\n            // This entry *could* be in the bottom group, so keep it in the eset,\n            // and update the stats.\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n\n\n      // if we still didn't remove enough entries, then make another pass while\n      // inserting into a priority queue\n      if (sz - numRemoved > acceptableWaterMark) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        PQueue<K,V> queue = new PQueue<K,V>(wantToRemove);\n\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) {  // entry in bottom group?\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n          } else {\n            // This entry *could* be in the bottom group.\n            // add it to the priority queue\n\n            // everything in the priority queue will be removed, so keep track of\n            // the lowest value that ever comes back out of the queue.\n\n            // first reduce the size of the priority queue to account for\n            // the number of items we have already removed while executing\n            // this loop so far.\n            queue.myMaxSize = sz - lowerWaterMark - numRemoved;\n            while (queue.size() > queue.myMaxSize && queue.size() > 0) {\n              CacheEntry otherEntry = (CacheEntry) queue.pop();\n              newOldestEntry = Math.min(otherEntry.lastAccessedCopy, newOldestEntry);\n            }\n            if (queue.myMaxSize <= 0) break;\n\n            Object o = queue.myInsertWithOverflow(ce);\n            if (o != null) {\n              newOldestEntry = Math.min(((CacheEntry)o).lastAccessedCopy, newOldestEntry);\n            }\n          }\n        }\n\n        // Now delete everything in the priority queue.\n        // avoid using pop() since order doesn't matter anymore\n        for (CacheEntry<K,V> ce : queue.getValues()) {\n          if (ce==null) continue;\n          evictEntry(ce.key);\n          numRemoved++;\n        }\n\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" initialQueueSize=\"+ wantToRemove + \" finalQueueSize=\" + queue.size() + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n      oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n      this.oldestEntry = oldestEntry;\n    } finally {\n      isCleaning = false;  // set before markAndSweep.unlock() for visibility\n      markAndSweepLock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/ConcurrentLRUCache#markAndSweep().mjava","pathOld":"solr/core/src/java/org/apache/solr/util/ConcurrentLRUCache#markAndSweep().mjava","sourceNew":"  /**\n   * Removes items from the cache to bring the size down\n   * to an acceptable value ('acceptableWaterMark').\n   * <p/>\n   * It is done in two stages. In the first stage, least recently used items are evicted.\n   * If, after the first stage, the cache size is still greater than 'acceptableSize'\n   * config parameter, the second stage takes over.\n   * <p/>\n   * The second stage is more intensive and tries to bring down the cache size\n   * to the 'lowerWaterMark' config parameter.\n   */\n  private void markAndSweep() {\n    // if we want to keep at least 1000 entries, then timestamps of\n    // current through current-1000 are guaranteed not to be the oldest (but that does\n    // not mean there are 1000 entries in that group... it's acutally anywhere between\n    // 1 and 1000).\n    // Also, if we want to remove 500 entries, then\n    // oldestEntry through oldestEntry+500 are guaranteed to be\n    // removed (however many there are there).\n\n    if (!markAndSweepLock.tryLock()) return;\n    try {\n      long oldestEntry = this.oldestEntry;\n      isCleaning = true;\n      this.oldestEntry = oldestEntry;     // volatile write to make isCleaning visible\n\n      long timeCurrent = stats.accessCounter.get();\n      int sz = stats.size.get();\n\n      int numRemoved = 0;\n      int numKept = 0;\n      long newestEntry = timeCurrent;\n      long newNewestEntry = -1;\n      long newOldestEntry = Long.MAX_VALUE;\n\n      int wantToKeep = lowerWaterMark;\n      int wantToRemove = sz - lowerWaterMark;\n\n      @SuppressWarnings(\"unchecked\") // generic array's are anoying\n      CacheEntry<K,V>[] eset = new CacheEntry[sz];\n      int eSize = 0;\n\n      // System.out.println(\"newestEntry=\"+newestEntry + \" oldestEntry=\"+oldestEntry);\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n\n      for (CacheEntry<K,V> ce : map.values()) {\n        // set lastAccessedCopy to avoid more volatile reads\n        ce.lastAccessedCopy = ce.lastAccessed;\n        long thisEntry = ce.lastAccessedCopy;\n\n        // since the wantToKeep group is likely to be bigger than wantToRemove, check it first\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing.\n          numKept++;\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it from the map.\n          evictEntry(ce.key);\n          numRemoved++;\n        } else {\n          // This entry *could* be in the bottom group.\n          // Collect these entries to avoid another full pass... this is wasted\n          // effort if enough entries are normally removed in this first pass.\n          // An alternate impl could make a full second pass.\n          if (eSize < eset.length-1) {\n            eset[eSize++] = ce;\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n      }\n\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      // TODO: allow this to be customized in the constructor?\n      int numPasses=1; // maximum number of linear passes over the data\n\n      // if we didn't remove enough entries, then make more passes\n      // over the values we collected, with updated min and max values.\n      while (sz - numRemoved > acceptableWaterMark && --numPasses>=0) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        // iterate backward to make it easy to remove items.\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // remove the entry by moving the last element to it's position\n            eset[i] = eset[eSize-1];\n            eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it from the map.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // remove the entry by moving the last element to it's position\n            eset[i] = eset[eSize-1];\n            eSize--;\n          } else {\n            // This entry *could* be in the bottom group, so keep it in the eset,\n            // and update the stats.\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n\n\n      // if we still didn't remove enough entries, then make another pass while\n      // inserting into a priority queue\n      if (sz - numRemoved > acceptableWaterMark) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        PQueue<K,V> queue = new PQueue<>(wantToRemove);\n\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) {  // entry in bottom group?\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n          } else {\n            // This entry *could* be in the bottom group.\n            // add it to the priority queue\n\n            // everything in the priority queue will be removed, so keep track of\n            // the lowest value that ever comes back out of the queue.\n\n            // first reduce the size of the priority queue to account for\n            // the number of items we have already removed while executing\n            // this loop so far.\n            queue.myMaxSize = sz - lowerWaterMark - numRemoved;\n            while (queue.size() > queue.myMaxSize && queue.size() > 0) {\n              CacheEntry otherEntry = queue.pop();\n              newOldestEntry = Math.min(otherEntry.lastAccessedCopy, newOldestEntry);\n            }\n            if (queue.myMaxSize <= 0) break;\n\n            Object o = queue.myInsertWithOverflow(ce);\n            if (o != null) {\n              newOldestEntry = Math.min(((CacheEntry)o).lastAccessedCopy, newOldestEntry);\n            }\n          }\n        }\n\n        // Now delete everything in the priority queue.\n        // avoid using pop() since order doesn't matter anymore\n        for (CacheEntry<K,V> ce : queue.getValues()) {\n          if (ce==null) continue;\n          evictEntry(ce.key);\n          numRemoved++;\n        }\n\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" initialQueueSize=\"+ wantToRemove + \" finalQueueSize=\" + queue.size() + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n      oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n      this.oldestEntry = oldestEntry;\n    } finally {\n      isCleaning = false;  // set before markAndSweep.unlock() for visibility\n      markAndSweepLock.unlock();\n    }\n  }\n\n","sourceOld":"  /**\n   * Removes items from the cache to bring the size down\n   * to an acceptable value ('acceptableWaterMark').\n   * <p/>\n   * It is done in two stages. In the first stage, least recently used items are evicted.\n   * If, after the first stage, the cache size is still greater than 'acceptableSize'\n   * config parameter, the second stage takes over.\n   * <p/>\n   * The second stage is more intensive and tries to bring down the cache size\n   * to the 'lowerWaterMark' config parameter.\n   */\n  private void markAndSweep() {\n    // if we want to keep at least 1000 entries, then timestamps of\n    // current through current-1000 are guaranteed not to be the oldest (but that does\n    // not mean there are 1000 entries in that group... it's acutally anywhere between\n    // 1 and 1000).\n    // Also, if we want to remove 500 entries, then\n    // oldestEntry through oldestEntry+500 are guaranteed to be\n    // removed (however many there are there).\n\n    if (!markAndSweepLock.tryLock()) return;\n    try {\n      long oldestEntry = this.oldestEntry;\n      isCleaning = true;\n      this.oldestEntry = oldestEntry;     // volatile write to make isCleaning visible\n\n      long timeCurrent = stats.accessCounter.get();\n      int sz = stats.size.get();\n\n      int numRemoved = 0;\n      int numKept = 0;\n      long newestEntry = timeCurrent;\n      long newNewestEntry = -1;\n      long newOldestEntry = Long.MAX_VALUE;\n\n      int wantToKeep = lowerWaterMark;\n      int wantToRemove = sz - lowerWaterMark;\n\n      @SuppressWarnings(\"unchecked\") // generic array's are anoying\n      CacheEntry<K,V>[] eset = new CacheEntry[sz];\n      int eSize = 0;\n\n      // System.out.println(\"newestEntry=\"+newestEntry + \" oldestEntry=\"+oldestEntry);\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n\n      for (CacheEntry<K,V> ce : map.values()) {\n        // set lastAccessedCopy to avoid more volatile reads\n        ce.lastAccessedCopy = ce.lastAccessed;\n        long thisEntry = ce.lastAccessedCopy;\n\n        // since the wantToKeep group is likely to be bigger than wantToRemove, check it first\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing.\n          numKept++;\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it from the map.\n          evictEntry(ce.key);\n          numRemoved++;\n        } else {\n          // This entry *could* be in the bottom group.\n          // Collect these entries to avoid another full pass... this is wasted\n          // effort if enough entries are normally removed in this first pass.\n          // An alternate impl could make a full second pass.\n          if (eSize < eset.length-1) {\n            eset[eSize++] = ce;\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n      }\n\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      // TODO: allow this to be customized in the constructor?\n      int numPasses=1; // maximum number of linear passes over the data\n\n      // if we didn't remove enough entries, then make more passes\n      // over the values we collected, with updated min and max values.\n      while (sz - numRemoved > acceptableWaterMark && --numPasses>=0) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        // iterate backward to make it easy to remove items.\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // remove the entry by moving the last element to it's position\n            eset[i] = eset[eSize-1];\n            eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it from the map.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // remove the entry by moving the last element to it's position\n            eset[i] = eset[eSize-1];\n            eSize--;\n          } else {\n            // This entry *could* be in the bottom group, so keep it in the eset,\n            // and update the stats.\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n\n\n      // if we still didn't remove enough entries, then make another pass while\n      // inserting into a priority queue\n      if (sz - numRemoved > acceptableWaterMark) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        PQueue<K,V> queue = new PQueue<K,V>(wantToRemove);\n\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) {  // entry in bottom group?\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n          } else {\n            // This entry *could* be in the bottom group.\n            // add it to the priority queue\n\n            // everything in the priority queue will be removed, so keep track of\n            // the lowest value that ever comes back out of the queue.\n\n            // first reduce the size of the priority queue to account for\n            // the number of items we have already removed while executing\n            // this loop so far.\n            queue.myMaxSize = sz - lowerWaterMark - numRemoved;\n            while (queue.size() > queue.myMaxSize && queue.size() > 0) {\n              CacheEntry otherEntry = queue.pop();\n              newOldestEntry = Math.min(otherEntry.lastAccessedCopy, newOldestEntry);\n            }\n            if (queue.myMaxSize <= 0) break;\n\n            Object o = queue.myInsertWithOverflow(ce);\n            if (o != null) {\n              newOldestEntry = Math.min(((CacheEntry)o).lastAccessedCopy, newOldestEntry);\n            }\n          }\n        }\n\n        // Now delete everything in the priority queue.\n        // avoid using pop() since order doesn't matter anymore\n        for (CacheEntry<K,V> ce : queue.getValues()) {\n          if (ce==null) continue;\n          evictEntry(ce.key);\n          numRemoved++;\n        }\n\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" initialQueueSize=\"+ wantToRemove + \" finalQueueSize=\" + queue.size() + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n      oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n      this.oldestEntry = oldestEntry;\n    } finally {\n      isCleaning = false;  // set before markAndSweep.unlock() for visibility\n      markAndSweepLock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1","date":1419400138,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/ConcurrentLRUCache#markAndSweep().mjava","pathOld":"solr/core/src/java/org/apache/solr/util/ConcurrentLRUCache#markAndSweep().mjava","sourceNew":"  /**\n   * Removes items from the cache to bring the size down\n   * to an acceptable value ('acceptableWaterMark').\n   * <p/>\n   * It is done in two stages. In the first stage, least recently used items are evicted.\n   * If, after the first stage, the cache size is still greater than 'acceptableSize'\n   * config parameter, the second stage takes over.\n   * <p/>\n   * The second stage is more intensive and tries to bring down the cache size\n   * to the 'lowerWaterMark' config parameter.\n   */\n  private void markAndSweep() {\n    // if we want to keep at least 1000 entries, then timestamps of\n    // current through current-1000 are guaranteed not to be the oldest (but that does\n    // not mean there are 1000 entries in that group... it's acutally anywhere between\n    // 1 and 1000).\n    // Also, if we want to remove 500 entries, then\n    // oldestEntry through oldestEntry+500 are guaranteed to be\n    // removed (however many there are there).\n\n    if (!markAndSweepLock.tryLock()) return;\n    try {\n      long oldestEntry = this.oldestEntry;\n      isCleaning = true;\n      this.oldestEntry = oldestEntry;     // volatile write to make isCleaning visible\n\n      long timeCurrent = stats.accessCounter.get();\n      int sz = stats.size.get();\n\n      int numRemoved = 0;\n      int numKept = 0;\n      long newestEntry = timeCurrent;\n      long newNewestEntry = -1;\n      long newOldestEntry = Long.MAX_VALUE;\n\n      int wantToKeep = lowerWaterMark;\n      int wantToRemove = sz - lowerWaterMark;\n\n      @SuppressWarnings(\"unchecked\") // generic array's are anoying\n      CacheEntry<K,V>[] eset = new CacheEntry[sz];\n      int eSize = 0;\n\n      // System.out.println(\"newestEntry=\"+newestEntry + \" oldestEntry=\"+oldestEntry);\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n\n      for (CacheEntry<K,V> ce : map.values()) {\n        // set lastAccessedCopy to avoid more volatile reads\n        ce.lastAccessedCopy = ce.lastAccessed;\n        long thisEntry = ce.lastAccessedCopy;\n\n        // since the wantToKeep group is likely to be bigger than wantToRemove, check it first\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing.\n          numKept++;\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it from the map.\n          evictEntry(ce.key);\n          numRemoved++;\n        } else {\n          // This entry *could* be in the bottom group.\n          // Collect these entries to avoid another full pass... this is wasted\n          // effort if enough entries are normally removed in this first pass.\n          // An alternate impl could make a full second pass.\n          if (eSize < eset.length-1) {\n            eset[eSize++] = ce;\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n      }\n\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      // TODO: allow this to be customized in the constructor?\n      int numPasses=1; // maximum number of linear passes over the data\n\n      // if we didn't remove enough entries, then make more passes\n      // over the values we collected, with updated min and max values.\n      while (sz - numRemoved > acceptableWaterMark && --numPasses>=0) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        // iterate backward to make it easy to remove items.\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // remove the entry by moving the last element to its position\n            eset[i] = eset[eSize-1];\n            eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it from the map.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // remove the entry by moving the last element to its position\n            eset[i] = eset[eSize-1];\n            eSize--;\n          } else {\n            // This entry *could* be in the bottom group, so keep it in the eset,\n            // and update the stats.\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n\n\n      // if we still didn't remove enough entries, then make another pass while\n      // inserting into a priority queue\n      if (sz - numRemoved > acceptableWaterMark) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        PQueue<K,V> queue = new PQueue<>(wantToRemove);\n\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) {  // entry in bottom group?\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n          } else {\n            // This entry *could* be in the bottom group.\n            // add it to the priority queue\n\n            // everything in the priority queue will be removed, so keep track of\n            // the lowest value that ever comes back out of the queue.\n\n            // first reduce the size of the priority queue to account for\n            // the number of items we have already removed while executing\n            // this loop so far.\n            queue.myMaxSize = sz - lowerWaterMark - numRemoved;\n            while (queue.size() > queue.myMaxSize && queue.size() > 0) {\n              CacheEntry otherEntry = queue.pop();\n              newOldestEntry = Math.min(otherEntry.lastAccessedCopy, newOldestEntry);\n            }\n            if (queue.myMaxSize <= 0) break;\n\n            Object o = queue.myInsertWithOverflow(ce);\n            if (o != null) {\n              newOldestEntry = Math.min(((CacheEntry)o).lastAccessedCopy, newOldestEntry);\n            }\n          }\n        }\n\n        // Now delete everything in the priority queue.\n        // avoid using pop() since order doesn't matter anymore\n        for (CacheEntry<K,V> ce : queue.getValues()) {\n          if (ce==null) continue;\n          evictEntry(ce.key);\n          numRemoved++;\n        }\n\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" initialQueueSize=\"+ wantToRemove + \" finalQueueSize=\" + queue.size() + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n      oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n      this.oldestEntry = oldestEntry;\n    } finally {\n      isCleaning = false;  // set before markAndSweep.unlock() for visibility\n      markAndSweepLock.unlock();\n    }\n  }\n\n","sourceOld":"  /**\n   * Removes items from the cache to bring the size down\n   * to an acceptable value ('acceptableWaterMark').\n   * <p/>\n   * It is done in two stages. In the first stage, least recently used items are evicted.\n   * If, after the first stage, the cache size is still greater than 'acceptableSize'\n   * config parameter, the second stage takes over.\n   * <p/>\n   * The second stage is more intensive and tries to bring down the cache size\n   * to the 'lowerWaterMark' config parameter.\n   */\n  private void markAndSweep() {\n    // if we want to keep at least 1000 entries, then timestamps of\n    // current through current-1000 are guaranteed not to be the oldest (but that does\n    // not mean there are 1000 entries in that group... it's acutally anywhere between\n    // 1 and 1000).\n    // Also, if we want to remove 500 entries, then\n    // oldestEntry through oldestEntry+500 are guaranteed to be\n    // removed (however many there are there).\n\n    if (!markAndSweepLock.tryLock()) return;\n    try {\n      long oldestEntry = this.oldestEntry;\n      isCleaning = true;\n      this.oldestEntry = oldestEntry;     // volatile write to make isCleaning visible\n\n      long timeCurrent = stats.accessCounter.get();\n      int sz = stats.size.get();\n\n      int numRemoved = 0;\n      int numKept = 0;\n      long newestEntry = timeCurrent;\n      long newNewestEntry = -1;\n      long newOldestEntry = Long.MAX_VALUE;\n\n      int wantToKeep = lowerWaterMark;\n      int wantToRemove = sz - lowerWaterMark;\n\n      @SuppressWarnings(\"unchecked\") // generic array's are anoying\n      CacheEntry<K,V>[] eset = new CacheEntry[sz];\n      int eSize = 0;\n\n      // System.out.println(\"newestEntry=\"+newestEntry + \" oldestEntry=\"+oldestEntry);\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n\n      for (CacheEntry<K,V> ce : map.values()) {\n        // set lastAccessedCopy to avoid more volatile reads\n        ce.lastAccessedCopy = ce.lastAccessed;\n        long thisEntry = ce.lastAccessedCopy;\n\n        // since the wantToKeep group is likely to be bigger than wantToRemove, check it first\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing.\n          numKept++;\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it from the map.\n          evictEntry(ce.key);\n          numRemoved++;\n        } else {\n          // This entry *could* be in the bottom group.\n          // Collect these entries to avoid another full pass... this is wasted\n          // effort if enough entries are normally removed in this first pass.\n          // An alternate impl could make a full second pass.\n          if (eSize < eset.length-1) {\n            eset[eSize++] = ce;\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n      }\n\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      // TODO: allow this to be customized in the constructor?\n      int numPasses=1; // maximum number of linear passes over the data\n\n      // if we didn't remove enough entries, then make more passes\n      // over the values we collected, with updated min and max values.\n      while (sz - numRemoved > acceptableWaterMark && --numPasses>=0) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        // iterate backward to make it easy to remove items.\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // remove the entry by moving the last element to it's position\n            eset[i] = eset[eSize-1];\n            eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it from the map.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // remove the entry by moving the last element to it's position\n            eset[i] = eset[eSize-1];\n            eSize--;\n          } else {\n            // This entry *could* be in the bottom group, so keep it in the eset,\n            // and update the stats.\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n\n\n      // if we still didn't remove enough entries, then make another pass while\n      // inserting into a priority queue\n      if (sz - numRemoved > acceptableWaterMark) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        PQueue<K,V> queue = new PQueue<>(wantToRemove);\n\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) {  // entry in bottom group?\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n          } else {\n            // This entry *could* be in the bottom group.\n            // add it to the priority queue\n\n            // everything in the priority queue will be removed, so keep track of\n            // the lowest value that ever comes back out of the queue.\n\n            // first reduce the size of the priority queue to account for\n            // the number of items we have already removed while executing\n            // this loop so far.\n            queue.myMaxSize = sz - lowerWaterMark - numRemoved;\n            while (queue.size() > queue.myMaxSize && queue.size() > 0) {\n              CacheEntry otherEntry = queue.pop();\n              newOldestEntry = Math.min(otherEntry.lastAccessedCopy, newOldestEntry);\n            }\n            if (queue.myMaxSize <= 0) break;\n\n            Object o = queue.myInsertWithOverflow(ce);\n            if (o != null) {\n              newOldestEntry = Math.min(((CacheEntry)o).lastAccessedCopy, newOldestEntry);\n            }\n          }\n        }\n\n        // Now delete everything in the priority queue.\n        // avoid using pop() since order doesn't matter anymore\n        for (CacheEntry<K,V> ce : queue.getValues()) {\n          if (ce==null) continue;\n          evictEntry(ce.key);\n          numRemoved++;\n        }\n\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" initialQueueSize=\"+ wantToRemove + \" finalQueueSize=\" + queue.size() + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n      oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n      this.oldestEntry = oldestEntry;\n    } finally {\n      isCleaning = false;  // set before markAndSweep.unlock() for visibility\n      markAndSweepLock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"310f3f20b324aca4933c1fc4261b19bfe3bc3322","date":1428729280,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/ConcurrentLRUCache#markAndSweep().mjava","pathOld":"solr/core/src/java/org/apache/solr/util/ConcurrentLRUCache#markAndSweep().mjava","sourceNew":"  /**\n   * Removes items from the cache to bring the size down\n   * to an acceptable value ('acceptableWaterMark').\n   * <p/>\n   * It is done in two stages. In the first stage, least recently used items are evicted.\n   * If, after the first stage, the cache size is still greater than 'acceptableSize'\n   * config parameter, the second stage takes over.\n   * <p/>\n   * The second stage is more intensive and tries to bring down the cache size\n   * to the 'lowerWaterMark' config parameter.\n   */\n  private void markAndSweep() {\n    // if we want to keep at least 1000 entries, then timestamps of\n    // current through current-1000 are guaranteed not to be the oldest (but that does\n    // not mean there are 1000 entries in that group... it's actually anywhere between\n    // 1 and 1000).\n    // Also, if we want to remove 500 entries, then\n    // oldestEntry through oldestEntry+500 are guaranteed to be\n    // removed (however many there are there).\n\n    if (!markAndSweepLock.tryLock()) return;\n    try {\n      long oldestEntry = this.oldestEntry;\n      isCleaning = true;\n      this.oldestEntry = oldestEntry;     // volatile write to make isCleaning visible\n\n      long timeCurrent = stats.accessCounter.get();\n      int sz = stats.size.get();\n\n      int numRemoved = 0;\n      int numKept = 0;\n      long newestEntry = timeCurrent;\n      long newNewestEntry = -1;\n      long newOldestEntry = Long.MAX_VALUE;\n\n      int wantToKeep = lowerWaterMark;\n      int wantToRemove = sz - lowerWaterMark;\n\n      @SuppressWarnings(\"unchecked\") // generic array's are annoying\n      CacheEntry<K,V>[] eset = new CacheEntry[sz];\n      int eSize = 0;\n\n      // System.out.println(\"newestEntry=\"+newestEntry + \" oldestEntry=\"+oldestEntry);\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n\n      for (CacheEntry<K,V> ce : map.values()) {\n        // set lastAccessedCopy to avoid more volatile reads\n        ce.lastAccessedCopy = ce.lastAccessed;\n        long thisEntry = ce.lastAccessedCopy;\n\n        // since the wantToKeep group is likely to be bigger than wantToRemove, check it first\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing.\n          numKept++;\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it from the map.\n          evictEntry(ce.key);\n          numRemoved++;\n        } else {\n          // This entry *could* be in the bottom group.\n          // Collect these entries to avoid another full pass... this is wasted\n          // effort if enough entries are normally removed in this first pass.\n          // An alternate impl could make a full second pass.\n          if (eSize < eset.length-1) {\n            eset[eSize++] = ce;\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n      }\n\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      // TODO: allow this to be customized in the constructor?\n      int numPasses=1; // maximum number of linear passes over the data\n\n      // if we didn't remove enough entries, then make more passes\n      // over the values we collected, with updated min and max values.\n      while (sz - numRemoved > acceptableWaterMark && --numPasses>=0) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        // iterate backward to make it easy to remove items.\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // remove the entry by moving the last element to its position\n            eset[i] = eset[eSize-1];\n            eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it from the map.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // remove the entry by moving the last element to its position\n            eset[i] = eset[eSize-1];\n            eSize--;\n          } else {\n            // This entry *could* be in the bottom group, so keep it in the eset,\n            // and update the stats.\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n\n\n      // if we still didn't remove enough entries, then make another pass while\n      // inserting into a priority queue\n      if (sz - numRemoved > acceptableWaterMark) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        PQueue<K,V> queue = new PQueue<>(wantToRemove);\n\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) {  // entry in bottom group?\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n          } else {\n            // This entry *could* be in the bottom group.\n            // add it to the priority queue\n\n            // everything in the priority queue will be removed, so keep track of\n            // the lowest value that ever comes back out of the queue.\n\n            // first reduce the size of the priority queue to account for\n            // the number of items we have already removed while executing\n            // this loop so far.\n            queue.myMaxSize = sz - lowerWaterMark - numRemoved;\n            while (queue.size() > queue.myMaxSize && queue.size() > 0) {\n              CacheEntry otherEntry = queue.pop();\n              newOldestEntry = Math.min(otherEntry.lastAccessedCopy, newOldestEntry);\n            }\n            if (queue.myMaxSize <= 0) break;\n\n            Object o = queue.myInsertWithOverflow(ce);\n            if (o != null) {\n              newOldestEntry = Math.min(((CacheEntry)o).lastAccessedCopy, newOldestEntry);\n            }\n          }\n        }\n\n        // Now delete everything in the priority queue.\n        // avoid using pop() since order doesn't matter anymore\n        for (CacheEntry<K,V> ce : queue.getValues()) {\n          if (ce==null) continue;\n          evictEntry(ce.key);\n          numRemoved++;\n        }\n\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" initialQueueSize=\"+ wantToRemove + \" finalQueueSize=\" + queue.size() + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n      oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n      this.oldestEntry = oldestEntry;\n    } finally {\n      isCleaning = false;  // set before markAndSweep.unlock() for visibility\n      markAndSweepLock.unlock();\n    }\n  }\n\n","sourceOld":"  /**\n   * Removes items from the cache to bring the size down\n   * to an acceptable value ('acceptableWaterMark').\n   * <p/>\n   * It is done in two stages. In the first stage, least recently used items are evicted.\n   * If, after the first stage, the cache size is still greater than 'acceptableSize'\n   * config parameter, the second stage takes over.\n   * <p/>\n   * The second stage is more intensive and tries to bring down the cache size\n   * to the 'lowerWaterMark' config parameter.\n   */\n  private void markAndSweep() {\n    // if we want to keep at least 1000 entries, then timestamps of\n    // current through current-1000 are guaranteed not to be the oldest (but that does\n    // not mean there are 1000 entries in that group... it's acutally anywhere between\n    // 1 and 1000).\n    // Also, if we want to remove 500 entries, then\n    // oldestEntry through oldestEntry+500 are guaranteed to be\n    // removed (however many there are there).\n\n    if (!markAndSweepLock.tryLock()) return;\n    try {\n      long oldestEntry = this.oldestEntry;\n      isCleaning = true;\n      this.oldestEntry = oldestEntry;     // volatile write to make isCleaning visible\n\n      long timeCurrent = stats.accessCounter.get();\n      int sz = stats.size.get();\n\n      int numRemoved = 0;\n      int numKept = 0;\n      long newestEntry = timeCurrent;\n      long newNewestEntry = -1;\n      long newOldestEntry = Long.MAX_VALUE;\n\n      int wantToKeep = lowerWaterMark;\n      int wantToRemove = sz - lowerWaterMark;\n\n      @SuppressWarnings(\"unchecked\") // generic array's are anoying\n      CacheEntry<K,V>[] eset = new CacheEntry[sz];\n      int eSize = 0;\n\n      // System.out.println(\"newestEntry=\"+newestEntry + \" oldestEntry=\"+oldestEntry);\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n\n      for (CacheEntry<K,V> ce : map.values()) {\n        // set lastAccessedCopy to avoid more volatile reads\n        ce.lastAccessedCopy = ce.lastAccessed;\n        long thisEntry = ce.lastAccessedCopy;\n\n        // since the wantToKeep group is likely to be bigger than wantToRemove, check it first\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing.\n          numKept++;\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it from the map.\n          evictEntry(ce.key);\n          numRemoved++;\n        } else {\n          // This entry *could* be in the bottom group.\n          // Collect these entries to avoid another full pass... this is wasted\n          // effort if enough entries are normally removed in this first pass.\n          // An alternate impl could make a full second pass.\n          if (eSize < eset.length-1) {\n            eset[eSize++] = ce;\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n      }\n\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      // TODO: allow this to be customized in the constructor?\n      int numPasses=1; // maximum number of linear passes over the data\n\n      // if we didn't remove enough entries, then make more passes\n      // over the values we collected, with updated min and max values.\n      while (sz - numRemoved > acceptableWaterMark && --numPasses>=0) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        // iterate backward to make it easy to remove items.\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // remove the entry by moving the last element to its position\n            eset[i] = eset[eSize-1];\n            eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it from the map.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // remove the entry by moving the last element to its position\n            eset[i] = eset[eSize-1];\n            eSize--;\n          } else {\n            // This entry *could* be in the bottom group, so keep it in the eset,\n            // and update the stats.\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n\n\n      // if we still didn't remove enough entries, then make another pass while\n      // inserting into a priority queue\n      if (sz - numRemoved > acceptableWaterMark) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        PQueue<K,V> queue = new PQueue<>(wantToRemove);\n\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) {  // entry in bottom group?\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n          } else {\n            // This entry *could* be in the bottom group.\n            // add it to the priority queue\n\n            // everything in the priority queue will be removed, so keep track of\n            // the lowest value that ever comes back out of the queue.\n\n            // first reduce the size of the priority queue to account for\n            // the number of items we have already removed while executing\n            // this loop so far.\n            queue.myMaxSize = sz - lowerWaterMark - numRemoved;\n            while (queue.size() > queue.myMaxSize && queue.size() > 0) {\n              CacheEntry otherEntry = queue.pop();\n              newOldestEntry = Math.min(otherEntry.lastAccessedCopy, newOldestEntry);\n            }\n            if (queue.myMaxSize <= 0) break;\n\n            Object o = queue.myInsertWithOverflow(ce);\n            if (o != null) {\n              newOldestEntry = Math.min(((CacheEntry)o).lastAccessedCopy, newOldestEntry);\n            }\n          }\n        }\n\n        // Now delete everything in the priority queue.\n        // avoid using pop() since order doesn't matter anymore\n        for (CacheEntry<K,V> ce : queue.getValues()) {\n          if (ce==null) continue;\n          evictEntry(ce.key);\n          numRemoved++;\n        }\n\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" initialQueueSize=\"+ wantToRemove + \" finalQueueSize=\" + queue.size() + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n      oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n      this.oldestEntry = oldestEntry;\n    } finally {\n      isCleaning = false;  // set before markAndSweep.unlock() for visibility\n      markAndSweepLock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bc0fbfa191179ae7a0081ee1cf7da0464bcd8078","date":1469530061,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/ConcurrentLRUCache#markAndSweep().mjava","pathOld":"solr/core/src/java/org/apache/solr/util/ConcurrentLRUCache#markAndSweep().mjava","sourceNew":"  /**\n   * Removes items from the cache to bring the size down\n   * to an acceptable value ('acceptableWaterMark').\n   * <p/>\n   * It is done in two stages. In the first stage, least recently used items are evicted.\n   * If, after the first stage, the cache size is still greater than 'acceptableSize'\n   * config parameter, the second stage takes over.\n   * <p/>\n   * The second stage is more intensive and tries to bring down the cache size\n   * to the 'lowerWaterMark' config parameter.\n   */\n  private void markAndSweep() {\n    // if we want to keep at least 1000 entries, then timestamps of\n    // current through current-1000 are guaranteed not to be the oldest (but that does\n    // not mean there are 1000 entries in that group... it's actually anywhere between\n    // 1 and 1000).\n    // Also, if we want to remove 500 entries, then\n    // oldestEntry through oldestEntry+500 are guaranteed to be\n    // removed (however many there are there).\n\n    if (!markAndSweepLock.tryLock()) return;\n    try {\n      long oldestEntry = this.oldestEntry;\n      isCleaning = true;\n      this.oldestEntry = oldestEntry;     // volatile write to make isCleaning visible\n\n      long timeCurrent = stats.accessCounter.longValue();\n      int sz = stats.size.get();\n\n      int numRemoved = 0;\n      int numKept = 0;\n      long newestEntry = timeCurrent;\n      long newNewestEntry = -1;\n      long newOldestEntry = Long.MAX_VALUE;\n\n      int wantToKeep = lowerWaterMark;\n      int wantToRemove = sz - lowerWaterMark;\n\n      @SuppressWarnings(\"unchecked\") // generic array's are annoying\n      CacheEntry<K,V>[] eset = new CacheEntry[sz];\n      int eSize = 0;\n\n      // System.out.println(\"newestEntry=\"+newestEntry + \" oldestEntry=\"+oldestEntry);\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n\n      for (CacheEntry<K,V> ce : map.values()) {\n        // set lastAccessedCopy to avoid more volatile reads\n        ce.lastAccessedCopy = ce.lastAccessed;\n        long thisEntry = ce.lastAccessedCopy;\n\n        // since the wantToKeep group is likely to be bigger than wantToRemove, check it first\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing.\n          numKept++;\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it from the map.\n          evictEntry(ce.key);\n          numRemoved++;\n        } else {\n          // This entry *could* be in the bottom group.\n          // Collect these entries to avoid another full pass... this is wasted\n          // effort if enough entries are normally removed in this first pass.\n          // An alternate impl could make a full second pass.\n          if (eSize < eset.length-1) {\n            eset[eSize++] = ce;\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n      }\n\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      // TODO: allow this to be customized in the constructor?\n      int numPasses=1; // maximum number of linear passes over the data\n\n      // if we didn't remove enough entries, then make more passes\n      // over the values we collected, with updated min and max values.\n      while (sz - numRemoved > acceptableWaterMark && --numPasses>=0) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        // iterate backward to make it easy to remove items.\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // remove the entry by moving the last element to its position\n            eset[i] = eset[eSize-1];\n            eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it from the map.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // remove the entry by moving the last element to its position\n            eset[i] = eset[eSize-1];\n            eSize--;\n          } else {\n            // This entry *could* be in the bottom group, so keep it in the eset,\n            // and update the stats.\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n\n\n      // if we still didn't remove enough entries, then make another pass while\n      // inserting into a priority queue\n      if (sz - numRemoved > acceptableWaterMark) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        PQueue<K,V> queue = new PQueue<>(wantToRemove);\n\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) {  // entry in bottom group?\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n          } else {\n            // This entry *could* be in the bottom group.\n            // add it to the priority queue\n\n            // everything in the priority queue will be removed, so keep track of\n            // the lowest value that ever comes back out of the queue.\n\n            // first reduce the size of the priority queue to account for\n            // the number of items we have already removed while executing\n            // this loop so far.\n            queue.myMaxSize = sz - lowerWaterMark - numRemoved;\n            while (queue.size() > queue.myMaxSize && queue.size() > 0) {\n              CacheEntry otherEntry = queue.pop();\n              newOldestEntry = Math.min(otherEntry.lastAccessedCopy, newOldestEntry);\n            }\n            if (queue.myMaxSize <= 0) break;\n\n            Object o = queue.myInsertWithOverflow(ce);\n            if (o != null) {\n              newOldestEntry = Math.min(((CacheEntry)o).lastAccessedCopy, newOldestEntry);\n            }\n          }\n        }\n\n        // Now delete everything in the priority queue.\n        // avoid using pop() since order doesn't matter anymore\n        for (CacheEntry<K,V> ce : queue.getValues()) {\n          if (ce==null) continue;\n          evictEntry(ce.key);\n          numRemoved++;\n        }\n\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" initialQueueSize=\"+ wantToRemove + \" finalQueueSize=\" + queue.size() + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n      oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n      this.oldestEntry = oldestEntry;\n    } finally {\n      isCleaning = false;  // set before markAndSweep.unlock() for visibility\n      markAndSweepLock.unlock();\n    }\n  }\n\n","sourceOld":"  /**\n   * Removes items from the cache to bring the size down\n   * to an acceptable value ('acceptableWaterMark').\n   * <p/>\n   * It is done in two stages. In the first stage, least recently used items are evicted.\n   * If, after the first stage, the cache size is still greater than 'acceptableSize'\n   * config parameter, the second stage takes over.\n   * <p/>\n   * The second stage is more intensive and tries to bring down the cache size\n   * to the 'lowerWaterMark' config parameter.\n   */\n  private void markAndSweep() {\n    // if we want to keep at least 1000 entries, then timestamps of\n    // current through current-1000 are guaranteed not to be the oldest (but that does\n    // not mean there are 1000 entries in that group... it's actually anywhere between\n    // 1 and 1000).\n    // Also, if we want to remove 500 entries, then\n    // oldestEntry through oldestEntry+500 are guaranteed to be\n    // removed (however many there are there).\n\n    if (!markAndSweepLock.tryLock()) return;\n    try {\n      long oldestEntry = this.oldestEntry;\n      isCleaning = true;\n      this.oldestEntry = oldestEntry;     // volatile write to make isCleaning visible\n\n      long timeCurrent = stats.accessCounter.get();\n      int sz = stats.size.get();\n\n      int numRemoved = 0;\n      int numKept = 0;\n      long newestEntry = timeCurrent;\n      long newNewestEntry = -1;\n      long newOldestEntry = Long.MAX_VALUE;\n\n      int wantToKeep = lowerWaterMark;\n      int wantToRemove = sz - lowerWaterMark;\n\n      @SuppressWarnings(\"unchecked\") // generic array's are annoying\n      CacheEntry<K,V>[] eset = new CacheEntry[sz];\n      int eSize = 0;\n\n      // System.out.println(\"newestEntry=\"+newestEntry + \" oldestEntry=\"+oldestEntry);\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n\n      for (CacheEntry<K,V> ce : map.values()) {\n        // set lastAccessedCopy to avoid more volatile reads\n        ce.lastAccessedCopy = ce.lastAccessed;\n        long thisEntry = ce.lastAccessedCopy;\n\n        // since the wantToKeep group is likely to be bigger than wantToRemove, check it first\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing.\n          numKept++;\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it from the map.\n          evictEntry(ce.key);\n          numRemoved++;\n        } else {\n          // This entry *could* be in the bottom group.\n          // Collect these entries to avoid another full pass... this is wasted\n          // effort if enough entries are normally removed in this first pass.\n          // An alternate impl could make a full second pass.\n          if (eSize < eset.length-1) {\n            eset[eSize++] = ce;\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n      }\n\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      // TODO: allow this to be customized in the constructor?\n      int numPasses=1; // maximum number of linear passes over the data\n\n      // if we didn't remove enough entries, then make more passes\n      // over the values we collected, with updated min and max values.\n      while (sz - numRemoved > acceptableWaterMark && --numPasses>=0) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        // iterate backward to make it easy to remove items.\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // remove the entry by moving the last element to its position\n            eset[i] = eset[eSize-1];\n            eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it from the map.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // remove the entry by moving the last element to its position\n            eset[i] = eset[eSize-1];\n            eSize--;\n          } else {\n            // This entry *could* be in the bottom group, so keep it in the eset,\n            // and update the stats.\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n\n\n      // if we still didn't remove enough entries, then make another pass while\n      // inserting into a priority queue\n      if (sz - numRemoved > acceptableWaterMark) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        PQueue<K,V> queue = new PQueue<>(wantToRemove);\n\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) {  // entry in bottom group?\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n          } else {\n            // This entry *could* be in the bottom group.\n            // add it to the priority queue\n\n            // everything in the priority queue will be removed, so keep track of\n            // the lowest value that ever comes back out of the queue.\n\n            // first reduce the size of the priority queue to account for\n            // the number of items we have already removed while executing\n            // this loop so far.\n            queue.myMaxSize = sz - lowerWaterMark - numRemoved;\n            while (queue.size() > queue.myMaxSize && queue.size() > 0) {\n              CacheEntry otherEntry = queue.pop();\n              newOldestEntry = Math.min(otherEntry.lastAccessedCopy, newOldestEntry);\n            }\n            if (queue.myMaxSize <= 0) break;\n\n            Object o = queue.myInsertWithOverflow(ce);\n            if (o != null) {\n              newOldestEntry = Math.min(((CacheEntry)o).lastAccessedCopy, newOldestEntry);\n            }\n          }\n        }\n\n        // Now delete everything in the priority queue.\n        // avoid using pop() since order doesn't matter anymore\n        for (CacheEntry<K,V> ce : queue.getValues()) {\n          if (ce==null) continue;\n          evictEntry(ce.key);\n          numRemoved++;\n        }\n\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" initialQueueSize=\"+ wantToRemove + \" finalQueueSize=\" + queue.size() + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n      oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n      this.oldestEntry = oldestEntry;\n    } finally {\n      isCleaning = false;  // set before markAndSweep.unlock() for visibility\n      markAndSweepLock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3b013574eedcdbac35dc7e35b0ee616ffc38895d","date":1470897818,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/util/ConcurrentLRUCache#markAndSweep().mjava","pathOld":"solr/core/src/java/org/apache/solr/util/ConcurrentLRUCache#markAndSweep().mjava","sourceNew":"  /**\n   * Removes items from the cache to bring the size down\n   * to an acceptable value ('acceptableWaterMark').\n   * <p/>\n   * It is done in two stages. In the first stage, least recently used items are evicted.\n   * If, after the first stage, the cache size is still greater than 'acceptableSize'\n   * config parameter, the second stage takes over.\n   * <p/>\n   * The second stage is more intensive and tries to bring down the cache size\n   * to the 'lowerWaterMark' config parameter.\n   */\n  private void markAndSweep() {\n    // if we want to keep at least 1000 entries, then timestamps of\n    // current through current-1000 are guaranteed not to be the oldest (but that does\n    // not mean there are 1000 entries in that group... it's actually anywhere between\n    // 1 and 1000).\n    // Also, if we want to remove 500 entries, then\n    // oldestEntry through oldestEntry+500 are guaranteed to be\n    // removed (however many there are there).\n\n    if (!markAndSweepLock.tryLock()) return;\n    try {\n      long oldestEntry = this.oldestEntry;\n      isCleaning = true;\n      this.oldestEntry = oldestEntry;     // volatile write to make isCleaning visible\n\n      long timeCurrent = stats.accessCounter.longValue();\n      int sz = stats.size.get();\n\n      int numRemoved = 0;\n      int numKept = 0;\n      long newestEntry = timeCurrent;\n      long newNewestEntry = -1;\n      long newOldestEntry = Long.MAX_VALUE;\n\n      int wantToKeep = lowerWaterMark;\n      int wantToRemove = sz - lowerWaterMark;\n\n      @SuppressWarnings(\"unchecked\") // generic array's are annoying\n      CacheEntry<K,V>[] eset = new CacheEntry[sz];\n      int eSize = 0;\n\n      // System.out.println(\"newestEntry=\"+newestEntry + \" oldestEntry=\"+oldestEntry);\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n\n      for (CacheEntry<K,V> ce : map.values()) {\n        // set lastAccessedCopy to avoid more volatile reads\n        ce.lastAccessedCopy = ce.lastAccessed;\n        long thisEntry = ce.lastAccessedCopy;\n\n        // since the wantToKeep group is likely to be bigger than wantToRemove, check it first\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing.\n          numKept++;\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it from the map.\n          evictEntry(ce.key);\n          numRemoved++;\n        } else {\n          // This entry *could* be in the bottom group.\n          // Collect these entries to avoid another full pass... this is wasted\n          // effort if enough entries are normally removed in this first pass.\n          // An alternate impl could make a full second pass.\n          if (eSize < eset.length-1) {\n            eset[eSize++] = ce;\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n      }\n\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      // TODO: allow this to be customized in the constructor?\n      int numPasses=1; // maximum number of linear passes over the data\n\n      // if we didn't remove enough entries, then make more passes\n      // over the values we collected, with updated min and max values.\n      while (sz - numRemoved > acceptableWaterMark && --numPasses>=0) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        // iterate backward to make it easy to remove items.\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // remove the entry by moving the last element to its position\n            eset[i] = eset[eSize-1];\n            eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it from the map.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // remove the entry by moving the last element to its position\n            eset[i] = eset[eSize-1];\n            eSize--;\n          } else {\n            // This entry *could* be in the bottom group, so keep it in the eset,\n            // and update the stats.\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n\n\n      // if we still didn't remove enough entries, then make another pass while\n      // inserting into a priority queue\n      if (sz - numRemoved > acceptableWaterMark) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        PQueue<K,V> queue = new PQueue<>(wantToRemove);\n\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) {  // entry in bottom group?\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n          } else {\n            // This entry *could* be in the bottom group.\n            // add it to the priority queue\n\n            // everything in the priority queue will be removed, so keep track of\n            // the lowest value that ever comes back out of the queue.\n\n            // first reduce the size of the priority queue to account for\n            // the number of items we have already removed while executing\n            // this loop so far.\n            queue.myMaxSize = sz - lowerWaterMark - numRemoved;\n            while (queue.size() > queue.myMaxSize && queue.size() > 0) {\n              CacheEntry otherEntry = queue.pop();\n              newOldestEntry = Math.min(otherEntry.lastAccessedCopy, newOldestEntry);\n            }\n            if (queue.myMaxSize <= 0) break;\n\n            Object o = queue.myInsertWithOverflow(ce);\n            if (o != null) {\n              newOldestEntry = Math.min(((CacheEntry)o).lastAccessedCopy, newOldestEntry);\n            }\n          }\n        }\n\n        // Now delete everything in the priority queue.\n        // avoid using pop() since order doesn't matter anymore\n        for (CacheEntry<K,V> ce : queue.getValues()) {\n          if (ce==null) continue;\n          evictEntry(ce.key);\n          numRemoved++;\n        }\n\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" initialQueueSize=\"+ wantToRemove + \" finalQueueSize=\" + queue.size() + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n      oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n      this.oldestEntry = oldestEntry;\n    } finally {\n      isCleaning = false;  // set before markAndSweep.unlock() for visibility\n      markAndSweepLock.unlock();\n    }\n  }\n\n","sourceOld":"  /**\n   * Removes items from the cache to bring the size down\n   * to an acceptable value ('acceptableWaterMark').\n   * <p/>\n   * It is done in two stages. In the first stage, least recently used items are evicted.\n   * If, after the first stage, the cache size is still greater than 'acceptableSize'\n   * config parameter, the second stage takes over.\n   * <p/>\n   * The second stage is more intensive and tries to bring down the cache size\n   * to the 'lowerWaterMark' config parameter.\n   */\n  private void markAndSweep() {\n    // if we want to keep at least 1000 entries, then timestamps of\n    // current through current-1000 are guaranteed not to be the oldest (but that does\n    // not mean there are 1000 entries in that group... it's actually anywhere between\n    // 1 and 1000).\n    // Also, if we want to remove 500 entries, then\n    // oldestEntry through oldestEntry+500 are guaranteed to be\n    // removed (however many there are there).\n\n    if (!markAndSweepLock.tryLock()) return;\n    try {\n      long oldestEntry = this.oldestEntry;\n      isCleaning = true;\n      this.oldestEntry = oldestEntry;     // volatile write to make isCleaning visible\n\n      long timeCurrent = stats.accessCounter.get();\n      int sz = stats.size.get();\n\n      int numRemoved = 0;\n      int numKept = 0;\n      long newestEntry = timeCurrent;\n      long newNewestEntry = -1;\n      long newOldestEntry = Long.MAX_VALUE;\n\n      int wantToKeep = lowerWaterMark;\n      int wantToRemove = sz - lowerWaterMark;\n\n      @SuppressWarnings(\"unchecked\") // generic array's are annoying\n      CacheEntry<K,V>[] eset = new CacheEntry[sz];\n      int eSize = 0;\n\n      // System.out.println(\"newestEntry=\"+newestEntry + \" oldestEntry=\"+oldestEntry);\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n\n      for (CacheEntry<K,V> ce : map.values()) {\n        // set lastAccessedCopy to avoid more volatile reads\n        ce.lastAccessedCopy = ce.lastAccessed;\n        long thisEntry = ce.lastAccessedCopy;\n\n        // since the wantToKeep group is likely to be bigger than wantToRemove, check it first\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing.\n          numKept++;\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it from the map.\n          evictEntry(ce.key);\n          numRemoved++;\n        } else {\n          // This entry *could* be in the bottom group.\n          // Collect these entries to avoid another full pass... this is wasted\n          // effort if enough entries are normally removed in this first pass.\n          // An alternate impl could make a full second pass.\n          if (eSize < eset.length-1) {\n            eset[eSize++] = ce;\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n      }\n\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      // TODO: allow this to be customized in the constructor?\n      int numPasses=1; // maximum number of linear passes over the data\n\n      // if we didn't remove enough entries, then make more passes\n      // over the values we collected, with updated min and max values.\n      while (sz - numRemoved > acceptableWaterMark && --numPasses>=0) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        // iterate backward to make it easy to remove items.\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // remove the entry by moving the last element to its position\n            eset[i] = eset[eSize-1];\n            eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it from the map.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // remove the entry by moving the last element to its position\n            eset[i] = eset[eSize-1];\n            eSize--;\n          } else {\n            // This entry *could* be in the bottom group, so keep it in the eset,\n            // and update the stats.\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n\n\n      // if we still didn't remove enough entries, then make another pass while\n      // inserting into a priority queue\n      if (sz - numRemoved > acceptableWaterMark) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        PQueue<K,V> queue = new PQueue<>(wantToRemove);\n\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) {  // entry in bottom group?\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n          } else {\n            // This entry *could* be in the bottom group.\n            // add it to the priority queue\n\n            // everything in the priority queue will be removed, so keep track of\n            // the lowest value that ever comes back out of the queue.\n\n            // first reduce the size of the priority queue to account for\n            // the number of items we have already removed while executing\n            // this loop so far.\n            queue.myMaxSize = sz - lowerWaterMark - numRemoved;\n            while (queue.size() > queue.myMaxSize && queue.size() > 0) {\n              CacheEntry otherEntry = queue.pop();\n              newOldestEntry = Math.min(otherEntry.lastAccessedCopy, newOldestEntry);\n            }\n            if (queue.myMaxSize <= 0) break;\n\n            Object o = queue.myInsertWithOverflow(ce);\n            if (o != null) {\n              newOldestEntry = Math.min(((CacheEntry)o).lastAccessedCopy, newOldestEntry);\n            }\n          }\n        }\n\n        // Now delete everything in the priority queue.\n        // avoid using pop() since order doesn't matter anymore\n        for (CacheEntry<K,V> ce : queue.getValues()) {\n          if (ce==null) continue;\n          evictEntry(ce.key);\n          numRemoved++;\n        }\n\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" initialQueueSize=\"+ wantToRemove + \" finalQueueSize=\" + queue.size() + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n      oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n      this.oldestEntry = oldestEntry;\n    } finally {\n      isCleaning = false;  // set before markAndSweep.unlock() for visibility\n      markAndSweepLock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/util/ConcurrentLRUCache#markAndSweep().mjava","pathOld":"solr/core/src/java/org/apache/solr/util/ConcurrentLRUCache#markAndSweep().mjava","sourceNew":"  /**\n   * Removes items from the cache to bring the size down\n   * to an acceptable value ('acceptableWaterMark').\n   * <p/>\n   * It is done in two stages. In the first stage, least recently used items are evicted.\n   * If, after the first stage, the cache size is still greater than 'acceptableSize'\n   * config parameter, the second stage takes over.\n   * <p/>\n   * The second stage is more intensive and tries to bring down the cache size\n   * to the 'lowerWaterMark' config parameter.\n   */\n  private void markAndSweep() {\n    // if we want to keep at least 1000 entries, then timestamps of\n    // current through current-1000 are guaranteed not to be the oldest (but that does\n    // not mean there are 1000 entries in that group... it's actually anywhere between\n    // 1 and 1000).\n    // Also, if we want to remove 500 entries, then\n    // oldestEntry through oldestEntry+500 are guaranteed to be\n    // removed (however many there are there).\n\n    if (!markAndSweepLock.tryLock()) return;\n    try {\n      long oldestEntry = this.oldestEntry;\n      isCleaning = true;\n      this.oldestEntry = oldestEntry;     // volatile write to make isCleaning visible\n\n      long timeCurrent = stats.accessCounter.longValue();\n      int sz = stats.size.get();\n\n      int numRemoved = 0;\n      int numKept = 0;\n      long newestEntry = timeCurrent;\n      long newNewestEntry = -1;\n      long newOldestEntry = Long.MAX_VALUE;\n\n      int wantToKeep = lowerWaterMark;\n      int wantToRemove = sz - lowerWaterMark;\n\n      @SuppressWarnings(\"unchecked\") // generic array's are annoying\n      CacheEntry<K,V>[] eset = new CacheEntry[sz];\n      int eSize = 0;\n\n      // System.out.println(\"newestEntry=\"+newestEntry + \" oldestEntry=\"+oldestEntry);\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n\n      for (CacheEntry<K,V> ce : map.values()) {\n        // set lastAccessedCopy to avoid more volatile reads\n        ce.lastAccessedCopy = ce.lastAccessed;\n        long thisEntry = ce.lastAccessedCopy;\n\n        // since the wantToKeep group is likely to be bigger than wantToRemove, check it first\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing.\n          numKept++;\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it from the map.\n          evictEntry(ce.key);\n          numRemoved++;\n        } else {\n          // This entry *could* be in the bottom group.\n          // Collect these entries to avoid another full pass... this is wasted\n          // effort if enough entries are normally removed in this first pass.\n          // An alternate impl could make a full second pass.\n          if (eSize < eset.length-1) {\n            eset[eSize++] = ce;\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n      }\n\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      // TODO: allow this to be customized in the constructor?\n      int numPasses=1; // maximum number of linear passes over the data\n\n      // if we didn't remove enough entries, then make more passes\n      // over the values we collected, with updated min and max values.\n      while (sz - numRemoved > acceptableWaterMark && --numPasses>=0) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        // iterate backward to make it easy to remove items.\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // remove the entry by moving the last element to its position\n            eset[i] = eset[eSize-1];\n            eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it from the map.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // remove the entry by moving the last element to its position\n            eset[i] = eset[eSize-1];\n            eSize--;\n          } else {\n            // This entry *could* be in the bottom group, so keep it in the eset,\n            // and update the stats.\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n\n\n      // if we still didn't remove enough entries, then make another pass while\n      // inserting into a priority queue\n      if (sz - numRemoved > acceptableWaterMark) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        PQueue<K,V> queue = new PQueue<>(wantToRemove);\n\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) {  // entry in bottom group?\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n          } else {\n            // This entry *could* be in the bottom group.\n            // add it to the priority queue\n\n            // everything in the priority queue will be removed, so keep track of\n            // the lowest value that ever comes back out of the queue.\n\n            // first reduce the size of the priority queue to account for\n            // the number of items we have already removed while executing\n            // this loop so far.\n            queue.myMaxSize = sz - lowerWaterMark - numRemoved;\n            while (queue.size() > queue.myMaxSize && queue.size() > 0) {\n              CacheEntry otherEntry = queue.pop();\n              newOldestEntry = Math.min(otherEntry.lastAccessedCopy, newOldestEntry);\n            }\n            if (queue.myMaxSize <= 0) break;\n\n            Object o = queue.myInsertWithOverflow(ce);\n            if (o != null) {\n              newOldestEntry = Math.min(((CacheEntry)o).lastAccessedCopy, newOldestEntry);\n            }\n          }\n        }\n\n        // Now delete everything in the priority queue.\n        // avoid using pop() since order doesn't matter anymore\n        for (CacheEntry<K,V> ce : queue.getValues()) {\n          if (ce==null) continue;\n          evictEntry(ce.key);\n          numRemoved++;\n        }\n\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" initialQueueSize=\"+ wantToRemove + \" finalQueueSize=\" + queue.size() + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n      oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n      this.oldestEntry = oldestEntry;\n    } finally {\n      isCleaning = false;  // set before markAndSweep.unlock() for visibility\n      markAndSweepLock.unlock();\n    }\n  }\n\n","sourceOld":"  /**\n   * Removes items from the cache to bring the size down\n   * to an acceptable value ('acceptableWaterMark').\n   * <p/>\n   * It is done in two stages. In the first stage, least recently used items are evicted.\n   * If, after the first stage, the cache size is still greater than 'acceptableSize'\n   * config parameter, the second stage takes over.\n   * <p/>\n   * The second stage is more intensive and tries to bring down the cache size\n   * to the 'lowerWaterMark' config parameter.\n   */\n  private void markAndSweep() {\n    // if we want to keep at least 1000 entries, then timestamps of\n    // current through current-1000 are guaranteed not to be the oldest (but that does\n    // not mean there are 1000 entries in that group... it's actually anywhere between\n    // 1 and 1000).\n    // Also, if we want to remove 500 entries, then\n    // oldestEntry through oldestEntry+500 are guaranteed to be\n    // removed (however many there are there).\n\n    if (!markAndSweepLock.tryLock()) return;\n    try {\n      long oldestEntry = this.oldestEntry;\n      isCleaning = true;\n      this.oldestEntry = oldestEntry;     // volatile write to make isCleaning visible\n\n      long timeCurrent = stats.accessCounter.get();\n      int sz = stats.size.get();\n\n      int numRemoved = 0;\n      int numKept = 0;\n      long newestEntry = timeCurrent;\n      long newNewestEntry = -1;\n      long newOldestEntry = Long.MAX_VALUE;\n\n      int wantToKeep = lowerWaterMark;\n      int wantToRemove = sz - lowerWaterMark;\n\n      @SuppressWarnings(\"unchecked\") // generic array's are annoying\n      CacheEntry<K,V>[] eset = new CacheEntry[sz];\n      int eSize = 0;\n\n      // System.out.println(\"newestEntry=\"+newestEntry + \" oldestEntry=\"+oldestEntry);\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n\n      for (CacheEntry<K,V> ce : map.values()) {\n        // set lastAccessedCopy to avoid more volatile reads\n        ce.lastAccessedCopy = ce.lastAccessed;\n        long thisEntry = ce.lastAccessedCopy;\n\n        // since the wantToKeep group is likely to be bigger than wantToRemove, check it first\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing.\n          numKept++;\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it from the map.\n          evictEntry(ce.key);\n          numRemoved++;\n        } else {\n          // This entry *could* be in the bottom group.\n          // Collect these entries to avoid another full pass... this is wasted\n          // effort if enough entries are normally removed in this first pass.\n          // An alternate impl could make a full second pass.\n          if (eSize < eset.length-1) {\n            eset[eSize++] = ce;\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n      }\n\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      // TODO: allow this to be customized in the constructor?\n      int numPasses=1; // maximum number of linear passes over the data\n\n      // if we didn't remove enough entries, then make more passes\n      // over the values we collected, with updated min and max values.\n      while (sz - numRemoved > acceptableWaterMark && --numPasses>=0) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        // iterate backward to make it easy to remove items.\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // remove the entry by moving the last element to its position\n            eset[i] = eset[eSize-1];\n            eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it from the map.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // remove the entry by moving the last element to its position\n            eset[i] = eset[eSize-1];\n            eSize--;\n          } else {\n            // This entry *could* be in the bottom group, so keep it in the eset,\n            // and update the stats.\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n\n\n      // if we still didn't remove enough entries, then make another pass while\n      // inserting into a priority queue\n      if (sz - numRemoved > acceptableWaterMark) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        PQueue<K,V> queue = new PQueue<>(wantToRemove);\n\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) {  // entry in bottom group?\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n          } else {\n            // This entry *could* be in the bottom group.\n            // add it to the priority queue\n\n            // everything in the priority queue will be removed, so keep track of\n            // the lowest value that ever comes back out of the queue.\n\n            // first reduce the size of the priority queue to account for\n            // the number of items we have already removed while executing\n            // this loop so far.\n            queue.myMaxSize = sz - lowerWaterMark - numRemoved;\n            while (queue.size() > queue.myMaxSize && queue.size() > 0) {\n              CacheEntry otherEntry = queue.pop();\n              newOldestEntry = Math.min(otherEntry.lastAccessedCopy, newOldestEntry);\n            }\n            if (queue.myMaxSize <= 0) break;\n\n            Object o = queue.myInsertWithOverflow(ce);\n            if (o != null) {\n              newOldestEntry = Math.min(((CacheEntry)o).lastAccessedCopy, newOldestEntry);\n            }\n          }\n        }\n\n        // Now delete everything in the priority queue.\n        // avoid using pop() since order doesn't matter anymore\n        for (CacheEntry<K,V> ce : queue.getValues()) {\n          if (ce==null) continue;\n          evictEntry(ce.key);\n          numRemoved++;\n        }\n\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" initialQueueSize=\"+ wantToRemove + \" finalQueueSize=\" + queue.size() + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n      oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n      this.oldestEntry = oldestEntry;\n    } finally {\n      isCleaning = false;  // set before markAndSweep.unlock() for visibility\n      markAndSweepLock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c5044c9bb1518e7a13c1c5385a21325ae343056","date":1479187798,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/ConcurrentLRUCache#markAndSweep().mjava","pathOld":"solr/core/src/java/org/apache/solr/util/ConcurrentLRUCache#markAndSweep().mjava","sourceNew":"  /**\n   * Removes items from the cache to bring the size down\n   * to an acceptable value ('acceptableWaterMark').\n   * <p/>\n   * It is done in two stages. In the first stage, least recently used items are evicted.\n   * If, after the first stage, the cache size is still greater than 'acceptableSize'\n   * config parameter, the second stage takes over.\n   * <p/>\n   * The second stage is more intensive and tries to bring down the cache size\n   * to the 'lowerWaterMark' config parameter.\n   */\n  private void markAndSweep() {\n    // if we want to keep at least 1000 entries, then timestamps of\n    // current through current-1000 are guaranteed not to be the oldest (but that does\n    // not mean there are 1000 entries in that group... it's actually anywhere between\n    // 1 and 1000).\n    // Also, if we want to remove 500 entries, then\n    // oldestEntry through oldestEntry+500 are guaranteed to be\n    // removed (however many there are there).\n\n    if (!markAndSweepLock.tryLock()) return;\n    try {\n      if (upperWaterMark != Integer.MAX_VALUE) {\n        markAndSweepByCacheSize();\n      } else if (ramUpperWatermark != Long.MAX_VALUE) {\n        markAndSweepByRamSize();\n      } else  {\n        // should never happen\n        throw new AssertionError(\"ConcurrentLRUCache initialized with neither size limits nor ram limits\");\n      }\n    } finally {\n      isCleaning = false;  // set before markAndSweep.unlock() for visibility\n      markAndSweepLock.unlock();\n    }\n  }\n\n","sourceOld":"  /**\n   * Removes items from the cache to bring the size down\n   * to an acceptable value ('acceptableWaterMark').\n   * <p/>\n   * It is done in two stages. In the first stage, least recently used items are evicted.\n   * If, after the first stage, the cache size is still greater than 'acceptableSize'\n   * config parameter, the second stage takes over.\n   * <p/>\n   * The second stage is more intensive and tries to bring down the cache size\n   * to the 'lowerWaterMark' config parameter.\n   */\n  private void markAndSweep() {\n    // if we want to keep at least 1000 entries, then timestamps of\n    // current through current-1000 are guaranteed not to be the oldest (but that does\n    // not mean there are 1000 entries in that group... it's actually anywhere between\n    // 1 and 1000).\n    // Also, if we want to remove 500 entries, then\n    // oldestEntry through oldestEntry+500 are guaranteed to be\n    // removed (however many there are there).\n\n    if (!markAndSweepLock.tryLock()) return;\n    try {\n      long oldestEntry = this.oldestEntry;\n      isCleaning = true;\n      this.oldestEntry = oldestEntry;     // volatile write to make isCleaning visible\n\n      long timeCurrent = stats.accessCounter.longValue();\n      int sz = stats.size.get();\n\n      int numRemoved = 0;\n      int numKept = 0;\n      long newestEntry = timeCurrent;\n      long newNewestEntry = -1;\n      long newOldestEntry = Long.MAX_VALUE;\n\n      int wantToKeep = lowerWaterMark;\n      int wantToRemove = sz - lowerWaterMark;\n\n      @SuppressWarnings(\"unchecked\") // generic array's are annoying\n      CacheEntry<K,V>[] eset = new CacheEntry[sz];\n      int eSize = 0;\n\n      // System.out.println(\"newestEntry=\"+newestEntry + \" oldestEntry=\"+oldestEntry);\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n\n      for (CacheEntry<K,V> ce : map.values()) {\n        // set lastAccessedCopy to avoid more volatile reads\n        ce.lastAccessedCopy = ce.lastAccessed;\n        long thisEntry = ce.lastAccessedCopy;\n\n        // since the wantToKeep group is likely to be bigger than wantToRemove, check it first\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing.\n          numKept++;\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it from the map.\n          evictEntry(ce.key);\n          numRemoved++;\n        } else {\n          // This entry *could* be in the bottom group.\n          // Collect these entries to avoid another full pass... this is wasted\n          // effort if enough entries are normally removed in this first pass.\n          // An alternate impl could make a full second pass.\n          if (eSize < eset.length-1) {\n            eset[eSize++] = ce;\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n      }\n\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      // TODO: allow this to be customized in the constructor?\n      int numPasses=1; // maximum number of linear passes over the data\n\n      // if we didn't remove enough entries, then make more passes\n      // over the values we collected, with updated min and max values.\n      while (sz - numRemoved > acceptableWaterMark && --numPasses>=0) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        // iterate backward to make it easy to remove items.\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // remove the entry by moving the last element to its position\n            eset[i] = eset[eSize-1];\n            eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it from the map.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // remove the entry by moving the last element to its position\n            eset[i] = eset[eSize-1];\n            eSize--;\n          } else {\n            // This entry *could* be in the bottom group, so keep it in the eset,\n            // and update the stats.\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n\n\n      // if we still didn't remove enough entries, then make another pass while\n      // inserting into a priority queue\n      if (sz - numRemoved > acceptableWaterMark) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        PQueue<K,V> queue = new PQueue<>(wantToRemove);\n\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) {  // entry in bottom group?\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n          } else {\n            // This entry *could* be in the bottom group.\n            // add it to the priority queue\n\n            // everything in the priority queue will be removed, so keep track of\n            // the lowest value that ever comes back out of the queue.\n\n            // first reduce the size of the priority queue to account for\n            // the number of items we have already removed while executing\n            // this loop so far.\n            queue.myMaxSize = sz - lowerWaterMark - numRemoved;\n            while (queue.size() > queue.myMaxSize && queue.size() > 0) {\n              CacheEntry otherEntry = queue.pop();\n              newOldestEntry = Math.min(otherEntry.lastAccessedCopy, newOldestEntry);\n            }\n            if (queue.myMaxSize <= 0) break;\n\n            Object o = queue.myInsertWithOverflow(ce);\n            if (o != null) {\n              newOldestEntry = Math.min(((CacheEntry)o).lastAccessedCopy, newOldestEntry);\n            }\n          }\n        }\n\n        // Now delete everything in the priority queue.\n        // avoid using pop() since order doesn't matter anymore\n        for (CacheEntry<K,V> ce : queue.getValues()) {\n          if (ce==null) continue;\n          evictEntry(ce.key);\n          numRemoved++;\n        }\n\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" initialQueueSize=\"+ wantToRemove + \" finalQueueSize=\" + queue.size() + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n      oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n      this.oldestEntry = oldestEntry;\n    } finally {\n      isCleaning = false;  // set before markAndSweep.unlock() for visibility\n      markAndSweepLock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"21019aa828c8c9b0153877543a8b3f200bf2ca19","date":1479224450,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/util/ConcurrentLRUCache#markAndSweep().mjava","pathOld":"solr/core/src/java/org/apache/solr/util/ConcurrentLRUCache#markAndSweep().mjava","sourceNew":"  /**\n   * Removes items from the cache to bring the size down\n   * to an acceptable value ('acceptableWaterMark').\n   * <p/>\n   * It is done in two stages. In the first stage, least recently used items are evicted.\n   * If, after the first stage, the cache size is still greater than 'acceptableSize'\n   * config parameter, the second stage takes over.\n   * <p/>\n   * The second stage is more intensive and tries to bring down the cache size\n   * to the 'lowerWaterMark' config parameter.\n   */\n  private void markAndSweep() {\n    // if we want to keep at least 1000 entries, then timestamps of\n    // current through current-1000 are guaranteed not to be the oldest (but that does\n    // not mean there are 1000 entries in that group... it's actually anywhere between\n    // 1 and 1000).\n    // Also, if we want to remove 500 entries, then\n    // oldestEntry through oldestEntry+500 are guaranteed to be\n    // removed (however many there are there).\n\n    if (!markAndSweepLock.tryLock()) return;\n    try {\n      if (upperWaterMark != Integer.MAX_VALUE) {\n        markAndSweepByCacheSize();\n      } else if (ramUpperWatermark != Long.MAX_VALUE) {\n        markAndSweepByRamSize();\n      } else  {\n        // should never happen\n        throw new AssertionError(\"ConcurrentLRUCache initialized with neither size limits nor ram limits\");\n      }\n    } finally {\n      isCleaning = false;  // set before markAndSweep.unlock() for visibility\n      markAndSweepLock.unlock();\n    }\n  }\n\n","sourceOld":"  /**\n   * Removes items from the cache to bring the size down\n   * to an acceptable value ('acceptableWaterMark').\n   * <p/>\n   * It is done in two stages. In the first stage, least recently used items are evicted.\n   * If, after the first stage, the cache size is still greater than 'acceptableSize'\n   * config parameter, the second stage takes over.\n   * <p/>\n   * The second stage is more intensive and tries to bring down the cache size\n   * to the 'lowerWaterMark' config parameter.\n   */\n  private void markAndSweep() {\n    // if we want to keep at least 1000 entries, then timestamps of\n    // current through current-1000 are guaranteed not to be the oldest (but that does\n    // not mean there are 1000 entries in that group... it's actually anywhere between\n    // 1 and 1000).\n    // Also, if we want to remove 500 entries, then\n    // oldestEntry through oldestEntry+500 are guaranteed to be\n    // removed (however many there are there).\n\n    if (!markAndSweepLock.tryLock()) return;\n    try {\n      long oldestEntry = this.oldestEntry;\n      isCleaning = true;\n      this.oldestEntry = oldestEntry;     // volatile write to make isCleaning visible\n\n      long timeCurrent = stats.accessCounter.longValue();\n      int sz = stats.size.get();\n\n      int numRemoved = 0;\n      int numKept = 0;\n      long newestEntry = timeCurrent;\n      long newNewestEntry = -1;\n      long newOldestEntry = Long.MAX_VALUE;\n\n      int wantToKeep = lowerWaterMark;\n      int wantToRemove = sz - lowerWaterMark;\n\n      @SuppressWarnings(\"unchecked\") // generic array's are annoying\n      CacheEntry<K,V>[] eset = new CacheEntry[sz];\n      int eSize = 0;\n\n      // System.out.println(\"newestEntry=\"+newestEntry + \" oldestEntry=\"+oldestEntry);\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n\n      for (CacheEntry<K,V> ce : map.values()) {\n        // set lastAccessedCopy to avoid more volatile reads\n        ce.lastAccessedCopy = ce.lastAccessed;\n        long thisEntry = ce.lastAccessedCopy;\n\n        // since the wantToKeep group is likely to be bigger than wantToRemove, check it first\n        if (thisEntry > newestEntry - wantToKeep) {\n          // this entry is guaranteed not to be in the bottom\n          // group, so do nothing.\n          numKept++;\n          newOldestEntry = Math.min(thisEntry, newOldestEntry);\n        } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n          // this entry is guaranteed to be in the bottom group\n          // so immediately remove it from the map.\n          evictEntry(ce.key);\n          numRemoved++;\n        } else {\n          // This entry *could* be in the bottom group.\n          // Collect these entries to avoid another full pass... this is wasted\n          // effort if enough entries are normally removed in this first pass.\n          // An alternate impl could make a full second pass.\n          if (eSize < eset.length-1) {\n            eset[eSize++] = ce;\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n      }\n\n      // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      // TODO: allow this to be customized in the constructor?\n      int numPasses=1; // maximum number of linear passes over the data\n\n      // if we didn't remove enough entries, then make more passes\n      // over the values we collected, with updated min and max values.\n      while (sz - numRemoved > acceptableWaterMark && --numPasses>=0) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        // iterate backward to make it easy to remove items.\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // remove the entry by moving the last element to its position\n            eset[i] = eset[eSize-1];\n            eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?\n\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it from the map.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // remove the entry by moving the last element to its position\n            eset[i] = eset[eSize-1];\n            eSize--;\n          } else {\n            // This entry *could* be in the bottom group, so keep it in the eset,\n            // and update the stats.\n            newNewestEntry = Math.max(thisEntry, newNewestEntry);\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n          }\n        }\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" esetSz=\"+ eSize + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n\n\n      // if we still didn't remove enough entries, then make another pass while\n      // inserting into a priority queue\n      if (sz - numRemoved > acceptableWaterMark) {\n\n        oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n        newOldestEntry = Long.MAX_VALUE;\n        newestEntry = newNewestEntry;\n        newNewestEntry = -1;\n        wantToKeep = lowerWaterMark - numKept;\n        wantToRemove = sz - lowerWaterMark - numRemoved;\n\n        PQueue<K,V> queue = new PQueue<>(wantToRemove);\n\n        for (int i=eSize-1; i>=0; i--) {\n          CacheEntry<K,V> ce = eset[i];\n          long thisEntry = ce.lastAccessedCopy;\n\n          if (thisEntry > newestEntry - wantToKeep) {\n            // this entry is guaranteed not to be in the bottom\n            // group, so do nothing but remove it from the eset.\n            numKept++;\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n\n            newOldestEntry = Math.min(thisEntry, newOldestEntry);\n            \n          } else if (thisEntry < oldestEntry + wantToRemove) {  // entry in bottom group?\n            // this entry is guaranteed to be in the bottom group\n            // so immediately remove it.\n            evictEntry(ce.key);\n            numRemoved++;\n\n            // removal not necessary on last pass.\n            // eset[i] = eset[eSize-1];\n            // eSize--;\n          } else {\n            // This entry *could* be in the bottom group.\n            // add it to the priority queue\n\n            // everything in the priority queue will be removed, so keep track of\n            // the lowest value that ever comes back out of the queue.\n\n            // first reduce the size of the priority queue to account for\n            // the number of items we have already removed while executing\n            // this loop so far.\n            queue.myMaxSize = sz - lowerWaterMark - numRemoved;\n            while (queue.size() > queue.myMaxSize && queue.size() > 0) {\n              CacheEntry otherEntry = queue.pop();\n              newOldestEntry = Math.min(otherEntry.lastAccessedCopy, newOldestEntry);\n            }\n            if (queue.myMaxSize <= 0) break;\n\n            Object o = queue.myInsertWithOverflow(ce);\n            if (o != null) {\n              newOldestEntry = Math.min(((CacheEntry)o).lastAccessedCopy, newOldestEntry);\n            }\n          }\n        }\n\n        // Now delete everything in the priority queue.\n        // avoid using pop() since order doesn't matter anymore\n        for (CacheEntry<K,V> ce : queue.getValues()) {\n          if (ce==null) continue;\n          evictEntry(ce.key);\n          numRemoved++;\n        }\n\n        // System.out.println(\"items removed:\" + numRemoved + \" numKept=\" + numKept + \" initialQueueSize=\"+ wantToRemove + \" finalQueueSize=\" + queue.size() + \" sz-numRemoved=\" + (sz-numRemoved));\n      }\n\n      oldestEntry = newOldestEntry == Long.MAX_VALUE ? oldestEntry : newOldestEntry;\n      this.oldestEntry = oldestEntry;\n    } finally {\n      isCleaning = false;  // set before markAndSweep.unlock() for visibility\n      markAndSweepLock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ce13e934d6cfdcc82d51e85de460cf9790e97566","date":1563877281,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/ConcurrentLRUCache#markAndSweep().mjava","pathOld":"solr/core/src/java/org/apache/solr/util/ConcurrentLRUCache#markAndSweep().mjava","sourceNew":"  /**\n   * Removes items from the cache to bring the size down\n   * to an acceptable value ('acceptableWaterMark').\n   * <p/>\n   * It is done in two stages. In the first stage, least recently used items are evicted.\n   * If, after the first stage, the cache size is still greater than 'acceptableSize'\n   * config parameter, the second stage takes over.\n   * <p/>\n   * The second stage is more intensive and tries to bring down the cache size\n   * to the 'lowerWaterMark' config parameter.\n   */\n  private void markAndSweep() {\n    // if we want to keep at least 1000 entries, then timestamps of\n    // current through current-1000 are guaranteed not to be the oldest (but that does\n    // not mean there are 1000 entries in that group... it's actually anywhere between\n    // 1 and 1000).\n    // Also, if we want to remove 500 entries, then\n    // oldestEntry through oldestEntry+500 are guaranteed to be\n    // removed (however many there are there).\n\n    if (!markAndSweepLock.tryLock()) return;\n    try {\n      if (upperWaterMark < size()) {\n        markAndSweepByCacheSize();\n      } else if (ramUpperWatermark < ramBytesUsed()) {\n        markAndSweepByRamSize();\n      } else if (upperWaterMark == Integer.MAX_VALUE && ramUpperWatermark == Long.MAX_VALUE) {\n        // should never happen\n        throw new AssertionError(\"ConcurrentLRUCache initialized with neither size limits nor ram limits\");\n      }\n    } finally {\n      isCleaning = false;  // set before markAndSweep.unlock() for visibility\n      markAndSweepLock.unlock();\n    }\n  }\n\n","sourceOld":"  /**\n   * Removes items from the cache to bring the size down\n   * to an acceptable value ('acceptableWaterMark').\n   * <p/>\n   * It is done in two stages. In the first stage, least recently used items are evicted.\n   * If, after the first stage, the cache size is still greater than 'acceptableSize'\n   * config parameter, the second stage takes over.\n   * <p/>\n   * The second stage is more intensive and tries to bring down the cache size\n   * to the 'lowerWaterMark' config parameter.\n   */\n  private void markAndSweep() {\n    // if we want to keep at least 1000 entries, then timestamps of\n    // current through current-1000 are guaranteed not to be the oldest (but that does\n    // not mean there are 1000 entries in that group... it's actually anywhere between\n    // 1 and 1000).\n    // Also, if we want to remove 500 entries, then\n    // oldestEntry through oldestEntry+500 are guaranteed to be\n    // removed (however many there are there).\n\n    if (!markAndSweepLock.tryLock()) return;\n    try {\n      if (upperWaterMark != Integer.MAX_VALUE) {\n        markAndSweepByCacheSize();\n      } else if (ramUpperWatermark != Long.MAX_VALUE) {\n        markAndSweepByRamSize();\n      } else  {\n        // should never happen\n        throw new AssertionError(\"ConcurrentLRUCache initialized with neither size limits nor ram limits\");\n      }\n    } finally {\n      isCleaning = false;  // set before markAndSweep.unlock() for visibility\n      markAndSweepLock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fbd58791ecf2b92d8917c2f4aab0e50965ec6a83","date":1568645407,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/ConcurrentLRUCache#markAndSweep().mjava","pathOld":"solr/core/src/java/org/apache/solr/util/ConcurrentLRUCache#markAndSweep().mjava","sourceNew":"  /**\n   * Removes items from the cache to bring the size down\n   * to an acceptable value.\n   * <p>Visible for unit testing.</p>\n   * @lucene.internal\n   */\n   public void markAndSweep() {\n    // if we want to keep at least 1000 entries, then timestamps of\n    // current through current-1000 are guaranteed not to be the oldest (but that does\n    // not mean there are 1000 entries in that group... it's actually anywhere between\n    // 1 and 1000).\n    // Also, if we want to remove 500 entries, then\n    // oldestEntry through oldestEntry+500 are guaranteed to be\n    // removed (however many there are there).\n\n    if (!markAndSweepLock.tryLock()) return;\n    try {\n      if (maxIdleTimeNs != Long.MAX_VALUE) {\n        long idleCutoff = timeSource.getEpochTimeNs() - maxIdleTimeNs;\n        if (oldestEntryNs.get() < idleCutoff) {\n          markAndSweepByIdleTime();\n        }\n      }\n      if (upperWaterMark < size()) {\n        markAndSweepByCacheSize();\n      } else if (ramUpperWatermark < ramBytesUsed()) {\n        markAndSweepByRamSize();\n      } else if (upperWaterMark == Integer.MAX_VALUE && ramUpperWatermark == Long.MAX_VALUE) {\n        // should never happen\n        throw new AssertionError(\"ConcurrentLRUCache initialized with neither size limits nor ram limits\");\n      }\n    } finally {\n      isCleaning = false;  // set before markAndSweep.unlock() for visibility\n      markAndSweepLock.unlock();\n    }\n  }\n\n","sourceOld":"  /**\n   * Removes items from the cache to bring the size down\n   * to an acceptable value ('acceptableWaterMark').\n   * <p/>\n   * It is done in two stages. In the first stage, least recently used items are evicted.\n   * If, after the first stage, the cache size is still greater than 'acceptableSize'\n   * config parameter, the second stage takes over.\n   * <p/>\n   * The second stage is more intensive and tries to bring down the cache size\n   * to the 'lowerWaterMark' config parameter.\n   */\n  private void markAndSweep() {\n    // if we want to keep at least 1000 entries, then timestamps of\n    // current through current-1000 are guaranteed not to be the oldest (but that does\n    // not mean there are 1000 entries in that group... it's actually anywhere between\n    // 1 and 1000).\n    // Also, if we want to remove 500 entries, then\n    // oldestEntry through oldestEntry+500 are guaranteed to be\n    // removed (however many there are there).\n\n    if (!markAndSweepLock.tryLock()) return;\n    try {\n      if (upperWaterMark < size()) {\n        markAndSweepByCacheSize();\n      } else if (ramUpperWatermark < ramBytesUsed()) {\n        markAndSweepByRamSize();\n      } else if (upperWaterMark == Integer.MAX_VALUE && ramUpperWatermark == Long.MAX_VALUE) {\n        // should never happen\n        throw new AssertionError(\"ConcurrentLRUCache initialized with neither size limits nor ram limits\");\n      }\n    } finally {\n      isCleaning = false;  // set before markAndSweep.unlock() for visibility\n      markAndSweepLock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"cf0b1b21012d341c80a1f3975cf88823f0fe95a9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["399d5903979ca52514d2bc7e3a362e1c45885c94"],"21019aa828c8c9b0153877543a8b3f200bf2ca19":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","7c5044c9bb1518e7a13c1c5385a21325ae343056"],"fbd58791ecf2b92d8917c2f4aab0e50965ec6a83":["ce13e934d6cfdcc82d51e85de460cf9790e97566"],"bc0fbfa191179ae7a0081ee1cf7da0464bcd8078":["310f3f20b324aca4933c1fc4261b19bfe3bc3322"],"399d5903979ca52514d2bc7e3a362e1c45885c94":["cf0b1b21012d341c80a1f3975cf88823f0fe95a9"],"ce13e934d6cfdcc82d51e85de460cf9790e97566":["7c5044c9bb1518e7a13c1c5385a21325ae343056"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["310f3f20b324aca4933c1fc4261b19bfe3bc3322","bc0fbfa191179ae7a0081ee1cf7da0464bcd8078"],"7c5044c9bb1518e7a13c1c5385a21325ae343056":["bc0fbfa191179ae7a0081ee1cf7da0464bcd8078"],"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"310f3f20b324aca4933c1fc4261b19bfe3bc3322":["8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":["310f3f20b324aca4933c1fc4261b19bfe3bc3322","bc0fbfa191179ae7a0081ee1cf7da0464bcd8078"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["fbd58791ecf2b92d8917c2f4aab0e50965ec6a83"]},"commit2Childs":{"cf0b1b21012d341c80a1f3975cf88823f0fe95a9":["399d5903979ca52514d2bc7e3a362e1c45885c94"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1"],"21019aa828c8c9b0153877543a8b3f200bf2ca19":[],"fbd58791ecf2b92d8917c2f4aab0e50965ec6a83":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"399d5903979ca52514d2bc7e3a362e1c45885c94":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"bc0fbfa191179ae7a0081ee1cf7da0464bcd8078":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","7c5044c9bb1518e7a13c1c5385a21325ae343056","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"ce13e934d6cfdcc82d51e85de460cf9790e97566":["fbd58791ecf2b92d8917c2f4aab0e50965ec6a83"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["21019aa828c8c9b0153877543a8b3f200bf2ca19"],"7c5044c9bb1518e7a13c1c5385a21325ae343056":["21019aa828c8c9b0153877543a8b3f200bf2ca19","ce13e934d6cfdcc82d51e85de460cf9790e97566"],"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1":["310f3f20b324aca4933c1fc4261b19bfe3bc3322"],"310f3f20b324aca4933c1fc4261b19bfe3bc3322":["bc0fbfa191179ae7a0081ee1cf7da0464bcd8078","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cf0b1b21012d341c80a1f3975cf88823f0fe95a9"],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["21019aa828c8c9b0153877543a8b3f200bf2ca19","3b013574eedcdbac35dc7e35b0ee616ffc38895d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}