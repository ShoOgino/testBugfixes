{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(double,double,double).mjava","commits":[{"id":"33861a7dcb2e09155c04cd7507f0ab74d5d102b6","date":1461397689,"type":0,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(double,double,double).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public boolean isWithin(final double x, final double y, final double z) {\n    // MHL\n    return false;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09149ac46adf9772db58c67d18f37b1c5e109b34","date":1461566431,"type":4,"author":"Karl Wright","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(double,double,double).mjava","sourceNew":null,"sourceOld":"  @Override\n  public boolean isWithin(final double x, final double y, final double z) {\n    // MHL\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"116824c1b3f14f43f9a77914fbf6f0d70a5b7c89","date":1461609218,"type":0,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(double,double,double).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public boolean isWithin(final double x, final double y, final double z) {\n    return isWithin(new Vector(x, y, z));\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c46db27f3364a67a1c77a0f4e462cc7c5b4147f0","date":1461888019,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(double,double,double).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public boolean isWithin(final double x, final double y, final double z) {\n    return isWithin(new Vector(x, y, z));\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55b50463286869f584cf849d1587a0fcd54d1dfa","date":1462378517,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(double,double,double).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public boolean isWithin(final double x, final double y, final double z) {\n    return isWithin(new Vector(x, y, z));\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7fe41964e49958f662028ea7ed8c224e0955edae","date":1462534610,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(double,double,double).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(double,double,double).mjava","sourceNew":"  @Override\n  public boolean isWithin(final double x, final double y, final double z) {\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(x, y, z)) {\n      return testPointInSet;\n    }\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointFixedYPlane.evaluateIsZero(x, y, z)) {\n      // Use the XZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      if (!yTree.traverse(crossingEdgeIterator, testPoint.y)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedXPlane.evaluateIsZero(x, y, z)) {\n      // Use the YZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      if (!xTree.traverse(crossingEdgeIterator, testPoint.x)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedZPlane.evaluateIsZero(x, y, z)) {\n      // Use the XY plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!zTree.traverse(crossingEdgeIterator, testPoint.z)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else {\n      \n      // This is the expensive part!!\n      // Changing the code below has an enormous impact on the queries per second we see with the benchmark.\n      \n      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.\n      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -x);\n      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -y);\n      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -z);\n\n      // Find the intersection points for each one of these and the complementary test point planes.\n      final GeoPoint[] XIntersectionsY = travelPlaneFixedX.findIntersections(planetModel, testPointFixedYPlane);\n      final GeoPoint[] XIntersectionsZ = travelPlaneFixedX.findIntersections(planetModel, testPointFixedZPlane);\n      final GeoPoint[] YIntersectionsX = travelPlaneFixedY.findIntersections(planetModel, testPointFixedXPlane);\n      final GeoPoint[] YIntersectionsZ = travelPlaneFixedY.findIntersections(planetModel, testPointFixedZPlane);\n      final GeoPoint[] ZIntersectionsX = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedXPlane);\n      final GeoPoint[] ZIntersectionsY = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedYPlane);\n\n      // There will be multiple intersection points found.  We choose the one that has the lowest total distance, as measured in delta X, delta Y, and delta Z.\n      double bestDistance = Double.MAX_VALUE;\n      double firstLegValue = 0.0;\n      double secondLegValue = 0.0;\n      Plane firstLegPlane = null;\n      Plane firstLegAbovePlane = null;\n      Plane firstLegBelowPlane = null;\n      Plane secondLegPlane = null;\n      Tree firstLegTree = null;\n      Tree secondLegTree = null;\n      GeoPoint intersectionPoint = null;\n      \n      for (final GeoPoint p : XIntersectionsY) {\n        // Travel would be in YZ plane (fixed x) then in XZ (fixed y)\n        // We compute distance we need to travel as a placeholder for the number of intersections we might encounter.\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = y - p.y;\n        final double cpDelta2 = z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = x;\n          firstLegPlane = testPointFixedYPlane;\n          firstLegAbovePlane = testPointFixedYAbovePlane;\n          firstLegBelowPlane = testPointFixedYBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = yTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : XIntersectionsZ) {\n        // Travel would be in YZ plane (fixed x) then in XY (fixed z)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.y - p.y;\n        final double cpDelta1 = y - p.y;\n        final double cpDelta2 = z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = x;\n          firstLegPlane = testPointFixedZPlane;\n          firstLegAbovePlane = testPointFixedZAbovePlane;\n          firstLegBelowPlane = testPointFixedZBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = zTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YIntersectionsX) {\n        // Travel would be in XZ plane (fixed y) then in YZ (fixed x)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.y - p.y;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = x - p.x;\n        final double cpDelta2 = z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = y;\n          firstLegPlane = testPointFixedXPlane;\n          firstLegAbovePlane = testPointFixedXAbovePlane;\n          firstLegBelowPlane = testPointFixedXBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = xTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YIntersectionsZ) {\n        // Travel would be in XZ plane (fixed y) then in XY (fixed z)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.y - p.y;\n        final double cpDelta1 = x - p.x;\n        final double cpDelta2 = z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = y;\n          firstLegPlane = testPointFixedZPlane;\n          firstLegAbovePlane = testPointFixedZAbovePlane;\n          firstLegBelowPlane = testPointFixedZBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = zTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : ZIntersectionsX) {\n        // Travel would be in XY plane (fixed z) then in YZ (fixed x)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.y - p.y;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = y - p.y;\n        final double cpDelta2 = x - p.x;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n        //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = z;\n          firstLegPlane = testPointFixedXPlane;\n          firstLegAbovePlane = testPointFixedXAbovePlane;\n          firstLegBelowPlane = testPointFixedXBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = xTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : ZIntersectionsY) {\n        // Travel would be in XY plane (fixed z) then in XZ (fixed y)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = y - p.y;\n        final double cpDelta2 = x - p.x;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n        //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = z;\n          firstLegPlane = testPointFixedYPlane;\n          firstLegAbovePlane = testPointFixedYAbovePlane;\n          firstLegBelowPlane = testPointFixedYBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = yTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n\n      assert bestDistance > 0.0 : \"Best distance should not be zero unless on single plane\";\n      assert bestDistance < Double.MAX_VALUE : \"Couldn't find an intersection point of any kind\";\n      \n      final DualCrossingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(firstLegPlane, firstLegAbovePlane, firstLegBelowPlane, secondLegPlane, x, y, z, intersectionPoint);\n      if (!firstLegTree.traverse(edgeIterator, firstLegValue)) {\n        return true;\n      }\n      edgeIterator.setSecondLeg();\n      if (!secondLegTree.traverse(edgeIterator, secondLegValue)) {\n        return true;\n      }\n      return ((edgeIterator.crossingCount  & 1) == 0)?testPointInSet:!testPointInSet;\n\n    }\n  }\n\n","sourceOld":"  @Override\n  public boolean isWithin(final double x, final double y, final double z) {\n    return isWithin(new Vector(x, y, z));\n  }\n\n","bugFix":null,"bugIntro":["1e7090fb56105afb6515b6506724359c32ec7639","824fea352f6fabb3a66e7d4df5c72c2ff9511359"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","date":1462576651,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(double,double,double).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(double,double,double).mjava","sourceNew":"  @Override\n  public boolean isWithin(final double x, final double y, final double z) {\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(x, y, z)) {\n      return testPointInSet;\n    }\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointFixedYPlane.evaluateIsZero(x, y, z)) {\n      // Use the XZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      if (!yTree.traverse(crossingEdgeIterator, testPoint.y)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedXPlane.evaluateIsZero(x, y, z)) {\n      // Use the YZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      if (!xTree.traverse(crossingEdgeIterator, testPoint.x)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedZPlane.evaluateIsZero(x, y, z)) {\n      // Use the XY plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!zTree.traverse(crossingEdgeIterator, testPoint.z)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else {\n      \n      // This is the expensive part!!\n      // Changing the code below has an enormous impact on the queries per second we see with the benchmark.\n      \n      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.\n      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -x);\n      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -y);\n      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -z);\n\n      // Find the intersection points for each one of these and the complementary test point planes.\n      final GeoPoint[] XIntersectionsY = travelPlaneFixedX.findIntersections(planetModel, testPointFixedYPlane);\n      final GeoPoint[] XIntersectionsZ = travelPlaneFixedX.findIntersections(planetModel, testPointFixedZPlane);\n      final GeoPoint[] YIntersectionsX = travelPlaneFixedY.findIntersections(planetModel, testPointFixedXPlane);\n      final GeoPoint[] YIntersectionsZ = travelPlaneFixedY.findIntersections(planetModel, testPointFixedZPlane);\n      final GeoPoint[] ZIntersectionsX = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedXPlane);\n      final GeoPoint[] ZIntersectionsY = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedYPlane);\n\n      // There will be multiple intersection points found.  We choose the one that has the lowest total distance, as measured in delta X, delta Y, and delta Z.\n      double bestDistance = Double.MAX_VALUE;\n      double firstLegValue = 0.0;\n      double secondLegValue = 0.0;\n      Plane firstLegPlane = null;\n      Plane firstLegAbovePlane = null;\n      Plane firstLegBelowPlane = null;\n      Plane secondLegPlane = null;\n      Tree firstLegTree = null;\n      Tree secondLegTree = null;\n      GeoPoint intersectionPoint = null;\n      \n      for (final GeoPoint p : XIntersectionsY) {\n        // Travel would be in YZ plane (fixed x) then in XZ (fixed y)\n        // We compute distance we need to travel as a placeholder for the number of intersections we might encounter.\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = y - p.y;\n        final double cpDelta2 = z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = x;\n          firstLegPlane = testPointFixedYPlane;\n          firstLegAbovePlane = testPointFixedYAbovePlane;\n          firstLegBelowPlane = testPointFixedYBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = yTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : XIntersectionsZ) {\n        // Travel would be in YZ plane (fixed x) then in XY (fixed z)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.y - p.y;\n        final double cpDelta1 = y - p.y;\n        final double cpDelta2 = z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = x;\n          firstLegPlane = testPointFixedZPlane;\n          firstLegAbovePlane = testPointFixedZAbovePlane;\n          firstLegBelowPlane = testPointFixedZBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = zTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YIntersectionsX) {\n        // Travel would be in XZ plane (fixed y) then in YZ (fixed x)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.y - p.y;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = x - p.x;\n        final double cpDelta2 = z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = y;\n          firstLegPlane = testPointFixedXPlane;\n          firstLegAbovePlane = testPointFixedXAbovePlane;\n          firstLegBelowPlane = testPointFixedXBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = xTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YIntersectionsZ) {\n        // Travel would be in XZ plane (fixed y) then in XY (fixed z)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.y - p.y;\n        final double cpDelta1 = x - p.x;\n        final double cpDelta2 = z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = y;\n          firstLegPlane = testPointFixedZPlane;\n          firstLegAbovePlane = testPointFixedZAbovePlane;\n          firstLegBelowPlane = testPointFixedZBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = zTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : ZIntersectionsX) {\n        // Travel would be in XY plane (fixed z) then in YZ (fixed x)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.y - p.y;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = y - p.y;\n        final double cpDelta2 = x - p.x;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n        //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = z;\n          firstLegPlane = testPointFixedXPlane;\n          firstLegAbovePlane = testPointFixedXAbovePlane;\n          firstLegBelowPlane = testPointFixedXBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = xTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : ZIntersectionsY) {\n        // Travel would be in XY plane (fixed z) then in XZ (fixed y)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = y - p.y;\n        final double cpDelta2 = x - p.x;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n        //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = z;\n          firstLegPlane = testPointFixedYPlane;\n          firstLegAbovePlane = testPointFixedYAbovePlane;\n          firstLegBelowPlane = testPointFixedYBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = yTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n\n      assert bestDistance > 0.0 : \"Best distance should not be zero unless on single plane\";\n      assert bestDistance < Double.MAX_VALUE : \"Couldn't find an intersection point of any kind\";\n      \n      final DualCrossingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(firstLegPlane, firstLegAbovePlane, firstLegBelowPlane, secondLegPlane, x, y, z, intersectionPoint);\n      if (!firstLegTree.traverse(edgeIterator, firstLegValue)) {\n        return true;\n      }\n      edgeIterator.setSecondLeg();\n      if (!secondLegTree.traverse(edgeIterator, secondLegValue)) {\n        return true;\n      }\n      return ((edgeIterator.crossingCount  & 1) == 0)?testPointInSet:!testPointInSet;\n\n    }\n  }\n\n","sourceOld":"  @Override\n  public boolean isWithin(final double x, final double y, final double z) {\n    return isWithin(new Vector(x, y, z));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae0a2a645db6ae8e4aca176aefd05f400689d2f4","date":1463569628,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(double,double,double).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(double,double,double).mjava","sourceNew":"  @Override\n  public boolean isWithin(final double x, final double y, final double z) {\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(x, y, z)) {\n      return testPointInSet;\n    }\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointFixedYPlane.evaluateIsZero(x, y, z)) {\n      // Use the XZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      if (!yTree.traverse(crossingEdgeIterator, testPoint.y)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedXPlane.evaluateIsZero(x, y, z)) {\n      // Use the YZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      if (!xTree.traverse(crossingEdgeIterator, testPoint.x)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedZPlane.evaluateIsZero(x, y, z)) {\n      // Use the XY plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!zTree.traverse(crossingEdgeIterator, testPoint.z)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else {\n      \n      // This is the expensive part!!\n      // Changing the code below has an enormous impact on the queries per second we see with the benchmark.\n      \n      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.\n      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -x);\n      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -y);\n      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -z);\n\n      // Find the intersection points for each one of these and the complementary test point planes.\n      final GeoPoint[] XIntersectionsY = travelPlaneFixedX.findIntersections(planetModel, testPointFixedYPlane);\n      final GeoPoint[] XIntersectionsZ = travelPlaneFixedX.findIntersections(planetModel, testPointFixedZPlane);\n      final GeoPoint[] YIntersectionsX = travelPlaneFixedY.findIntersections(planetModel, testPointFixedXPlane);\n      final GeoPoint[] YIntersectionsZ = travelPlaneFixedY.findIntersections(planetModel, testPointFixedZPlane);\n      final GeoPoint[] ZIntersectionsX = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedXPlane);\n      final GeoPoint[] ZIntersectionsY = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedYPlane);\n\n      // There will be multiple intersection points found.  We choose the one that has the lowest total distance, as measured in delta X, delta Y, and delta Z.\n      double bestDistance = Double.POSITIVE_INFINITY;\n      double firstLegValue = 0.0;\n      double secondLegValue = 0.0;\n      Plane firstLegPlane = null;\n      Plane firstLegAbovePlane = null;\n      Plane firstLegBelowPlane = null;\n      Plane secondLegPlane = null;\n      Tree firstLegTree = null;\n      Tree secondLegTree = null;\n      GeoPoint intersectionPoint = null;\n      \n      for (final GeoPoint p : XIntersectionsY) {\n        // Travel would be in YZ plane (fixed x) then in XZ (fixed y)\n        // We compute distance we need to travel as a placeholder for the number of intersections we might encounter.\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = y - p.y;\n        final double cpDelta2 = z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = x;\n          firstLegPlane = testPointFixedYPlane;\n          firstLegAbovePlane = testPointFixedYAbovePlane;\n          firstLegBelowPlane = testPointFixedYBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = yTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : XIntersectionsZ) {\n        // Travel would be in YZ plane (fixed x) then in XY (fixed z)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.y - p.y;\n        final double cpDelta1 = y - p.y;\n        final double cpDelta2 = z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = x;\n          firstLegPlane = testPointFixedZPlane;\n          firstLegAbovePlane = testPointFixedZAbovePlane;\n          firstLegBelowPlane = testPointFixedZBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = zTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YIntersectionsX) {\n        // Travel would be in XZ plane (fixed y) then in YZ (fixed x)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.y - p.y;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = x - p.x;\n        final double cpDelta2 = z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = y;\n          firstLegPlane = testPointFixedXPlane;\n          firstLegAbovePlane = testPointFixedXAbovePlane;\n          firstLegBelowPlane = testPointFixedXBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = xTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YIntersectionsZ) {\n        // Travel would be in XZ plane (fixed y) then in XY (fixed z)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.y - p.y;\n        final double cpDelta1 = x - p.x;\n        final double cpDelta2 = z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = y;\n          firstLegPlane = testPointFixedZPlane;\n          firstLegAbovePlane = testPointFixedZAbovePlane;\n          firstLegBelowPlane = testPointFixedZBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = zTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : ZIntersectionsX) {\n        // Travel would be in XY plane (fixed z) then in YZ (fixed x)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.y - p.y;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = y - p.y;\n        final double cpDelta2 = x - p.x;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n        //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = z;\n          firstLegPlane = testPointFixedXPlane;\n          firstLegAbovePlane = testPointFixedXAbovePlane;\n          firstLegBelowPlane = testPointFixedXBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = xTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : ZIntersectionsY) {\n        // Travel would be in XY plane (fixed z) then in XZ (fixed y)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = y - p.y;\n        final double cpDelta2 = x - p.x;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n        //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = z;\n          firstLegPlane = testPointFixedYPlane;\n          firstLegAbovePlane = testPointFixedYAbovePlane;\n          firstLegBelowPlane = testPointFixedYBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = yTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n\n      assert bestDistance > 0.0 : \"Best distance should not be zero unless on single plane\";\n      assert bestDistance < Double.POSITIVE_INFINITY : \"Couldn't find an intersection point of any kind\";\n      \n      final DualCrossingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(firstLegPlane, firstLegAbovePlane, firstLegBelowPlane, secondLegPlane, x, y, z, intersectionPoint);\n      if (!firstLegTree.traverse(edgeIterator, firstLegValue)) {\n        return true;\n      }\n      edgeIterator.setSecondLeg();\n      if (!secondLegTree.traverse(edgeIterator, secondLegValue)) {\n        return true;\n      }\n      return ((edgeIterator.crossingCount  & 1) == 0)?testPointInSet:!testPointInSet;\n\n    }\n  }\n\n","sourceOld":"  @Override\n  public boolean isWithin(final double x, final double y, final double z) {\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(x, y, z)) {\n      return testPointInSet;\n    }\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointFixedYPlane.evaluateIsZero(x, y, z)) {\n      // Use the XZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      if (!yTree.traverse(crossingEdgeIterator, testPoint.y)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedXPlane.evaluateIsZero(x, y, z)) {\n      // Use the YZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      if (!xTree.traverse(crossingEdgeIterator, testPoint.x)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedZPlane.evaluateIsZero(x, y, z)) {\n      // Use the XY plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!zTree.traverse(crossingEdgeIterator, testPoint.z)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else {\n      \n      // This is the expensive part!!\n      // Changing the code below has an enormous impact on the queries per second we see with the benchmark.\n      \n      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.\n      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -x);\n      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -y);\n      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -z);\n\n      // Find the intersection points for each one of these and the complementary test point planes.\n      final GeoPoint[] XIntersectionsY = travelPlaneFixedX.findIntersections(planetModel, testPointFixedYPlane);\n      final GeoPoint[] XIntersectionsZ = travelPlaneFixedX.findIntersections(planetModel, testPointFixedZPlane);\n      final GeoPoint[] YIntersectionsX = travelPlaneFixedY.findIntersections(planetModel, testPointFixedXPlane);\n      final GeoPoint[] YIntersectionsZ = travelPlaneFixedY.findIntersections(planetModel, testPointFixedZPlane);\n      final GeoPoint[] ZIntersectionsX = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedXPlane);\n      final GeoPoint[] ZIntersectionsY = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedYPlane);\n\n      // There will be multiple intersection points found.  We choose the one that has the lowest total distance, as measured in delta X, delta Y, and delta Z.\n      double bestDistance = Double.MAX_VALUE;\n      double firstLegValue = 0.0;\n      double secondLegValue = 0.0;\n      Plane firstLegPlane = null;\n      Plane firstLegAbovePlane = null;\n      Plane firstLegBelowPlane = null;\n      Plane secondLegPlane = null;\n      Tree firstLegTree = null;\n      Tree secondLegTree = null;\n      GeoPoint intersectionPoint = null;\n      \n      for (final GeoPoint p : XIntersectionsY) {\n        // Travel would be in YZ plane (fixed x) then in XZ (fixed y)\n        // We compute distance we need to travel as a placeholder for the number of intersections we might encounter.\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = y - p.y;\n        final double cpDelta2 = z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = x;\n          firstLegPlane = testPointFixedYPlane;\n          firstLegAbovePlane = testPointFixedYAbovePlane;\n          firstLegBelowPlane = testPointFixedYBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = yTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : XIntersectionsZ) {\n        // Travel would be in YZ plane (fixed x) then in XY (fixed z)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.y - p.y;\n        final double cpDelta1 = y - p.y;\n        final double cpDelta2 = z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = x;\n          firstLegPlane = testPointFixedZPlane;\n          firstLegAbovePlane = testPointFixedZAbovePlane;\n          firstLegBelowPlane = testPointFixedZBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = zTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YIntersectionsX) {\n        // Travel would be in XZ plane (fixed y) then in YZ (fixed x)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.y - p.y;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = x - p.x;\n        final double cpDelta2 = z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = y;\n          firstLegPlane = testPointFixedXPlane;\n          firstLegAbovePlane = testPointFixedXAbovePlane;\n          firstLegBelowPlane = testPointFixedXBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = xTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YIntersectionsZ) {\n        // Travel would be in XZ plane (fixed y) then in XY (fixed z)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.y - p.y;\n        final double cpDelta1 = x - p.x;\n        final double cpDelta2 = z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = y;\n          firstLegPlane = testPointFixedZPlane;\n          firstLegAbovePlane = testPointFixedZAbovePlane;\n          firstLegBelowPlane = testPointFixedZBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = zTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : ZIntersectionsX) {\n        // Travel would be in XY plane (fixed z) then in YZ (fixed x)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.y - p.y;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = y - p.y;\n        final double cpDelta2 = x - p.x;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n        //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = z;\n          firstLegPlane = testPointFixedXPlane;\n          firstLegAbovePlane = testPointFixedXAbovePlane;\n          firstLegBelowPlane = testPointFixedXBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = xTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : ZIntersectionsY) {\n        // Travel would be in XY plane (fixed z) then in XZ (fixed y)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = y - p.y;\n        final double cpDelta2 = x - p.x;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n        //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = z;\n          firstLegPlane = testPointFixedYPlane;\n          firstLegAbovePlane = testPointFixedYAbovePlane;\n          firstLegBelowPlane = testPointFixedYBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = yTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n\n      assert bestDistance > 0.0 : \"Best distance should not be zero unless on single plane\";\n      assert bestDistance < Double.MAX_VALUE : \"Couldn't find an intersection point of any kind\";\n      \n      final DualCrossingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(firstLegPlane, firstLegAbovePlane, firstLegBelowPlane, secondLegPlane, x, y, z, intersectionPoint);\n      if (!firstLegTree.traverse(edgeIterator, firstLegValue)) {\n        return true;\n      }\n      edgeIterator.setSecondLeg();\n      if (!secondLegTree.traverse(edgeIterator, secondLegValue)) {\n        return true;\n      }\n      return ((edgeIterator.crossingCount  & 1) == 0)?testPointInSet:!testPointInSet;\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(double,double,double).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(double,double,double).mjava","sourceNew":"  @Override\n  public boolean isWithin(final double x, final double y, final double z) {\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(x, y, z)) {\n      return testPointInSet;\n    }\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointFixedYPlane.evaluateIsZero(x, y, z)) {\n      // Use the XZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      if (!yTree.traverse(crossingEdgeIterator, testPoint.y)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedXPlane.evaluateIsZero(x, y, z)) {\n      // Use the YZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      if (!xTree.traverse(crossingEdgeIterator, testPoint.x)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedZPlane.evaluateIsZero(x, y, z)) {\n      // Use the XY plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!zTree.traverse(crossingEdgeIterator, testPoint.z)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else {\n      \n      // This is the expensive part!!\n      // Changing the code below has an enormous impact on the queries per second we see with the benchmark.\n      \n      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.\n      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -x);\n      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -y);\n      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -z);\n\n      // Find the intersection points for each one of these and the complementary test point planes.\n      final GeoPoint[] XIntersectionsY = travelPlaneFixedX.findIntersections(planetModel, testPointFixedYPlane);\n      final GeoPoint[] XIntersectionsZ = travelPlaneFixedX.findIntersections(planetModel, testPointFixedZPlane);\n      final GeoPoint[] YIntersectionsX = travelPlaneFixedY.findIntersections(planetModel, testPointFixedXPlane);\n      final GeoPoint[] YIntersectionsZ = travelPlaneFixedY.findIntersections(planetModel, testPointFixedZPlane);\n      final GeoPoint[] ZIntersectionsX = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedXPlane);\n      final GeoPoint[] ZIntersectionsY = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedYPlane);\n\n      // There will be multiple intersection points found.  We choose the one that has the lowest total distance, as measured in delta X, delta Y, and delta Z.\n      double bestDistance = Double.POSITIVE_INFINITY;\n      double firstLegValue = 0.0;\n      double secondLegValue = 0.0;\n      Plane firstLegPlane = null;\n      Plane firstLegAbovePlane = null;\n      Plane firstLegBelowPlane = null;\n      Plane secondLegPlane = null;\n      Tree firstLegTree = null;\n      Tree secondLegTree = null;\n      GeoPoint intersectionPoint = null;\n      \n      for (final GeoPoint p : XIntersectionsY) {\n        // Travel would be in YZ plane (fixed x) then in XZ (fixed y)\n        // We compute distance we need to travel as a placeholder for the number of intersections we might encounter.\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = y - p.y;\n        final double cpDelta2 = z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = x;\n          firstLegPlane = testPointFixedYPlane;\n          firstLegAbovePlane = testPointFixedYAbovePlane;\n          firstLegBelowPlane = testPointFixedYBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = yTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : XIntersectionsZ) {\n        // Travel would be in YZ plane (fixed x) then in XY (fixed z)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.y - p.y;\n        final double cpDelta1 = y - p.y;\n        final double cpDelta2 = z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = x;\n          firstLegPlane = testPointFixedZPlane;\n          firstLegAbovePlane = testPointFixedZAbovePlane;\n          firstLegBelowPlane = testPointFixedZBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = zTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YIntersectionsX) {\n        // Travel would be in XZ plane (fixed y) then in YZ (fixed x)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.y - p.y;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = x - p.x;\n        final double cpDelta2 = z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = y;\n          firstLegPlane = testPointFixedXPlane;\n          firstLegAbovePlane = testPointFixedXAbovePlane;\n          firstLegBelowPlane = testPointFixedXBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = xTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YIntersectionsZ) {\n        // Travel would be in XZ plane (fixed y) then in XY (fixed z)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.y - p.y;\n        final double cpDelta1 = x - p.x;\n        final double cpDelta2 = z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = y;\n          firstLegPlane = testPointFixedZPlane;\n          firstLegAbovePlane = testPointFixedZAbovePlane;\n          firstLegBelowPlane = testPointFixedZBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = zTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : ZIntersectionsX) {\n        // Travel would be in XY plane (fixed z) then in YZ (fixed x)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.y - p.y;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = y - p.y;\n        final double cpDelta2 = x - p.x;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n        //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = z;\n          firstLegPlane = testPointFixedXPlane;\n          firstLegAbovePlane = testPointFixedXAbovePlane;\n          firstLegBelowPlane = testPointFixedXBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = xTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : ZIntersectionsY) {\n        // Travel would be in XY plane (fixed z) then in XZ (fixed y)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = y - p.y;\n        final double cpDelta2 = x - p.x;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n        //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = z;\n          firstLegPlane = testPointFixedYPlane;\n          firstLegAbovePlane = testPointFixedYAbovePlane;\n          firstLegBelowPlane = testPointFixedYBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = yTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n\n      assert bestDistance > 0.0 : \"Best distance should not be zero unless on single plane\";\n      assert bestDistance < Double.POSITIVE_INFINITY : \"Couldn't find an intersection point of any kind\";\n      \n      final DualCrossingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(firstLegPlane, firstLegAbovePlane, firstLegBelowPlane, secondLegPlane, x, y, z, intersectionPoint);\n      if (!firstLegTree.traverse(edgeIterator, firstLegValue)) {\n        return true;\n      }\n      edgeIterator.setSecondLeg();\n      if (!secondLegTree.traverse(edgeIterator, secondLegValue)) {\n        return true;\n      }\n      return ((edgeIterator.crossingCount  & 1) == 0)?testPointInSet:!testPointInSet;\n\n    }\n  }\n\n","sourceOld":"  @Override\n  public boolean isWithin(final double x, final double y, final double z) {\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(x, y, z)) {\n      return testPointInSet;\n    }\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointFixedYPlane.evaluateIsZero(x, y, z)) {\n      // Use the XZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      if (!yTree.traverse(crossingEdgeIterator, testPoint.y)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedXPlane.evaluateIsZero(x, y, z)) {\n      // Use the YZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      if (!xTree.traverse(crossingEdgeIterator, testPoint.x)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedZPlane.evaluateIsZero(x, y, z)) {\n      // Use the XY plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!zTree.traverse(crossingEdgeIterator, testPoint.z)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else {\n      \n      // This is the expensive part!!\n      // Changing the code below has an enormous impact on the queries per second we see with the benchmark.\n      \n      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.\n      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -x);\n      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -y);\n      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -z);\n\n      // Find the intersection points for each one of these and the complementary test point planes.\n      final GeoPoint[] XIntersectionsY = travelPlaneFixedX.findIntersections(planetModel, testPointFixedYPlane);\n      final GeoPoint[] XIntersectionsZ = travelPlaneFixedX.findIntersections(planetModel, testPointFixedZPlane);\n      final GeoPoint[] YIntersectionsX = travelPlaneFixedY.findIntersections(planetModel, testPointFixedXPlane);\n      final GeoPoint[] YIntersectionsZ = travelPlaneFixedY.findIntersections(planetModel, testPointFixedZPlane);\n      final GeoPoint[] ZIntersectionsX = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedXPlane);\n      final GeoPoint[] ZIntersectionsY = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedYPlane);\n\n      // There will be multiple intersection points found.  We choose the one that has the lowest total distance, as measured in delta X, delta Y, and delta Z.\n      double bestDistance = Double.MAX_VALUE;\n      double firstLegValue = 0.0;\n      double secondLegValue = 0.0;\n      Plane firstLegPlane = null;\n      Plane firstLegAbovePlane = null;\n      Plane firstLegBelowPlane = null;\n      Plane secondLegPlane = null;\n      Tree firstLegTree = null;\n      Tree secondLegTree = null;\n      GeoPoint intersectionPoint = null;\n      \n      for (final GeoPoint p : XIntersectionsY) {\n        // Travel would be in YZ plane (fixed x) then in XZ (fixed y)\n        // We compute distance we need to travel as a placeholder for the number of intersections we might encounter.\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = y - p.y;\n        final double cpDelta2 = z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = x;\n          firstLegPlane = testPointFixedYPlane;\n          firstLegAbovePlane = testPointFixedYAbovePlane;\n          firstLegBelowPlane = testPointFixedYBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = yTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : XIntersectionsZ) {\n        // Travel would be in YZ plane (fixed x) then in XY (fixed z)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.y - p.y;\n        final double cpDelta1 = y - p.y;\n        final double cpDelta2 = z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = x;\n          firstLegPlane = testPointFixedZPlane;\n          firstLegAbovePlane = testPointFixedZAbovePlane;\n          firstLegBelowPlane = testPointFixedZBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = zTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YIntersectionsX) {\n        // Travel would be in XZ plane (fixed y) then in YZ (fixed x)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.y - p.y;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = x - p.x;\n        final double cpDelta2 = z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = y;\n          firstLegPlane = testPointFixedXPlane;\n          firstLegAbovePlane = testPointFixedXAbovePlane;\n          firstLegBelowPlane = testPointFixedXBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = xTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YIntersectionsZ) {\n        // Travel would be in XZ plane (fixed y) then in XY (fixed z)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.y - p.y;\n        final double cpDelta1 = x - p.x;\n        final double cpDelta2 = z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = y;\n          firstLegPlane = testPointFixedZPlane;\n          firstLegAbovePlane = testPointFixedZAbovePlane;\n          firstLegBelowPlane = testPointFixedZBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = zTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : ZIntersectionsX) {\n        // Travel would be in XY plane (fixed z) then in YZ (fixed x)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.y - p.y;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = y - p.y;\n        final double cpDelta2 = x - p.x;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n        //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = z;\n          firstLegPlane = testPointFixedXPlane;\n          firstLegAbovePlane = testPointFixedXAbovePlane;\n          firstLegBelowPlane = testPointFixedXBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = xTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : ZIntersectionsY) {\n        // Travel would be in XY plane (fixed z) then in XZ (fixed y)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = y - p.y;\n        final double cpDelta2 = x - p.x;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n        //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = z;\n          firstLegPlane = testPointFixedYPlane;\n          firstLegAbovePlane = testPointFixedYAbovePlane;\n          firstLegBelowPlane = testPointFixedYBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = yTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n\n      assert bestDistance > 0.0 : \"Best distance should not be zero unless on single plane\";\n      assert bestDistance < Double.MAX_VALUE : \"Couldn't find an intersection point of any kind\";\n      \n      final DualCrossingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(firstLegPlane, firstLegAbovePlane, firstLegBelowPlane, secondLegPlane, x, y, z, intersectionPoint);\n      if (!firstLegTree.traverse(edgeIterator, firstLegValue)) {\n        return true;\n      }\n      edgeIterator.setSecondLeg();\n      if (!secondLegTree.traverse(edgeIterator, secondLegValue)) {\n        return true;\n      }\n      return ((edgeIterator.crossingCount  & 1) == 0)?testPointInSet:!testPointInSet;\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(double,double,double).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(double,double,double).mjava","sourceNew":"  @Override\n  public boolean isWithin(final double x, final double y, final double z) {\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(x, y, z)) {\n      return testPointInSet;\n    }\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointFixedYPlane.evaluateIsZero(x, y, z)) {\n      // Use the XZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      if (!yTree.traverse(crossingEdgeIterator, testPoint.y)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedXPlane.evaluateIsZero(x, y, z)) {\n      // Use the YZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      if (!xTree.traverse(crossingEdgeIterator, testPoint.x)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedZPlane.evaluateIsZero(x, y, z)) {\n      // Use the XY plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!zTree.traverse(crossingEdgeIterator, testPoint.z)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else {\n      \n      // This is the expensive part!!\n      // Changing the code below has an enormous impact on the queries per second we see with the benchmark.\n      \n      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.\n      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -x);\n      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -y);\n      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -z);\n\n      // Find the intersection points for each one of these and the complementary test point planes.\n      final GeoPoint[] XIntersectionsY = travelPlaneFixedX.findIntersections(planetModel, testPointFixedYPlane);\n      final GeoPoint[] XIntersectionsZ = travelPlaneFixedX.findIntersections(planetModel, testPointFixedZPlane);\n      final GeoPoint[] YIntersectionsX = travelPlaneFixedY.findIntersections(planetModel, testPointFixedXPlane);\n      final GeoPoint[] YIntersectionsZ = travelPlaneFixedY.findIntersections(planetModel, testPointFixedZPlane);\n      final GeoPoint[] ZIntersectionsX = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedXPlane);\n      final GeoPoint[] ZIntersectionsY = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedYPlane);\n\n      // There will be multiple intersection points found.  We choose the one that has the lowest total distance, as measured in delta X, delta Y, and delta Z.\n      double bestDistance = Double.POSITIVE_INFINITY;\n      double firstLegValue = 0.0;\n      double secondLegValue = 0.0;\n      Plane firstLegPlane = null;\n      Plane firstLegAbovePlane = null;\n      Plane firstLegBelowPlane = null;\n      Plane secondLegPlane = null;\n      Tree firstLegTree = null;\n      Tree secondLegTree = null;\n      GeoPoint intersectionPoint = null;\n      \n      for (final GeoPoint p : XIntersectionsY) {\n        // Travel would be in YZ plane (fixed x) then in XZ (fixed y)\n        // We compute distance we need to travel as a placeholder for the number of intersections we might encounter.\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = y - p.y;\n        final double cpDelta2 = z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = x;\n          firstLegPlane = testPointFixedYPlane;\n          firstLegAbovePlane = testPointFixedYAbovePlane;\n          firstLegBelowPlane = testPointFixedYBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = yTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : XIntersectionsZ) {\n        // Travel would be in YZ plane (fixed x) then in XY (fixed z)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.y - p.y;\n        final double cpDelta1 = y - p.y;\n        final double cpDelta2 = z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = x;\n          firstLegPlane = testPointFixedZPlane;\n          firstLegAbovePlane = testPointFixedZAbovePlane;\n          firstLegBelowPlane = testPointFixedZBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = zTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YIntersectionsX) {\n        // Travel would be in XZ plane (fixed y) then in YZ (fixed x)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.y - p.y;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = x - p.x;\n        final double cpDelta2 = z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = y;\n          firstLegPlane = testPointFixedXPlane;\n          firstLegAbovePlane = testPointFixedXAbovePlane;\n          firstLegBelowPlane = testPointFixedXBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = xTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YIntersectionsZ) {\n        // Travel would be in XZ plane (fixed y) then in XY (fixed z)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.y - p.y;\n        final double cpDelta1 = x - p.x;\n        final double cpDelta2 = z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = y;\n          firstLegPlane = testPointFixedZPlane;\n          firstLegAbovePlane = testPointFixedZAbovePlane;\n          firstLegBelowPlane = testPointFixedZBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = zTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : ZIntersectionsX) {\n        // Travel would be in XY plane (fixed z) then in YZ (fixed x)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.y - p.y;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = y - p.y;\n        final double cpDelta2 = x - p.x;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n        //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = z;\n          firstLegPlane = testPointFixedXPlane;\n          firstLegAbovePlane = testPointFixedXAbovePlane;\n          firstLegBelowPlane = testPointFixedXBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = xTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : ZIntersectionsY) {\n        // Travel would be in XY plane (fixed z) then in XZ (fixed y)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = y - p.y;\n        final double cpDelta2 = x - p.x;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n        //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = z;\n          firstLegPlane = testPointFixedYPlane;\n          firstLegAbovePlane = testPointFixedYAbovePlane;\n          firstLegBelowPlane = testPointFixedYBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = yTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n\n      assert bestDistance > 0.0 : \"Best distance should not be zero unless on single plane\";\n      assert bestDistance < Double.POSITIVE_INFINITY : \"Couldn't find an intersection point of any kind\";\n      \n      final DualCrossingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(firstLegPlane, firstLegAbovePlane, firstLegBelowPlane, secondLegPlane, x, y, z, intersectionPoint);\n      if (!firstLegTree.traverse(edgeIterator, firstLegValue)) {\n        return true;\n      }\n      edgeIterator.setSecondLeg();\n      if (!secondLegTree.traverse(edgeIterator, secondLegValue)) {\n        return true;\n      }\n      return ((edgeIterator.crossingCount  & 1) == 0)?testPointInSet:!testPointInSet;\n\n    }\n  }\n\n","sourceOld":"  @Override\n  public boolean isWithin(final double x, final double y, final double z) {\n    return isWithin(new Vector(x, y, z));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e7090fb56105afb6515b6506724359c32ec7639","date":1521211434,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(double,double,double).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(double,double,double).mjava","sourceNew":"  @Override\n  public boolean isWithin(final double x, final double y, final double z) {\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(x, y, z)) {\n      return testPointInSet;\n    }\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointFixedYPlane.evaluateIsZero(x, y, z)) {\n      // Use the XZ plane exclusively.\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      if (!yTree.traverse(crossingEdgeIterator, testPoint.y)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedXPlane.evaluateIsZero(x, y, z)) {\n      // Use the YZ plane exclusively.\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      if (!xTree.traverse(crossingEdgeIterator, testPoint.x)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedZPlane.evaluateIsZero(x, y, z)) {\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!zTree.traverse(crossingEdgeIterator, testPoint.z)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n    } else {\n      \n      // This is the expensive part!!\n      // Changing the code below has an enormous impact on the queries per second we see with the benchmark.\n      \n      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.\n      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -x);\n      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -y);\n      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -z);\n\n      // Find the intersection points for each one of these and the complementary test point planes.\n      final GeoPoint[] XIntersectionsY = travelPlaneFixedX.findIntersections(planetModel, testPointFixedYPlane);\n      final GeoPoint[] XIntersectionsZ = travelPlaneFixedX.findIntersections(planetModel, testPointFixedZPlane);\n      final GeoPoint[] YIntersectionsX = travelPlaneFixedY.findIntersections(planetModel, testPointFixedXPlane);\n      final GeoPoint[] YIntersectionsZ = travelPlaneFixedY.findIntersections(planetModel, testPointFixedZPlane);\n      final GeoPoint[] ZIntersectionsX = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedXPlane);\n      final GeoPoint[] ZIntersectionsY = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedYPlane);\n\n      // There will be multiple intersection points found.  We choose the one that has the lowest total distance, as measured in delta X, delta Y, and delta Z.\n      double bestDistance = Double.POSITIVE_INFINITY;\n      double firstLegValue = 0.0;\n      double secondLegValue = 0.0;\n      Plane firstLegPlane = null;\n      Plane firstLegAbovePlane = null;\n      Plane firstLegBelowPlane = null;\n      Plane secondLegPlane = null;\n      Tree firstLegTree = null;\n      Tree secondLegTree = null;\n      GeoPoint intersectionPoint = null;\n      \n      for (final GeoPoint p : XIntersectionsY) {\n        // Travel would be in YZ plane (fixed x) then in XZ (fixed y)\n        // We compute distance we need to travel as a placeholder for the number of intersections we might encounter.\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = y - p.y;\n        final double cpDelta2 = z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = x;\n          firstLegPlane = testPointFixedYPlane;\n          firstLegAbovePlane = testPointFixedYAbovePlane;\n          firstLegBelowPlane = testPointFixedYBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = yTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : XIntersectionsZ) {\n        // Travel would be in YZ plane (fixed x) then in XY (fixed z)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.y - p.y;\n        final double cpDelta1 = y - p.y;\n        final double cpDelta2 = z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = x;\n          firstLegPlane = testPointFixedZPlane;\n          firstLegAbovePlane = testPointFixedZAbovePlane;\n          firstLegBelowPlane = testPointFixedZBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = zTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YIntersectionsX) {\n        // Travel would be in XZ plane (fixed y) then in YZ (fixed x)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.y - p.y;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = x - p.x;\n        final double cpDelta2 = z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = y;\n          firstLegPlane = testPointFixedXPlane;\n          firstLegAbovePlane = testPointFixedXAbovePlane;\n          firstLegBelowPlane = testPointFixedXBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = xTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YIntersectionsZ) {\n        // Travel would be in XZ plane (fixed y) then in XY (fixed z)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.y - p.y;\n        final double cpDelta1 = x - p.x;\n        final double cpDelta2 = z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = y;\n          firstLegPlane = testPointFixedZPlane;\n          firstLegAbovePlane = testPointFixedZAbovePlane;\n          firstLegBelowPlane = testPointFixedZBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = zTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : ZIntersectionsX) {\n        // Travel would be in XY plane (fixed z) then in YZ (fixed x)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.y - p.y;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = y - p.y;\n        final double cpDelta2 = x - p.x;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n        //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = z;\n          firstLegPlane = testPointFixedXPlane;\n          firstLegAbovePlane = testPointFixedXAbovePlane;\n          firstLegBelowPlane = testPointFixedXBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = xTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : ZIntersectionsY) {\n        // Travel would be in XY plane (fixed z) then in XZ (fixed y)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = y - p.y;\n        final double cpDelta2 = x - p.x;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n        //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = z;\n          firstLegPlane = testPointFixedYPlane;\n          firstLegAbovePlane = testPointFixedYAbovePlane;\n          firstLegBelowPlane = testPointFixedYBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = yTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n\n      assert bestDistance > 0.0 : \"Best distance should not be zero unless on single plane\";\n      assert bestDistance < Double.POSITIVE_INFINITY : \"Couldn't find an intersection point of any kind\";\n      \n      final DualCrossingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(firstLegPlane, firstLegAbovePlane, firstLegBelowPlane, secondLegPlane, x, y, z, intersectionPoint);\n      if (!firstLegTree.traverse(edgeIterator, firstLegValue)) {\n        return true;\n      }\n      edgeIterator.setSecondLeg();\n      if (!secondLegTree.traverse(edgeIterator, secondLegValue)) {\n        return true;\n      }\n      return ((edgeIterator.crossingCount  & 1) == 0)?testPointInSet:!testPointInSet;\n\n    }\n  }\n\n","sourceOld":"  @Override\n  public boolean isWithin(final double x, final double y, final double z) {\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(x, y, z)) {\n      return testPointInSet;\n    }\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointFixedYPlane.evaluateIsZero(x, y, z)) {\n      // Use the XZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      if (!yTree.traverse(crossingEdgeIterator, testPoint.y)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedXPlane.evaluateIsZero(x, y, z)) {\n      // Use the YZ plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      if (!xTree.traverse(crossingEdgeIterator, testPoint.x)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedZPlane.evaluateIsZero(x, y, z)) {\n      // Use the XY plane exclusively.\n      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!zTree.traverse(crossingEdgeIterator, testPoint.z)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;\n    } else {\n      \n      // This is the expensive part!!\n      // Changing the code below has an enormous impact on the queries per second we see with the benchmark.\n      \n      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.\n      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -x);\n      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -y);\n      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -z);\n\n      // Find the intersection points for each one of these and the complementary test point planes.\n      final GeoPoint[] XIntersectionsY = travelPlaneFixedX.findIntersections(planetModel, testPointFixedYPlane);\n      final GeoPoint[] XIntersectionsZ = travelPlaneFixedX.findIntersections(planetModel, testPointFixedZPlane);\n      final GeoPoint[] YIntersectionsX = travelPlaneFixedY.findIntersections(planetModel, testPointFixedXPlane);\n      final GeoPoint[] YIntersectionsZ = travelPlaneFixedY.findIntersections(planetModel, testPointFixedZPlane);\n      final GeoPoint[] ZIntersectionsX = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedXPlane);\n      final GeoPoint[] ZIntersectionsY = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedYPlane);\n\n      // There will be multiple intersection points found.  We choose the one that has the lowest total distance, as measured in delta X, delta Y, and delta Z.\n      double bestDistance = Double.POSITIVE_INFINITY;\n      double firstLegValue = 0.0;\n      double secondLegValue = 0.0;\n      Plane firstLegPlane = null;\n      Plane firstLegAbovePlane = null;\n      Plane firstLegBelowPlane = null;\n      Plane secondLegPlane = null;\n      Tree firstLegTree = null;\n      Tree secondLegTree = null;\n      GeoPoint intersectionPoint = null;\n      \n      for (final GeoPoint p : XIntersectionsY) {\n        // Travel would be in YZ plane (fixed x) then in XZ (fixed y)\n        // We compute distance we need to travel as a placeholder for the number of intersections we might encounter.\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = y - p.y;\n        final double cpDelta2 = z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = x;\n          firstLegPlane = testPointFixedYPlane;\n          firstLegAbovePlane = testPointFixedYAbovePlane;\n          firstLegBelowPlane = testPointFixedYBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = yTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : XIntersectionsZ) {\n        // Travel would be in YZ plane (fixed x) then in XY (fixed z)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.y - p.y;\n        final double cpDelta1 = y - p.y;\n        final double cpDelta2 = z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = x;\n          firstLegPlane = testPointFixedZPlane;\n          firstLegAbovePlane = testPointFixedZAbovePlane;\n          firstLegBelowPlane = testPointFixedZBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = zTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YIntersectionsX) {\n        // Travel would be in XZ plane (fixed y) then in YZ (fixed x)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.y - p.y;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = x - p.x;\n        final double cpDelta2 = z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = y;\n          firstLegPlane = testPointFixedXPlane;\n          firstLegAbovePlane = testPointFixedXAbovePlane;\n          firstLegBelowPlane = testPointFixedXBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = xTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YIntersectionsZ) {\n        // Travel would be in XZ plane (fixed y) then in XY (fixed z)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.y - p.y;\n        final double cpDelta1 = x - p.x;\n        final double cpDelta2 = z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = y;\n          firstLegPlane = testPointFixedZPlane;\n          firstLegAbovePlane = testPointFixedZAbovePlane;\n          firstLegBelowPlane = testPointFixedZBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = zTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : ZIntersectionsX) {\n        // Travel would be in XY plane (fixed z) then in YZ (fixed x)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.y - p.y;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = y - p.y;\n        final double cpDelta2 = x - p.x;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n        //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = z;\n          firstLegPlane = testPointFixedXPlane;\n          firstLegAbovePlane = testPointFixedXAbovePlane;\n          firstLegBelowPlane = testPointFixedXBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = xTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : ZIntersectionsY) {\n        // Travel would be in XY plane (fixed z) then in XZ (fixed y)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = y - p.y;\n        final double cpDelta2 = x - p.x;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n        //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = z;\n          firstLegPlane = testPointFixedYPlane;\n          firstLegAbovePlane = testPointFixedYAbovePlane;\n          firstLegBelowPlane = testPointFixedYBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = yTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n\n      assert bestDistance > 0.0 : \"Best distance should not be zero unless on single plane\";\n      assert bestDistance < Double.POSITIVE_INFINITY : \"Couldn't find an intersection point of any kind\";\n      \n      final DualCrossingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(firstLegPlane, firstLegAbovePlane, firstLegBelowPlane, secondLegPlane, x, y, z, intersectionPoint);\n      if (!firstLegTree.traverse(edgeIterator, firstLegValue)) {\n        return true;\n      }\n      edgeIterator.setSecondLeg();\n      if (!secondLegTree.traverse(edgeIterator, secondLegValue)) {\n        return true;\n      }\n      return ((edgeIterator.crossingCount  & 1) == 0)?testPointInSet:!testPointInSet;\n\n    }\n  }\n\n","bugFix":["7fe41964e49958f662028ea7ed8c224e0955edae"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8b879b14da40ab73551b75835099a61e622a83d3","date":1522406622,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(double,double,double).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(double,double,double).mjava","sourceNew":"  @Override\n  public boolean isWithin(final double x, final double y, final double z) {\n    //System.out.println(\"\\nIswithin called for [\"+x+\",\"+y+\",\"+z+\"]\");\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(x, y, z)) {\n      return testPointInSet;\n    }\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointFixedYPlane.evaluateIsZero(x, y, z)) {\n      // Use the XZ plane exclusively.\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      if (!yTree.traverse(crossingEdgeIterator, testPoint.y)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedXPlane.evaluateIsZero(x, y, z)) {\n      // Use the YZ plane exclusively.\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      if (!xTree.traverse(crossingEdgeIterator, testPoint.x)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedZPlane.evaluateIsZero(x, y, z)) {\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!zTree.traverse(crossingEdgeIterator, testPoint.z)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n    } else {\n      \n      // This is the expensive part!!\n      // Changing the code below has an enormous impact on the queries per second we see with the benchmark.\n      \n      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.\n      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -x);\n      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -y);\n      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -z);\n\n      // Find the intersection points for each one of these and the complementary test point planes.\n      final GeoPoint[] XIntersectionsY = travelPlaneFixedX.findIntersections(planetModel, testPointFixedYPlane);\n      final GeoPoint[] XIntersectionsZ = travelPlaneFixedX.findIntersections(planetModel, testPointFixedZPlane);\n      final GeoPoint[] YIntersectionsX = travelPlaneFixedY.findIntersections(planetModel, testPointFixedXPlane);\n      final GeoPoint[] YIntersectionsZ = travelPlaneFixedY.findIntersections(planetModel, testPointFixedZPlane);\n      final GeoPoint[] ZIntersectionsX = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedXPlane);\n      final GeoPoint[] ZIntersectionsY = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedYPlane);\n\n      // There will be multiple intersection points found.  We choose the one that has the lowest total distance, as measured in delta X, delta Y, and delta Z.\n      double bestDistance = Double.POSITIVE_INFINITY;\n      double firstLegValue = 0.0;\n      double secondLegValue = 0.0;\n      Plane firstLegPlane = null;\n      Plane firstLegAbovePlane = null;\n      Plane firstLegBelowPlane = null;\n      Plane secondLegPlane = null;\n      Tree firstLegTree = null;\n      Tree secondLegTree = null;\n      GeoPoint intersectionPoint = null;\n      \n      for (final GeoPoint p : XIntersectionsY) {\n        // Travel would be in YZ plane (fixed x) then in XZ (fixed y)\n        // We compute distance we need to travel as a placeholder for the number of intersections we might encounter.\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = y - p.y;\n        final double cpDelta2 = z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = x;\n          firstLegPlane = testPointFixedYPlane;\n          firstLegAbovePlane = testPointFixedYAbovePlane;\n          firstLegBelowPlane = testPointFixedYBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = yTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : XIntersectionsZ) {\n        // Travel would be in YZ plane (fixed x) then in XY (fixed z)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.y - p.y;\n        final double cpDelta1 = y - p.y;\n        final double cpDelta2 = z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = x;\n          firstLegPlane = testPointFixedZPlane;\n          firstLegAbovePlane = testPointFixedZAbovePlane;\n          firstLegBelowPlane = testPointFixedZBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = zTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YIntersectionsX) {\n        // Travel would be in XZ plane (fixed y) then in YZ (fixed x)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.y - p.y;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = x - p.x;\n        final double cpDelta2 = z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = y;\n          firstLegPlane = testPointFixedXPlane;\n          firstLegAbovePlane = testPointFixedXAbovePlane;\n          firstLegBelowPlane = testPointFixedXBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = xTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YIntersectionsZ) {\n        // Travel would be in XZ plane (fixed y) then in XY (fixed z)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.y - p.y;\n        final double cpDelta1 = x - p.x;\n        final double cpDelta2 = z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = y;\n          firstLegPlane = testPointFixedZPlane;\n          firstLegAbovePlane = testPointFixedZAbovePlane;\n          firstLegBelowPlane = testPointFixedZBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = zTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : ZIntersectionsX) {\n        // Travel would be in XY plane (fixed z) then in YZ (fixed x)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.y - p.y;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = y - p.y;\n        final double cpDelta2 = x - p.x;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n        //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = z;\n          firstLegPlane = testPointFixedXPlane;\n          firstLegAbovePlane = testPointFixedXAbovePlane;\n          firstLegBelowPlane = testPointFixedXBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = xTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : ZIntersectionsY) {\n        // Travel would be in XY plane (fixed z) then in XZ (fixed y)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = y - p.y;\n        final double cpDelta2 = x - p.x;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n        //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = z;\n          firstLegPlane = testPointFixedYPlane;\n          firstLegAbovePlane = testPointFixedYAbovePlane;\n          firstLegBelowPlane = testPointFixedYBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = yTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n\n      assert bestDistance > 0.0 : \"Best distance should not be zero unless on single plane\";\n      assert bestDistance < Double.POSITIVE_INFINITY : \"Couldn't find an intersection point of any kind\";\n      \n      final DualCrossingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(firstLegPlane, firstLegAbovePlane, firstLegBelowPlane, secondLegPlane, x, y, z, intersectionPoint);\n      if (!firstLegTree.traverse(edgeIterator, firstLegValue)) {\n        return true;\n      }\n      //edgeIterator.setSecondLeg();\n      if (!secondLegTree.traverse(edgeIterator, secondLegValue)) {\n        return true;\n      }\n      //System.out.println(\"Polarity vs. test point: \"+(((edgeIterator.getCrossingCount()  & 1) == 0)?\"same\":\"different\")+\"; testPointInSet: \"+testPointInSet);\n      return ((edgeIterator.getCrossingCount()  & 1) == 0)?testPointInSet:!testPointInSet;\n\n    }\n  }\n\n","sourceOld":"  @Override\n  public boolean isWithin(final double x, final double y, final double z) {\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(x, y, z)) {\n      return testPointInSet;\n    }\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointFixedYPlane.evaluateIsZero(x, y, z)) {\n      // Use the XZ plane exclusively.\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      if (!yTree.traverse(crossingEdgeIterator, testPoint.y)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedXPlane.evaluateIsZero(x, y, z)) {\n      // Use the YZ plane exclusively.\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      if (!xTree.traverse(crossingEdgeIterator, testPoint.x)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedZPlane.evaluateIsZero(x, y, z)) {\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!zTree.traverse(crossingEdgeIterator, testPoint.z)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n    } else {\n      \n      // This is the expensive part!!\n      // Changing the code below has an enormous impact on the queries per second we see with the benchmark.\n      \n      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.\n      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -x);\n      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -y);\n      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -z);\n\n      // Find the intersection points for each one of these and the complementary test point planes.\n      final GeoPoint[] XIntersectionsY = travelPlaneFixedX.findIntersections(planetModel, testPointFixedYPlane);\n      final GeoPoint[] XIntersectionsZ = travelPlaneFixedX.findIntersections(planetModel, testPointFixedZPlane);\n      final GeoPoint[] YIntersectionsX = travelPlaneFixedY.findIntersections(planetModel, testPointFixedXPlane);\n      final GeoPoint[] YIntersectionsZ = travelPlaneFixedY.findIntersections(planetModel, testPointFixedZPlane);\n      final GeoPoint[] ZIntersectionsX = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedXPlane);\n      final GeoPoint[] ZIntersectionsY = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedYPlane);\n\n      // There will be multiple intersection points found.  We choose the one that has the lowest total distance, as measured in delta X, delta Y, and delta Z.\n      double bestDistance = Double.POSITIVE_INFINITY;\n      double firstLegValue = 0.0;\n      double secondLegValue = 0.0;\n      Plane firstLegPlane = null;\n      Plane firstLegAbovePlane = null;\n      Plane firstLegBelowPlane = null;\n      Plane secondLegPlane = null;\n      Tree firstLegTree = null;\n      Tree secondLegTree = null;\n      GeoPoint intersectionPoint = null;\n      \n      for (final GeoPoint p : XIntersectionsY) {\n        // Travel would be in YZ plane (fixed x) then in XZ (fixed y)\n        // We compute distance we need to travel as a placeholder for the number of intersections we might encounter.\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = y - p.y;\n        final double cpDelta2 = z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = x;\n          firstLegPlane = testPointFixedYPlane;\n          firstLegAbovePlane = testPointFixedYAbovePlane;\n          firstLegBelowPlane = testPointFixedYBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = yTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : XIntersectionsZ) {\n        // Travel would be in YZ plane (fixed x) then in XY (fixed z)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.y - p.y;\n        final double cpDelta1 = y - p.y;\n        final double cpDelta2 = z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = x;\n          firstLegPlane = testPointFixedZPlane;\n          firstLegAbovePlane = testPointFixedZAbovePlane;\n          firstLegBelowPlane = testPointFixedZBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = zTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YIntersectionsX) {\n        // Travel would be in XZ plane (fixed y) then in YZ (fixed x)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.y - p.y;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = x - p.x;\n        final double cpDelta2 = z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = y;\n          firstLegPlane = testPointFixedXPlane;\n          firstLegAbovePlane = testPointFixedXAbovePlane;\n          firstLegBelowPlane = testPointFixedXBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = xTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YIntersectionsZ) {\n        // Travel would be in XZ plane (fixed y) then in XY (fixed z)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.y - p.y;\n        final double cpDelta1 = x - p.x;\n        final double cpDelta2 = z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = y;\n          firstLegPlane = testPointFixedZPlane;\n          firstLegAbovePlane = testPointFixedZAbovePlane;\n          firstLegBelowPlane = testPointFixedZBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = zTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : ZIntersectionsX) {\n        // Travel would be in XY plane (fixed z) then in YZ (fixed x)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.y - p.y;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = y - p.y;\n        final double cpDelta2 = x - p.x;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n        //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = z;\n          firstLegPlane = testPointFixedXPlane;\n          firstLegAbovePlane = testPointFixedXAbovePlane;\n          firstLegBelowPlane = testPointFixedXBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = xTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : ZIntersectionsY) {\n        // Travel would be in XY plane (fixed z) then in XZ (fixed y)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = y - p.y;\n        final double cpDelta2 = x - p.x;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n        //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = z;\n          firstLegPlane = testPointFixedYPlane;\n          firstLegAbovePlane = testPointFixedYAbovePlane;\n          firstLegBelowPlane = testPointFixedYBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = yTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n\n      assert bestDistance > 0.0 : \"Best distance should not be zero unless on single plane\";\n      assert bestDistance < Double.POSITIVE_INFINITY : \"Couldn't find an intersection point of any kind\";\n      \n      final DualCrossingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(firstLegPlane, firstLegAbovePlane, firstLegBelowPlane, secondLegPlane, x, y, z, intersectionPoint);\n      if (!firstLegTree.traverse(edgeIterator, firstLegValue)) {\n        return true;\n      }\n      edgeIterator.setSecondLeg();\n      if (!secondLegTree.traverse(edgeIterator, secondLegValue)) {\n        return true;\n      }\n      return ((edgeIterator.crossingCount  & 1) == 0)?testPointInSet:!testPointInSet;\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3c9c955664ed32e2bf97b3da26467354673ea18","date":1522944427,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(double,double,double).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(double,double,double).mjava","sourceNew":"  @Override\n  public boolean isWithin(final double x, final double y, final double z) {\n    //System.out.println(\"\\nIswithin called for [\"+x+\",\"+y+\",\"+z+\"]\");\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(x, y, z)) {\n      return testPointInSet;\n    }\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointFixedYPlane.evaluateIsZero(x, y, z)) {\n      // Use the XZ plane exclusively.\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      if (!yTree.traverse(crossingEdgeIterator, testPoint.y)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedXPlane.evaluateIsZero(x, y, z)) {\n      // Use the YZ plane exclusively.\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      if (!xTree.traverse(crossingEdgeIterator, testPoint.x)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedZPlane.evaluateIsZero(x, y, z)) {\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!zTree.traverse(crossingEdgeIterator, testPoint.z)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n    } else {\n\n      // This is the expensive part!!\n      // Changing the code below has an enormous impact on the queries per second we see with the benchmark.\n      \n      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.\n      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -x);\n      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -y);\n      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -z);\n\n      Plane fixedYAbovePlane = new Plane(travelPlaneFixedY, true);\n      if (fixedYAbovePlane.D - planetModel.getMaximumYValue() >= Vector.MINIMUM_RESOLUTION || planetModel.getMinimumYValue() - fixedYAbovePlane.D >= Vector.MINIMUM_RESOLUTION) {\n          fixedYAbovePlane = null;\n      }\n      \n      Plane fixedYBelowPlane = new Plane(travelPlaneFixedY, false);\n      if (fixedYBelowPlane.D - planetModel.getMaximumYValue() >= Vector.MINIMUM_RESOLUTION || planetModel.getMinimumYValue() - fixedYBelowPlane.D >= Vector.MINIMUM_RESOLUTION) {\n          fixedYBelowPlane = null;\n      }\n      \n      Plane fixedXAbovePlane = new Plane(travelPlaneFixedX, true);\n      if (fixedXAbovePlane.D - planetModel.getMaximumXValue() >= Vector.MINIMUM_RESOLUTION || planetModel.getMinimumXValue() - fixedXAbovePlane.D >= Vector.MINIMUM_RESOLUTION) {\n          fixedXAbovePlane = null;\n      }\n      \n      Plane fixedXBelowPlane = new Plane(travelPlaneFixedX, false);\n      if (fixedXBelowPlane.D - planetModel.getMaximumXValue() >= Vector.MINIMUM_RESOLUTION || planetModel.getMinimumXValue() - fixedXBelowPlane.D >= Vector.MINIMUM_RESOLUTION) {\n          fixedXBelowPlane = null;\n      }\n      \n      Plane fixedZAbovePlane = new Plane(travelPlaneFixedZ, true);\n      if (fixedZAbovePlane.D - planetModel.getMaximumZValue() >= Vector.MINIMUM_RESOLUTION || planetModel.getMinimumZValue() - fixedZAbovePlane.D >= Vector.MINIMUM_RESOLUTION) {\n          fixedZAbovePlane = null;\n      }\n      \n      Plane fixedZBelowPlane = new Plane(travelPlaneFixedZ, false);\n      if (fixedZBelowPlane.D - planetModel.getMaximumZValue() >= Vector.MINIMUM_RESOLUTION || planetModel.getMinimumZValue() - fixedZBelowPlane.D >= Vector.MINIMUM_RESOLUTION) {\n          fixedZBelowPlane = null;\n      }\n\n      // Find the intersection points for each one of these and the complementary test point planes.\n\n      // There will be multiple intersection points found.  We choose the one that has the lowest total distance, as measured in delta X, delta Y, and delta Z.\n      double bestDistance = Double.POSITIVE_INFINITY;\n      double firstLegValue = 0.0;\n      double secondLegValue = 0.0;\n      Plane firstLegPlane = null;\n      Plane firstLegAbovePlane = null;\n      Plane firstLegBelowPlane = null;\n      Plane secondLegPlane = null;\n      Plane secondLegAbovePlane = null;\n      Plane secondLegBelowPlane = null;\n      Tree firstLegTree = null;\n      Tree secondLegTree = null;\n      GeoPoint intersectionPoint = null;\n\n      if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && fixedXAbovePlane != null && fixedXBelowPlane != null) {\n        final GeoPoint[] XIntersectionsY = travelPlaneFixedX.findIntersections(planetModel, testPointFixedYPlane);\n        for (final GeoPoint p : XIntersectionsY) {\n          // Travel would be in YZ plane (fixed x) then in XZ (fixed y)\n          // We compute distance we need to travel as a placeholder for the number of intersections we might encounter.\n          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n          final double tpDelta1 = testPoint.x - p.x;\n          final double tpDelta2 = testPoint.z - p.z;\n          final double cpDelta1 = y - p.y;\n          final double cpDelta2 = z - p.z;\n          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n          //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n          //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.y - p.y);\n          if (newDistance < bestDistance) {\n            bestDistance = newDistance;\n            firstLegValue = testPoint.y;\n            secondLegValue = x;\n            firstLegPlane = testPointFixedYPlane;\n            firstLegAbovePlane = testPointFixedYAbovePlane;\n            firstLegBelowPlane = testPointFixedYBelowPlane;\n            secondLegPlane = travelPlaneFixedX;\n            secondLegAbovePlane = fixedXAbovePlane;\n            secondLegBelowPlane = fixedXBelowPlane;\n            firstLegTree = yTree;\n            secondLegTree = xTree;\n            intersectionPoint = p;\n          }\n        }\n      }\n      if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && fixedXAbovePlane != null && fixedXBelowPlane != null) {\n        final GeoPoint[] XIntersectionsZ = travelPlaneFixedX.findIntersections(planetModel, testPointFixedZPlane);\n        for (final GeoPoint p : XIntersectionsZ) {\n          // Travel would be in YZ plane (fixed x) then in XY (fixed z)\n          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n          final double tpDelta1 = testPoint.x - p.x;\n          final double tpDelta2 = testPoint.y - p.y;\n          final double cpDelta1 = y - p.y;\n          final double cpDelta2 = z - p.z;\n          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n          //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n          //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.z - p.z);\n          if (newDistance < bestDistance) {\n            bestDistance = newDistance;\n            firstLegValue = testPoint.z;\n            secondLegValue = x;\n            firstLegPlane = testPointFixedZPlane;\n            firstLegAbovePlane = testPointFixedZAbovePlane;\n            firstLegBelowPlane = testPointFixedZBelowPlane;\n            secondLegPlane = travelPlaneFixedX;\n            secondLegAbovePlane = fixedXAbovePlane;\n            secondLegBelowPlane = fixedXBelowPlane;\n            firstLegTree = zTree;\n            secondLegTree = xTree;\n            intersectionPoint = p;\n          }\n        }\n      }\n      if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && fixedYAbovePlane != null && fixedYBelowPlane != null) {\n        final GeoPoint[] YIntersectionsX = travelPlaneFixedY.findIntersections(planetModel, testPointFixedXPlane);\n        for (final GeoPoint p : YIntersectionsX) {\n          // Travel would be in XZ plane (fixed y) then in YZ (fixed x)\n          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n          final double tpDelta1 = testPoint.y - p.y;\n          final double tpDelta2 = testPoint.z - p.z;\n          final double cpDelta1 = x - p.x;\n          final double cpDelta2 = z - p.z;\n          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n          //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n          //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.x - p.x);\n          if (newDistance < bestDistance) {\n            bestDistance = newDistance;\n            firstLegValue = testPoint.x;\n            secondLegValue = y;\n            firstLegPlane = testPointFixedXPlane;\n            firstLegAbovePlane = testPointFixedXAbovePlane;\n            firstLegBelowPlane = testPointFixedXBelowPlane;\n            secondLegPlane = travelPlaneFixedY;\n            secondLegAbovePlane = fixedYAbovePlane;\n            secondLegBelowPlane = fixedYBelowPlane;\n            firstLegTree = xTree;\n            secondLegTree = yTree;\n            intersectionPoint = p;\n          }\n        }\n      }\n      if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && fixedYAbovePlane != null && fixedYBelowPlane != null) {\n        final GeoPoint[] YIntersectionsZ = travelPlaneFixedY.findIntersections(planetModel, testPointFixedZPlane);\n        for (final GeoPoint p : YIntersectionsZ) {\n          // Travel would be in XZ plane (fixed y) then in XY (fixed z)\n          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n          final double tpDelta1 = testPoint.x - p.x;\n          final double tpDelta2 = testPoint.y - p.y;\n          final double cpDelta1 = x - p.x;\n          final double cpDelta2 = z - p.z;\n          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n          //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n          //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.z - p.z);\n          if (newDistance < bestDistance) {\n            bestDistance = newDistance;\n            firstLegValue = testPoint.z;\n            secondLegValue = y;\n            firstLegPlane = testPointFixedZPlane;\n            firstLegAbovePlane = testPointFixedZAbovePlane;\n            firstLegBelowPlane = testPointFixedZBelowPlane;\n            secondLegPlane = travelPlaneFixedY;\n            secondLegAbovePlane = fixedYAbovePlane;\n            secondLegBelowPlane = fixedYBelowPlane;\n            firstLegTree = zTree;\n            secondLegTree = yTree;\n            intersectionPoint = p;\n          }\n        }\n      }\n      if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && fixedZAbovePlane != null && fixedZBelowPlane != null) {\n        final GeoPoint[] ZIntersectionsX = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedXPlane);\n        for (final GeoPoint p : ZIntersectionsX) {\n          // Travel would be in XY plane (fixed z) then in YZ (fixed x)\n          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n          final double tpDelta1 = testPoint.y - p.y;\n          final double tpDelta2 = testPoint.z - p.z;\n          final double cpDelta1 = y - p.y;\n          final double cpDelta2 = x - p.x;\n          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n          //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n          //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.x - p.x);\n          if (newDistance < bestDistance) {\n            bestDistance = newDistance;\n            firstLegValue = testPoint.x;\n            secondLegValue = z;\n            firstLegPlane = testPointFixedXPlane;\n            firstLegAbovePlane = testPointFixedXAbovePlane;\n            firstLegBelowPlane = testPointFixedXBelowPlane;\n            secondLegPlane = travelPlaneFixedZ;\n            secondLegAbovePlane = fixedZAbovePlane;\n            secondLegBelowPlane = fixedZBelowPlane;\n            firstLegTree = xTree;\n            secondLegTree = zTree;\n            intersectionPoint = p;\n          }\n        }\n      }\n      if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && fixedZAbovePlane != null && fixedZBelowPlane != null) {\n        final GeoPoint[] ZIntersectionsY = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedYPlane);\n        for (final GeoPoint p : ZIntersectionsY) {\n          // Travel would be in XY plane (fixed z) then in XZ (fixed y)\n          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n          final double tpDelta1 = testPoint.x - p.x;\n          final double tpDelta2 = testPoint.z - p.z;\n          final double cpDelta1 = y - p.y;\n          final double cpDelta2 = x - p.x;\n          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n          //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n          //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.y - p.y);\n          if (newDistance < bestDistance) {\n            bestDistance = newDistance;\n            firstLegValue = testPoint.y;\n            secondLegValue = z;\n            firstLegPlane = testPointFixedYPlane;\n            firstLegAbovePlane = testPointFixedYAbovePlane;\n            firstLegBelowPlane = testPointFixedYBelowPlane;\n            secondLegPlane = travelPlaneFixedZ;\n            secondLegAbovePlane = fixedZAbovePlane;\n            secondLegBelowPlane = fixedZBelowPlane;\n            firstLegTree = yTree;\n            secondLegTree = zTree;\n            intersectionPoint = p;\n          }\n        }\n      }\n\n      assert bestDistance > 0.0 : \"Best distance should not be zero unless on single plane\";\n      assert bestDistance < Double.POSITIVE_INFINITY : \"Couldn't find an intersection point of any kind\";\n      \n      final DualCrossingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(firstLegPlane, firstLegAbovePlane, firstLegBelowPlane, secondLegPlane, secondLegAbovePlane, secondLegBelowPlane, x, y, z, intersectionPoint);\n      if (!firstLegTree.traverse(edgeIterator, firstLegValue)) {\n        return true;\n      }\n      //edgeIterator.setSecondLeg();\n      if (!secondLegTree.traverse(edgeIterator, secondLegValue)) {\n        return true;\n      }\n      //System.out.println(\"Polarity vs. test point: \"+(((edgeIterator.getCrossingCount()  & 1) == 0)?\"same\":\"different\")+\"; testPointInSet: \"+testPointInSet);\n      return ((edgeIterator.getCrossingCount()  & 1) == 0)?testPointInSet:!testPointInSet;\n\n    }\n  }\n\n","sourceOld":"  @Override\n  public boolean isWithin(final double x, final double y, final double z) {\n    //System.out.println(\"\\nIswithin called for [\"+x+\",\"+y+\",\"+z+\"]\");\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(x, y, z)) {\n      return testPointInSet;\n    }\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointFixedYPlane.evaluateIsZero(x, y, z)) {\n      // Use the XZ plane exclusively.\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      if (!yTree.traverse(crossingEdgeIterator, testPoint.y)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedXPlane.evaluateIsZero(x, y, z)) {\n      // Use the YZ plane exclusively.\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      if (!xTree.traverse(crossingEdgeIterator, testPoint.x)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedZPlane.evaluateIsZero(x, y, z)) {\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!zTree.traverse(crossingEdgeIterator, testPoint.z)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n    } else {\n      \n      // This is the expensive part!!\n      // Changing the code below has an enormous impact on the queries per second we see with the benchmark.\n      \n      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.\n      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -x);\n      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -y);\n      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -z);\n\n      // Find the intersection points for each one of these and the complementary test point planes.\n      final GeoPoint[] XIntersectionsY = travelPlaneFixedX.findIntersections(planetModel, testPointFixedYPlane);\n      final GeoPoint[] XIntersectionsZ = travelPlaneFixedX.findIntersections(planetModel, testPointFixedZPlane);\n      final GeoPoint[] YIntersectionsX = travelPlaneFixedY.findIntersections(planetModel, testPointFixedXPlane);\n      final GeoPoint[] YIntersectionsZ = travelPlaneFixedY.findIntersections(planetModel, testPointFixedZPlane);\n      final GeoPoint[] ZIntersectionsX = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedXPlane);\n      final GeoPoint[] ZIntersectionsY = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedYPlane);\n\n      // There will be multiple intersection points found.  We choose the one that has the lowest total distance, as measured in delta X, delta Y, and delta Z.\n      double bestDistance = Double.POSITIVE_INFINITY;\n      double firstLegValue = 0.0;\n      double secondLegValue = 0.0;\n      Plane firstLegPlane = null;\n      Plane firstLegAbovePlane = null;\n      Plane firstLegBelowPlane = null;\n      Plane secondLegPlane = null;\n      Tree firstLegTree = null;\n      Tree secondLegTree = null;\n      GeoPoint intersectionPoint = null;\n      \n      for (final GeoPoint p : XIntersectionsY) {\n        // Travel would be in YZ plane (fixed x) then in XZ (fixed y)\n        // We compute distance we need to travel as a placeholder for the number of intersections we might encounter.\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = y - p.y;\n        final double cpDelta2 = z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = x;\n          firstLegPlane = testPointFixedYPlane;\n          firstLegAbovePlane = testPointFixedYAbovePlane;\n          firstLegBelowPlane = testPointFixedYBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = yTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : XIntersectionsZ) {\n        // Travel would be in YZ plane (fixed x) then in XY (fixed z)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.y - p.y;\n        final double cpDelta1 = y - p.y;\n        final double cpDelta2 = z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = x;\n          firstLegPlane = testPointFixedZPlane;\n          firstLegAbovePlane = testPointFixedZAbovePlane;\n          firstLegBelowPlane = testPointFixedZBelowPlane;\n          secondLegPlane = travelPlaneFixedX;\n          firstLegTree = zTree;\n          secondLegTree = xTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YIntersectionsX) {\n        // Travel would be in XZ plane (fixed y) then in YZ (fixed x)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.y - p.y;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = x - p.x;\n        final double cpDelta2 = z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = y;\n          firstLegPlane = testPointFixedXPlane;\n          firstLegAbovePlane = testPointFixedXAbovePlane;\n          firstLegBelowPlane = testPointFixedXBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = xTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : YIntersectionsZ) {\n        // Travel would be in XZ plane (fixed y) then in XY (fixed z)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.y - p.y;\n        final double cpDelta1 = x - p.x;\n        final double cpDelta2 = z - p.z;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n        //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.z - p.z);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.z;\n          secondLegValue = y;\n          firstLegPlane = testPointFixedZPlane;\n          firstLegAbovePlane = testPointFixedZAbovePlane;\n          firstLegBelowPlane = testPointFixedZBelowPlane;\n          secondLegPlane = travelPlaneFixedY;\n          firstLegTree = zTree;\n          secondLegTree = yTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : ZIntersectionsX) {\n        // Travel would be in XY plane (fixed z) then in YZ (fixed x)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.y - p.y;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = y - p.y;\n        final double cpDelta2 = x - p.x;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n        //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.x - p.x);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.x;\n          secondLegValue = z;\n          firstLegPlane = testPointFixedXPlane;\n          firstLegAbovePlane = testPointFixedXAbovePlane;\n          firstLegBelowPlane = testPointFixedXBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = xTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n      for (final GeoPoint p : ZIntersectionsY) {\n        // Travel would be in XY plane (fixed z) then in XZ (fixed y)\n        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n        final double tpDelta1 = testPoint.x - p.x;\n        final double tpDelta2 = testPoint.z - p.z;\n        final double cpDelta1 = y - p.y;\n        final double cpDelta2 = x - p.x;\n        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n        //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.y - p.y);\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          firstLegValue = testPoint.y;\n          secondLegValue = z;\n          firstLegPlane = testPointFixedYPlane;\n          firstLegAbovePlane = testPointFixedYAbovePlane;\n          firstLegBelowPlane = testPointFixedYBelowPlane;\n          secondLegPlane = travelPlaneFixedZ;\n          firstLegTree = yTree;\n          secondLegTree = zTree;\n          intersectionPoint = p;\n        }\n      }\n\n      assert bestDistance > 0.0 : \"Best distance should not be zero unless on single plane\";\n      assert bestDistance < Double.POSITIVE_INFINITY : \"Couldn't find an intersection point of any kind\";\n      \n      final DualCrossingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(firstLegPlane, firstLegAbovePlane, firstLegBelowPlane, secondLegPlane, x, y, z, intersectionPoint);\n      if (!firstLegTree.traverse(edgeIterator, firstLegValue)) {\n        return true;\n      }\n      //edgeIterator.setSecondLeg();\n      if (!secondLegTree.traverse(edgeIterator, secondLegValue)) {\n        return true;\n      }\n      //System.out.println(\"Polarity vs. test point: \"+(((edgeIterator.getCrossingCount()  & 1) == 0)?\"same\":\"different\")+\"; testPointInSet: \"+testPointInSet);\n      return ((edgeIterator.getCrossingCount()  & 1) == 0)?testPointInSet:!testPointInSet;\n\n    }\n  }\n\n","bugFix":null,"bugIntro":["46e2380a7b2f7e3b199fffe1179d745d5c289227"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b69c4d16cfa7d88d9a2ae23fdd1790a8d412a1b6","date":1522950981,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(double,double,double).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(double,double,double).mjava","sourceNew":"  @Override\n  public boolean isWithin(final double x, final double y, final double z) {\n    //System.out.println(\"\\nIswithin called for [\"+x+\",\"+y+\",\"+z+\"]\");\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(x, y, z)) {\n      return testPointInSet;\n    }\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && testPointFixedYPlane.evaluateIsZero(x, y, z)) {\n      // Use the XZ plane exclusively.\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      if (!yTree.traverse(crossingEdgeIterator, testPoint.y)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && testPointFixedXPlane.evaluateIsZero(x, y, z)) {\n      // Use the YZ plane exclusively.\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      if (!xTree.traverse(crossingEdgeIterator, testPoint.x)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && testPointFixedZPlane.evaluateIsZero(x, y, z)) {\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!zTree.traverse(crossingEdgeIterator, testPoint.z)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedYPlane.evaluateIsZero(x, y, z) || testPointFixedXPlane.evaluateIsZero(x, y, z) || testPointFixedZPlane.evaluateIsZero(x, y, z)) {\n      throw new IllegalArgumentException(\"Can't compute isWithin for specified point\");\n    } else {\n\n      // This is the expensive part!!\n      // Changing the code below has an enormous impact on the queries per second we see with the benchmark.\n      \n      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.\n      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -x);\n      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -y);\n      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -z);\n\n      Plane fixedYAbovePlane = new Plane(travelPlaneFixedY, true);\n      if (fixedYAbovePlane.D - planetModel.getMaximumYValue() >= Vector.MINIMUM_RESOLUTION || planetModel.getMinimumYValue() - fixedYAbovePlane.D >= Vector.MINIMUM_RESOLUTION) {\n          fixedYAbovePlane = null;\n      }\n      \n      Plane fixedYBelowPlane = new Plane(travelPlaneFixedY, false);\n      if (fixedYBelowPlane.D - planetModel.getMaximumYValue() >= Vector.MINIMUM_RESOLUTION || planetModel.getMinimumYValue() - fixedYBelowPlane.D >= Vector.MINIMUM_RESOLUTION) {\n          fixedYBelowPlane = null;\n      }\n      \n      Plane fixedXAbovePlane = new Plane(travelPlaneFixedX, true);\n      if (fixedXAbovePlane.D - planetModel.getMaximumXValue() >= Vector.MINIMUM_RESOLUTION || planetModel.getMinimumXValue() - fixedXAbovePlane.D >= Vector.MINIMUM_RESOLUTION) {\n          fixedXAbovePlane = null;\n      }\n      \n      Plane fixedXBelowPlane = new Plane(travelPlaneFixedX, false);\n      if (fixedXBelowPlane.D - planetModel.getMaximumXValue() >= Vector.MINIMUM_RESOLUTION || planetModel.getMinimumXValue() - fixedXBelowPlane.D >= Vector.MINIMUM_RESOLUTION) {\n          fixedXBelowPlane = null;\n      }\n      \n      Plane fixedZAbovePlane = new Plane(travelPlaneFixedZ, true);\n      if (fixedZAbovePlane.D - planetModel.getMaximumZValue() >= Vector.MINIMUM_RESOLUTION || planetModel.getMinimumZValue() - fixedZAbovePlane.D >= Vector.MINIMUM_RESOLUTION) {\n          fixedZAbovePlane = null;\n      }\n      \n      Plane fixedZBelowPlane = new Plane(travelPlaneFixedZ, false);\n      if (fixedZBelowPlane.D - planetModel.getMaximumZValue() >= Vector.MINIMUM_RESOLUTION || planetModel.getMinimumZValue() - fixedZBelowPlane.D >= Vector.MINIMUM_RESOLUTION) {\n          fixedZBelowPlane = null;\n      }\n\n      // Find the intersection points for each one of these and the complementary test point planes.\n\n      // There will be multiple intersection points found.  We choose the one that has the lowest total distance, as measured in delta X, delta Y, and delta Z.\n      double bestDistance = Double.POSITIVE_INFINITY;\n      double firstLegValue = 0.0;\n      double secondLegValue = 0.0;\n      Plane firstLegPlane = null;\n      Plane firstLegAbovePlane = null;\n      Plane firstLegBelowPlane = null;\n      Plane secondLegPlane = null;\n      Plane secondLegAbovePlane = null;\n      Plane secondLegBelowPlane = null;\n      Tree firstLegTree = null;\n      Tree secondLegTree = null;\n      GeoPoint intersectionPoint = null;\n\n      if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && fixedXAbovePlane != null && fixedXBelowPlane != null) {\n        final GeoPoint[] XIntersectionsY = travelPlaneFixedX.findIntersections(planetModel, testPointFixedYPlane);\n        for (final GeoPoint p : XIntersectionsY) {\n          // Travel would be in YZ plane (fixed x) then in XZ (fixed y)\n          // We compute distance we need to travel as a placeholder for the number of intersections we might encounter.\n          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n          final double tpDelta1 = testPoint.x - p.x;\n          final double tpDelta2 = testPoint.z - p.z;\n          final double cpDelta1 = y - p.y;\n          final double cpDelta2 = z - p.z;\n          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n          //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n          //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.y - p.y);\n          if (newDistance < bestDistance) {\n            bestDistance = newDistance;\n            firstLegValue = testPoint.y;\n            secondLegValue = x;\n            firstLegPlane = testPointFixedYPlane;\n            firstLegAbovePlane = testPointFixedYAbovePlane;\n            firstLegBelowPlane = testPointFixedYBelowPlane;\n            secondLegPlane = travelPlaneFixedX;\n            secondLegAbovePlane = fixedXAbovePlane;\n            secondLegBelowPlane = fixedXBelowPlane;\n            firstLegTree = yTree;\n            secondLegTree = xTree;\n            intersectionPoint = p;\n          }\n        }\n      }\n      if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && fixedXAbovePlane != null && fixedXBelowPlane != null) {\n        final GeoPoint[] XIntersectionsZ = travelPlaneFixedX.findIntersections(planetModel, testPointFixedZPlane);\n        for (final GeoPoint p : XIntersectionsZ) {\n          // Travel would be in YZ plane (fixed x) then in XY (fixed z)\n          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n          final double tpDelta1 = testPoint.x - p.x;\n          final double tpDelta2 = testPoint.y - p.y;\n          final double cpDelta1 = y - p.y;\n          final double cpDelta2 = z - p.z;\n          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n          //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n          //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.z - p.z);\n          if (newDistance < bestDistance) {\n            bestDistance = newDistance;\n            firstLegValue = testPoint.z;\n            secondLegValue = x;\n            firstLegPlane = testPointFixedZPlane;\n            firstLegAbovePlane = testPointFixedZAbovePlane;\n            firstLegBelowPlane = testPointFixedZBelowPlane;\n            secondLegPlane = travelPlaneFixedX;\n            secondLegAbovePlane = fixedXAbovePlane;\n            secondLegBelowPlane = fixedXBelowPlane;\n            firstLegTree = zTree;\n            secondLegTree = xTree;\n            intersectionPoint = p;\n          }\n        }\n      }\n      if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && fixedYAbovePlane != null && fixedYBelowPlane != null) {\n        final GeoPoint[] YIntersectionsX = travelPlaneFixedY.findIntersections(planetModel, testPointFixedXPlane);\n        for (final GeoPoint p : YIntersectionsX) {\n          // Travel would be in XZ plane (fixed y) then in YZ (fixed x)\n          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n          final double tpDelta1 = testPoint.y - p.y;\n          final double tpDelta2 = testPoint.z - p.z;\n          final double cpDelta1 = x - p.x;\n          final double cpDelta2 = z - p.z;\n          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n          //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n          //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.x - p.x);\n          if (newDistance < bestDistance) {\n            bestDistance = newDistance;\n            firstLegValue = testPoint.x;\n            secondLegValue = y;\n            firstLegPlane = testPointFixedXPlane;\n            firstLegAbovePlane = testPointFixedXAbovePlane;\n            firstLegBelowPlane = testPointFixedXBelowPlane;\n            secondLegPlane = travelPlaneFixedY;\n            secondLegAbovePlane = fixedYAbovePlane;\n            secondLegBelowPlane = fixedYBelowPlane;\n            firstLegTree = xTree;\n            secondLegTree = yTree;\n            intersectionPoint = p;\n          }\n        }\n      }\n      if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && fixedYAbovePlane != null && fixedYBelowPlane != null) {\n        final GeoPoint[] YIntersectionsZ = travelPlaneFixedY.findIntersections(planetModel, testPointFixedZPlane);\n        for (final GeoPoint p : YIntersectionsZ) {\n          // Travel would be in XZ plane (fixed y) then in XY (fixed z)\n          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n          final double tpDelta1 = testPoint.x - p.x;\n          final double tpDelta2 = testPoint.y - p.y;\n          final double cpDelta1 = x - p.x;\n          final double cpDelta2 = z - p.z;\n          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n          //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n          //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.z - p.z);\n          if (newDistance < bestDistance) {\n            bestDistance = newDistance;\n            firstLegValue = testPoint.z;\n            secondLegValue = y;\n            firstLegPlane = testPointFixedZPlane;\n            firstLegAbovePlane = testPointFixedZAbovePlane;\n            firstLegBelowPlane = testPointFixedZBelowPlane;\n            secondLegPlane = travelPlaneFixedY;\n            secondLegAbovePlane = fixedYAbovePlane;\n            secondLegBelowPlane = fixedYBelowPlane;\n            firstLegTree = zTree;\n            secondLegTree = yTree;\n            intersectionPoint = p;\n          }\n        }\n      }\n      if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && fixedZAbovePlane != null && fixedZBelowPlane != null) {\n        final GeoPoint[] ZIntersectionsX = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedXPlane);\n        for (final GeoPoint p : ZIntersectionsX) {\n          // Travel would be in XY plane (fixed z) then in YZ (fixed x)\n          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n          final double tpDelta1 = testPoint.y - p.y;\n          final double tpDelta2 = testPoint.z - p.z;\n          final double cpDelta1 = y - p.y;\n          final double cpDelta2 = x - p.x;\n          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n          //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n          //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.x - p.x);\n          if (newDistance < bestDistance) {\n            bestDistance = newDistance;\n            firstLegValue = testPoint.x;\n            secondLegValue = z;\n            firstLegPlane = testPointFixedXPlane;\n            firstLegAbovePlane = testPointFixedXAbovePlane;\n            firstLegBelowPlane = testPointFixedXBelowPlane;\n            secondLegPlane = travelPlaneFixedZ;\n            secondLegAbovePlane = fixedZAbovePlane;\n            secondLegBelowPlane = fixedZBelowPlane;\n            firstLegTree = xTree;\n            secondLegTree = zTree;\n            intersectionPoint = p;\n          }\n        }\n      }\n      if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && fixedZAbovePlane != null && fixedZBelowPlane != null) {\n        final GeoPoint[] ZIntersectionsY = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedYPlane);\n        for (final GeoPoint p : ZIntersectionsY) {\n          // Travel would be in XY plane (fixed z) then in XZ (fixed y)\n          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n          final double tpDelta1 = testPoint.x - p.x;\n          final double tpDelta2 = testPoint.z - p.z;\n          final double cpDelta1 = y - p.y;\n          final double cpDelta2 = x - p.x;\n          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n          //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n          //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.y - p.y);\n          if (newDistance < bestDistance) {\n            bestDistance = newDistance;\n            firstLegValue = testPoint.y;\n            secondLegValue = z;\n            firstLegPlane = testPointFixedYPlane;\n            firstLegAbovePlane = testPointFixedYAbovePlane;\n            firstLegBelowPlane = testPointFixedYBelowPlane;\n            secondLegPlane = travelPlaneFixedZ;\n            secondLegAbovePlane = fixedZAbovePlane;\n            secondLegBelowPlane = fixedZBelowPlane;\n            firstLegTree = yTree;\n            secondLegTree = zTree;\n            intersectionPoint = p;\n          }\n        }\n      }\n\n      assert bestDistance > 0.0 : \"Best distance should not be zero unless on single plane\";\n      assert bestDistance < Double.POSITIVE_INFINITY : \"Couldn't find an intersection point of any kind\";\n      \n      final DualCrossingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(firstLegPlane, firstLegAbovePlane, firstLegBelowPlane, secondLegPlane, secondLegAbovePlane, secondLegBelowPlane, x, y, z, intersectionPoint);\n      if (!firstLegTree.traverse(edgeIterator, firstLegValue)) {\n        return true;\n      }\n      //edgeIterator.setSecondLeg();\n      if (!secondLegTree.traverse(edgeIterator, secondLegValue)) {\n        return true;\n      }\n      //System.out.println(\"Polarity vs. test point: \"+(((edgeIterator.getCrossingCount()  & 1) == 0)?\"same\":\"different\")+\"; testPointInSet: \"+testPointInSet);\n      return ((edgeIterator.getCrossingCount()  & 1) == 0)?testPointInSet:!testPointInSet;\n\n    }\n  }\n\n","sourceOld":"  @Override\n  public boolean isWithin(final double x, final double y, final double z) {\n    //System.out.println(\"\\nIswithin called for [\"+x+\",\"+y+\",\"+z+\"]\");\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(x, y, z)) {\n      return testPointInSet;\n    }\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointFixedYPlane.evaluateIsZero(x, y, z)) {\n      // Use the XZ plane exclusively.\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      if (!yTree.traverse(crossingEdgeIterator, testPoint.y)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedXPlane.evaluateIsZero(x, y, z)) {\n      // Use the YZ plane exclusively.\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      if (!xTree.traverse(crossingEdgeIterator, testPoint.x)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedZPlane.evaluateIsZero(x, y, z)) {\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!zTree.traverse(crossingEdgeIterator, testPoint.z)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n    } else {\n\n      // This is the expensive part!!\n      // Changing the code below has an enormous impact on the queries per second we see with the benchmark.\n      \n      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.\n      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -x);\n      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -y);\n      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -z);\n\n      Plane fixedYAbovePlane = new Plane(travelPlaneFixedY, true);\n      if (fixedYAbovePlane.D - planetModel.getMaximumYValue() >= Vector.MINIMUM_RESOLUTION || planetModel.getMinimumYValue() - fixedYAbovePlane.D >= Vector.MINIMUM_RESOLUTION) {\n          fixedYAbovePlane = null;\n      }\n      \n      Plane fixedYBelowPlane = new Plane(travelPlaneFixedY, false);\n      if (fixedYBelowPlane.D - planetModel.getMaximumYValue() >= Vector.MINIMUM_RESOLUTION || planetModel.getMinimumYValue() - fixedYBelowPlane.D >= Vector.MINIMUM_RESOLUTION) {\n          fixedYBelowPlane = null;\n      }\n      \n      Plane fixedXAbovePlane = new Plane(travelPlaneFixedX, true);\n      if (fixedXAbovePlane.D - planetModel.getMaximumXValue() >= Vector.MINIMUM_RESOLUTION || planetModel.getMinimumXValue() - fixedXAbovePlane.D >= Vector.MINIMUM_RESOLUTION) {\n          fixedXAbovePlane = null;\n      }\n      \n      Plane fixedXBelowPlane = new Plane(travelPlaneFixedX, false);\n      if (fixedXBelowPlane.D - planetModel.getMaximumXValue() >= Vector.MINIMUM_RESOLUTION || planetModel.getMinimumXValue() - fixedXBelowPlane.D >= Vector.MINIMUM_RESOLUTION) {\n          fixedXBelowPlane = null;\n      }\n      \n      Plane fixedZAbovePlane = new Plane(travelPlaneFixedZ, true);\n      if (fixedZAbovePlane.D - planetModel.getMaximumZValue() >= Vector.MINIMUM_RESOLUTION || planetModel.getMinimumZValue() - fixedZAbovePlane.D >= Vector.MINIMUM_RESOLUTION) {\n          fixedZAbovePlane = null;\n      }\n      \n      Plane fixedZBelowPlane = new Plane(travelPlaneFixedZ, false);\n      if (fixedZBelowPlane.D - planetModel.getMaximumZValue() >= Vector.MINIMUM_RESOLUTION || planetModel.getMinimumZValue() - fixedZBelowPlane.D >= Vector.MINIMUM_RESOLUTION) {\n          fixedZBelowPlane = null;\n      }\n\n      // Find the intersection points for each one of these and the complementary test point planes.\n\n      // There will be multiple intersection points found.  We choose the one that has the lowest total distance, as measured in delta X, delta Y, and delta Z.\n      double bestDistance = Double.POSITIVE_INFINITY;\n      double firstLegValue = 0.0;\n      double secondLegValue = 0.0;\n      Plane firstLegPlane = null;\n      Plane firstLegAbovePlane = null;\n      Plane firstLegBelowPlane = null;\n      Plane secondLegPlane = null;\n      Plane secondLegAbovePlane = null;\n      Plane secondLegBelowPlane = null;\n      Tree firstLegTree = null;\n      Tree secondLegTree = null;\n      GeoPoint intersectionPoint = null;\n\n      if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && fixedXAbovePlane != null && fixedXBelowPlane != null) {\n        final GeoPoint[] XIntersectionsY = travelPlaneFixedX.findIntersections(planetModel, testPointFixedYPlane);\n        for (final GeoPoint p : XIntersectionsY) {\n          // Travel would be in YZ plane (fixed x) then in XZ (fixed y)\n          // We compute distance we need to travel as a placeholder for the number of intersections we might encounter.\n          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n          final double tpDelta1 = testPoint.x - p.x;\n          final double tpDelta2 = testPoint.z - p.z;\n          final double cpDelta1 = y - p.y;\n          final double cpDelta2 = z - p.z;\n          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n          //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n          //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.y - p.y);\n          if (newDistance < bestDistance) {\n            bestDistance = newDistance;\n            firstLegValue = testPoint.y;\n            secondLegValue = x;\n            firstLegPlane = testPointFixedYPlane;\n            firstLegAbovePlane = testPointFixedYAbovePlane;\n            firstLegBelowPlane = testPointFixedYBelowPlane;\n            secondLegPlane = travelPlaneFixedX;\n            secondLegAbovePlane = fixedXAbovePlane;\n            secondLegBelowPlane = fixedXBelowPlane;\n            firstLegTree = yTree;\n            secondLegTree = xTree;\n            intersectionPoint = p;\n          }\n        }\n      }\n      if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && fixedXAbovePlane != null && fixedXBelowPlane != null) {\n        final GeoPoint[] XIntersectionsZ = travelPlaneFixedX.findIntersections(planetModel, testPointFixedZPlane);\n        for (final GeoPoint p : XIntersectionsZ) {\n          // Travel would be in YZ plane (fixed x) then in XY (fixed z)\n          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n          final double tpDelta1 = testPoint.x - p.x;\n          final double tpDelta2 = testPoint.y - p.y;\n          final double cpDelta1 = y - p.y;\n          final double cpDelta2 = z - p.z;\n          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n          //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n          //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.z - p.z);\n          if (newDistance < bestDistance) {\n            bestDistance = newDistance;\n            firstLegValue = testPoint.z;\n            secondLegValue = x;\n            firstLegPlane = testPointFixedZPlane;\n            firstLegAbovePlane = testPointFixedZAbovePlane;\n            firstLegBelowPlane = testPointFixedZBelowPlane;\n            secondLegPlane = travelPlaneFixedX;\n            secondLegAbovePlane = fixedXAbovePlane;\n            secondLegBelowPlane = fixedXBelowPlane;\n            firstLegTree = zTree;\n            secondLegTree = xTree;\n            intersectionPoint = p;\n          }\n        }\n      }\n      if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && fixedYAbovePlane != null && fixedYBelowPlane != null) {\n        final GeoPoint[] YIntersectionsX = travelPlaneFixedY.findIntersections(planetModel, testPointFixedXPlane);\n        for (final GeoPoint p : YIntersectionsX) {\n          // Travel would be in XZ plane (fixed y) then in YZ (fixed x)\n          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n          final double tpDelta1 = testPoint.y - p.y;\n          final double tpDelta2 = testPoint.z - p.z;\n          final double cpDelta1 = x - p.x;\n          final double cpDelta2 = z - p.z;\n          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n          //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n          //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.x - p.x);\n          if (newDistance < bestDistance) {\n            bestDistance = newDistance;\n            firstLegValue = testPoint.x;\n            secondLegValue = y;\n            firstLegPlane = testPointFixedXPlane;\n            firstLegAbovePlane = testPointFixedXAbovePlane;\n            firstLegBelowPlane = testPointFixedXBelowPlane;\n            secondLegPlane = travelPlaneFixedY;\n            secondLegAbovePlane = fixedYAbovePlane;\n            secondLegBelowPlane = fixedYBelowPlane;\n            firstLegTree = xTree;\n            secondLegTree = yTree;\n            intersectionPoint = p;\n          }\n        }\n      }\n      if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && fixedYAbovePlane != null && fixedYBelowPlane != null) {\n        final GeoPoint[] YIntersectionsZ = travelPlaneFixedY.findIntersections(planetModel, testPointFixedZPlane);\n        for (final GeoPoint p : YIntersectionsZ) {\n          // Travel would be in XZ plane (fixed y) then in XY (fixed z)\n          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n          final double tpDelta1 = testPoint.x - p.x;\n          final double tpDelta2 = testPoint.y - p.y;\n          final double cpDelta1 = x - p.x;\n          final double cpDelta2 = z - p.z;\n          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n          //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n          //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.z - p.z);\n          if (newDistance < bestDistance) {\n            bestDistance = newDistance;\n            firstLegValue = testPoint.z;\n            secondLegValue = y;\n            firstLegPlane = testPointFixedZPlane;\n            firstLegAbovePlane = testPointFixedZAbovePlane;\n            firstLegBelowPlane = testPointFixedZBelowPlane;\n            secondLegPlane = travelPlaneFixedY;\n            secondLegAbovePlane = fixedYAbovePlane;\n            secondLegBelowPlane = fixedYBelowPlane;\n            firstLegTree = zTree;\n            secondLegTree = yTree;\n            intersectionPoint = p;\n          }\n        }\n      }\n      if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && fixedZAbovePlane != null && fixedZBelowPlane != null) {\n        final GeoPoint[] ZIntersectionsX = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedXPlane);\n        for (final GeoPoint p : ZIntersectionsX) {\n          // Travel would be in XY plane (fixed z) then in YZ (fixed x)\n          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n          final double tpDelta1 = testPoint.y - p.y;\n          final double tpDelta2 = testPoint.z - p.z;\n          final double cpDelta1 = y - p.y;\n          final double cpDelta2 = x - p.x;\n          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n          //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n          //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.x - p.x);\n          if (newDistance < bestDistance) {\n            bestDistance = newDistance;\n            firstLegValue = testPoint.x;\n            secondLegValue = z;\n            firstLegPlane = testPointFixedXPlane;\n            firstLegAbovePlane = testPointFixedXAbovePlane;\n            firstLegBelowPlane = testPointFixedXBelowPlane;\n            secondLegPlane = travelPlaneFixedZ;\n            secondLegAbovePlane = fixedZAbovePlane;\n            secondLegBelowPlane = fixedZBelowPlane;\n            firstLegTree = xTree;\n            secondLegTree = zTree;\n            intersectionPoint = p;\n          }\n        }\n      }\n      if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && fixedZAbovePlane != null && fixedZBelowPlane != null) {\n        final GeoPoint[] ZIntersectionsY = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedYPlane);\n        for (final GeoPoint p : ZIntersectionsY) {\n          // Travel would be in XY plane (fixed z) then in XZ (fixed y)\n          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n          final double tpDelta1 = testPoint.x - p.x;\n          final double tpDelta2 = testPoint.z - p.z;\n          final double cpDelta1 = y - p.y;\n          final double cpDelta2 = x - p.x;\n          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n          //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n          //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.y - p.y);\n          if (newDistance < bestDistance) {\n            bestDistance = newDistance;\n            firstLegValue = testPoint.y;\n            secondLegValue = z;\n            firstLegPlane = testPointFixedYPlane;\n            firstLegAbovePlane = testPointFixedYAbovePlane;\n            firstLegBelowPlane = testPointFixedYBelowPlane;\n            secondLegPlane = travelPlaneFixedZ;\n            secondLegAbovePlane = fixedZAbovePlane;\n            secondLegBelowPlane = fixedZBelowPlane;\n            firstLegTree = yTree;\n            secondLegTree = zTree;\n            intersectionPoint = p;\n          }\n        }\n      }\n\n      assert bestDistance > 0.0 : \"Best distance should not be zero unless on single plane\";\n      assert bestDistance < Double.POSITIVE_INFINITY : \"Couldn't find an intersection point of any kind\";\n      \n      final DualCrossingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(firstLegPlane, firstLegAbovePlane, firstLegBelowPlane, secondLegPlane, secondLegAbovePlane, secondLegBelowPlane, x, y, z, intersectionPoint);\n      if (!firstLegTree.traverse(edgeIterator, firstLegValue)) {\n        return true;\n      }\n      //edgeIterator.setSecondLeg();\n      if (!secondLegTree.traverse(edgeIterator, secondLegValue)) {\n        return true;\n      }\n      //System.out.println(\"Polarity vs. test point: \"+(((edgeIterator.getCrossingCount()  & 1) == 0)?\"same\":\"different\")+\"; testPointInSet: \"+testPointInSet);\n      return ((edgeIterator.getCrossingCount()  & 1) == 0)?testPointInSet:!testPointInSet;\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e872ee16caf3bf386b6a55f3654fabb2840d8fc9","date":1523529572,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(double,double,double).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(double,double,double).mjava","sourceNew":"  @Override\n  public boolean isWithin(final double x, final double y, final double z) {\n    //System.out.println(\"\\nIswithin called for [\"+x+\",\"+y+\",\"+z+\"]\");\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(x, y, z)) {\n      return testPointInSet;\n    }\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && testPointFixedYPlane.evaluateIsZero(x, y, z)) {\n      // Use the XZ plane exclusively.\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      if (!yTree.traverse(crossingEdgeIterator, testPoint.y)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && testPointFixedXPlane.evaluateIsZero(x, y, z)) {\n      // Use the YZ plane exclusively.\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      if (!xTree.traverse(crossingEdgeIterator, testPoint.x)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && testPointFixedZPlane.evaluateIsZero(x, y, z)) {\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!zTree.traverse(crossingEdgeIterator, testPoint.z)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedYPlane.evaluateIsZero(x, y, z) || testPointFixedXPlane.evaluateIsZero(x, y, z) || testPointFixedZPlane.evaluateIsZero(x, y, z)) {\n      throw new IllegalArgumentException(\"Can't compute isWithin for specified point\");\n    } else {\n\n      // This is the expensive part!!\n      // Changing the code below has an enormous impact on the queries per second we see with the benchmark.\n      \n      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.\n      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -x);\n      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -y);\n      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -z);\n\n      Plane fixedYAbovePlane = new Plane(travelPlaneFixedY, true);\n      if (fixedYAbovePlane.D - planetModel.getMaximumYValue() > 0.0 || planetModel.getMinimumYValue() - fixedYAbovePlane.D > 0.0) {\n          fixedYAbovePlane = null;\n      }\n      \n      Plane fixedYBelowPlane = new Plane(travelPlaneFixedY, false);\n      if (fixedYBelowPlane.D - planetModel.getMaximumYValue() > 0.0 || planetModel.getMinimumYValue() - fixedYBelowPlane.D > 0.0) {\n          fixedYBelowPlane = null;\n      }\n      \n      Plane fixedXAbovePlane = new Plane(travelPlaneFixedX, true);\n      if (fixedXAbovePlane.D - planetModel.getMaximumXValue() > 0.0 || planetModel.getMinimumXValue() - fixedXAbovePlane.D > 0.0) {\n          fixedXAbovePlane = null;\n      }\n      \n      Plane fixedXBelowPlane = new Plane(travelPlaneFixedX, false);\n      if (fixedXBelowPlane.D - planetModel.getMaximumXValue() > 0.0 || planetModel.getMinimumXValue() - fixedXBelowPlane.D > 0.0) {\n          fixedXBelowPlane = null;\n      }\n      \n      Plane fixedZAbovePlane = new Plane(travelPlaneFixedZ, true);\n      if (fixedZAbovePlane.D - planetModel.getMaximumZValue() > 0.0 || planetModel.getMinimumZValue() - fixedZAbovePlane.D > 0.0) {\n          fixedZAbovePlane = null;\n      }\n      \n      Plane fixedZBelowPlane = new Plane(travelPlaneFixedZ, false);\n      if (fixedZBelowPlane.D - planetModel.getMaximumZValue() > 0.0 || planetModel.getMinimumZValue() - fixedZBelowPlane.D > 0.0) {\n          fixedZBelowPlane = null;\n      }\n\n      // Find the intersection points for each one of these and the complementary test point planes.\n\n      // There will be multiple intersection points found.  We choose the one that has the lowest total distance, as measured in delta X, delta Y, and delta Z.\n      double bestDistance = Double.POSITIVE_INFINITY;\n      double firstLegValue = 0.0;\n      double secondLegValue = 0.0;\n      Plane firstLegPlane = null;\n      Plane firstLegAbovePlane = null;\n      Plane firstLegBelowPlane = null;\n      Plane secondLegPlane = null;\n      Plane secondLegAbovePlane = null;\n      Plane secondLegBelowPlane = null;\n      Tree firstLegTree = null;\n      Tree secondLegTree = null;\n      GeoPoint intersectionPoint = null;\n\n      if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && fixedXAbovePlane != null && fixedXBelowPlane != null) {\n        final GeoPoint[] XIntersectionsY = travelPlaneFixedX.findIntersections(planetModel, testPointFixedYPlane);\n        for (final GeoPoint p : XIntersectionsY) {\n          // Travel would be in YZ plane (fixed x) then in XZ (fixed y)\n          // We compute distance we need to travel as a placeholder for the number of intersections we might encounter.\n          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n          final double tpDelta1 = testPoint.x - p.x;\n          final double tpDelta2 = testPoint.z - p.z;\n          final double cpDelta1 = y - p.y;\n          final double cpDelta2 = z - p.z;\n          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n          //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n          //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.y - p.y);\n          if (newDistance < bestDistance) {\n            bestDistance = newDistance;\n            firstLegValue = testPoint.y;\n            secondLegValue = x;\n            firstLegPlane = testPointFixedYPlane;\n            firstLegAbovePlane = testPointFixedYAbovePlane;\n            firstLegBelowPlane = testPointFixedYBelowPlane;\n            secondLegPlane = travelPlaneFixedX;\n            secondLegAbovePlane = fixedXAbovePlane;\n            secondLegBelowPlane = fixedXBelowPlane;\n            firstLegTree = yTree;\n            secondLegTree = xTree;\n            intersectionPoint = p;\n          }\n        }\n      }\n      if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && fixedXAbovePlane != null && fixedXBelowPlane != null) {\n        final GeoPoint[] XIntersectionsZ = travelPlaneFixedX.findIntersections(planetModel, testPointFixedZPlane);\n        for (final GeoPoint p : XIntersectionsZ) {\n          // Travel would be in YZ plane (fixed x) then in XY (fixed z)\n          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n          final double tpDelta1 = testPoint.x - p.x;\n          final double tpDelta2 = testPoint.y - p.y;\n          final double cpDelta1 = y - p.y;\n          final double cpDelta2 = z - p.z;\n          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n          //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n          //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.z - p.z);\n          if (newDistance < bestDistance) {\n            bestDistance = newDistance;\n            firstLegValue = testPoint.z;\n            secondLegValue = x;\n            firstLegPlane = testPointFixedZPlane;\n            firstLegAbovePlane = testPointFixedZAbovePlane;\n            firstLegBelowPlane = testPointFixedZBelowPlane;\n            secondLegPlane = travelPlaneFixedX;\n            secondLegAbovePlane = fixedXAbovePlane;\n            secondLegBelowPlane = fixedXBelowPlane;\n            firstLegTree = zTree;\n            secondLegTree = xTree;\n            intersectionPoint = p;\n          }\n        }\n      }\n      if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && fixedYAbovePlane != null && fixedYBelowPlane != null) {\n        final GeoPoint[] YIntersectionsX = travelPlaneFixedY.findIntersections(planetModel, testPointFixedXPlane);\n        for (final GeoPoint p : YIntersectionsX) {\n          // Travel would be in XZ plane (fixed y) then in YZ (fixed x)\n          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n          final double tpDelta1 = testPoint.y - p.y;\n          final double tpDelta2 = testPoint.z - p.z;\n          final double cpDelta1 = x - p.x;\n          final double cpDelta2 = z - p.z;\n          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n          //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n          //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.x - p.x);\n          if (newDistance < bestDistance) {\n            bestDistance = newDistance;\n            firstLegValue = testPoint.x;\n            secondLegValue = y;\n            firstLegPlane = testPointFixedXPlane;\n            firstLegAbovePlane = testPointFixedXAbovePlane;\n            firstLegBelowPlane = testPointFixedXBelowPlane;\n            secondLegPlane = travelPlaneFixedY;\n            secondLegAbovePlane = fixedYAbovePlane;\n            secondLegBelowPlane = fixedYBelowPlane;\n            firstLegTree = xTree;\n            secondLegTree = yTree;\n            intersectionPoint = p;\n          }\n        }\n      }\n      if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && fixedYAbovePlane != null && fixedYBelowPlane != null) {\n        final GeoPoint[] YIntersectionsZ = travelPlaneFixedY.findIntersections(planetModel, testPointFixedZPlane);\n        for (final GeoPoint p : YIntersectionsZ) {\n          // Travel would be in XZ plane (fixed y) then in XY (fixed z)\n          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n          final double tpDelta1 = testPoint.x - p.x;\n          final double tpDelta2 = testPoint.y - p.y;\n          final double cpDelta1 = x - p.x;\n          final double cpDelta2 = z - p.z;\n          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n          //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n          //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.z - p.z);\n          if (newDistance < bestDistance) {\n            bestDistance = newDistance;\n            firstLegValue = testPoint.z;\n            secondLegValue = y;\n            firstLegPlane = testPointFixedZPlane;\n            firstLegAbovePlane = testPointFixedZAbovePlane;\n            firstLegBelowPlane = testPointFixedZBelowPlane;\n            secondLegPlane = travelPlaneFixedY;\n            secondLegAbovePlane = fixedYAbovePlane;\n            secondLegBelowPlane = fixedYBelowPlane;\n            firstLegTree = zTree;\n            secondLegTree = yTree;\n            intersectionPoint = p;\n          }\n        }\n      }\n      if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && fixedZAbovePlane != null && fixedZBelowPlane != null) {\n        final GeoPoint[] ZIntersectionsX = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedXPlane);\n        for (final GeoPoint p : ZIntersectionsX) {\n          // Travel would be in XY plane (fixed z) then in YZ (fixed x)\n          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n          final double tpDelta1 = testPoint.y - p.y;\n          final double tpDelta2 = testPoint.z - p.z;\n          final double cpDelta1 = y - p.y;\n          final double cpDelta2 = x - p.x;\n          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n          //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n          //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.x - p.x);\n          if (newDistance < bestDistance) {\n            bestDistance = newDistance;\n            firstLegValue = testPoint.x;\n            secondLegValue = z;\n            firstLegPlane = testPointFixedXPlane;\n            firstLegAbovePlane = testPointFixedXAbovePlane;\n            firstLegBelowPlane = testPointFixedXBelowPlane;\n            secondLegPlane = travelPlaneFixedZ;\n            secondLegAbovePlane = fixedZAbovePlane;\n            secondLegBelowPlane = fixedZBelowPlane;\n            firstLegTree = xTree;\n            secondLegTree = zTree;\n            intersectionPoint = p;\n          }\n        }\n      }\n      if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && fixedZAbovePlane != null && fixedZBelowPlane != null) {\n        final GeoPoint[] ZIntersectionsY = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedYPlane);\n        for (final GeoPoint p : ZIntersectionsY) {\n          // Travel would be in XY plane (fixed z) then in XZ (fixed y)\n          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n          final double tpDelta1 = testPoint.x - p.x;\n          final double tpDelta2 = testPoint.z - p.z;\n          final double cpDelta1 = y - p.y;\n          final double cpDelta2 = x - p.x;\n          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n          //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n          //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.y - p.y);\n          if (newDistance < bestDistance) {\n            bestDistance = newDistance;\n            firstLegValue = testPoint.y;\n            secondLegValue = z;\n            firstLegPlane = testPointFixedYPlane;\n            firstLegAbovePlane = testPointFixedYAbovePlane;\n            firstLegBelowPlane = testPointFixedYBelowPlane;\n            secondLegPlane = travelPlaneFixedZ;\n            secondLegAbovePlane = fixedZAbovePlane;\n            secondLegBelowPlane = fixedZBelowPlane;\n            firstLegTree = yTree;\n            secondLegTree = zTree;\n            intersectionPoint = p;\n          }\n        }\n      }\n\n      assert bestDistance > 0.0 : \"Best distance should not be zero unless on single plane\";\n      assert bestDistance < Double.POSITIVE_INFINITY : \"Couldn't find an intersection point of any kind\";\n      \n      final DualCrossingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(firstLegPlane, firstLegAbovePlane, firstLegBelowPlane, secondLegPlane, secondLegAbovePlane, secondLegBelowPlane, x, y, z, intersectionPoint);\n      if (!firstLegTree.traverse(edgeIterator, firstLegValue)) {\n        return true;\n      }\n      //edgeIterator.setSecondLeg();\n      if (!secondLegTree.traverse(edgeIterator, secondLegValue)) {\n        return true;\n      }\n      //System.out.println(\"Polarity vs. test point: \"+(((edgeIterator.getCrossingCount()  & 1) == 0)?\"same\":\"different\")+\"; testPointInSet: \"+testPointInSet);\n      return ((edgeIterator.getCrossingCount()  & 1) == 0)?testPointInSet:!testPointInSet;\n\n    }\n  }\n\n","sourceOld":"  @Override\n  public boolean isWithin(final double x, final double y, final double z) {\n    //System.out.println(\"\\nIswithin called for [\"+x+\",\"+y+\",\"+z+\"]\");\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(x, y, z)) {\n      return testPointInSet;\n    }\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && testPointFixedYPlane.evaluateIsZero(x, y, z)) {\n      // Use the XZ plane exclusively.\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      if (!yTree.traverse(crossingEdgeIterator, testPoint.y)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && testPointFixedXPlane.evaluateIsZero(x, y, z)) {\n      // Use the YZ plane exclusively.\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      if (!xTree.traverse(crossingEdgeIterator, testPoint.x)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && testPointFixedZPlane.evaluateIsZero(x, y, z)) {\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!zTree.traverse(crossingEdgeIterator, testPoint.z)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedYPlane.evaluateIsZero(x, y, z) || testPointFixedXPlane.evaluateIsZero(x, y, z) || testPointFixedZPlane.evaluateIsZero(x, y, z)) {\n      throw new IllegalArgumentException(\"Can't compute isWithin for specified point\");\n    } else {\n\n      // This is the expensive part!!\n      // Changing the code below has an enormous impact on the queries per second we see with the benchmark.\n      \n      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.\n      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -x);\n      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -y);\n      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -z);\n\n      Plane fixedYAbovePlane = new Plane(travelPlaneFixedY, true);\n      if (fixedYAbovePlane.D - planetModel.getMaximumYValue() >= Vector.MINIMUM_RESOLUTION || planetModel.getMinimumYValue() - fixedYAbovePlane.D >= Vector.MINIMUM_RESOLUTION) {\n          fixedYAbovePlane = null;\n      }\n      \n      Plane fixedYBelowPlane = new Plane(travelPlaneFixedY, false);\n      if (fixedYBelowPlane.D - planetModel.getMaximumYValue() >= Vector.MINIMUM_RESOLUTION || planetModel.getMinimumYValue() - fixedYBelowPlane.D >= Vector.MINIMUM_RESOLUTION) {\n          fixedYBelowPlane = null;\n      }\n      \n      Plane fixedXAbovePlane = new Plane(travelPlaneFixedX, true);\n      if (fixedXAbovePlane.D - planetModel.getMaximumXValue() >= Vector.MINIMUM_RESOLUTION || planetModel.getMinimumXValue() - fixedXAbovePlane.D >= Vector.MINIMUM_RESOLUTION) {\n          fixedXAbovePlane = null;\n      }\n      \n      Plane fixedXBelowPlane = new Plane(travelPlaneFixedX, false);\n      if (fixedXBelowPlane.D - planetModel.getMaximumXValue() >= Vector.MINIMUM_RESOLUTION || planetModel.getMinimumXValue() - fixedXBelowPlane.D >= Vector.MINIMUM_RESOLUTION) {\n          fixedXBelowPlane = null;\n      }\n      \n      Plane fixedZAbovePlane = new Plane(travelPlaneFixedZ, true);\n      if (fixedZAbovePlane.D - planetModel.getMaximumZValue() >= Vector.MINIMUM_RESOLUTION || planetModel.getMinimumZValue() - fixedZAbovePlane.D >= Vector.MINIMUM_RESOLUTION) {\n          fixedZAbovePlane = null;\n      }\n      \n      Plane fixedZBelowPlane = new Plane(travelPlaneFixedZ, false);\n      if (fixedZBelowPlane.D - planetModel.getMaximumZValue() >= Vector.MINIMUM_RESOLUTION || planetModel.getMinimumZValue() - fixedZBelowPlane.D >= Vector.MINIMUM_RESOLUTION) {\n          fixedZBelowPlane = null;\n      }\n\n      // Find the intersection points for each one of these and the complementary test point planes.\n\n      // There will be multiple intersection points found.  We choose the one that has the lowest total distance, as measured in delta X, delta Y, and delta Z.\n      double bestDistance = Double.POSITIVE_INFINITY;\n      double firstLegValue = 0.0;\n      double secondLegValue = 0.0;\n      Plane firstLegPlane = null;\n      Plane firstLegAbovePlane = null;\n      Plane firstLegBelowPlane = null;\n      Plane secondLegPlane = null;\n      Plane secondLegAbovePlane = null;\n      Plane secondLegBelowPlane = null;\n      Tree firstLegTree = null;\n      Tree secondLegTree = null;\n      GeoPoint intersectionPoint = null;\n\n      if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && fixedXAbovePlane != null && fixedXBelowPlane != null) {\n        final GeoPoint[] XIntersectionsY = travelPlaneFixedX.findIntersections(planetModel, testPointFixedYPlane);\n        for (final GeoPoint p : XIntersectionsY) {\n          // Travel would be in YZ plane (fixed x) then in XZ (fixed y)\n          // We compute distance we need to travel as a placeholder for the number of intersections we might encounter.\n          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n          final double tpDelta1 = testPoint.x - p.x;\n          final double tpDelta2 = testPoint.z - p.z;\n          final double cpDelta1 = y - p.y;\n          final double cpDelta2 = z - p.z;\n          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n          //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n          //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.y - p.y);\n          if (newDistance < bestDistance) {\n            bestDistance = newDistance;\n            firstLegValue = testPoint.y;\n            secondLegValue = x;\n            firstLegPlane = testPointFixedYPlane;\n            firstLegAbovePlane = testPointFixedYAbovePlane;\n            firstLegBelowPlane = testPointFixedYBelowPlane;\n            secondLegPlane = travelPlaneFixedX;\n            secondLegAbovePlane = fixedXAbovePlane;\n            secondLegBelowPlane = fixedXBelowPlane;\n            firstLegTree = yTree;\n            secondLegTree = xTree;\n            intersectionPoint = p;\n          }\n        }\n      }\n      if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && fixedXAbovePlane != null && fixedXBelowPlane != null) {\n        final GeoPoint[] XIntersectionsZ = travelPlaneFixedX.findIntersections(planetModel, testPointFixedZPlane);\n        for (final GeoPoint p : XIntersectionsZ) {\n          // Travel would be in YZ plane (fixed x) then in XY (fixed z)\n          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n          final double tpDelta1 = testPoint.x - p.x;\n          final double tpDelta2 = testPoint.y - p.y;\n          final double cpDelta1 = y - p.y;\n          final double cpDelta2 = z - p.z;\n          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n          //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n          //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.z - p.z);\n          if (newDistance < bestDistance) {\n            bestDistance = newDistance;\n            firstLegValue = testPoint.z;\n            secondLegValue = x;\n            firstLegPlane = testPointFixedZPlane;\n            firstLegAbovePlane = testPointFixedZAbovePlane;\n            firstLegBelowPlane = testPointFixedZBelowPlane;\n            secondLegPlane = travelPlaneFixedX;\n            secondLegAbovePlane = fixedXAbovePlane;\n            secondLegBelowPlane = fixedXBelowPlane;\n            firstLegTree = zTree;\n            secondLegTree = xTree;\n            intersectionPoint = p;\n          }\n        }\n      }\n      if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && fixedYAbovePlane != null && fixedYBelowPlane != null) {\n        final GeoPoint[] YIntersectionsX = travelPlaneFixedY.findIntersections(planetModel, testPointFixedXPlane);\n        for (final GeoPoint p : YIntersectionsX) {\n          // Travel would be in XZ plane (fixed y) then in YZ (fixed x)\n          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n          final double tpDelta1 = testPoint.y - p.y;\n          final double tpDelta2 = testPoint.z - p.z;\n          final double cpDelta1 = x - p.x;\n          final double cpDelta2 = z - p.z;\n          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n          //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n          //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.x - p.x);\n          if (newDistance < bestDistance) {\n            bestDistance = newDistance;\n            firstLegValue = testPoint.x;\n            secondLegValue = y;\n            firstLegPlane = testPointFixedXPlane;\n            firstLegAbovePlane = testPointFixedXAbovePlane;\n            firstLegBelowPlane = testPointFixedXBelowPlane;\n            secondLegPlane = travelPlaneFixedY;\n            secondLegAbovePlane = fixedYAbovePlane;\n            secondLegBelowPlane = fixedYBelowPlane;\n            firstLegTree = xTree;\n            secondLegTree = yTree;\n            intersectionPoint = p;\n          }\n        }\n      }\n      if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && fixedYAbovePlane != null && fixedYBelowPlane != null) {\n        final GeoPoint[] YIntersectionsZ = travelPlaneFixedY.findIntersections(planetModel, testPointFixedZPlane);\n        for (final GeoPoint p : YIntersectionsZ) {\n          // Travel would be in XZ plane (fixed y) then in XY (fixed z)\n          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n          final double tpDelta1 = testPoint.x - p.x;\n          final double tpDelta2 = testPoint.y - p.y;\n          final double cpDelta1 = x - p.x;\n          final double cpDelta2 = z - p.z;\n          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n          //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n          //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.z - p.z);\n          if (newDistance < bestDistance) {\n            bestDistance = newDistance;\n            firstLegValue = testPoint.z;\n            secondLegValue = y;\n            firstLegPlane = testPointFixedZPlane;\n            firstLegAbovePlane = testPointFixedZAbovePlane;\n            firstLegBelowPlane = testPointFixedZBelowPlane;\n            secondLegPlane = travelPlaneFixedY;\n            secondLegAbovePlane = fixedYAbovePlane;\n            secondLegBelowPlane = fixedYBelowPlane;\n            firstLegTree = zTree;\n            secondLegTree = yTree;\n            intersectionPoint = p;\n          }\n        }\n      }\n      if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && fixedZAbovePlane != null && fixedZBelowPlane != null) {\n        final GeoPoint[] ZIntersectionsX = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedXPlane);\n        for (final GeoPoint p : ZIntersectionsX) {\n          // Travel would be in XY plane (fixed z) then in YZ (fixed x)\n          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n          final double tpDelta1 = testPoint.y - p.y;\n          final double tpDelta2 = testPoint.z - p.z;\n          final double cpDelta1 = y - p.y;\n          final double cpDelta2 = x - p.x;\n          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n          //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n          //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.x - p.x);\n          if (newDistance < bestDistance) {\n            bestDistance = newDistance;\n            firstLegValue = testPoint.x;\n            secondLegValue = z;\n            firstLegPlane = testPointFixedXPlane;\n            firstLegAbovePlane = testPointFixedXAbovePlane;\n            firstLegBelowPlane = testPointFixedXBelowPlane;\n            secondLegPlane = travelPlaneFixedZ;\n            secondLegAbovePlane = fixedZAbovePlane;\n            secondLegBelowPlane = fixedZBelowPlane;\n            firstLegTree = xTree;\n            secondLegTree = zTree;\n            intersectionPoint = p;\n          }\n        }\n      }\n      if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && fixedZAbovePlane != null && fixedZBelowPlane != null) {\n        final GeoPoint[] ZIntersectionsY = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedYPlane);\n        for (final GeoPoint p : ZIntersectionsY) {\n          // Travel would be in XY plane (fixed z) then in XZ (fixed y)\n          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n          final double tpDelta1 = testPoint.x - p.x;\n          final double tpDelta2 = testPoint.z - p.z;\n          final double cpDelta1 = y - p.y;\n          final double cpDelta2 = x - p.x;\n          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n          //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n          //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.y - p.y);\n          if (newDistance < bestDistance) {\n            bestDistance = newDistance;\n            firstLegValue = testPoint.y;\n            secondLegValue = z;\n            firstLegPlane = testPointFixedYPlane;\n            firstLegAbovePlane = testPointFixedYAbovePlane;\n            firstLegBelowPlane = testPointFixedYBelowPlane;\n            secondLegPlane = travelPlaneFixedZ;\n            secondLegAbovePlane = fixedZAbovePlane;\n            secondLegBelowPlane = fixedZBelowPlane;\n            firstLegTree = yTree;\n            secondLegTree = zTree;\n            intersectionPoint = p;\n          }\n        }\n      }\n\n      assert bestDistance > 0.0 : \"Best distance should not be zero unless on single plane\";\n      assert bestDistance < Double.POSITIVE_INFINITY : \"Couldn't find an intersection point of any kind\";\n      \n      final DualCrossingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(firstLegPlane, firstLegAbovePlane, firstLegBelowPlane, secondLegPlane, secondLegAbovePlane, secondLegBelowPlane, x, y, z, intersectionPoint);\n      if (!firstLegTree.traverse(edgeIterator, firstLegValue)) {\n        return true;\n      }\n      //edgeIterator.setSecondLeg();\n      if (!secondLegTree.traverse(edgeIterator, secondLegValue)) {\n        return true;\n      }\n      //System.out.println(\"Polarity vs. test point: \"+(((edgeIterator.getCrossingCount()  & 1) == 0)?\"same\":\"different\")+\"; testPointInSet: \"+testPointInSet);\n      return ((edgeIterator.getCrossingCount()  & 1) == 0)?testPointInSet:!testPointInSet;\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a31f543c55a8dd122ed8676510a9c6d8000fa214","date":1524142014,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(double,double,double).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(double,double,double).mjava","sourceNew":"  @Override\n  public boolean isWithin(final double x, final double y, final double z) {\n    //System.out.println(\"\\nIswithin called for [\"+x+\",\"+y+\",\"+z+\"]\");\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(x, y, z)) {\n      return testPointInSet;\n    }\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && testPointFixedYPlane.evaluateIsZero(x, y, z)) {\n      // Use the XZ plane exclusively.\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      if (!yTree.traverse(crossingEdgeIterator, testPoint.y)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && testPointFixedXPlane.evaluateIsZero(x, y, z)) {\n      // Use the YZ plane exclusively.\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      if (!xTree.traverse(crossingEdgeIterator, testPoint.x)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && testPointFixedZPlane.evaluateIsZero(x, y, z)) {\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!zTree.traverse(crossingEdgeIterator, testPoint.z)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedYPlane.evaluateIsZero(x, y, z) || testPointFixedXPlane.evaluateIsZero(x, y, z) || testPointFixedZPlane.evaluateIsZero(x, y, z)) {\n      throw new IllegalArgumentException(\"Can't compute isWithin for specified point\");\n    } else {\n\n      // This is the expensive part!!\n      // Changing the code below has an enormous impact on the queries per second we see with the benchmark.\n      \n      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.\n      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -x);\n      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -y);\n      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -z);\n\n      Plane fixedYAbovePlane = new Plane(travelPlaneFixedY, true);\n      if (fixedYAbovePlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumYValue() - fixedYAbovePlane.D > NEAR_EDGE_CUTOFF) {\n          fixedYAbovePlane = null;\n      }\n      \n      Plane fixedYBelowPlane = new Plane(travelPlaneFixedY, false);\n      if (fixedYBelowPlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumYValue() - fixedYBelowPlane.D > NEAR_EDGE_CUTOFF) {\n          fixedYBelowPlane = null;\n      }\n      \n      Plane fixedXAbovePlane = new Plane(travelPlaneFixedX, true);\n      if (fixedXAbovePlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() - fixedXAbovePlane.D > NEAR_EDGE_CUTOFF) {\n          fixedXAbovePlane = null;\n      }\n      \n      Plane fixedXBelowPlane = new Plane(travelPlaneFixedX, false);\n      if (fixedXBelowPlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() - fixedXBelowPlane.D > NEAR_EDGE_CUTOFF) {\n          fixedXBelowPlane = null;\n      }\n      \n      Plane fixedZAbovePlane = new Plane(travelPlaneFixedZ, true);\n      if (fixedZAbovePlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumZValue() - fixedZAbovePlane.D > NEAR_EDGE_CUTOFF) {\n          fixedZAbovePlane = null;\n      }\n      \n      Plane fixedZBelowPlane = new Plane(travelPlaneFixedZ, false);\n      if (fixedZBelowPlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumZValue() - fixedZBelowPlane.D > NEAR_EDGE_CUTOFF) {\n          fixedZBelowPlane = null;\n      }\n\n      // Find the intersection points for each one of these and the complementary test point planes.\n\n      // There will be multiple intersection points found.  We choose the one that has the lowest total distance, as measured in delta X, delta Y, and delta Z.\n      double bestDistance = Double.POSITIVE_INFINITY;\n      double firstLegValue = 0.0;\n      double secondLegValue = 0.0;\n      Plane firstLegPlane = null;\n      Plane firstLegAbovePlane = null;\n      Plane firstLegBelowPlane = null;\n      Plane secondLegPlane = null;\n      Plane secondLegAbovePlane = null;\n      Plane secondLegBelowPlane = null;\n      Tree firstLegTree = null;\n      Tree secondLegTree = null;\n      GeoPoint intersectionPoint = null;\n\n      if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && fixedXAbovePlane != null && fixedXBelowPlane != null) {\n        final GeoPoint[] XIntersectionsY = travelPlaneFixedX.findIntersections(planetModel, testPointFixedYPlane);\n        for (final GeoPoint p : XIntersectionsY) {\n          // Travel would be in YZ plane (fixed x) then in XZ (fixed y)\n          // We compute distance we need to travel as a placeholder for the number of intersections we might encounter.\n          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n          final double tpDelta1 = testPoint.x - p.x;\n          final double tpDelta2 = testPoint.z - p.z;\n          final double cpDelta1 = y - p.y;\n          final double cpDelta2 = z - p.z;\n          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n          //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n          //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.y - p.y);\n          if (newDistance < bestDistance) {\n            bestDistance = newDistance;\n            firstLegValue = testPoint.y;\n            secondLegValue = x;\n            firstLegPlane = testPointFixedYPlane;\n            firstLegAbovePlane = testPointFixedYAbovePlane;\n            firstLegBelowPlane = testPointFixedYBelowPlane;\n            secondLegPlane = travelPlaneFixedX;\n            secondLegAbovePlane = fixedXAbovePlane;\n            secondLegBelowPlane = fixedXBelowPlane;\n            firstLegTree = yTree;\n            secondLegTree = xTree;\n            intersectionPoint = p;\n          }\n        }\n      }\n      if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && fixedXAbovePlane != null && fixedXBelowPlane != null) {\n        final GeoPoint[] XIntersectionsZ = travelPlaneFixedX.findIntersections(planetModel, testPointFixedZPlane);\n        for (final GeoPoint p : XIntersectionsZ) {\n          // Travel would be in YZ plane (fixed x) then in XY (fixed z)\n          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n          final double tpDelta1 = testPoint.x - p.x;\n          final double tpDelta2 = testPoint.y - p.y;\n          final double cpDelta1 = y - p.y;\n          final double cpDelta2 = z - p.z;\n          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n          //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n          //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.z - p.z);\n          if (newDistance < bestDistance) {\n            bestDistance = newDistance;\n            firstLegValue = testPoint.z;\n            secondLegValue = x;\n            firstLegPlane = testPointFixedZPlane;\n            firstLegAbovePlane = testPointFixedZAbovePlane;\n            firstLegBelowPlane = testPointFixedZBelowPlane;\n            secondLegPlane = travelPlaneFixedX;\n            secondLegAbovePlane = fixedXAbovePlane;\n            secondLegBelowPlane = fixedXBelowPlane;\n            firstLegTree = zTree;\n            secondLegTree = xTree;\n            intersectionPoint = p;\n          }\n        }\n      }\n      if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && fixedYAbovePlane != null && fixedYBelowPlane != null) {\n        final GeoPoint[] YIntersectionsX = travelPlaneFixedY.findIntersections(planetModel, testPointFixedXPlane);\n        for (final GeoPoint p : YIntersectionsX) {\n          // Travel would be in XZ plane (fixed y) then in YZ (fixed x)\n          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n          final double tpDelta1 = testPoint.y - p.y;\n          final double tpDelta2 = testPoint.z - p.z;\n          final double cpDelta1 = x - p.x;\n          final double cpDelta2 = z - p.z;\n          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n          //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n          //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.x - p.x);\n          if (newDistance < bestDistance) {\n            bestDistance = newDistance;\n            firstLegValue = testPoint.x;\n            secondLegValue = y;\n            firstLegPlane = testPointFixedXPlane;\n            firstLegAbovePlane = testPointFixedXAbovePlane;\n            firstLegBelowPlane = testPointFixedXBelowPlane;\n            secondLegPlane = travelPlaneFixedY;\n            secondLegAbovePlane = fixedYAbovePlane;\n            secondLegBelowPlane = fixedYBelowPlane;\n            firstLegTree = xTree;\n            secondLegTree = yTree;\n            intersectionPoint = p;\n          }\n        }\n      }\n      if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && fixedYAbovePlane != null && fixedYBelowPlane != null) {\n        final GeoPoint[] YIntersectionsZ = travelPlaneFixedY.findIntersections(planetModel, testPointFixedZPlane);\n        for (final GeoPoint p : YIntersectionsZ) {\n          // Travel would be in XZ plane (fixed y) then in XY (fixed z)\n          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n          final double tpDelta1 = testPoint.x - p.x;\n          final double tpDelta2 = testPoint.y - p.y;\n          final double cpDelta1 = x - p.x;\n          final double cpDelta2 = z - p.z;\n          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n          //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n          //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.z - p.z);\n          if (newDistance < bestDistance) {\n            bestDistance = newDistance;\n            firstLegValue = testPoint.z;\n            secondLegValue = y;\n            firstLegPlane = testPointFixedZPlane;\n            firstLegAbovePlane = testPointFixedZAbovePlane;\n            firstLegBelowPlane = testPointFixedZBelowPlane;\n            secondLegPlane = travelPlaneFixedY;\n            secondLegAbovePlane = fixedYAbovePlane;\n            secondLegBelowPlane = fixedYBelowPlane;\n            firstLegTree = zTree;\n            secondLegTree = yTree;\n            intersectionPoint = p;\n          }\n        }\n      }\n      if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && fixedZAbovePlane != null && fixedZBelowPlane != null) {\n        final GeoPoint[] ZIntersectionsX = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedXPlane);\n        for (final GeoPoint p : ZIntersectionsX) {\n          // Travel would be in XY plane (fixed z) then in YZ (fixed x)\n          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n          final double tpDelta1 = testPoint.y - p.y;\n          final double tpDelta2 = testPoint.z - p.z;\n          final double cpDelta1 = y - p.y;\n          final double cpDelta2 = x - p.x;\n          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n          //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n          //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.x - p.x);\n          if (newDistance < bestDistance) {\n            bestDistance = newDistance;\n            firstLegValue = testPoint.x;\n            secondLegValue = z;\n            firstLegPlane = testPointFixedXPlane;\n            firstLegAbovePlane = testPointFixedXAbovePlane;\n            firstLegBelowPlane = testPointFixedXBelowPlane;\n            secondLegPlane = travelPlaneFixedZ;\n            secondLegAbovePlane = fixedZAbovePlane;\n            secondLegBelowPlane = fixedZBelowPlane;\n            firstLegTree = xTree;\n            secondLegTree = zTree;\n            intersectionPoint = p;\n          }\n        }\n      }\n      if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && fixedZAbovePlane != null && fixedZBelowPlane != null) {\n        final GeoPoint[] ZIntersectionsY = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedYPlane);\n        for (final GeoPoint p : ZIntersectionsY) {\n          // Travel would be in XY plane (fixed z) then in XZ (fixed y)\n          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n          final double tpDelta1 = testPoint.x - p.x;\n          final double tpDelta2 = testPoint.z - p.z;\n          final double cpDelta1 = y - p.y;\n          final double cpDelta2 = x - p.x;\n          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n          //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n          //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.y - p.y);\n          if (newDistance < bestDistance) {\n            bestDistance = newDistance;\n            firstLegValue = testPoint.y;\n            secondLegValue = z;\n            firstLegPlane = testPointFixedYPlane;\n            firstLegAbovePlane = testPointFixedYAbovePlane;\n            firstLegBelowPlane = testPointFixedYBelowPlane;\n            secondLegPlane = travelPlaneFixedZ;\n            secondLegAbovePlane = fixedZAbovePlane;\n            secondLegBelowPlane = fixedZBelowPlane;\n            firstLegTree = yTree;\n            secondLegTree = zTree;\n            intersectionPoint = p;\n          }\n        }\n      }\n\n      assert bestDistance > 0.0 : \"Best distance should not be zero unless on single plane\";\n      assert bestDistance < Double.POSITIVE_INFINITY : \"Couldn't find an intersection point of any kind\";\n      \n      final DualCrossingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(firstLegPlane, firstLegAbovePlane, firstLegBelowPlane, secondLegPlane, secondLegAbovePlane, secondLegBelowPlane, x, y, z, intersectionPoint);\n      if (!firstLegTree.traverse(edgeIterator, firstLegValue)) {\n        return true;\n      }\n      //edgeIterator.setSecondLeg();\n      if (!secondLegTree.traverse(edgeIterator, secondLegValue)) {\n        return true;\n      }\n      //System.out.println(\"Polarity vs. test point: \"+(((edgeIterator.getCrossingCount()  & 1) == 0)?\"same\":\"different\")+\"; testPointInSet: \"+testPointInSet);\n      return ((edgeIterator.getCrossingCount()  & 1) == 0)?testPointInSet:!testPointInSet;\n\n    }\n  }\n\n","sourceOld":"  @Override\n  public boolean isWithin(final double x, final double y, final double z) {\n    //System.out.println(\"\\nIswithin called for [\"+x+\",\"+y+\",\"+z+\"]\");\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(x, y, z)) {\n      return testPointInSet;\n    }\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && testPointFixedYPlane.evaluateIsZero(x, y, z)) {\n      // Use the XZ plane exclusively.\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      if (!yTree.traverse(crossingEdgeIterator, testPoint.y)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && testPointFixedXPlane.evaluateIsZero(x, y, z)) {\n      // Use the YZ plane exclusively.\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      if (!xTree.traverse(crossingEdgeIterator, testPoint.x)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && testPointFixedZPlane.evaluateIsZero(x, y, z)) {\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!zTree.traverse(crossingEdgeIterator, testPoint.z)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedYPlane.evaluateIsZero(x, y, z) || testPointFixedXPlane.evaluateIsZero(x, y, z) || testPointFixedZPlane.evaluateIsZero(x, y, z)) {\n      throw new IllegalArgumentException(\"Can't compute isWithin for specified point\");\n    } else {\n\n      // This is the expensive part!!\n      // Changing the code below has an enormous impact on the queries per second we see with the benchmark.\n      \n      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.\n      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -x);\n      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -y);\n      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -z);\n\n      Plane fixedYAbovePlane = new Plane(travelPlaneFixedY, true);\n      if (fixedYAbovePlane.D - planetModel.getMaximumYValue() > 0.0 || planetModel.getMinimumYValue() - fixedYAbovePlane.D > 0.0) {\n          fixedYAbovePlane = null;\n      }\n      \n      Plane fixedYBelowPlane = new Plane(travelPlaneFixedY, false);\n      if (fixedYBelowPlane.D - planetModel.getMaximumYValue() > 0.0 || planetModel.getMinimumYValue() - fixedYBelowPlane.D > 0.0) {\n          fixedYBelowPlane = null;\n      }\n      \n      Plane fixedXAbovePlane = new Plane(travelPlaneFixedX, true);\n      if (fixedXAbovePlane.D - planetModel.getMaximumXValue() > 0.0 || planetModel.getMinimumXValue() - fixedXAbovePlane.D > 0.0) {\n          fixedXAbovePlane = null;\n      }\n      \n      Plane fixedXBelowPlane = new Plane(travelPlaneFixedX, false);\n      if (fixedXBelowPlane.D - planetModel.getMaximumXValue() > 0.0 || planetModel.getMinimumXValue() - fixedXBelowPlane.D > 0.0) {\n          fixedXBelowPlane = null;\n      }\n      \n      Plane fixedZAbovePlane = new Plane(travelPlaneFixedZ, true);\n      if (fixedZAbovePlane.D - planetModel.getMaximumZValue() > 0.0 || planetModel.getMinimumZValue() - fixedZAbovePlane.D > 0.0) {\n          fixedZAbovePlane = null;\n      }\n      \n      Plane fixedZBelowPlane = new Plane(travelPlaneFixedZ, false);\n      if (fixedZBelowPlane.D - planetModel.getMaximumZValue() > 0.0 || planetModel.getMinimumZValue() - fixedZBelowPlane.D > 0.0) {\n          fixedZBelowPlane = null;\n      }\n\n      // Find the intersection points for each one of these and the complementary test point planes.\n\n      // There will be multiple intersection points found.  We choose the one that has the lowest total distance, as measured in delta X, delta Y, and delta Z.\n      double bestDistance = Double.POSITIVE_INFINITY;\n      double firstLegValue = 0.0;\n      double secondLegValue = 0.0;\n      Plane firstLegPlane = null;\n      Plane firstLegAbovePlane = null;\n      Plane firstLegBelowPlane = null;\n      Plane secondLegPlane = null;\n      Plane secondLegAbovePlane = null;\n      Plane secondLegBelowPlane = null;\n      Tree firstLegTree = null;\n      Tree secondLegTree = null;\n      GeoPoint intersectionPoint = null;\n\n      if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && fixedXAbovePlane != null && fixedXBelowPlane != null) {\n        final GeoPoint[] XIntersectionsY = travelPlaneFixedX.findIntersections(planetModel, testPointFixedYPlane);\n        for (final GeoPoint p : XIntersectionsY) {\n          // Travel would be in YZ plane (fixed x) then in XZ (fixed y)\n          // We compute distance we need to travel as a placeholder for the number of intersections we might encounter.\n          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n          final double tpDelta1 = testPoint.x - p.x;\n          final double tpDelta2 = testPoint.z - p.z;\n          final double cpDelta1 = y - p.y;\n          final double cpDelta2 = z - p.z;\n          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n          //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n          //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.y - p.y);\n          if (newDistance < bestDistance) {\n            bestDistance = newDistance;\n            firstLegValue = testPoint.y;\n            secondLegValue = x;\n            firstLegPlane = testPointFixedYPlane;\n            firstLegAbovePlane = testPointFixedYAbovePlane;\n            firstLegBelowPlane = testPointFixedYBelowPlane;\n            secondLegPlane = travelPlaneFixedX;\n            secondLegAbovePlane = fixedXAbovePlane;\n            secondLegBelowPlane = fixedXBelowPlane;\n            firstLegTree = yTree;\n            secondLegTree = xTree;\n            intersectionPoint = p;\n          }\n        }\n      }\n      if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && fixedXAbovePlane != null && fixedXBelowPlane != null) {\n        final GeoPoint[] XIntersectionsZ = travelPlaneFixedX.findIntersections(planetModel, testPointFixedZPlane);\n        for (final GeoPoint p : XIntersectionsZ) {\n          // Travel would be in YZ plane (fixed x) then in XY (fixed z)\n          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n          final double tpDelta1 = testPoint.x - p.x;\n          final double tpDelta2 = testPoint.y - p.y;\n          final double cpDelta1 = y - p.y;\n          final double cpDelta2 = z - p.z;\n          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n          //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n          //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.z - p.z);\n          if (newDistance < bestDistance) {\n            bestDistance = newDistance;\n            firstLegValue = testPoint.z;\n            secondLegValue = x;\n            firstLegPlane = testPointFixedZPlane;\n            firstLegAbovePlane = testPointFixedZAbovePlane;\n            firstLegBelowPlane = testPointFixedZBelowPlane;\n            secondLegPlane = travelPlaneFixedX;\n            secondLegAbovePlane = fixedXAbovePlane;\n            secondLegBelowPlane = fixedXBelowPlane;\n            firstLegTree = zTree;\n            secondLegTree = xTree;\n            intersectionPoint = p;\n          }\n        }\n      }\n      if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && fixedYAbovePlane != null && fixedYBelowPlane != null) {\n        final GeoPoint[] YIntersectionsX = travelPlaneFixedY.findIntersections(planetModel, testPointFixedXPlane);\n        for (final GeoPoint p : YIntersectionsX) {\n          // Travel would be in XZ plane (fixed y) then in YZ (fixed x)\n          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n          final double tpDelta1 = testPoint.y - p.y;\n          final double tpDelta2 = testPoint.z - p.z;\n          final double cpDelta1 = x - p.x;\n          final double cpDelta2 = z - p.z;\n          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n          //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n          //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.x - p.x);\n          if (newDistance < bestDistance) {\n            bestDistance = newDistance;\n            firstLegValue = testPoint.x;\n            secondLegValue = y;\n            firstLegPlane = testPointFixedXPlane;\n            firstLegAbovePlane = testPointFixedXAbovePlane;\n            firstLegBelowPlane = testPointFixedXBelowPlane;\n            secondLegPlane = travelPlaneFixedY;\n            secondLegAbovePlane = fixedYAbovePlane;\n            secondLegBelowPlane = fixedYBelowPlane;\n            firstLegTree = xTree;\n            secondLegTree = yTree;\n            intersectionPoint = p;\n          }\n        }\n      }\n      if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && fixedYAbovePlane != null && fixedYBelowPlane != null) {\n        final GeoPoint[] YIntersectionsZ = travelPlaneFixedY.findIntersections(planetModel, testPointFixedZPlane);\n        for (final GeoPoint p : YIntersectionsZ) {\n          // Travel would be in XZ plane (fixed y) then in XY (fixed z)\n          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n          final double tpDelta1 = testPoint.x - p.x;\n          final double tpDelta2 = testPoint.y - p.y;\n          final double cpDelta1 = x - p.x;\n          final double cpDelta2 = z - p.z;\n          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n          //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n          //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.z - p.z);\n          if (newDistance < bestDistance) {\n            bestDistance = newDistance;\n            firstLegValue = testPoint.z;\n            secondLegValue = y;\n            firstLegPlane = testPointFixedZPlane;\n            firstLegAbovePlane = testPointFixedZAbovePlane;\n            firstLegBelowPlane = testPointFixedZBelowPlane;\n            secondLegPlane = travelPlaneFixedY;\n            secondLegAbovePlane = fixedYAbovePlane;\n            secondLegBelowPlane = fixedYBelowPlane;\n            firstLegTree = zTree;\n            secondLegTree = yTree;\n            intersectionPoint = p;\n          }\n        }\n      }\n      if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && fixedZAbovePlane != null && fixedZBelowPlane != null) {\n        final GeoPoint[] ZIntersectionsX = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedXPlane);\n        for (final GeoPoint p : ZIntersectionsX) {\n          // Travel would be in XY plane (fixed z) then in YZ (fixed x)\n          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n          final double tpDelta1 = testPoint.y - p.y;\n          final double tpDelta2 = testPoint.z - p.z;\n          final double cpDelta1 = y - p.y;\n          final double cpDelta2 = x - p.x;\n          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n          //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n          //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.x - p.x);\n          if (newDistance < bestDistance) {\n            bestDistance = newDistance;\n            firstLegValue = testPoint.x;\n            secondLegValue = z;\n            firstLegPlane = testPointFixedXPlane;\n            firstLegAbovePlane = testPointFixedXAbovePlane;\n            firstLegBelowPlane = testPointFixedXBelowPlane;\n            secondLegPlane = travelPlaneFixedZ;\n            secondLegAbovePlane = fixedZAbovePlane;\n            secondLegBelowPlane = fixedZBelowPlane;\n            firstLegTree = xTree;\n            secondLegTree = zTree;\n            intersectionPoint = p;\n          }\n        }\n      }\n      if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && fixedZAbovePlane != null && fixedZBelowPlane != null) {\n        final GeoPoint[] ZIntersectionsY = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedYPlane);\n        for (final GeoPoint p : ZIntersectionsY) {\n          // Travel would be in XY plane (fixed z) then in XZ (fixed y)\n          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n          final double tpDelta1 = testPoint.x - p.x;\n          final double tpDelta2 = testPoint.z - p.z;\n          final double cpDelta1 = y - p.y;\n          final double cpDelta2 = x - p.x;\n          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n          //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n          //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.y - p.y);\n          if (newDistance < bestDistance) {\n            bestDistance = newDistance;\n            firstLegValue = testPoint.y;\n            secondLegValue = z;\n            firstLegPlane = testPointFixedYPlane;\n            firstLegAbovePlane = testPointFixedYAbovePlane;\n            firstLegBelowPlane = testPointFixedYBelowPlane;\n            secondLegPlane = travelPlaneFixedZ;\n            secondLegAbovePlane = fixedZAbovePlane;\n            secondLegBelowPlane = fixedZBelowPlane;\n            firstLegTree = yTree;\n            secondLegTree = zTree;\n            intersectionPoint = p;\n          }\n        }\n      }\n\n      assert bestDistance > 0.0 : \"Best distance should not be zero unless on single plane\";\n      assert bestDistance < Double.POSITIVE_INFINITY : \"Couldn't find an intersection point of any kind\";\n      \n      final DualCrossingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(firstLegPlane, firstLegAbovePlane, firstLegBelowPlane, secondLegPlane, secondLegAbovePlane, secondLegBelowPlane, x, y, z, intersectionPoint);\n      if (!firstLegTree.traverse(edgeIterator, firstLegValue)) {\n        return true;\n      }\n      //edgeIterator.setSecondLeg();\n      if (!secondLegTree.traverse(edgeIterator, secondLegValue)) {\n        return true;\n      }\n      //System.out.println(\"Polarity vs. test point: \"+(((edgeIterator.getCrossingCount()  & 1) == 0)?\"same\":\"different\")+\"; testPointInSet: \"+testPointInSet);\n      return ((edgeIterator.getCrossingCount()  & 1) == 0)?testPointInSet:!testPointInSet;\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"46e2380a7b2f7e3b199fffe1179d745d5c289227","date":1524209409,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(double,double,double).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(double,double,double).mjava","sourceNew":"  @Override\n  public boolean isWithin(final double x, final double y, final double z) {\n    //System.out.println(\"\\nIswithin called for [\"+x+\",\"+y+\",\"+z+\"]\");\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(x, y, z)) {\n      return testPointInSet;\n    }\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && testPointFixedYPlane.evaluateIsZero(x, y, z)) {\n      // Use the XZ plane exclusively.\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      if (!yTree.traverse(crossingEdgeIterator, testPoint.y)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && testPointFixedXPlane.evaluateIsZero(x, y, z)) {\n      // Use the YZ plane exclusively.\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      if (!xTree.traverse(crossingEdgeIterator, testPoint.x)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && testPointFixedZPlane.evaluateIsZero(x, y, z)) {\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!zTree.traverse(crossingEdgeIterator, testPoint.z)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedYPlane.evaluateIsZero(x, y, z) || testPointFixedXPlane.evaluateIsZero(x, y, z) || testPointFixedZPlane.evaluateIsZero(x, y, z)) {\n      throw new IllegalArgumentException(\"Can't compute isWithin for specified point\");\n    } else {\n\n      // This is the expensive part!!\n      // Changing the code below has an enormous impact on the queries per second we see with the benchmark.\n      \n      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.\n      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -x);\n      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -y);\n      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -z);\n\n      Plane fixedYAbovePlane = new Plane(travelPlaneFixedY, true);\n      if (fixedYAbovePlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumYValue() - fixedYAbovePlane.D > NEAR_EDGE_CUTOFF) {\n          fixedYAbovePlane = null;\n      }\n      \n      Plane fixedYBelowPlane = new Plane(travelPlaneFixedY, false);\n      if (fixedYBelowPlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumYValue() - fixedYBelowPlane.D > NEAR_EDGE_CUTOFF) {\n          fixedYBelowPlane = null;\n      }\n      \n      Plane fixedXAbovePlane = new Plane(travelPlaneFixedX, true);\n      if (fixedXAbovePlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() - fixedXAbovePlane.D > NEAR_EDGE_CUTOFF) {\n          fixedXAbovePlane = null;\n      }\n      \n      Plane fixedXBelowPlane = new Plane(travelPlaneFixedX, false);\n      if (fixedXBelowPlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() - fixedXBelowPlane.D > NEAR_EDGE_CUTOFF) {\n          fixedXBelowPlane = null;\n      }\n      \n      Plane fixedZAbovePlane = new Plane(travelPlaneFixedZ, true);\n      if (fixedZAbovePlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumZValue() - fixedZAbovePlane.D > NEAR_EDGE_CUTOFF) {\n          fixedZAbovePlane = null;\n      }\n      \n      Plane fixedZBelowPlane = new Plane(travelPlaneFixedZ, false);\n      if (fixedZBelowPlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumZValue() - fixedZBelowPlane.D > NEAR_EDGE_CUTOFF) {\n          fixedZBelowPlane = null;\n      }\n\n      // Find the intersection points for each one of these and the complementary test point planes.\n\n      // There will be multiple intersection points found.  We choose the one that has the lowest total distance, as measured in delta X, delta Y, and delta Z.\n      double bestDistance = Double.POSITIVE_INFINITY;\n      double firstLegValue = 0.0;\n      double secondLegValue = 0.0;\n      Plane firstLegPlane = null;\n      Plane firstLegAbovePlane = null;\n      Plane firstLegBelowPlane = null;\n      Plane secondLegPlane = null;\n      Plane secondLegAbovePlane = null;\n      Plane secondLegBelowPlane = null;\n      Tree firstLegTree = null;\n      Tree secondLegTree = null;\n      GeoPoint intersectionPoint = null;\n\n      if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && fixedXAbovePlane != null && fixedXBelowPlane != null) {\n        //check if planes intersects  inside world\n        final double checkAbove = 4.0 * (fixedXAbovePlane.D * fixedXAbovePlane.D * planetModel.inverseAbSquared + testPointFixedYAbovePlane.D * testPointFixedYAbovePlane.D * planetModel.inverseAbSquared - 1.0);\n        final double checkBelow = 4.0 * (fixedXBelowPlane.D * fixedXBelowPlane.D * planetModel.inverseAbSquared + testPointFixedYBelowPlane.D * testPointFixedYBelowPlane.D * planetModel.inverseAbSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          final GeoPoint[] XIntersectionsY = travelPlaneFixedX.findIntersections(planetModel, testPointFixedYPlane);\n          for (final GeoPoint p : XIntersectionsY) {\n            // Travel would be in YZ plane (fixed x) then in XZ (fixed y)\n            // We compute distance we need to travel as a placeholder for the number of intersections we might encounter.\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.x - p.x;\n            final double tpDelta2 = testPoint.z - p.z;\n            final double cpDelta1 = y - p.y;\n            final double cpDelta2 = z - p.z;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n            //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.y - p.y);\n            if (newDistance < bestDistance) {\n              bestDistance = newDistance;\n              firstLegValue = testPoint.y;\n              secondLegValue = x;\n              firstLegPlane = testPointFixedYPlane;\n              firstLegAbovePlane = testPointFixedYAbovePlane;\n              firstLegBelowPlane = testPointFixedYBelowPlane;\n              secondLegPlane = travelPlaneFixedX;\n              secondLegAbovePlane = fixedXAbovePlane;\n              secondLegBelowPlane = fixedXBelowPlane;\n              firstLegTree = yTree;\n              secondLegTree = xTree;\n              intersectionPoint = p;\n            }\n          }\n        }\n      }\n      if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && fixedXAbovePlane != null && fixedXBelowPlane != null) {\n        //check if planes intersects  inside world\n        final double checkAbove = 4.0 * (fixedXAbovePlane.D * fixedXAbovePlane.D * planetModel.inverseAbSquared + testPointFixedZAbovePlane.D * testPointFixedZAbovePlane.D * planetModel.inverseCSquared - 1.0);\n        final double checkBelow = 4.0 * (fixedXBelowPlane.D * fixedXBelowPlane.D * planetModel.inverseAbSquared + testPointFixedZBelowPlane.D * testPointFixedZBelowPlane.D * planetModel.inverseCSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          final GeoPoint[] XIntersectionsZ = travelPlaneFixedX.findIntersections(planetModel, testPointFixedZPlane);\n          for (final GeoPoint p : XIntersectionsZ) {\n            // Travel would be in YZ plane (fixed x) then in XY (fixed z)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.x - p.x;\n            final double tpDelta2 = testPoint.y - p.y;\n            final double cpDelta1 = y - p.y;\n            final double cpDelta2 = z - p.z;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n            //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.z - p.z);\n            if (newDistance < bestDistance) {\n              bestDistance = newDistance;\n              firstLegValue = testPoint.z;\n              secondLegValue = x;\n              firstLegPlane = testPointFixedZPlane;\n              firstLegAbovePlane = testPointFixedZAbovePlane;\n              firstLegBelowPlane = testPointFixedZBelowPlane;\n              secondLegPlane = travelPlaneFixedX;\n              secondLegAbovePlane = fixedXAbovePlane;\n              secondLegBelowPlane = fixedXBelowPlane;\n              firstLegTree = zTree;\n              secondLegTree = xTree;\n              intersectionPoint = p;\n            }\n          }\n        }\n      }\n      if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && fixedYAbovePlane != null && fixedYBelowPlane != null) {\n        //check if planes intersects inside world\n        final double checkAbove = 4.0 * (testPointFixedXAbovePlane.D * testPointFixedXAbovePlane.D * planetModel.inverseAbSquared + fixedYAbovePlane.D * fixedYAbovePlane.D * planetModel.inverseAbSquared - 1.0);\n        final double checkBelow = 4.0 * (testPointFixedXBelowPlane.D * testPointFixedXBelowPlane.D * planetModel.inverseAbSquared + fixedYBelowPlane.D * fixedYBelowPlane.D * planetModel.inverseAbSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          final GeoPoint[] YIntersectionsX = travelPlaneFixedY.findIntersections(planetModel, testPointFixedXPlane);\n          for (final GeoPoint p : YIntersectionsX) {\n            // Travel would be in XZ plane (fixed y) then in YZ (fixed x)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.y - p.y;\n            final double tpDelta2 = testPoint.z - p.z;\n            final double cpDelta1 = x - p.x;\n            final double cpDelta2 = z - p.z;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n            //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.x - p.x);\n            if (newDistance < bestDistance) {\n              bestDistance = newDistance;\n              firstLegValue = testPoint.x;\n              secondLegValue = y;\n              firstLegPlane = testPointFixedXPlane;\n              firstLegAbovePlane = testPointFixedXAbovePlane;\n              firstLegBelowPlane = testPointFixedXBelowPlane;\n              secondLegPlane = travelPlaneFixedY;\n              secondLegAbovePlane = fixedYAbovePlane;\n              secondLegBelowPlane = fixedYBelowPlane;\n              firstLegTree = xTree;\n              secondLegTree = yTree;\n              intersectionPoint = p;\n            }\n          }\n        }\n      }\n      if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && fixedYAbovePlane != null && fixedYBelowPlane != null) {\n        //check if planes intersects inside world\n        final double checkAbove = 4.0 * (testPointFixedZAbovePlane.D * testPointFixedZAbovePlane.D * planetModel.inverseCSquared + fixedYAbovePlane.D * fixedYAbovePlane.D * planetModel.inverseAbSquared - 1.0);\n        final double checkBelow = 4.0 * (testPointFixedZBelowPlane.D * testPointFixedZBelowPlane.D * planetModel.inverseCSquared + fixedYBelowPlane.D * fixedYBelowPlane.D * planetModel.inverseAbSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          final GeoPoint[] YIntersectionsZ = travelPlaneFixedY.findIntersections(planetModel, testPointFixedZPlane);\n          for (final GeoPoint p : YIntersectionsZ) {\n            // Travel would be in XZ plane (fixed y) then in XY (fixed z)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.x - p.x;\n            final double tpDelta2 = testPoint.y - p.y;\n            final double cpDelta1 = x - p.x;\n            final double cpDelta2 = z - p.z;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n            //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.z - p.z);\n            if (newDistance < bestDistance) {\n              bestDistance = newDistance;\n              firstLegValue = testPoint.z;\n              secondLegValue = y;\n              firstLegPlane = testPointFixedZPlane;\n              firstLegAbovePlane = testPointFixedZAbovePlane;\n              firstLegBelowPlane = testPointFixedZBelowPlane;\n              secondLegPlane = travelPlaneFixedY;\n              secondLegAbovePlane = fixedYAbovePlane;\n              secondLegBelowPlane = fixedYBelowPlane;\n              firstLegTree = zTree;\n              secondLegTree = yTree;\n              intersectionPoint = p;\n            }\n          }\n        }\n      }\n      if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && fixedZAbovePlane != null && fixedZBelowPlane != null) {\n        //check if planes intersects inside world\n        final double checkAbove = 4.0 * (testPointFixedXAbovePlane.D * testPointFixedXAbovePlane.D * planetModel.inverseAbSquared + fixedZAbovePlane.D * fixedZAbovePlane.D * planetModel.inverseCSquared - 1.0);\n        final double checkBelow = 4.0 * (testPointFixedXBelowPlane.D * testPointFixedXBelowPlane.D * planetModel.inverseAbSquared + fixedZBelowPlane.D * fixedZBelowPlane.D * planetModel.inverseCSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          final GeoPoint[] ZIntersectionsX = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedXPlane);\n          for (final GeoPoint p : ZIntersectionsX) {\n            // Travel would be in XY plane (fixed z) then in YZ (fixed x)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.y - p.y;\n            final double tpDelta2 = testPoint.z - p.z;\n            final double cpDelta1 = y - p.y;\n            final double cpDelta2 = x - p.x;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n            //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.x - p.x);\n            if (newDistance < bestDistance) {\n              bestDistance = newDistance;\n              firstLegValue = testPoint.x;\n              secondLegValue = z;\n              firstLegPlane = testPointFixedXPlane;\n              firstLegAbovePlane = testPointFixedXAbovePlane;\n              firstLegBelowPlane = testPointFixedXBelowPlane;\n              secondLegPlane = travelPlaneFixedZ;\n              secondLegAbovePlane = fixedZAbovePlane;\n              secondLegBelowPlane = fixedZBelowPlane;\n              firstLegTree = xTree;\n              secondLegTree = zTree;\n              intersectionPoint = p;\n            }\n          }\n        }\n      }\n      if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && fixedZAbovePlane != null && fixedZBelowPlane != null) {\n        //check if planes intersects inside world\n        final double checkAbove = 4.0 * (testPointFixedYAbovePlane.D * testPointFixedYAbovePlane.D * planetModel.inverseAbSquared + fixedZAbovePlane.D * fixedZAbovePlane.D * planetModel.inverseCSquared - 1.0);\n        final double checkBelow = 4.0 * (testPointFixedYBelowPlane.D * testPointFixedYBelowPlane.D * planetModel.inverseAbSquared + fixedZBelowPlane.D * fixedZBelowPlane.D * planetModel.inverseCSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          final GeoPoint[] ZIntersectionsY = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedYPlane);\n          for (final GeoPoint p : ZIntersectionsY) {\n            // Travel would be in XY plane (fixed z) then in XZ (fixed y)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.x - p.x;\n            final double tpDelta2 = testPoint.z - p.z;\n            final double cpDelta1 = y - p.y;\n            final double cpDelta2 = x - p.x;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n            //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.y - p.y);\n            if (newDistance < bestDistance) {\n              bestDistance = newDistance;\n              firstLegValue = testPoint.y;\n              secondLegValue = z;\n              firstLegPlane = testPointFixedYPlane;\n              firstLegAbovePlane = testPointFixedYAbovePlane;\n              firstLegBelowPlane = testPointFixedYBelowPlane;\n              secondLegPlane = travelPlaneFixedZ;\n              secondLegAbovePlane = fixedZAbovePlane;\n              secondLegBelowPlane = fixedZBelowPlane;\n              firstLegTree = yTree;\n              secondLegTree = zTree;\n              intersectionPoint = p;\n            }\n          }\n        }\n      }\n\n      assert bestDistance > 0.0 : \"Best distance should not be zero unless on single plane\";\n      assert bestDistance < Double.POSITIVE_INFINITY : \"Couldn't find an intersection point of any kind\";\n      \n      final DualCrossingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(firstLegPlane, firstLegAbovePlane, firstLegBelowPlane, secondLegPlane, secondLegAbovePlane, secondLegBelowPlane, x, y, z, intersectionPoint);\n      if (!firstLegTree.traverse(edgeIterator, firstLegValue)) {\n        return true;\n      }\n      //edgeIterator.setSecondLeg();\n      if (!secondLegTree.traverse(edgeIterator, secondLegValue)) {\n        return true;\n      }\n      //System.out.println(\"Polarity vs. test point: \"+(((edgeIterator.getCrossingCount()  & 1) == 0)?\"same\":\"different\")+\"; testPointInSet: \"+testPointInSet);\n      return ((edgeIterator.getCrossingCount()  & 1) == 0)?testPointInSet:!testPointInSet;\n\n    }\n  }\n\n","sourceOld":"  @Override\n  public boolean isWithin(final double x, final double y, final double z) {\n    //System.out.println(\"\\nIswithin called for [\"+x+\",\"+y+\",\"+z+\"]\");\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(x, y, z)) {\n      return testPointInSet;\n    }\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && testPointFixedYPlane.evaluateIsZero(x, y, z)) {\n      // Use the XZ plane exclusively.\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      if (!yTree.traverse(crossingEdgeIterator, testPoint.y)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && testPointFixedXPlane.evaluateIsZero(x, y, z)) {\n      // Use the YZ plane exclusively.\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      if (!xTree.traverse(crossingEdgeIterator, testPoint.x)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && testPointFixedZPlane.evaluateIsZero(x, y, z)) {\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!zTree.traverse(crossingEdgeIterator, testPoint.z)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedYPlane.evaluateIsZero(x, y, z) || testPointFixedXPlane.evaluateIsZero(x, y, z) || testPointFixedZPlane.evaluateIsZero(x, y, z)) {\n      throw new IllegalArgumentException(\"Can't compute isWithin for specified point\");\n    } else {\n\n      // This is the expensive part!!\n      // Changing the code below has an enormous impact on the queries per second we see with the benchmark.\n      \n      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.\n      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -x);\n      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -y);\n      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -z);\n\n      Plane fixedYAbovePlane = new Plane(travelPlaneFixedY, true);\n      if (fixedYAbovePlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumYValue() - fixedYAbovePlane.D > NEAR_EDGE_CUTOFF) {\n          fixedYAbovePlane = null;\n      }\n      \n      Plane fixedYBelowPlane = new Plane(travelPlaneFixedY, false);\n      if (fixedYBelowPlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumYValue() - fixedYBelowPlane.D > NEAR_EDGE_CUTOFF) {\n          fixedYBelowPlane = null;\n      }\n      \n      Plane fixedXAbovePlane = new Plane(travelPlaneFixedX, true);\n      if (fixedXAbovePlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() - fixedXAbovePlane.D > NEAR_EDGE_CUTOFF) {\n          fixedXAbovePlane = null;\n      }\n      \n      Plane fixedXBelowPlane = new Plane(travelPlaneFixedX, false);\n      if (fixedXBelowPlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() - fixedXBelowPlane.D > NEAR_EDGE_CUTOFF) {\n          fixedXBelowPlane = null;\n      }\n      \n      Plane fixedZAbovePlane = new Plane(travelPlaneFixedZ, true);\n      if (fixedZAbovePlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumZValue() - fixedZAbovePlane.D > NEAR_EDGE_CUTOFF) {\n          fixedZAbovePlane = null;\n      }\n      \n      Plane fixedZBelowPlane = new Plane(travelPlaneFixedZ, false);\n      if (fixedZBelowPlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumZValue() - fixedZBelowPlane.D > NEAR_EDGE_CUTOFF) {\n          fixedZBelowPlane = null;\n      }\n\n      // Find the intersection points for each one of these and the complementary test point planes.\n\n      // There will be multiple intersection points found.  We choose the one that has the lowest total distance, as measured in delta X, delta Y, and delta Z.\n      double bestDistance = Double.POSITIVE_INFINITY;\n      double firstLegValue = 0.0;\n      double secondLegValue = 0.0;\n      Plane firstLegPlane = null;\n      Plane firstLegAbovePlane = null;\n      Plane firstLegBelowPlane = null;\n      Plane secondLegPlane = null;\n      Plane secondLegAbovePlane = null;\n      Plane secondLegBelowPlane = null;\n      Tree firstLegTree = null;\n      Tree secondLegTree = null;\n      GeoPoint intersectionPoint = null;\n\n      if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && fixedXAbovePlane != null && fixedXBelowPlane != null) {\n        final GeoPoint[] XIntersectionsY = travelPlaneFixedX.findIntersections(planetModel, testPointFixedYPlane);\n        for (final GeoPoint p : XIntersectionsY) {\n          // Travel would be in YZ plane (fixed x) then in XZ (fixed y)\n          // We compute distance we need to travel as a placeholder for the number of intersections we might encounter.\n          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n          final double tpDelta1 = testPoint.x - p.x;\n          final double tpDelta2 = testPoint.z - p.z;\n          final double cpDelta1 = y - p.y;\n          final double cpDelta2 = z - p.z;\n          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n          //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n          //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.y - p.y);\n          if (newDistance < bestDistance) {\n            bestDistance = newDistance;\n            firstLegValue = testPoint.y;\n            secondLegValue = x;\n            firstLegPlane = testPointFixedYPlane;\n            firstLegAbovePlane = testPointFixedYAbovePlane;\n            firstLegBelowPlane = testPointFixedYBelowPlane;\n            secondLegPlane = travelPlaneFixedX;\n            secondLegAbovePlane = fixedXAbovePlane;\n            secondLegBelowPlane = fixedXBelowPlane;\n            firstLegTree = yTree;\n            secondLegTree = xTree;\n            intersectionPoint = p;\n          }\n        }\n      }\n      if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && fixedXAbovePlane != null && fixedXBelowPlane != null) {\n        final GeoPoint[] XIntersectionsZ = travelPlaneFixedX.findIntersections(planetModel, testPointFixedZPlane);\n        for (final GeoPoint p : XIntersectionsZ) {\n          // Travel would be in YZ plane (fixed x) then in XY (fixed z)\n          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n          final double tpDelta1 = testPoint.x - p.x;\n          final double tpDelta2 = testPoint.y - p.y;\n          final double cpDelta1 = y - p.y;\n          final double cpDelta2 = z - p.z;\n          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n          //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n          //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.z - p.z);\n          if (newDistance < bestDistance) {\n            bestDistance = newDistance;\n            firstLegValue = testPoint.z;\n            secondLegValue = x;\n            firstLegPlane = testPointFixedZPlane;\n            firstLegAbovePlane = testPointFixedZAbovePlane;\n            firstLegBelowPlane = testPointFixedZBelowPlane;\n            secondLegPlane = travelPlaneFixedX;\n            secondLegAbovePlane = fixedXAbovePlane;\n            secondLegBelowPlane = fixedXBelowPlane;\n            firstLegTree = zTree;\n            secondLegTree = xTree;\n            intersectionPoint = p;\n          }\n        }\n      }\n      if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && fixedYAbovePlane != null && fixedYBelowPlane != null) {\n        final GeoPoint[] YIntersectionsX = travelPlaneFixedY.findIntersections(planetModel, testPointFixedXPlane);\n        for (final GeoPoint p : YIntersectionsX) {\n          // Travel would be in XZ plane (fixed y) then in YZ (fixed x)\n          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n          final double tpDelta1 = testPoint.y - p.y;\n          final double tpDelta2 = testPoint.z - p.z;\n          final double cpDelta1 = x - p.x;\n          final double cpDelta2 = z - p.z;\n          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n          //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n          //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.x - p.x);\n          if (newDistance < bestDistance) {\n            bestDistance = newDistance;\n            firstLegValue = testPoint.x;\n            secondLegValue = y;\n            firstLegPlane = testPointFixedXPlane;\n            firstLegAbovePlane = testPointFixedXAbovePlane;\n            firstLegBelowPlane = testPointFixedXBelowPlane;\n            secondLegPlane = travelPlaneFixedY;\n            secondLegAbovePlane = fixedYAbovePlane;\n            secondLegBelowPlane = fixedYBelowPlane;\n            firstLegTree = xTree;\n            secondLegTree = yTree;\n            intersectionPoint = p;\n          }\n        }\n      }\n      if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && fixedYAbovePlane != null && fixedYBelowPlane != null) {\n        final GeoPoint[] YIntersectionsZ = travelPlaneFixedY.findIntersections(planetModel, testPointFixedZPlane);\n        for (final GeoPoint p : YIntersectionsZ) {\n          // Travel would be in XZ plane (fixed y) then in XY (fixed z)\n          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n          final double tpDelta1 = testPoint.x - p.x;\n          final double tpDelta2 = testPoint.y - p.y;\n          final double cpDelta1 = x - p.x;\n          final double cpDelta2 = z - p.z;\n          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n          //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n          //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.z - p.z);\n          if (newDistance < bestDistance) {\n            bestDistance = newDistance;\n            firstLegValue = testPoint.z;\n            secondLegValue = y;\n            firstLegPlane = testPointFixedZPlane;\n            firstLegAbovePlane = testPointFixedZAbovePlane;\n            firstLegBelowPlane = testPointFixedZBelowPlane;\n            secondLegPlane = travelPlaneFixedY;\n            secondLegAbovePlane = fixedYAbovePlane;\n            secondLegBelowPlane = fixedYBelowPlane;\n            firstLegTree = zTree;\n            secondLegTree = yTree;\n            intersectionPoint = p;\n          }\n        }\n      }\n      if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && fixedZAbovePlane != null && fixedZBelowPlane != null) {\n        final GeoPoint[] ZIntersectionsX = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedXPlane);\n        for (final GeoPoint p : ZIntersectionsX) {\n          // Travel would be in XY plane (fixed z) then in YZ (fixed x)\n          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n          final double tpDelta1 = testPoint.y - p.y;\n          final double tpDelta2 = testPoint.z - p.z;\n          final double cpDelta1 = y - p.y;\n          final double cpDelta2 = x - p.x;\n          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n          //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n          //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.x - p.x);\n          if (newDistance < bestDistance) {\n            bestDistance = newDistance;\n            firstLegValue = testPoint.x;\n            secondLegValue = z;\n            firstLegPlane = testPointFixedXPlane;\n            firstLegAbovePlane = testPointFixedXAbovePlane;\n            firstLegBelowPlane = testPointFixedXBelowPlane;\n            secondLegPlane = travelPlaneFixedZ;\n            secondLegAbovePlane = fixedZAbovePlane;\n            secondLegBelowPlane = fixedZBelowPlane;\n            firstLegTree = xTree;\n            secondLegTree = zTree;\n            intersectionPoint = p;\n          }\n        }\n      }\n      if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && fixedZAbovePlane != null && fixedZBelowPlane != null) {\n        final GeoPoint[] ZIntersectionsY = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedYPlane);\n        for (final GeoPoint p : ZIntersectionsY) {\n          // Travel would be in XY plane (fixed z) then in XZ (fixed y)\n          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n          final double tpDelta1 = testPoint.x - p.x;\n          final double tpDelta2 = testPoint.z - p.z;\n          final double cpDelta1 = y - p.y;\n          final double cpDelta2 = x - p.x;\n          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n          //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n          //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.y - p.y);\n          if (newDistance < bestDistance) {\n            bestDistance = newDistance;\n            firstLegValue = testPoint.y;\n            secondLegValue = z;\n            firstLegPlane = testPointFixedYPlane;\n            firstLegAbovePlane = testPointFixedYAbovePlane;\n            firstLegBelowPlane = testPointFixedYBelowPlane;\n            secondLegPlane = travelPlaneFixedZ;\n            secondLegAbovePlane = fixedZAbovePlane;\n            secondLegBelowPlane = fixedZBelowPlane;\n            firstLegTree = yTree;\n            secondLegTree = zTree;\n            intersectionPoint = p;\n          }\n        }\n      }\n\n      assert bestDistance > 0.0 : \"Best distance should not be zero unless on single plane\";\n      assert bestDistance < Double.POSITIVE_INFINITY : \"Couldn't find an intersection point of any kind\";\n      \n      final DualCrossingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(firstLegPlane, firstLegAbovePlane, firstLegBelowPlane, secondLegPlane, secondLegAbovePlane, secondLegBelowPlane, x, y, z, intersectionPoint);\n      if (!firstLegTree.traverse(edgeIterator, firstLegValue)) {\n        return true;\n      }\n      //edgeIterator.setSecondLeg();\n      if (!secondLegTree.traverse(edgeIterator, secondLegValue)) {\n        return true;\n      }\n      //System.out.println(\"Polarity vs. test point: \"+(((edgeIterator.getCrossingCount()  & 1) == 0)?\"same\":\"different\")+\"; testPointInSet: \"+testPointInSet);\n      return ((edgeIterator.getCrossingCount()  & 1) == 0)?testPointInSet:!testPointInSet;\n\n    }\n  }\n\n","bugFix":["d3c9c955664ed32e2bf97b3da26467354673ea18"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"039615f2ceafe5881c61222281f45a0631b90174","date":1524725949,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(double,double,double).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(double,double,double).mjava","sourceNew":"  @Override\n  public boolean isWithin(final double x, final double y, final double z) {\n    try {\n      // Try with the primary test point\n      return isInSet(x, y, z,\n        testPoint1,\n        testPoint1InSet,\n        testPoint1FixedXPlane, testPoint1FixedXAbovePlane, testPoint1FixedXBelowPlane,\n        testPoint1FixedYPlane, testPoint1FixedYAbovePlane, testPoint1FixedYBelowPlane,\n        testPoint1FixedZPlane, testPoint1FixedZAbovePlane, testPoint1FixedZBelowPlane);\n    } catch (IllegalArgumentException e) {\n      // Try with an alternate test point\n      return isInSet(x, y, z,\n        testPoint2,\n        testPoint2InSet,\n        testPoint2FixedXPlane, testPoint2FixedXAbovePlane, testPoint2FixedXBelowPlane,\n        testPoint2FixedYPlane, testPoint2FixedYAbovePlane, testPoint2FixedYBelowPlane,\n        testPoint2FixedZPlane, testPoint2FixedZAbovePlane, testPoint2FixedZBelowPlane);\n    }\n  }\n\n","sourceOld":"  @Override\n  public boolean isWithin(final double x, final double y, final double z) {\n    //System.out.println(\"\\nIswithin called for [\"+x+\",\"+y+\",\"+z+\"]\");\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(x, y, z)) {\n      return testPointInSet;\n    }\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && testPointFixedYPlane.evaluateIsZero(x, y, z)) {\n      // Use the XZ plane exclusively.\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      if (!yTree.traverse(crossingEdgeIterator, testPoint.y)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && testPointFixedXPlane.evaluateIsZero(x, y, z)) {\n      // Use the YZ plane exclusively.\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      if (!xTree.traverse(crossingEdgeIterator, testPoint.x)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && testPointFixedZPlane.evaluateIsZero(x, y, z)) {\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!zTree.traverse(crossingEdgeIterator, testPoint.z)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedYPlane.evaluateIsZero(x, y, z) || testPointFixedXPlane.evaluateIsZero(x, y, z) || testPointFixedZPlane.evaluateIsZero(x, y, z)) {\n      throw new IllegalArgumentException(\"Can't compute isWithin for specified point\");\n    } else {\n\n      // This is the expensive part!!\n      // Changing the code below has an enormous impact on the queries per second we see with the benchmark.\n      \n      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.\n      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -x);\n      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -y);\n      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -z);\n\n      Plane fixedYAbovePlane = new Plane(travelPlaneFixedY, true);\n      if (fixedYAbovePlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumYValue() - fixedYAbovePlane.D > NEAR_EDGE_CUTOFF) {\n          fixedYAbovePlane = null;\n      }\n      \n      Plane fixedYBelowPlane = new Plane(travelPlaneFixedY, false);\n      if (fixedYBelowPlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumYValue() - fixedYBelowPlane.D > NEAR_EDGE_CUTOFF) {\n          fixedYBelowPlane = null;\n      }\n      \n      Plane fixedXAbovePlane = new Plane(travelPlaneFixedX, true);\n      if (fixedXAbovePlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() - fixedXAbovePlane.D > NEAR_EDGE_CUTOFF) {\n          fixedXAbovePlane = null;\n      }\n      \n      Plane fixedXBelowPlane = new Plane(travelPlaneFixedX, false);\n      if (fixedXBelowPlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() - fixedXBelowPlane.D > NEAR_EDGE_CUTOFF) {\n          fixedXBelowPlane = null;\n      }\n      \n      Plane fixedZAbovePlane = new Plane(travelPlaneFixedZ, true);\n      if (fixedZAbovePlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumZValue() - fixedZAbovePlane.D > NEAR_EDGE_CUTOFF) {\n          fixedZAbovePlane = null;\n      }\n      \n      Plane fixedZBelowPlane = new Plane(travelPlaneFixedZ, false);\n      if (fixedZBelowPlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumZValue() - fixedZBelowPlane.D > NEAR_EDGE_CUTOFF) {\n          fixedZBelowPlane = null;\n      }\n\n      // Find the intersection points for each one of these and the complementary test point planes.\n\n      // There will be multiple intersection points found.  We choose the one that has the lowest total distance, as measured in delta X, delta Y, and delta Z.\n      double bestDistance = Double.POSITIVE_INFINITY;\n      double firstLegValue = 0.0;\n      double secondLegValue = 0.0;\n      Plane firstLegPlane = null;\n      Plane firstLegAbovePlane = null;\n      Plane firstLegBelowPlane = null;\n      Plane secondLegPlane = null;\n      Plane secondLegAbovePlane = null;\n      Plane secondLegBelowPlane = null;\n      Tree firstLegTree = null;\n      Tree secondLegTree = null;\n      GeoPoint intersectionPoint = null;\n\n      if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && fixedXAbovePlane != null && fixedXBelowPlane != null) {\n        //check if planes intersects  inside world\n        final double checkAbove = 4.0 * (fixedXAbovePlane.D * fixedXAbovePlane.D * planetModel.inverseAbSquared + testPointFixedYAbovePlane.D * testPointFixedYAbovePlane.D * planetModel.inverseAbSquared - 1.0);\n        final double checkBelow = 4.0 * (fixedXBelowPlane.D * fixedXBelowPlane.D * planetModel.inverseAbSquared + testPointFixedYBelowPlane.D * testPointFixedYBelowPlane.D * planetModel.inverseAbSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          final GeoPoint[] XIntersectionsY = travelPlaneFixedX.findIntersections(planetModel, testPointFixedYPlane);\n          for (final GeoPoint p : XIntersectionsY) {\n            // Travel would be in YZ plane (fixed x) then in XZ (fixed y)\n            // We compute distance we need to travel as a placeholder for the number of intersections we might encounter.\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.x - p.x;\n            final double tpDelta2 = testPoint.z - p.z;\n            final double cpDelta1 = y - p.y;\n            final double cpDelta2 = z - p.z;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n            //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.y - p.y);\n            if (newDistance < bestDistance) {\n              bestDistance = newDistance;\n              firstLegValue = testPoint.y;\n              secondLegValue = x;\n              firstLegPlane = testPointFixedYPlane;\n              firstLegAbovePlane = testPointFixedYAbovePlane;\n              firstLegBelowPlane = testPointFixedYBelowPlane;\n              secondLegPlane = travelPlaneFixedX;\n              secondLegAbovePlane = fixedXAbovePlane;\n              secondLegBelowPlane = fixedXBelowPlane;\n              firstLegTree = yTree;\n              secondLegTree = xTree;\n              intersectionPoint = p;\n            }\n          }\n        }\n      }\n      if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && fixedXAbovePlane != null && fixedXBelowPlane != null) {\n        //check if planes intersects  inside world\n        final double checkAbove = 4.0 * (fixedXAbovePlane.D * fixedXAbovePlane.D * planetModel.inverseAbSquared + testPointFixedZAbovePlane.D * testPointFixedZAbovePlane.D * planetModel.inverseCSquared - 1.0);\n        final double checkBelow = 4.0 * (fixedXBelowPlane.D * fixedXBelowPlane.D * planetModel.inverseAbSquared + testPointFixedZBelowPlane.D * testPointFixedZBelowPlane.D * planetModel.inverseCSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          final GeoPoint[] XIntersectionsZ = travelPlaneFixedX.findIntersections(planetModel, testPointFixedZPlane);\n          for (final GeoPoint p : XIntersectionsZ) {\n            // Travel would be in YZ plane (fixed x) then in XY (fixed z)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.x - p.x;\n            final double tpDelta2 = testPoint.y - p.y;\n            final double cpDelta1 = y - p.y;\n            final double cpDelta2 = z - p.z;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n            //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.z - p.z);\n            if (newDistance < bestDistance) {\n              bestDistance = newDistance;\n              firstLegValue = testPoint.z;\n              secondLegValue = x;\n              firstLegPlane = testPointFixedZPlane;\n              firstLegAbovePlane = testPointFixedZAbovePlane;\n              firstLegBelowPlane = testPointFixedZBelowPlane;\n              secondLegPlane = travelPlaneFixedX;\n              secondLegAbovePlane = fixedXAbovePlane;\n              secondLegBelowPlane = fixedXBelowPlane;\n              firstLegTree = zTree;\n              secondLegTree = xTree;\n              intersectionPoint = p;\n            }\n          }\n        }\n      }\n      if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && fixedYAbovePlane != null && fixedYBelowPlane != null) {\n        //check if planes intersects inside world\n        final double checkAbove = 4.0 * (testPointFixedXAbovePlane.D * testPointFixedXAbovePlane.D * planetModel.inverseAbSquared + fixedYAbovePlane.D * fixedYAbovePlane.D * planetModel.inverseAbSquared - 1.0);\n        final double checkBelow = 4.0 * (testPointFixedXBelowPlane.D * testPointFixedXBelowPlane.D * planetModel.inverseAbSquared + fixedYBelowPlane.D * fixedYBelowPlane.D * planetModel.inverseAbSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          final GeoPoint[] YIntersectionsX = travelPlaneFixedY.findIntersections(planetModel, testPointFixedXPlane);\n          for (final GeoPoint p : YIntersectionsX) {\n            // Travel would be in XZ plane (fixed y) then in YZ (fixed x)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.y - p.y;\n            final double tpDelta2 = testPoint.z - p.z;\n            final double cpDelta1 = x - p.x;\n            final double cpDelta2 = z - p.z;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n            //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.x - p.x);\n            if (newDistance < bestDistance) {\n              bestDistance = newDistance;\n              firstLegValue = testPoint.x;\n              secondLegValue = y;\n              firstLegPlane = testPointFixedXPlane;\n              firstLegAbovePlane = testPointFixedXAbovePlane;\n              firstLegBelowPlane = testPointFixedXBelowPlane;\n              secondLegPlane = travelPlaneFixedY;\n              secondLegAbovePlane = fixedYAbovePlane;\n              secondLegBelowPlane = fixedYBelowPlane;\n              firstLegTree = xTree;\n              secondLegTree = yTree;\n              intersectionPoint = p;\n            }\n          }\n        }\n      }\n      if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && fixedYAbovePlane != null && fixedYBelowPlane != null) {\n        //check if planes intersects inside world\n        final double checkAbove = 4.0 * (testPointFixedZAbovePlane.D * testPointFixedZAbovePlane.D * planetModel.inverseCSquared + fixedYAbovePlane.D * fixedYAbovePlane.D * planetModel.inverseAbSquared - 1.0);\n        final double checkBelow = 4.0 * (testPointFixedZBelowPlane.D * testPointFixedZBelowPlane.D * planetModel.inverseCSquared + fixedYBelowPlane.D * fixedYBelowPlane.D * planetModel.inverseAbSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          final GeoPoint[] YIntersectionsZ = travelPlaneFixedY.findIntersections(planetModel, testPointFixedZPlane);\n          for (final GeoPoint p : YIntersectionsZ) {\n            // Travel would be in XZ plane (fixed y) then in XY (fixed z)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.x - p.x;\n            final double tpDelta2 = testPoint.y - p.y;\n            final double cpDelta1 = x - p.x;\n            final double cpDelta2 = z - p.z;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n            //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.z - p.z);\n            if (newDistance < bestDistance) {\n              bestDistance = newDistance;\n              firstLegValue = testPoint.z;\n              secondLegValue = y;\n              firstLegPlane = testPointFixedZPlane;\n              firstLegAbovePlane = testPointFixedZAbovePlane;\n              firstLegBelowPlane = testPointFixedZBelowPlane;\n              secondLegPlane = travelPlaneFixedY;\n              secondLegAbovePlane = fixedYAbovePlane;\n              secondLegBelowPlane = fixedYBelowPlane;\n              firstLegTree = zTree;\n              secondLegTree = yTree;\n              intersectionPoint = p;\n            }\n          }\n        }\n      }\n      if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && fixedZAbovePlane != null && fixedZBelowPlane != null) {\n        //check if planes intersects inside world\n        final double checkAbove = 4.0 * (testPointFixedXAbovePlane.D * testPointFixedXAbovePlane.D * planetModel.inverseAbSquared + fixedZAbovePlane.D * fixedZAbovePlane.D * planetModel.inverseCSquared - 1.0);\n        final double checkBelow = 4.0 * (testPointFixedXBelowPlane.D * testPointFixedXBelowPlane.D * planetModel.inverseAbSquared + fixedZBelowPlane.D * fixedZBelowPlane.D * planetModel.inverseCSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          final GeoPoint[] ZIntersectionsX = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedXPlane);\n          for (final GeoPoint p : ZIntersectionsX) {\n            // Travel would be in XY plane (fixed z) then in YZ (fixed x)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.y - p.y;\n            final double tpDelta2 = testPoint.z - p.z;\n            final double cpDelta1 = y - p.y;\n            final double cpDelta2 = x - p.x;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n            //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.x - p.x);\n            if (newDistance < bestDistance) {\n              bestDistance = newDistance;\n              firstLegValue = testPoint.x;\n              secondLegValue = z;\n              firstLegPlane = testPointFixedXPlane;\n              firstLegAbovePlane = testPointFixedXAbovePlane;\n              firstLegBelowPlane = testPointFixedXBelowPlane;\n              secondLegPlane = travelPlaneFixedZ;\n              secondLegAbovePlane = fixedZAbovePlane;\n              secondLegBelowPlane = fixedZBelowPlane;\n              firstLegTree = xTree;\n              secondLegTree = zTree;\n              intersectionPoint = p;\n            }\n          }\n        }\n      }\n      if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && fixedZAbovePlane != null && fixedZBelowPlane != null) {\n        //check if planes intersects inside world\n        final double checkAbove = 4.0 * (testPointFixedYAbovePlane.D * testPointFixedYAbovePlane.D * planetModel.inverseAbSquared + fixedZAbovePlane.D * fixedZAbovePlane.D * planetModel.inverseCSquared - 1.0);\n        final double checkBelow = 4.0 * (testPointFixedYBelowPlane.D * testPointFixedYBelowPlane.D * planetModel.inverseAbSquared + fixedZBelowPlane.D * fixedZBelowPlane.D * planetModel.inverseCSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          final GeoPoint[] ZIntersectionsY = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedYPlane);\n          for (final GeoPoint p : ZIntersectionsY) {\n            // Travel would be in XY plane (fixed z) then in XZ (fixed y)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.x - p.x;\n            final double tpDelta2 = testPoint.z - p.z;\n            final double cpDelta1 = y - p.y;\n            final double cpDelta2 = x - p.x;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n            //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.y - p.y);\n            if (newDistance < bestDistance) {\n              bestDistance = newDistance;\n              firstLegValue = testPoint.y;\n              secondLegValue = z;\n              firstLegPlane = testPointFixedYPlane;\n              firstLegAbovePlane = testPointFixedYAbovePlane;\n              firstLegBelowPlane = testPointFixedYBelowPlane;\n              secondLegPlane = travelPlaneFixedZ;\n              secondLegAbovePlane = fixedZAbovePlane;\n              secondLegBelowPlane = fixedZBelowPlane;\n              firstLegTree = yTree;\n              secondLegTree = zTree;\n              intersectionPoint = p;\n            }\n          }\n        }\n      }\n\n      assert bestDistance > 0.0 : \"Best distance should not be zero unless on single plane\";\n      assert bestDistance < Double.POSITIVE_INFINITY : \"Couldn't find an intersection point of any kind\";\n      \n      final DualCrossingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(firstLegPlane, firstLegAbovePlane, firstLegBelowPlane, secondLegPlane, secondLegAbovePlane, secondLegBelowPlane, x, y, z, intersectionPoint);\n      if (!firstLegTree.traverse(edgeIterator, firstLegValue)) {\n        return true;\n      }\n      //edgeIterator.setSecondLeg();\n      if (!secondLegTree.traverse(edgeIterator, secondLegValue)) {\n        return true;\n      }\n      //System.out.println(\"Polarity vs. test point: \"+(((edgeIterator.getCrossingCount()  & 1) == 0)?\"same\":\"different\")+\"; testPointInSet: \"+testPointInSet);\n      return ((edgeIterator.getCrossingCount()  & 1) == 0)?testPointInSet:!testPointInSet;\n\n    }\n  }\n\n","bugFix":null,"bugIntro":["824fea352f6fabb3a66e7d4df5c72c2ff9511359"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d1ddb4f16cfdfa4f6fa9349fb90d48b0f1e6f040","date":1524832766,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(double,double,double).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(double,double,double).mjava","sourceNew":"  @Override\n  public boolean isWithin(final double x, final double y, final double z) {\n    //System.out.println(\"IsWithin() for [\"+x+\",\"+y+\",\"+z+\"]\");\n    try {\n      // Try with the primary test point\n      //if (true) throw new IllegalArgumentException(\"use second point as exercise\");\n      //System.out.println(\" Trying testPoint1...\");\n      return isInSet(x, y, z,\n        testPoint1,\n        testPoint1InSet,\n        testPoint1FixedXPlane, testPoint1FixedXAbovePlane, testPoint1FixedXBelowPlane,\n        testPoint1FixedYPlane, testPoint1FixedYAbovePlane, testPoint1FixedYBelowPlane,\n        testPoint1FixedZPlane, testPoint1FixedZAbovePlane, testPoint1FixedZBelowPlane);\n    } catch (IllegalArgumentException e) {\n      // Try with an alternate test point\n      //e.printStackTrace(System.out);\n      //System.out.println(\" Trying testPoint2...\");\n      return isInSet(x, y, z,\n        testPoint2,\n        testPoint2InSet,\n        testPoint2FixedXPlane, testPoint2FixedXAbovePlane, testPoint2FixedXBelowPlane,\n        testPoint2FixedYPlane, testPoint2FixedYAbovePlane, testPoint2FixedYBelowPlane,\n        testPoint2FixedZPlane, testPoint2FixedZAbovePlane, testPoint2FixedZBelowPlane);\n    }\n  }\n\n","sourceOld":"  @Override\n  public boolean isWithin(final double x, final double y, final double z) {\n    try {\n      // Try with the primary test point\n      return isInSet(x, y, z,\n        testPoint1,\n        testPoint1InSet,\n        testPoint1FixedXPlane, testPoint1FixedXAbovePlane, testPoint1FixedXBelowPlane,\n        testPoint1FixedYPlane, testPoint1FixedYAbovePlane, testPoint1FixedYBelowPlane,\n        testPoint1FixedZPlane, testPoint1FixedZAbovePlane, testPoint1FixedZBelowPlane);\n    } catch (IllegalArgumentException e) {\n      // Try with an alternate test point\n      return isInSet(x, y, z,\n        testPoint2,\n        testPoint2InSet,\n        testPoint2FixedXPlane, testPoint2FixedXAbovePlane, testPoint2FixedXBelowPlane,\n        testPoint2FixedYPlane, testPoint2FixedYAbovePlane, testPoint2FixedYBelowPlane,\n        testPoint2FixedZPlane, testPoint2FixedZAbovePlane, testPoint2FixedZBelowPlane);\n    }\n  }\n\n","bugFix":null,"bugIntro":["824fea352f6fabb3a66e7d4df5c72c2ff9511359"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"824fea352f6fabb3a66e7d4df5c72c2ff9511359","date":1537699526,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(double,double,double).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isWithin(double,double,double).mjava","sourceNew":"  @Override\n  public boolean isWithin(final double x, final double y, final double z) {\n    //System.out.println(\"IsWithin() for [\"+x+\",\"+y+\",\"+z+\"]\");\n    return isInSet(x, y, z,\n      testPoint1,\n      testPoint1InSet,\n      testPoint1FixedXPlane, testPoint1FixedXAbovePlane, testPoint1FixedXBelowPlane,\n      testPoint1FixedYPlane, testPoint1FixedYAbovePlane, testPoint1FixedYBelowPlane,\n      testPoint1FixedZPlane, testPoint1FixedZAbovePlane, testPoint1FixedZBelowPlane);\n  }\n\n","sourceOld":"  @Override\n  public boolean isWithin(final double x, final double y, final double z) {\n    //System.out.println(\"IsWithin() for [\"+x+\",\"+y+\",\"+z+\"]\");\n    try {\n      // Try with the primary test point\n      //if (true) throw new IllegalArgumentException(\"use second point as exercise\");\n      //System.out.println(\" Trying testPoint1...\");\n      return isInSet(x, y, z,\n        testPoint1,\n        testPoint1InSet,\n        testPoint1FixedXPlane, testPoint1FixedXAbovePlane, testPoint1FixedXBelowPlane,\n        testPoint1FixedYPlane, testPoint1FixedYAbovePlane, testPoint1FixedYBelowPlane,\n        testPoint1FixedZPlane, testPoint1FixedZAbovePlane, testPoint1FixedZBelowPlane);\n    } catch (IllegalArgumentException e) {\n      // Try with an alternate test point\n      //e.printStackTrace(System.out);\n      //System.out.println(\" Trying testPoint2...\");\n      return isInSet(x, y, z,\n        testPoint2,\n        testPoint2InSet,\n        testPoint2FixedXPlane, testPoint2FixedXAbovePlane, testPoint2FixedXBelowPlane,\n        testPoint2FixedYPlane, testPoint2FixedYAbovePlane, testPoint2FixedYBelowPlane,\n        testPoint2FixedZPlane, testPoint2FixedZAbovePlane, testPoint2FixedZBelowPlane);\n    }\n  }\n\n","bugFix":["d1ddb4f16cfdfa4f6fa9349fb90d48b0f1e6f040","039615f2ceafe5881c61222281f45a0631b90174","7fe41964e49958f662028ea7ed8c224e0955edae"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"8b879b14da40ab73551b75835099a61e622a83d3":["1e7090fb56105afb6515b6506724359c32ec7639"],"1e7090fb56105afb6515b6506724359c32ec7639":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"a31f543c55a8dd122ed8676510a9c6d8000fa214":["e872ee16caf3bf386b6a55f3654fabb2840d8fc9"],"09149ac46adf9772db58c67d18f37b1c5e109b34":["33861a7dcb2e09155c04cd7507f0ab74d5d102b6"],"d1ddb4f16cfdfa4f6fa9349fb90d48b0f1e6f040":["039615f2ceafe5881c61222281f45a0631b90174"],"e872ee16caf3bf386b6a55f3654fabb2840d8fc9":["b69c4d16cfa7d88d9a2ae23fdd1790a8d412a1b6"],"039615f2ceafe5881c61222281f45a0631b90174":["46e2380a7b2f7e3b199fffe1179d745d5c289227"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["55b50463286869f584cf849d1587a0fcd54d1dfa","d470c8182e92b264680e34081b75e70a9f2b3c89"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["7fe41964e49958f662028ea7ed8c224e0955edae","ae0a2a645db6ae8e4aca176aefd05f400689d2f4"],"55b50463286869f584cf849d1587a0fcd54d1dfa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c46db27f3364a67a1c77a0f4e462cc7c5b4147f0"],"33861a7dcb2e09155c04cd7507f0ab74d5d102b6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d3c9c955664ed32e2bf97b3da26467354673ea18":["8b879b14da40ab73551b75835099a61e622a83d3"],"b69c4d16cfa7d88d9a2ae23fdd1790a8d412a1b6":["d3c9c955664ed32e2bf97b3da26467354673ea18"],"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904":["c46db27f3364a67a1c77a0f4e462cc7c5b4147f0","7fe41964e49958f662028ea7ed8c224e0955edae"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"46e2380a7b2f7e3b199fffe1179d745d5c289227":["a31f543c55a8dd122ed8676510a9c6d8000fa214"],"c46db27f3364a67a1c77a0f4e462cc7c5b4147f0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","116824c1b3f14f43f9a77914fbf6f0d70a5b7c89"],"824fea352f6fabb3a66e7d4df5c72c2ff9511359":["d1ddb4f16cfdfa4f6fa9349fb90d48b0f1e6f040"],"7fe41964e49958f662028ea7ed8c224e0955edae":["c46db27f3364a67a1c77a0f4e462cc7c5b4147f0"],"116824c1b3f14f43f9a77914fbf6f0d70a5b7c89":["09149ac46adf9772db58c67d18f37b1c5e109b34"],"ae0a2a645db6ae8e4aca176aefd05f400689d2f4":["7fe41964e49958f662028ea7ed8c224e0955edae"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["824fea352f6fabb3a66e7d4df5c72c2ff9511359"]},"commit2Childs":{"8b879b14da40ab73551b75835099a61e622a83d3":["d3c9c955664ed32e2bf97b3da26467354673ea18"],"1e7090fb56105afb6515b6506724359c32ec7639":["8b879b14da40ab73551b75835099a61e622a83d3"],"a31f543c55a8dd122ed8676510a9c6d8000fa214":["46e2380a7b2f7e3b199fffe1179d745d5c289227"],"09149ac46adf9772db58c67d18f37b1c5e109b34":["116824c1b3f14f43f9a77914fbf6f0d70a5b7c89"],"d1ddb4f16cfdfa4f6fa9349fb90d48b0f1e6f040":["824fea352f6fabb3a66e7d4df5c72c2ff9511359"],"e872ee16caf3bf386b6a55f3654fabb2840d8fc9":["a31f543c55a8dd122ed8676510a9c6d8000fa214"],"039615f2ceafe5881c61222281f45a0631b90174":["d1ddb4f16cfdfa4f6fa9349fb90d48b0f1e6f040"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"d470c8182e92b264680e34081b75e70a9f2b3c89":["1e7090fb56105afb6515b6506724359c32ec7639","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"55b50463286869f584cf849d1587a0fcd54d1dfa":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"33861a7dcb2e09155c04cd7507f0ab74d5d102b6":["09149ac46adf9772db58c67d18f37b1c5e109b34"],"d3c9c955664ed32e2bf97b3da26467354673ea18":["b69c4d16cfa7d88d9a2ae23fdd1790a8d412a1b6"],"b69c4d16cfa7d88d9a2ae23fdd1790a8d412a1b6":["e872ee16caf3bf386b6a55f3654fabb2840d8fc9"],"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["55b50463286869f584cf849d1587a0fcd54d1dfa","33861a7dcb2e09155c04cd7507f0ab74d5d102b6","c46db27f3364a67a1c77a0f4e462cc7c5b4147f0"],"46e2380a7b2f7e3b199fffe1179d745d5c289227":["039615f2ceafe5881c61222281f45a0631b90174"],"c46db27f3364a67a1c77a0f4e462cc7c5b4147f0":["55b50463286869f584cf849d1587a0fcd54d1dfa","a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","7fe41964e49958f662028ea7ed8c224e0955edae"],"7fe41964e49958f662028ea7ed8c224e0955edae":["d470c8182e92b264680e34081b75e70a9f2b3c89","a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","ae0a2a645db6ae8e4aca176aefd05f400689d2f4"],"824fea352f6fabb3a66e7d4df5c72c2ff9511359":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"116824c1b3f14f43f9a77914fbf6f0d70a5b7c89":["c46db27f3364a67a1c77a0f4e462cc7c5b4147f0"],"ae0a2a645db6ae8e4aca176aefd05f400689d2f4":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}