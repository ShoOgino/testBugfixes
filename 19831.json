{"path":"src/test/org/apache/lucene/index/TermInfosTest#test().mjava","commits":[{"id":"e0b950aef8cdf4606d480e28ea17bd870b93c81e","date":1060680143,"type":0,"author":"Erik Hatcher","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/TermInfosTest#test().mjava","pathOld":"/dev/null","sourceNew":"  // FIXME: OG: remove hard-coded file names\n  public static void test()\n       throws Exception {\n\n    File file = new File(\"words.txt\");\n    System.out.println(\" reading word file containing \" +\n\t\t       file.length() + \" bytes\");\n\n    Date start = new Date();\n\n    Vector keys = new Vector();\n    FileInputStream ws = new FileInputStream(file);\n    BufferedReader wr = new BufferedReader(new InputStreamReader(ws));\n\n    for (String key = wr.readLine(); key!=null; key = wr.readLine())\n      keys.addElement(new Term(\"word\", key));\n    wr.close();\n\n    Date end = new Date();\n\n    System.out.print(end.getTime() - start.getTime());\n    System.out.println(\" milliseconds to read \" + keys.size() + \" words\");\n\n    start = new Date();\n\n    Random gen = new Random(1251971);\n    long fp = (gen.nextInt() & 0xF) + 1;\n    long pp = (gen.nextInt() & 0xF) + 1;\n    int[] docFreqs = new int[keys.size()];\n    long[] freqPointers = new long[keys.size()];\n    long[] proxPointers = new long[keys.size()];\n    for (int i = 0; i < keys.size(); i++) {\n      docFreqs[i] = (gen.nextInt() & 0xF) + 1;\n      freqPointers[i] = fp;\n      proxPointers[i] = pp;\n      fp += (gen.nextInt() & 0xF) + 1;;\n      pp += (gen.nextInt() & 0xF) + 1;;\n    }\n\n    end = new Date();\n\n    System.out.print(end.getTime() - start.getTime());\n    System.out.println(\" milliseconds to generate values\");\n\n    start = new Date();\n\n    Directory store = FSDirectory.getDirectory(\"test.store\", true);\n    FieldInfos fis = new FieldInfos();\n\n    TermInfosWriter writer = new TermInfosWriter(store, \"words\", fis);\n    fis.add(\"word\", false);\n\n    for (int i = 0; i < keys.size(); i++)\n      writer.add((Term)keys.elementAt(i),\n\t\t new TermInfo(docFreqs[i], freqPointers[i], proxPointers[i]));\n\n    writer.close();\n\n    end = new Date();\n\n    System.out.print(end.getTime() - start.getTime());\n    System.out.println(\" milliseconds to write table\");\n\n    System.out.println(\" table occupies \" +\n\t\t       store.fileLength(\"words.tis\") + \" bytes\");\n\n    start = new Date();\n\n    TermInfosReader reader = new TermInfosReader(store, \"words\", fis);\n\n    end = new Date();\n\n    System.out.print(end.getTime() - start.getTime());\n    System.out.println(\" milliseconds to open table\");\n\n    start = new Date();\n\n    SegmentTermEnum enumerator = reader.terms();\n    for (int i = 0; i < keys.size(); i++) {\n      enumerator.next();\n      Term key = (Term)keys.elementAt(i);\n      if (!key.equals(enumerator.term()))\n\tthrow new Exception(\"wrong term: \" + enumerator.term()\n\t\t\t    + \", expected: \" + key\n\t\t\t    + \" at \" + i);\n      TermInfo ti = enumerator.termInfo();\n      if (ti.docFreq != docFreqs[i])\n\tthrow\n\t  new Exception(\"wrong value: \" + Long.toString(ti.docFreq, 16)\n\t\t\t+ \", expected: \" + Long.toString(docFreqs[i], 16)\n\t\t\t+ \" at \" + i);\n      if (ti.freqPointer != freqPointers[i])\n\tthrow\n\t  new Exception(\"wrong value: \" + Long.toString(ti.freqPointer, 16)\n\t\t\t+ \", expected: \" + Long.toString(freqPointers[i], 16)\n\t\t\t+ \" at \" + i);\n      if (ti.proxPointer != proxPointers[i])\n\tthrow\n\t  new Exception(\"wrong value: \" + Long.toString(ti.proxPointer, 16)\n\t\t\t+ \", expected: \" + Long.toString(proxPointers[i], 16)\n\t\t\t+ \" at \" + i);\n    }\n\n    end = new Date();\n\n    System.out.print(end.getTime() - start.getTime());\n    System.out.println(\" milliseconds to iterate over \" +\n\t\t       keys.size() + \" words\");\n\n    start = new Date();\n\n    for (int i = 0; i < keys.size(); i++) {\n      Term key = (Term)keys.elementAt(i);\n      TermInfo ti = reader.get(key);\n      if (ti.docFreq != docFreqs[i])\n\tthrow\n\t  new Exception(\"wrong value: \" + Long.toString(ti.docFreq, 16)\n\t\t\t+ \", expected: \" + Long.toString(docFreqs[i], 16)\n\t\t\t+ \" at \" + i);\n      if (ti.freqPointer != freqPointers[i])\n\tthrow\n\t  new Exception(\"wrong value: \" + Long.toString(ti.freqPointer, 16)\n\t\t\t+ \", expected: \" + Long.toString(freqPointers[i], 16)\n\t\t\t+ \" at \" + i);\n      if (ti.proxPointer != proxPointers[i])\n\tthrow\n\t  new Exception(\"wrong value: \" + Long.toString(ti.proxPointer, 16)\n\t\t\t+ \", expected: \" + Long.toString(proxPointers[i], 16)\n\t\t\t+ \" at \" + i);\n    }\n\n    end = new Date();\n\n    System.out.print((end.getTime() - start.getTime()) / (float)keys.size());\n    System.out.println(\" average milliseconds per lookup\");\n\n    TermEnum e = reader.terms(new Term(\"word\", \"azz\"));\n    System.out.println(\"Word after azz is \" + e.term().text);\n\n    reader.close();\n\n    store.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d41d9416ee7cc6639348fe8fe00cbd1ac0681c10","date":1110595377,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/TermInfosTest#test().mjava","pathOld":"src/test/org/apache/lucene/index/TermInfosTest#test().mjava","sourceNew":"  // FIXME: OG: remove hard-coded file names\n  public static void test()\n       throws Exception {\n\n    File file = new File(\"words.txt\");\n    System.out.println(\" reading word file containing \" +\n\t\t       file.length() + \" bytes\");\n\n    Date start = new Date();\n\n    Vector keys = new Vector();\n    FileInputStream ws = new FileInputStream(file);\n    BufferedReader wr = new BufferedReader(new InputStreamReader(ws));\n\n    for (String key = wr.readLine(); key!=null; key = wr.readLine())\n      keys.addElement(new Term(\"word\", key));\n    wr.close();\n\n    Date end = new Date();\n\n    System.out.print(end.getTime() - start.getTime());\n    System.out.println(\" milliseconds to read \" + keys.size() + \" words\");\n\n    start = new Date();\n\n    Random gen = new Random(1251971);\n    long fp = (gen.nextInt() & 0xF) + 1;\n    long pp = (gen.nextInt() & 0xF) + 1;\n    int[] docFreqs = new int[keys.size()];\n    long[] freqPointers = new long[keys.size()];\n    long[] proxPointers = new long[keys.size()];\n    for (int i = 0; i < keys.size(); i++) {\n      docFreqs[i] = (gen.nextInt() & 0xF) + 1;\n      freqPointers[i] = fp;\n      proxPointers[i] = pp;\n      fp += (gen.nextInt() & 0xF) + 1;;\n      pp += (gen.nextInt() & 0xF) + 1;;\n    }\n\n    end = new Date();\n\n    System.out.print(end.getTime() - start.getTime());\n    System.out.println(\" milliseconds to generate values\");\n\n    start = new Date();\n\n    Directory store = FSDirectory.getDirectory(\"test.store\", true);\n    FieldInfos fis = new FieldInfos();\n\n    TermInfosWriter writer = new TermInfosWriter(store, \"words\", fis,\n            IndexWriter.DEFAULT_TERM_INDEX_INTERVAL);\n    fis.add(\"word\", false);\n\n    for (int i = 0; i < keys.size(); i++)\n      writer.add((Term)keys.elementAt(i),\n\t\t new TermInfo(docFreqs[i], freqPointers[i], proxPointers[i]));\n\n    writer.close();\n\n    end = new Date();\n\n    System.out.print(end.getTime() - start.getTime());\n    System.out.println(\" milliseconds to write table\");\n\n    System.out.println(\" table occupies \" +\n\t\t       store.fileLength(\"words.tis\") + \" bytes\");\n\n    start = new Date();\n\n    TermInfosReader reader = new TermInfosReader(store, \"words\", fis);\n\n    end = new Date();\n\n    System.out.print(end.getTime() - start.getTime());\n    System.out.println(\" milliseconds to open table\");\n\n    start = new Date();\n\n    SegmentTermEnum enumerator = reader.terms();\n    for (int i = 0; i < keys.size(); i++) {\n      enumerator.next();\n      Term key = (Term)keys.elementAt(i);\n      if (!key.equals(enumerator.term()))\n\tthrow new Exception(\"wrong term: \" + enumerator.term()\n\t\t\t    + \", expected: \" + key\n\t\t\t    + \" at \" + i);\n      TermInfo ti = enumerator.termInfo();\n      if (ti.docFreq != docFreqs[i])\n\tthrow\n\t  new Exception(\"wrong value: \" + Long.toString(ti.docFreq, 16)\n\t\t\t+ \", expected: \" + Long.toString(docFreqs[i], 16)\n\t\t\t+ \" at \" + i);\n      if (ti.freqPointer != freqPointers[i])\n\tthrow\n\t  new Exception(\"wrong value: \" + Long.toString(ti.freqPointer, 16)\n\t\t\t+ \", expected: \" + Long.toString(freqPointers[i], 16)\n\t\t\t+ \" at \" + i);\n      if (ti.proxPointer != proxPointers[i])\n\tthrow\n\t  new Exception(\"wrong value: \" + Long.toString(ti.proxPointer, 16)\n\t\t\t+ \", expected: \" + Long.toString(proxPointers[i], 16)\n\t\t\t+ \" at \" + i);\n    }\n\n    end = new Date();\n\n    System.out.print(end.getTime() - start.getTime());\n    System.out.println(\" milliseconds to iterate over \" +\n\t\t       keys.size() + \" words\");\n\n    start = new Date();\n\n    for (int i = 0; i < keys.size(); i++) {\n      Term key = (Term)keys.elementAt(i);\n      TermInfo ti = reader.get(key);\n      if (ti.docFreq != docFreqs[i])\n\tthrow\n\t  new Exception(\"wrong value: \" + Long.toString(ti.docFreq, 16)\n\t\t\t+ \", expected: \" + Long.toString(docFreqs[i], 16)\n\t\t\t+ \" at \" + i);\n      if (ti.freqPointer != freqPointers[i])\n\tthrow\n\t  new Exception(\"wrong value: \" + Long.toString(ti.freqPointer, 16)\n\t\t\t+ \", expected: \" + Long.toString(freqPointers[i], 16)\n\t\t\t+ \" at \" + i);\n      if (ti.proxPointer != proxPointers[i])\n\tthrow\n\t  new Exception(\"wrong value: \" + Long.toString(ti.proxPointer, 16)\n\t\t\t+ \", expected: \" + Long.toString(proxPointers[i], 16)\n\t\t\t+ \" at \" + i);\n    }\n\n    end = new Date();\n\n    System.out.print((end.getTime() - start.getTime()) / (float)keys.size());\n    System.out.println(\" average milliseconds per lookup\");\n\n    TermEnum e = reader.terms(new Term(\"word\", \"azz\"));\n    System.out.println(\"Word after azz is \" + e.term().text);\n\n    reader.close();\n\n    store.close();\n  }\n\n","sourceOld":"  // FIXME: OG: remove hard-coded file names\n  public static void test()\n       throws Exception {\n\n    File file = new File(\"words.txt\");\n    System.out.println(\" reading word file containing \" +\n\t\t       file.length() + \" bytes\");\n\n    Date start = new Date();\n\n    Vector keys = new Vector();\n    FileInputStream ws = new FileInputStream(file);\n    BufferedReader wr = new BufferedReader(new InputStreamReader(ws));\n\n    for (String key = wr.readLine(); key!=null; key = wr.readLine())\n      keys.addElement(new Term(\"word\", key));\n    wr.close();\n\n    Date end = new Date();\n\n    System.out.print(end.getTime() - start.getTime());\n    System.out.println(\" milliseconds to read \" + keys.size() + \" words\");\n\n    start = new Date();\n\n    Random gen = new Random(1251971);\n    long fp = (gen.nextInt() & 0xF) + 1;\n    long pp = (gen.nextInt() & 0xF) + 1;\n    int[] docFreqs = new int[keys.size()];\n    long[] freqPointers = new long[keys.size()];\n    long[] proxPointers = new long[keys.size()];\n    for (int i = 0; i < keys.size(); i++) {\n      docFreqs[i] = (gen.nextInt() & 0xF) + 1;\n      freqPointers[i] = fp;\n      proxPointers[i] = pp;\n      fp += (gen.nextInt() & 0xF) + 1;;\n      pp += (gen.nextInt() & 0xF) + 1;;\n    }\n\n    end = new Date();\n\n    System.out.print(end.getTime() - start.getTime());\n    System.out.println(\" milliseconds to generate values\");\n\n    start = new Date();\n\n    Directory store = FSDirectory.getDirectory(\"test.store\", true);\n    FieldInfos fis = new FieldInfos();\n\n    TermInfosWriter writer = new TermInfosWriter(store, \"words\", fis);\n    fis.add(\"word\", false);\n\n    for (int i = 0; i < keys.size(); i++)\n      writer.add((Term)keys.elementAt(i),\n\t\t new TermInfo(docFreqs[i], freqPointers[i], proxPointers[i]));\n\n    writer.close();\n\n    end = new Date();\n\n    System.out.print(end.getTime() - start.getTime());\n    System.out.println(\" milliseconds to write table\");\n\n    System.out.println(\" table occupies \" +\n\t\t       store.fileLength(\"words.tis\") + \" bytes\");\n\n    start = new Date();\n\n    TermInfosReader reader = new TermInfosReader(store, \"words\", fis);\n\n    end = new Date();\n\n    System.out.print(end.getTime() - start.getTime());\n    System.out.println(\" milliseconds to open table\");\n\n    start = new Date();\n\n    SegmentTermEnum enumerator = reader.terms();\n    for (int i = 0; i < keys.size(); i++) {\n      enumerator.next();\n      Term key = (Term)keys.elementAt(i);\n      if (!key.equals(enumerator.term()))\n\tthrow new Exception(\"wrong term: \" + enumerator.term()\n\t\t\t    + \", expected: \" + key\n\t\t\t    + \" at \" + i);\n      TermInfo ti = enumerator.termInfo();\n      if (ti.docFreq != docFreqs[i])\n\tthrow\n\t  new Exception(\"wrong value: \" + Long.toString(ti.docFreq, 16)\n\t\t\t+ \", expected: \" + Long.toString(docFreqs[i], 16)\n\t\t\t+ \" at \" + i);\n      if (ti.freqPointer != freqPointers[i])\n\tthrow\n\t  new Exception(\"wrong value: \" + Long.toString(ti.freqPointer, 16)\n\t\t\t+ \", expected: \" + Long.toString(freqPointers[i], 16)\n\t\t\t+ \" at \" + i);\n      if (ti.proxPointer != proxPointers[i])\n\tthrow\n\t  new Exception(\"wrong value: \" + Long.toString(ti.proxPointer, 16)\n\t\t\t+ \", expected: \" + Long.toString(proxPointers[i], 16)\n\t\t\t+ \" at \" + i);\n    }\n\n    end = new Date();\n\n    System.out.print(end.getTime() - start.getTime());\n    System.out.println(\" milliseconds to iterate over \" +\n\t\t       keys.size() + \" words\");\n\n    start = new Date();\n\n    for (int i = 0; i < keys.size(); i++) {\n      Term key = (Term)keys.elementAt(i);\n      TermInfo ti = reader.get(key);\n      if (ti.docFreq != docFreqs[i])\n\tthrow\n\t  new Exception(\"wrong value: \" + Long.toString(ti.docFreq, 16)\n\t\t\t+ \", expected: \" + Long.toString(docFreqs[i], 16)\n\t\t\t+ \" at \" + i);\n      if (ti.freqPointer != freqPointers[i])\n\tthrow\n\t  new Exception(\"wrong value: \" + Long.toString(ti.freqPointer, 16)\n\t\t\t+ \", expected: \" + Long.toString(freqPointers[i], 16)\n\t\t\t+ \" at \" + i);\n      if (ti.proxPointer != proxPointers[i])\n\tthrow\n\t  new Exception(\"wrong value: \" + Long.toString(ti.proxPointer, 16)\n\t\t\t+ \", expected: \" + Long.toString(proxPointers[i], 16)\n\t\t\t+ \" at \" + i);\n    }\n\n    end = new Date();\n\n    System.out.print((end.getTime() - start.getTime()) / (float)keys.size());\n    System.out.println(\" average milliseconds per lookup\");\n\n    TermEnum e = reader.terms(new Term(\"word\", \"azz\"));\n    System.out.println(\"Word after azz is \" + e.term().text);\n\n    reader.close();\n\n    store.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eeef6f9ff028b4bc9731aeb7841786944411fc24","date":1133543435,"type":4,"author":"Bernhard Messer","isMerge":false,"pathNew":"/dev/null","pathOld":"src/test/org/apache/lucene/index/TermInfosTest#test().mjava","sourceNew":null,"sourceOld":"  // FIXME: OG: remove hard-coded file names\n  public static void test()\n       throws Exception {\n\n    File file = new File(\"words.txt\");\n    System.out.println(\" reading word file containing \" +\n\t\t       file.length() + \" bytes\");\n\n    Date start = new Date();\n\n    Vector keys = new Vector();\n    FileInputStream ws = new FileInputStream(file);\n    BufferedReader wr = new BufferedReader(new InputStreamReader(ws));\n\n    for (String key = wr.readLine(); key!=null; key = wr.readLine())\n      keys.addElement(new Term(\"word\", key));\n    wr.close();\n\n    Date end = new Date();\n\n    System.out.print(end.getTime() - start.getTime());\n    System.out.println(\" milliseconds to read \" + keys.size() + \" words\");\n\n    start = new Date();\n\n    Random gen = new Random(1251971);\n    long fp = (gen.nextInt() & 0xF) + 1;\n    long pp = (gen.nextInt() & 0xF) + 1;\n    int[] docFreqs = new int[keys.size()];\n    long[] freqPointers = new long[keys.size()];\n    long[] proxPointers = new long[keys.size()];\n    for (int i = 0; i < keys.size(); i++) {\n      docFreqs[i] = (gen.nextInt() & 0xF) + 1;\n      freqPointers[i] = fp;\n      proxPointers[i] = pp;\n      fp += (gen.nextInt() & 0xF) + 1;;\n      pp += (gen.nextInt() & 0xF) + 1;;\n    }\n\n    end = new Date();\n\n    System.out.print(end.getTime() - start.getTime());\n    System.out.println(\" milliseconds to generate values\");\n\n    start = new Date();\n\n    Directory store = FSDirectory.getDirectory(\"test.store\", true);\n    FieldInfos fis = new FieldInfos();\n\n    TermInfosWriter writer = new TermInfosWriter(store, \"words\", fis,\n            IndexWriter.DEFAULT_TERM_INDEX_INTERVAL);\n    fis.add(\"word\", false);\n\n    for (int i = 0; i < keys.size(); i++)\n      writer.add((Term)keys.elementAt(i),\n\t\t new TermInfo(docFreqs[i], freqPointers[i], proxPointers[i]));\n\n    writer.close();\n\n    end = new Date();\n\n    System.out.print(end.getTime() - start.getTime());\n    System.out.println(\" milliseconds to write table\");\n\n    System.out.println(\" table occupies \" +\n\t\t       store.fileLength(\"words.tis\") + \" bytes\");\n\n    start = new Date();\n\n    TermInfosReader reader = new TermInfosReader(store, \"words\", fis);\n\n    end = new Date();\n\n    System.out.print(end.getTime() - start.getTime());\n    System.out.println(\" milliseconds to open table\");\n\n    start = new Date();\n\n    SegmentTermEnum enumerator = reader.terms();\n    for (int i = 0; i < keys.size(); i++) {\n      enumerator.next();\n      Term key = (Term)keys.elementAt(i);\n      if (!key.equals(enumerator.term()))\n\tthrow new Exception(\"wrong term: \" + enumerator.term()\n\t\t\t    + \", expected: \" + key\n\t\t\t    + \" at \" + i);\n      TermInfo ti = enumerator.termInfo();\n      if (ti.docFreq != docFreqs[i])\n\tthrow\n\t  new Exception(\"wrong value: \" + Long.toString(ti.docFreq, 16)\n\t\t\t+ \", expected: \" + Long.toString(docFreqs[i], 16)\n\t\t\t+ \" at \" + i);\n      if (ti.freqPointer != freqPointers[i])\n\tthrow\n\t  new Exception(\"wrong value: \" + Long.toString(ti.freqPointer, 16)\n\t\t\t+ \", expected: \" + Long.toString(freqPointers[i], 16)\n\t\t\t+ \" at \" + i);\n      if (ti.proxPointer != proxPointers[i])\n\tthrow\n\t  new Exception(\"wrong value: \" + Long.toString(ti.proxPointer, 16)\n\t\t\t+ \", expected: \" + Long.toString(proxPointers[i], 16)\n\t\t\t+ \" at \" + i);\n    }\n\n    end = new Date();\n\n    System.out.print(end.getTime() - start.getTime());\n    System.out.println(\" milliseconds to iterate over \" +\n\t\t       keys.size() + \" words\");\n\n    start = new Date();\n\n    for (int i = 0; i < keys.size(); i++) {\n      Term key = (Term)keys.elementAt(i);\n      TermInfo ti = reader.get(key);\n      if (ti.docFreq != docFreqs[i])\n\tthrow\n\t  new Exception(\"wrong value: \" + Long.toString(ti.docFreq, 16)\n\t\t\t+ \", expected: \" + Long.toString(docFreqs[i], 16)\n\t\t\t+ \" at \" + i);\n      if (ti.freqPointer != freqPointers[i])\n\tthrow\n\t  new Exception(\"wrong value: \" + Long.toString(ti.freqPointer, 16)\n\t\t\t+ \", expected: \" + Long.toString(freqPointers[i], 16)\n\t\t\t+ \" at \" + i);\n      if (ti.proxPointer != proxPointers[i])\n\tthrow\n\t  new Exception(\"wrong value: \" + Long.toString(ti.proxPointer, 16)\n\t\t\t+ \", expected: \" + Long.toString(proxPointers[i], 16)\n\t\t\t+ \" at \" + i);\n    }\n\n    end = new Date();\n\n    System.out.print((end.getTime() - start.getTime()) / (float)keys.size());\n    System.out.println(\" average milliseconds per lookup\");\n\n    TermEnum e = reader.terms(new Term(\"word\", \"azz\"));\n    System.out.println(\"Word after azz is \" + e.term().text);\n\n    reader.close();\n\n    store.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e0b950aef8cdf4606d480e28ea17bd870b93c81e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"eeef6f9ff028b4bc9731aeb7841786944411fc24":["d41d9416ee7cc6639348fe8fe00cbd1ac0681c10"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["eeef6f9ff028b4bc9731aeb7841786944411fc24"],"d41d9416ee7cc6639348fe8fe00cbd1ac0681c10":["e0b950aef8cdf4606d480e28ea17bd870b93c81e"]},"commit2Childs":{"e0b950aef8cdf4606d480e28ea17bd870b93c81e":["d41d9416ee7cc6639348fe8fe00cbd1ac0681c10"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e0b950aef8cdf4606d480e28ea17bd870b93c81e"],"eeef6f9ff028b4bc9731aeb7841786944411fc24":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d41d9416ee7cc6639348fe8fe00cbd1ac0681c10":["eeef6f9ff028b4bc9731aeb7841786944411fc24"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}