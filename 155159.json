{"path":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter.OneDimensionBKDWriter#writeLeafBlock().mjava","commits":[{"id":"d561885e9bb6238af1ff8afe8630dcfe49b66ac7","date":1469780634,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter.OneDimensionBKDWriter#writeLeafBlock().mjava","pathOld":"/dev/null","sourceNew":"    private void writeLeafBlock() throws IOException {\n      assert leafCount != 0;\n      if (valueCount == 0) {\n        System.arraycopy(leafValues, 0, minPackedValue, 0, packedBytesLength);\n      }\n      System.arraycopy(leafValues, (leafCount - 1) * packedBytesLength, maxPackedValue, 0, packedBytesLength);\n\n      valueCount += leafCount;\n\n      if (leafBlockFPs.size() > 0) {\n        // Save the first (minimum) value in each leaf block except the first, to build the split value index in the end:\n        leafBlockStartValues.add(Arrays.copyOf(leafValues, packedBytesLength));\n      }\n      leafBlockFPs.add(out.getFilePointer());\n      checkMaxLeafNodeCount(leafBlockFPs.size());\n\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      // Find per-dim common prefix:\n      for(int dim=0;dim<numDims;dim++) {\n        int offset1 = dim * bytesPerDim;\n        int offset2 = (leafCount - 1) * packedBytesLength + offset1;\n        for(int j=0;j<commonPrefixLengths[dim];j++) {\n          if (leafValues[offset1+j] != leafValues[offset2+j]) {\n            commonPrefixLengths[dim] = j;\n            break;\n          }\n        }\n      }\n\n      writeLeafBlockDocs(out, leafDocs, 0, leafCount);\n      writeCommonPrefixes(out, commonPrefixLengths, leafValues);\n\n      final IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        final BytesRef scratch = new BytesRef();\n\n        {\n          scratch.length = packedBytesLength;\n          scratch.bytes = leafValues;\n        }\n\n        @Override\n        public BytesRef apply(int i) {\n          scratch.offset = packedBytesLength * i;\n          return scratch;\n        }\n      };\n      assert valuesInOrderAndBounds(leafCount, 0, Arrays.copyOf(leafValues, packedBytesLength),\n          Arrays.copyOfRange(leafValues, (leafCount - 1) * packedBytesLength, leafCount * packedBytesLength),\n          packedValues, leafDocs, 0);\n      writeLeafBlockPackedValues(out, commonPrefixLengths, leafCount, 0, packedValues);\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3b013574eedcdbac35dc7e35b0ee616ffc38895d","date":1470897818,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter.OneDimensionBKDWriter#writeLeafBlock().mjava","pathOld":"/dev/null","sourceNew":"    private void writeLeafBlock() throws IOException {\n      assert leafCount != 0;\n      if (valueCount == 0) {\n        System.arraycopy(leafValues, 0, minPackedValue, 0, packedBytesLength);\n      }\n      System.arraycopy(leafValues, (leafCount - 1) * packedBytesLength, maxPackedValue, 0, packedBytesLength);\n\n      valueCount += leafCount;\n\n      if (leafBlockFPs.size() > 0) {\n        // Save the first (minimum) value in each leaf block except the first, to build the split value index in the end:\n        leafBlockStartValues.add(Arrays.copyOf(leafValues, packedBytesLength));\n      }\n      leafBlockFPs.add(out.getFilePointer());\n      checkMaxLeafNodeCount(leafBlockFPs.size());\n\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      // Find per-dim common prefix:\n      for(int dim=0;dim<numDims;dim++) {\n        int offset1 = dim * bytesPerDim;\n        int offset2 = (leafCount - 1) * packedBytesLength + offset1;\n        for(int j=0;j<commonPrefixLengths[dim];j++) {\n          if (leafValues[offset1+j] != leafValues[offset2+j]) {\n            commonPrefixLengths[dim] = j;\n            break;\n          }\n        }\n      }\n\n      writeLeafBlockDocs(out, leafDocs, 0, leafCount);\n      writeCommonPrefixes(out, commonPrefixLengths, leafValues);\n\n      final IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        final BytesRef scratch = new BytesRef();\n\n        {\n          scratch.length = packedBytesLength;\n          scratch.bytes = leafValues;\n        }\n\n        @Override\n        public BytesRef apply(int i) {\n          scratch.offset = packedBytesLength * i;\n          return scratch;\n        }\n      };\n      assert valuesInOrderAndBounds(leafCount, 0, Arrays.copyOf(leafValues, packedBytesLength),\n          Arrays.copyOfRange(leafValues, (leafCount - 1) * packedBytesLength, leafCount * packedBytesLength),\n          packedValues, leafDocs, 0);\n      writeLeafBlockPackedValues(out, commonPrefixLengths, leafCount, 0, packedValues);\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter.OneDimensionBKDWriter#writeLeafBlock().mjava","pathOld":"/dev/null","sourceNew":"    private void writeLeafBlock() throws IOException {\n      assert leafCount != 0;\n      if (valueCount == 0) {\n        System.arraycopy(leafValues, 0, minPackedValue, 0, packedBytesLength);\n      }\n      System.arraycopy(leafValues, (leafCount - 1) * packedBytesLength, maxPackedValue, 0, packedBytesLength);\n\n      valueCount += leafCount;\n\n      if (leafBlockFPs.size() > 0) {\n        // Save the first (minimum) value in each leaf block except the first, to build the split value index in the end:\n        leafBlockStartValues.add(Arrays.copyOf(leafValues, packedBytesLength));\n      }\n      leafBlockFPs.add(out.getFilePointer());\n      checkMaxLeafNodeCount(leafBlockFPs.size());\n\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      // Find per-dim common prefix:\n      for(int dim=0;dim<numDims;dim++) {\n        int offset1 = dim * bytesPerDim;\n        int offset2 = (leafCount - 1) * packedBytesLength + offset1;\n        for(int j=0;j<commonPrefixLengths[dim];j++) {\n          if (leafValues[offset1+j] != leafValues[offset2+j]) {\n            commonPrefixLengths[dim] = j;\n            break;\n          }\n        }\n      }\n\n      writeLeafBlockDocs(out, leafDocs, 0, leafCount);\n      writeCommonPrefixes(out, commonPrefixLengths, leafValues);\n\n      final IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        final BytesRef scratch = new BytesRef();\n\n        {\n          scratch.length = packedBytesLength;\n          scratch.bytes = leafValues;\n        }\n\n        @Override\n        public BytesRef apply(int i) {\n          scratch.offset = packedBytesLength * i;\n          return scratch;\n        }\n      };\n      assert valuesInOrderAndBounds(leafCount, 0, Arrays.copyOf(leafValues, packedBytesLength),\n          Arrays.copyOfRange(leafValues, (leafCount - 1) * packedBytesLength, leafCount * packedBytesLength),\n          packedValues, leafDocs, 0);\n      writeLeafBlockPackedValues(out, commonPrefixLengths, leafCount, 0, packedValues);\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9fc0d60683b47b5d922124c31f57c8b34734f9e6","date":1480846684,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter.OneDimensionBKDWriter#writeLeafBlock().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter.OneDimensionBKDWriter#writeLeafBlock().mjava","sourceNew":"    private void writeLeafBlock() throws IOException {\n      //System.out.println(\"writeLeafBlock pos=\" + out.getFilePointer());\n      assert leafCount != 0;\n      if (valueCount == 0) {\n        System.arraycopy(leafValues, 0, minPackedValue, 0, packedBytesLength);\n      }\n      System.arraycopy(leafValues, (leafCount - 1) * packedBytesLength, maxPackedValue, 0, packedBytesLength);\n\n      valueCount += leafCount;\n\n      if (leafBlockFPs.size() > 0) {\n        // Save the first (minimum) value in each leaf block except the first, to build the split value index in the end:\n        leafBlockStartValues.add(Arrays.copyOf(leafValues, packedBytesLength));\n      }\n      leafBlockFPs.add(out.getFilePointer());\n      checkMaxLeafNodeCount(leafBlockFPs.size());\n\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      // Find per-dim common prefix:\n      for(int dim=0;dim<numDims;dim++) {\n        int offset1 = dim * bytesPerDim;\n        int offset2 = (leafCount - 1) * packedBytesLength + offset1;\n        for(int j=0;j<commonPrefixLengths[dim];j++) {\n          if (leafValues[offset1+j] != leafValues[offset2+j]) {\n            commonPrefixLengths[dim] = j;\n            break;\n          }\n        }\n      }\n\n      writeLeafBlockDocs(out, leafDocs, 0, leafCount);\n      writeCommonPrefixes(out, commonPrefixLengths, leafValues);\n\n      final IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        final BytesRef scratch = new BytesRef();\n\n        {\n          scratch.length = packedBytesLength;\n          scratch.bytes = leafValues;\n        }\n\n        @Override\n        public BytesRef apply(int i) {\n          scratch.offset = packedBytesLength * i;\n          return scratch;\n        }\n      };\n      assert valuesInOrderAndBounds(leafCount, 0, Arrays.copyOf(leafValues, packedBytesLength),\n          Arrays.copyOfRange(leafValues, (leafCount - 1) * packedBytesLength, leafCount * packedBytesLength),\n          packedValues, leafDocs, 0);\n      writeLeafBlockPackedValues(out, commonPrefixLengths, leafCount, 0, packedValues);\n    }\n\n","sourceOld":"    private void writeLeafBlock() throws IOException {\n      assert leafCount != 0;\n      if (valueCount == 0) {\n        System.arraycopy(leafValues, 0, minPackedValue, 0, packedBytesLength);\n      }\n      System.arraycopy(leafValues, (leafCount - 1) * packedBytesLength, maxPackedValue, 0, packedBytesLength);\n\n      valueCount += leafCount;\n\n      if (leafBlockFPs.size() > 0) {\n        // Save the first (minimum) value in each leaf block except the first, to build the split value index in the end:\n        leafBlockStartValues.add(Arrays.copyOf(leafValues, packedBytesLength));\n      }\n      leafBlockFPs.add(out.getFilePointer());\n      checkMaxLeafNodeCount(leafBlockFPs.size());\n\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      // Find per-dim common prefix:\n      for(int dim=0;dim<numDims;dim++) {\n        int offset1 = dim * bytesPerDim;\n        int offset2 = (leafCount - 1) * packedBytesLength + offset1;\n        for(int j=0;j<commonPrefixLengths[dim];j++) {\n          if (leafValues[offset1+j] != leafValues[offset2+j]) {\n            commonPrefixLengths[dim] = j;\n            break;\n          }\n        }\n      }\n\n      writeLeafBlockDocs(out, leafDocs, 0, leafCount);\n      writeCommonPrefixes(out, commonPrefixLengths, leafValues);\n\n      final IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        final BytesRef scratch = new BytesRef();\n\n        {\n          scratch.length = packedBytesLength;\n          scratch.bytes = leafValues;\n        }\n\n        @Override\n        public BytesRef apply(int i) {\n          scratch.offset = packedBytesLength * i;\n          return scratch;\n        }\n      };\n      assert valuesInOrderAndBounds(leafCount, 0, Arrays.copyOf(leafValues, packedBytesLength),\n          Arrays.copyOfRange(leafValues, (leafCount - 1) * packedBytesLength, leafCount * packedBytesLength),\n          packedValues, leafDocs, 0);\n      writeLeafBlockPackedValues(out, commonPrefixLengths, leafCount, 0, packedValues);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c4ad863d796f4e72a3a1ef4bacd2e19c3e9258c9","date":1481155163,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter.OneDimensionBKDWriter#writeLeafBlock().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter.OneDimensionBKDWriter#writeLeafBlock().mjava","sourceNew":"    private void writeLeafBlock() throws IOException {\n      assert leafCount != 0;\n      if (valueCount == 0) {\n        System.arraycopy(leafValues, 0, minPackedValue, 0, packedBytesLength);\n      }\n      System.arraycopy(leafValues, (leafCount - 1) * packedBytesLength, maxPackedValue, 0, packedBytesLength);\n\n      valueCount += leafCount;\n\n      if (leafBlockFPs.size() > 0) {\n        // Save the first (minimum) value in each leaf block except the first, to build the split value index in the end:\n        leafBlockStartValues.add(Arrays.copyOf(leafValues, packedBytesLength));\n      }\n      leafBlockFPs.add(out.getFilePointer());\n      checkMaxLeafNodeCount(leafBlockFPs.size());\n\n      // Find per-dim common prefix:\n      int prefix = bytesPerDim;\n      int offset = (leafCount - 1) * packedBytesLength;\n      for(int j=0;j<bytesPerDim;j++) {\n        if (leafValues[j] != leafValues[offset+j]) {\n          prefix = j;\n          break;\n        }\n      }\n\n      commonPrefixLengths[0] = prefix;\n\n      assert scratchOut.getPosition() == 0;\n      writeLeafBlockDocs(scratchOut, leafDocs, 0, leafCount);\n      writeCommonPrefixes(scratchOut, commonPrefixLengths, leafValues);\n\n      scratchBytesRef1.length = packedBytesLength;\n      scratchBytesRef1.bytes = leafValues;\n      \n      final IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        @Override\n        public BytesRef apply(int i) {\n          scratchBytesRef1.offset = packedBytesLength * i;\n          return scratchBytesRef1;\n        }\n      };\n      assert valuesInOrderAndBounds(leafCount, 0, Arrays.copyOf(leafValues, packedBytesLength),\n          Arrays.copyOfRange(leafValues, (leafCount - 1) * packedBytesLength, leafCount * packedBytesLength),\n          packedValues, leafDocs, 0);\n      writeLeafBlockPackedValues(scratchOut, commonPrefixLengths, leafCount, 0, packedValues);\n      out.writeBytes(scratchOut.getBytes(), 0, scratchOut.getPosition());\n      scratchOut.reset();\n    }\n\n","sourceOld":"    private void writeLeafBlock() throws IOException {\n      //System.out.println(\"writeLeafBlock pos=\" + out.getFilePointer());\n      assert leafCount != 0;\n      if (valueCount == 0) {\n        System.arraycopy(leafValues, 0, minPackedValue, 0, packedBytesLength);\n      }\n      System.arraycopy(leafValues, (leafCount - 1) * packedBytesLength, maxPackedValue, 0, packedBytesLength);\n\n      valueCount += leafCount;\n\n      if (leafBlockFPs.size() > 0) {\n        // Save the first (minimum) value in each leaf block except the first, to build the split value index in the end:\n        leafBlockStartValues.add(Arrays.copyOf(leafValues, packedBytesLength));\n      }\n      leafBlockFPs.add(out.getFilePointer());\n      checkMaxLeafNodeCount(leafBlockFPs.size());\n\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      // Find per-dim common prefix:\n      for(int dim=0;dim<numDims;dim++) {\n        int offset1 = dim * bytesPerDim;\n        int offset2 = (leafCount - 1) * packedBytesLength + offset1;\n        for(int j=0;j<commonPrefixLengths[dim];j++) {\n          if (leafValues[offset1+j] != leafValues[offset2+j]) {\n            commonPrefixLengths[dim] = j;\n            break;\n          }\n        }\n      }\n\n      writeLeafBlockDocs(out, leafDocs, 0, leafCount);\n      writeCommonPrefixes(out, commonPrefixLengths, leafValues);\n\n      final IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        final BytesRef scratch = new BytesRef();\n\n        {\n          scratch.length = packedBytesLength;\n          scratch.bytes = leafValues;\n        }\n\n        @Override\n        public BytesRef apply(int i) {\n          scratch.offset = packedBytesLength * i;\n          return scratch;\n        }\n      };\n      assert valuesInOrderAndBounds(leafCount, 0, Arrays.copyOf(leafValues, packedBytesLength),\n          Arrays.copyOfRange(leafValues, (leafCount - 1) * packedBytesLength, leafCount * packedBytesLength),\n          packedValues, leafDocs, 0);\n      writeLeafBlockPackedValues(out, commonPrefixLengths, leafCount, 0, packedValues);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9856095f7afb5a607bf5e65077615ed91273508c","date":1481837697,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter.OneDimensionBKDWriter#writeLeafBlock().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter.OneDimensionBKDWriter#writeLeafBlock().mjava","sourceNew":"    private void writeLeafBlock() throws IOException {\n      assert leafCount != 0;\n      if (valueCount == 0) {\n        System.arraycopy(leafValues, 0, minPackedValue, 0, packedBytesLength);\n      }\n      System.arraycopy(leafValues, (leafCount - 1) * packedBytesLength, maxPackedValue, 0, packedBytesLength);\n\n      valueCount += leafCount;\n\n      if (leafBlockFPs.size() > 0) {\n        // Save the first (minimum) value in each leaf block except the first, to build the split value index in the end:\n        leafBlockStartValues.add(Arrays.copyOf(leafValues, packedBytesLength));\n      }\n      leafBlockFPs.add(out.getFilePointer());\n      checkMaxLeafNodeCount(leafBlockFPs.size());\n\n      // Find per-dim common prefix:\n      int prefix = bytesPerDim;\n      int offset = (leafCount - 1) * packedBytesLength;\n      for(int j=0;j<bytesPerDim;j++) {\n        if (leafValues[j] != leafValues[offset+j]) {\n          prefix = j;\n          break;\n        }\n      }\n\n      commonPrefixLengths[0] = prefix;\n\n      assert scratchOut.getPosition() == 0;\n      writeLeafBlockDocs(scratchOut, leafDocs, 0, leafCount);\n      writeCommonPrefixes(scratchOut, commonPrefixLengths, leafValues);\n\n      scratchBytesRef1.length = packedBytesLength;\n      scratchBytesRef1.bytes = leafValues;\n      \n      final IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        @Override\n        public BytesRef apply(int i) {\n          scratchBytesRef1.offset = packedBytesLength * i;\n          return scratchBytesRef1;\n        }\n      };\n      assert valuesInOrderAndBounds(leafCount, 0, Arrays.copyOf(leafValues, packedBytesLength),\n          Arrays.copyOfRange(leafValues, (leafCount - 1) * packedBytesLength, leafCount * packedBytesLength),\n          packedValues, leafDocs, 0);\n      writeLeafBlockPackedValues(scratchOut, commonPrefixLengths, leafCount, 0, packedValues);\n      out.writeBytes(scratchOut.getBytes(), 0, scratchOut.getPosition());\n      scratchOut.reset();\n    }\n\n","sourceOld":"    private void writeLeafBlock() throws IOException {\n      assert leafCount != 0;\n      if (valueCount == 0) {\n        System.arraycopy(leafValues, 0, minPackedValue, 0, packedBytesLength);\n      }\n      System.arraycopy(leafValues, (leafCount - 1) * packedBytesLength, maxPackedValue, 0, packedBytesLength);\n\n      valueCount += leafCount;\n\n      if (leafBlockFPs.size() > 0) {\n        // Save the first (minimum) value in each leaf block except the first, to build the split value index in the end:\n        leafBlockStartValues.add(Arrays.copyOf(leafValues, packedBytesLength));\n      }\n      leafBlockFPs.add(out.getFilePointer());\n      checkMaxLeafNodeCount(leafBlockFPs.size());\n\n      Arrays.fill(commonPrefixLengths, bytesPerDim);\n      // Find per-dim common prefix:\n      for(int dim=0;dim<numDims;dim++) {\n        int offset1 = dim * bytesPerDim;\n        int offset2 = (leafCount - 1) * packedBytesLength + offset1;\n        for(int j=0;j<commonPrefixLengths[dim];j++) {\n          if (leafValues[offset1+j] != leafValues[offset2+j]) {\n            commonPrefixLengths[dim] = j;\n            break;\n          }\n        }\n      }\n\n      writeLeafBlockDocs(out, leafDocs, 0, leafCount);\n      writeCommonPrefixes(out, commonPrefixLengths, leafValues);\n\n      final IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        final BytesRef scratch = new BytesRef();\n\n        {\n          scratch.length = packedBytesLength;\n          scratch.bytes = leafValues;\n        }\n\n        @Override\n        public BytesRef apply(int i) {\n          scratch.offset = packedBytesLength * i;\n          return scratch;\n        }\n      };\n      assert valuesInOrderAndBounds(leafCount, 0, Arrays.copyOf(leafValues, packedBytesLength),\n          Arrays.copyOfRange(leafValues, (leafCount - 1) * packedBytesLength, leafCount * packedBytesLength),\n          packedValues, leafDocs, 0);\n      writeLeafBlockPackedValues(out, commonPrefixLengths, leafCount, 0, packedValues);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9798d0818e7a880546802b509792d3f3d57babd2","date":1528358901,"type":3,"author":"Nhat Nguyen","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter.OneDimensionBKDWriter#writeLeafBlock().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter.OneDimensionBKDWriter#writeLeafBlock().mjava","sourceNew":"    private void writeLeafBlock() throws IOException {\n      assert leafCount != 0;\n      if (valueCount == 0) {\n        System.arraycopy(leafValues, 0, minPackedValue, 0, packedBytesLength);\n      }\n      System.arraycopy(leafValues, (leafCount - 1) * packedBytesLength, maxPackedValue, 0, packedBytesLength);\n\n      valueCount += leafCount;\n\n      if (leafBlockFPs.size() > 0) {\n        // Save the first (minimum) value in each leaf block except the first, to build the split value index in the end:\n        leafBlockStartValues.add(ArrayUtil.copyOfSubArray(leafValues, 0, packedBytesLength));\n      }\n      leafBlockFPs.add(out.getFilePointer());\n      checkMaxLeafNodeCount(leafBlockFPs.size());\n\n      // Find per-dim common prefix:\n      int prefix = bytesPerDim;\n      int offset = (leafCount - 1) * packedBytesLength;\n      for(int j=0;j<bytesPerDim;j++) {\n        if (leafValues[j] != leafValues[offset+j]) {\n          prefix = j;\n          break;\n        }\n      }\n\n      commonPrefixLengths[0] = prefix;\n\n      assert scratchOut.getPosition() == 0;\n      writeLeafBlockDocs(scratchOut, leafDocs, 0, leafCount);\n      writeCommonPrefixes(scratchOut, commonPrefixLengths, leafValues);\n\n      scratchBytesRef1.length = packedBytesLength;\n      scratchBytesRef1.bytes = leafValues;\n      \n      final IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        @Override\n        public BytesRef apply(int i) {\n          scratchBytesRef1.offset = packedBytesLength * i;\n          return scratchBytesRef1;\n        }\n      };\n      assert valuesInOrderAndBounds(leafCount, 0, ArrayUtil.copyOfSubArray(leafValues, 0, packedBytesLength),\n          ArrayUtil.copyOfSubArray(leafValues, (leafCount - 1) * packedBytesLength, leafCount * packedBytesLength),\n          packedValues, leafDocs, 0);\n      writeLeafBlockPackedValues(scratchOut, commonPrefixLengths, leafCount, 0, packedValues);\n      out.writeBytes(scratchOut.getBytes(), 0, scratchOut.getPosition());\n      scratchOut.reset();\n    }\n\n","sourceOld":"    private void writeLeafBlock() throws IOException {\n      assert leafCount != 0;\n      if (valueCount == 0) {\n        System.arraycopy(leafValues, 0, minPackedValue, 0, packedBytesLength);\n      }\n      System.arraycopy(leafValues, (leafCount - 1) * packedBytesLength, maxPackedValue, 0, packedBytesLength);\n\n      valueCount += leafCount;\n\n      if (leafBlockFPs.size() > 0) {\n        // Save the first (minimum) value in each leaf block except the first, to build the split value index in the end:\n        leafBlockStartValues.add(Arrays.copyOf(leafValues, packedBytesLength));\n      }\n      leafBlockFPs.add(out.getFilePointer());\n      checkMaxLeafNodeCount(leafBlockFPs.size());\n\n      // Find per-dim common prefix:\n      int prefix = bytesPerDim;\n      int offset = (leafCount - 1) * packedBytesLength;\n      for(int j=0;j<bytesPerDim;j++) {\n        if (leafValues[j] != leafValues[offset+j]) {\n          prefix = j;\n          break;\n        }\n      }\n\n      commonPrefixLengths[0] = prefix;\n\n      assert scratchOut.getPosition() == 0;\n      writeLeafBlockDocs(scratchOut, leafDocs, 0, leafCount);\n      writeCommonPrefixes(scratchOut, commonPrefixLengths, leafValues);\n\n      scratchBytesRef1.length = packedBytesLength;\n      scratchBytesRef1.bytes = leafValues;\n      \n      final IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        @Override\n        public BytesRef apply(int i) {\n          scratchBytesRef1.offset = packedBytesLength * i;\n          return scratchBytesRef1;\n        }\n      };\n      assert valuesInOrderAndBounds(leafCount, 0, Arrays.copyOf(leafValues, packedBytesLength),\n          Arrays.copyOfRange(leafValues, (leafCount - 1) * packedBytesLength, leafCount * packedBytesLength),\n          packedValues, leafDocs, 0);\n      writeLeafBlockPackedValues(scratchOut, commonPrefixLengths, leafCount, 0, packedValues);\n      out.writeBytes(scratchOut.getBytes(), 0, scratchOut.getPosition());\n      scratchOut.reset();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b70042a8a492f7054d480ccdd2be9796510d4327","date":1528386658,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter.OneDimensionBKDWriter#writeLeafBlock().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter.OneDimensionBKDWriter#writeLeafBlock().mjava","sourceNew":"    private void writeLeafBlock() throws IOException {\n      assert leafCount != 0;\n      if (valueCount == 0) {\n        System.arraycopy(leafValues, 0, minPackedValue, 0, packedBytesLength);\n      }\n      System.arraycopy(leafValues, (leafCount - 1) * packedBytesLength, maxPackedValue, 0, packedBytesLength);\n\n      valueCount += leafCount;\n\n      if (leafBlockFPs.size() > 0) {\n        // Save the first (minimum) value in each leaf block except the first, to build the split value index in the end:\n        leafBlockStartValues.add(ArrayUtil.copyOfSubArray(leafValues, 0, packedBytesLength));\n      }\n      leafBlockFPs.add(out.getFilePointer());\n      checkMaxLeafNodeCount(leafBlockFPs.size());\n\n      // Find per-dim common prefix:\n      int prefix = bytesPerDim;\n      int offset = (leafCount - 1) * packedBytesLength;\n      for(int j=0;j<bytesPerDim;j++) {\n        if (leafValues[j] != leafValues[offset+j]) {\n          prefix = j;\n          break;\n        }\n      }\n\n      commonPrefixLengths[0] = prefix;\n\n      assert scratchOut.getPosition() == 0;\n      writeLeafBlockDocs(scratchOut, leafDocs, 0, leafCount);\n      writeCommonPrefixes(scratchOut, commonPrefixLengths, leafValues);\n\n      scratchBytesRef1.length = packedBytesLength;\n      scratchBytesRef1.bytes = leafValues;\n      \n      final IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        @Override\n        public BytesRef apply(int i) {\n          scratchBytesRef1.offset = packedBytesLength * i;\n          return scratchBytesRef1;\n        }\n      };\n      assert valuesInOrderAndBounds(leafCount, 0, ArrayUtil.copyOfSubArray(leafValues, 0, packedBytesLength),\n          ArrayUtil.copyOfSubArray(leafValues, (leafCount - 1) * packedBytesLength, leafCount * packedBytesLength),\n          packedValues, leafDocs, 0);\n      writeLeafBlockPackedValues(scratchOut, commonPrefixLengths, leafCount, 0, packedValues);\n      out.writeBytes(scratchOut.getBytes(), 0, scratchOut.getPosition());\n      scratchOut.reset();\n    }\n\n","sourceOld":"    private void writeLeafBlock() throws IOException {\n      assert leafCount != 0;\n      if (valueCount == 0) {\n        System.arraycopy(leafValues, 0, minPackedValue, 0, packedBytesLength);\n      }\n      System.arraycopy(leafValues, (leafCount - 1) * packedBytesLength, maxPackedValue, 0, packedBytesLength);\n\n      valueCount += leafCount;\n\n      if (leafBlockFPs.size() > 0) {\n        // Save the first (minimum) value in each leaf block except the first, to build the split value index in the end:\n        leafBlockStartValues.add(Arrays.copyOf(leafValues, packedBytesLength));\n      }\n      leafBlockFPs.add(out.getFilePointer());\n      checkMaxLeafNodeCount(leafBlockFPs.size());\n\n      // Find per-dim common prefix:\n      int prefix = bytesPerDim;\n      int offset = (leafCount - 1) * packedBytesLength;\n      for(int j=0;j<bytesPerDim;j++) {\n        if (leafValues[j] != leafValues[offset+j]) {\n          prefix = j;\n          break;\n        }\n      }\n\n      commonPrefixLengths[0] = prefix;\n\n      assert scratchOut.getPosition() == 0;\n      writeLeafBlockDocs(scratchOut, leafDocs, 0, leafCount);\n      writeCommonPrefixes(scratchOut, commonPrefixLengths, leafValues);\n\n      scratchBytesRef1.length = packedBytesLength;\n      scratchBytesRef1.bytes = leafValues;\n      \n      final IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        @Override\n        public BytesRef apply(int i) {\n          scratchBytesRef1.offset = packedBytesLength * i;\n          return scratchBytesRef1;\n        }\n      };\n      assert valuesInOrderAndBounds(leafCount, 0, Arrays.copyOf(leafValues, packedBytesLength),\n          Arrays.copyOfRange(leafValues, (leafCount - 1) * packedBytesLength, leafCount * packedBytesLength),\n          packedValues, leafDocs, 0);\n      writeLeafBlockPackedValues(scratchOut, commonPrefixLengths, leafCount, 0, packedValues);\n      out.writeBytes(scratchOut.getBytes(), 0, scratchOut.getPosition());\n      scratchOut.reset();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter.OneDimensionBKDWriter#writeLeafBlock().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter.OneDimensionBKDWriter#writeLeafBlock().mjava","sourceNew":"    private void writeLeafBlock() throws IOException {\n      assert leafCount != 0;\n      if (valueCount == 0) {\n        System.arraycopy(leafValues, 0, minPackedValue, 0, packedBytesLength);\n      }\n      System.arraycopy(leafValues, (leafCount - 1) * packedBytesLength, maxPackedValue, 0, packedBytesLength);\n\n      valueCount += leafCount;\n\n      if (leafBlockFPs.size() > 0) {\n        // Save the first (minimum) value in each leaf block except the first, to build the split value index in the end:\n        leafBlockStartValues.add(ArrayUtil.copyOfSubArray(leafValues, 0, packedBytesLength));\n      }\n      leafBlockFPs.add(out.getFilePointer());\n      checkMaxLeafNodeCount(leafBlockFPs.size());\n\n      // Find per-dim common prefix:\n      int prefix = bytesPerDim;\n      int offset = (leafCount - 1) * packedBytesLength;\n      for(int j=0;j<bytesPerDim;j++) {\n        if (leafValues[j] != leafValues[offset+j]) {\n          prefix = j;\n          break;\n        }\n      }\n\n      commonPrefixLengths[0] = prefix;\n\n      assert scratchOut.getPosition() == 0;\n      writeLeafBlockDocs(scratchOut, leafDocs, 0, leafCount);\n      writeCommonPrefixes(scratchOut, commonPrefixLengths, leafValues);\n\n      scratchBytesRef1.length = packedBytesLength;\n      scratchBytesRef1.bytes = leafValues;\n      \n      final IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        @Override\n        public BytesRef apply(int i) {\n          scratchBytesRef1.offset = packedBytesLength * i;\n          return scratchBytesRef1;\n        }\n      };\n      assert valuesInOrderAndBounds(leafCount, 0, ArrayUtil.copyOfSubArray(leafValues, 0, packedBytesLength),\n          ArrayUtil.copyOfSubArray(leafValues, (leafCount - 1) * packedBytesLength, leafCount * packedBytesLength),\n          packedValues, leafDocs, 0);\n      writeLeafBlockPackedValues(scratchOut, commonPrefixLengths, leafCount, 0, packedValues);\n      out.writeBytes(scratchOut.getBytes(), 0, scratchOut.getPosition());\n      scratchOut.reset();\n    }\n\n","sourceOld":"    private void writeLeafBlock() throws IOException {\n      assert leafCount != 0;\n      if (valueCount == 0) {\n        System.arraycopy(leafValues, 0, minPackedValue, 0, packedBytesLength);\n      }\n      System.arraycopy(leafValues, (leafCount - 1) * packedBytesLength, maxPackedValue, 0, packedBytesLength);\n\n      valueCount += leafCount;\n\n      if (leafBlockFPs.size() > 0) {\n        // Save the first (minimum) value in each leaf block except the first, to build the split value index in the end:\n        leafBlockStartValues.add(Arrays.copyOf(leafValues, packedBytesLength));\n      }\n      leafBlockFPs.add(out.getFilePointer());\n      checkMaxLeafNodeCount(leafBlockFPs.size());\n\n      // Find per-dim common prefix:\n      int prefix = bytesPerDim;\n      int offset = (leafCount - 1) * packedBytesLength;\n      for(int j=0;j<bytesPerDim;j++) {\n        if (leafValues[j] != leafValues[offset+j]) {\n          prefix = j;\n          break;\n        }\n      }\n\n      commonPrefixLengths[0] = prefix;\n\n      assert scratchOut.getPosition() == 0;\n      writeLeafBlockDocs(scratchOut, leafDocs, 0, leafCount);\n      writeCommonPrefixes(scratchOut, commonPrefixLengths, leafValues);\n\n      scratchBytesRef1.length = packedBytesLength;\n      scratchBytesRef1.bytes = leafValues;\n      \n      final IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        @Override\n        public BytesRef apply(int i) {\n          scratchBytesRef1.offset = packedBytesLength * i;\n          return scratchBytesRef1;\n        }\n      };\n      assert valuesInOrderAndBounds(leafCount, 0, Arrays.copyOf(leafValues, packedBytesLength),\n          Arrays.copyOfRange(leafValues, (leafCount - 1) * packedBytesLength, leafCount * packedBytesLength),\n          packedValues, leafDocs, 0);\n      writeLeafBlockPackedValues(scratchOut, commonPrefixLengths, leafCount, 0, packedValues);\n      out.writeBytes(scratchOut.getBytes(), 0, scratchOut.getPosition());\n      scratchOut.reset();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f6652c943595e92c187ee904c382863013eae28f","date":1539042663,"type":3,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter.OneDimensionBKDWriter#writeLeafBlock().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter.OneDimensionBKDWriter#writeLeafBlock().mjava","sourceNew":"    private void writeLeafBlock() throws IOException {\n      assert leafCount != 0;\n      if (valueCount == 0) {\n        System.arraycopy(leafValues, 0, minPackedValue, 0, packedIndexBytesLength);\n      }\n      System.arraycopy(leafValues, (leafCount - 1) * packedBytesLength, maxPackedValue, 0, packedIndexBytesLength);\n\n      valueCount += leafCount;\n\n      if (leafBlockFPs.size() > 0) {\n        // Save the first (minimum) value in each leaf block except the first, to build the split value index in the end:\n        leafBlockStartValues.add(ArrayUtil.copyOfSubArray(leafValues, 0, packedBytesLength));\n      }\n      leafBlockFPs.add(out.getFilePointer());\n      checkMaxLeafNodeCount(leafBlockFPs.size());\n\n      // Find per-dim common prefix:\n      int prefix = bytesPerDim;\n      int offset = (leafCount - 1) * packedBytesLength;\n      for(int j=0;j<bytesPerDim;j++) {\n        if (leafValues[j] != leafValues[offset+j]) {\n          prefix = j;\n          break;\n        }\n      }\n\n      commonPrefixLengths[0] = prefix;\n\n      assert scratchOut.getPosition() == 0;\n      writeLeafBlockDocs(scratchOut, leafDocs, 0, leafCount);\n      writeCommonPrefixes(scratchOut, commonPrefixLengths, leafValues);\n\n      scratchBytesRef1.length = packedBytesLength;\n      scratchBytesRef1.bytes = leafValues;\n      \n      final IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        @Override\n        public BytesRef apply(int i) {\n          scratchBytesRef1.offset = packedBytesLength * i;\n          return scratchBytesRef1;\n        }\n      };\n      assert valuesInOrderAndBounds(leafCount, 0, ArrayUtil.copyOfSubArray(leafValues, 0, packedBytesLength),\n          ArrayUtil.copyOfSubArray(leafValues, (leafCount - 1) * packedBytesLength, leafCount * packedBytesLength),\n          packedValues, leafDocs, 0);\n      writeLeafBlockPackedValues(scratchOut, commonPrefixLengths, leafCount, 0, packedValues);\n      out.writeBytes(scratchOut.getBytes(), 0, scratchOut.getPosition());\n      scratchOut.reset();\n    }\n\n","sourceOld":"    private void writeLeafBlock() throws IOException {\n      assert leafCount != 0;\n      if (valueCount == 0) {\n        System.arraycopy(leafValues, 0, minPackedValue, 0, packedBytesLength);\n      }\n      System.arraycopy(leafValues, (leafCount - 1) * packedBytesLength, maxPackedValue, 0, packedBytesLength);\n\n      valueCount += leafCount;\n\n      if (leafBlockFPs.size() > 0) {\n        // Save the first (minimum) value in each leaf block except the first, to build the split value index in the end:\n        leafBlockStartValues.add(ArrayUtil.copyOfSubArray(leafValues, 0, packedBytesLength));\n      }\n      leafBlockFPs.add(out.getFilePointer());\n      checkMaxLeafNodeCount(leafBlockFPs.size());\n\n      // Find per-dim common prefix:\n      int prefix = bytesPerDim;\n      int offset = (leafCount - 1) * packedBytesLength;\n      for(int j=0;j<bytesPerDim;j++) {\n        if (leafValues[j] != leafValues[offset+j]) {\n          prefix = j;\n          break;\n        }\n      }\n\n      commonPrefixLengths[0] = prefix;\n\n      assert scratchOut.getPosition() == 0;\n      writeLeafBlockDocs(scratchOut, leafDocs, 0, leafCount);\n      writeCommonPrefixes(scratchOut, commonPrefixLengths, leafValues);\n\n      scratchBytesRef1.length = packedBytesLength;\n      scratchBytesRef1.bytes = leafValues;\n      \n      final IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        @Override\n        public BytesRef apply(int i) {\n          scratchBytesRef1.offset = packedBytesLength * i;\n          return scratchBytesRef1;\n        }\n      };\n      assert valuesInOrderAndBounds(leafCount, 0, ArrayUtil.copyOfSubArray(leafValues, 0, packedBytesLength),\n          ArrayUtil.copyOfSubArray(leafValues, (leafCount - 1) * packedBytesLength, leafCount * packedBytesLength),\n          packedValues, leafDocs, 0);\n      writeLeafBlockPackedValues(scratchOut, commonPrefixLengths, leafCount, 0, packedValues);\n      out.writeBytes(scratchOut.getBytes(), 0, scratchOut.getPosition());\n      scratchOut.reset();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"68144b3b30df82b7233727bc4fb958ce52e5b483","date":1543396715,"type":3,"author":"Christoph Büscher","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter.OneDimensionBKDWriter#writeLeafBlock().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter.OneDimensionBKDWriter#writeLeafBlock().mjava","sourceNew":"    private void writeLeafBlock() throws IOException {\n      assert leafCount != 0;\n      if (valueCount == 0) {\n        System.arraycopy(leafValues, 0, minPackedValue, 0, packedIndexBytesLength);\n      }\n      System.arraycopy(leafValues, (leafCount - 1) * packedBytesLength, maxPackedValue, 0, packedIndexBytesLength);\n\n      valueCount += leafCount;\n\n      if (leafBlockFPs.size() > 0) {\n        // Save the first (minimum) value in each leaf block except the first, to build the split value index in the end:\n        leafBlockStartValues.add(ArrayUtil.copyOfSubArray(leafValues, 0, packedBytesLength));\n      }\n      leafBlockFPs.add(out.getFilePointer());\n      checkMaxLeafNodeCount(leafBlockFPs.size());\n\n      // Find per-dim common prefix:\n      int offset = (leafCount - 1) * packedBytesLength;\n      int prefix = FutureArrays.mismatch(leafValues, 0, bytesPerDim, leafValues, offset, offset + bytesPerDim);\n      if (prefix == -1) {\n          prefix = bytesPerDim;\n      }\n\n      commonPrefixLengths[0] = prefix;\n\n      assert scratchOut.getPosition() == 0;\n      writeLeafBlockDocs(scratchOut, leafDocs, 0, leafCount);\n      writeCommonPrefixes(scratchOut, commonPrefixLengths, leafValues);\n\n      scratchBytesRef1.length = packedBytesLength;\n      scratchBytesRef1.bytes = leafValues;\n      \n      final IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        @Override\n        public BytesRef apply(int i) {\n          scratchBytesRef1.offset = packedBytesLength * i;\n          return scratchBytesRef1;\n        }\n      };\n      assert valuesInOrderAndBounds(leafCount, 0, ArrayUtil.copyOfSubArray(leafValues, 0, packedBytesLength),\n          ArrayUtil.copyOfSubArray(leafValues, (leafCount - 1) * packedBytesLength, leafCount * packedBytesLength),\n          packedValues, leafDocs, 0);\n      writeLeafBlockPackedValues(scratchOut, commonPrefixLengths, leafCount, 0, packedValues);\n      out.writeBytes(scratchOut.getBytes(), 0, scratchOut.getPosition());\n      scratchOut.reset();\n    }\n\n","sourceOld":"    private void writeLeafBlock() throws IOException {\n      assert leafCount != 0;\n      if (valueCount == 0) {\n        System.arraycopy(leafValues, 0, minPackedValue, 0, packedIndexBytesLength);\n      }\n      System.arraycopy(leafValues, (leafCount - 1) * packedBytesLength, maxPackedValue, 0, packedIndexBytesLength);\n\n      valueCount += leafCount;\n\n      if (leafBlockFPs.size() > 0) {\n        // Save the first (minimum) value in each leaf block except the first, to build the split value index in the end:\n        leafBlockStartValues.add(ArrayUtil.copyOfSubArray(leafValues, 0, packedBytesLength));\n      }\n      leafBlockFPs.add(out.getFilePointer());\n      checkMaxLeafNodeCount(leafBlockFPs.size());\n\n      // Find per-dim common prefix:\n      int prefix = bytesPerDim;\n      int offset = (leafCount - 1) * packedBytesLength;\n      for(int j=0;j<bytesPerDim;j++) {\n        if (leafValues[j] != leafValues[offset+j]) {\n          prefix = j;\n          break;\n        }\n      }\n\n      commonPrefixLengths[0] = prefix;\n\n      assert scratchOut.getPosition() == 0;\n      writeLeafBlockDocs(scratchOut, leafDocs, 0, leafCount);\n      writeCommonPrefixes(scratchOut, commonPrefixLengths, leafValues);\n\n      scratchBytesRef1.length = packedBytesLength;\n      scratchBytesRef1.bytes = leafValues;\n      \n      final IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        @Override\n        public BytesRef apply(int i) {\n          scratchBytesRef1.offset = packedBytesLength * i;\n          return scratchBytesRef1;\n        }\n      };\n      assert valuesInOrderAndBounds(leafCount, 0, ArrayUtil.copyOfSubArray(leafValues, 0, packedBytesLength),\n          ArrayUtil.copyOfSubArray(leafValues, (leafCount - 1) * packedBytesLength, leafCount * packedBytesLength),\n          packedValues, leafDocs, 0);\n      writeLeafBlockPackedValues(scratchOut, commonPrefixLengths, leafCount, 0, packedValues);\n      out.writeBytes(scratchOut.getBytes(), 0, scratchOut.getPosition());\n      scratchOut.reset();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"409da428f28953cf35fddd5c9ff5c7e4f5439863","date":1547556145,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter.OneDimensionBKDWriter#writeLeafBlock().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter.OneDimensionBKDWriter#writeLeafBlock().mjava","sourceNew":"    private void writeLeafBlock() throws IOException {\n      assert leafCount != 0;\n      if (valueCount == 0) {\n        System.arraycopy(leafValues, 0, minPackedValue, 0, packedIndexBytesLength);\n      }\n      System.arraycopy(leafValues, (leafCount - 1) * packedBytesLength, maxPackedValue, 0, packedIndexBytesLength);\n\n      valueCount += leafCount;\n\n      if (leafBlockFPs.size() > 0) {\n        // Save the first (minimum) value in each leaf block except the first, to build the split value index in the end:\n        leafBlockStartValues.add(ArrayUtil.copyOfSubArray(leafValues, 0, packedBytesLength));\n      }\n      leafBlockFPs.add(out.getFilePointer());\n      checkMaxLeafNodeCount(leafBlockFPs.size());\n\n      // Find per-dim common prefix:\n      int offset = (leafCount - 1) * packedBytesLength;\n      int prefix = FutureArrays.mismatch(leafValues, 0, bytesPerDim, leafValues, offset, offset + bytesPerDim);\n      if (prefix == -1) {\n          prefix = bytesPerDim;\n      }\n\n      commonPrefixLengths[0] = prefix;\n\n      assert scratchOut.size() == 0;\n      writeLeafBlockDocs(scratchOut, leafDocs, 0, leafCount);\n      writeCommonPrefixes(scratchOut, commonPrefixLengths, leafValues);\n\n      scratchBytesRef1.length = packedBytesLength;\n      scratchBytesRef1.bytes = leafValues;\n      \n      final IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        @Override\n        public BytesRef apply(int i) {\n          scratchBytesRef1.offset = packedBytesLength * i;\n          return scratchBytesRef1;\n        }\n      };\n      assert valuesInOrderAndBounds(leafCount, 0, ArrayUtil.copyOfSubArray(leafValues, 0, packedBytesLength),\n          ArrayUtil.copyOfSubArray(leafValues, (leafCount - 1) * packedBytesLength, leafCount * packedBytesLength),\n          packedValues, leafDocs, 0);\n      writeLeafBlockPackedValues(scratchOut, commonPrefixLengths, leafCount, 0, packedValues);\n      scratchOut.copyTo(out);\n      scratchOut.reset();\n    }\n\n","sourceOld":"    private void writeLeafBlock() throws IOException {\n      assert leafCount != 0;\n      if (valueCount == 0) {\n        System.arraycopy(leafValues, 0, minPackedValue, 0, packedIndexBytesLength);\n      }\n      System.arraycopy(leafValues, (leafCount - 1) * packedBytesLength, maxPackedValue, 0, packedIndexBytesLength);\n\n      valueCount += leafCount;\n\n      if (leafBlockFPs.size() > 0) {\n        // Save the first (minimum) value in each leaf block except the first, to build the split value index in the end:\n        leafBlockStartValues.add(ArrayUtil.copyOfSubArray(leafValues, 0, packedBytesLength));\n      }\n      leafBlockFPs.add(out.getFilePointer());\n      checkMaxLeafNodeCount(leafBlockFPs.size());\n\n      // Find per-dim common prefix:\n      int offset = (leafCount - 1) * packedBytesLength;\n      int prefix = FutureArrays.mismatch(leafValues, 0, bytesPerDim, leafValues, offset, offset + bytesPerDim);\n      if (prefix == -1) {\n          prefix = bytesPerDim;\n      }\n\n      commonPrefixLengths[0] = prefix;\n\n      assert scratchOut.getPosition() == 0;\n      writeLeafBlockDocs(scratchOut, leafDocs, 0, leafCount);\n      writeCommonPrefixes(scratchOut, commonPrefixLengths, leafValues);\n\n      scratchBytesRef1.length = packedBytesLength;\n      scratchBytesRef1.bytes = leafValues;\n      \n      final IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        @Override\n        public BytesRef apply(int i) {\n          scratchBytesRef1.offset = packedBytesLength * i;\n          return scratchBytesRef1;\n        }\n      };\n      assert valuesInOrderAndBounds(leafCount, 0, ArrayUtil.copyOfSubArray(leafValues, 0, packedBytesLength),\n          ArrayUtil.copyOfSubArray(leafValues, (leafCount - 1) * packedBytesLength, leafCount * packedBytesLength),\n          packedValues, leafDocs, 0);\n      writeLeafBlockPackedValues(scratchOut, commonPrefixLengths, leafCount, 0, packedValues);\n      out.writeBytes(scratchOut.getBytes(), 0, scratchOut.getPosition());\n      scratchOut.reset();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b88a121b875f9ae2ac50f85cf46dcb680f126357","date":1555416009,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter.OneDimensionBKDWriter#writeLeafBlock().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter.OneDimensionBKDWriter#writeLeafBlock().mjava","sourceNew":"    private void writeLeafBlock() throws IOException {\n      assert leafCount != 0;\n      if (valueCount == 0) {\n        System.arraycopy(leafValues, 0, minPackedValue, 0, packedIndexBytesLength);\n      }\n      System.arraycopy(leafValues, (leafCount - 1) * packedBytesLength, maxPackedValue, 0, packedIndexBytesLength);\n\n      valueCount += leafCount;\n\n      if (leafBlockFPs.size() > 0) {\n        // Save the first (minimum) value in each leaf block except the first, to build the split value index in the end:\n        leafBlockStartValues.add(ArrayUtil.copyOfSubArray(leafValues, 0, packedBytesLength));\n      }\n      leafBlockFPs.add(out.getFilePointer());\n      checkMaxLeafNodeCount(leafBlockFPs.size());\n\n      // Find per-dim common prefix:\n      int offset = (leafCount - 1) * packedBytesLength;\n      int prefix = Arrays.mismatch(leafValues, 0, bytesPerDim, leafValues, offset, offset + bytesPerDim);\n      if (prefix == -1) {\n          prefix = bytesPerDim;\n      }\n\n      commonPrefixLengths[0] = prefix;\n\n      assert scratchOut.size() == 0;\n      writeLeafBlockDocs(scratchOut, leafDocs, 0, leafCount);\n      writeCommonPrefixes(scratchOut, commonPrefixLengths, leafValues);\n\n      scratchBytesRef1.length = packedBytesLength;\n      scratchBytesRef1.bytes = leafValues;\n      \n      final IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        @Override\n        public BytesRef apply(int i) {\n          scratchBytesRef1.offset = packedBytesLength * i;\n          return scratchBytesRef1;\n        }\n      };\n      assert valuesInOrderAndBounds(leafCount, 0, ArrayUtil.copyOfSubArray(leafValues, 0, packedBytesLength),\n          ArrayUtil.copyOfSubArray(leafValues, (leafCount - 1) * packedBytesLength, leafCount * packedBytesLength),\n          packedValues, leafDocs, 0);\n      writeLeafBlockPackedValues(scratchOut, commonPrefixLengths, leafCount, 0, packedValues);\n      scratchOut.copyTo(out);\n      scratchOut.reset();\n    }\n\n","sourceOld":"    private void writeLeafBlock() throws IOException {\n      assert leafCount != 0;\n      if (valueCount == 0) {\n        System.arraycopy(leafValues, 0, minPackedValue, 0, packedIndexBytesLength);\n      }\n      System.arraycopy(leafValues, (leafCount - 1) * packedBytesLength, maxPackedValue, 0, packedIndexBytesLength);\n\n      valueCount += leafCount;\n\n      if (leafBlockFPs.size() > 0) {\n        // Save the first (minimum) value in each leaf block except the first, to build the split value index in the end:\n        leafBlockStartValues.add(ArrayUtil.copyOfSubArray(leafValues, 0, packedBytesLength));\n      }\n      leafBlockFPs.add(out.getFilePointer());\n      checkMaxLeafNodeCount(leafBlockFPs.size());\n\n      // Find per-dim common prefix:\n      int offset = (leafCount - 1) * packedBytesLength;\n      int prefix = FutureArrays.mismatch(leafValues, 0, bytesPerDim, leafValues, offset, offset + bytesPerDim);\n      if (prefix == -1) {\n          prefix = bytesPerDim;\n      }\n\n      commonPrefixLengths[0] = prefix;\n\n      assert scratchOut.size() == 0;\n      writeLeafBlockDocs(scratchOut, leafDocs, 0, leafCount);\n      writeCommonPrefixes(scratchOut, commonPrefixLengths, leafValues);\n\n      scratchBytesRef1.length = packedBytesLength;\n      scratchBytesRef1.bytes = leafValues;\n      \n      final IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        @Override\n        public BytesRef apply(int i) {\n          scratchBytesRef1.offset = packedBytesLength * i;\n          return scratchBytesRef1;\n        }\n      };\n      assert valuesInOrderAndBounds(leafCount, 0, ArrayUtil.copyOfSubArray(leafValues, 0, packedBytesLength),\n          ArrayUtil.copyOfSubArray(leafValues, (leafCount - 1) * packedBytesLength, leafCount * packedBytesLength),\n          packedValues, leafDocs, 0);\n      writeLeafBlockPackedValues(scratchOut, commonPrefixLengths, leafCount, 0, packedValues);\n      scratchOut.copyTo(out);\n      scratchOut.reset();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e70dbc563c35c0f6b6a0a545e65346166e6e5f2b","date":1561536972,"type":5,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter.OneDimensionBKDWriter#writeLeafBlock(int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter.OneDimensionBKDWriter#writeLeafBlock().mjava","sourceNew":"    private void writeLeafBlock(int leafCardinality) throws IOException {\n      assert leafCount != 0;\n      if (valueCount == 0) {\n        System.arraycopy(leafValues, 0, minPackedValue, 0, packedIndexBytesLength);\n      }\n      System.arraycopy(leafValues, (leafCount - 1) * packedBytesLength, maxPackedValue, 0, packedIndexBytesLength);\n\n      valueCount += leafCount;\n\n      if (leafBlockFPs.size() > 0) {\n        // Save the first (minimum) value in each leaf block except the first, to build the split value index in the end:\n        leafBlockStartValues.add(ArrayUtil.copyOfSubArray(leafValues, 0, packedBytesLength));\n      }\n      leafBlockFPs.add(out.getFilePointer());\n      checkMaxLeafNodeCount(leafBlockFPs.size());\n\n      // Find per-dim common prefix:\n      int offset = (leafCount - 1) * packedBytesLength;\n      int prefix = Arrays.mismatch(leafValues, 0, bytesPerDim, leafValues, offset, offset + bytesPerDim);\n      if (prefix == -1) {\n        prefix = bytesPerDim;\n      }\n\n      commonPrefixLengths[0] = prefix;\n\n      assert scratchOut.size() == 0;\n      writeLeafBlockDocs(scratchOut, leafDocs, 0, leafCount);\n      writeCommonPrefixes(scratchOut, commonPrefixLengths, leafValues);\n\n      scratchBytesRef1.length = packedBytesLength;\n      scratchBytesRef1.bytes = leafValues;\n      \n      final IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        @Override\n        public BytesRef apply(int i) {\n          scratchBytesRef1.offset = packedBytesLength * i;\n          return scratchBytesRef1;\n        }\n      };\n      assert valuesInOrderAndBounds(leafCount, 0, ArrayUtil.copyOfSubArray(leafValues, 0, packedBytesLength),\n          ArrayUtil.copyOfSubArray(leafValues, (leafCount - 1) * packedBytesLength, leafCount * packedBytesLength),\n          packedValues, leafDocs, 0);\n      writeLeafBlockPackedValues(scratchOut, commonPrefixLengths, leafCount, 0, packedValues, leafCardinality);\n      scratchOut.copyTo(out);\n      scratchOut.reset();\n    }\n\n","sourceOld":"    private void writeLeafBlock() throws IOException {\n      assert leafCount != 0;\n      if (valueCount == 0) {\n        System.arraycopy(leafValues, 0, minPackedValue, 0, packedIndexBytesLength);\n      }\n      System.arraycopy(leafValues, (leafCount - 1) * packedBytesLength, maxPackedValue, 0, packedIndexBytesLength);\n\n      valueCount += leafCount;\n\n      if (leafBlockFPs.size() > 0) {\n        // Save the first (minimum) value in each leaf block except the first, to build the split value index in the end:\n        leafBlockStartValues.add(ArrayUtil.copyOfSubArray(leafValues, 0, packedBytesLength));\n      }\n      leafBlockFPs.add(out.getFilePointer());\n      checkMaxLeafNodeCount(leafBlockFPs.size());\n\n      // Find per-dim common prefix:\n      int offset = (leafCount - 1) * packedBytesLength;\n      int prefix = Arrays.mismatch(leafValues, 0, bytesPerDim, leafValues, offset, offset + bytesPerDim);\n      if (prefix == -1) {\n          prefix = bytesPerDim;\n      }\n\n      commonPrefixLengths[0] = prefix;\n\n      assert scratchOut.size() == 0;\n      writeLeafBlockDocs(scratchOut, leafDocs, 0, leafCount);\n      writeCommonPrefixes(scratchOut, commonPrefixLengths, leafValues);\n\n      scratchBytesRef1.length = packedBytesLength;\n      scratchBytesRef1.bytes = leafValues;\n      \n      final IntFunction<BytesRef> packedValues = new IntFunction<BytesRef>() {\n        @Override\n        public BytesRef apply(int i) {\n          scratchBytesRef1.offset = packedBytesLength * i;\n          return scratchBytesRef1;\n        }\n      };\n      assert valuesInOrderAndBounds(leafCount, 0, ArrayUtil.copyOfSubArray(leafValues, 0, packedBytesLength),\n          ArrayUtil.copyOfSubArray(leafValues, (leafCount - 1) * packedBytesLength, leafCount * packedBytesLength),\n          packedValues, leafDocs, 0);\n      writeLeafBlockPackedValues(scratchOut, commonPrefixLengths, leafCount, 0, packedValues);\n      scratchOut.copyTo(out);\n      scratchOut.reset();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"68144b3b30df82b7233727bc4fb958ce52e5b483":["f6652c943595e92c187ee904c382863013eae28f"],"f6652c943595e92c187ee904c382863013eae28f":["9798d0818e7a880546802b509792d3f3d57babd2"],"e70dbc563c35c0f6b6a0a545e65346166e6e5f2b":["b88a121b875f9ae2ac50f85cf46dcb680f126357"],"d561885e9bb6238af1ff8afe8630dcfe49b66ac7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","d561885e9bb6238af1ff8afe8630dcfe49b66ac7"],"c4ad863d796f4e72a3a1ef4bacd2e19c3e9258c9":["9fc0d60683b47b5d922124c31f57c8b34734f9e6"],"9fc0d60683b47b5d922124c31f57c8b34734f9e6":["d561885e9bb6238af1ff8afe8630dcfe49b66ac7"],"b88a121b875f9ae2ac50f85cf46dcb680f126357":["409da428f28953cf35fddd5c9ff5c7e4f5439863"],"409da428f28953cf35fddd5c9ff5c7e4f5439863":["68144b3b30df82b7233727bc4fb958ce52e5b483"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b70042a8a492f7054d480ccdd2be9796510d4327":["c4ad863d796f4e72a3a1ef4bacd2e19c3e9258c9","9798d0818e7a880546802b509792d3f3d57babd2"],"9856095f7afb5a607bf5e65077615ed91273508c":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","c4ad863d796f4e72a3a1ef4bacd2e19c3e9258c9"],"9798d0818e7a880546802b509792d3f3d57babd2":["c4ad863d796f4e72a3a1ef4bacd2e19c3e9258c9"],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","d561885e9bb6238af1ff8afe8630dcfe49b66ac7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e70dbc563c35c0f6b6a0a545e65346166e6e5f2b"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["c4ad863d796f4e72a3a1ef4bacd2e19c3e9258c9","9798d0818e7a880546802b509792d3f3d57babd2"]},"commit2Childs":{"68144b3b30df82b7233727bc4fb958ce52e5b483":["409da428f28953cf35fddd5c9ff5c7e4f5439863"],"f6652c943595e92c187ee904c382863013eae28f":["68144b3b30df82b7233727bc4fb958ce52e5b483"],"e70dbc563c35c0f6b6a0a545e65346166e6e5f2b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d561885e9bb6238af1ff8afe8630dcfe49b66ac7":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","9fc0d60683b47b5d922124c31f57c8b34734f9e6","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["9856095f7afb5a607bf5e65077615ed91273508c"],"c4ad863d796f4e72a3a1ef4bacd2e19c3e9258c9":["b70042a8a492f7054d480ccdd2be9796510d4327","9856095f7afb5a607bf5e65077615ed91273508c","9798d0818e7a880546802b509792d3f3d57babd2","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"9fc0d60683b47b5d922124c31f57c8b34734f9e6":["c4ad863d796f4e72a3a1ef4bacd2e19c3e9258c9"],"b88a121b875f9ae2ac50f85cf46dcb680f126357":["e70dbc563c35c0f6b6a0a545e65346166e6e5f2b"],"409da428f28953cf35fddd5c9ff5c7e4f5439863":["b88a121b875f9ae2ac50f85cf46dcb680f126357"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d561885e9bb6238af1ff8afe8630dcfe49b66ac7","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"b70042a8a492f7054d480ccdd2be9796510d4327":[],"9856095f7afb5a607bf5e65077615ed91273508c":[],"9798d0818e7a880546802b509792d3f3d57babd2":["f6652c943595e92c187ee904c382863013eae28f","b70042a8a492f7054d480ccdd2be9796510d4327","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["b70042a8a492f7054d480ccdd2be9796510d4327","9856095f7afb5a607bf5e65077615ed91273508c","3b013574eedcdbac35dc7e35b0ee616ffc38895d","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}