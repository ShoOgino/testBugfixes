{"path":"modules/benchmark/src/java/org/apache/lucene/benchmark/quality/QualityStats#average(QualityStats[]).mjava","commits":[{"id":"ecc11368dc265bfdad90214f8bf5da99016ab1e2","date":1294144090,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"modules/benchmark/src/java/org/apache/lucene/benchmark/quality/QualityStats#average(QualityStats[]).mjava","pathOld":"lucene/contrib/benchmark/src/java/org/apache/lucene/benchmark/quality/QualityStats#average(QualityStats[]).mjava","sourceNew":"  /**\n   * Create a QualityStats object that is the average of the input QualityStats objects. \n   * @param stats array of input stats to be averaged.\n   * @return an average over the input stats.\n   */\n  public static QualityStats average(QualityStats[] stats) {\n    QualityStats avg = new QualityStats(0,0);\n    if (stats.length==0) {\n      // weired, no stats to average!\n      return avg;\n    }\n    int m = 0; // queries with positive judgements\n    // aggregate\n    for (int i=0; i<stats.length; i++) {\n      avg.searchTime += stats[i].searchTime;\n      avg.docNamesExtractTime += stats[i].docNamesExtractTime;\n      if (stats[i].maxGoodPoints>0) {\n        m++;\n        avg.numGoodPoints += stats[i].numGoodPoints;\n        avg.numPoints += stats[i].numPoints;\n        avg.pReleventSum += stats[i].getAvp();\n        avg.recall += stats[i].recall;\n        avg.mrr += stats[i].getMRR();\n        avg.maxGoodPoints += stats[i].maxGoodPoints;\n        for (int j=1; j<avg.pAt.length; j++) {\n          avg.pAt[j] += stats[i].getPrecisionAt(j);\n        }\n      }\n    }\n    assert m>0 : \"Fishy: no \\\"good\\\" queries!\";\n    // take average: times go by all queries, other measures go by \"good\" queries only.\n    avg.searchTime /= stats.length;\n    avg.docNamesExtractTime /= stats.length;\n    avg.numGoodPoints /= m;\n    avg.numPoints /= m;\n    avg.recall /= m;\n    avg.mrr /= m;\n    avg.maxGoodPoints /= m;\n    for (int j=1; j<avg.pAt.length; j++) {\n      avg.pAt[j] /= m;\n    }\n    avg.pReleventSum /= m;                 // this is actually avgp now \n    avg.pReleventSum *= avg.maxGoodPoints; // so that getAvgP() would be correct\n    \n    return avg;\n  }\n\n","sourceOld":"  /**\n   * Create a QualityStats object that is the average of the input QualityStats objects. \n   * @param stats array of input stats to be averaged.\n   * @return an average over the input stats.\n   */\n  public static QualityStats average(QualityStats[] stats) {\n    QualityStats avg = new QualityStats(0,0);\n    if (stats.length==0) {\n      // weired, no stats to average!\n      return avg;\n    }\n    int m = 0; // queries with positive judgements\n    // aggregate\n    for (int i=0; i<stats.length; i++) {\n      avg.searchTime += stats[i].searchTime;\n      avg.docNamesExtractTime += stats[i].docNamesExtractTime;\n      if (stats[i].maxGoodPoints>0) {\n        m++;\n        avg.numGoodPoints += stats[i].numGoodPoints;\n        avg.numPoints += stats[i].numPoints;\n        avg.pReleventSum += stats[i].getAvp();\n        avg.recall += stats[i].recall;\n        avg.mrr += stats[i].getMRR();\n        avg.maxGoodPoints += stats[i].maxGoodPoints;\n        for (int j=1; j<avg.pAt.length; j++) {\n          avg.pAt[j] += stats[i].getPrecisionAt(j);\n        }\n      }\n    }\n    assert m>0 : \"Fishy: no \\\"good\\\" queries!\";\n    // take average: times go by all queries, other measures go by \"good\" queries only.\n    avg.searchTime /= stats.length;\n    avg.docNamesExtractTime /= stats.length;\n    avg.numGoodPoints /= m;\n    avg.numPoints /= m;\n    avg.recall /= m;\n    avg.mrr /= m;\n    avg.maxGoodPoints /= m;\n    for (int j=1; j<avg.pAt.length; j++) {\n      avg.pAt[j] /= m;\n    }\n    avg.pReleventSum /= m;                 // this is actually avgp now \n    avg.pReleventSum *= avg.maxGoodPoints; // so that getAvgP() would be correct\n    \n    return avg;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"70ad682703b8585f5d0a637efec044d57ec05efb","date":1294259117,"type":1,"author":"Simon Willnauer","isMerge":true,"pathNew":"modules/benchmark/src/java/org/apache/lucene/benchmark/quality/QualityStats#average(QualityStats[]).mjava","pathOld":"lucene/contrib/benchmark/src/java/org/apache/lucene/benchmark/quality/QualityStats#average(QualityStats[]).mjava","sourceNew":"  /**\n   * Create a QualityStats object that is the average of the input QualityStats objects. \n   * @param stats array of input stats to be averaged.\n   * @return an average over the input stats.\n   */\n  public static QualityStats average(QualityStats[] stats) {\n    QualityStats avg = new QualityStats(0,0);\n    if (stats.length==0) {\n      // weired, no stats to average!\n      return avg;\n    }\n    int m = 0; // queries with positive judgements\n    // aggregate\n    for (int i=0; i<stats.length; i++) {\n      avg.searchTime += stats[i].searchTime;\n      avg.docNamesExtractTime += stats[i].docNamesExtractTime;\n      if (stats[i].maxGoodPoints>0) {\n        m++;\n        avg.numGoodPoints += stats[i].numGoodPoints;\n        avg.numPoints += stats[i].numPoints;\n        avg.pReleventSum += stats[i].getAvp();\n        avg.recall += stats[i].recall;\n        avg.mrr += stats[i].getMRR();\n        avg.maxGoodPoints += stats[i].maxGoodPoints;\n        for (int j=1; j<avg.pAt.length; j++) {\n          avg.pAt[j] += stats[i].getPrecisionAt(j);\n        }\n      }\n    }\n    assert m>0 : \"Fishy: no \\\"good\\\" queries!\";\n    // take average: times go by all queries, other measures go by \"good\" queries only.\n    avg.searchTime /= stats.length;\n    avg.docNamesExtractTime /= stats.length;\n    avg.numGoodPoints /= m;\n    avg.numPoints /= m;\n    avg.recall /= m;\n    avg.mrr /= m;\n    avg.maxGoodPoints /= m;\n    for (int j=1; j<avg.pAt.length; j++) {\n      avg.pAt[j] /= m;\n    }\n    avg.pReleventSum /= m;                 // this is actually avgp now \n    avg.pReleventSum *= avg.maxGoodPoints; // so that getAvgP() would be correct\n    \n    return avg;\n  }\n\n","sourceOld":"  /**\n   * Create a QualityStats object that is the average of the input QualityStats objects. \n   * @param stats array of input stats to be averaged.\n   * @return an average over the input stats.\n   */\n  public static QualityStats average(QualityStats[] stats) {\n    QualityStats avg = new QualityStats(0,0);\n    if (stats.length==0) {\n      // weired, no stats to average!\n      return avg;\n    }\n    int m = 0; // queries with positive judgements\n    // aggregate\n    for (int i=0; i<stats.length; i++) {\n      avg.searchTime += stats[i].searchTime;\n      avg.docNamesExtractTime += stats[i].docNamesExtractTime;\n      if (stats[i].maxGoodPoints>0) {\n        m++;\n        avg.numGoodPoints += stats[i].numGoodPoints;\n        avg.numPoints += stats[i].numPoints;\n        avg.pReleventSum += stats[i].getAvp();\n        avg.recall += stats[i].recall;\n        avg.mrr += stats[i].getMRR();\n        avg.maxGoodPoints += stats[i].maxGoodPoints;\n        for (int j=1; j<avg.pAt.length; j++) {\n          avg.pAt[j] += stats[i].getPrecisionAt(j);\n        }\n      }\n    }\n    assert m>0 : \"Fishy: no \\\"good\\\" queries!\";\n    // take average: times go by all queries, other measures go by \"good\" queries only.\n    avg.searchTime /= stats.length;\n    avg.docNamesExtractTime /= stats.length;\n    avg.numGoodPoints /= m;\n    avg.numPoints /= m;\n    avg.recall /= m;\n    avg.mrr /= m;\n    avg.maxGoodPoints /= m;\n    for (int j=1; j<avg.pAt.length; j++) {\n      avg.pAt[j] /= m;\n    }\n    avg.pReleventSum /= m;                 // this is actually avgp now \n    avg.pReleventSum *= avg.maxGoodPoints; // so that getAvgP() would be correct\n    \n    return avg;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"868da859b43505d9d2a023bfeae6dd0c795f5295","date":1294948401,"type":1,"author":"Michael Busch","isMerge":true,"pathNew":"modules/benchmark/src/java/org/apache/lucene/benchmark/quality/QualityStats#average(QualityStats[]).mjava","pathOld":"lucene/contrib/benchmark/src/java/org/apache/lucene/benchmark/quality/QualityStats#average(QualityStats[]).mjava","sourceNew":"  /**\n   * Create a QualityStats object that is the average of the input QualityStats objects. \n   * @param stats array of input stats to be averaged.\n   * @return an average over the input stats.\n   */\n  public static QualityStats average(QualityStats[] stats) {\n    QualityStats avg = new QualityStats(0,0);\n    if (stats.length==0) {\n      // weired, no stats to average!\n      return avg;\n    }\n    int m = 0; // queries with positive judgements\n    // aggregate\n    for (int i=0; i<stats.length; i++) {\n      avg.searchTime += stats[i].searchTime;\n      avg.docNamesExtractTime += stats[i].docNamesExtractTime;\n      if (stats[i].maxGoodPoints>0) {\n        m++;\n        avg.numGoodPoints += stats[i].numGoodPoints;\n        avg.numPoints += stats[i].numPoints;\n        avg.pReleventSum += stats[i].getAvp();\n        avg.recall += stats[i].recall;\n        avg.mrr += stats[i].getMRR();\n        avg.maxGoodPoints += stats[i].maxGoodPoints;\n        for (int j=1; j<avg.pAt.length; j++) {\n          avg.pAt[j] += stats[i].getPrecisionAt(j);\n        }\n      }\n    }\n    assert m>0 : \"Fishy: no \\\"good\\\" queries!\";\n    // take average: times go by all queries, other measures go by \"good\" queries only.\n    avg.searchTime /= stats.length;\n    avg.docNamesExtractTime /= stats.length;\n    avg.numGoodPoints /= m;\n    avg.numPoints /= m;\n    avg.recall /= m;\n    avg.mrr /= m;\n    avg.maxGoodPoints /= m;\n    for (int j=1; j<avg.pAt.length; j++) {\n      avg.pAt[j] /= m;\n    }\n    avg.pReleventSum /= m;                 // this is actually avgp now \n    avg.pReleventSum *= avg.maxGoodPoints; // so that getAvgP() would be correct\n    \n    return avg;\n  }\n\n","sourceOld":"  /**\n   * Create a QualityStats object that is the average of the input QualityStats objects. \n   * @param stats array of input stats to be averaged.\n   * @return an average over the input stats.\n   */\n  public static QualityStats average(QualityStats[] stats) {\n    QualityStats avg = new QualityStats(0,0);\n    if (stats.length==0) {\n      // weired, no stats to average!\n      return avg;\n    }\n    int m = 0; // queries with positive judgements\n    // aggregate\n    for (int i=0; i<stats.length; i++) {\n      avg.searchTime += stats[i].searchTime;\n      avg.docNamesExtractTime += stats[i].docNamesExtractTime;\n      if (stats[i].maxGoodPoints>0) {\n        m++;\n        avg.numGoodPoints += stats[i].numGoodPoints;\n        avg.numPoints += stats[i].numPoints;\n        avg.pReleventSum += stats[i].getAvp();\n        avg.recall += stats[i].recall;\n        avg.mrr += stats[i].getMRR();\n        avg.maxGoodPoints += stats[i].maxGoodPoints;\n        for (int j=1; j<avg.pAt.length; j++) {\n          avg.pAt[j] += stats[i].getPrecisionAt(j);\n        }\n      }\n    }\n    assert m>0 : \"Fishy: no \\\"good\\\" queries!\";\n    // take average: times go by all queries, other measures go by \"good\" queries only.\n    avg.searchTime /= stats.length;\n    avg.docNamesExtractTime /= stats.length;\n    avg.numGoodPoints /= m;\n    avg.numPoints /= m;\n    avg.recall /= m;\n    avg.mrr /= m;\n    avg.maxGoodPoints /= m;\n    for (int j=1; j<avg.pAt.length; j++) {\n      avg.pAt[j] /= m;\n    }\n    avg.pReleventSum /= m;                 // this is actually avgp now \n    avg.pReleventSum *= avg.maxGoodPoints; // so that getAvgP() would be correct\n    \n    return avg;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/benchmark/src/java/org/apache/lucene/benchmark/quality/QualityStats#average(QualityStats[]).mjava","pathOld":"modules/benchmark/src/java/org/apache/lucene/benchmark/quality/QualityStats#average(QualityStats[]).mjava","sourceNew":"  /**\n   * Create a QualityStats object that is the average of the input QualityStats objects. \n   * @param stats array of input stats to be averaged.\n   * @return an average over the input stats.\n   */\n  public static QualityStats average(QualityStats[] stats) {\n    QualityStats avg = new QualityStats(0,0);\n    if (stats.length==0) {\n      // weired, no stats to average!\n      return avg;\n    }\n    int m = 0; // queries with positive judgements\n    // aggregate\n    for (int i=0; i<stats.length; i++) {\n      avg.searchTime += stats[i].searchTime;\n      avg.docNamesExtractTime += stats[i].docNamesExtractTime;\n      if (stats[i].maxGoodPoints>0) {\n        m++;\n        avg.numGoodPoints += stats[i].numGoodPoints;\n        avg.numPoints += stats[i].numPoints;\n        avg.pReleventSum += stats[i].getAvp();\n        avg.recall += stats[i].recall;\n        avg.mrr += stats[i].getMRR();\n        avg.maxGoodPoints += stats[i].maxGoodPoints;\n        for (int j=1; j<avg.pAt.length; j++) {\n          avg.pAt[j] += stats[i].getPrecisionAt(j);\n        }\n      }\n    }\n    assert m>0 : \"Fishy: no \\\"good\\\" queries!\";\n    // take average: times go by all queries, other measures go by \"good\" queries only.\n    avg.searchTime /= stats.length;\n    avg.docNamesExtractTime /= stats.length;\n    avg.numGoodPoints /= m;\n    avg.numPoints /= m;\n    avg.recall /= m;\n    avg.mrr /= m;\n    avg.maxGoodPoints /= m;\n    for (int j=1; j<avg.pAt.length; j++) {\n      avg.pAt[j] /= m;\n    }\n    avg.pReleventSum /= m;                 // this is actually avgp now \n    avg.pReleventSum *= avg.maxGoodPoints; // so that getAvgP() would be correct\n    \n    return avg;\n  }\n\n","sourceOld":"  /**\n   * Create a QualityStats object that is the average of the input QualityStats objects. \n   * @param stats array of input stats to be averaged.\n   * @return an average over the input stats.\n   */\n  public static QualityStats average(QualityStats[] stats) {\n    QualityStats avg = new QualityStats(0,0);\n    if (stats.length==0) {\n      // weired, no stats to average!\n      return avg;\n    }\n    int m = 0; // queries with positive judgements\n    // aggregate\n    for (int i=0; i<stats.length; i++) {\n      avg.searchTime += stats[i].searchTime;\n      avg.docNamesExtractTime += stats[i].docNamesExtractTime;\n      if (stats[i].maxGoodPoints>0) {\n        m++;\n        avg.numGoodPoints += stats[i].numGoodPoints;\n        avg.numPoints += stats[i].numPoints;\n        avg.pReleventSum += stats[i].getAvp();\n        avg.recall += stats[i].recall;\n        avg.mrr += stats[i].getMRR();\n        avg.maxGoodPoints += stats[i].maxGoodPoints;\n        for (int j=1; j<avg.pAt.length; j++) {\n          avg.pAt[j] += stats[i].getPrecisionAt(j);\n        }\n      }\n    }\n    assert m>0 : \"Fishy: no \\\"good\\\" queries!\";\n    // take average: times go by all queries, other measures go by \"good\" queries only.\n    avg.searchTime /= stats.length;\n    avg.docNamesExtractTime /= stats.length;\n    avg.numGoodPoints /= m;\n    avg.numPoints /= m;\n    avg.recall /= m;\n    avg.mrr /= m;\n    avg.maxGoodPoints /= m;\n    for (int j=1; j<avg.pAt.length; j++) {\n      avg.pAt[j] /= m;\n    }\n    avg.pReleventSum /= m;                 // this is actually avgp now \n    avg.pReleventSum *= avg.maxGoodPoints; // so that getAvgP() would be correct\n    \n    return avg;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"70ad682703b8585f5d0a637efec044d57ec05efb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ecc11368dc265bfdad90214f8bf5da99016ab1e2"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["ecc11368dc265bfdad90214f8bf5da99016ab1e2"],"ecc11368dc265bfdad90214f8bf5da99016ab1e2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"868da859b43505d9d2a023bfeae6dd0c795f5295":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ecc11368dc265bfdad90214f8bf5da99016ab1e2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b89678825b68eccaf09e6ab71675fc0b0af1e099"]},"commit2Childs":{"70ad682703b8585f5d0a637efec044d57ec05efb":[],"ecc11368dc265bfdad90214f8bf5da99016ab1e2":["70ad682703b8585f5d0a637efec044d57ec05efb","b89678825b68eccaf09e6ab71675fc0b0af1e099","868da859b43505d9d2a023bfeae6dd0c795f5295"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["70ad682703b8585f5d0a637efec044d57ec05efb","ecc11368dc265bfdad90214f8bf5da99016ab1e2","868da859b43505d9d2a023bfeae6dd0c795f5295"],"868da859b43505d9d2a023bfeae6dd0c795f5295":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["70ad682703b8585f5d0a637efec044d57ec05efb","868da859b43505d9d2a023bfeae6dd0c795f5295","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}