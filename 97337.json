{"path":"solr/test-framework/src/java/org/apache/solr/BaseDistributedSearchTestCase#compare(NamedList,NamedList,int,Map[String,Integer]).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/BaseDistributedSearchTestCase#compare(NamedList,NamedList,int,Map[String,Integer]).mjava","pathOld":"solr/src/test-framework/org/apache/solr/BaseDistributedSearchTestCase#compare(NamedList,NamedList,int,Map[String,Integer]).mjava","sourceNew":"  public static String compare(NamedList a, NamedList b, int flags, Map<String, Integer> handle) {\n    boolean ordered = (flags & UNORDERED) == 0;\n\n    int posa = 0, posb = 0;\n    int aSkipped = 0, bSkipped = 0;\n\n    for (; ;) {\n      if (posa >= a.size() || posb >= b.size()) {\n        break;\n      }\n\n      String namea, nameb;\n      Object vala, valb = null;\n\n      int flagsa, flagsb;\n      for (; ;) {\n        namea = a.getName(posa);\n        vala = a.getVal(posa);\n        posa++;\n        flagsa = flags(handle, namea);\n        if ((flagsa & SKIP) != 0) {\n          aSkipped++;\n          continue;\n        }\n        break;\n      }\n\n      if (!ordered) posb = 0;  // reset if not ordered\n\n      while (posb < b.size()) {\n        nameb = b.getName(posb);\n        valb = b.getVal(posb);\n        posb++;\n        flagsb = flags(handle, nameb);\n        if ((flagsb & SKIP) != 0) {\n          bSkipped++;\n          continue;\n        }\n        if (eq(namea, nameb)) {\n          break;\n        }\n        if (ordered) {\n          return \".\" + namea + \"!=\" + nameb + \" (unordered or missing)\";\n        }\n        // if unordered, continue until we find the right field.\n      }\n\n      // ok, namea and nameb should be equal here already.\n      if ((flagsa & SKIPVAL) != 0) continue;  // keys matching is enough\n\n      String cmp = compare(vala, valb, flagsa, handle);\n      if (cmp != null) return \".\" + namea + cmp;\n    }\n\n\n    if (a.size() - aSkipped != b.size() - bSkipped) {\n      return \".size()==\" + a.size() + \",\" + b.size() + \"skipped=\" + aSkipped + \",\" + bSkipped;\n    }\n\n    return null;\n  }\n\n","sourceOld":"  public static String compare(NamedList a, NamedList b, int flags, Map<String, Integer> handle) {\n    boolean ordered = (flags & UNORDERED) == 0;\n\n    int posa = 0, posb = 0;\n    int aSkipped = 0, bSkipped = 0;\n\n    for (; ;) {\n      if (posa >= a.size() || posb >= b.size()) {\n        break;\n      }\n\n      String namea, nameb;\n      Object vala, valb = null;\n\n      int flagsa, flagsb;\n      for (; ;) {\n        namea = a.getName(posa);\n        vala = a.getVal(posa);\n        posa++;\n        flagsa = flags(handle, namea);\n        if ((flagsa & SKIP) != 0) {\n          aSkipped++;\n          continue;\n        }\n        break;\n      }\n\n      if (!ordered) posb = 0;  // reset if not ordered\n\n      while (posb < b.size()) {\n        nameb = b.getName(posb);\n        valb = b.getVal(posb);\n        posb++;\n        flagsb = flags(handle, nameb);\n        if ((flagsb & SKIP) != 0) {\n          bSkipped++;\n          continue;\n        }\n        if (eq(namea, nameb)) {\n          break;\n        }\n        if (ordered) {\n          return \".\" + namea + \"!=\" + nameb + \" (unordered or missing)\";\n        }\n        // if unordered, continue until we find the right field.\n      }\n\n      // ok, namea and nameb should be equal here already.\n      if ((flagsa & SKIPVAL) != 0) continue;  // keys matching is enough\n\n      String cmp = compare(vala, valb, flagsa, handle);\n      if (cmp != null) return \".\" + namea + cmp;\n    }\n\n\n    if (a.size() - aSkipped != b.size() - bSkipped) {\n      return \".size()==\" + a.size() + \",\" + b.size() + \"skipped=\" + aSkipped + \",\" + bSkipped;\n    }\n\n    return null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/BaseDistributedSearchTestCase#compare(NamedList,NamedList,int,Map[String,Integer]).mjava","pathOld":"solr/src/test-framework/org/apache/solr/BaseDistributedSearchTestCase#compare(NamedList,NamedList,int,Map[String,Integer]).mjava","sourceNew":"  public static String compare(NamedList a, NamedList b, int flags, Map<String, Integer> handle) {\n    boolean ordered = (flags & UNORDERED) == 0;\n\n    int posa = 0, posb = 0;\n    int aSkipped = 0, bSkipped = 0;\n\n    for (; ;) {\n      if (posa >= a.size() || posb >= b.size()) {\n        break;\n      }\n\n      String namea, nameb;\n      Object vala, valb = null;\n\n      int flagsa, flagsb;\n      for (; ;) {\n        namea = a.getName(posa);\n        vala = a.getVal(posa);\n        posa++;\n        flagsa = flags(handle, namea);\n        if ((flagsa & SKIP) != 0) {\n          aSkipped++;\n          continue;\n        }\n        break;\n      }\n\n      if (!ordered) posb = 0;  // reset if not ordered\n\n      while (posb < b.size()) {\n        nameb = b.getName(posb);\n        valb = b.getVal(posb);\n        posb++;\n        flagsb = flags(handle, nameb);\n        if ((flagsb & SKIP) != 0) {\n          bSkipped++;\n          continue;\n        }\n        if (eq(namea, nameb)) {\n          break;\n        }\n        if (ordered) {\n          return err(\".\" + namea + \"!=\" + nameb + \" (unordered or missing)\");\n        }\n        // if unordered, continue until we find the right field.\n      }\n\n      // ok, namea and nameb should be equal here already.\n      if ((flagsa & SKIPVAL) != 0) continue;  // keys matching is enough\n\n      String cmp = compare(vala, valb, flagsa, handle);\n      if (cmp != null) return \".\" + namea + cmp;\n    }\n\n\n    if (a.size() - aSkipped != b.size() - bSkipped) {\n      return err(\".size()==\" + a.size() + \",\" + b.size() + \"skipped=\" + aSkipped + \",\" + bSkipped);\n    }\n\n    return null;\n  }\n\n","sourceOld":"  public static String compare(NamedList a, NamedList b, int flags, Map<String, Integer> handle) {\n    boolean ordered = (flags & UNORDERED) == 0;\n\n    int posa = 0, posb = 0;\n    int aSkipped = 0, bSkipped = 0;\n\n    for (; ;) {\n      if (posa >= a.size() || posb >= b.size()) {\n        break;\n      }\n\n      String namea, nameb;\n      Object vala, valb = null;\n\n      int flagsa, flagsb;\n      for (; ;) {\n        namea = a.getName(posa);\n        vala = a.getVal(posa);\n        posa++;\n        flagsa = flags(handle, namea);\n        if ((flagsa & SKIP) != 0) {\n          aSkipped++;\n          continue;\n        }\n        break;\n      }\n\n      if (!ordered) posb = 0;  // reset if not ordered\n\n      while (posb < b.size()) {\n        nameb = b.getName(posb);\n        valb = b.getVal(posb);\n        posb++;\n        flagsb = flags(handle, nameb);\n        if ((flagsb & SKIP) != 0) {\n          bSkipped++;\n          continue;\n        }\n        if (eq(namea, nameb)) {\n          break;\n        }\n        if (ordered) {\n          return err(\".\" + namea + \"!=\" + nameb + \" (unordered or missing)\");\n        }\n        // if unordered, continue until we find the right field.\n      }\n\n      // ok, namea and nameb should be equal here already.\n      if ((flagsa & SKIPVAL) != 0) continue;  // keys matching is enough\n\n      String cmp = compare(vala, valb, flagsa, handle);\n      if (cmp != null) return \".\" + namea + cmp;\n    }\n\n\n    if (a.size() - aSkipped != b.size() - bSkipped) {\n      return err(\".size()==\" + a.size() + \",\" + b.size() + \"skipped=\" + aSkipped + \",\" + bSkipped);\n    }\n\n    return null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/test-framework/src/java/org/apache/solr/BaseDistributedSearchTestCase#compare(NamedList,NamedList,int,Map[String,Integer]).mjava","pathOld":"solr/src/test-framework/org/apache/solr/BaseDistributedSearchTestCase#compare(NamedList,NamedList,int,Map[String,Integer]).mjava","sourceNew":"  public static String compare(NamedList a, NamedList b, int flags, Map<String, Integer> handle) {\n    boolean ordered = (flags & UNORDERED) == 0;\n\n    int posa = 0, posb = 0;\n    int aSkipped = 0, bSkipped = 0;\n\n    for (; ;) {\n      if (posa >= a.size() || posb >= b.size()) {\n        break;\n      }\n\n      String namea, nameb;\n      Object vala, valb = null;\n\n      int flagsa, flagsb;\n      for (; ;) {\n        namea = a.getName(posa);\n        vala = a.getVal(posa);\n        posa++;\n        flagsa = flags(handle, namea);\n        if ((flagsa & SKIP) != 0) {\n          aSkipped++;\n          continue;\n        }\n        break;\n      }\n\n      if (!ordered) posb = 0;  // reset if not ordered\n\n      while (posb < b.size()) {\n        nameb = b.getName(posb);\n        valb = b.getVal(posb);\n        posb++;\n        flagsb = flags(handle, nameb);\n        if ((flagsb & SKIP) != 0) {\n          bSkipped++;\n          continue;\n        }\n        if (eq(namea, nameb)) {\n          break;\n        }\n        if (ordered) {\n          return \".\" + namea + \"!=\" + nameb + \" (unordered or missing)\";\n        }\n        // if unordered, continue until we find the right field.\n      }\n\n      // ok, namea and nameb should be equal here already.\n      if ((flagsa & SKIPVAL) != 0) continue;  // keys matching is enough\n\n      String cmp = compare(vala, valb, flagsa, handle);\n      if (cmp != null) return \".\" + namea + cmp;\n    }\n\n\n    if (a.size() - aSkipped != b.size() - bSkipped) {\n      return \".size()==\" + a.size() + \",\" + b.size() + \"skipped=\" + aSkipped + \",\" + bSkipped;\n    }\n\n    return null;\n  }\n\n","sourceOld":"  public static String compare(NamedList a, NamedList b, int flags, Map<String, Integer> handle) {\n    boolean ordered = (flags & UNORDERED) == 0;\n\n    int posa = 0, posb = 0;\n    int aSkipped = 0, bSkipped = 0;\n\n    for (; ;) {\n      if (posa >= a.size() || posb >= b.size()) {\n        break;\n      }\n\n      String namea, nameb;\n      Object vala, valb = null;\n\n      int flagsa, flagsb;\n      for (; ;) {\n        namea = a.getName(posa);\n        vala = a.getVal(posa);\n        posa++;\n        flagsa = flags(handle, namea);\n        if ((flagsa & SKIP) != 0) {\n          aSkipped++;\n          continue;\n        }\n        break;\n      }\n\n      if (!ordered) posb = 0;  // reset if not ordered\n\n      while (posb < b.size()) {\n        nameb = b.getName(posb);\n        valb = b.getVal(posb);\n        posb++;\n        flagsb = flags(handle, nameb);\n        if ((flagsb & SKIP) != 0) {\n          bSkipped++;\n          continue;\n        }\n        if (eq(namea, nameb)) {\n          break;\n        }\n        if (ordered) {\n          return err(\".\" + namea + \"!=\" + nameb + \" (unordered or missing)\");\n        }\n        // if unordered, continue until we find the right field.\n      }\n\n      // ok, namea and nameb should be equal here already.\n      if ((flagsa & SKIPVAL) != 0) continue;  // keys matching is enough\n\n      String cmp = compare(vala, valb, flagsa, handle);\n      if (cmp != null) return \".\" + namea + cmp;\n    }\n\n\n    if (a.size() - aSkipped != b.size() - bSkipped) {\n      return err(\".size()==\" + a.size() + \",\" + b.size() + \"skipped=\" + aSkipped + \",\" + bSkipped);\n    }\n\n    return null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2c007e7c4cf8c55bc2a5884e315123afaaeec87f","date":1327520966,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/BaseDistributedSearchTestCase#compare(NamedList,NamedList,int,Map[String,Integer]).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/BaseDistributedSearchTestCase#compare(NamedList,NamedList,int,Map[String,Integer]).mjava","sourceNew":"  public static String compare(NamedList a, NamedList b, int flags, Map<String, Integer> handle) {\n//    System.out.println(\"resp a:\" + a);\n//    System.out.println(\"resp b:\" + b);\n    boolean ordered = (flags & UNORDERED) == 0;\n\n    int posa = 0, posb = 0;\n    int aSkipped = 0, bSkipped = 0;\n\n    for (; ;) {\n      if (posa >= a.size() || posb >= b.size()) {\n        break;\n      }\n\n      String namea, nameb;\n      Object vala, valb = null;\n\n      int flagsa, flagsb;\n      for (; ;) {\n        namea = a.getName(posa);\n        vala = a.getVal(posa);\n        posa++;\n        flagsa = flags(handle, namea);\n        if ((flagsa & SKIP) != 0) {\n          aSkipped++;\n          continue;\n        }\n        break;\n      }\n\n      if (!ordered) posb = 0;  // reset if not ordered\n\n      while (posb < b.size()) {\n        nameb = b.getName(posb);\n        valb = b.getVal(posb);\n        posb++;\n        flagsb = flags(handle, nameb);\n        if ((flagsb & SKIP) != 0) {\n          bSkipped++;\n          continue;\n        }\n        if (eq(namea, nameb)) {\n          break;\n        }\n        if (ordered) {\n          return \".\" + namea + \"!=\" + nameb + \" (unordered or missing)\";\n        }\n        // if unordered, continue until we find the right field.\n      }\n\n      // ok, namea and nameb should be equal here already.\n      if ((flagsa & SKIPVAL) != 0) continue;  // keys matching is enough\n\n      String cmp = compare(vala, valb, flagsa, handle);\n      if (cmp != null) return \".\" + namea + cmp;\n    }\n\n\n    if (a.size() - aSkipped != b.size() - bSkipped) {\n      return \".size()==\" + a.size() + \",\" + b.size() + \"skipped=\" + aSkipped + \",\" + bSkipped;\n    }\n\n    return null;\n  }\n\n","sourceOld":"  public static String compare(NamedList a, NamedList b, int flags, Map<String, Integer> handle) {\n    boolean ordered = (flags & UNORDERED) == 0;\n\n    int posa = 0, posb = 0;\n    int aSkipped = 0, bSkipped = 0;\n\n    for (; ;) {\n      if (posa >= a.size() || posb >= b.size()) {\n        break;\n      }\n\n      String namea, nameb;\n      Object vala, valb = null;\n\n      int flagsa, flagsb;\n      for (; ;) {\n        namea = a.getName(posa);\n        vala = a.getVal(posa);\n        posa++;\n        flagsa = flags(handle, namea);\n        if ((flagsa & SKIP) != 0) {\n          aSkipped++;\n          continue;\n        }\n        break;\n      }\n\n      if (!ordered) posb = 0;  // reset if not ordered\n\n      while (posb < b.size()) {\n        nameb = b.getName(posb);\n        valb = b.getVal(posb);\n        posb++;\n        flagsb = flags(handle, nameb);\n        if ((flagsb & SKIP) != 0) {\n          bSkipped++;\n          continue;\n        }\n        if (eq(namea, nameb)) {\n          break;\n        }\n        if (ordered) {\n          return \".\" + namea + \"!=\" + nameb + \" (unordered or missing)\";\n        }\n        // if unordered, continue until we find the right field.\n      }\n\n      // ok, namea and nameb should be equal here already.\n      if ((flagsa & SKIPVAL) != 0) continue;  // keys matching is enough\n\n      String cmp = compare(vala, valb, flagsa, handle);\n      if (cmp != null) return \".\" + namea + cmp;\n    }\n\n\n    if (a.size() - aSkipped != b.size() - bSkipped) {\n      return \".size()==\" + a.size() + \",\" + b.size() + \"skipped=\" + aSkipped + \",\" + bSkipped;\n    }\n\n    return null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/test-framework/src/java/org/apache/solr/BaseDistributedSearchTestCase#compare(NamedList,NamedList,int,Map[String,Integer]).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/BaseDistributedSearchTestCase#compare(NamedList,NamedList,int,Map[String,Integer]).mjava","sourceNew":"  public static String compare(NamedList a, NamedList b, int flags, Map<String, Integer> handle) {\n//    System.out.println(\"resp a:\" + a);\n//    System.out.println(\"resp b:\" + b);\n    boolean ordered = (flags & UNORDERED) == 0;\n\n    int posa = 0, posb = 0;\n    int aSkipped = 0, bSkipped = 0;\n\n    for (; ;) {\n      if (posa >= a.size() || posb >= b.size()) {\n        break;\n      }\n\n      String namea, nameb;\n      Object vala, valb = null;\n\n      int flagsa, flagsb;\n      for (; ;) {\n        namea = a.getName(posa);\n        vala = a.getVal(posa);\n        posa++;\n        flagsa = flags(handle, namea);\n        if ((flagsa & SKIP) != 0) {\n          aSkipped++;\n          continue;\n        }\n        break;\n      }\n\n      if (!ordered) posb = 0;  // reset if not ordered\n\n      while (posb < b.size()) {\n        nameb = b.getName(posb);\n        valb = b.getVal(posb);\n        posb++;\n        flagsb = flags(handle, nameb);\n        if ((flagsb & SKIP) != 0) {\n          bSkipped++;\n          continue;\n        }\n        if (eq(namea, nameb)) {\n          break;\n        }\n        if (ordered) {\n          return \".\" + namea + \"!=\" + nameb + \" (unordered or missing)\";\n        }\n        // if unordered, continue until we find the right field.\n      }\n\n      // ok, namea and nameb should be equal here already.\n      if ((flagsa & SKIPVAL) != 0) continue;  // keys matching is enough\n\n      String cmp = compare(vala, valb, flagsa, handle);\n      if (cmp != null) return \".\" + namea + cmp;\n    }\n\n\n    if (a.size() - aSkipped != b.size() - bSkipped) {\n      return \".size()==\" + a.size() + \",\" + b.size() + \"skipped=\" + aSkipped + \",\" + bSkipped;\n    }\n\n    return null;\n  }\n\n","sourceOld":"  public static String compare(NamedList a, NamedList b, int flags, Map<String, Integer> handle) {\n    boolean ordered = (flags & UNORDERED) == 0;\n\n    int posa = 0, posb = 0;\n    int aSkipped = 0, bSkipped = 0;\n\n    for (; ;) {\n      if (posa >= a.size() || posb >= b.size()) {\n        break;\n      }\n\n      String namea, nameb;\n      Object vala, valb = null;\n\n      int flagsa, flagsb;\n      for (; ;) {\n        namea = a.getName(posa);\n        vala = a.getVal(posa);\n        posa++;\n        flagsa = flags(handle, namea);\n        if ((flagsa & SKIP) != 0) {\n          aSkipped++;\n          continue;\n        }\n        break;\n      }\n\n      if (!ordered) posb = 0;  // reset if not ordered\n\n      while (posb < b.size()) {\n        nameb = b.getName(posb);\n        valb = b.getVal(posb);\n        posb++;\n        flagsb = flags(handle, nameb);\n        if ((flagsb & SKIP) != 0) {\n          bSkipped++;\n          continue;\n        }\n        if (eq(namea, nameb)) {\n          break;\n        }\n        if (ordered) {\n          return \".\" + namea + \"!=\" + nameb + \" (unordered or missing)\";\n        }\n        // if unordered, continue until we find the right field.\n      }\n\n      // ok, namea and nameb should be equal here already.\n      if ((flagsa & SKIPVAL) != 0) continue;  // keys matching is enough\n\n      String cmp = compare(vala, valb, flagsa, handle);\n      if (cmp != null) return \".\" + namea + cmp;\n    }\n\n\n    if (a.size() - aSkipped != b.size() - bSkipped) {\n      return \".size()==\" + a.size() + \",\" + b.size() + \"skipped=\" + aSkipped + \",\" + bSkipped;\n    }\n\n    return null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d22ac6a4146774c1bc8400160fc0b6150294e92","date":1327528604,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/test-framework/src/java/org/apache/solr/BaseDistributedSearchTestCase#compare(NamedList,NamedList,int,Map[String,Integer]).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/BaseDistributedSearchTestCase#compare(NamedList,NamedList,int,Map[String,Integer]).mjava","sourceNew":"  public static String compare(NamedList a, NamedList b, int flags, Map<String, Integer> handle) {\n//    System.out.println(\"resp a:\" + a);\n//    System.out.println(\"resp b:\" + b);\n    boolean ordered = (flags & UNORDERED) == 0;\n\n    int posa = 0, posb = 0;\n    int aSkipped = 0, bSkipped = 0;\n\n    for (; ;) {\n      if (posa >= a.size() || posb >= b.size()) {\n        break;\n      }\n\n      String namea, nameb;\n      Object vala, valb = null;\n\n      int flagsa, flagsb;\n      for (; ;) {\n        namea = a.getName(posa);\n        vala = a.getVal(posa);\n        posa++;\n        flagsa = flags(handle, namea);\n        if ((flagsa & SKIP) != 0) {\n          aSkipped++;\n          continue;\n        }\n        break;\n      }\n\n      if (!ordered) posb = 0;  // reset if not ordered\n\n      while (posb < b.size()) {\n        nameb = b.getName(posb);\n        valb = b.getVal(posb);\n        posb++;\n        flagsb = flags(handle, nameb);\n        if ((flagsb & SKIP) != 0) {\n          bSkipped++;\n          continue;\n        }\n        if (eq(namea, nameb)) {\n          break;\n        }\n        if (ordered) {\n          return \".\" + namea + \"!=\" + nameb + \" (unordered or missing)\";\n        }\n        // if unordered, continue until we find the right field.\n      }\n\n      // ok, namea and nameb should be equal here already.\n      if ((flagsa & SKIPVAL) != 0) continue;  // keys matching is enough\n\n      String cmp = compare(vala, valb, flagsa, handle);\n      if (cmp != null) return \".\" + namea + cmp;\n    }\n\n\n    if (a.size() - aSkipped != b.size() - bSkipped) {\n      return \".size()==\" + a.size() + \",\" + b.size() + \"skipped=\" + aSkipped + \",\" + bSkipped;\n    }\n\n    return null;\n  }\n\n","sourceOld":"  public static String compare(NamedList a, NamedList b, int flags, Map<String, Integer> handle) {\n    boolean ordered = (flags & UNORDERED) == 0;\n\n    int posa = 0, posb = 0;\n    int aSkipped = 0, bSkipped = 0;\n\n    for (; ;) {\n      if (posa >= a.size() || posb >= b.size()) {\n        break;\n      }\n\n      String namea, nameb;\n      Object vala, valb = null;\n\n      int flagsa, flagsb;\n      for (; ;) {\n        namea = a.getName(posa);\n        vala = a.getVal(posa);\n        posa++;\n        flagsa = flags(handle, namea);\n        if ((flagsa & SKIP) != 0) {\n          aSkipped++;\n          continue;\n        }\n        break;\n      }\n\n      if (!ordered) posb = 0;  // reset if not ordered\n\n      while (posb < b.size()) {\n        nameb = b.getName(posb);\n        valb = b.getVal(posb);\n        posb++;\n        flagsb = flags(handle, nameb);\n        if ((flagsb & SKIP) != 0) {\n          bSkipped++;\n          continue;\n        }\n        if (eq(namea, nameb)) {\n          break;\n        }\n        if (ordered) {\n          return \".\" + namea + \"!=\" + nameb + \" (unordered or missing)\";\n        }\n        // if unordered, continue until we find the right field.\n      }\n\n      // ok, namea and nameb should be equal here already.\n      if ((flagsa & SKIPVAL) != 0) continue;  // keys matching is enough\n\n      String cmp = compare(vala, valb, flagsa, handle);\n      if (cmp != null) return \".\" + namea + cmp;\n    }\n\n\n    if (a.size() - aSkipped != b.size() - bSkipped) {\n      return \".size()==\" + a.size() + \",\" + b.size() + \"skipped=\" + aSkipped + \",\" + bSkipped;\n    }\n\n    return null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"663f593f2cd8745f49fd55e9c155255d4a135aea","date":1342261508,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/BaseDistributedSearchTestCase#compare(NamedList,NamedList,int,Map[String,Integer]).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/BaseDistributedSearchTestCase#compare(NamedList,NamedList,int,Map[String,Integer]).mjava","sourceNew":"  public static String compare(NamedList a, NamedList b, int flags, Map<String, Integer> handle) {\n//    System.out.println(\"resp a:\" + a);\n//    System.out.println(\"resp b:\" + b);\n    boolean ordered = (flags & UNORDERED) == 0;\n\n    int posa = 0, posb = 0;\n    int aSkipped = 0, bSkipped = 0;\n\n    for (; ;) {\n      if (posa >= a.size() || posb >= b.size()) {\n        break;\n      }\n\n      String namea = null, nameb = null;\n      Object vala = null, valb = null;\n\n      int flagsa = 0, flagsb = 0;\n      while (posa < a.size()) {\n        namea = a.getName(posa);\n        vala = a.getVal(posa);\n        posa++;\n        flagsa = flags(handle, namea);\n        if ((flagsa & SKIP) != 0) {\n          aSkipped++;\n          continue;\n        }\n        break;\n      }\n\n      if (!ordered) posb = 0;  // reset if not ordered\n\n      while (posb < b.size()) {\n        nameb = b.getName(posb);\n        valb = b.getVal(posb);\n        posb++;\n        flagsb = flags(handle, nameb);\n        if ((flagsb & SKIP) != 0) {\n          bSkipped++;\n          continue;\n        }\n        if (eq(namea, nameb)) {\n          break;\n        }\n        if (ordered) {\n          return \".\" + namea + \"!=\" + nameb + \" (unordered or missing)\";\n        }\n        // if unordered, continue until we find the right field.\n      }\n\n      // ok, namea and nameb should be equal here already.\n      if ((flagsa & SKIPVAL) != 0) continue;  // keys matching is enough\n\n      String cmp = compare(vala, valb, flagsa, handle);\n      if (cmp != null) return \".\" + namea + cmp;\n    }\n\n\n    if (a.size() - aSkipped != b.size() - bSkipped) {\n      return \".size()==\" + a.size() + \",\" + b.size() + \"skipped=\" + aSkipped + \",\" + bSkipped;\n    }\n\n    return null;\n  }\n\n","sourceOld":"  public static String compare(NamedList a, NamedList b, int flags, Map<String, Integer> handle) {\n//    System.out.println(\"resp a:\" + a);\n//    System.out.println(\"resp b:\" + b);\n    boolean ordered = (flags & UNORDERED) == 0;\n\n    int posa = 0, posb = 0;\n    int aSkipped = 0, bSkipped = 0;\n\n    for (; ;) {\n      if (posa >= a.size() || posb >= b.size()) {\n        break;\n      }\n\n      String namea, nameb;\n      Object vala, valb = null;\n\n      int flagsa, flagsb;\n      for (; ;) {\n        namea = a.getName(posa);\n        vala = a.getVal(posa);\n        posa++;\n        flagsa = flags(handle, namea);\n        if ((flagsa & SKIP) != 0) {\n          aSkipped++;\n          continue;\n        }\n        break;\n      }\n\n      if (!ordered) posb = 0;  // reset if not ordered\n\n      while (posb < b.size()) {\n        nameb = b.getName(posb);\n        valb = b.getVal(posb);\n        posb++;\n        flagsb = flags(handle, nameb);\n        if ((flagsb & SKIP) != 0) {\n          bSkipped++;\n          continue;\n        }\n        if (eq(namea, nameb)) {\n          break;\n        }\n        if (ordered) {\n          return \".\" + namea + \"!=\" + nameb + \" (unordered or missing)\";\n        }\n        // if unordered, continue until we find the right field.\n      }\n\n      // ok, namea and nameb should be equal here already.\n      if ((flagsa & SKIPVAL) != 0) continue;  // keys matching is enough\n\n      String cmp = compare(vala, valb, flagsa, handle);\n      if (cmp != null) return \".\" + namea + cmp;\n    }\n\n\n    if (a.size() - aSkipped != b.size() - bSkipped) {\n      return \".size()==\" + a.size() + \",\" + b.size() + \"skipped=\" + aSkipped + \",\" + bSkipped;\n    }\n\n    return null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/test-framework/src/java/org/apache/solr/BaseDistributedSearchTestCase#compare(NamedList,NamedList,int,Map[String,Integer]).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/BaseDistributedSearchTestCase#compare(NamedList,NamedList,int,Map[String,Integer]).mjava","sourceNew":"  public static String compare(NamedList a, NamedList b, int flags, Map<String, Integer> handle) {\n//    System.out.println(\"resp a:\" + a);\n//    System.out.println(\"resp b:\" + b);\n    boolean ordered = (flags & UNORDERED) == 0;\n\n    int posa = 0, posb = 0;\n    int aSkipped = 0, bSkipped = 0;\n\n    for (; ;) {\n      if (posa >= a.size() || posb >= b.size()) {\n        break;\n      }\n\n      String namea = null, nameb = null;\n      Object vala = null, valb = null;\n\n      int flagsa = 0, flagsb = 0;\n      while (posa < a.size()) {\n        namea = a.getName(posa);\n        vala = a.getVal(posa);\n        posa++;\n        flagsa = flags(handle, namea);\n        if ((flagsa & SKIP) != 0) {\n          aSkipped++;\n          continue;\n        }\n        break;\n      }\n\n      if (!ordered) posb = 0;  // reset if not ordered\n\n      while (posb < b.size()) {\n        nameb = b.getName(posb);\n        valb = b.getVal(posb);\n        posb++;\n        flagsb = flags(handle, nameb);\n        if ((flagsb & SKIP) != 0) {\n          bSkipped++;\n          continue;\n        }\n        if (eq(namea, nameb)) {\n          break;\n        }\n        if (ordered) {\n          return \".\" + namea + \"!=\" + nameb + \" (unordered or missing)\";\n        }\n        // if unordered, continue until we find the right field.\n      }\n\n      // ok, namea and nameb should be equal here already.\n      if ((flagsa & SKIPVAL) != 0) continue;  // keys matching is enough\n\n      String cmp = compare(vala, valb, flagsa, handle);\n      if (cmp != null) return \".\" + namea + cmp;\n    }\n\n\n    if (a.size() - aSkipped != b.size() - bSkipped) {\n      return \".size()==\" + a.size() + \",\" + b.size() + \"skipped=\" + aSkipped + \",\" + bSkipped;\n    }\n\n    return null;\n  }\n\n","sourceOld":"  public static String compare(NamedList a, NamedList b, int flags, Map<String, Integer> handle) {\n//    System.out.println(\"resp a:\" + a);\n//    System.out.println(\"resp b:\" + b);\n    boolean ordered = (flags & UNORDERED) == 0;\n\n    int posa = 0, posb = 0;\n    int aSkipped = 0, bSkipped = 0;\n\n    for (; ;) {\n      if (posa >= a.size() || posb >= b.size()) {\n        break;\n      }\n\n      String namea, nameb;\n      Object vala, valb = null;\n\n      int flagsa, flagsb;\n      for (; ;) {\n        namea = a.getName(posa);\n        vala = a.getVal(posa);\n        posa++;\n        flagsa = flags(handle, namea);\n        if ((flagsa & SKIP) != 0) {\n          aSkipped++;\n          continue;\n        }\n        break;\n      }\n\n      if (!ordered) posb = 0;  // reset if not ordered\n\n      while (posb < b.size()) {\n        nameb = b.getName(posb);\n        valb = b.getVal(posb);\n        posb++;\n        flagsb = flags(handle, nameb);\n        if ((flagsb & SKIP) != 0) {\n          bSkipped++;\n          continue;\n        }\n        if (eq(namea, nameb)) {\n          break;\n        }\n        if (ordered) {\n          return \".\" + namea + \"!=\" + nameb + \" (unordered or missing)\";\n        }\n        // if unordered, continue until we find the right field.\n      }\n\n      // ok, namea and nameb should be equal here already.\n      if ((flagsa & SKIPVAL) != 0) continue;  // keys matching is enough\n\n      String cmp = compare(vala, valb, flagsa, handle);\n      if (cmp != null) return \".\" + namea + cmp;\n    }\n\n\n    if (a.size() - aSkipped != b.size() - bSkipped) {\n      return \".size()==\" + a.size() + \",\" + b.size() + \"skipped=\" + aSkipped + \",\" + bSkipped;\n    }\n\n    return null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/test-framework/src/java/org/apache/solr/BaseDistributedSearchTestCase#compare(NamedList,NamedList,int,Map[String,Integer]).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/BaseDistributedSearchTestCase#compare(NamedList,NamedList,int,Map[String,Integer]).mjava","sourceNew":"  public static String compare(NamedList a, NamedList b, int flags, Map<String, Integer> handle) {\n//    System.out.println(\"resp a:\" + a);\n//    System.out.println(\"resp b:\" + b);\n    boolean ordered = (flags & UNORDERED) == 0;\n\n    int posa = 0, posb = 0;\n    int aSkipped = 0, bSkipped = 0;\n\n    for (; ;) {\n      if (posa >= a.size() || posb >= b.size()) {\n        break;\n      }\n\n      String namea = null, nameb = null;\n      Object vala = null, valb = null;\n\n      int flagsa = 0, flagsb = 0;\n      while (posa < a.size()) {\n        namea = a.getName(posa);\n        vala = a.getVal(posa);\n        posa++;\n        flagsa = flags(handle, namea);\n        if ((flagsa & SKIP) != 0) {\n          aSkipped++;\n          continue;\n        }\n        break;\n      }\n\n      if (!ordered) posb = 0;  // reset if not ordered\n\n      while (posb < b.size()) {\n        nameb = b.getName(posb);\n        valb = b.getVal(posb);\n        posb++;\n        flagsb = flags(handle, nameb);\n        if ((flagsb & SKIP) != 0) {\n          bSkipped++;\n          continue;\n        }\n        if (eq(namea, nameb)) {\n          break;\n        }\n        if (ordered) {\n          return \".\" + namea + \"!=\" + nameb + \" (unordered or missing)\";\n        }\n        // if unordered, continue until we find the right field.\n      }\n\n      // ok, namea and nameb should be equal here already.\n      if ((flagsa & SKIPVAL) != 0) continue;  // keys matching is enough\n\n      String cmp = compare(vala, valb, flagsa, handle);\n      if (cmp != null) return \".\" + namea + cmp;\n    }\n\n\n    if (a.size() - aSkipped != b.size() - bSkipped) {\n      return \".size()==\" + a.size() + \",\" + b.size() + \"skipped=\" + aSkipped + \",\" + bSkipped;\n    }\n\n    return null;\n  }\n\n","sourceOld":"  public static String compare(NamedList a, NamedList b, int flags, Map<String, Integer> handle) {\n//    System.out.println(\"resp a:\" + a);\n//    System.out.println(\"resp b:\" + b);\n    boolean ordered = (flags & UNORDERED) == 0;\n\n    int posa = 0, posb = 0;\n    int aSkipped = 0, bSkipped = 0;\n\n    for (; ;) {\n      if (posa >= a.size() || posb >= b.size()) {\n        break;\n      }\n\n      String namea, nameb;\n      Object vala, valb = null;\n\n      int flagsa, flagsb;\n      for (; ;) {\n        namea = a.getName(posa);\n        vala = a.getVal(posa);\n        posa++;\n        flagsa = flags(handle, namea);\n        if ((flagsa & SKIP) != 0) {\n          aSkipped++;\n          continue;\n        }\n        break;\n      }\n\n      if (!ordered) posb = 0;  // reset if not ordered\n\n      while (posb < b.size()) {\n        nameb = b.getName(posb);\n        valb = b.getVal(posb);\n        posb++;\n        flagsb = flags(handle, nameb);\n        if ((flagsb & SKIP) != 0) {\n          bSkipped++;\n          continue;\n        }\n        if (eq(namea, nameb)) {\n          break;\n        }\n        if (ordered) {\n          return \".\" + namea + \"!=\" + nameb + \" (unordered or missing)\";\n        }\n        // if unordered, continue until we find the right field.\n      }\n\n      // ok, namea and nameb should be equal here already.\n      if ((flagsa & SKIPVAL) != 0) continue;  // keys matching is enough\n\n      String cmp = compare(vala, valb, flagsa, handle);\n      if (cmp != null) return \".\" + namea + cmp;\n    }\n\n\n    if (a.size() - aSkipped != b.size() - bSkipped) {\n      return \".size()==\" + a.size() + \",\" + b.size() + \"skipped=\" + aSkipped + \",\" + bSkipped;\n    }\n\n    return null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5c7ba2bec83cc0a507e2cb5a5af99102deb9b01d","date":1344284819,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/BaseDistributedSearchTestCase#compare(NamedList,NamedList,int,Map[String,Integer]).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/BaseDistributedSearchTestCase#compare(NamedList,NamedList,int,Map[String,Integer]).mjava","sourceNew":"  public static String compare(NamedList a, NamedList b, int flags, Map<String, Integer> handle) {\n//    System.out.println(\"resp a:\" + a);\n//    System.out.println(\"resp b:\" + b);\n    boolean ordered = (flags & UNORDERED) == 0;\n\n    if (!ordered) {\n      Map mapA = new HashMap(a.size());\n      for (int i=0; i<a.size(); i++) {\n        Object prev = mapA.put(a.getName(i), a.getVal(i));\n      }\n\n      Map mapB = new HashMap(b.size());\n      for (int i=0; i<b.size(); i++) {\n        Object prev = mapB.put(b.getName(i), b.getVal(i));\n      }\n\n      return compare(mapA, mapB, flags, handle);\n    }\n\n    int posa = 0, posb = 0;\n    int aSkipped = 0, bSkipped = 0;\n\n    for (; ;) {\n      if (posa >= a.size() && posb >= b.size()) {\n        break;\n      }\n\n      String namea = null, nameb = null;\n      Object vala = null, valb = null;\n\n      int flagsa = 0, flagsb = 0;\n      while (posa < a.size()) {\n        namea = a.getName(posa);\n        vala = a.getVal(posa);\n        posa++;\n        flagsa = flags(handle, namea);\n        if ((flagsa & SKIP) != 0) {\n          namea = null; vala = null;\n          aSkipped++;\n          continue;\n        }\n        break;\n      }\n\n      while (posb < b.size()) {\n        nameb = b.getName(posb);\n        valb = b.getVal(posb);\n        posb++;\n        flagsb = flags(handle, nameb);\n        if ((flagsb & SKIP) != 0) {\n          nameb = null; valb = null;\n          bSkipped++;\n          continue;\n        }\n        if (eq(namea, nameb)) {\n          break;\n        }\n        return \".\" + namea + \"!=\" + nameb + \" (unordered or missing)\";\n        // if unordered, continue until we find the right field.\n      }\n\n      // ok, namea and nameb should be equal here already.\n      if ((flagsa & SKIPVAL) != 0) continue;  // keys matching is enough\n\n      String cmp = compare(vala, valb, flagsa, handle);\n      if (cmp != null) return \".\" + namea + cmp;\n    }\n\n\n    if (a.size() - aSkipped != b.size() - bSkipped) {\n      return \".size()==\" + a.size() + \",\" + b.size() + \" skipped=\" + aSkipped + \",\" + bSkipped;\n    }\n\n    return null;\n  }\n\n","sourceOld":"  public static String compare(NamedList a, NamedList b, int flags, Map<String, Integer> handle) {\n//    System.out.println(\"resp a:\" + a);\n//    System.out.println(\"resp b:\" + b);\n    boolean ordered = (flags & UNORDERED) == 0;\n\n    int posa = 0, posb = 0;\n    int aSkipped = 0, bSkipped = 0;\n\n    for (; ;) {\n      if (posa >= a.size() || posb >= b.size()) {\n        break;\n      }\n\n      String namea = null, nameb = null;\n      Object vala = null, valb = null;\n\n      int flagsa = 0, flagsb = 0;\n      while (posa < a.size()) {\n        namea = a.getName(posa);\n        vala = a.getVal(posa);\n        posa++;\n        flagsa = flags(handle, namea);\n        if ((flagsa & SKIP) != 0) {\n          aSkipped++;\n          continue;\n        }\n        break;\n      }\n\n      if (!ordered) posb = 0;  // reset if not ordered\n\n      while (posb < b.size()) {\n        nameb = b.getName(posb);\n        valb = b.getVal(posb);\n        posb++;\n        flagsb = flags(handle, nameb);\n        if ((flagsb & SKIP) != 0) {\n          bSkipped++;\n          continue;\n        }\n        if (eq(namea, nameb)) {\n          break;\n        }\n        if (ordered) {\n          return \".\" + namea + \"!=\" + nameb + \" (unordered or missing)\";\n        }\n        // if unordered, continue until we find the right field.\n      }\n\n      // ok, namea and nameb should be equal here already.\n      if ((flagsa & SKIPVAL) != 0) continue;  // keys matching is enough\n\n      String cmp = compare(vala, valb, flagsa, handle);\n      if (cmp != null) return \".\" + namea + cmp;\n    }\n\n\n    if (a.size() - aSkipped != b.size() - bSkipped) {\n      return \".size()==\" + a.size() + \",\" + b.size() + \"skipped=\" + aSkipped + \",\" + bSkipped;\n    }\n\n    return null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/test-framework/src/java/org/apache/solr/BaseDistributedSearchTestCase#compare(NamedList,NamedList,int,Map[String,Integer]).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/BaseDistributedSearchTestCase#compare(NamedList,NamedList,int,Map[String,Integer]).mjava","sourceNew":"  public static String compare(NamedList a, NamedList b, int flags, Map<String, Integer> handle) {\n//    System.out.println(\"resp a:\" + a);\n//    System.out.println(\"resp b:\" + b);\n    boolean ordered = (flags & UNORDERED) == 0;\n\n    if (!ordered) {\n      Map mapA = new HashMap(a.size());\n      for (int i=0; i<a.size(); i++) {\n        Object prev = mapA.put(a.getName(i), a.getVal(i));\n      }\n\n      Map mapB = new HashMap(b.size());\n      for (int i=0; i<b.size(); i++) {\n        Object prev = mapB.put(b.getName(i), b.getVal(i));\n      }\n\n      return compare(mapA, mapB, flags, handle);\n    }\n\n    int posa = 0, posb = 0;\n    int aSkipped = 0, bSkipped = 0;\n\n    for (; ;) {\n      if (posa >= a.size() && posb >= b.size()) {\n        break;\n      }\n\n      String namea = null, nameb = null;\n      Object vala = null, valb = null;\n\n      int flagsa = 0, flagsb = 0;\n      while (posa < a.size()) {\n        namea = a.getName(posa);\n        vala = a.getVal(posa);\n        posa++;\n        flagsa = flags(handle, namea);\n        if ((flagsa & SKIP) != 0) {\n          namea = null; vala = null;\n          aSkipped++;\n          continue;\n        }\n        break;\n      }\n\n      while (posb < b.size()) {\n        nameb = b.getName(posb);\n        valb = b.getVal(posb);\n        posb++;\n        flagsb = flags(handle, nameb);\n        if ((flagsb & SKIP) != 0) {\n          nameb = null; valb = null;\n          bSkipped++;\n          continue;\n        }\n        if (eq(namea, nameb)) {\n          break;\n        }\n        return \".\" + namea + \"!=\" + nameb + \" (unordered or missing)\";\n        // if unordered, continue until we find the right field.\n      }\n\n      // ok, namea and nameb should be equal here already.\n      if ((flagsa & SKIPVAL) != 0) continue;  // keys matching is enough\n\n      String cmp = compare(vala, valb, flagsa, handle);\n      if (cmp != null) return \".\" + namea + cmp;\n    }\n\n\n    if (a.size() - aSkipped != b.size() - bSkipped) {\n      return \".size()==\" + a.size() + \",\" + b.size() + \" skipped=\" + aSkipped + \",\" + bSkipped;\n    }\n\n    return null;\n  }\n\n","sourceOld":"  public static String compare(NamedList a, NamedList b, int flags, Map<String, Integer> handle) {\n//    System.out.println(\"resp a:\" + a);\n//    System.out.println(\"resp b:\" + b);\n    boolean ordered = (flags & UNORDERED) == 0;\n\n    int posa = 0, posb = 0;\n    int aSkipped = 0, bSkipped = 0;\n\n    for (; ;) {\n      if (posa >= a.size() || posb >= b.size()) {\n        break;\n      }\n\n      String namea = null, nameb = null;\n      Object vala = null, valb = null;\n\n      int flagsa = 0, flagsb = 0;\n      while (posa < a.size()) {\n        namea = a.getName(posa);\n        vala = a.getVal(posa);\n        posa++;\n        flagsa = flags(handle, namea);\n        if ((flagsa & SKIP) != 0) {\n          aSkipped++;\n          continue;\n        }\n        break;\n      }\n\n      if (!ordered) posb = 0;  // reset if not ordered\n\n      while (posb < b.size()) {\n        nameb = b.getName(posb);\n        valb = b.getVal(posb);\n        posb++;\n        flagsb = flags(handle, nameb);\n        if ((flagsb & SKIP) != 0) {\n          bSkipped++;\n          continue;\n        }\n        if (eq(namea, nameb)) {\n          break;\n        }\n        if (ordered) {\n          return \".\" + namea + \"!=\" + nameb + \" (unordered or missing)\";\n        }\n        // if unordered, continue until we find the right field.\n      }\n\n      // ok, namea and nameb should be equal here already.\n      if ((flagsa & SKIPVAL) != 0) continue;  // keys matching is enough\n\n      String cmp = compare(vala, valb, flagsa, handle);\n      if (cmp != null) return \".\" + namea + cmp;\n    }\n\n\n    if (a.size() - aSkipped != b.size() - bSkipped) {\n      return \".size()==\" + a.size() + \",\" + b.size() + \"skipped=\" + aSkipped + \",\" + bSkipped;\n    }\n\n    return null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7869f64c874ebf7f317d22c00baf2b6857797a6","date":1344856617,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/test-framework/src/java/org/apache/solr/BaseDistributedSearchTestCase#compare(NamedList,NamedList,int,Map[String,Integer]).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/BaseDistributedSearchTestCase#compare(NamedList,NamedList,int,Map[String,Integer]).mjava","sourceNew":"  public static String compare(NamedList a, NamedList b, int flags, Map<String, Integer> handle) {\n//    System.out.println(\"resp a:\" + a);\n//    System.out.println(\"resp b:\" + b);\n    boolean ordered = (flags & UNORDERED) == 0;\n\n    if (!ordered) {\n      Map mapA = new HashMap(a.size());\n      for (int i=0; i<a.size(); i++) {\n        Object prev = mapA.put(a.getName(i), a.getVal(i));\n      }\n\n      Map mapB = new HashMap(b.size());\n      for (int i=0; i<b.size(); i++) {\n        Object prev = mapB.put(b.getName(i), b.getVal(i));\n      }\n\n      return compare(mapA, mapB, flags, handle);\n    }\n\n    int posa = 0, posb = 0;\n    int aSkipped = 0, bSkipped = 0;\n\n    for (; ;) {\n      if (posa >= a.size() && posb >= b.size()) {\n        break;\n      }\n\n      String namea = null, nameb = null;\n      Object vala = null, valb = null;\n\n      int flagsa = 0, flagsb = 0;\n      while (posa < a.size()) {\n        namea = a.getName(posa);\n        vala = a.getVal(posa);\n        posa++;\n        flagsa = flags(handle, namea);\n        if ((flagsa & SKIP) != 0) {\n          namea = null; vala = null;\n          aSkipped++;\n          continue;\n        }\n        break;\n      }\n\n      while (posb < b.size()) {\n        nameb = b.getName(posb);\n        valb = b.getVal(posb);\n        posb++;\n        flagsb = flags(handle, nameb);\n        if ((flagsb & SKIP) != 0) {\n          nameb = null; valb = null;\n          bSkipped++;\n          continue;\n        }\n        if (eq(namea, nameb)) {\n          break;\n        }\n        return \".\" + namea + \"!=\" + nameb + \" (unordered or missing)\";\n        // if unordered, continue until we find the right field.\n      }\n\n      // ok, namea and nameb should be equal here already.\n      if ((flagsa & SKIPVAL) != 0) continue;  // keys matching is enough\n\n      String cmp = compare(vala, valb, flagsa, handle);\n      if (cmp != null) return \".\" + namea + cmp;\n    }\n\n\n    if (a.size() - aSkipped != b.size() - bSkipped) {\n      return \".size()==\" + a.size() + \",\" + b.size() + \" skipped=\" + aSkipped + \",\" + bSkipped;\n    }\n\n    return null;\n  }\n\n","sourceOld":"  public static String compare(NamedList a, NamedList b, int flags, Map<String, Integer> handle) {\n//    System.out.println(\"resp a:\" + a);\n//    System.out.println(\"resp b:\" + b);\n    boolean ordered = (flags & UNORDERED) == 0;\n\n    int posa = 0, posb = 0;\n    int aSkipped = 0, bSkipped = 0;\n\n    for (; ;) {\n      if (posa >= a.size() || posb >= b.size()) {\n        break;\n      }\n\n      String namea = null, nameb = null;\n      Object vala = null, valb = null;\n\n      int flagsa = 0, flagsb = 0;\n      while (posa < a.size()) {\n        namea = a.getName(posa);\n        vala = a.getVal(posa);\n        posa++;\n        flagsa = flags(handle, namea);\n        if ((flagsa & SKIP) != 0) {\n          aSkipped++;\n          continue;\n        }\n        break;\n      }\n\n      if (!ordered) posb = 0;  // reset if not ordered\n\n      while (posb < b.size()) {\n        nameb = b.getName(posb);\n        valb = b.getVal(posb);\n        posb++;\n        flagsb = flags(handle, nameb);\n        if ((flagsb & SKIP) != 0) {\n          bSkipped++;\n          continue;\n        }\n        if (eq(namea, nameb)) {\n          break;\n        }\n        if (ordered) {\n          return \".\" + namea + \"!=\" + nameb + \" (unordered or missing)\";\n        }\n        // if unordered, continue until we find the right field.\n      }\n\n      // ok, namea and nameb should be equal here already.\n      if ((flagsa & SKIPVAL) != 0) continue;  // keys matching is enough\n\n      String cmp = compare(vala, valb, flagsa, handle);\n      if (cmp != null) return \".\" + namea + cmp;\n    }\n\n\n    if (a.size() - aSkipped != b.size() - bSkipped) {\n      return \".size()==\" + a.size() + \",\" + b.size() + \"skipped=\" + aSkipped + \",\" + bSkipped;\n    }\n\n    return null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/BaseDistributedSearchTestCase#compare(NamedList,NamedList,int,Map[String,Integer]).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/BaseDistributedSearchTestCase#compare(NamedList,NamedList,int,Map[String,Integer]).mjava","sourceNew":"  public static String compare(NamedList a, NamedList b, int flags, Map<String, Integer> handle) {\n//    System.out.println(\"resp a:\" + a);\n//    System.out.println(\"resp b:\" + b);\n    boolean ordered = (flags & UNORDERED) == 0;\n\n    if (!ordered) {\n      Map mapA = new HashMap(a.size());\n      for (int i=0; i<a.size(); i++) {\n        Object prev = mapA.put(a.getName(i), a.getVal(i));\n      }\n\n      Map mapB = new HashMap(b.size());\n      for (int i=0; i<b.size(); i++) {\n        Object prev = mapB.put(b.getName(i), b.getVal(i));\n      }\n\n      return compare(mapA, mapB, flags, handle);\n    }\n\n    int posa = 0, posb = 0;\n    int aSkipped = 0, bSkipped = 0;\n\n    for (; ;) {\n      if (posa >= a.size() && posb >= b.size()) {\n        break;\n      }\n\n      String namea = null, nameb = null;\n      Object vala = null, valb = null;\n\n      int flagsa = 0, flagsb = 0;\n      while (posa < a.size()) {\n        namea = a.getName(posa);\n        vala = a.getVal(posa);\n        posa++;\n        flagsa = flags(handle, namea);\n        if ((flagsa & SKIP) != 0) {\n          namea = null; vala = null;\n          aSkipped++;\n          continue;\n        }\n        \n        break;\n      }\n\n      while (posb < b.size()) {\n        nameb = b.getName(posb);\n        valb = b.getVal(posb);\n        posb++;\n        flagsb = flags(handle, nameb);\n        if ((flagsb & SKIP) != 0) {\n          nameb = null; valb = null;\n          bSkipped++;\n          continue;\n        }\n        if (eq(namea, nameb)) {\n          break;\n        }\n        return \".\" + namea + \"!=\" + nameb + \" (unordered or missing)\";\n        // if unordered, continue until we find the right field.\n      }\n\n      // ok, namea and nameb should be equal here already.\n      if ((flagsa & SKIPVAL) != 0) continue;  // keys matching is enough\n\n      String cmp = compare(vala, valb, flagsa, handle);\n      if (cmp != null) return \".\" + namea + cmp;\n    }\n\n\n    if (a.size() - aSkipped != b.size() - bSkipped) {\n      return \".size()==\" + a.size() + \",\" + b.size() + \" skipped=\" + aSkipped + \",\" + bSkipped;\n    }\n\n    return null;\n  }\n\n","sourceOld":"  public static String compare(NamedList a, NamedList b, int flags, Map<String, Integer> handle) {\n//    System.out.println(\"resp a:\" + a);\n//    System.out.println(\"resp b:\" + b);\n    boolean ordered = (flags & UNORDERED) == 0;\n\n    if (!ordered) {\n      Map mapA = new HashMap(a.size());\n      for (int i=0; i<a.size(); i++) {\n        Object prev = mapA.put(a.getName(i), a.getVal(i));\n      }\n\n      Map mapB = new HashMap(b.size());\n      for (int i=0; i<b.size(); i++) {\n        Object prev = mapB.put(b.getName(i), b.getVal(i));\n      }\n\n      return compare(mapA, mapB, flags, handle);\n    }\n\n    int posa = 0, posb = 0;\n    int aSkipped = 0, bSkipped = 0;\n\n    for (; ;) {\n      if (posa >= a.size() && posb >= b.size()) {\n        break;\n      }\n\n      String namea = null, nameb = null;\n      Object vala = null, valb = null;\n\n      int flagsa = 0, flagsb = 0;\n      while (posa < a.size()) {\n        namea = a.getName(posa);\n        vala = a.getVal(posa);\n        posa++;\n        flagsa = flags(handle, namea);\n        if ((flagsa & SKIP) != 0) {\n          namea = null; vala = null;\n          aSkipped++;\n          continue;\n        }\n        break;\n      }\n\n      while (posb < b.size()) {\n        nameb = b.getName(posb);\n        valb = b.getVal(posb);\n        posb++;\n        flagsb = flags(handle, nameb);\n        if ((flagsb & SKIP) != 0) {\n          nameb = null; valb = null;\n          bSkipped++;\n          continue;\n        }\n        if (eq(namea, nameb)) {\n          break;\n        }\n        return \".\" + namea + \"!=\" + nameb + \" (unordered or missing)\";\n        // if unordered, continue until we find the right field.\n      }\n\n      // ok, namea and nameb should be equal here already.\n      if ((flagsa & SKIPVAL) != 0) continue;  // keys matching is enough\n\n      String cmp = compare(vala, valb, flagsa, handle);\n      if (cmp != null) return \".\" + namea + cmp;\n    }\n\n\n    if (a.size() - aSkipped != b.size() - bSkipped) {\n      return \".size()==\" + a.size() + \",\" + b.size() + \" skipped=\" + aSkipped + \",\" + bSkipped;\n    }\n\n    return null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6809a6d7924df2c864d6a5863944aff9dfeb372c","date":1591826750,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/BaseDistributedSearchTestCase#compare(NamedList,NamedList,int,Map[String,Integer]).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/BaseDistributedSearchTestCase#compare(NamedList,NamedList,int,Map[String,Integer]).mjava","sourceNew":"  @SuppressWarnings({\"unchecked\"})\n  public static String compare(@SuppressWarnings({\"rawtypes\"})NamedList a,\n                               @SuppressWarnings({\"rawtypes\"})NamedList b, int flags, Map<String, Integer> handle) {\n//    System.out.println(\"resp a:\" + a);\n//    System.out.println(\"resp b:\" + b);\n    boolean ordered = (flags & UNORDERED) == 0;\n\n    if (!ordered) {\n      @SuppressWarnings({\"rawtypes\"})\n      Map mapA = new HashMap(a.size());\n      for (int i=0; i<a.size(); i++) {\n        Object prev = mapA.put(a.getName(i), a.getVal(i));\n      }\n\n      @SuppressWarnings({\"rawtypes\"})\n      Map mapB = new HashMap(b.size());\n      for (int i=0; i<b.size(); i++) {\n        Object prev = mapB.put(b.getName(i), b.getVal(i));\n      }\n\n      return compare(mapA, mapB, flags, handle);\n    }\n\n    int posa = 0, posb = 0;\n    int aSkipped = 0, bSkipped = 0;\n\n    for (; ;) {\n      if (posa >= a.size() && posb >= b.size()) {\n        break;\n      }\n\n      String namea = null, nameb = null;\n      Object vala = null, valb = null;\n\n      int flagsa = 0, flagsb = 0;\n      while (posa < a.size()) {\n        namea = a.getName(posa);\n        vala = a.getVal(posa);\n        posa++;\n        flagsa = flags(handle, namea);\n        if ((flagsa & SKIP) != 0) {\n          namea = null; vala = null;\n          aSkipped++;\n          continue;\n        }\n        \n        break;\n      }\n\n      while (posb < b.size()) {\n        nameb = b.getName(posb);\n        valb = b.getVal(posb);\n        posb++;\n        flagsb = flags(handle, nameb);\n        if ((flagsb & SKIP) != 0) {\n          nameb = null; valb = null;\n          bSkipped++;\n          continue;\n        }\n        if (eq(namea, nameb)) {\n          break;\n        }\n        return \".\" + namea + \"!=\" + nameb + \" (unordered or missing)\";\n        // if unordered, continue until we find the right field.\n      }\n\n      // ok, namea and nameb should be equal here already.\n      if ((flagsa & SKIPVAL) != 0) continue;  // keys matching is enough\n\n      String cmp = compare(vala, valb, flagsa, handle);\n      if (cmp != null) return \".\" + namea + cmp;\n    }\n\n\n    if (a.size() - aSkipped != b.size() - bSkipped) {\n      return \".size()==\" + a.size() + \",\" + b.size() + \" skipped=\" + aSkipped + \",\" + bSkipped;\n    }\n\n    return null;\n  }\n\n","sourceOld":"  public static String compare(NamedList a, NamedList b, int flags, Map<String, Integer> handle) {\n//    System.out.println(\"resp a:\" + a);\n//    System.out.println(\"resp b:\" + b);\n    boolean ordered = (flags & UNORDERED) == 0;\n\n    if (!ordered) {\n      Map mapA = new HashMap(a.size());\n      for (int i=0; i<a.size(); i++) {\n        Object prev = mapA.put(a.getName(i), a.getVal(i));\n      }\n\n      Map mapB = new HashMap(b.size());\n      for (int i=0; i<b.size(); i++) {\n        Object prev = mapB.put(b.getName(i), b.getVal(i));\n      }\n\n      return compare(mapA, mapB, flags, handle);\n    }\n\n    int posa = 0, posb = 0;\n    int aSkipped = 0, bSkipped = 0;\n\n    for (; ;) {\n      if (posa >= a.size() && posb >= b.size()) {\n        break;\n      }\n\n      String namea = null, nameb = null;\n      Object vala = null, valb = null;\n\n      int flagsa = 0, flagsb = 0;\n      while (posa < a.size()) {\n        namea = a.getName(posa);\n        vala = a.getVal(posa);\n        posa++;\n        flagsa = flags(handle, namea);\n        if ((flagsa & SKIP) != 0) {\n          namea = null; vala = null;\n          aSkipped++;\n          continue;\n        }\n        \n        break;\n      }\n\n      while (posb < b.size()) {\n        nameb = b.getName(posb);\n        valb = b.getVal(posb);\n        posb++;\n        flagsb = flags(handle, nameb);\n        if ((flagsb & SKIP) != 0) {\n          nameb = null; valb = null;\n          bSkipped++;\n          continue;\n        }\n        if (eq(namea, nameb)) {\n          break;\n        }\n        return \".\" + namea + \"!=\" + nameb + \" (unordered or missing)\";\n        // if unordered, continue until we find the right field.\n      }\n\n      // ok, namea and nameb should be equal here already.\n      if ((flagsa & SKIPVAL) != 0) continue;  // keys matching is enough\n\n      String cmp = compare(vala, valb, flagsa, handle);\n      if (cmp != null) return \".\" + namea + cmp;\n    }\n\n\n    if (a.size() - aSkipped != b.size() - bSkipped) {\n      return \".size()==\" + a.size() + \",\" + b.size() + \" skipped=\" + aSkipped + \",\" + bSkipped;\n    }\n\n    return null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6809a6d7924df2c864d6a5863944aff9dfeb372c":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"5c7ba2bec83cc0a507e2cb5a5af99102deb9b01d":["663f593f2cd8745f49fd55e9c155255d4a135aea"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["5c7ba2bec83cc0a507e2cb5a5af99102deb9b01d"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["c26f00b574427b55127e869b935845554afde1fa","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["c26f00b574427b55127e869b935845554afde1fa","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":["fe33227f6805edab2036cbb80645cc4e2d1fa424","5c7ba2bec83cc0a507e2cb5a5af99102deb9b01d"],"aba371508186796cc6151d8223a5b4e16d02e26e":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f","663f593f2cd8745f49fd55e9c155255d4a135aea"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f","663f593f2cd8745f49fd55e9c155255d4a135aea"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["aba371508186796cc6151d8223a5b4e16d02e26e","5c7ba2bec83cc0a507e2cb5a5af99102deb9b01d"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["c26f00b574427b55127e869b935845554afde1fa"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"663f593f2cd8745f49fd55e9c155255d4a135aea":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6809a6d7924df2c864d6a5863944aff9dfeb372c"]},"commit2Childs":{"6809a6d7924df2c864d6a5863944aff9dfeb372c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5c7ba2bec83cc0a507e2cb5a5af99102deb9b01d":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f","c7869f64c874ebf7f317d22c00baf2b6857797a6","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["6809a6d7924df2c864d6a5863944aff9dfeb372c"],"c26f00b574427b55127e869b935845554afde1fa":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","0d22ac6a4146774c1bc8400160fc0b6150294e92","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":[],"0d22ac6a4146774c1bc8400160fc0b6150294e92":[],"c7869f64c874ebf7f317d22c00baf2b6857797a6":[],"aba371508186796cc6151d8223a5b4e16d02e26e":["d6f074e73200c07d54f242d3880a8da5a35ff97b"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["c7869f64c874ebf7f317d22c00baf2b6857797a6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":[],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","0d22ac6a4146774c1bc8400160fc0b6150294e92","aba371508186796cc6151d8223a5b4e16d02e26e","fe33227f6805edab2036cbb80645cc4e2d1fa424","663f593f2cd8745f49fd55e9c155255d4a135aea"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"663f593f2cd8745f49fd55e9c155255d4a135aea":["5c7ba2bec83cc0a507e2cb5a5af99102deb9b01d","aba371508186796cc6151d8223a5b4e16d02e26e","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","0d22ac6a4146774c1bc8400160fc0b6150294e92","c7869f64c874ebf7f317d22c00baf2b6857797a6","d6f074e73200c07d54f242d3880a8da5a35ff97b","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}