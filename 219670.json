{"path":"modules/facet/src/test/org/apache/lucene/facet/util/TestScoredDocIDsUtils#createReaderWithNDocs(Random,int,DocumentFactory,Directory).mjava","commits":[{"id":"7a4df66e06e0c3b520d7d5941e1c043076f06f17","date":1309454196,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"modules/facet/src/test/org/apache/lucene/facet/util/TestScoredDocIDsUtils#createReaderWithNDocs(Random,int,DocumentFactory,Directory).mjava","pathOld":"modules/facet/src/test/org/apache/lucene/facet/util/TestScoredDocIDsUtils#createReaderWithNDocs(int,DocumentFactory).mjava","sourceNew":"  static IndexReader createReaderWithNDocs(Random random, int nDocs, DocumentFactory docFactory, Directory dir) throws IOException {\n    // Create the index\n    RandomIndexWriter writer = new RandomIndexWriter(random, dir, newIndexWriterConfig(random, TEST_VERSION_CURRENT, \n        new MockAnalyzer(random, MockTokenizer.KEYWORD, false)));\n    for (int docNum = 0; docNum < nDocs; docNum++) {\n      writer.addDocument(docFactory.getDoc(docNum));\n    }\n    writer.close();\n\n    // Delete documents marked for deletion\n    IndexReader reader = IndexReader.open(dir, false);\n    reader.deleteDocuments(new Term(DocumentFactory.field, DocumentFactory.delTxt));\n    reader.close();\n\n    // Open a fresh read-only reader with the deletions in place\n    return IndexReader.open(dir, true);\n  }\n\n","sourceOld":"  static IndexReader createReaderWithNDocs(int nDocs, DocumentFactory docFactory) throws IOException {\n    Directory ramDir = new RAMDirectory();\n\n    // Create the index\n    IndexWriter writer = new IndexWriter(ramDir, new IndexWriterConfig(TEST_VERSION_CURRENT, new KeywordAnalyzer()));\n    for (int docNum = 0; docNum < nDocs; docNum++) {\n      writer.addDocument(docFactory.getDoc(docNum));\n    }\n    writer.commit();\n    writer.close();\n\n    // Delete documents marked for deletion\n    IndexReader reader = IndexReader.open(ramDir, false);\n    reader.deleteDocuments(new Term(DocumentFactory.field, DocumentFactory.delTxt));\n    reader.close();\n\n    // Open a fresh read-only reader with the deletions in place\n    return IndexReader.open(ramDir, true);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1cbb38b21d3ae707ef21bd5ea237bda83b091ce5","date":1309679041,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"modules/facet/src/test/org/apache/lucene/facet/util/TestScoredDocIDsUtils#createReaderWithNDocs(Random,int,DocumentFactory,Directory).mjava","pathOld":"modules/facet/src/test/org/apache/lucene/facet/util/TestScoredDocIDsUtils#createReaderWithNDocs(Random,int,DocumentFactory,Directory).mjava","sourceNew":"  static IndexReader createReaderWithNDocs(Random random, int nDocs, DocumentFactory docFactory, Directory dir) throws IOException {\n    // Create the index - force log-merge policy since we rely on docs order.\n    RandomIndexWriter writer = new RandomIndexWriter(random, dir,\n        newIndexWriterConfig(random, TEST_VERSION_CURRENT,\n            new MockAnalyzer(random, MockTokenizer.KEYWORD, false))\n            .setMergePolicy(newLogMergePolicy()));\n    for (int docNum = 0; docNum < nDocs; docNum++) {\n      writer.addDocument(docFactory.getDoc(docNum));\n    }\n    writer.close();\n\n    // Delete documents marked for deletion\n    IndexReader reader = IndexReader.open(dir, false);\n    reader.deleteDocuments(new Term(DocumentFactory.field, DocumentFactory.delTxt));\n    reader.close();\n\n    // Open a fresh read-only reader with the deletions in place\n    return IndexReader.open(dir, true);\n  }\n\n","sourceOld":"  static IndexReader createReaderWithNDocs(Random random, int nDocs, DocumentFactory docFactory, Directory dir) throws IOException {\n    // Create the index\n    RandomIndexWriter writer = new RandomIndexWriter(random, dir, newIndexWriterConfig(random, TEST_VERSION_CURRENT, \n        new MockAnalyzer(random, MockTokenizer.KEYWORD, false)));\n    for (int docNum = 0; docNum < nDocs; docNum++) {\n      writer.addDocument(docFactory.getDoc(docNum));\n    }\n    writer.close();\n\n    // Delete documents marked for deletion\n    IndexReader reader = IndexReader.open(dir, false);\n    reader.deleteDocuments(new Term(DocumentFactory.field, DocumentFactory.delTxt));\n    reader.close();\n\n    // Open a fresh read-only reader with the deletions in place\n    return IndexReader.open(dir, true);\n  }\n\n","bugFix":null,"bugIntro":["72584c1b1d38813cce9071e38f9e8481bf4add9a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"72584c1b1d38813cce9071e38f9e8481bf4add9a","date":1309788398,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"modules/facet/src/test/org/apache/lucene/facet/util/TestScoredDocIDsUtils#createReaderWithNDocs(Random,int,DocumentFactory,Directory).mjava","pathOld":"modules/facet/src/test/org/apache/lucene/facet/util/TestScoredDocIDsUtils#createReaderWithNDocs(Random,int,DocumentFactory,Directory).mjava","sourceNew":"  static IndexReader createReaderWithNDocs(Random random, int nDocs, DocumentFactory docFactory, Directory dir) throws IOException {\n    RandomIndexWriter writer = new RandomIndexWriter(random, dir,\n        newIndexWriterConfig(random, TEST_VERSION_CURRENT,\n            new MockAnalyzer(random, MockTokenizer.KEYWORD, false)));\n    for (int docNum = 0; docNum < nDocs; docNum++) {\n      writer.addDocument(docFactory.getDoc(docNum));\n    }\n    writer.close();\n\n    // Delete documents marked for deletion\n    IndexReader reader = IndexReader.open(dir, false);\n    reader.deleteDocuments(new Term(DocumentFactory.field, DocumentFactory.delTxt));\n    reader.close();\n\n    // Open a fresh read-only reader with the deletions in place\n    return IndexReader.open(dir, true);\n  }\n\n","sourceOld":"  static IndexReader createReaderWithNDocs(Random random, int nDocs, DocumentFactory docFactory, Directory dir) throws IOException {\n    // Create the index - force log-merge policy since we rely on docs order.\n    RandomIndexWriter writer = new RandomIndexWriter(random, dir,\n        newIndexWriterConfig(random, TEST_VERSION_CURRENT,\n            new MockAnalyzer(random, MockTokenizer.KEYWORD, false))\n            .setMergePolicy(newLogMergePolicy()));\n    for (int docNum = 0; docNum < nDocs; docNum++) {\n      writer.addDocument(docFactory.getDoc(docNum));\n    }\n    writer.close();\n\n    // Delete documents marked for deletion\n    IndexReader reader = IndexReader.open(dir, false);\n    reader.deleteDocuments(new Term(DocumentFactory.field, DocumentFactory.delTxt));\n    reader.close();\n\n    // Open a fresh read-only reader with the deletions in place\n    return IndexReader.open(dir, true);\n  }\n\n","bugFix":["1cbb38b21d3ae707ef21bd5ea237bda83b091ce5"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"817d8435e9135b756f08ce6710ab0baac51bdf88","date":1309986993,"type":0,"author":"Steven Rowe","isMerge":true,"pathNew":"modules/facet/src/test/org/apache/lucene/facet/util/TestScoredDocIDsUtils#createReaderWithNDocs(Random,int,DocumentFactory,Directory).mjava","pathOld":"/dev/null","sourceNew":"  static IndexReader createReaderWithNDocs(Random random, int nDocs, DocumentFactory docFactory, Directory dir) throws IOException {\n    RandomIndexWriter writer = new RandomIndexWriter(random, dir,\n        newIndexWriterConfig(random, TEST_VERSION_CURRENT,\n            new MockAnalyzer(random, MockTokenizer.KEYWORD, false)));\n    for (int docNum = 0; docNum < nDocs; docNum++) {\n      writer.addDocument(docFactory.getDoc(docNum));\n    }\n    writer.close();\n\n    // Delete documents marked for deletion\n    IndexReader reader = IndexReader.open(dir, false);\n    reader.deleteDocuments(new Term(DocumentFactory.field, DocumentFactory.delTxt));\n    reader.close();\n\n    // Open a fresh read-only reader with the deletions in place\n    return IndexReader.open(dir, true);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d083e83f225b11e5fdd900e83d26ddb385b6955c","date":1310029438,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"modules/facet/src/test/org/apache/lucene/facet/util/TestScoredDocIDsUtils#createReaderWithNDocs(Random,int,DocumentFactory,Directory).mjava","pathOld":"/dev/null","sourceNew":"  static IndexReader createReaderWithNDocs(Random random, int nDocs, DocumentFactory docFactory, Directory dir) throws IOException {\n    RandomIndexWriter writer = new RandomIndexWriter(random, dir,\n        newIndexWriterConfig(random, TEST_VERSION_CURRENT,\n            new MockAnalyzer(random, MockTokenizer.KEYWORD, false)));\n    for (int docNum = 0; docNum < nDocs; docNum++) {\n      writer.addDocument(docFactory.getDoc(docNum));\n    }\n    writer.close();\n\n    // Delete documents marked for deletion\n    IndexReader reader = IndexReader.open(dir, false);\n    reader.deleteDocuments(new Term(DocumentFactory.field, DocumentFactory.delTxt));\n    reader.close();\n\n    // Open a fresh read-only reader with the deletions in place\n    return IndexReader.open(dir, true);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b60058a041168f523085f33ef5c4f9a5306f18b1","date":1323097526,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"modules/facet/src/test/org/apache/lucene/facet/util/TestScoredDocIDsUtils#createReaderWithNDocs(Random,int,DocumentFactory,Directory).mjava","pathOld":"modules/facet/src/test/org/apache/lucene/facet/util/TestScoredDocIDsUtils#createReaderWithNDocs(Random,int,DocumentFactory,Directory).mjava","sourceNew":"  static IndexReader createReaderWithNDocs(Random random, int nDocs, DocumentFactory docFactory, Directory dir) throws IOException {\n    RandomIndexWriter writer = new RandomIndexWriter(random, dir,\n        newIndexWriterConfig(random, TEST_VERSION_CURRENT,\n            new MockAnalyzer(random, MockTokenizer.KEYWORD, false)));\n    for (int docNum = 0; docNum < nDocs; docNum++) {\n      writer.addDocument(docFactory.getDoc(docNum));\n    }\n    // Delete documents marked for deletion\n    writer.deleteDocuments(new Term(DocumentFactory.field, DocumentFactory.delTxt));\n    writer.close();\n\n    // Open a fresh read-only reader with the deletions in place\n    return IndexReader.open(dir);\n  }\n\n","sourceOld":"  static IndexReader createReaderWithNDocs(Random random, int nDocs, DocumentFactory docFactory, Directory dir) throws IOException {\n    RandomIndexWriter writer = new RandomIndexWriter(random, dir,\n        newIndexWriterConfig(random, TEST_VERSION_CURRENT,\n            new MockAnalyzer(random, MockTokenizer.KEYWORD, false)));\n    for (int docNum = 0; docNum < nDocs; docNum++) {\n      writer.addDocument(docFactory.getDoc(docNum));\n    }\n    writer.close();\n\n    // Delete documents marked for deletion\n    IndexReader reader = IndexReader.open(dir, false);\n    reader.deleteDocuments(new Term(DocumentFactory.field, DocumentFactory.delTxt));\n    reader.close();\n\n    // Open a fresh read-only reader with the deletions in place\n    return IndexReader.open(dir, true);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3615ce4a1f785ae1b779244de52c6a7d99227e60","date":1323422019,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"modules/facet/src/test/org/apache/lucene/facet/util/TestScoredDocIDsUtils#createReaderWithNDocs(Random,int,DocumentFactory,Directory).mjava","pathOld":"modules/facet/src/test/org/apache/lucene/facet/util/TestScoredDocIDsUtils#createReaderWithNDocs(Random,int,DocumentFactory,Directory).mjava","sourceNew":"  static IndexReader createReaderWithNDocs(Random random, int nDocs, DocumentFactory docFactory, Directory dir) throws IOException {\n    RandomIndexWriter writer = new RandomIndexWriter(random, dir,\n        newIndexWriterConfig(random, TEST_VERSION_CURRENT,\n            new MockAnalyzer(random, MockTokenizer.KEYWORD, false)));\n    for (int docNum = 0; docNum < nDocs; docNum++) {\n      writer.addDocument(docFactory.getDoc(docNum));\n    }\n    // Delete documents marked for deletion\n    writer.deleteDocuments(new Term(DocumentFactory.field, DocumentFactory.delTxt));\n    writer.close();\n\n    // Open a fresh read-only reader with the deletions in place\n    return IndexReader.open(dir);\n  }\n\n","sourceOld":"  static IndexReader createReaderWithNDocs(Random random, int nDocs, DocumentFactory docFactory, Directory dir) throws IOException {\n    RandomIndexWriter writer = new RandomIndexWriter(random, dir,\n        newIndexWriterConfig(random, TEST_VERSION_CURRENT,\n            new MockAnalyzer(random, MockTokenizer.KEYWORD, false)));\n    for (int docNum = 0; docNum < nDocs; docNum++) {\n      writer.addDocument(docFactory.getDoc(docNum));\n    }\n    writer.close();\n\n    // Delete documents marked for deletion\n    IndexReader reader = IndexReader.open(dir, false);\n    reader.deleteDocuments(new Term(DocumentFactory.field, DocumentFactory.delTxt));\n    reader.close();\n\n    // Open a fresh read-only reader with the deletions in place\n    return IndexReader.open(dir, true);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00","date":1323437438,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"modules/facet/src/test/org/apache/lucene/facet/util/TestScoredDocIDsUtils#createReaderWithNDocs(Random,int,DocumentFactory,Directory).mjava","pathOld":"modules/facet/src/test/org/apache/lucene/facet/util/TestScoredDocIDsUtils#createReaderWithNDocs(Random,int,DocumentFactory,Directory).mjava","sourceNew":"  static IndexReader createReaderWithNDocs(Random random, int nDocs, DocumentFactory docFactory, Directory dir) throws IOException {\n    RandomIndexWriter writer = new RandomIndexWriter(random, dir,\n        newIndexWriterConfig(random, TEST_VERSION_CURRENT,\n            new MockAnalyzer(random, MockTokenizer.KEYWORD, false)));\n    for (int docNum = 0; docNum < nDocs; docNum++) {\n      writer.addDocument(docFactory.getDoc(docNum));\n    }\n    // Delete documents marked for deletion\n    writer.deleteDocuments(new Term(DocumentFactory.field, DocumentFactory.delTxt));\n    writer.close();\n\n    // Open a fresh read-only reader with the deletions in place\n    return IndexReader.open(dir);\n  }\n\n","sourceOld":"  static IndexReader createReaderWithNDocs(Random random, int nDocs, DocumentFactory docFactory, Directory dir) throws IOException {\n    RandomIndexWriter writer = new RandomIndexWriter(random, dir,\n        newIndexWriterConfig(random, TEST_VERSION_CURRENT,\n            new MockAnalyzer(random, MockTokenizer.KEYWORD, false)));\n    for (int docNum = 0; docNum < nDocs; docNum++) {\n      writer.addDocument(docFactory.getDoc(docNum));\n    }\n    writer.close();\n\n    // Delete documents marked for deletion\n    IndexReader reader = IndexReader.open(dir, false);\n    reader.deleteDocuments(new Term(DocumentFactory.field, DocumentFactory.delTxt));\n    reader.close();\n\n    // Open a fresh read-only reader with the deletions in place\n    return IndexReader.open(dir, true);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/util/TestScoredDocIDsUtils#createReaderWithNDocs(Random,int,DocumentFactory,Directory).mjava","pathOld":"modules/facet/src/test/org/apache/lucene/facet/util/TestScoredDocIDsUtils#createReaderWithNDocs(Random,int,DocumentFactory,Directory).mjava","sourceNew":"  static IndexReader createReaderWithNDocs(Random random, int nDocs, DocumentFactory docFactory, Directory dir) throws IOException {\n    RandomIndexWriter writer = new RandomIndexWriter(random, dir,\n        newIndexWriterConfig(random, TEST_VERSION_CURRENT,\n            new MockAnalyzer(random, MockTokenizer.KEYWORD, false)));\n    for (int docNum = 0; docNum < nDocs; docNum++) {\n      writer.addDocument(docFactory.getDoc(docNum));\n    }\n    // Delete documents marked for deletion\n    writer.deleteDocuments(new Term(DocumentFactory.field, DocumentFactory.delTxt));\n    writer.close();\n\n    // Open a fresh read-only reader with the deletions in place\n    return IndexReader.open(dir);\n  }\n\n","sourceOld":"  static IndexReader createReaderWithNDocs(Random random, int nDocs, DocumentFactory docFactory, Directory dir) throws IOException {\n    RandomIndexWriter writer = new RandomIndexWriter(random, dir,\n        newIndexWriterConfig(random, TEST_VERSION_CURRENT,\n            new MockAnalyzer(random, MockTokenizer.KEYWORD, false)));\n    for (int docNum = 0; docNum < nDocs; docNum++) {\n      writer.addDocument(docFactory.getDoc(docNum));\n    }\n    // Delete documents marked for deletion\n    writer.deleteDocuments(new Term(DocumentFactory.field, DocumentFactory.delTxt));\n    writer.close();\n\n    // Open a fresh read-only reader with the deletions in place\n    return IndexReader.open(dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1cbb38b21d3ae707ef21bd5ea237bda83b091ce5":["7a4df66e06e0c3b520d7d5941e1c043076f06f17"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["3615ce4a1f785ae1b779244de52c6a7d99227e60"],"ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00":["72584c1b1d38813cce9071e38f9e8481bf4add9a","3615ce4a1f785ae1b779244de52c6a7d99227e60"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"72584c1b1d38813cce9071e38f9e8481bf4add9a":["1cbb38b21d3ae707ef21bd5ea237bda83b091ce5"],"3615ce4a1f785ae1b779244de52c6a7d99227e60":["72584c1b1d38813cce9071e38f9e8481bf4add9a","b60058a041168f523085f33ef5c4f9a5306f18b1"],"b60058a041168f523085f33ef5c4f9a5306f18b1":["72584c1b1d38813cce9071e38f9e8481bf4add9a"],"7a4df66e06e0c3b520d7d5941e1c043076f06f17":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","72584c1b1d38813cce9071e38f9e8481bf4add9a"],"817d8435e9135b756f08ce6710ab0baac51bdf88":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","72584c1b1d38813cce9071e38f9e8481bf4add9a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b89678825b68eccaf09e6ab71675fc0b0af1e099"]},"commit2Childs":{"1cbb38b21d3ae707ef21bd5ea237bda83b091ce5":["72584c1b1d38813cce9071e38f9e8481bf4add9a"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7a4df66e06e0c3b520d7d5941e1c043076f06f17","d083e83f225b11e5fdd900e83d26ddb385b6955c","817d8435e9135b756f08ce6710ab0baac51bdf88"],"72584c1b1d38813cce9071e38f9e8481bf4add9a":["ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00","3615ce4a1f785ae1b779244de52c6a7d99227e60","b60058a041168f523085f33ef5c4f9a5306f18b1","d083e83f225b11e5fdd900e83d26ddb385b6955c","817d8435e9135b756f08ce6710ab0baac51bdf88"],"3615ce4a1f785ae1b779244de52c6a7d99227e60":["b89678825b68eccaf09e6ab71675fc0b0af1e099","ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00"],"b60058a041168f523085f33ef5c4f9a5306f18b1":["3615ce4a1f785ae1b779244de52c6a7d99227e60"],"7a4df66e06e0c3b520d7d5941e1c043076f06f17":["1cbb38b21d3ae707ef21bd5ea237bda83b091ce5"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":[],"817d8435e9135b756f08ce6710ab0baac51bdf88":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00","d083e83f225b11e5fdd900e83d26ddb385b6955c","817d8435e9135b756f08ce6710ab0baac51bdf88","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}