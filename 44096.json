{"path":"solr/core/src/java/org/apache/solr/util/CryptoKeys#decodeAES(String,String,int).mjava","commits":[{"id":"284866683716f2dec31be6489f8f5d2432074d14","date":1431005603,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/CryptoKeys#decodeAES(String,String,int).mjava","pathOld":"/dev/null","sourceNew":"  public static String decodeAES(String base64CipherTxt, String pwd, final int keySizeBits) {\n    final Charset ASCII = Charset.forName(\"ASCII\");\n    final int INDEX_KEY = 0;\n    final int INDEX_IV = 1;\n    final int ITERATIONS = 1;\n    final int SALT_OFFSET = 8;\n    final int SALT_SIZE = 8;\n    final int CIPHERTEXT_OFFSET = SALT_OFFSET + SALT_SIZE;\n\n    try {\n      byte[] headerSaltAndCipherText = Base64.base64ToByteArray(base64CipherTxt);\n\n      // --- extract salt & encrypted ---\n      // header is \"Salted__\", ASCII encoded, if salt is being used (the default)\n      byte[] salt = Arrays.copyOfRange(\n          headerSaltAndCipherText, SALT_OFFSET, SALT_OFFSET + SALT_SIZE);\n      byte[] encrypted = Arrays.copyOfRange(\n          headerSaltAndCipherText, CIPHERTEXT_OFFSET, headerSaltAndCipherText.length);\n\n      // --- specify cipher and digest for evpBytesTokey method ---\n\n      Cipher aesCBC = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n      MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n\n      // --- create key and IV  ---\n\n      // the IV is useless, OpenSSL might as well have use zero's\n      final byte[][] keyAndIV = evpBytesTokey(\n          keySizeBits / Byte.SIZE,\n          aesCBC.getBlockSize(),\n          md5,\n          salt,\n          pwd.getBytes(ASCII),\n          ITERATIONS);\n\n      SecretKeySpec key = new SecretKeySpec(keyAndIV[INDEX_KEY], \"AES\");\n      IvParameterSpec iv = new IvParameterSpec(keyAndIV[INDEX_IV]);\n\n      // --- initialize cipher instance and decrypt ---\n\n      aesCBC.init(Cipher.DECRYPT_MODE, key, iv);\n      byte[] decrypted = aesCBC.doFinal(encrypted);\n      return new String(decrypted, ASCII);\n    } catch (BadPaddingException e) {\n      // AKA \"something went wrong\"\n      throw new IllegalStateException(\n          \"Bad password, algorithm, mode or padding;\" +\n              \" no salt, wrong number of iterations or corrupted ciphertext.\", e);\n    } catch (IllegalBlockSizeException e) {\n      throw new IllegalStateException(\n          \"Bad algorithm, mode or corrupted (resized) ciphertext.\", e);\n    } catch (GeneralSecurityException e) {\n      throw new IllegalStateException(e);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9d757ce39e75479053df1fc9641acbe360e28376","date":1431020684,"type":4,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/util/CryptoKeys#decodeAES(String,String,int).mjava","sourceNew":null,"sourceOld":"  public static String decodeAES(String base64CipherTxt, String pwd, final int keySizeBits) {\n    final Charset ASCII = Charset.forName(\"ASCII\");\n    final int INDEX_KEY = 0;\n    final int INDEX_IV = 1;\n    final int ITERATIONS = 1;\n    final int SALT_OFFSET = 8;\n    final int SALT_SIZE = 8;\n    final int CIPHERTEXT_OFFSET = SALT_OFFSET + SALT_SIZE;\n\n    try {\n      byte[] headerSaltAndCipherText = Base64.base64ToByteArray(base64CipherTxt);\n\n      // --- extract salt & encrypted ---\n      // header is \"Salted__\", ASCII encoded, if salt is being used (the default)\n      byte[] salt = Arrays.copyOfRange(\n          headerSaltAndCipherText, SALT_OFFSET, SALT_OFFSET + SALT_SIZE);\n      byte[] encrypted = Arrays.copyOfRange(\n          headerSaltAndCipherText, CIPHERTEXT_OFFSET, headerSaltAndCipherText.length);\n\n      // --- specify cipher and digest for evpBytesTokey method ---\n\n      Cipher aesCBC = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n      MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n\n      // --- create key and IV  ---\n\n      // the IV is useless, OpenSSL might as well have use zero's\n      final byte[][] keyAndIV = evpBytesTokey(\n          keySizeBits / Byte.SIZE,\n          aesCBC.getBlockSize(),\n          md5,\n          salt,\n          pwd.getBytes(ASCII),\n          ITERATIONS);\n\n      SecretKeySpec key = new SecretKeySpec(keyAndIV[INDEX_KEY], \"AES\");\n      IvParameterSpec iv = new IvParameterSpec(keyAndIV[INDEX_IV]);\n\n      // --- initialize cipher instance and decrypt ---\n\n      aesCBC.init(Cipher.DECRYPT_MODE, key, iv);\n      byte[] decrypted = aesCBC.doFinal(encrypted);\n      return new String(decrypted, ASCII);\n    } catch (BadPaddingException e) {\n      // AKA \"something went wrong\"\n      throw new IllegalStateException(\n          \"Bad password, algorithm, mode or padding;\" +\n              \" no salt, wrong number of iterations or corrupted ciphertext.\", e);\n    } catch (IllegalBlockSizeException e) {\n      throw new IllegalStateException(\n          \"Bad algorithm, mode or corrupted (resized) ciphertext.\", e);\n    } catch (GeneralSecurityException e) {\n      throw new IllegalStateException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c771b7f862d3df7cfa7208b4f79ac658406d6d15","date":1431023495,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/CryptoKeys#decodeAES(String,String,int).mjava","pathOld":"/dev/null","sourceNew":"  public static String decodeAES(String base64CipherTxt, String pwd, final int keySizeBits) {\n    final Charset ASCII = Charset.forName(\"ASCII\");\n    final int INDEX_KEY = 0;\n    final int INDEX_IV = 1;\n    final int ITERATIONS = 1;\n    final int SALT_OFFSET = 8;\n    final int SALT_SIZE = 8;\n    final int CIPHERTEXT_OFFSET = SALT_OFFSET + SALT_SIZE;\n\n    try {\n      byte[] headerSaltAndCipherText = Base64.base64ToByteArray(base64CipherTxt);\n\n      // --- extract salt & encrypted ---\n      // header is \"Salted__\", ASCII encoded, if salt is being used (the default)\n      byte[] salt = Arrays.copyOfRange(\n          headerSaltAndCipherText, SALT_OFFSET, SALT_OFFSET + SALT_SIZE);\n      byte[] encrypted = Arrays.copyOfRange(\n          headerSaltAndCipherText, CIPHERTEXT_OFFSET, headerSaltAndCipherText.length);\n\n      // --- specify cipher and digest for evpBytesTokey method ---\n\n      Cipher aesCBC = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n      MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n\n      // --- create key and IV  ---\n\n      // the IV is useless, OpenSSL might as well have use zero's\n      final byte[][] keyAndIV = evpBytesTokey(\n          keySizeBits / Byte.SIZE,\n          aesCBC.getBlockSize(),\n          md5,\n          salt,\n          pwd.getBytes(ASCII),\n          ITERATIONS);\n\n      SecretKeySpec key = new SecretKeySpec(keyAndIV[INDEX_KEY], \"AES\");\n      IvParameterSpec iv = new IvParameterSpec(keyAndIV[INDEX_IV]);\n\n      // --- initialize cipher instance and decrypt ---\n\n      aesCBC.init(Cipher.DECRYPT_MODE, key, iv);\n      byte[] decrypted = aesCBC.doFinal(encrypted);\n      return new String(decrypted, ASCII);\n    } catch (BadPaddingException e) {\n      // AKA \"something went wrong\"\n      throw new IllegalStateException(\n          \"Bad password, algorithm, mode or padding;\" +\n              \" no salt, wrong number of iterations or corrupted ciphertext.\", e);\n    } catch (IllegalBlockSizeException e) {\n      throw new IllegalStateException(\n          \"Bad algorithm, mode or corrupted (resized) ciphertext.\", e);\n    } catch (GeneralSecurityException e) {\n      throw new IllegalStateException(e);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b409047f69fb85704c506753bc23a37d7ad37b54","date":1582574830,"type":3,"author":"Mike","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/CryptoKeys#decodeAES(String,String,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/CryptoKeys#decodeAES(String,String,int).mjava","sourceNew":"  public static String decodeAES(String base64CipherTxt, String pwd, final int keySizeBits) {\n    final Charset ASCII = StandardCharsets.US_ASCII;\n    final int INDEX_KEY = 0;\n    final int INDEX_IV = 1;\n    final int ITERATIONS = 1;\n    final int SALT_OFFSET = 8;\n    final int SALT_SIZE = 8;\n    final int CIPHERTEXT_OFFSET = SALT_OFFSET + SALT_SIZE;\n\n    try {\n      byte[] headerSaltAndCipherText = Base64.base64ToByteArray(base64CipherTxt);\n\n      // --- extract salt & encrypted ---\n      // header is \"Salted__\", ASCII encoded, if salt is being used (the default)\n      byte[] salt = Arrays.copyOfRange(\n          headerSaltAndCipherText, SALT_OFFSET, SALT_OFFSET + SALT_SIZE);\n      byte[] encrypted = Arrays.copyOfRange(\n          headerSaltAndCipherText, CIPHERTEXT_OFFSET, headerSaltAndCipherText.length);\n\n      // --- specify cipher and digest for evpBytesTokey method ---\n\n      Cipher aesCBC = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n      MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n\n      // --- create key and IV  ---\n\n      // the IV is useless, OpenSSL might as well have use zero's\n      final byte[][] keyAndIV = evpBytesTokey(\n          keySizeBits / Byte.SIZE,\n          aesCBC.getBlockSize(),\n          md5,\n          salt,\n          pwd.getBytes(ASCII),\n          ITERATIONS);\n\n      SecretKeySpec key = new SecretKeySpec(keyAndIV[INDEX_KEY], \"AES\");\n      IvParameterSpec iv = new IvParameterSpec(keyAndIV[INDEX_IV]);\n\n      // --- initialize cipher instance and decrypt ---\n\n      aesCBC.init(Cipher.DECRYPT_MODE, key, iv);\n      byte[] decrypted = aesCBC.doFinal(encrypted);\n      return new String(decrypted, ASCII);\n    } catch (BadPaddingException e) {\n      // AKA \"something went wrong\"\n      throw new IllegalStateException(\n          \"Bad password, algorithm, mode or padding;\" +\n              \" no salt, wrong number of iterations or corrupted ciphertext.\", e);\n    } catch (IllegalBlockSizeException e) {\n      throw new IllegalStateException(\n          \"Bad algorithm, mode or corrupted (resized) ciphertext.\", e);\n    } catch (GeneralSecurityException e) {\n      throw new IllegalStateException(e);\n    }\n  }\n\n","sourceOld":"  public static String decodeAES(String base64CipherTxt, String pwd, final int keySizeBits) {\n    final Charset ASCII = Charset.forName(\"ASCII\");\n    final int INDEX_KEY = 0;\n    final int INDEX_IV = 1;\n    final int ITERATIONS = 1;\n    final int SALT_OFFSET = 8;\n    final int SALT_SIZE = 8;\n    final int CIPHERTEXT_OFFSET = SALT_OFFSET + SALT_SIZE;\n\n    try {\n      byte[] headerSaltAndCipherText = Base64.base64ToByteArray(base64CipherTxt);\n\n      // --- extract salt & encrypted ---\n      // header is \"Salted__\", ASCII encoded, if salt is being used (the default)\n      byte[] salt = Arrays.copyOfRange(\n          headerSaltAndCipherText, SALT_OFFSET, SALT_OFFSET + SALT_SIZE);\n      byte[] encrypted = Arrays.copyOfRange(\n          headerSaltAndCipherText, CIPHERTEXT_OFFSET, headerSaltAndCipherText.length);\n\n      // --- specify cipher and digest for evpBytesTokey method ---\n\n      Cipher aesCBC = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n      MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n\n      // --- create key and IV  ---\n\n      // the IV is useless, OpenSSL might as well have use zero's\n      final byte[][] keyAndIV = evpBytesTokey(\n          keySizeBits / Byte.SIZE,\n          aesCBC.getBlockSize(),\n          md5,\n          salt,\n          pwd.getBytes(ASCII),\n          ITERATIONS);\n\n      SecretKeySpec key = new SecretKeySpec(keyAndIV[INDEX_KEY], \"AES\");\n      IvParameterSpec iv = new IvParameterSpec(keyAndIV[INDEX_IV]);\n\n      // --- initialize cipher instance and decrypt ---\n\n      aesCBC.init(Cipher.DECRYPT_MODE, key, iv);\n      byte[] decrypted = aesCBC.doFinal(encrypted);\n      return new String(decrypted, ASCII);\n    } catch (BadPaddingException e) {\n      // AKA \"something went wrong\"\n      throw new IllegalStateException(\n          \"Bad password, algorithm, mode or padding;\" +\n              \" no salt, wrong number of iterations or corrupted ciphertext.\", e);\n    } catch (IllegalBlockSizeException e) {\n      throw new IllegalStateException(\n          \"Bad algorithm, mode or corrupted (resized) ciphertext.\", e);\n    } catch (GeneralSecurityException e) {\n      throw new IllegalStateException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b409047f69fb85704c506753bc23a37d7ad37b54":["c771b7f862d3df7cfa7208b4f79ac658406d6d15"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9d757ce39e75479053df1fc9641acbe360e28376":["284866683716f2dec31be6489f8f5d2432074d14"],"284866683716f2dec31be6489f8f5d2432074d14":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c771b7f862d3df7cfa7208b4f79ac658406d6d15":["9d757ce39e75479053df1fc9641acbe360e28376"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b409047f69fb85704c506753bc23a37d7ad37b54"]},"commit2Childs":{"b409047f69fb85704c506753bc23a37d7ad37b54":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["284866683716f2dec31be6489f8f5d2432074d14"],"9d757ce39e75479053df1fc9641acbe360e28376":["c771b7f862d3df7cfa7208b4f79ac658406d6d15"],"284866683716f2dec31be6489f8f5d2432074d14":["9d757ce39e75479053df1fc9641acbe360e28376"],"c771b7f862d3df7cfa7208b4f79ac658406d6d15":["b409047f69fb85704c506753bc23a37d7ad37b54"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}