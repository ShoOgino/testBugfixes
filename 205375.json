{"path":"lucene/src/test-framework/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runTest(String).mjava","commits":[{"id":"7b91922b55d15444d554721b352861d028eb8278","date":1320421415,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test-framework/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runTest(String).mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runTest(String).mjava","sourceNew":"  public void runTest(String testName) throws Exception {\n\n    failed.set(false);\n    addCount.set(0);\n    delCount.set(0);\n    packCount.set(0);\n\n    final long t0 = System.currentTimeMillis();\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final File tempDir = _TestUtil.getTempDir(testName);\n    dir = newFSDirectory(tempDir);\n    ((MockDirectoryWrapper) dir).setCheckIndexOnClose(false); // don't double-checkIndex, we do it ourselves.\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random));\n\n    if (LuceneTestCase.TEST_NIGHTLY) {\n      // newIWConfig makes smallish max seg size, which\n      // results in tons and tons of segments for this test\n      // when run nightly:\n      MergePolicy mp = conf.getMergePolicy();\n      if (mp instanceof TieredMergePolicy) {\n        ((TieredMergePolicy) mp).setMaxMergedSegmentMB(5000.);\n      } else if (mp instanceof LogByteSizeMergePolicy) {\n        ((LogByteSizeMergePolicy) mp).setMaxMergeMB(1000.);\n      } else if (mp instanceof LogMergePolicy) {\n        ((LogMergePolicy) mp).setMaxMergeDocs(100000);\n      }\n    }\n\n    conf.setMergedSegmentWarmer(new IndexWriter.IndexReaderWarmer() {\n      @Override\n      public void warm(IndexReader reader) throws IOException {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now warm merged reader=\" + reader);\n        }\n        final int maxDoc = reader.maxDoc();\n        final Bits liveDocs = reader.getLiveDocs();\n        int sum = 0;\n        final int inc = Math.max(1, maxDoc/50);\n        for(int docID=0;docID<maxDoc;docID += inc) {\n          if (liveDocs == null || liveDocs.get(docID)) {\n            final Document doc = reader.document(docID);\n            sum += doc.getFields().size();\n          }\n        }\n\n        IndexSearcher searcher = newSearcher(reader);\n        sum += searcher.search(new TermQuery(new Term(\"body\", \"united\")), 10).totalHits;\n        searcher.close();\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: warm visited \" + sum + \" fields\");\n        }\n      }\n      });\n    \n    writer = new IndexWriter(dir, conf);\n    if (VERBOSE) {\n      writer.setInfoStream(System.out);\n    }\n    _TestUtil.reduceOpenFiles(writer);\n\n    final ExecutorService es = random.nextBoolean() ? null : Executors.newCachedThreadPool(new NamedThreadFactory(testName));\n\n    doAfterWriter(es);\n\n    final int NUM_INDEX_THREADS = _TestUtil.nextInt(random, 2, 4);\n\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 300 : RANDOM_MULTIPLIER;\n\n    final Set<String> delIDs = Collections.synchronizedSet(new HashSet<String>());\n    final Set<String> delPackIDs = Collections.synchronizedSet(new HashSet<String>());\n    final List<SubDocs> allSubDocs = Collections.synchronizedList(new ArrayList<SubDocs>());\n\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC*1000;\n\n    final Thread[] indexThreads = launchIndexingThreads(docs, NUM_INDEX_THREADS, stopTime, delIDs, delPackIDs, allSubDocs);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE start indexing threads [\" + (System.currentTimeMillis()-t0) + \" ms]\");\n    }\n\n    // Let index build up a bit\n    Thread.sleep(100);\n\n    doSearching(es, stopTime);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: all searching done [\" + (System.currentTimeMillis()-t0) + \" ms]\");\n    }\n    \n    for(int thread=0;thread<indexThreads.length;thread++) {\n      indexThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: done join indexing threads [\" + (System.currentTimeMillis()-t0) + \" ms]; addCount=\" + addCount + \" delCount=\" + delCount);\n    }\n\n    final IndexSearcher s = getFinalSearcher();\n    if (VERBOSE) {\n      System.out.println(\"TEST: finalSearcher=\" + s);\n    }\n    boolean doFail = false;\n\n    // Verify: make sure delIDs are in fact deleted:\n    for(String id : delIDs) {\n      final TopDocs hits = s.search(new TermQuery(new Term(\"docid\", id)), 1);\n      if (hits.totalHits != 0) {\n        System.out.println(\"doc id=\" + id + \" is supposed to be deleted, but got \" + hits.totalHits + \" hits; first docID=\" + hits.scoreDocs[0].doc);\n        doFail = true;\n      }\n    }\n\n    // Verify: make sure delPackIDs are in fact deleted:\n    for(String id : delPackIDs) {\n      final TopDocs hits = s.search(new TermQuery(new Term(\"packID\", id)), 1);\n      if (hits.totalHits != 0) {\n        System.out.println(\"packID=\" + id + \" is supposed to be deleted, but got \" + hits.totalHits + \" matches\");\n        doFail = true;\n      }\n    }\n\n    // Verify: make sure each group of sub-docs are still in docID order:\n    for(SubDocs subDocs : allSubDocs) {\n      TopDocs hits = s.search(new TermQuery(new Term(\"packID\", subDocs.packID)), 20);\n      if (!subDocs.deleted) {\n        // We sort by relevance but the scores should be identical so sort falls back to by docID:\n        if (hits.totalHits != subDocs.subIDs.size()) {\n          System.out.println(\"packID=\" + subDocs.packID + \": expected \" + subDocs.subIDs.size() + \" hits but got \" + hits.totalHits);\n          doFail = true;\n        } else {\n          int lastDocID = -1;\n          int startDocID = -1;\n          for(ScoreDoc scoreDoc : hits.scoreDocs) {\n            final int docID = scoreDoc.doc;\n            if (lastDocID != -1) {\n              assertEquals(1+lastDocID, docID);\n            } else {\n              startDocID = docID;\n            }\n            lastDocID = docID;\n            final Document doc = s.doc(docID);\n            assertEquals(subDocs.packID, doc.get(\"packID\"));\n          }\n\n          lastDocID = startDocID - 1;\n          for(String subID : subDocs.subIDs) {\n            hits = s.search(new TermQuery(new Term(\"docid\", subID)), 1);\n            assertEquals(1, hits.totalHits);\n            final int docID = hits.scoreDocs[0].doc;\n            if (lastDocID != -1) {\n              assertEquals(1+lastDocID, docID);\n            }\n            lastDocID = docID;\n          }\n        }\n      } else {\n        // Pack was deleted -- make sure its docs are\n        // deleted.  We can't verify packID is deleted\n        // because we can re-use packID for update:\n        for(String subID : subDocs.subIDs) {\n          assertEquals(0, s.search(new TermQuery(new Term(\"docid\", subID)), 1).totalHits);\n        }\n      }\n    }\n\n    // Verify: make sure all not-deleted docs are in fact\n    // not deleted:\n    final int endID = Integer.parseInt(docs.nextDoc().get(\"docid\"));\n    docs.close();\n\n    for(int id=0;id<endID;id++) {\n      String stringID = \"\"+id;\n      if (!delIDs.contains(stringID)) {\n        final TopDocs hits = s.search(new TermQuery(new Term(\"docid\", stringID)), 1);\n        if (hits.totalHits != 1) {\n          System.out.println(\"doc id=\" + stringID + \" is not supposed to be deleted, but got hitCount=\" + hits.totalHits);\n          doFail = true;\n        }\n      }\n    }\n    assertFalse(doFail);\n    \n    assertEquals(\"index=\" + writer.segString() + \" addCount=\" + addCount + \" delCount=\" + delCount, addCount.get() - delCount.get(), s.getIndexReader().numDocs());\n    releaseSearcher(s);\n\n    writer.commit();\n\n    assertEquals(\"index=\" + writer.segString() + \" addCount=\" + addCount + \" delCount=\" + delCount, addCount.get() - delCount.get(), writer.numDocs());\n\n    assertFalse(writer.anyNonBulkMerges);\n    doClose();\n    writer.close(false);\n\n    // Cannot shutdown until after writer is closed because\n    // writer has merged segment warmer that uses IS to run\n    // searches, and that IS may be using this es!\n    if (es != null) {\n      es.shutdown();\n      es.awaitTermination(1, TimeUnit.SECONDS);\n    }\n\n    _TestUtil.checkIndex(dir);\n    dir.close();\n    _TestUtil.rmDir(tempDir);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: done [\" + (System.currentTimeMillis()-t0) + \" ms]\");\n    }\n  }\n\n","sourceOld":"  public void runTest(String testName) throws Exception {\n\n    failed.set(false);\n    addCount.set(0);\n    delCount.set(0);\n    packCount.set(0);\n\n    final long t0 = System.currentTimeMillis();\n\n    final String defaultCodec = CodecProvider.getDefault().getDefaultFieldCodec();\n    if (defaultCodec.equals(\"SimpleText\") || defaultCodec.equals(\"Memory\")) {\n      // no\n      CodecProvider.getDefault().setDefaultFieldCodec(\"Standard\");\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final File tempDir = _TestUtil.getTempDir(testName);\n    dir = newFSDirectory(tempDir);\n    ((MockDirectoryWrapper) dir).setCheckIndexOnClose(false); // don't double-checkIndex, we do it ourselves.\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random));\n\n    if (LuceneTestCase.TEST_NIGHTLY) {\n      // newIWConfig makes smallish max seg size, which\n      // results in tons and tons of segments for this test\n      // when run nightly:\n      MergePolicy mp = conf.getMergePolicy();\n      if (mp instanceof TieredMergePolicy) {\n        ((TieredMergePolicy) mp).setMaxMergedSegmentMB(5000.);\n      } else if (mp instanceof LogByteSizeMergePolicy) {\n        ((LogByteSizeMergePolicy) mp).setMaxMergeMB(1000.);\n      } else if (mp instanceof LogMergePolicy) {\n        ((LogMergePolicy) mp).setMaxMergeDocs(100000);\n      }\n    }\n\n    conf.setMergedSegmentWarmer(new IndexWriter.IndexReaderWarmer() {\n      @Override\n      public void warm(IndexReader reader) throws IOException {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now warm merged reader=\" + reader);\n        }\n        final int maxDoc = reader.maxDoc();\n        final Bits liveDocs = reader.getLiveDocs();\n        int sum = 0;\n        final int inc = Math.max(1, maxDoc/50);\n        for(int docID=0;docID<maxDoc;docID += inc) {\n          if (liveDocs == null || liveDocs.get(docID)) {\n            final Document doc = reader.document(docID);\n            sum += doc.getFields().size();\n          }\n        }\n\n        IndexSearcher searcher = newSearcher(reader);\n        sum += searcher.search(new TermQuery(new Term(\"body\", \"united\")), 10).totalHits;\n        searcher.close();\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: warm visited \" + sum + \" fields\");\n        }\n      }\n      });\n    \n    writer = new IndexWriter(dir, conf);\n    if (VERBOSE) {\n      writer.setInfoStream(System.out);\n    }\n    _TestUtil.reduceOpenFiles(writer);\n\n    final ExecutorService es = random.nextBoolean() ? null : Executors.newCachedThreadPool(new NamedThreadFactory(testName));\n\n    doAfterWriter(es);\n\n    final int NUM_INDEX_THREADS = _TestUtil.nextInt(random, 2, 4);\n\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 300 : RANDOM_MULTIPLIER;\n\n    final Set<String> delIDs = Collections.synchronizedSet(new HashSet<String>());\n    final Set<String> delPackIDs = Collections.synchronizedSet(new HashSet<String>());\n    final List<SubDocs> allSubDocs = Collections.synchronizedList(new ArrayList<SubDocs>());\n\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC*1000;\n\n    final Thread[] indexThreads = launchIndexingThreads(docs, NUM_INDEX_THREADS, stopTime, delIDs, delPackIDs, allSubDocs);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE start indexing threads [\" + (System.currentTimeMillis()-t0) + \" ms]\");\n    }\n\n    // Let index build up a bit\n    Thread.sleep(100);\n\n    doSearching(es, stopTime);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: all searching done [\" + (System.currentTimeMillis()-t0) + \" ms]\");\n    }\n    \n    for(int thread=0;thread<indexThreads.length;thread++) {\n      indexThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: done join indexing threads [\" + (System.currentTimeMillis()-t0) + \" ms]; addCount=\" + addCount + \" delCount=\" + delCount);\n    }\n\n    final IndexSearcher s = getFinalSearcher();\n    if (VERBOSE) {\n      System.out.println(\"TEST: finalSearcher=\" + s);\n    }\n    boolean doFail = false;\n\n    // Verify: make sure delIDs are in fact deleted:\n    for(String id : delIDs) {\n      final TopDocs hits = s.search(new TermQuery(new Term(\"docid\", id)), 1);\n      if (hits.totalHits != 0) {\n        System.out.println(\"doc id=\" + id + \" is supposed to be deleted, but got \" + hits.totalHits + \" hits; first docID=\" + hits.scoreDocs[0].doc);\n        doFail = true;\n      }\n    }\n\n    // Verify: make sure delPackIDs are in fact deleted:\n    for(String id : delPackIDs) {\n      final TopDocs hits = s.search(new TermQuery(new Term(\"packID\", id)), 1);\n      if (hits.totalHits != 0) {\n        System.out.println(\"packID=\" + id + \" is supposed to be deleted, but got \" + hits.totalHits + \" matches\");\n        doFail = true;\n      }\n    }\n\n    // Verify: make sure each group of sub-docs are still in docID order:\n    for(SubDocs subDocs : allSubDocs) {\n      TopDocs hits = s.search(new TermQuery(new Term(\"packID\", subDocs.packID)), 20);\n      if (!subDocs.deleted) {\n        // We sort by relevance but the scores should be identical so sort falls back to by docID:\n        if (hits.totalHits != subDocs.subIDs.size()) {\n          System.out.println(\"packID=\" + subDocs.packID + \": expected \" + subDocs.subIDs.size() + \" hits but got \" + hits.totalHits);\n          doFail = true;\n        } else {\n          int lastDocID = -1;\n          int startDocID = -1;\n          for(ScoreDoc scoreDoc : hits.scoreDocs) {\n            final int docID = scoreDoc.doc;\n            if (lastDocID != -1) {\n              assertEquals(1+lastDocID, docID);\n            } else {\n              startDocID = docID;\n            }\n            lastDocID = docID;\n            final Document doc = s.doc(docID);\n            assertEquals(subDocs.packID, doc.get(\"packID\"));\n          }\n\n          lastDocID = startDocID - 1;\n          for(String subID : subDocs.subIDs) {\n            hits = s.search(new TermQuery(new Term(\"docid\", subID)), 1);\n            assertEquals(1, hits.totalHits);\n            final int docID = hits.scoreDocs[0].doc;\n            if (lastDocID != -1) {\n              assertEquals(1+lastDocID, docID);\n            }\n            lastDocID = docID;\n          }\n        }\n      } else {\n        // Pack was deleted -- make sure its docs are\n        // deleted.  We can't verify packID is deleted\n        // because we can re-use packID for update:\n        for(String subID : subDocs.subIDs) {\n          assertEquals(0, s.search(new TermQuery(new Term(\"docid\", subID)), 1).totalHits);\n        }\n      }\n    }\n\n    // Verify: make sure all not-deleted docs are in fact\n    // not deleted:\n    final int endID = Integer.parseInt(docs.nextDoc().get(\"docid\"));\n    docs.close();\n\n    for(int id=0;id<endID;id++) {\n      String stringID = \"\"+id;\n      if (!delIDs.contains(stringID)) {\n        final TopDocs hits = s.search(new TermQuery(new Term(\"docid\", stringID)), 1);\n        if (hits.totalHits != 1) {\n          System.out.println(\"doc id=\" + stringID + \" is not supposed to be deleted, but got hitCount=\" + hits.totalHits);\n          doFail = true;\n        }\n      }\n    }\n    assertFalse(doFail);\n    \n    assertEquals(\"index=\" + writer.segString() + \" addCount=\" + addCount + \" delCount=\" + delCount, addCount.get() - delCount.get(), s.getIndexReader().numDocs());\n    releaseSearcher(s);\n\n    writer.commit();\n\n    assertEquals(\"index=\" + writer.segString() + \" addCount=\" + addCount + \" delCount=\" + delCount, addCount.get() - delCount.get(), writer.numDocs());\n\n    assertFalse(writer.anyNonBulkMerges);\n    doClose();\n    writer.close(false);\n\n    // Cannot shutdown until after writer is closed because\n    // writer has merged segment warmer that uses IS to run\n    // searches, and that IS may be using this es!\n    if (es != null) {\n      es.shutdown();\n      es.awaitTermination(1, TimeUnit.SECONDS);\n    }\n\n    _TestUtil.checkIndex(dir);\n    dir.close();\n    _TestUtil.rmDir(tempDir);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: done [\" + (System.currentTimeMillis()-t0) + \" ms]\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"602693d7e565c9a90b2a23c7142de80411187e6e","date":1320587578,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test-framework/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runTest(String).mjava","pathOld":"lucene/src/test-framework/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runTest(String).mjava","sourceNew":"  public void runTest(String testName) throws Exception {\n\n    failed.set(false);\n    addCount.set(0);\n    delCount.set(0);\n    packCount.set(0);\n\n    final long t0 = System.currentTimeMillis();\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final File tempDir = _TestUtil.getTempDir(testName);\n    dir = newFSDirectory(tempDir);\n    ((MockDirectoryWrapper) dir).setCheckIndexOnClose(false); // don't double-checkIndex, we do it ourselves.\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random));\n\n    if (LuceneTestCase.TEST_NIGHTLY) {\n      // newIWConfig makes smallish max seg size, which\n      // results in tons and tons of segments for this test\n      // when run nightly:\n      MergePolicy mp = conf.getMergePolicy();\n      if (mp instanceof TieredMergePolicy) {\n        ((TieredMergePolicy) mp).setMaxMergedSegmentMB(5000.);\n      } else if (mp instanceof LogByteSizeMergePolicy) {\n        ((LogByteSizeMergePolicy) mp).setMaxMergeMB(1000.);\n      } else if (mp instanceof LogMergePolicy) {\n        ((LogMergePolicy) mp).setMaxMergeDocs(100000);\n      }\n    }\n\n    conf.setMergedSegmentWarmer(new IndexWriter.IndexReaderWarmer() {\n      @Override\n      public void warm(IndexReader reader) throws IOException {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now warm merged reader=\" + reader);\n        }\n        final int maxDoc = reader.maxDoc();\n        final Bits liveDocs = reader.getLiveDocs();\n        int sum = 0;\n        final int inc = Math.max(1, maxDoc/50);\n        for(int docID=0;docID<maxDoc;docID += inc) {\n          if (liveDocs == null || liveDocs.get(docID)) {\n            final Document doc = reader.document(docID);\n            sum += doc.getFields().size();\n          }\n        }\n\n        IndexSearcher searcher = newSearcher(reader);\n        sum += searcher.search(new TermQuery(new Term(\"body\", \"united\")), 10).totalHits;\n        searcher.close();\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: warm visited \" + sum + \" fields\");\n        }\n      }\n      });\n\n    writer = new IndexWriter(dir, conf);\n    if (VERBOSE) {\n      writer.setInfoStream(System.out);\n    }\n    _TestUtil.reduceOpenFiles(writer);\n\n    final ExecutorService es = random.nextBoolean() ? null : Executors.newCachedThreadPool(new NamedThreadFactory(testName));\n\n    doAfterWriter(es);\n\n    final int NUM_INDEX_THREADS = _TestUtil.nextInt(random, 2, 4);\n\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 300 : RANDOM_MULTIPLIER;\n\n    final Set<String> delIDs = Collections.synchronizedSet(new HashSet<String>());\n    final Set<String> delPackIDs = Collections.synchronizedSet(new HashSet<String>());\n    final List<SubDocs> allSubDocs = Collections.synchronizedList(new ArrayList<SubDocs>());\n\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC*1000;\n\n    final Thread[] indexThreads = launchIndexingThreads(docs, NUM_INDEX_THREADS, stopTime, delIDs, delPackIDs, allSubDocs);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE start indexing threads [\" + (System.currentTimeMillis()-t0) + \" ms]\");\n    }\n\n    // Let index build up a bit\n    Thread.sleep(100);\n\n    doSearching(es, stopTime);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: all searching done [\" + (System.currentTimeMillis()-t0) + \" ms]\");\n    }\n    \n    for(int thread=0;thread<indexThreads.length;thread++) {\n      indexThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: done join indexing threads [\" + (System.currentTimeMillis()-t0) + \" ms]; addCount=\" + addCount + \" delCount=\" + delCount);\n    }\n\n    final IndexSearcher s = getFinalSearcher();\n    if (VERBOSE) {\n      System.out.println(\"TEST: finalSearcher=\" + s);\n    }\n\n    assertFalse(failed.get());\n\n    boolean doFail = false;\n\n    // Verify: make sure delIDs are in fact deleted:\n    for(String id : delIDs) {\n      final TopDocs hits = s.search(new TermQuery(new Term(\"docid\", id)), 1);\n      if (hits.totalHits != 0) {\n        System.out.println(\"doc id=\" + id + \" is supposed to be deleted, but got \" + hits.totalHits + \" hits; first docID=\" + hits.scoreDocs[0].doc);\n        doFail = true;\n      }\n    }\n\n    // Verify: make sure delPackIDs are in fact deleted:\n    for(String id : delPackIDs) {\n      final TopDocs hits = s.search(new TermQuery(new Term(\"packID\", id)), 1);\n      if (hits.totalHits != 0) {\n        System.out.println(\"packID=\" + id + \" is supposed to be deleted, but got \" + hits.totalHits + \" matches\");\n        doFail = true;\n      }\n    }\n\n    // Verify: make sure each group of sub-docs are still in docID order:\n    for(SubDocs subDocs : allSubDocs) {\n      TopDocs hits = s.search(new TermQuery(new Term(\"packID\", subDocs.packID)), 20);\n      if (!subDocs.deleted) {\n        // We sort by relevance but the scores should be identical so sort falls back to by docID:\n        if (hits.totalHits != subDocs.subIDs.size()) {\n          System.out.println(\"packID=\" + subDocs.packID + \": expected \" + subDocs.subIDs.size() + \" hits but got \" + hits.totalHits);\n          doFail = true;\n        } else {\n          int lastDocID = -1;\n          int startDocID = -1;\n          for(ScoreDoc scoreDoc : hits.scoreDocs) {\n            final int docID = scoreDoc.doc;\n            if (lastDocID != -1) {\n              assertEquals(1+lastDocID, docID);\n            } else {\n              startDocID = docID;\n            }\n            lastDocID = docID;\n            final Document doc = s.doc(docID);\n            assertEquals(subDocs.packID, doc.get(\"packID\"));\n          }\n\n          lastDocID = startDocID - 1;\n          for(String subID : subDocs.subIDs) {\n            hits = s.search(new TermQuery(new Term(\"docid\", subID)), 1);\n            assertEquals(1, hits.totalHits);\n            final int docID = hits.scoreDocs[0].doc;\n            if (lastDocID != -1) {\n              assertEquals(1+lastDocID, docID);\n            }\n            lastDocID = docID;\n          }\n        }\n      } else {\n        // Pack was deleted -- make sure its docs are\n        // deleted.  We can't verify packID is deleted\n        // because we can re-use packID for update:\n        for(String subID : subDocs.subIDs) {\n          assertEquals(0, s.search(new TermQuery(new Term(\"docid\", subID)), 1).totalHits);\n        }\n      }\n    }\n\n    // Verify: make sure all not-deleted docs are in fact\n    // not deleted:\n    final int endID = Integer.parseInt(docs.nextDoc().get(\"docid\"));\n    docs.close();\n\n    for(int id=0;id<endID;id++) {\n      String stringID = \"\"+id;\n      if (!delIDs.contains(stringID)) {\n        final TopDocs hits = s.search(new TermQuery(new Term(\"docid\", stringID)), 1);\n        if (hits.totalHits != 1) {\n          System.out.println(\"doc id=\" + stringID + \" is not supposed to be deleted, but got hitCount=\" + hits.totalHits);\n          doFail = true;\n        }\n      }\n    }\n    assertFalse(doFail);\n    \n    assertEquals(\"index=\" + writer.segString() + \" addCount=\" + addCount + \" delCount=\" + delCount, addCount.get() - delCount.get(), s.getIndexReader().numDocs());\n    releaseSearcher(s);\n\n    writer.commit();\n\n    assertEquals(\"index=\" + writer.segString() + \" addCount=\" + addCount + \" delCount=\" + delCount, addCount.get() - delCount.get(), writer.numDocs());\n\n    assertFalse(writer.anyNonBulkMerges);\n    doClose();\n    writer.close(false);\n\n    // Cannot shutdown until after writer is closed because\n    // writer has merged segment warmer that uses IS to run\n    // searches, and that IS may be using this es!\n    if (es != null) {\n      es.shutdown();\n      es.awaitTermination(1, TimeUnit.SECONDS);\n    }\n\n    _TestUtil.checkIndex(dir);\n    dir.close();\n    _TestUtil.rmDir(tempDir);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: done [\" + (System.currentTimeMillis()-t0) + \" ms]\");\n    }\n  }\n\n","sourceOld":"  public void runTest(String testName) throws Exception {\n\n    failed.set(false);\n    addCount.set(0);\n    delCount.set(0);\n    packCount.set(0);\n\n    final long t0 = System.currentTimeMillis();\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final File tempDir = _TestUtil.getTempDir(testName);\n    dir = newFSDirectory(tempDir);\n    ((MockDirectoryWrapper) dir).setCheckIndexOnClose(false); // don't double-checkIndex, we do it ourselves.\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random));\n\n    if (LuceneTestCase.TEST_NIGHTLY) {\n      // newIWConfig makes smallish max seg size, which\n      // results in tons and tons of segments for this test\n      // when run nightly:\n      MergePolicy mp = conf.getMergePolicy();\n      if (mp instanceof TieredMergePolicy) {\n        ((TieredMergePolicy) mp).setMaxMergedSegmentMB(5000.);\n      } else if (mp instanceof LogByteSizeMergePolicy) {\n        ((LogByteSizeMergePolicy) mp).setMaxMergeMB(1000.);\n      } else if (mp instanceof LogMergePolicy) {\n        ((LogMergePolicy) mp).setMaxMergeDocs(100000);\n      }\n    }\n\n    conf.setMergedSegmentWarmer(new IndexWriter.IndexReaderWarmer() {\n      @Override\n      public void warm(IndexReader reader) throws IOException {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now warm merged reader=\" + reader);\n        }\n        final int maxDoc = reader.maxDoc();\n        final Bits liveDocs = reader.getLiveDocs();\n        int sum = 0;\n        final int inc = Math.max(1, maxDoc/50);\n        for(int docID=0;docID<maxDoc;docID += inc) {\n          if (liveDocs == null || liveDocs.get(docID)) {\n            final Document doc = reader.document(docID);\n            sum += doc.getFields().size();\n          }\n        }\n\n        IndexSearcher searcher = newSearcher(reader);\n        sum += searcher.search(new TermQuery(new Term(\"body\", \"united\")), 10).totalHits;\n        searcher.close();\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: warm visited \" + sum + \" fields\");\n        }\n      }\n      });\n    \n    writer = new IndexWriter(dir, conf);\n    if (VERBOSE) {\n      writer.setInfoStream(System.out);\n    }\n    _TestUtil.reduceOpenFiles(writer);\n\n    final ExecutorService es = random.nextBoolean() ? null : Executors.newCachedThreadPool(new NamedThreadFactory(testName));\n\n    doAfterWriter(es);\n\n    final int NUM_INDEX_THREADS = _TestUtil.nextInt(random, 2, 4);\n\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 300 : RANDOM_MULTIPLIER;\n\n    final Set<String> delIDs = Collections.synchronizedSet(new HashSet<String>());\n    final Set<String> delPackIDs = Collections.synchronizedSet(new HashSet<String>());\n    final List<SubDocs> allSubDocs = Collections.synchronizedList(new ArrayList<SubDocs>());\n\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC*1000;\n\n    final Thread[] indexThreads = launchIndexingThreads(docs, NUM_INDEX_THREADS, stopTime, delIDs, delPackIDs, allSubDocs);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE start indexing threads [\" + (System.currentTimeMillis()-t0) + \" ms]\");\n    }\n\n    // Let index build up a bit\n    Thread.sleep(100);\n\n    doSearching(es, stopTime);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: all searching done [\" + (System.currentTimeMillis()-t0) + \" ms]\");\n    }\n    \n    for(int thread=0;thread<indexThreads.length;thread++) {\n      indexThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: done join indexing threads [\" + (System.currentTimeMillis()-t0) + \" ms]; addCount=\" + addCount + \" delCount=\" + delCount);\n    }\n\n    final IndexSearcher s = getFinalSearcher();\n    if (VERBOSE) {\n      System.out.println(\"TEST: finalSearcher=\" + s);\n    }\n    boolean doFail = false;\n\n    // Verify: make sure delIDs are in fact deleted:\n    for(String id : delIDs) {\n      final TopDocs hits = s.search(new TermQuery(new Term(\"docid\", id)), 1);\n      if (hits.totalHits != 0) {\n        System.out.println(\"doc id=\" + id + \" is supposed to be deleted, but got \" + hits.totalHits + \" hits; first docID=\" + hits.scoreDocs[0].doc);\n        doFail = true;\n      }\n    }\n\n    // Verify: make sure delPackIDs are in fact deleted:\n    for(String id : delPackIDs) {\n      final TopDocs hits = s.search(new TermQuery(new Term(\"packID\", id)), 1);\n      if (hits.totalHits != 0) {\n        System.out.println(\"packID=\" + id + \" is supposed to be deleted, but got \" + hits.totalHits + \" matches\");\n        doFail = true;\n      }\n    }\n\n    // Verify: make sure each group of sub-docs are still in docID order:\n    for(SubDocs subDocs : allSubDocs) {\n      TopDocs hits = s.search(new TermQuery(new Term(\"packID\", subDocs.packID)), 20);\n      if (!subDocs.deleted) {\n        // We sort by relevance but the scores should be identical so sort falls back to by docID:\n        if (hits.totalHits != subDocs.subIDs.size()) {\n          System.out.println(\"packID=\" + subDocs.packID + \": expected \" + subDocs.subIDs.size() + \" hits but got \" + hits.totalHits);\n          doFail = true;\n        } else {\n          int lastDocID = -1;\n          int startDocID = -1;\n          for(ScoreDoc scoreDoc : hits.scoreDocs) {\n            final int docID = scoreDoc.doc;\n            if (lastDocID != -1) {\n              assertEquals(1+lastDocID, docID);\n            } else {\n              startDocID = docID;\n            }\n            lastDocID = docID;\n            final Document doc = s.doc(docID);\n            assertEquals(subDocs.packID, doc.get(\"packID\"));\n          }\n\n          lastDocID = startDocID - 1;\n          for(String subID : subDocs.subIDs) {\n            hits = s.search(new TermQuery(new Term(\"docid\", subID)), 1);\n            assertEquals(1, hits.totalHits);\n            final int docID = hits.scoreDocs[0].doc;\n            if (lastDocID != -1) {\n              assertEquals(1+lastDocID, docID);\n            }\n            lastDocID = docID;\n          }\n        }\n      } else {\n        // Pack was deleted -- make sure its docs are\n        // deleted.  We can't verify packID is deleted\n        // because we can re-use packID for update:\n        for(String subID : subDocs.subIDs) {\n          assertEquals(0, s.search(new TermQuery(new Term(\"docid\", subID)), 1).totalHits);\n        }\n      }\n    }\n\n    // Verify: make sure all not-deleted docs are in fact\n    // not deleted:\n    final int endID = Integer.parseInt(docs.nextDoc().get(\"docid\"));\n    docs.close();\n\n    for(int id=0;id<endID;id++) {\n      String stringID = \"\"+id;\n      if (!delIDs.contains(stringID)) {\n        final TopDocs hits = s.search(new TermQuery(new Term(\"docid\", stringID)), 1);\n        if (hits.totalHits != 1) {\n          System.out.println(\"doc id=\" + stringID + \" is not supposed to be deleted, but got hitCount=\" + hits.totalHits);\n          doFail = true;\n        }\n      }\n    }\n    assertFalse(doFail);\n    \n    assertEquals(\"index=\" + writer.segString() + \" addCount=\" + addCount + \" delCount=\" + delCount, addCount.get() - delCount.get(), s.getIndexReader().numDocs());\n    releaseSearcher(s);\n\n    writer.commit();\n\n    assertEquals(\"index=\" + writer.segString() + \" addCount=\" + addCount + \" delCount=\" + delCount, addCount.get() - delCount.get(), writer.numDocs());\n\n    assertFalse(writer.anyNonBulkMerges);\n    doClose();\n    writer.close(false);\n\n    // Cannot shutdown until after writer is closed because\n    // writer has merged segment warmer that uses IS to run\n    // searches, and that IS may be using this es!\n    if (es != null) {\n      es.shutdown();\n      es.awaitTermination(1, TimeUnit.SECONDS);\n    }\n\n    _TestUtil.checkIndex(dir);\n    dir.close();\n    _TestUtil.rmDir(tempDir);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: done [\" + (System.currentTimeMillis()-t0) + \" ms]\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"06584e6e98d592b34e1329b384182f368d2025e8","date":1320850353,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test-framework/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runTest(String).mjava","pathOld":"lucene/src/test-framework/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runTest(String).mjava","sourceNew":"  public void runTest(String testName) throws Exception {\n\n    failed.set(false);\n    addCount.set(0);\n    delCount.set(0);\n    packCount.set(0);\n\n    final long t0 = System.currentTimeMillis();\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final File tempDir = _TestUtil.getTempDir(testName);\n    dir = newFSDirectory(tempDir);\n    ((MockDirectoryWrapper) dir).setCheckIndexOnClose(false); // don't double-checkIndex, we do it ourselves.\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).\n        setInfoStream(new FailOnNonBulkMergesInfoStream());\n\n    if (LuceneTestCase.TEST_NIGHTLY) {\n      // newIWConfig makes smallish max seg size, which\n      // results in tons and tons of segments for this test\n      // when run nightly:\n      MergePolicy mp = conf.getMergePolicy();\n      if (mp instanceof TieredMergePolicy) {\n        ((TieredMergePolicy) mp).setMaxMergedSegmentMB(5000.);\n      } else if (mp instanceof LogByteSizeMergePolicy) {\n        ((LogByteSizeMergePolicy) mp).setMaxMergeMB(1000.);\n      } else if (mp instanceof LogMergePolicy) {\n        ((LogMergePolicy) mp).setMaxMergeDocs(100000);\n      }\n    }\n\n    conf.setMergedSegmentWarmer(new IndexWriter.IndexReaderWarmer() {\n      @Override\n      public void warm(IndexReader reader) throws IOException {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now warm merged reader=\" + reader);\n        }\n        final int maxDoc = reader.maxDoc();\n        final Bits liveDocs = reader.getLiveDocs();\n        int sum = 0;\n        final int inc = Math.max(1, maxDoc/50);\n        for(int docID=0;docID<maxDoc;docID += inc) {\n          if (liveDocs == null || liveDocs.get(docID)) {\n            final Document doc = reader.document(docID);\n            sum += doc.getFields().size();\n          }\n        }\n\n        IndexSearcher searcher = newSearcher(reader);\n        sum += searcher.search(new TermQuery(new Term(\"body\", \"united\")), 10).totalHits;\n        searcher.close();\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: warm visited \" + sum + \" fields\");\n        }\n      }\n      });\n\n    writer = new IndexWriter(dir, conf);\n    _TestUtil.reduceOpenFiles(writer);\n\n    final ExecutorService es = random.nextBoolean() ? null : Executors.newCachedThreadPool(new NamedThreadFactory(testName));\n\n    doAfterWriter(es);\n\n    final int NUM_INDEX_THREADS = _TestUtil.nextInt(random, 2, 4);\n\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 300 : RANDOM_MULTIPLIER;\n\n    final Set<String> delIDs = Collections.synchronizedSet(new HashSet<String>());\n    final Set<String> delPackIDs = Collections.synchronizedSet(new HashSet<String>());\n    final List<SubDocs> allSubDocs = Collections.synchronizedList(new ArrayList<SubDocs>());\n\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC*1000;\n\n    final Thread[] indexThreads = launchIndexingThreads(docs, NUM_INDEX_THREADS, stopTime, delIDs, delPackIDs, allSubDocs);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE start indexing threads [\" + (System.currentTimeMillis()-t0) + \" ms]\");\n    }\n\n    // Let index build up a bit\n    Thread.sleep(100);\n\n    doSearching(es, stopTime);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: all searching done [\" + (System.currentTimeMillis()-t0) + \" ms]\");\n    }\n    \n    for(int thread=0;thread<indexThreads.length;thread++) {\n      indexThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: done join indexing threads [\" + (System.currentTimeMillis()-t0) + \" ms]; addCount=\" + addCount + \" delCount=\" + delCount);\n    }\n\n    final IndexSearcher s = getFinalSearcher();\n    if (VERBOSE) {\n      System.out.println(\"TEST: finalSearcher=\" + s);\n    }\n\n    assertFalse(failed.get());\n\n    boolean doFail = false;\n\n    // Verify: make sure delIDs are in fact deleted:\n    for(String id : delIDs) {\n      final TopDocs hits = s.search(new TermQuery(new Term(\"docid\", id)), 1);\n      if (hits.totalHits != 0) {\n        System.out.println(\"doc id=\" + id + \" is supposed to be deleted, but got \" + hits.totalHits + \" hits; first docID=\" + hits.scoreDocs[0].doc);\n        doFail = true;\n      }\n    }\n\n    // Verify: make sure delPackIDs are in fact deleted:\n    for(String id : delPackIDs) {\n      final TopDocs hits = s.search(new TermQuery(new Term(\"packID\", id)), 1);\n      if (hits.totalHits != 0) {\n        System.out.println(\"packID=\" + id + \" is supposed to be deleted, but got \" + hits.totalHits + \" matches\");\n        doFail = true;\n      }\n    }\n\n    // Verify: make sure each group of sub-docs are still in docID order:\n    for(SubDocs subDocs : allSubDocs) {\n      TopDocs hits = s.search(new TermQuery(new Term(\"packID\", subDocs.packID)), 20);\n      if (!subDocs.deleted) {\n        // We sort by relevance but the scores should be identical so sort falls back to by docID:\n        if (hits.totalHits != subDocs.subIDs.size()) {\n          System.out.println(\"packID=\" + subDocs.packID + \": expected \" + subDocs.subIDs.size() + \" hits but got \" + hits.totalHits);\n          doFail = true;\n        } else {\n          int lastDocID = -1;\n          int startDocID = -1;\n          for(ScoreDoc scoreDoc : hits.scoreDocs) {\n            final int docID = scoreDoc.doc;\n            if (lastDocID != -1) {\n              assertEquals(1+lastDocID, docID);\n            } else {\n              startDocID = docID;\n            }\n            lastDocID = docID;\n            final Document doc = s.doc(docID);\n            assertEquals(subDocs.packID, doc.get(\"packID\"));\n          }\n\n          lastDocID = startDocID - 1;\n          for(String subID : subDocs.subIDs) {\n            hits = s.search(new TermQuery(new Term(\"docid\", subID)), 1);\n            assertEquals(1, hits.totalHits);\n            final int docID = hits.scoreDocs[0].doc;\n            if (lastDocID != -1) {\n              assertEquals(1+lastDocID, docID);\n            }\n            lastDocID = docID;\n          }\n        }\n      } else {\n        // Pack was deleted -- make sure its docs are\n        // deleted.  We can't verify packID is deleted\n        // because we can re-use packID for update:\n        for(String subID : subDocs.subIDs) {\n          assertEquals(0, s.search(new TermQuery(new Term(\"docid\", subID)), 1).totalHits);\n        }\n      }\n    }\n\n    // Verify: make sure all not-deleted docs are in fact\n    // not deleted:\n    final int endID = Integer.parseInt(docs.nextDoc().get(\"docid\"));\n    docs.close();\n\n    for(int id=0;id<endID;id++) {\n      String stringID = \"\"+id;\n      if (!delIDs.contains(stringID)) {\n        final TopDocs hits = s.search(new TermQuery(new Term(\"docid\", stringID)), 1);\n        if (hits.totalHits != 1) {\n          System.out.println(\"doc id=\" + stringID + \" is not supposed to be deleted, but got hitCount=\" + hits.totalHits);\n          doFail = true;\n        }\n      }\n    }\n    assertFalse(doFail);\n    \n    assertEquals(\"index=\" + writer.segString() + \" addCount=\" + addCount + \" delCount=\" + delCount, addCount.get() - delCount.get(), s.getIndexReader().numDocs());\n    releaseSearcher(s);\n\n    writer.commit();\n\n    assertEquals(\"index=\" + writer.segString() + \" addCount=\" + addCount + \" delCount=\" + delCount, addCount.get() - delCount.get(), writer.numDocs());\n\n    doClose();\n    writer.close(false);\n\n    // Cannot shutdown until after writer is closed because\n    // writer has merged segment warmer that uses IS to run\n    // searches, and that IS may be using this es!\n    if (es != null) {\n      es.shutdown();\n      es.awaitTermination(1, TimeUnit.SECONDS);\n    }\n\n    _TestUtil.checkIndex(dir);\n    dir.close();\n    _TestUtil.rmDir(tempDir);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: done [\" + (System.currentTimeMillis()-t0) + \" ms]\");\n    }\n  }\n\n","sourceOld":"  public void runTest(String testName) throws Exception {\n\n    failed.set(false);\n    addCount.set(0);\n    delCount.set(0);\n    packCount.set(0);\n\n    final long t0 = System.currentTimeMillis();\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final File tempDir = _TestUtil.getTempDir(testName);\n    dir = newFSDirectory(tempDir);\n    ((MockDirectoryWrapper) dir).setCheckIndexOnClose(false); // don't double-checkIndex, we do it ourselves.\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random));\n\n    if (LuceneTestCase.TEST_NIGHTLY) {\n      // newIWConfig makes smallish max seg size, which\n      // results in tons and tons of segments for this test\n      // when run nightly:\n      MergePolicy mp = conf.getMergePolicy();\n      if (mp instanceof TieredMergePolicy) {\n        ((TieredMergePolicy) mp).setMaxMergedSegmentMB(5000.);\n      } else if (mp instanceof LogByteSizeMergePolicy) {\n        ((LogByteSizeMergePolicy) mp).setMaxMergeMB(1000.);\n      } else if (mp instanceof LogMergePolicy) {\n        ((LogMergePolicy) mp).setMaxMergeDocs(100000);\n      }\n    }\n\n    conf.setMergedSegmentWarmer(new IndexWriter.IndexReaderWarmer() {\n      @Override\n      public void warm(IndexReader reader) throws IOException {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now warm merged reader=\" + reader);\n        }\n        final int maxDoc = reader.maxDoc();\n        final Bits liveDocs = reader.getLiveDocs();\n        int sum = 0;\n        final int inc = Math.max(1, maxDoc/50);\n        for(int docID=0;docID<maxDoc;docID += inc) {\n          if (liveDocs == null || liveDocs.get(docID)) {\n            final Document doc = reader.document(docID);\n            sum += doc.getFields().size();\n          }\n        }\n\n        IndexSearcher searcher = newSearcher(reader);\n        sum += searcher.search(new TermQuery(new Term(\"body\", \"united\")), 10).totalHits;\n        searcher.close();\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: warm visited \" + sum + \" fields\");\n        }\n      }\n      });\n\n    writer = new IndexWriter(dir, conf);\n    if (VERBOSE) {\n      writer.setInfoStream(System.out);\n    }\n    _TestUtil.reduceOpenFiles(writer);\n\n    final ExecutorService es = random.nextBoolean() ? null : Executors.newCachedThreadPool(new NamedThreadFactory(testName));\n\n    doAfterWriter(es);\n\n    final int NUM_INDEX_THREADS = _TestUtil.nextInt(random, 2, 4);\n\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 300 : RANDOM_MULTIPLIER;\n\n    final Set<String> delIDs = Collections.synchronizedSet(new HashSet<String>());\n    final Set<String> delPackIDs = Collections.synchronizedSet(new HashSet<String>());\n    final List<SubDocs> allSubDocs = Collections.synchronizedList(new ArrayList<SubDocs>());\n\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC*1000;\n\n    final Thread[] indexThreads = launchIndexingThreads(docs, NUM_INDEX_THREADS, stopTime, delIDs, delPackIDs, allSubDocs);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE start indexing threads [\" + (System.currentTimeMillis()-t0) + \" ms]\");\n    }\n\n    // Let index build up a bit\n    Thread.sleep(100);\n\n    doSearching(es, stopTime);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: all searching done [\" + (System.currentTimeMillis()-t0) + \" ms]\");\n    }\n    \n    for(int thread=0;thread<indexThreads.length;thread++) {\n      indexThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: done join indexing threads [\" + (System.currentTimeMillis()-t0) + \" ms]; addCount=\" + addCount + \" delCount=\" + delCount);\n    }\n\n    final IndexSearcher s = getFinalSearcher();\n    if (VERBOSE) {\n      System.out.println(\"TEST: finalSearcher=\" + s);\n    }\n\n    assertFalse(failed.get());\n\n    boolean doFail = false;\n\n    // Verify: make sure delIDs are in fact deleted:\n    for(String id : delIDs) {\n      final TopDocs hits = s.search(new TermQuery(new Term(\"docid\", id)), 1);\n      if (hits.totalHits != 0) {\n        System.out.println(\"doc id=\" + id + \" is supposed to be deleted, but got \" + hits.totalHits + \" hits; first docID=\" + hits.scoreDocs[0].doc);\n        doFail = true;\n      }\n    }\n\n    // Verify: make sure delPackIDs are in fact deleted:\n    for(String id : delPackIDs) {\n      final TopDocs hits = s.search(new TermQuery(new Term(\"packID\", id)), 1);\n      if (hits.totalHits != 0) {\n        System.out.println(\"packID=\" + id + \" is supposed to be deleted, but got \" + hits.totalHits + \" matches\");\n        doFail = true;\n      }\n    }\n\n    // Verify: make sure each group of sub-docs are still in docID order:\n    for(SubDocs subDocs : allSubDocs) {\n      TopDocs hits = s.search(new TermQuery(new Term(\"packID\", subDocs.packID)), 20);\n      if (!subDocs.deleted) {\n        // We sort by relevance but the scores should be identical so sort falls back to by docID:\n        if (hits.totalHits != subDocs.subIDs.size()) {\n          System.out.println(\"packID=\" + subDocs.packID + \": expected \" + subDocs.subIDs.size() + \" hits but got \" + hits.totalHits);\n          doFail = true;\n        } else {\n          int lastDocID = -1;\n          int startDocID = -1;\n          for(ScoreDoc scoreDoc : hits.scoreDocs) {\n            final int docID = scoreDoc.doc;\n            if (lastDocID != -1) {\n              assertEquals(1+lastDocID, docID);\n            } else {\n              startDocID = docID;\n            }\n            lastDocID = docID;\n            final Document doc = s.doc(docID);\n            assertEquals(subDocs.packID, doc.get(\"packID\"));\n          }\n\n          lastDocID = startDocID - 1;\n          for(String subID : subDocs.subIDs) {\n            hits = s.search(new TermQuery(new Term(\"docid\", subID)), 1);\n            assertEquals(1, hits.totalHits);\n            final int docID = hits.scoreDocs[0].doc;\n            if (lastDocID != -1) {\n              assertEquals(1+lastDocID, docID);\n            }\n            lastDocID = docID;\n          }\n        }\n      } else {\n        // Pack was deleted -- make sure its docs are\n        // deleted.  We can't verify packID is deleted\n        // because we can re-use packID for update:\n        for(String subID : subDocs.subIDs) {\n          assertEquals(0, s.search(new TermQuery(new Term(\"docid\", subID)), 1).totalHits);\n        }\n      }\n    }\n\n    // Verify: make sure all not-deleted docs are in fact\n    // not deleted:\n    final int endID = Integer.parseInt(docs.nextDoc().get(\"docid\"));\n    docs.close();\n\n    for(int id=0;id<endID;id++) {\n      String stringID = \"\"+id;\n      if (!delIDs.contains(stringID)) {\n        final TopDocs hits = s.search(new TermQuery(new Term(\"docid\", stringID)), 1);\n        if (hits.totalHits != 1) {\n          System.out.println(\"doc id=\" + stringID + \" is not supposed to be deleted, but got hitCount=\" + hits.totalHits);\n          doFail = true;\n        }\n      }\n    }\n    assertFalse(doFail);\n    \n    assertEquals(\"index=\" + writer.segString() + \" addCount=\" + addCount + \" delCount=\" + delCount, addCount.get() - delCount.get(), s.getIndexReader().numDocs());\n    releaseSearcher(s);\n\n    writer.commit();\n\n    assertEquals(\"index=\" + writer.segString() + \" addCount=\" + addCount + \" delCount=\" + delCount, addCount.get() - delCount.get(), writer.numDocs());\n\n    assertFalse(writer.anyNonBulkMerges);\n    doClose();\n    writer.close(false);\n\n    // Cannot shutdown until after writer is closed because\n    // writer has merged segment warmer that uses IS to run\n    // searches, and that IS may be using this es!\n    if (es != null) {\n      es.shutdown();\n      es.awaitTermination(1, TimeUnit.SECONDS);\n    }\n\n    _TestUtil.checkIndex(dir);\n    dir.close();\n    _TestUtil.rmDir(tempDir);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: done [\" + (System.currentTimeMillis()-t0) + \" ms]\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0e7c2454a6a8237bfd0e953f5b940838408c9055","date":1323649300,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test-framework/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runTest(String).mjava","pathOld":"lucene/src/test-framework/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runTest(String).mjava","sourceNew":"  public void runTest(String testName) throws Exception {\n\n    failed.set(false);\n    addCount.set(0);\n    delCount.set(0);\n    packCount.set(0);\n\n    final long t0 = System.currentTimeMillis();\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final File tempDir = _TestUtil.getTempDir(testName);\n    dir = newFSDirectory(tempDir);\n    ((MockDirectoryWrapper) dir).setCheckIndexOnClose(false); // don't double-checkIndex, we do it ourselves.\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).\n        setInfoStream(new FailOnNonBulkMergesInfoStream());\n\n    if (LuceneTestCase.TEST_NIGHTLY) {\n      // newIWConfig makes smallish max seg size, which\n      // results in tons and tons of segments for this test\n      // when run nightly:\n      MergePolicy mp = conf.getMergePolicy();\n      if (mp instanceof TieredMergePolicy) {\n        ((TieredMergePolicy) mp).setMaxMergedSegmentMB(5000.);\n      } else if (mp instanceof LogByteSizeMergePolicy) {\n        ((LogByteSizeMergePolicy) mp).setMaxMergeMB(1000.);\n      } else if (mp instanceof LogMergePolicy) {\n        ((LogMergePolicy) mp).setMaxMergeDocs(100000);\n      }\n    }\n\n    conf.setMergedSegmentWarmer(new IndexWriter.IndexReaderWarmer() {\n      @Override\n      public void warm(IndexReader reader) throws IOException {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now warm merged reader=\" + reader);\n        }\n        final int maxDoc = reader.maxDoc();\n        final Bits liveDocs = reader.getLiveDocs();\n        int sum = 0;\n        final int inc = Math.max(1, maxDoc/50);\n        for(int docID=0;docID<maxDoc;docID += inc) {\n          if (liveDocs == null || liveDocs.get(docID)) {\n            final Document doc = reader.document(docID);\n            sum += doc.getFields().size();\n          }\n        }\n\n        IndexSearcher searcher = newSearcher(reader);\n        sum += searcher.search(new TermQuery(new Term(\"body\", \"united\")), 10).totalHits;\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: warm visited \" + sum + \" fields\");\n        }\n      }\n      });\n\n    writer = new IndexWriter(dir, conf);\n    _TestUtil.reduceOpenFiles(writer);\n\n    final ExecutorService es = random.nextBoolean() ? null : Executors.newCachedThreadPool(new NamedThreadFactory(testName));\n\n    doAfterWriter(es);\n\n    final int NUM_INDEX_THREADS = _TestUtil.nextInt(random, 2, 4);\n\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 300 : RANDOM_MULTIPLIER;\n\n    final Set<String> delIDs = Collections.synchronizedSet(new HashSet<String>());\n    final Set<String> delPackIDs = Collections.synchronizedSet(new HashSet<String>());\n    final List<SubDocs> allSubDocs = Collections.synchronizedList(new ArrayList<SubDocs>());\n\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC*1000;\n\n    final Thread[] indexThreads = launchIndexingThreads(docs, NUM_INDEX_THREADS, stopTime, delIDs, delPackIDs, allSubDocs);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE start indexing threads [\" + (System.currentTimeMillis()-t0) + \" ms]\");\n    }\n\n    // Let index build up a bit\n    Thread.sleep(100);\n\n    doSearching(es, stopTime);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: all searching done [\" + (System.currentTimeMillis()-t0) + \" ms]\");\n    }\n    \n    for(int thread=0;thread<indexThreads.length;thread++) {\n      indexThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: done join indexing threads [\" + (System.currentTimeMillis()-t0) + \" ms]; addCount=\" + addCount + \" delCount=\" + delCount);\n    }\n\n    final IndexSearcher s = getFinalSearcher();\n    if (VERBOSE) {\n      System.out.println(\"TEST: finalSearcher=\" + s);\n    }\n\n    assertFalse(failed.get());\n\n    boolean doFail = false;\n\n    // Verify: make sure delIDs are in fact deleted:\n    for(String id : delIDs) {\n      final TopDocs hits = s.search(new TermQuery(new Term(\"docid\", id)), 1);\n      if (hits.totalHits != 0) {\n        System.out.println(\"doc id=\" + id + \" is supposed to be deleted, but got \" + hits.totalHits + \" hits; first docID=\" + hits.scoreDocs[0].doc);\n        doFail = true;\n      }\n    }\n\n    // Verify: make sure delPackIDs are in fact deleted:\n    for(String id : delPackIDs) {\n      final TopDocs hits = s.search(new TermQuery(new Term(\"packID\", id)), 1);\n      if (hits.totalHits != 0) {\n        System.out.println(\"packID=\" + id + \" is supposed to be deleted, but got \" + hits.totalHits + \" matches\");\n        doFail = true;\n      }\n    }\n\n    // Verify: make sure each group of sub-docs are still in docID order:\n    for(SubDocs subDocs : allSubDocs) {\n      TopDocs hits = s.search(new TermQuery(new Term(\"packID\", subDocs.packID)), 20);\n      if (!subDocs.deleted) {\n        // We sort by relevance but the scores should be identical so sort falls back to by docID:\n        if (hits.totalHits != subDocs.subIDs.size()) {\n          System.out.println(\"packID=\" + subDocs.packID + \": expected \" + subDocs.subIDs.size() + \" hits but got \" + hits.totalHits);\n          doFail = true;\n        } else {\n          int lastDocID = -1;\n          int startDocID = -1;\n          for(ScoreDoc scoreDoc : hits.scoreDocs) {\n            final int docID = scoreDoc.doc;\n            if (lastDocID != -1) {\n              assertEquals(1+lastDocID, docID);\n            } else {\n              startDocID = docID;\n            }\n            lastDocID = docID;\n            final Document doc = s.doc(docID);\n            assertEquals(subDocs.packID, doc.get(\"packID\"));\n          }\n\n          lastDocID = startDocID - 1;\n          for(String subID : subDocs.subIDs) {\n            hits = s.search(new TermQuery(new Term(\"docid\", subID)), 1);\n            assertEquals(1, hits.totalHits);\n            final int docID = hits.scoreDocs[0].doc;\n            if (lastDocID != -1) {\n              assertEquals(1+lastDocID, docID);\n            }\n            lastDocID = docID;\n          }\n        }\n      } else {\n        // Pack was deleted -- make sure its docs are\n        // deleted.  We can't verify packID is deleted\n        // because we can re-use packID for update:\n        for(String subID : subDocs.subIDs) {\n          assertEquals(0, s.search(new TermQuery(new Term(\"docid\", subID)), 1).totalHits);\n        }\n      }\n    }\n\n    // Verify: make sure all not-deleted docs are in fact\n    // not deleted:\n    final int endID = Integer.parseInt(docs.nextDoc().get(\"docid\"));\n    docs.close();\n\n    for(int id=0;id<endID;id++) {\n      String stringID = \"\"+id;\n      if (!delIDs.contains(stringID)) {\n        final TopDocs hits = s.search(new TermQuery(new Term(\"docid\", stringID)), 1);\n        if (hits.totalHits != 1) {\n          System.out.println(\"doc id=\" + stringID + \" is not supposed to be deleted, but got hitCount=\" + hits.totalHits);\n          doFail = true;\n        }\n      }\n    }\n    assertFalse(doFail);\n    \n    assertEquals(\"index=\" + writer.segString() + \" addCount=\" + addCount + \" delCount=\" + delCount, addCount.get() - delCount.get(), s.getIndexReader().numDocs());\n    releaseSearcher(s);\n\n    writer.commit();\n\n    assertEquals(\"index=\" + writer.segString() + \" addCount=\" + addCount + \" delCount=\" + delCount, addCount.get() - delCount.get(), writer.numDocs());\n\n    doClose();\n    writer.close(false);\n\n    // Cannot shutdown until after writer is closed because\n    // writer has merged segment warmer that uses IS to run\n    // searches, and that IS may be using this es!\n    if (es != null) {\n      es.shutdown();\n      es.awaitTermination(1, TimeUnit.SECONDS);\n    }\n\n    _TestUtil.checkIndex(dir);\n    dir.close();\n    _TestUtil.rmDir(tempDir);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: done [\" + (System.currentTimeMillis()-t0) + \" ms]\");\n    }\n  }\n\n","sourceOld":"  public void runTest(String testName) throws Exception {\n\n    failed.set(false);\n    addCount.set(0);\n    delCount.set(0);\n    packCount.set(0);\n\n    final long t0 = System.currentTimeMillis();\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final File tempDir = _TestUtil.getTempDir(testName);\n    dir = newFSDirectory(tempDir);\n    ((MockDirectoryWrapper) dir).setCheckIndexOnClose(false); // don't double-checkIndex, we do it ourselves.\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).\n        setInfoStream(new FailOnNonBulkMergesInfoStream());\n\n    if (LuceneTestCase.TEST_NIGHTLY) {\n      // newIWConfig makes smallish max seg size, which\n      // results in tons and tons of segments for this test\n      // when run nightly:\n      MergePolicy mp = conf.getMergePolicy();\n      if (mp instanceof TieredMergePolicy) {\n        ((TieredMergePolicy) mp).setMaxMergedSegmentMB(5000.);\n      } else if (mp instanceof LogByteSizeMergePolicy) {\n        ((LogByteSizeMergePolicy) mp).setMaxMergeMB(1000.);\n      } else if (mp instanceof LogMergePolicy) {\n        ((LogMergePolicy) mp).setMaxMergeDocs(100000);\n      }\n    }\n\n    conf.setMergedSegmentWarmer(new IndexWriter.IndexReaderWarmer() {\n      @Override\n      public void warm(IndexReader reader) throws IOException {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now warm merged reader=\" + reader);\n        }\n        final int maxDoc = reader.maxDoc();\n        final Bits liveDocs = reader.getLiveDocs();\n        int sum = 0;\n        final int inc = Math.max(1, maxDoc/50);\n        for(int docID=0;docID<maxDoc;docID += inc) {\n          if (liveDocs == null || liveDocs.get(docID)) {\n            final Document doc = reader.document(docID);\n            sum += doc.getFields().size();\n          }\n        }\n\n        IndexSearcher searcher = newSearcher(reader);\n        sum += searcher.search(new TermQuery(new Term(\"body\", \"united\")), 10).totalHits;\n        searcher.close();\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: warm visited \" + sum + \" fields\");\n        }\n      }\n      });\n\n    writer = new IndexWriter(dir, conf);\n    _TestUtil.reduceOpenFiles(writer);\n\n    final ExecutorService es = random.nextBoolean() ? null : Executors.newCachedThreadPool(new NamedThreadFactory(testName));\n\n    doAfterWriter(es);\n\n    final int NUM_INDEX_THREADS = _TestUtil.nextInt(random, 2, 4);\n\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 300 : RANDOM_MULTIPLIER;\n\n    final Set<String> delIDs = Collections.synchronizedSet(new HashSet<String>());\n    final Set<String> delPackIDs = Collections.synchronizedSet(new HashSet<String>());\n    final List<SubDocs> allSubDocs = Collections.synchronizedList(new ArrayList<SubDocs>());\n\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC*1000;\n\n    final Thread[] indexThreads = launchIndexingThreads(docs, NUM_INDEX_THREADS, stopTime, delIDs, delPackIDs, allSubDocs);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE start indexing threads [\" + (System.currentTimeMillis()-t0) + \" ms]\");\n    }\n\n    // Let index build up a bit\n    Thread.sleep(100);\n\n    doSearching(es, stopTime);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: all searching done [\" + (System.currentTimeMillis()-t0) + \" ms]\");\n    }\n    \n    for(int thread=0;thread<indexThreads.length;thread++) {\n      indexThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: done join indexing threads [\" + (System.currentTimeMillis()-t0) + \" ms]; addCount=\" + addCount + \" delCount=\" + delCount);\n    }\n\n    final IndexSearcher s = getFinalSearcher();\n    if (VERBOSE) {\n      System.out.println(\"TEST: finalSearcher=\" + s);\n    }\n\n    assertFalse(failed.get());\n\n    boolean doFail = false;\n\n    // Verify: make sure delIDs are in fact deleted:\n    for(String id : delIDs) {\n      final TopDocs hits = s.search(new TermQuery(new Term(\"docid\", id)), 1);\n      if (hits.totalHits != 0) {\n        System.out.println(\"doc id=\" + id + \" is supposed to be deleted, but got \" + hits.totalHits + \" hits; first docID=\" + hits.scoreDocs[0].doc);\n        doFail = true;\n      }\n    }\n\n    // Verify: make sure delPackIDs are in fact deleted:\n    for(String id : delPackIDs) {\n      final TopDocs hits = s.search(new TermQuery(new Term(\"packID\", id)), 1);\n      if (hits.totalHits != 0) {\n        System.out.println(\"packID=\" + id + \" is supposed to be deleted, but got \" + hits.totalHits + \" matches\");\n        doFail = true;\n      }\n    }\n\n    // Verify: make sure each group of sub-docs are still in docID order:\n    for(SubDocs subDocs : allSubDocs) {\n      TopDocs hits = s.search(new TermQuery(new Term(\"packID\", subDocs.packID)), 20);\n      if (!subDocs.deleted) {\n        // We sort by relevance but the scores should be identical so sort falls back to by docID:\n        if (hits.totalHits != subDocs.subIDs.size()) {\n          System.out.println(\"packID=\" + subDocs.packID + \": expected \" + subDocs.subIDs.size() + \" hits but got \" + hits.totalHits);\n          doFail = true;\n        } else {\n          int lastDocID = -1;\n          int startDocID = -1;\n          for(ScoreDoc scoreDoc : hits.scoreDocs) {\n            final int docID = scoreDoc.doc;\n            if (lastDocID != -1) {\n              assertEquals(1+lastDocID, docID);\n            } else {\n              startDocID = docID;\n            }\n            lastDocID = docID;\n            final Document doc = s.doc(docID);\n            assertEquals(subDocs.packID, doc.get(\"packID\"));\n          }\n\n          lastDocID = startDocID - 1;\n          for(String subID : subDocs.subIDs) {\n            hits = s.search(new TermQuery(new Term(\"docid\", subID)), 1);\n            assertEquals(1, hits.totalHits);\n            final int docID = hits.scoreDocs[0].doc;\n            if (lastDocID != -1) {\n              assertEquals(1+lastDocID, docID);\n            }\n            lastDocID = docID;\n          }\n        }\n      } else {\n        // Pack was deleted -- make sure its docs are\n        // deleted.  We can't verify packID is deleted\n        // because we can re-use packID for update:\n        for(String subID : subDocs.subIDs) {\n          assertEquals(0, s.search(new TermQuery(new Term(\"docid\", subID)), 1).totalHits);\n        }\n      }\n    }\n\n    // Verify: make sure all not-deleted docs are in fact\n    // not deleted:\n    final int endID = Integer.parseInt(docs.nextDoc().get(\"docid\"));\n    docs.close();\n\n    for(int id=0;id<endID;id++) {\n      String stringID = \"\"+id;\n      if (!delIDs.contains(stringID)) {\n        final TopDocs hits = s.search(new TermQuery(new Term(\"docid\", stringID)), 1);\n        if (hits.totalHits != 1) {\n          System.out.println(\"doc id=\" + stringID + \" is not supposed to be deleted, but got hitCount=\" + hits.totalHits);\n          doFail = true;\n        }\n      }\n    }\n    assertFalse(doFail);\n    \n    assertEquals(\"index=\" + writer.segString() + \" addCount=\" + addCount + \" delCount=\" + delCount, addCount.get() - delCount.get(), s.getIndexReader().numDocs());\n    releaseSearcher(s);\n\n    writer.commit();\n\n    assertEquals(\"index=\" + writer.segString() + \" addCount=\" + addCount + \" delCount=\" + delCount, addCount.get() - delCount.get(), writer.numDocs());\n\n    doClose();\n    writer.close(false);\n\n    // Cannot shutdown until after writer is closed because\n    // writer has merged segment warmer that uses IS to run\n    // searches, and that IS may be using this es!\n    if (es != null) {\n      es.shutdown();\n      es.awaitTermination(1, TimeUnit.SECONDS);\n    }\n\n    _TestUtil.checkIndex(dir);\n    dir.close();\n    _TestUtil.rmDir(tempDir);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: done [\" + (System.currentTimeMillis()-t0) + \" ms]\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","date":1323720782,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/test-framework/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runTest(String).mjava","pathOld":"lucene/src/test-framework/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runTest(String).mjava","sourceNew":"  public void runTest(String testName) throws Exception {\n\n    failed.set(false);\n    addCount.set(0);\n    delCount.set(0);\n    packCount.set(0);\n\n    final long t0 = System.currentTimeMillis();\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final File tempDir = _TestUtil.getTempDir(testName);\n    dir = newFSDirectory(tempDir);\n    ((MockDirectoryWrapper) dir).setCheckIndexOnClose(false); // don't double-checkIndex, we do it ourselves.\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).\n        setInfoStream(new FailOnNonBulkMergesInfoStream());\n\n    if (LuceneTestCase.TEST_NIGHTLY) {\n      // newIWConfig makes smallish max seg size, which\n      // results in tons and tons of segments for this test\n      // when run nightly:\n      MergePolicy mp = conf.getMergePolicy();\n      if (mp instanceof TieredMergePolicy) {\n        ((TieredMergePolicy) mp).setMaxMergedSegmentMB(5000.);\n      } else if (mp instanceof LogByteSizeMergePolicy) {\n        ((LogByteSizeMergePolicy) mp).setMaxMergeMB(1000.);\n      } else if (mp instanceof LogMergePolicy) {\n        ((LogMergePolicy) mp).setMaxMergeDocs(100000);\n      }\n    }\n\n    conf.setMergedSegmentWarmer(new IndexWriter.IndexReaderWarmer() {\n      @Override\n      public void warm(IndexReader reader) throws IOException {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now warm merged reader=\" + reader);\n        }\n        final int maxDoc = reader.maxDoc();\n        final Bits liveDocs = reader.getLiveDocs();\n        int sum = 0;\n        final int inc = Math.max(1, maxDoc/50);\n        for(int docID=0;docID<maxDoc;docID += inc) {\n          if (liveDocs == null || liveDocs.get(docID)) {\n            final Document doc = reader.document(docID);\n            sum += doc.getFields().size();\n          }\n        }\n\n        IndexSearcher searcher = newSearcher(reader);\n        sum += searcher.search(new TermQuery(new Term(\"body\", \"united\")), 10).totalHits;\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: warm visited \" + sum + \" fields\");\n        }\n      }\n      });\n\n    writer = new IndexWriter(dir, conf);\n    _TestUtil.reduceOpenFiles(writer);\n\n    final ExecutorService es = random.nextBoolean() ? null : Executors.newCachedThreadPool(new NamedThreadFactory(testName));\n\n    doAfterWriter(es);\n\n    final int NUM_INDEX_THREADS = _TestUtil.nextInt(random, 2, 4);\n\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 300 : RANDOM_MULTIPLIER;\n\n    final Set<String> delIDs = Collections.synchronizedSet(new HashSet<String>());\n    final Set<String> delPackIDs = Collections.synchronizedSet(new HashSet<String>());\n    final List<SubDocs> allSubDocs = Collections.synchronizedList(new ArrayList<SubDocs>());\n\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC*1000;\n\n    final Thread[] indexThreads = launchIndexingThreads(docs, NUM_INDEX_THREADS, stopTime, delIDs, delPackIDs, allSubDocs);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE start indexing threads [\" + (System.currentTimeMillis()-t0) + \" ms]\");\n    }\n\n    // Let index build up a bit\n    Thread.sleep(100);\n\n    doSearching(es, stopTime);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: all searching done [\" + (System.currentTimeMillis()-t0) + \" ms]\");\n    }\n    \n    for(int thread=0;thread<indexThreads.length;thread++) {\n      indexThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: done join indexing threads [\" + (System.currentTimeMillis()-t0) + \" ms]; addCount=\" + addCount + \" delCount=\" + delCount);\n    }\n\n    final IndexSearcher s = getFinalSearcher();\n    if (VERBOSE) {\n      System.out.println(\"TEST: finalSearcher=\" + s);\n    }\n\n    assertFalse(failed.get());\n\n    boolean doFail = false;\n\n    // Verify: make sure delIDs are in fact deleted:\n    for(String id : delIDs) {\n      final TopDocs hits = s.search(new TermQuery(new Term(\"docid\", id)), 1);\n      if (hits.totalHits != 0) {\n        System.out.println(\"doc id=\" + id + \" is supposed to be deleted, but got \" + hits.totalHits + \" hits; first docID=\" + hits.scoreDocs[0].doc);\n        doFail = true;\n      }\n    }\n\n    // Verify: make sure delPackIDs are in fact deleted:\n    for(String id : delPackIDs) {\n      final TopDocs hits = s.search(new TermQuery(new Term(\"packID\", id)), 1);\n      if (hits.totalHits != 0) {\n        System.out.println(\"packID=\" + id + \" is supposed to be deleted, but got \" + hits.totalHits + \" matches\");\n        doFail = true;\n      }\n    }\n\n    // Verify: make sure each group of sub-docs are still in docID order:\n    for(SubDocs subDocs : allSubDocs) {\n      TopDocs hits = s.search(new TermQuery(new Term(\"packID\", subDocs.packID)), 20);\n      if (!subDocs.deleted) {\n        // We sort by relevance but the scores should be identical so sort falls back to by docID:\n        if (hits.totalHits != subDocs.subIDs.size()) {\n          System.out.println(\"packID=\" + subDocs.packID + \": expected \" + subDocs.subIDs.size() + \" hits but got \" + hits.totalHits);\n          doFail = true;\n        } else {\n          int lastDocID = -1;\n          int startDocID = -1;\n          for(ScoreDoc scoreDoc : hits.scoreDocs) {\n            final int docID = scoreDoc.doc;\n            if (lastDocID != -1) {\n              assertEquals(1+lastDocID, docID);\n            } else {\n              startDocID = docID;\n            }\n            lastDocID = docID;\n            final Document doc = s.doc(docID);\n            assertEquals(subDocs.packID, doc.get(\"packID\"));\n          }\n\n          lastDocID = startDocID - 1;\n          for(String subID : subDocs.subIDs) {\n            hits = s.search(new TermQuery(new Term(\"docid\", subID)), 1);\n            assertEquals(1, hits.totalHits);\n            final int docID = hits.scoreDocs[0].doc;\n            if (lastDocID != -1) {\n              assertEquals(1+lastDocID, docID);\n            }\n            lastDocID = docID;\n          }\n        }\n      } else {\n        // Pack was deleted -- make sure its docs are\n        // deleted.  We can't verify packID is deleted\n        // because we can re-use packID for update:\n        for(String subID : subDocs.subIDs) {\n          assertEquals(0, s.search(new TermQuery(new Term(\"docid\", subID)), 1).totalHits);\n        }\n      }\n    }\n\n    // Verify: make sure all not-deleted docs are in fact\n    // not deleted:\n    final int endID = Integer.parseInt(docs.nextDoc().get(\"docid\"));\n    docs.close();\n\n    for(int id=0;id<endID;id++) {\n      String stringID = \"\"+id;\n      if (!delIDs.contains(stringID)) {\n        final TopDocs hits = s.search(new TermQuery(new Term(\"docid\", stringID)), 1);\n        if (hits.totalHits != 1) {\n          System.out.println(\"doc id=\" + stringID + \" is not supposed to be deleted, but got hitCount=\" + hits.totalHits);\n          doFail = true;\n        }\n      }\n    }\n    assertFalse(doFail);\n    \n    assertEquals(\"index=\" + writer.segString() + \" addCount=\" + addCount + \" delCount=\" + delCount, addCount.get() - delCount.get(), s.getIndexReader().numDocs());\n    releaseSearcher(s);\n\n    writer.commit();\n\n    assertEquals(\"index=\" + writer.segString() + \" addCount=\" + addCount + \" delCount=\" + delCount, addCount.get() - delCount.get(), writer.numDocs());\n\n    doClose();\n    writer.close(false);\n\n    // Cannot shutdown until after writer is closed because\n    // writer has merged segment warmer that uses IS to run\n    // searches, and that IS may be using this es!\n    if (es != null) {\n      es.shutdown();\n      es.awaitTermination(1, TimeUnit.SECONDS);\n    }\n\n    _TestUtil.checkIndex(dir);\n    dir.close();\n    _TestUtil.rmDir(tempDir);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: done [\" + (System.currentTimeMillis()-t0) + \" ms]\");\n    }\n  }\n\n","sourceOld":"  public void runTest(String testName) throws Exception {\n\n    failed.set(false);\n    addCount.set(0);\n    delCount.set(0);\n    packCount.set(0);\n\n    final long t0 = System.currentTimeMillis();\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final File tempDir = _TestUtil.getTempDir(testName);\n    dir = newFSDirectory(tempDir);\n    ((MockDirectoryWrapper) dir).setCheckIndexOnClose(false); // don't double-checkIndex, we do it ourselves.\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).\n        setInfoStream(new FailOnNonBulkMergesInfoStream());\n\n    if (LuceneTestCase.TEST_NIGHTLY) {\n      // newIWConfig makes smallish max seg size, which\n      // results in tons and tons of segments for this test\n      // when run nightly:\n      MergePolicy mp = conf.getMergePolicy();\n      if (mp instanceof TieredMergePolicy) {\n        ((TieredMergePolicy) mp).setMaxMergedSegmentMB(5000.);\n      } else if (mp instanceof LogByteSizeMergePolicy) {\n        ((LogByteSizeMergePolicy) mp).setMaxMergeMB(1000.);\n      } else if (mp instanceof LogMergePolicy) {\n        ((LogMergePolicy) mp).setMaxMergeDocs(100000);\n      }\n    }\n\n    conf.setMergedSegmentWarmer(new IndexWriter.IndexReaderWarmer() {\n      @Override\n      public void warm(IndexReader reader) throws IOException {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now warm merged reader=\" + reader);\n        }\n        final int maxDoc = reader.maxDoc();\n        final Bits liveDocs = reader.getLiveDocs();\n        int sum = 0;\n        final int inc = Math.max(1, maxDoc/50);\n        for(int docID=0;docID<maxDoc;docID += inc) {\n          if (liveDocs == null || liveDocs.get(docID)) {\n            final Document doc = reader.document(docID);\n            sum += doc.getFields().size();\n          }\n        }\n\n        IndexSearcher searcher = newSearcher(reader);\n        sum += searcher.search(new TermQuery(new Term(\"body\", \"united\")), 10).totalHits;\n        searcher.close();\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: warm visited \" + sum + \" fields\");\n        }\n      }\n      });\n\n    writer = new IndexWriter(dir, conf);\n    _TestUtil.reduceOpenFiles(writer);\n\n    final ExecutorService es = random.nextBoolean() ? null : Executors.newCachedThreadPool(new NamedThreadFactory(testName));\n\n    doAfterWriter(es);\n\n    final int NUM_INDEX_THREADS = _TestUtil.nextInt(random, 2, 4);\n\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 300 : RANDOM_MULTIPLIER;\n\n    final Set<String> delIDs = Collections.synchronizedSet(new HashSet<String>());\n    final Set<String> delPackIDs = Collections.synchronizedSet(new HashSet<String>());\n    final List<SubDocs> allSubDocs = Collections.synchronizedList(new ArrayList<SubDocs>());\n\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC*1000;\n\n    final Thread[] indexThreads = launchIndexingThreads(docs, NUM_INDEX_THREADS, stopTime, delIDs, delPackIDs, allSubDocs);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE start indexing threads [\" + (System.currentTimeMillis()-t0) + \" ms]\");\n    }\n\n    // Let index build up a bit\n    Thread.sleep(100);\n\n    doSearching(es, stopTime);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: all searching done [\" + (System.currentTimeMillis()-t0) + \" ms]\");\n    }\n    \n    for(int thread=0;thread<indexThreads.length;thread++) {\n      indexThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: done join indexing threads [\" + (System.currentTimeMillis()-t0) + \" ms]; addCount=\" + addCount + \" delCount=\" + delCount);\n    }\n\n    final IndexSearcher s = getFinalSearcher();\n    if (VERBOSE) {\n      System.out.println(\"TEST: finalSearcher=\" + s);\n    }\n\n    assertFalse(failed.get());\n\n    boolean doFail = false;\n\n    // Verify: make sure delIDs are in fact deleted:\n    for(String id : delIDs) {\n      final TopDocs hits = s.search(new TermQuery(new Term(\"docid\", id)), 1);\n      if (hits.totalHits != 0) {\n        System.out.println(\"doc id=\" + id + \" is supposed to be deleted, but got \" + hits.totalHits + \" hits; first docID=\" + hits.scoreDocs[0].doc);\n        doFail = true;\n      }\n    }\n\n    // Verify: make sure delPackIDs are in fact deleted:\n    for(String id : delPackIDs) {\n      final TopDocs hits = s.search(new TermQuery(new Term(\"packID\", id)), 1);\n      if (hits.totalHits != 0) {\n        System.out.println(\"packID=\" + id + \" is supposed to be deleted, but got \" + hits.totalHits + \" matches\");\n        doFail = true;\n      }\n    }\n\n    // Verify: make sure each group of sub-docs are still in docID order:\n    for(SubDocs subDocs : allSubDocs) {\n      TopDocs hits = s.search(new TermQuery(new Term(\"packID\", subDocs.packID)), 20);\n      if (!subDocs.deleted) {\n        // We sort by relevance but the scores should be identical so sort falls back to by docID:\n        if (hits.totalHits != subDocs.subIDs.size()) {\n          System.out.println(\"packID=\" + subDocs.packID + \": expected \" + subDocs.subIDs.size() + \" hits but got \" + hits.totalHits);\n          doFail = true;\n        } else {\n          int lastDocID = -1;\n          int startDocID = -1;\n          for(ScoreDoc scoreDoc : hits.scoreDocs) {\n            final int docID = scoreDoc.doc;\n            if (lastDocID != -1) {\n              assertEquals(1+lastDocID, docID);\n            } else {\n              startDocID = docID;\n            }\n            lastDocID = docID;\n            final Document doc = s.doc(docID);\n            assertEquals(subDocs.packID, doc.get(\"packID\"));\n          }\n\n          lastDocID = startDocID - 1;\n          for(String subID : subDocs.subIDs) {\n            hits = s.search(new TermQuery(new Term(\"docid\", subID)), 1);\n            assertEquals(1, hits.totalHits);\n            final int docID = hits.scoreDocs[0].doc;\n            if (lastDocID != -1) {\n              assertEquals(1+lastDocID, docID);\n            }\n            lastDocID = docID;\n          }\n        }\n      } else {\n        // Pack was deleted -- make sure its docs are\n        // deleted.  We can't verify packID is deleted\n        // because we can re-use packID for update:\n        for(String subID : subDocs.subIDs) {\n          assertEquals(0, s.search(new TermQuery(new Term(\"docid\", subID)), 1).totalHits);\n        }\n      }\n    }\n\n    // Verify: make sure all not-deleted docs are in fact\n    // not deleted:\n    final int endID = Integer.parseInt(docs.nextDoc().get(\"docid\"));\n    docs.close();\n\n    for(int id=0;id<endID;id++) {\n      String stringID = \"\"+id;\n      if (!delIDs.contains(stringID)) {\n        final TopDocs hits = s.search(new TermQuery(new Term(\"docid\", stringID)), 1);\n        if (hits.totalHits != 1) {\n          System.out.println(\"doc id=\" + stringID + \" is not supposed to be deleted, but got hitCount=\" + hits.totalHits);\n          doFail = true;\n        }\n      }\n    }\n    assertFalse(doFail);\n    \n    assertEquals(\"index=\" + writer.segString() + \" addCount=\" + addCount + \" delCount=\" + delCount, addCount.get() - delCount.get(), s.getIndexReader().numDocs());\n    releaseSearcher(s);\n\n    writer.commit();\n\n    assertEquals(\"index=\" + writer.segString() + \" addCount=\" + addCount + \" delCount=\" + delCount, addCount.get() - delCount.get(), writer.numDocs());\n\n    doClose();\n    writer.close(false);\n\n    // Cannot shutdown until after writer is closed because\n    // writer has merged segment warmer that uses IS to run\n    // searches, and that IS may be using this es!\n    if (es != null) {\n      es.shutdown();\n      es.awaitTermination(1, TimeUnit.SECONDS);\n    }\n\n    _TestUtil.checkIndex(dir);\n    dir.close();\n    _TestUtil.rmDir(tempDir);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: done [\" + (System.currentTimeMillis()-t0) + \" ms]\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a85e7319b5cf755cba8f1bfa7365afeb9cc3ad94","date":1327846543,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/test-framework/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runTest(String).mjava","pathOld":"lucene/src/test-framework/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runTest(String).mjava","sourceNew":"  public void runTest(String testName) throws Exception {\n\n    failed.set(false);\n    addCount.set(0);\n    delCount.set(0);\n    packCount.set(0);\n\n    final long t0 = System.currentTimeMillis();\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final File tempDir = _TestUtil.getTempDir(testName);\n    dir = newFSDirectory(tempDir);\n    ((MockDirectoryWrapper) dir).setCheckIndexOnClose(false); // don't double-checkIndex, we do it ourselves.\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).\n        setInfoStream(new FailOnNonBulkMergesInfoStream());\n\n    if (LuceneTestCase.TEST_NIGHTLY) {\n      // newIWConfig makes smallish max seg size, which\n      // results in tons and tons of segments for this test\n      // when run nightly:\n      MergePolicy mp = conf.getMergePolicy();\n      if (mp instanceof TieredMergePolicy) {\n        ((TieredMergePolicy) mp).setMaxMergedSegmentMB(5000.);\n      } else if (mp instanceof LogByteSizeMergePolicy) {\n        ((LogByteSizeMergePolicy) mp).setMaxMergeMB(1000.);\n      } else if (mp instanceof LogMergePolicy) {\n        ((LogMergePolicy) mp).setMaxMergeDocs(100000);\n      }\n    }\n\n    conf.setMergedSegmentWarmer(new IndexWriter.IndexReaderWarmer() {\n      @Override\n      public void warm(AtomicIndexReader reader) throws IOException {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now warm merged reader=\" + reader);\n        }\n        final int maxDoc = reader.maxDoc();\n        final Bits liveDocs = reader.getLiveDocs();\n        int sum = 0;\n        final int inc = Math.max(1, maxDoc/50);\n        for(int docID=0;docID<maxDoc;docID += inc) {\n          if (liveDocs == null || liveDocs.get(docID)) {\n            final Document doc = reader.document(docID);\n            sum += doc.getFields().size();\n          }\n        }\n\n        IndexSearcher searcher = newSearcher(reader);\n        sum += searcher.search(new TermQuery(new Term(\"body\", \"united\")), 10).totalHits;\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: warm visited \" + sum + \" fields\");\n        }\n      }\n      });\n\n    writer = new IndexWriter(dir, conf);\n    _TestUtil.reduceOpenFiles(writer);\n\n    final ExecutorService es = random.nextBoolean() ? null : Executors.newCachedThreadPool(new NamedThreadFactory(testName));\n\n    doAfterWriter(es);\n\n    final int NUM_INDEX_THREADS = _TestUtil.nextInt(random, 2, 4);\n\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 300 : RANDOM_MULTIPLIER;\n\n    final Set<String> delIDs = Collections.synchronizedSet(new HashSet<String>());\n    final Set<String> delPackIDs = Collections.synchronizedSet(new HashSet<String>());\n    final List<SubDocs> allSubDocs = Collections.synchronizedList(new ArrayList<SubDocs>());\n\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC*1000;\n\n    final Thread[] indexThreads = launchIndexingThreads(docs, NUM_INDEX_THREADS, stopTime, delIDs, delPackIDs, allSubDocs);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE start indexing threads [\" + (System.currentTimeMillis()-t0) + \" ms]\");\n    }\n\n    // Let index build up a bit\n    Thread.sleep(100);\n\n    doSearching(es, stopTime);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: all searching done [\" + (System.currentTimeMillis()-t0) + \" ms]\");\n    }\n    \n    for(int thread=0;thread<indexThreads.length;thread++) {\n      indexThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: done join indexing threads [\" + (System.currentTimeMillis()-t0) + \" ms]; addCount=\" + addCount + \" delCount=\" + delCount);\n    }\n\n    final IndexSearcher s = getFinalSearcher();\n    if (VERBOSE) {\n      System.out.println(\"TEST: finalSearcher=\" + s);\n    }\n\n    assertFalse(failed.get());\n\n    boolean doFail = false;\n\n    // Verify: make sure delIDs are in fact deleted:\n    for(String id : delIDs) {\n      final TopDocs hits = s.search(new TermQuery(new Term(\"docid\", id)), 1);\n      if (hits.totalHits != 0) {\n        System.out.println(\"doc id=\" + id + \" is supposed to be deleted, but got \" + hits.totalHits + \" hits; first docID=\" + hits.scoreDocs[0].doc);\n        doFail = true;\n      }\n    }\n\n    // Verify: make sure delPackIDs are in fact deleted:\n    for(String id : delPackIDs) {\n      final TopDocs hits = s.search(new TermQuery(new Term(\"packID\", id)), 1);\n      if (hits.totalHits != 0) {\n        System.out.println(\"packID=\" + id + \" is supposed to be deleted, but got \" + hits.totalHits + \" matches\");\n        doFail = true;\n      }\n    }\n\n    // Verify: make sure each group of sub-docs are still in docID order:\n    for(SubDocs subDocs : allSubDocs) {\n      TopDocs hits = s.search(new TermQuery(new Term(\"packID\", subDocs.packID)), 20);\n      if (!subDocs.deleted) {\n        // We sort by relevance but the scores should be identical so sort falls back to by docID:\n        if (hits.totalHits != subDocs.subIDs.size()) {\n          System.out.println(\"packID=\" + subDocs.packID + \": expected \" + subDocs.subIDs.size() + \" hits but got \" + hits.totalHits);\n          doFail = true;\n        } else {\n          int lastDocID = -1;\n          int startDocID = -1;\n          for(ScoreDoc scoreDoc : hits.scoreDocs) {\n            final int docID = scoreDoc.doc;\n            if (lastDocID != -1) {\n              assertEquals(1+lastDocID, docID);\n            } else {\n              startDocID = docID;\n            }\n            lastDocID = docID;\n            final Document doc = s.doc(docID);\n            assertEquals(subDocs.packID, doc.get(\"packID\"));\n          }\n\n          lastDocID = startDocID - 1;\n          for(String subID : subDocs.subIDs) {\n            hits = s.search(new TermQuery(new Term(\"docid\", subID)), 1);\n            assertEquals(1, hits.totalHits);\n            final int docID = hits.scoreDocs[0].doc;\n            if (lastDocID != -1) {\n              assertEquals(1+lastDocID, docID);\n            }\n            lastDocID = docID;\n          }\n        }\n      } else {\n        // Pack was deleted -- make sure its docs are\n        // deleted.  We can't verify packID is deleted\n        // because we can re-use packID for update:\n        for(String subID : subDocs.subIDs) {\n          assertEquals(0, s.search(new TermQuery(new Term(\"docid\", subID)), 1).totalHits);\n        }\n      }\n    }\n\n    // Verify: make sure all not-deleted docs are in fact\n    // not deleted:\n    final int endID = Integer.parseInt(docs.nextDoc().get(\"docid\"));\n    docs.close();\n\n    for(int id=0;id<endID;id++) {\n      String stringID = \"\"+id;\n      if (!delIDs.contains(stringID)) {\n        final TopDocs hits = s.search(new TermQuery(new Term(\"docid\", stringID)), 1);\n        if (hits.totalHits != 1) {\n          System.out.println(\"doc id=\" + stringID + \" is not supposed to be deleted, but got hitCount=\" + hits.totalHits);\n          doFail = true;\n        }\n      }\n    }\n    assertFalse(doFail);\n    \n    assertEquals(\"index=\" + writer.segString() + \" addCount=\" + addCount + \" delCount=\" + delCount, addCount.get() - delCount.get(), s.getIndexReader().numDocs());\n    releaseSearcher(s);\n\n    writer.commit();\n\n    assertEquals(\"index=\" + writer.segString() + \" addCount=\" + addCount + \" delCount=\" + delCount, addCount.get() - delCount.get(), writer.numDocs());\n\n    doClose();\n    writer.close(false);\n\n    // Cannot shutdown until after writer is closed because\n    // writer has merged segment warmer that uses IS to run\n    // searches, and that IS may be using this es!\n    if (es != null) {\n      es.shutdown();\n      es.awaitTermination(1, TimeUnit.SECONDS);\n    }\n\n    _TestUtil.checkIndex(dir);\n    dir.close();\n    _TestUtil.rmDir(tempDir);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: done [\" + (System.currentTimeMillis()-t0) + \" ms]\");\n    }\n  }\n\n","sourceOld":"  public void runTest(String testName) throws Exception {\n\n    failed.set(false);\n    addCount.set(0);\n    delCount.set(0);\n    packCount.set(0);\n\n    final long t0 = System.currentTimeMillis();\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final File tempDir = _TestUtil.getTempDir(testName);\n    dir = newFSDirectory(tempDir);\n    ((MockDirectoryWrapper) dir).setCheckIndexOnClose(false); // don't double-checkIndex, we do it ourselves.\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).\n        setInfoStream(new FailOnNonBulkMergesInfoStream());\n\n    if (LuceneTestCase.TEST_NIGHTLY) {\n      // newIWConfig makes smallish max seg size, which\n      // results in tons and tons of segments for this test\n      // when run nightly:\n      MergePolicy mp = conf.getMergePolicy();\n      if (mp instanceof TieredMergePolicy) {\n        ((TieredMergePolicy) mp).setMaxMergedSegmentMB(5000.);\n      } else if (mp instanceof LogByteSizeMergePolicy) {\n        ((LogByteSizeMergePolicy) mp).setMaxMergeMB(1000.);\n      } else if (mp instanceof LogMergePolicy) {\n        ((LogMergePolicy) mp).setMaxMergeDocs(100000);\n      }\n    }\n\n    conf.setMergedSegmentWarmer(new IndexWriter.IndexReaderWarmer() {\n      @Override\n      public void warm(IndexReader reader) throws IOException {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now warm merged reader=\" + reader);\n        }\n        final int maxDoc = reader.maxDoc();\n        final Bits liveDocs = reader.getLiveDocs();\n        int sum = 0;\n        final int inc = Math.max(1, maxDoc/50);\n        for(int docID=0;docID<maxDoc;docID += inc) {\n          if (liveDocs == null || liveDocs.get(docID)) {\n            final Document doc = reader.document(docID);\n            sum += doc.getFields().size();\n          }\n        }\n\n        IndexSearcher searcher = newSearcher(reader);\n        sum += searcher.search(new TermQuery(new Term(\"body\", \"united\")), 10).totalHits;\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: warm visited \" + sum + \" fields\");\n        }\n      }\n      });\n\n    writer = new IndexWriter(dir, conf);\n    _TestUtil.reduceOpenFiles(writer);\n\n    final ExecutorService es = random.nextBoolean() ? null : Executors.newCachedThreadPool(new NamedThreadFactory(testName));\n\n    doAfterWriter(es);\n\n    final int NUM_INDEX_THREADS = _TestUtil.nextInt(random, 2, 4);\n\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 300 : RANDOM_MULTIPLIER;\n\n    final Set<String> delIDs = Collections.synchronizedSet(new HashSet<String>());\n    final Set<String> delPackIDs = Collections.synchronizedSet(new HashSet<String>());\n    final List<SubDocs> allSubDocs = Collections.synchronizedList(new ArrayList<SubDocs>());\n\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC*1000;\n\n    final Thread[] indexThreads = launchIndexingThreads(docs, NUM_INDEX_THREADS, stopTime, delIDs, delPackIDs, allSubDocs);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE start indexing threads [\" + (System.currentTimeMillis()-t0) + \" ms]\");\n    }\n\n    // Let index build up a bit\n    Thread.sleep(100);\n\n    doSearching(es, stopTime);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: all searching done [\" + (System.currentTimeMillis()-t0) + \" ms]\");\n    }\n    \n    for(int thread=0;thread<indexThreads.length;thread++) {\n      indexThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: done join indexing threads [\" + (System.currentTimeMillis()-t0) + \" ms]; addCount=\" + addCount + \" delCount=\" + delCount);\n    }\n\n    final IndexSearcher s = getFinalSearcher();\n    if (VERBOSE) {\n      System.out.println(\"TEST: finalSearcher=\" + s);\n    }\n\n    assertFalse(failed.get());\n\n    boolean doFail = false;\n\n    // Verify: make sure delIDs are in fact deleted:\n    for(String id : delIDs) {\n      final TopDocs hits = s.search(new TermQuery(new Term(\"docid\", id)), 1);\n      if (hits.totalHits != 0) {\n        System.out.println(\"doc id=\" + id + \" is supposed to be deleted, but got \" + hits.totalHits + \" hits; first docID=\" + hits.scoreDocs[0].doc);\n        doFail = true;\n      }\n    }\n\n    // Verify: make sure delPackIDs are in fact deleted:\n    for(String id : delPackIDs) {\n      final TopDocs hits = s.search(new TermQuery(new Term(\"packID\", id)), 1);\n      if (hits.totalHits != 0) {\n        System.out.println(\"packID=\" + id + \" is supposed to be deleted, but got \" + hits.totalHits + \" matches\");\n        doFail = true;\n      }\n    }\n\n    // Verify: make sure each group of sub-docs are still in docID order:\n    for(SubDocs subDocs : allSubDocs) {\n      TopDocs hits = s.search(new TermQuery(new Term(\"packID\", subDocs.packID)), 20);\n      if (!subDocs.deleted) {\n        // We sort by relevance but the scores should be identical so sort falls back to by docID:\n        if (hits.totalHits != subDocs.subIDs.size()) {\n          System.out.println(\"packID=\" + subDocs.packID + \": expected \" + subDocs.subIDs.size() + \" hits but got \" + hits.totalHits);\n          doFail = true;\n        } else {\n          int lastDocID = -1;\n          int startDocID = -1;\n          for(ScoreDoc scoreDoc : hits.scoreDocs) {\n            final int docID = scoreDoc.doc;\n            if (lastDocID != -1) {\n              assertEquals(1+lastDocID, docID);\n            } else {\n              startDocID = docID;\n            }\n            lastDocID = docID;\n            final Document doc = s.doc(docID);\n            assertEquals(subDocs.packID, doc.get(\"packID\"));\n          }\n\n          lastDocID = startDocID - 1;\n          for(String subID : subDocs.subIDs) {\n            hits = s.search(new TermQuery(new Term(\"docid\", subID)), 1);\n            assertEquals(1, hits.totalHits);\n            final int docID = hits.scoreDocs[0].doc;\n            if (lastDocID != -1) {\n              assertEquals(1+lastDocID, docID);\n            }\n            lastDocID = docID;\n          }\n        }\n      } else {\n        // Pack was deleted -- make sure its docs are\n        // deleted.  We can't verify packID is deleted\n        // because we can re-use packID for update:\n        for(String subID : subDocs.subIDs) {\n          assertEquals(0, s.search(new TermQuery(new Term(\"docid\", subID)), 1).totalHits);\n        }\n      }\n    }\n\n    // Verify: make sure all not-deleted docs are in fact\n    // not deleted:\n    final int endID = Integer.parseInt(docs.nextDoc().get(\"docid\"));\n    docs.close();\n\n    for(int id=0;id<endID;id++) {\n      String stringID = \"\"+id;\n      if (!delIDs.contains(stringID)) {\n        final TopDocs hits = s.search(new TermQuery(new Term(\"docid\", stringID)), 1);\n        if (hits.totalHits != 1) {\n          System.out.println(\"doc id=\" + stringID + \" is not supposed to be deleted, but got hitCount=\" + hits.totalHits);\n          doFail = true;\n        }\n      }\n    }\n    assertFalse(doFail);\n    \n    assertEquals(\"index=\" + writer.segString() + \" addCount=\" + addCount + \" delCount=\" + delCount, addCount.get() - delCount.get(), s.getIndexReader().numDocs());\n    releaseSearcher(s);\n\n    writer.commit();\n\n    assertEquals(\"index=\" + writer.segString() + \" addCount=\" + addCount + \" delCount=\" + delCount, addCount.get() - delCount.get(), writer.numDocs());\n\n    doClose();\n    writer.close(false);\n\n    // Cannot shutdown until after writer is closed because\n    // writer has merged segment warmer that uses IS to run\n    // searches, and that IS may be using this es!\n    if (es != null) {\n      es.shutdown();\n      es.awaitTermination(1, TimeUnit.SECONDS);\n    }\n\n    _TestUtil.checkIndex(dir);\n    dir.close();\n    _TestUtil.rmDir(tempDir);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: done [\" + (System.currentTimeMillis()-t0) + \" ms]\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"da6d5ac19a80d65b1e864251f155d30960353b7e","date":1327881054,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/test-framework/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runTest(String).mjava","pathOld":"lucene/src/test-framework/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runTest(String).mjava","sourceNew":"  public void runTest(String testName) throws Exception {\n\n    failed.set(false);\n    addCount.set(0);\n    delCount.set(0);\n    packCount.set(0);\n\n    final long t0 = System.currentTimeMillis();\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final File tempDir = _TestUtil.getTempDir(testName);\n    dir = newFSDirectory(tempDir);\n    ((MockDirectoryWrapper) dir).setCheckIndexOnClose(false); // don't double-checkIndex, we do it ourselves.\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).\n        setInfoStream(new FailOnNonBulkMergesInfoStream());\n\n    if (LuceneTestCase.TEST_NIGHTLY) {\n      // newIWConfig makes smallish max seg size, which\n      // results in tons and tons of segments for this test\n      // when run nightly:\n      MergePolicy mp = conf.getMergePolicy();\n      if (mp instanceof TieredMergePolicy) {\n        ((TieredMergePolicy) mp).setMaxMergedSegmentMB(5000.);\n      } else if (mp instanceof LogByteSizeMergePolicy) {\n        ((LogByteSizeMergePolicy) mp).setMaxMergeMB(1000.);\n      } else if (mp instanceof LogMergePolicy) {\n        ((LogMergePolicy) mp).setMaxMergeDocs(100000);\n      }\n    }\n\n    conf.setMergedSegmentWarmer(new IndexWriter.IndexReaderWarmer() {\n      @Override\n      public void warm(AtomicReader reader) throws IOException {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now warm merged reader=\" + reader);\n        }\n        final int maxDoc = reader.maxDoc();\n        final Bits liveDocs = reader.getLiveDocs();\n        int sum = 0;\n        final int inc = Math.max(1, maxDoc/50);\n        for(int docID=0;docID<maxDoc;docID += inc) {\n          if (liveDocs == null || liveDocs.get(docID)) {\n            final Document doc = reader.document(docID);\n            sum += doc.getFields().size();\n          }\n        }\n\n        IndexSearcher searcher = newSearcher(reader);\n        sum += searcher.search(new TermQuery(new Term(\"body\", \"united\")), 10).totalHits;\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: warm visited \" + sum + \" fields\");\n        }\n      }\n      });\n\n    writer = new IndexWriter(dir, conf);\n    _TestUtil.reduceOpenFiles(writer);\n\n    final ExecutorService es = random.nextBoolean() ? null : Executors.newCachedThreadPool(new NamedThreadFactory(testName));\n\n    doAfterWriter(es);\n\n    final int NUM_INDEX_THREADS = _TestUtil.nextInt(random, 2, 4);\n\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 300 : RANDOM_MULTIPLIER;\n\n    final Set<String> delIDs = Collections.synchronizedSet(new HashSet<String>());\n    final Set<String> delPackIDs = Collections.synchronizedSet(new HashSet<String>());\n    final List<SubDocs> allSubDocs = Collections.synchronizedList(new ArrayList<SubDocs>());\n\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC*1000;\n\n    final Thread[] indexThreads = launchIndexingThreads(docs, NUM_INDEX_THREADS, stopTime, delIDs, delPackIDs, allSubDocs);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE start indexing threads [\" + (System.currentTimeMillis()-t0) + \" ms]\");\n    }\n\n    // Let index build up a bit\n    Thread.sleep(100);\n\n    doSearching(es, stopTime);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: all searching done [\" + (System.currentTimeMillis()-t0) + \" ms]\");\n    }\n    \n    for(int thread=0;thread<indexThreads.length;thread++) {\n      indexThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: done join indexing threads [\" + (System.currentTimeMillis()-t0) + \" ms]; addCount=\" + addCount + \" delCount=\" + delCount);\n    }\n\n    final IndexSearcher s = getFinalSearcher();\n    if (VERBOSE) {\n      System.out.println(\"TEST: finalSearcher=\" + s);\n    }\n\n    assertFalse(failed.get());\n\n    boolean doFail = false;\n\n    // Verify: make sure delIDs are in fact deleted:\n    for(String id : delIDs) {\n      final TopDocs hits = s.search(new TermQuery(new Term(\"docid\", id)), 1);\n      if (hits.totalHits != 0) {\n        System.out.println(\"doc id=\" + id + \" is supposed to be deleted, but got \" + hits.totalHits + \" hits; first docID=\" + hits.scoreDocs[0].doc);\n        doFail = true;\n      }\n    }\n\n    // Verify: make sure delPackIDs are in fact deleted:\n    for(String id : delPackIDs) {\n      final TopDocs hits = s.search(new TermQuery(new Term(\"packID\", id)), 1);\n      if (hits.totalHits != 0) {\n        System.out.println(\"packID=\" + id + \" is supposed to be deleted, but got \" + hits.totalHits + \" matches\");\n        doFail = true;\n      }\n    }\n\n    // Verify: make sure each group of sub-docs are still in docID order:\n    for(SubDocs subDocs : allSubDocs) {\n      TopDocs hits = s.search(new TermQuery(new Term(\"packID\", subDocs.packID)), 20);\n      if (!subDocs.deleted) {\n        // We sort by relevance but the scores should be identical so sort falls back to by docID:\n        if (hits.totalHits != subDocs.subIDs.size()) {\n          System.out.println(\"packID=\" + subDocs.packID + \": expected \" + subDocs.subIDs.size() + \" hits but got \" + hits.totalHits);\n          doFail = true;\n        } else {\n          int lastDocID = -1;\n          int startDocID = -1;\n          for(ScoreDoc scoreDoc : hits.scoreDocs) {\n            final int docID = scoreDoc.doc;\n            if (lastDocID != -1) {\n              assertEquals(1+lastDocID, docID);\n            } else {\n              startDocID = docID;\n            }\n            lastDocID = docID;\n            final Document doc = s.doc(docID);\n            assertEquals(subDocs.packID, doc.get(\"packID\"));\n          }\n\n          lastDocID = startDocID - 1;\n          for(String subID : subDocs.subIDs) {\n            hits = s.search(new TermQuery(new Term(\"docid\", subID)), 1);\n            assertEquals(1, hits.totalHits);\n            final int docID = hits.scoreDocs[0].doc;\n            if (lastDocID != -1) {\n              assertEquals(1+lastDocID, docID);\n            }\n            lastDocID = docID;\n          }\n        }\n      } else {\n        // Pack was deleted -- make sure its docs are\n        // deleted.  We can't verify packID is deleted\n        // because we can re-use packID for update:\n        for(String subID : subDocs.subIDs) {\n          assertEquals(0, s.search(new TermQuery(new Term(\"docid\", subID)), 1).totalHits);\n        }\n      }\n    }\n\n    // Verify: make sure all not-deleted docs are in fact\n    // not deleted:\n    final int endID = Integer.parseInt(docs.nextDoc().get(\"docid\"));\n    docs.close();\n\n    for(int id=0;id<endID;id++) {\n      String stringID = \"\"+id;\n      if (!delIDs.contains(stringID)) {\n        final TopDocs hits = s.search(new TermQuery(new Term(\"docid\", stringID)), 1);\n        if (hits.totalHits != 1) {\n          System.out.println(\"doc id=\" + stringID + \" is not supposed to be deleted, but got hitCount=\" + hits.totalHits);\n          doFail = true;\n        }\n      }\n    }\n    assertFalse(doFail);\n    \n    assertEquals(\"index=\" + writer.segString() + \" addCount=\" + addCount + \" delCount=\" + delCount, addCount.get() - delCount.get(), s.getIndexReader().numDocs());\n    releaseSearcher(s);\n\n    writer.commit();\n\n    assertEquals(\"index=\" + writer.segString() + \" addCount=\" + addCount + \" delCount=\" + delCount, addCount.get() - delCount.get(), writer.numDocs());\n\n    doClose();\n    writer.close(false);\n\n    // Cannot shutdown until after writer is closed because\n    // writer has merged segment warmer that uses IS to run\n    // searches, and that IS may be using this es!\n    if (es != null) {\n      es.shutdown();\n      es.awaitTermination(1, TimeUnit.SECONDS);\n    }\n\n    _TestUtil.checkIndex(dir);\n    dir.close();\n    _TestUtil.rmDir(tempDir);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: done [\" + (System.currentTimeMillis()-t0) + \" ms]\");\n    }\n  }\n\n","sourceOld":"  public void runTest(String testName) throws Exception {\n\n    failed.set(false);\n    addCount.set(0);\n    delCount.set(0);\n    packCount.set(0);\n\n    final long t0 = System.currentTimeMillis();\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final File tempDir = _TestUtil.getTempDir(testName);\n    dir = newFSDirectory(tempDir);\n    ((MockDirectoryWrapper) dir).setCheckIndexOnClose(false); // don't double-checkIndex, we do it ourselves.\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).\n        setInfoStream(new FailOnNonBulkMergesInfoStream());\n\n    if (LuceneTestCase.TEST_NIGHTLY) {\n      // newIWConfig makes smallish max seg size, which\n      // results in tons and tons of segments for this test\n      // when run nightly:\n      MergePolicy mp = conf.getMergePolicy();\n      if (mp instanceof TieredMergePolicy) {\n        ((TieredMergePolicy) mp).setMaxMergedSegmentMB(5000.);\n      } else if (mp instanceof LogByteSizeMergePolicy) {\n        ((LogByteSizeMergePolicy) mp).setMaxMergeMB(1000.);\n      } else if (mp instanceof LogMergePolicy) {\n        ((LogMergePolicy) mp).setMaxMergeDocs(100000);\n      }\n    }\n\n    conf.setMergedSegmentWarmer(new IndexWriter.IndexReaderWarmer() {\n      @Override\n      public void warm(AtomicIndexReader reader) throws IOException {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now warm merged reader=\" + reader);\n        }\n        final int maxDoc = reader.maxDoc();\n        final Bits liveDocs = reader.getLiveDocs();\n        int sum = 0;\n        final int inc = Math.max(1, maxDoc/50);\n        for(int docID=0;docID<maxDoc;docID += inc) {\n          if (liveDocs == null || liveDocs.get(docID)) {\n            final Document doc = reader.document(docID);\n            sum += doc.getFields().size();\n          }\n        }\n\n        IndexSearcher searcher = newSearcher(reader);\n        sum += searcher.search(new TermQuery(new Term(\"body\", \"united\")), 10).totalHits;\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: warm visited \" + sum + \" fields\");\n        }\n      }\n      });\n\n    writer = new IndexWriter(dir, conf);\n    _TestUtil.reduceOpenFiles(writer);\n\n    final ExecutorService es = random.nextBoolean() ? null : Executors.newCachedThreadPool(new NamedThreadFactory(testName));\n\n    doAfterWriter(es);\n\n    final int NUM_INDEX_THREADS = _TestUtil.nextInt(random, 2, 4);\n\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 300 : RANDOM_MULTIPLIER;\n\n    final Set<String> delIDs = Collections.synchronizedSet(new HashSet<String>());\n    final Set<String> delPackIDs = Collections.synchronizedSet(new HashSet<String>());\n    final List<SubDocs> allSubDocs = Collections.synchronizedList(new ArrayList<SubDocs>());\n\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC*1000;\n\n    final Thread[] indexThreads = launchIndexingThreads(docs, NUM_INDEX_THREADS, stopTime, delIDs, delPackIDs, allSubDocs);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE start indexing threads [\" + (System.currentTimeMillis()-t0) + \" ms]\");\n    }\n\n    // Let index build up a bit\n    Thread.sleep(100);\n\n    doSearching(es, stopTime);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: all searching done [\" + (System.currentTimeMillis()-t0) + \" ms]\");\n    }\n    \n    for(int thread=0;thread<indexThreads.length;thread++) {\n      indexThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: done join indexing threads [\" + (System.currentTimeMillis()-t0) + \" ms]; addCount=\" + addCount + \" delCount=\" + delCount);\n    }\n\n    final IndexSearcher s = getFinalSearcher();\n    if (VERBOSE) {\n      System.out.println(\"TEST: finalSearcher=\" + s);\n    }\n\n    assertFalse(failed.get());\n\n    boolean doFail = false;\n\n    // Verify: make sure delIDs are in fact deleted:\n    for(String id : delIDs) {\n      final TopDocs hits = s.search(new TermQuery(new Term(\"docid\", id)), 1);\n      if (hits.totalHits != 0) {\n        System.out.println(\"doc id=\" + id + \" is supposed to be deleted, but got \" + hits.totalHits + \" hits; first docID=\" + hits.scoreDocs[0].doc);\n        doFail = true;\n      }\n    }\n\n    // Verify: make sure delPackIDs are in fact deleted:\n    for(String id : delPackIDs) {\n      final TopDocs hits = s.search(new TermQuery(new Term(\"packID\", id)), 1);\n      if (hits.totalHits != 0) {\n        System.out.println(\"packID=\" + id + \" is supposed to be deleted, but got \" + hits.totalHits + \" matches\");\n        doFail = true;\n      }\n    }\n\n    // Verify: make sure each group of sub-docs are still in docID order:\n    for(SubDocs subDocs : allSubDocs) {\n      TopDocs hits = s.search(new TermQuery(new Term(\"packID\", subDocs.packID)), 20);\n      if (!subDocs.deleted) {\n        // We sort by relevance but the scores should be identical so sort falls back to by docID:\n        if (hits.totalHits != subDocs.subIDs.size()) {\n          System.out.println(\"packID=\" + subDocs.packID + \": expected \" + subDocs.subIDs.size() + \" hits but got \" + hits.totalHits);\n          doFail = true;\n        } else {\n          int lastDocID = -1;\n          int startDocID = -1;\n          for(ScoreDoc scoreDoc : hits.scoreDocs) {\n            final int docID = scoreDoc.doc;\n            if (lastDocID != -1) {\n              assertEquals(1+lastDocID, docID);\n            } else {\n              startDocID = docID;\n            }\n            lastDocID = docID;\n            final Document doc = s.doc(docID);\n            assertEquals(subDocs.packID, doc.get(\"packID\"));\n          }\n\n          lastDocID = startDocID - 1;\n          for(String subID : subDocs.subIDs) {\n            hits = s.search(new TermQuery(new Term(\"docid\", subID)), 1);\n            assertEquals(1, hits.totalHits);\n            final int docID = hits.scoreDocs[0].doc;\n            if (lastDocID != -1) {\n              assertEquals(1+lastDocID, docID);\n            }\n            lastDocID = docID;\n          }\n        }\n      } else {\n        // Pack was deleted -- make sure its docs are\n        // deleted.  We can't verify packID is deleted\n        // because we can re-use packID for update:\n        for(String subID : subDocs.subIDs) {\n          assertEquals(0, s.search(new TermQuery(new Term(\"docid\", subID)), 1).totalHits);\n        }\n      }\n    }\n\n    // Verify: make sure all not-deleted docs are in fact\n    // not deleted:\n    final int endID = Integer.parseInt(docs.nextDoc().get(\"docid\"));\n    docs.close();\n\n    for(int id=0;id<endID;id++) {\n      String stringID = \"\"+id;\n      if (!delIDs.contains(stringID)) {\n        final TopDocs hits = s.search(new TermQuery(new Term(\"docid\", stringID)), 1);\n        if (hits.totalHits != 1) {\n          System.out.println(\"doc id=\" + stringID + \" is not supposed to be deleted, but got hitCount=\" + hits.totalHits);\n          doFail = true;\n        }\n      }\n    }\n    assertFalse(doFail);\n    \n    assertEquals(\"index=\" + writer.segString() + \" addCount=\" + addCount + \" delCount=\" + delCount, addCount.get() - delCount.get(), s.getIndexReader().numDocs());\n    releaseSearcher(s);\n\n    writer.commit();\n\n    assertEquals(\"index=\" + writer.segString() + \" addCount=\" + addCount + \" delCount=\" + delCount, addCount.get() - delCount.get(), writer.numDocs());\n\n    doClose();\n    writer.close(false);\n\n    // Cannot shutdown until after writer is closed because\n    // writer has merged segment warmer that uses IS to run\n    // searches, and that IS may be using this es!\n    if (es != null) {\n      es.shutdown();\n      es.awaitTermination(1, TimeUnit.SECONDS);\n    }\n\n    _TestUtil.checkIndex(dir);\n    dir.close();\n    _TestUtil.rmDir(tempDir);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: done [\" + (System.currentTimeMillis()-t0) + \" ms]\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5cab9a86bd67202d20b6adc463008c8e982b070a","date":1327966443,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/src/test-framework/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runTest(String).mjava","pathOld":"lucene/src/test-framework/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runTest(String).mjava","sourceNew":"  public void runTest(String testName) throws Exception {\n\n    failed.set(false);\n    addCount.set(0);\n    delCount.set(0);\n    packCount.set(0);\n\n    final long t0 = System.currentTimeMillis();\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final File tempDir = _TestUtil.getTempDir(testName);\n    dir = newFSDirectory(tempDir);\n    ((MockDirectoryWrapper) dir).setCheckIndexOnClose(false); // don't double-checkIndex, we do it ourselves.\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).\n        setInfoStream(new FailOnNonBulkMergesInfoStream());\n\n    if (LuceneTestCase.TEST_NIGHTLY) {\n      // newIWConfig makes smallish max seg size, which\n      // results in tons and tons of segments for this test\n      // when run nightly:\n      MergePolicy mp = conf.getMergePolicy();\n      if (mp instanceof TieredMergePolicy) {\n        ((TieredMergePolicy) mp).setMaxMergedSegmentMB(5000.);\n      } else if (mp instanceof LogByteSizeMergePolicy) {\n        ((LogByteSizeMergePolicy) mp).setMaxMergeMB(1000.);\n      } else if (mp instanceof LogMergePolicy) {\n        ((LogMergePolicy) mp).setMaxMergeDocs(100000);\n      }\n    }\n\n    conf.setMergedSegmentWarmer(new IndexWriter.IndexReaderWarmer() {\n      @Override\n      public void warm(AtomicReader reader) throws IOException {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now warm merged reader=\" + reader);\n        }\n        final int maxDoc = reader.maxDoc();\n        final Bits liveDocs = reader.getLiveDocs();\n        int sum = 0;\n        final int inc = Math.max(1, maxDoc/50);\n        for(int docID=0;docID<maxDoc;docID += inc) {\n          if (liveDocs == null || liveDocs.get(docID)) {\n            final Document doc = reader.document(docID);\n            sum += doc.getFields().size();\n          }\n        }\n\n        IndexSearcher searcher = newSearcher(reader);\n        sum += searcher.search(new TermQuery(new Term(\"body\", \"united\")), 10).totalHits;\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: warm visited \" + sum + \" fields\");\n        }\n      }\n      });\n\n    writer = new IndexWriter(dir, conf);\n    _TestUtil.reduceOpenFiles(writer);\n\n    final ExecutorService es = random.nextBoolean() ? null : Executors.newCachedThreadPool(new NamedThreadFactory(testName));\n\n    doAfterWriter(es);\n\n    final int NUM_INDEX_THREADS = _TestUtil.nextInt(random, 2, 4);\n\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 300 : RANDOM_MULTIPLIER;\n\n    final Set<String> delIDs = Collections.synchronizedSet(new HashSet<String>());\n    final Set<String> delPackIDs = Collections.synchronizedSet(new HashSet<String>());\n    final List<SubDocs> allSubDocs = Collections.synchronizedList(new ArrayList<SubDocs>());\n\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC*1000;\n\n    final Thread[] indexThreads = launchIndexingThreads(docs, NUM_INDEX_THREADS, stopTime, delIDs, delPackIDs, allSubDocs);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE start indexing threads [\" + (System.currentTimeMillis()-t0) + \" ms]\");\n    }\n\n    // Let index build up a bit\n    Thread.sleep(100);\n\n    doSearching(es, stopTime);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: all searching done [\" + (System.currentTimeMillis()-t0) + \" ms]\");\n    }\n    \n    for(int thread=0;thread<indexThreads.length;thread++) {\n      indexThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: done join indexing threads [\" + (System.currentTimeMillis()-t0) + \" ms]; addCount=\" + addCount + \" delCount=\" + delCount);\n    }\n\n    final IndexSearcher s = getFinalSearcher();\n    if (VERBOSE) {\n      System.out.println(\"TEST: finalSearcher=\" + s);\n    }\n\n    assertFalse(failed.get());\n\n    boolean doFail = false;\n\n    // Verify: make sure delIDs are in fact deleted:\n    for(String id : delIDs) {\n      final TopDocs hits = s.search(new TermQuery(new Term(\"docid\", id)), 1);\n      if (hits.totalHits != 0) {\n        System.out.println(\"doc id=\" + id + \" is supposed to be deleted, but got \" + hits.totalHits + \" hits; first docID=\" + hits.scoreDocs[0].doc);\n        doFail = true;\n      }\n    }\n\n    // Verify: make sure delPackIDs are in fact deleted:\n    for(String id : delPackIDs) {\n      final TopDocs hits = s.search(new TermQuery(new Term(\"packID\", id)), 1);\n      if (hits.totalHits != 0) {\n        System.out.println(\"packID=\" + id + \" is supposed to be deleted, but got \" + hits.totalHits + \" matches\");\n        doFail = true;\n      }\n    }\n\n    // Verify: make sure each group of sub-docs are still in docID order:\n    for(SubDocs subDocs : allSubDocs) {\n      TopDocs hits = s.search(new TermQuery(new Term(\"packID\", subDocs.packID)), 20);\n      if (!subDocs.deleted) {\n        // We sort by relevance but the scores should be identical so sort falls back to by docID:\n        if (hits.totalHits != subDocs.subIDs.size()) {\n          System.out.println(\"packID=\" + subDocs.packID + \": expected \" + subDocs.subIDs.size() + \" hits but got \" + hits.totalHits);\n          doFail = true;\n        } else {\n          int lastDocID = -1;\n          int startDocID = -1;\n          for(ScoreDoc scoreDoc : hits.scoreDocs) {\n            final int docID = scoreDoc.doc;\n            if (lastDocID != -1) {\n              assertEquals(1+lastDocID, docID);\n            } else {\n              startDocID = docID;\n            }\n            lastDocID = docID;\n            final Document doc = s.doc(docID);\n            assertEquals(subDocs.packID, doc.get(\"packID\"));\n          }\n\n          lastDocID = startDocID - 1;\n          for(String subID : subDocs.subIDs) {\n            hits = s.search(new TermQuery(new Term(\"docid\", subID)), 1);\n            assertEquals(1, hits.totalHits);\n            final int docID = hits.scoreDocs[0].doc;\n            if (lastDocID != -1) {\n              assertEquals(1+lastDocID, docID);\n            }\n            lastDocID = docID;\n          }\n        }\n      } else {\n        // Pack was deleted -- make sure its docs are\n        // deleted.  We can't verify packID is deleted\n        // because we can re-use packID for update:\n        for(String subID : subDocs.subIDs) {\n          assertEquals(0, s.search(new TermQuery(new Term(\"docid\", subID)), 1).totalHits);\n        }\n      }\n    }\n\n    // Verify: make sure all not-deleted docs are in fact\n    // not deleted:\n    final int endID = Integer.parseInt(docs.nextDoc().get(\"docid\"));\n    docs.close();\n\n    for(int id=0;id<endID;id++) {\n      String stringID = \"\"+id;\n      if (!delIDs.contains(stringID)) {\n        final TopDocs hits = s.search(new TermQuery(new Term(\"docid\", stringID)), 1);\n        if (hits.totalHits != 1) {\n          System.out.println(\"doc id=\" + stringID + \" is not supposed to be deleted, but got hitCount=\" + hits.totalHits);\n          doFail = true;\n        }\n      }\n    }\n    assertFalse(doFail);\n    \n    assertEquals(\"index=\" + writer.segString() + \" addCount=\" + addCount + \" delCount=\" + delCount, addCount.get() - delCount.get(), s.getIndexReader().numDocs());\n    releaseSearcher(s);\n\n    writer.commit();\n\n    assertEquals(\"index=\" + writer.segString() + \" addCount=\" + addCount + \" delCount=\" + delCount, addCount.get() - delCount.get(), writer.numDocs());\n\n    doClose();\n    writer.close(false);\n\n    // Cannot shutdown until after writer is closed because\n    // writer has merged segment warmer that uses IS to run\n    // searches, and that IS may be using this es!\n    if (es != null) {\n      es.shutdown();\n      es.awaitTermination(1, TimeUnit.SECONDS);\n    }\n\n    _TestUtil.checkIndex(dir);\n    dir.close();\n    _TestUtil.rmDir(tempDir);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: done [\" + (System.currentTimeMillis()-t0) + \" ms]\");\n    }\n  }\n\n","sourceOld":"  public void runTest(String testName) throws Exception {\n\n    failed.set(false);\n    addCount.set(0);\n    delCount.set(0);\n    packCount.set(0);\n\n    final long t0 = System.currentTimeMillis();\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final File tempDir = _TestUtil.getTempDir(testName);\n    dir = newFSDirectory(tempDir);\n    ((MockDirectoryWrapper) dir).setCheckIndexOnClose(false); // don't double-checkIndex, we do it ourselves.\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).\n        setInfoStream(new FailOnNonBulkMergesInfoStream());\n\n    if (LuceneTestCase.TEST_NIGHTLY) {\n      // newIWConfig makes smallish max seg size, which\n      // results in tons and tons of segments for this test\n      // when run nightly:\n      MergePolicy mp = conf.getMergePolicy();\n      if (mp instanceof TieredMergePolicy) {\n        ((TieredMergePolicy) mp).setMaxMergedSegmentMB(5000.);\n      } else if (mp instanceof LogByteSizeMergePolicy) {\n        ((LogByteSizeMergePolicy) mp).setMaxMergeMB(1000.);\n      } else if (mp instanceof LogMergePolicy) {\n        ((LogMergePolicy) mp).setMaxMergeDocs(100000);\n      }\n    }\n\n    conf.setMergedSegmentWarmer(new IndexWriter.IndexReaderWarmer() {\n      @Override\n      public void warm(IndexReader reader) throws IOException {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now warm merged reader=\" + reader);\n        }\n        final int maxDoc = reader.maxDoc();\n        final Bits liveDocs = reader.getLiveDocs();\n        int sum = 0;\n        final int inc = Math.max(1, maxDoc/50);\n        for(int docID=0;docID<maxDoc;docID += inc) {\n          if (liveDocs == null || liveDocs.get(docID)) {\n            final Document doc = reader.document(docID);\n            sum += doc.getFields().size();\n          }\n        }\n\n        IndexSearcher searcher = newSearcher(reader);\n        sum += searcher.search(new TermQuery(new Term(\"body\", \"united\")), 10).totalHits;\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: warm visited \" + sum + \" fields\");\n        }\n      }\n      });\n\n    writer = new IndexWriter(dir, conf);\n    _TestUtil.reduceOpenFiles(writer);\n\n    final ExecutorService es = random.nextBoolean() ? null : Executors.newCachedThreadPool(new NamedThreadFactory(testName));\n\n    doAfterWriter(es);\n\n    final int NUM_INDEX_THREADS = _TestUtil.nextInt(random, 2, 4);\n\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 300 : RANDOM_MULTIPLIER;\n\n    final Set<String> delIDs = Collections.synchronizedSet(new HashSet<String>());\n    final Set<String> delPackIDs = Collections.synchronizedSet(new HashSet<String>());\n    final List<SubDocs> allSubDocs = Collections.synchronizedList(new ArrayList<SubDocs>());\n\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC*1000;\n\n    final Thread[] indexThreads = launchIndexingThreads(docs, NUM_INDEX_THREADS, stopTime, delIDs, delPackIDs, allSubDocs);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE start indexing threads [\" + (System.currentTimeMillis()-t0) + \" ms]\");\n    }\n\n    // Let index build up a bit\n    Thread.sleep(100);\n\n    doSearching(es, stopTime);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: all searching done [\" + (System.currentTimeMillis()-t0) + \" ms]\");\n    }\n    \n    for(int thread=0;thread<indexThreads.length;thread++) {\n      indexThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: done join indexing threads [\" + (System.currentTimeMillis()-t0) + \" ms]; addCount=\" + addCount + \" delCount=\" + delCount);\n    }\n\n    final IndexSearcher s = getFinalSearcher();\n    if (VERBOSE) {\n      System.out.println(\"TEST: finalSearcher=\" + s);\n    }\n\n    assertFalse(failed.get());\n\n    boolean doFail = false;\n\n    // Verify: make sure delIDs are in fact deleted:\n    for(String id : delIDs) {\n      final TopDocs hits = s.search(new TermQuery(new Term(\"docid\", id)), 1);\n      if (hits.totalHits != 0) {\n        System.out.println(\"doc id=\" + id + \" is supposed to be deleted, but got \" + hits.totalHits + \" hits; first docID=\" + hits.scoreDocs[0].doc);\n        doFail = true;\n      }\n    }\n\n    // Verify: make sure delPackIDs are in fact deleted:\n    for(String id : delPackIDs) {\n      final TopDocs hits = s.search(new TermQuery(new Term(\"packID\", id)), 1);\n      if (hits.totalHits != 0) {\n        System.out.println(\"packID=\" + id + \" is supposed to be deleted, but got \" + hits.totalHits + \" matches\");\n        doFail = true;\n      }\n    }\n\n    // Verify: make sure each group of sub-docs are still in docID order:\n    for(SubDocs subDocs : allSubDocs) {\n      TopDocs hits = s.search(new TermQuery(new Term(\"packID\", subDocs.packID)), 20);\n      if (!subDocs.deleted) {\n        // We sort by relevance but the scores should be identical so sort falls back to by docID:\n        if (hits.totalHits != subDocs.subIDs.size()) {\n          System.out.println(\"packID=\" + subDocs.packID + \": expected \" + subDocs.subIDs.size() + \" hits but got \" + hits.totalHits);\n          doFail = true;\n        } else {\n          int lastDocID = -1;\n          int startDocID = -1;\n          for(ScoreDoc scoreDoc : hits.scoreDocs) {\n            final int docID = scoreDoc.doc;\n            if (lastDocID != -1) {\n              assertEquals(1+lastDocID, docID);\n            } else {\n              startDocID = docID;\n            }\n            lastDocID = docID;\n            final Document doc = s.doc(docID);\n            assertEquals(subDocs.packID, doc.get(\"packID\"));\n          }\n\n          lastDocID = startDocID - 1;\n          for(String subID : subDocs.subIDs) {\n            hits = s.search(new TermQuery(new Term(\"docid\", subID)), 1);\n            assertEquals(1, hits.totalHits);\n            final int docID = hits.scoreDocs[0].doc;\n            if (lastDocID != -1) {\n              assertEquals(1+lastDocID, docID);\n            }\n            lastDocID = docID;\n          }\n        }\n      } else {\n        // Pack was deleted -- make sure its docs are\n        // deleted.  We can't verify packID is deleted\n        // because we can re-use packID for update:\n        for(String subID : subDocs.subIDs) {\n          assertEquals(0, s.search(new TermQuery(new Term(\"docid\", subID)), 1).totalHits);\n        }\n      }\n    }\n\n    // Verify: make sure all not-deleted docs are in fact\n    // not deleted:\n    final int endID = Integer.parseInt(docs.nextDoc().get(\"docid\"));\n    docs.close();\n\n    for(int id=0;id<endID;id++) {\n      String stringID = \"\"+id;\n      if (!delIDs.contains(stringID)) {\n        final TopDocs hits = s.search(new TermQuery(new Term(\"docid\", stringID)), 1);\n        if (hits.totalHits != 1) {\n          System.out.println(\"doc id=\" + stringID + \" is not supposed to be deleted, but got hitCount=\" + hits.totalHits);\n          doFail = true;\n        }\n      }\n    }\n    assertFalse(doFail);\n    \n    assertEquals(\"index=\" + writer.segString() + \" addCount=\" + addCount + \" delCount=\" + delCount, addCount.get() - delCount.get(), s.getIndexReader().numDocs());\n    releaseSearcher(s);\n\n    writer.commit();\n\n    assertEquals(\"index=\" + writer.segString() + \" addCount=\" + addCount + \" delCount=\" + delCount, addCount.get() - delCount.get(), writer.numDocs());\n\n    doClose();\n    writer.close(false);\n\n    // Cannot shutdown until after writer is closed because\n    // writer has merged segment warmer that uses IS to run\n    // searches, and that IS may be using this es!\n    if (es != null) {\n      es.shutdown();\n      es.awaitTermination(1, TimeUnit.SECONDS);\n    }\n\n    _TestUtil.checkIndex(dir);\n    dir.close();\n    _TestUtil.rmDir(tempDir);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: done [\" + (System.currentTimeMillis()-t0) + \" ms]\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runTest(String).mjava","pathOld":"lucene/src/test-framework/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#runTest(String).mjava","sourceNew":"  public void runTest(String testName) throws Exception {\n\n    failed.set(false);\n    addCount.set(0);\n    delCount.set(0);\n    packCount.set(0);\n\n    final long t0 = System.currentTimeMillis();\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final File tempDir = _TestUtil.getTempDir(testName);\n    dir = newFSDirectory(tempDir);\n    ((MockDirectoryWrapper) dir).setCheckIndexOnClose(false); // don't double-checkIndex, we do it ourselves.\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).\n        setInfoStream(new FailOnNonBulkMergesInfoStream());\n\n    if (LuceneTestCase.TEST_NIGHTLY) {\n      // newIWConfig makes smallish max seg size, which\n      // results in tons and tons of segments for this test\n      // when run nightly:\n      MergePolicy mp = conf.getMergePolicy();\n      if (mp instanceof TieredMergePolicy) {\n        ((TieredMergePolicy) mp).setMaxMergedSegmentMB(5000.);\n      } else if (mp instanceof LogByteSizeMergePolicy) {\n        ((LogByteSizeMergePolicy) mp).setMaxMergeMB(1000.);\n      } else if (mp instanceof LogMergePolicy) {\n        ((LogMergePolicy) mp).setMaxMergeDocs(100000);\n      }\n    }\n\n    conf.setMergedSegmentWarmer(new IndexWriter.IndexReaderWarmer() {\n      @Override\n      public void warm(AtomicReader reader) throws IOException {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now warm merged reader=\" + reader);\n        }\n        final int maxDoc = reader.maxDoc();\n        final Bits liveDocs = reader.getLiveDocs();\n        int sum = 0;\n        final int inc = Math.max(1, maxDoc/50);\n        for(int docID=0;docID<maxDoc;docID += inc) {\n          if (liveDocs == null || liveDocs.get(docID)) {\n            final Document doc = reader.document(docID);\n            sum += doc.getFields().size();\n          }\n        }\n\n        IndexSearcher searcher = newSearcher(reader);\n        sum += searcher.search(new TermQuery(new Term(\"body\", \"united\")), 10).totalHits;\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: warm visited \" + sum + \" fields\");\n        }\n      }\n      });\n\n    writer = new IndexWriter(dir, conf);\n    _TestUtil.reduceOpenFiles(writer);\n\n    final ExecutorService es = random.nextBoolean() ? null : Executors.newCachedThreadPool(new NamedThreadFactory(testName));\n\n    doAfterWriter(es);\n\n    final int NUM_INDEX_THREADS = _TestUtil.nextInt(random, 2, 4);\n\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 300 : RANDOM_MULTIPLIER;\n\n    final Set<String> delIDs = Collections.synchronizedSet(new HashSet<String>());\n    final Set<String> delPackIDs = Collections.synchronizedSet(new HashSet<String>());\n    final List<SubDocs> allSubDocs = Collections.synchronizedList(new ArrayList<SubDocs>());\n\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC*1000;\n\n    final Thread[] indexThreads = launchIndexingThreads(docs, NUM_INDEX_THREADS, stopTime, delIDs, delPackIDs, allSubDocs);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE start indexing threads [\" + (System.currentTimeMillis()-t0) + \" ms]\");\n    }\n\n    // Let index build up a bit\n    Thread.sleep(100);\n\n    doSearching(es, stopTime);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: all searching done [\" + (System.currentTimeMillis()-t0) + \" ms]\");\n    }\n    \n    for(int thread=0;thread<indexThreads.length;thread++) {\n      indexThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: done join indexing threads [\" + (System.currentTimeMillis()-t0) + \" ms]; addCount=\" + addCount + \" delCount=\" + delCount);\n    }\n\n    final IndexSearcher s = getFinalSearcher();\n    if (VERBOSE) {\n      System.out.println(\"TEST: finalSearcher=\" + s);\n    }\n\n    assertFalse(failed.get());\n\n    boolean doFail = false;\n\n    // Verify: make sure delIDs are in fact deleted:\n    for(String id : delIDs) {\n      final TopDocs hits = s.search(new TermQuery(new Term(\"docid\", id)), 1);\n      if (hits.totalHits != 0) {\n        System.out.println(\"doc id=\" + id + \" is supposed to be deleted, but got \" + hits.totalHits + \" hits; first docID=\" + hits.scoreDocs[0].doc);\n        doFail = true;\n      }\n    }\n\n    // Verify: make sure delPackIDs are in fact deleted:\n    for(String id : delPackIDs) {\n      final TopDocs hits = s.search(new TermQuery(new Term(\"packID\", id)), 1);\n      if (hits.totalHits != 0) {\n        System.out.println(\"packID=\" + id + \" is supposed to be deleted, but got \" + hits.totalHits + \" matches\");\n        doFail = true;\n      }\n    }\n\n    // Verify: make sure each group of sub-docs are still in docID order:\n    for(SubDocs subDocs : allSubDocs) {\n      TopDocs hits = s.search(new TermQuery(new Term(\"packID\", subDocs.packID)), 20);\n      if (!subDocs.deleted) {\n        // We sort by relevance but the scores should be identical so sort falls back to by docID:\n        if (hits.totalHits != subDocs.subIDs.size()) {\n          System.out.println(\"packID=\" + subDocs.packID + \": expected \" + subDocs.subIDs.size() + \" hits but got \" + hits.totalHits);\n          doFail = true;\n        } else {\n          int lastDocID = -1;\n          int startDocID = -1;\n          for(ScoreDoc scoreDoc : hits.scoreDocs) {\n            final int docID = scoreDoc.doc;\n            if (lastDocID != -1) {\n              assertEquals(1+lastDocID, docID);\n            } else {\n              startDocID = docID;\n            }\n            lastDocID = docID;\n            final Document doc = s.doc(docID);\n            assertEquals(subDocs.packID, doc.get(\"packID\"));\n          }\n\n          lastDocID = startDocID - 1;\n          for(String subID : subDocs.subIDs) {\n            hits = s.search(new TermQuery(new Term(\"docid\", subID)), 1);\n            assertEquals(1, hits.totalHits);\n            final int docID = hits.scoreDocs[0].doc;\n            if (lastDocID != -1) {\n              assertEquals(1+lastDocID, docID);\n            }\n            lastDocID = docID;\n          }\n        }\n      } else {\n        // Pack was deleted -- make sure its docs are\n        // deleted.  We can't verify packID is deleted\n        // because we can re-use packID for update:\n        for(String subID : subDocs.subIDs) {\n          assertEquals(0, s.search(new TermQuery(new Term(\"docid\", subID)), 1).totalHits);\n        }\n      }\n    }\n\n    // Verify: make sure all not-deleted docs are in fact\n    // not deleted:\n    final int endID = Integer.parseInt(docs.nextDoc().get(\"docid\"));\n    docs.close();\n\n    for(int id=0;id<endID;id++) {\n      String stringID = \"\"+id;\n      if (!delIDs.contains(stringID)) {\n        final TopDocs hits = s.search(new TermQuery(new Term(\"docid\", stringID)), 1);\n        if (hits.totalHits != 1) {\n          System.out.println(\"doc id=\" + stringID + \" is not supposed to be deleted, but got hitCount=\" + hits.totalHits);\n          doFail = true;\n        }\n      }\n    }\n    assertFalse(doFail);\n    \n    assertEquals(\"index=\" + writer.segString() + \" addCount=\" + addCount + \" delCount=\" + delCount, addCount.get() - delCount.get(), s.getIndexReader().numDocs());\n    releaseSearcher(s);\n\n    writer.commit();\n\n    assertEquals(\"index=\" + writer.segString() + \" addCount=\" + addCount + \" delCount=\" + delCount, addCount.get() - delCount.get(), writer.numDocs());\n\n    doClose();\n    writer.close(false);\n\n    // Cannot shutdown until after writer is closed because\n    // writer has merged segment warmer that uses IS to run\n    // searches, and that IS may be using this es!\n    if (es != null) {\n      es.shutdown();\n      es.awaitTermination(1, TimeUnit.SECONDS);\n    }\n\n    _TestUtil.checkIndex(dir);\n    dir.close();\n    _TestUtil.rmDir(tempDir);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: done [\" + (System.currentTimeMillis()-t0) + \" ms]\");\n    }\n  }\n\n","sourceOld":"  public void runTest(String testName) throws Exception {\n\n    failed.set(false);\n    addCount.set(0);\n    delCount.set(0);\n    packCount.set(0);\n\n    final long t0 = System.currentTimeMillis();\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final File tempDir = _TestUtil.getTempDir(testName);\n    dir = newFSDirectory(tempDir);\n    ((MockDirectoryWrapper) dir).setCheckIndexOnClose(false); // don't double-checkIndex, we do it ourselves.\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).\n        setInfoStream(new FailOnNonBulkMergesInfoStream());\n\n    if (LuceneTestCase.TEST_NIGHTLY) {\n      // newIWConfig makes smallish max seg size, which\n      // results in tons and tons of segments for this test\n      // when run nightly:\n      MergePolicy mp = conf.getMergePolicy();\n      if (mp instanceof TieredMergePolicy) {\n        ((TieredMergePolicy) mp).setMaxMergedSegmentMB(5000.);\n      } else if (mp instanceof LogByteSizeMergePolicy) {\n        ((LogByteSizeMergePolicy) mp).setMaxMergeMB(1000.);\n      } else if (mp instanceof LogMergePolicy) {\n        ((LogMergePolicy) mp).setMaxMergeDocs(100000);\n      }\n    }\n\n    conf.setMergedSegmentWarmer(new IndexWriter.IndexReaderWarmer() {\n      @Override\n      public void warm(AtomicReader reader) throws IOException {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now warm merged reader=\" + reader);\n        }\n        final int maxDoc = reader.maxDoc();\n        final Bits liveDocs = reader.getLiveDocs();\n        int sum = 0;\n        final int inc = Math.max(1, maxDoc/50);\n        for(int docID=0;docID<maxDoc;docID += inc) {\n          if (liveDocs == null || liveDocs.get(docID)) {\n            final Document doc = reader.document(docID);\n            sum += doc.getFields().size();\n          }\n        }\n\n        IndexSearcher searcher = newSearcher(reader);\n        sum += searcher.search(new TermQuery(new Term(\"body\", \"united\")), 10).totalHits;\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: warm visited \" + sum + \" fields\");\n        }\n      }\n      });\n\n    writer = new IndexWriter(dir, conf);\n    _TestUtil.reduceOpenFiles(writer);\n\n    final ExecutorService es = random.nextBoolean() ? null : Executors.newCachedThreadPool(new NamedThreadFactory(testName));\n\n    doAfterWriter(es);\n\n    final int NUM_INDEX_THREADS = _TestUtil.nextInt(random, 2, 4);\n\n    final int RUN_TIME_SEC = LuceneTestCase.TEST_NIGHTLY ? 300 : RANDOM_MULTIPLIER;\n\n    final Set<String> delIDs = Collections.synchronizedSet(new HashSet<String>());\n    final Set<String> delPackIDs = Collections.synchronizedSet(new HashSet<String>());\n    final List<SubDocs> allSubDocs = Collections.synchronizedList(new ArrayList<SubDocs>());\n\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_SEC*1000;\n\n    final Thread[] indexThreads = launchIndexingThreads(docs, NUM_INDEX_THREADS, stopTime, delIDs, delPackIDs, allSubDocs);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: DONE start indexing threads [\" + (System.currentTimeMillis()-t0) + \" ms]\");\n    }\n\n    // Let index build up a bit\n    Thread.sleep(100);\n\n    doSearching(es, stopTime);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: all searching done [\" + (System.currentTimeMillis()-t0) + \" ms]\");\n    }\n    \n    for(int thread=0;thread<indexThreads.length;thread++) {\n      indexThreads[thread].join();\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: done join indexing threads [\" + (System.currentTimeMillis()-t0) + \" ms]; addCount=\" + addCount + \" delCount=\" + delCount);\n    }\n\n    final IndexSearcher s = getFinalSearcher();\n    if (VERBOSE) {\n      System.out.println(\"TEST: finalSearcher=\" + s);\n    }\n\n    assertFalse(failed.get());\n\n    boolean doFail = false;\n\n    // Verify: make sure delIDs are in fact deleted:\n    for(String id : delIDs) {\n      final TopDocs hits = s.search(new TermQuery(new Term(\"docid\", id)), 1);\n      if (hits.totalHits != 0) {\n        System.out.println(\"doc id=\" + id + \" is supposed to be deleted, but got \" + hits.totalHits + \" hits; first docID=\" + hits.scoreDocs[0].doc);\n        doFail = true;\n      }\n    }\n\n    // Verify: make sure delPackIDs are in fact deleted:\n    for(String id : delPackIDs) {\n      final TopDocs hits = s.search(new TermQuery(new Term(\"packID\", id)), 1);\n      if (hits.totalHits != 0) {\n        System.out.println(\"packID=\" + id + \" is supposed to be deleted, but got \" + hits.totalHits + \" matches\");\n        doFail = true;\n      }\n    }\n\n    // Verify: make sure each group of sub-docs are still in docID order:\n    for(SubDocs subDocs : allSubDocs) {\n      TopDocs hits = s.search(new TermQuery(new Term(\"packID\", subDocs.packID)), 20);\n      if (!subDocs.deleted) {\n        // We sort by relevance but the scores should be identical so sort falls back to by docID:\n        if (hits.totalHits != subDocs.subIDs.size()) {\n          System.out.println(\"packID=\" + subDocs.packID + \": expected \" + subDocs.subIDs.size() + \" hits but got \" + hits.totalHits);\n          doFail = true;\n        } else {\n          int lastDocID = -1;\n          int startDocID = -1;\n          for(ScoreDoc scoreDoc : hits.scoreDocs) {\n            final int docID = scoreDoc.doc;\n            if (lastDocID != -1) {\n              assertEquals(1+lastDocID, docID);\n            } else {\n              startDocID = docID;\n            }\n            lastDocID = docID;\n            final Document doc = s.doc(docID);\n            assertEquals(subDocs.packID, doc.get(\"packID\"));\n          }\n\n          lastDocID = startDocID - 1;\n          for(String subID : subDocs.subIDs) {\n            hits = s.search(new TermQuery(new Term(\"docid\", subID)), 1);\n            assertEquals(1, hits.totalHits);\n            final int docID = hits.scoreDocs[0].doc;\n            if (lastDocID != -1) {\n              assertEquals(1+lastDocID, docID);\n            }\n            lastDocID = docID;\n          }\n        }\n      } else {\n        // Pack was deleted -- make sure its docs are\n        // deleted.  We can't verify packID is deleted\n        // because we can re-use packID for update:\n        for(String subID : subDocs.subIDs) {\n          assertEquals(0, s.search(new TermQuery(new Term(\"docid\", subID)), 1).totalHits);\n        }\n      }\n    }\n\n    // Verify: make sure all not-deleted docs are in fact\n    // not deleted:\n    final int endID = Integer.parseInt(docs.nextDoc().get(\"docid\"));\n    docs.close();\n\n    for(int id=0;id<endID;id++) {\n      String stringID = \"\"+id;\n      if (!delIDs.contains(stringID)) {\n        final TopDocs hits = s.search(new TermQuery(new Term(\"docid\", stringID)), 1);\n        if (hits.totalHits != 1) {\n          System.out.println(\"doc id=\" + stringID + \" is not supposed to be deleted, but got hitCount=\" + hits.totalHits);\n          doFail = true;\n        }\n      }\n    }\n    assertFalse(doFail);\n    \n    assertEquals(\"index=\" + writer.segString() + \" addCount=\" + addCount + \" delCount=\" + delCount, addCount.get() - delCount.get(), s.getIndexReader().numDocs());\n    releaseSearcher(s);\n\n    writer.commit();\n\n    assertEquals(\"index=\" + writer.segString() + \" addCount=\" + addCount + \" delCount=\" + delCount, addCount.get() - delCount.get(), writer.numDocs());\n\n    doClose();\n    writer.close(false);\n\n    // Cannot shutdown until after writer is closed because\n    // writer has merged segment warmer that uses IS to run\n    // searches, and that IS may be using this es!\n    if (es != null) {\n      es.shutdown();\n      es.awaitTermination(1, TimeUnit.SECONDS);\n    }\n\n    _TestUtil.checkIndex(dir);\n    dir.close();\n    _TestUtil.rmDir(tempDir);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: done [\" + (System.currentTimeMillis()-t0) + \" ms]\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"7b91922b55d15444d554721b352861d028eb8278":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0e7c2454a6a8237bfd0e953f5b940838408c9055":["06584e6e98d592b34e1329b384182f368d2025e8"],"da6d5ac19a80d65b1e864251f155d30960353b7e":["a85e7319b5cf755cba8f1bfa7365afeb9cc3ad94"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"06584e6e98d592b34e1329b384182f368d2025e8":["602693d7e565c9a90b2a23c7142de80411187e6e"],"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c":["06584e6e98d592b34e1329b384182f368d2025e8","0e7c2454a6a8237bfd0e953f5b940838408c9055"],"602693d7e565c9a90b2a23c7142de80411187e6e":["7b91922b55d15444d554721b352861d028eb8278"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a85e7319b5cf755cba8f1bfa7365afeb9cc3ad94":["0e7c2454a6a8237bfd0e953f5b940838408c9055"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["0e7c2454a6a8237bfd0e953f5b940838408c9055","da6d5ac19a80d65b1e864251f155d30960353b7e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"7b91922b55d15444d554721b352861d028eb8278":["602693d7e565c9a90b2a23c7142de80411187e6e"],"0e7c2454a6a8237bfd0e953f5b940838408c9055":["93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","a85e7319b5cf755cba8f1bfa7365afeb9cc3ad94","5cab9a86bd67202d20b6adc463008c8e982b070a"],"da6d5ac19a80d65b1e864251f155d30960353b7e":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"06584e6e98d592b34e1329b384182f368d2025e8":["0e7c2454a6a8237bfd0e953f5b940838408c9055","93ccd971aca7fb61b7f1b946e44714cfc80bfc7c"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7b91922b55d15444d554721b352861d028eb8278"],"602693d7e565c9a90b2a23c7142de80411187e6e":["06584e6e98d592b34e1329b384182f368d2025e8"],"a85e7319b5cf755cba8f1bfa7365afeb9cc3ad94":["da6d5ac19a80d65b1e864251f155d30960353b7e"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}