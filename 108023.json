{"path":"lucene/core/src/java/org/apache/lucene/store/FSDirectory#deletePendingFiles().mjava","commits":[{"id":"6bfe104fc023fadc9e709f8d17403d2cc61133fe","date":1454446396,"type":1,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/FSDirectory#deletePendingFiles().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deletePendingFiles().mjava","sourceNew":"  /** Try to delete any pending files that we had previously tried to delete but failed\n   *  because we are on Windows and the files were still\n   *  held open. */\n  public void deletePendingFiles() throws IOException {\n    // TODO: we could fix IndexInputs from FSDirectory subclasses to call this when they are closed?\n\n    // Clone the set because it will change as we iterate:\n    List<String> toDelete = new ArrayList<>(pendingDeletes);\n\n    // First pass: delete any segments_N files.  We do these first to be certain stale commit points are removed\n    // before we remove any files they reference.  If any delete of segments_N fails, we leave all other files\n    // undeleted so index is never in a corrupt state:\n    for (String fileName : toDelete) {\n      if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n        if (deleteFile(fileName) == false) {\n          return;\n        }\n      }\n    }\n\n    // Only delete other files if we were able to remove the segments_N files; this way we never\n    // leave a corrupt commit in the index even in the presense of virus checkers:\n    for(String fileName : toDelete) {\n      if (fileName.startsWith(IndexFileNames.SEGMENTS) == false) {\n        deleteFile(fileName);\n      }\n    }\n  }\n\n","sourceOld":"  public void deletePendingFiles() {\n    assert locked();\n\n    // Clone the set because it will change as we iterate:\n    List<String> toDelete = new ArrayList<>(deletable);\n    \n    // First pass: delete any segments_N files.  We do these first to be certain stale commit points are removed\n    // before we remove any files they reference.  If any delete of segments_N fails, we leave all other files\n    // undeleted so index is never in a corrupt state:\n    for (String fileName : toDelete) {\n      RefCount rc = refCounts.get(fileName);\n      if (rc != null && rc.count > 0) {\n        // LUCENE-5904: should never happen!  This means we are about to pending-delete a referenced index file\n        throw new IllegalStateException(\"file \\\"\" + fileName + \"\\\" is in pending delete set but has non-zero refCount=\" + rc.count);\n      } else if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n        if (deleteFile(fileName) == false) {\n          if (infoStream.isEnabled(\"IFD\")) {\n            infoStream.message(\"IFD\", \"failed to remove commit point \\\"\" + fileName + \"\\\"; skipping deletion of all other pending files\");\n          }\n          return;\n        }\n      }\n    }\n\n    // Only delete other files if we were able to remove the segments_N files; this way we never\n    // leave a corrupt commit in the index even in the presense of virus checkers:\n    for(String fileName : toDelete) {\n      if (fileName.startsWith(IndexFileNames.SEGMENTS) == false) {\n        deleteFile(fileName);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fbc04ab124c4db4a06d2a69891c3ec6ac9f934a9","date":1454454426,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/FSDirectory#deletePendingFiles().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/FSDirectory#deletePendingFiles().mjava","sourceNew":"  /** Try to delete any pending files that we had previously tried to delete but failed\n   *  because we are on Windows and the files were still held open. */\n  public synchronized void deletePendingFiles() throws IOException {\n    // TODO: we could fix IndexInputs from FSDirectory subclasses to call this when they are closed?\n\n    // Clone the set because it will change as we iterate:\n    List<String> toDelete = new ArrayList<>(pendingDeletes);\n    System.out.println(\"del pending: \" + pendingDeletes);\n\n    // First pass: delete any segments_N files.  We do these first to be certain stale commit points are removed\n    // before we remove any files they reference.  If any delete of segments_N fails, we leave all other files\n    // undeleted so index is never in a corrupt state:\n    Throwable firstException = null;\n    for (String fileName : toDelete) {\n      if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n        try {\n          if (deleteFile(fileName) == false) {\n            // nocommit\n            System.out.println(\"  false on \" + fileName + \"; skipping the rest\");\n            return;\n          }\n        } catch (Throwable t) {\n          if (firstException == null) {\n            firstException = t;\n          } else {\n            firstException.addSuppressed(t);\n          }\n          // nocommit\n          System.out.println(\"  fail on \" + fileName + \":\");\n          t.printStackTrace(System.out);\n          throw t;\n        }\n      }\n    }\n\n    // Only delete other files if we were able to remove the segments_N files; this way we never\n    // leave a corrupt commit in the index even in the presense of virus checkers:\n    for(String fileName : toDelete) {\n      if (fileName.startsWith(IndexFileNames.SEGMENTS) == false) {\n        try {\n          deleteFile(fileName);\n        } catch (Throwable t) {\n          if (firstException == null) {\n            firstException = t;\n          } else {\n            firstException.addSuppressed(t);\n          }\n          // nocommit\n          System.out.println(\"  fail on \" + fileName + \":\");\n          t.printStackTrace(System.out);\n          throw t;\n        }\n      }\n    }\n\n    // Does nothing if firstException is null:\n    IOUtils.reThrow(firstException);\n  }\n\n","sourceOld":"  /** Try to delete any pending files that we had previously tried to delete but failed\n   *  because we are on Windows and the files were still\n   *  held open. */\n  public void deletePendingFiles() throws IOException {\n    // TODO: we could fix IndexInputs from FSDirectory subclasses to call this when they are closed?\n\n    // Clone the set because it will change as we iterate:\n    List<String> toDelete = new ArrayList<>(pendingDeletes);\n\n    // First pass: delete any segments_N files.  We do these first to be certain stale commit points are removed\n    // before we remove any files they reference.  If any delete of segments_N fails, we leave all other files\n    // undeleted so index is never in a corrupt state:\n    for (String fileName : toDelete) {\n      if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n        if (deleteFile(fileName) == false) {\n          return;\n        }\n      }\n    }\n\n    // Only delete other files if we were able to remove the segments_N files; this way we never\n    // leave a corrupt commit in the index even in the presense of virus checkers:\n    for(String fileName : toDelete) {\n      if (fileName.startsWith(IndexFileNames.SEGMENTS) == false) {\n        deleteFile(fileName);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8f4e2dcb5e470991d83a63c264bfe20880d3b3c1","date":1454513757,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/FSDirectory#deletePendingFiles().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/FSDirectory#deletePendingFiles().mjava","sourceNew":"  /** Try to delete any pending files that we had previously tried to delete but failed\n   *  because we are on Windows and the files were still held open. */\n  public void deletePendingFiles() throws IOException {\n    // nocommit do we need exponential backoff here for windows?\n\n    // TODO: we could fix IndexInputs from FSDirectory subclasses to call this when they are closed?\n\n    Set<String> toDelete = new HashSet<>(pendingDeletes);\n\n    // nocommit heroic exceptions here or not?\n    for(String name : toDelete) {\n      deleteFile(name);\n    }\n  }\n\n","sourceOld":"  /** Try to delete any pending files that we had previously tried to delete but failed\n   *  because we are on Windows and the files were still held open. */\n  public synchronized void deletePendingFiles() throws IOException {\n    // TODO: we could fix IndexInputs from FSDirectory subclasses to call this when they are closed?\n\n    // Clone the set because it will change as we iterate:\n    List<String> toDelete = new ArrayList<>(pendingDeletes);\n    System.out.println(\"del pending: \" + pendingDeletes);\n\n    // First pass: delete any segments_N files.  We do these first to be certain stale commit points are removed\n    // before we remove any files they reference.  If any delete of segments_N fails, we leave all other files\n    // undeleted so index is never in a corrupt state:\n    Throwable firstException = null;\n    for (String fileName : toDelete) {\n      if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n        try {\n          if (deleteFile(fileName) == false) {\n            // nocommit\n            System.out.println(\"  false on \" + fileName + \"; skipping the rest\");\n            return;\n          }\n        } catch (Throwable t) {\n          if (firstException == null) {\n            firstException = t;\n          } else {\n            firstException.addSuppressed(t);\n          }\n          // nocommit\n          System.out.println(\"  fail on \" + fileName + \":\");\n          t.printStackTrace(System.out);\n          throw t;\n        }\n      }\n    }\n\n    // Only delete other files if we were able to remove the segments_N files; this way we never\n    // leave a corrupt commit in the index even in the presense of virus checkers:\n    for(String fileName : toDelete) {\n      if (fileName.startsWith(IndexFileNames.SEGMENTS) == false) {\n        try {\n          deleteFile(fileName);\n        } catch (Throwable t) {\n          if (firstException == null) {\n            firstException = t;\n          } else {\n            firstException.addSuppressed(t);\n          }\n          // nocommit\n          System.out.println(\"  fail on \" + fileName + \":\");\n          t.printStackTrace(System.out);\n          throw t;\n        }\n      }\n    }\n\n    // Does nothing if firstException is null:\n    IOUtils.reThrow(firstException);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"240cd0f67652ccfb87d7c5f8b2486d0f42012daa","date":1454536570,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/FSDirectory#deletePendingFiles().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/FSDirectory#deletePendingFiles().mjava","sourceNew":"  /** Try to delete any pending files that we had previously tried to delete but failed\n   *  because we are on Windows and the files were still held open. */\n  public void deletePendingFiles() throws IOException {\n\n    // TODO: we could fix IndexInputs from FSDirectory subclasses to call this when they are closed?\n\n    // Clone the set since we mutate it in privateDeleteFile:\n    for(String name : new HashSet<>(pendingDeletes)) {\n      privateDeleteFile(name);\n    }\n  }\n\n","sourceOld":"  /** Try to delete any pending files that we had previously tried to delete but failed\n   *  because we are on Windows and the files were still held open. */\n  public void deletePendingFiles() throws IOException {\n    // nocommit do we need exponential backoff here for windows?\n\n    // TODO: we could fix IndexInputs from FSDirectory subclasses to call this when they are closed?\n\n    Set<String> toDelete = new HashSet<>(pendingDeletes);\n\n    // nocommit heroic exceptions here or not?\n    for(String name : toDelete) {\n      deleteFile(name);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"34d6426cef006e0c3625cabe7a7ec1c2b08bc501","date":1454683374,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/FSDirectory#deletePendingFiles().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/FSDirectory#deletePendingFiles().mjava","sourceNew":"  /** Try to delete any pending files that we had previously tried to delete but failed\n   *  because we are on Windows and the files were still held open. */\n  public synchronized void deletePendingFiles() throws IOException {\n    if (pendingDeletes.isEmpty() == false) {\n\n      // TODO: we could fix IndexInputs from FSDirectory subclasses to call this when they are closed?\n\n      // Clone the set since we mutate it in privateDeleteFile:\n      for(String name : new HashSet<>(pendingDeletes)) {\n        privateDeleteFile(name);\n      }\n    }\n  }\n\n","sourceOld":"  /** Try to delete any pending files that we had previously tried to delete but failed\n   *  because we are on Windows and the files were still held open. */\n  public void deletePendingFiles() throws IOException {\n\n    // TODO: we could fix IndexInputs from FSDirectory subclasses to call this when they are closed?\n\n    // Clone the set since we mutate it in privateDeleteFile:\n    for(String name : new HashSet<>(pendingDeletes)) {\n      privateDeleteFile(name);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b470f36a9372c97283360b1304eacbde22df6c0d","date":1454765175,"type":0,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/store/FSDirectory#deletePendingFiles().mjava","pathOld":"/dev/null","sourceNew":"  /** Try to delete any pending files that we had previously tried to delete but failed\n   *  because we are on Windows and the files were still held open. */\n  public synchronized void deletePendingFiles() throws IOException {\n    if (pendingDeletes.isEmpty() == false) {\n\n      // TODO: we could fix IndexInputs from FSDirectory subclasses to call this when they are closed?\n\n      // Clone the set since we mutate it in privateDeleteFile:\n      for(String name : new HashSet<>(pendingDeletes)) {\n        privateDeleteFile(name);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e6acbaae7af722f17204ceccf0f7db5753eccf3","date":1454775255,"type":0,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/store/FSDirectory#deletePendingFiles().mjava","pathOld":"/dev/null","sourceNew":"  /** Try to delete any pending files that we had previously tried to delete but failed\n   *  because we are on Windows and the files were still held open. */\n  public synchronized void deletePendingFiles() throws IOException {\n    if (pendingDeletes.isEmpty() == false) {\n\n      // TODO: we could fix IndexInputs from FSDirectory subclasses to call this when they are closed?\n\n      // Clone the set since we mutate it in privateDeleteFile:\n      for(String name : new HashSet<>(pendingDeletes)) {\n        privateDeleteFile(name);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5a207d19eac354d649c3f0e2cce070017c78125e","date":1454776470,"type":0,"author":"Erick Erickson","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/store/FSDirectory#deletePendingFiles().mjava","pathOld":"/dev/null","sourceNew":"  /** Try to delete any pending files that we had previously tried to delete but failed\n   *  because we are on Windows and the files were still held open. */\n  public synchronized void deletePendingFiles() throws IOException {\n    if (pendingDeletes.isEmpty() == false) {\n\n      // TODO: we could fix IndexInputs from FSDirectory subclasses to call this when they are closed?\n\n      // Clone the set since we mutate it in privateDeleteFile:\n      for(String name : new HashSet<>(pendingDeletes)) {\n        privateDeleteFile(name);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cedcb3038bb218e20fc9c61e3b50642101e656e8","date":1454869299,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/FSDirectory#deletePendingFiles().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/FSDirectory#deletePendingFiles().mjava","sourceNew":"  /** Try to delete any pending files that we had previously tried to delete but failed\n   *  because we are on Windows and the files were still held open. */\n  public synchronized void deletePendingFiles() throws IOException {\n    if (pendingDeletes.isEmpty() == false) {\n\n      // TODO: we could fix IndexInputs from FSDirectory subclasses to call this when they are closed?\n\n      // Clone the set since we mutate it in privateDeleteFile:\n      for(String name : new HashSet<>(pendingDeletes)) {\n        privateDeleteFile(name, true);\n      }\n    }\n  }\n\n","sourceOld":"  /** Try to delete any pending files that we had previously tried to delete but failed\n   *  because we are on Windows and the files were still held open. */\n  public synchronized void deletePendingFiles() throws IOException {\n    if (pendingDeletes.isEmpty() == false) {\n\n      // TODO: we could fix IndexInputs from FSDirectory subclasses to call this when they are closed?\n\n      // Clone the set since we mutate it in privateDeleteFile:\n      for(String name : new HashSet<>(pendingDeletes)) {\n        privateDeleteFile(name);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dd75f58072bba84066e89d61bd7028de1bd5b632","date":1454871793,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/store/FSDirectory#deletePendingFiles().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/FSDirectory#deletePendingFiles().mjava","sourceNew":"  /** Try to delete any pending files that we had previously tried to delete but failed\n   *  because we are on Windows and the files were still held open. */\n  public synchronized void deletePendingFiles() throws IOException {\n    if (pendingDeletes.isEmpty() == false) {\n\n      // TODO: we could fix IndexInputs from FSDirectory subclasses to call this when they are closed?\n\n      // Clone the set since we mutate it in privateDeleteFile:\n      for(String name : new HashSet<>(pendingDeletes)) {\n        privateDeleteFile(name, true);\n      }\n    }\n  }\n\n","sourceOld":"  /** Try to delete any pending files that we had previously tried to delete but failed\n   *  because we are on Windows and the files were still held open. */\n  public synchronized void deletePendingFiles() throws IOException {\n    if (pendingDeletes.isEmpty() == false) {\n\n      // TODO: we could fix IndexInputs from FSDirectory subclasses to call this when they are closed?\n\n      // Clone the set since we mutate it in privateDeleteFile:\n      for(String name : new HashSet<>(pendingDeletes)) {\n        privateDeleteFile(name);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"34d6426cef006e0c3625cabe7a7ec1c2b08bc501":["240cd0f67652ccfb87d7c5f8b2486d0f42012daa"],"fbc04ab124c4db4a06d2a69891c3ec6ac9f934a9":["6bfe104fc023fadc9e709f8d17403d2cc61133fe"],"240cd0f67652ccfb87d7c5f8b2486d0f42012daa":["8f4e2dcb5e470991d83a63c264bfe20880d3b3c1"],"8f4e2dcb5e470991d83a63c264bfe20880d3b3c1":["fbc04ab124c4db4a06d2a69891c3ec6ac9f934a9"],"dd75f58072bba84066e89d61bd7028de1bd5b632":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","cedcb3038bb218e20fc9c61e3b50642101e656e8"],"cedcb3038bb218e20fc9c61e3b50642101e656e8":["5a207d19eac354d649c3f0e2cce070017c78125e"],"5a207d19eac354d649c3f0e2cce070017c78125e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","b470f36a9372c97283360b1304eacbde22df6c0d"],"b470f36a9372c97283360b1304eacbde22df6c0d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","34d6426cef006e0c3625cabe7a7ec1c2b08bc501"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","b470f36a9372c97283360b1304eacbde22df6c0d"],"6bfe104fc023fadc9e709f8d17403d2cc61133fe":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["cedcb3038bb218e20fc9c61e3b50642101e656e8"]},"commit2Childs":{"34d6426cef006e0c3625cabe7a7ec1c2b08bc501":["b470f36a9372c97283360b1304eacbde22df6c0d"],"fbc04ab124c4db4a06d2a69891c3ec6ac9f934a9":["8f4e2dcb5e470991d83a63c264bfe20880d3b3c1"],"240cd0f67652ccfb87d7c5f8b2486d0f42012daa":["34d6426cef006e0c3625cabe7a7ec1c2b08bc501"],"8f4e2dcb5e470991d83a63c264bfe20880d3b3c1":["240cd0f67652ccfb87d7c5f8b2486d0f42012daa"],"dd75f58072bba84066e89d61bd7028de1bd5b632":[],"cedcb3038bb218e20fc9c61e3b50642101e656e8":["dd75f58072bba84066e89d61bd7028de1bd5b632","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5a207d19eac354d649c3f0e2cce070017c78125e":["cedcb3038bb218e20fc9c61e3b50642101e656e8"],"b470f36a9372c97283360b1304eacbde22df6c0d":["5a207d19eac354d649c3f0e2cce070017c78125e","1e6acbaae7af722f17204ceccf0f7db5753eccf3"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":["dd75f58072bba84066e89d61bd7028de1bd5b632"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5a207d19eac354d649c3f0e2cce070017c78125e","b470f36a9372c97283360b1304eacbde22df6c0d","1e6acbaae7af722f17204ceccf0f7db5753eccf3","6bfe104fc023fadc9e709f8d17403d2cc61133fe"],"6bfe104fc023fadc9e709f8d17403d2cc61133fe":["fbc04ab124c4db4a06d2a69891c3ec6ac9f934a9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["dd75f58072bba84066e89d61bd7028de1bd5b632","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}