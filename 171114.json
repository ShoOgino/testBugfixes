{"path":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteSnapshotCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","commits":[{"id":"6146c07c0dee1ae1e42926167acd127fed5ef59d","date":1516129420,"type":1,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteSnapshotCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/DeleteSnapshotCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    String collectionName =  message.getStr(COLLECTION_PROP);\n    String commitName =  message.getStr(CoreAdminParams.COMMIT_NAME);\n    String asyncId = message.getStr(ASYNC);\n    Map<String, String> requestMap = new HashMap<>();\n    NamedList shardRequestResults = new NamedList();\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n    SolrZkClient zkClient = ocmh.zkStateReader.getZkClient();\n\n    Optional<CollectionSnapshotMetaData> meta = SolrSnapshotManager.getCollectionLevelSnapshot(zkClient, collectionName, commitName);\n    if (!meta.isPresent()) { // Snapshot not found. Nothing to do.\n      return;\n    }\n\n    log.info(\"Deleting a snapshot for collection={} with commitName={}\", collectionName, commitName);\n\n    Set<String> existingCores = new HashSet<>();\n    for (Slice s : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica r : s.getReplicas()) {\n        existingCores.add(r.getCoreName());\n      }\n    }\n\n    Set<String> coresWithSnapshot = new HashSet<>();\n    for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n      if (existingCores.contains(m.getCoreName())) {\n        coresWithSnapshot.add(m.getCoreName());\n      }\n    }\n\n    log.info(\"Existing cores with snapshot for collection={} are {}\", collectionName, existingCores);\n    for (Slice slice : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        if (replica.getState() == State.DOWN) {\n          continue; // Since replica is down - no point sending a request.\n        }\n\n        // Note - when a snapshot is found in_progress state - it is the result of overseer\n        // failure while handling the snapshot creation. Since we don't know the exact set of\n        // replicas to contact at this point, we try on all replicas.\n        if (meta.get().getStatus() == SnapshotStatus.InProgress || coresWithSnapshot.contains(replica.getCoreName())) {\n          String coreName = replica.getStr(CORE_NAME_PROP);\n\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CoreAdminParams.ACTION, CoreAdminAction.DELETESNAPSHOT.toString());\n          params.set(NAME, slice.getName());\n          params.set(CORE_NAME_PROP, coreName);\n          params.set(CoreAdminParams.COMMIT_NAME, commitName);\n\n          log.info(\"Sending deletesnapshot request to core={} with commitName={}\", coreName, commitName);\n          ocmh.sendShardRequest(replica.getNodeName(), params, shardHandler, asyncId, requestMap);\n        }\n      }\n    }\n\n    ocmh.processResponses(shardRequestResults, shardHandler, false, null, asyncId, requestMap);\n    NamedList success = (NamedList) shardRequestResults.get(\"success\");\n    List<CoreSnapshotMetaData> replicas = new ArrayList<>();\n    if (success != null) {\n      for ( int i = 0 ; i < success.size() ; i++) {\n        NamedList resp = (NamedList)success.getVal(i);\n        // Unfortunately async processing logic doesn't provide the \"core\" name automatically.\n        String coreName = (String)resp.get(\"core\");\n        coresWithSnapshot.remove(coreName);\n      }\n    }\n\n    if (!coresWithSnapshot.isEmpty()) { // One or more failures.\n      log.warn(\"Failed to delete a snapshot for collection {} with commitName = {}. Snapshot could not be deleted for following cores {}\",\n          collectionName, commitName, coresWithSnapshot);\n\n      List<CoreSnapshotMetaData> replicasWithSnapshot = new ArrayList<>();\n      for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n        if (coresWithSnapshot.contains(m.getCoreName())) {\n          replicasWithSnapshot.add(m);\n        }\n      }\n\n      // Update the ZK meta-data to include only cores with the snapshot. This will enable users to figure out\n      // which cores still contain the named snapshot.\n      CollectionSnapshotMetaData newResult = new CollectionSnapshotMetaData(meta.get().getName(), SnapshotStatus.Failed,\n          meta.get().getCreationDate(), replicasWithSnapshot);\n      SolrSnapshotManager.updateCollectionLevelSnapshot(zkClient, collectionName, newResult);\n      log.info(\"Saved snapshot information for collection={} with commitName={} in Zookeeper as follows\", collectionName, commitName,\n          Utils.toJSON(newResult));\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed to delete snapshot on cores \" + coresWithSnapshot);\n\n    } else {\n      // Delete the ZK path so that we eliminate the references of this snapshot from collection level meta-data.\n      SolrSnapshotManager.deleteCollectionLevelSnapshot(zkClient, collectionName, commitName);\n      log.info(\"Deleted Zookeeper snapshot metdata for collection={} with commitName={}\", collectionName, commitName);\n      log.info(\"Successfully deleted snapshot for collection={} with commitName={}\", collectionName, commitName);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    String collectionName =  message.getStr(COLLECTION_PROP);\n    String commitName =  message.getStr(CoreAdminParams.COMMIT_NAME);\n    String asyncId = message.getStr(ASYNC);\n    Map<String, String> requestMap = new HashMap<>();\n    NamedList shardRequestResults = new NamedList();\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n    SolrZkClient zkClient = ocmh.overseer.getZkController().getZkClient();\n\n    Optional<CollectionSnapshotMetaData> meta = SolrSnapshotManager.getCollectionLevelSnapshot(zkClient, collectionName, commitName);\n    if (!meta.isPresent()) { // Snapshot not found. Nothing to do.\n      return;\n    }\n\n    log.info(\"Deleting a snapshot for collection={} with commitName={}\", collectionName, commitName);\n\n    Set<String> existingCores = new HashSet<>();\n    for (Slice s : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica r : s.getReplicas()) {\n        existingCores.add(r.getCoreName());\n      }\n    }\n\n    Set<String> coresWithSnapshot = new HashSet<>();\n    for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n      if (existingCores.contains(m.getCoreName())) {\n        coresWithSnapshot.add(m.getCoreName());\n      }\n    }\n\n    log.info(\"Existing cores with snapshot for collection={} are {}\", collectionName, existingCores);\n    for (Slice slice : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        if (replica.getState() == State.DOWN) {\n          continue; // Since replica is down - no point sending a request.\n        }\n\n        // Note - when a snapshot is found in_progress state - it is the result of overseer\n        // failure while handling the snapshot creation. Since we don't know the exact set of\n        // replicas to contact at this point, we try on all replicas.\n        if (meta.get().getStatus() == SnapshotStatus.InProgress || coresWithSnapshot.contains(replica.getCoreName())) {\n          String coreName = replica.getStr(CORE_NAME_PROP);\n\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CoreAdminParams.ACTION, CoreAdminAction.DELETESNAPSHOT.toString());\n          params.set(NAME, slice.getName());\n          params.set(CORE_NAME_PROP, coreName);\n          params.set(CoreAdminParams.COMMIT_NAME, commitName);\n\n          log.info(\"Sending deletesnapshot request to core={} with commitName={}\", coreName, commitName);\n          ocmh.sendShardRequest(replica.getNodeName(), params, shardHandler, asyncId, requestMap);\n        }\n      }\n    }\n\n    ocmh.processResponses(shardRequestResults, shardHandler, false, null, asyncId, requestMap);\n    NamedList success = (NamedList) shardRequestResults.get(\"success\");\n    List<CoreSnapshotMetaData> replicas = new ArrayList<>();\n    if (success != null) {\n      for ( int i = 0 ; i < success.size() ; i++) {\n        NamedList resp = (NamedList)success.getVal(i);\n        // Unfortunately async processing logic doesn't provide the \"core\" name automatically.\n        String coreName = (String)resp.get(\"core\");\n        coresWithSnapshot.remove(coreName);\n      }\n    }\n\n    if (!coresWithSnapshot.isEmpty()) { // One or more failures.\n      log.warn(\"Failed to delete a snapshot for collection {} with commitName = {}. Snapshot could not be deleted for following cores {}\",\n          collectionName, commitName, coresWithSnapshot);\n\n      List<CoreSnapshotMetaData> replicasWithSnapshot = new ArrayList<>();\n      for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n        if (coresWithSnapshot.contains(m.getCoreName())) {\n          replicasWithSnapshot.add(m);\n        }\n      }\n\n      // Update the ZK meta-data to include only cores with the snapshot. This will enable users to figure out\n      // which cores still contain the named snapshot.\n      CollectionSnapshotMetaData newResult = new CollectionSnapshotMetaData(meta.get().getName(), SnapshotStatus.Failed,\n          meta.get().getCreationDate(), replicasWithSnapshot);\n      SolrSnapshotManager.updateCollectionLevelSnapshot(zkClient, collectionName, newResult);\n      log.info(\"Saved snapshot information for collection={} with commitName={} in Zookeeper as follows\", collectionName, commitName,\n          Utils.toJSON(newResult));\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed to delete snapshot on cores \" + coresWithSnapshot);\n\n    } else {\n      // Delete the ZK path so that we eliminate the references of this snapshot from collection level meta-data.\n      SolrSnapshotManager.deleteCollectionLevelSnapshot(zkClient, collectionName, commitName);\n      log.info(\"Deleted Zookeeper snapshot metdata for collection={} with commitName={}\", collectionName, commitName);\n      log.info(\"Successfully deleted snapshot for collection={} with commitName={}\", collectionName, commitName);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteSnapshotCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    String collectionName =  message.getStr(COLLECTION_PROP);\n    String commitName =  message.getStr(CoreAdminParams.COMMIT_NAME);\n    String asyncId = message.getStr(ASYNC);\n    Map<String, String> requestMap = new HashMap<>();\n    NamedList shardRequestResults = new NamedList();\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n    SolrZkClient zkClient = ocmh.zkStateReader.getZkClient();\n\n    Optional<CollectionSnapshotMetaData> meta = SolrSnapshotManager.getCollectionLevelSnapshot(zkClient, collectionName, commitName);\n    if (!meta.isPresent()) { // Snapshot not found. Nothing to do.\n      return;\n    }\n\n    log.info(\"Deleting a snapshot for collection={} with commitName={}\", collectionName, commitName);\n\n    Set<String> existingCores = new HashSet<>();\n    for (Slice s : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica r : s.getReplicas()) {\n        existingCores.add(r.getCoreName());\n      }\n    }\n\n    Set<String> coresWithSnapshot = new HashSet<>();\n    for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n      if (existingCores.contains(m.getCoreName())) {\n        coresWithSnapshot.add(m.getCoreName());\n      }\n    }\n\n    log.info(\"Existing cores with snapshot for collection={} are {}\", collectionName, existingCores);\n    for (Slice slice : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        if (replica.getState() == State.DOWN) {\n          continue; // Since replica is down - no point sending a request.\n        }\n\n        // Note - when a snapshot is found in_progress state - it is the result of overseer\n        // failure while handling the snapshot creation. Since we don't know the exact set of\n        // replicas to contact at this point, we try on all replicas.\n        if (meta.get().getStatus() == SnapshotStatus.InProgress || coresWithSnapshot.contains(replica.getCoreName())) {\n          String coreName = replica.getStr(CORE_NAME_PROP);\n\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CoreAdminParams.ACTION, CoreAdminAction.DELETESNAPSHOT.toString());\n          params.set(NAME, slice.getName());\n          params.set(CORE_NAME_PROP, coreName);\n          params.set(CoreAdminParams.COMMIT_NAME, commitName);\n\n          log.info(\"Sending deletesnapshot request to core={} with commitName={}\", coreName, commitName);\n          ocmh.sendShardRequest(replica.getNodeName(), params, shardHandler, asyncId, requestMap);\n        }\n      }\n    }\n\n    ocmh.processResponses(shardRequestResults, shardHandler, false, null, asyncId, requestMap);\n    NamedList success = (NamedList) shardRequestResults.get(\"success\");\n    List<CoreSnapshotMetaData> replicas = new ArrayList<>();\n    if (success != null) {\n      for ( int i = 0 ; i < success.size() ; i++) {\n        NamedList resp = (NamedList)success.getVal(i);\n        // Unfortunately async processing logic doesn't provide the \"core\" name automatically.\n        String coreName = (String)resp.get(\"core\");\n        coresWithSnapshot.remove(coreName);\n      }\n    }\n\n    if (!coresWithSnapshot.isEmpty()) { // One or more failures.\n      log.warn(\"Failed to delete a snapshot for collection {} with commitName = {}. Snapshot could not be deleted for following cores {}\",\n          collectionName, commitName, coresWithSnapshot);\n\n      List<CoreSnapshotMetaData> replicasWithSnapshot = new ArrayList<>();\n      for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n        if (coresWithSnapshot.contains(m.getCoreName())) {\n          replicasWithSnapshot.add(m);\n        }\n      }\n\n      // Update the ZK meta-data to include only cores with the snapshot. This will enable users to figure out\n      // which cores still contain the named snapshot.\n      CollectionSnapshotMetaData newResult = new CollectionSnapshotMetaData(meta.get().getName(), SnapshotStatus.Failed,\n          meta.get().getCreationDate(), replicasWithSnapshot);\n      SolrSnapshotManager.updateCollectionLevelSnapshot(zkClient, collectionName, newResult);\n      log.info(\"Saved snapshot information for collection={} with commitName={} in Zookeeper as follows\", collectionName, commitName,\n          Utils.toJSON(newResult));\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed to delete snapshot on cores \" + coresWithSnapshot);\n\n    } else {\n      // Delete the ZK path so that we eliminate the references of this snapshot from collection level meta-data.\n      SolrSnapshotManager.deleteCollectionLevelSnapshot(zkClient, collectionName, commitName);\n      log.info(\"Deleted Zookeeper snapshot metdata for collection={} with commitName={}\", collectionName, commitName);\n      log.info(\"Successfully deleted snapshot for collection={} with commitName={}\", collectionName, commitName);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteSnapshotCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteSnapshotCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    String collectionName =  message.getStr(COLLECTION_PROP);\n    String commitName =  message.getStr(CoreAdminParams.COMMIT_NAME);\n    String asyncId = message.getStr(ASYNC);\n    Map<String, String> requestMap = new HashMap<>();\n    NamedList shardRequestResults = new NamedList();\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler(ocmh.overseer.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient());\n    SolrZkClient zkClient = ocmh.zkStateReader.getZkClient();\n\n    Optional<CollectionSnapshotMetaData> meta = SolrSnapshotManager.getCollectionLevelSnapshot(zkClient, collectionName, commitName);\n    if (!meta.isPresent()) { // Snapshot not found. Nothing to do.\n      return;\n    }\n\n    log.info(\"Deleting a snapshot for collection={} with commitName={}\", collectionName, commitName);\n\n    Set<String> existingCores = new HashSet<>();\n    for (Slice s : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica r : s.getReplicas()) {\n        existingCores.add(r.getCoreName());\n      }\n    }\n\n    Set<String> coresWithSnapshot = new HashSet<>();\n    for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n      if (existingCores.contains(m.getCoreName())) {\n        coresWithSnapshot.add(m.getCoreName());\n      }\n    }\n\n    log.info(\"Existing cores with snapshot for collection={} are {}\", collectionName, existingCores);\n    for (Slice slice : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        if (replica.getState() == State.DOWN) {\n          continue; // Since replica is down - no point sending a request.\n        }\n\n        // Note - when a snapshot is found in_progress state - it is the result of overseer\n        // failure while handling the snapshot creation. Since we don't know the exact set of\n        // replicas to contact at this point, we try on all replicas.\n        if (meta.get().getStatus() == SnapshotStatus.InProgress || coresWithSnapshot.contains(replica.getCoreName())) {\n          String coreName = replica.getStr(CORE_NAME_PROP);\n\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CoreAdminParams.ACTION, CoreAdminAction.DELETESNAPSHOT.toString());\n          params.set(NAME, slice.getName());\n          params.set(CORE_NAME_PROP, coreName);\n          params.set(CoreAdminParams.COMMIT_NAME, commitName);\n\n          log.info(\"Sending deletesnapshot request to core={} with commitName={}\", coreName, commitName);\n          ocmh.sendShardRequest(replica.getNodeName(), params, shardHandler, asyncId, requestMap);\n        }\n      }\n    }\n\n    ocmh.processResponses(shardRequestResults, shardHandler, false, null, asyncId, requestMap);\n    NamedList success = (NamedList) shardRequestResults.get(\"success\");\n    List<CoreSnapshotMetaData> replicas = new ArrayList<>();\n    if (success != null) {\n      for ( int i = 0 ; i < success.size() ; i++) {\n        NamedList resp = (NamedList)success.getVal(i);\n        // Unfortunately async processing logic doesn't provide the \"core\" name automatically.\n        String coreName = (String)resp.get(\"core\");\n        coresWithSnapshot.remove(coreName);\n      }\n    }\n\n    if (!coresWithSnapshot.isEmpty()) { // One or more failures.\n      log.warn(\"Failed to delete a snapshot for collection {} with commitName = {}. Snapshot could not be deleted for following cores {}\",\n          collectionName, commitName, coresWithSnapshot);\n\n      List<CoreSnapshotMetaData> replicasWithSnapshot = new ArrayList<>();\n      for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n        if (coresWithSnapshot.contains(m.getCoreName())) {\n          replicasWithSnapshot.add(m);\n        }\n      }\n\n      // Update the ZK meta-data to include only cores with the snapshot. This will enable users to figure out\n      // which cores still contain the named snapshot.\n      CollectionSnapshotMetaData newResult = new CollectionSnapshotMetaData(meta.get().getName(), SnapshotStatus.Failed,\n          meta.get().getCreationDate(), replicasWithSnapshot);\n      SolrSnapshotManager.updateCollectionLevelSnapshot(zkClient, collectionName, newResult);\n      log.info(\"Saved snapshot information for collection={} with commitName={} in Zookeeper as follows\", collectionName, commitName,\n          Utils.toJSON(newResult));\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed to delete snapshot on cores \" + coresWithSnapshot);\n\n    } else {\n      // Delete the ZK path so that we eliminate the references of this snapshot from collection level meta-data.\n      SolrSnapshotManager.deleteCollectionLevelSnapshot(zkClient, collectionName, commitName);\n      log.info(\"Deleted Zookeeper snapshot metdata for collection={} with commitName={}\", collectionName, commitName);\n      log.info(\"Successfully deleted snapshot for collection={} with commitName={}\", collectionName, commitName);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    String collectionName =  message.getStr(COLLECTION_PROP);\n    String commitName =  message.getStr(CoreAdminParams.COMMIT_NAME);\n    String asyncId = message.getStr(ASYNC);\n    Map<String, String> requestMap = new HashMap<>();\n    NamedList shardRequestResults = new NamedList();\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n    SolrZkClient zkClient = ocmh.zkStateReader.getZkClient();\n\n    Optional<CollectionSnapshotMetaData> meta = SolrSnapshotManager.getCollectionLevelSnapshot(zkClient, collectionName, commitName);\n    if (!meta.isPresent()) { // Snapshot not found. Nothing to do.\n      return;\n    }\n\n    log.info(\"Deleting a snapshot for collection={} with commitName={}\", collectionName, commitName);\n\n    Set<String> existingCores = new HashSet<>();\n    for (Slice s : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica r : s.getReplicas()) {\n        existingCores.add(r.getCoreName());\n      }\n    }\n\n    Set<String> coresWithSnapshot = new HashSet<>();\n    for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n      if (existingCores.contains(m.getCoreName())) {\n        coresWithSnapshot.add(m.getCoreName());\n      }\n    }\n\n    log.info(\"Existing cores with snapshot for collection={} are {}\", collectionName, existingCores);\n    for (Slice slice : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        if (replica.getState() == State.DOWN) {\n          continue; // Since replica is down - no point sending a request.\n        }\n\n        // Note - when a snapshot is found in_progress state - it is the result of overseer\n        // failure while handling the snapshot creation. Since we don't know the exact set of\n        // replicas to contact at this point, we try on all replicas.\n        if (meta.get().getStatus() == SnapshotStatus.InProgress || coresWithSnapshot.contains(replica.getCoreName())) {\n          String coreName = replica.getStr(CORE_NAME_PROP);\n\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CoreAdminParams.ACTION, CoreAdminAction.DELETESNAPSHOT.toString());\n          params.set(NAME, slice.getName());\n          params.set(CORE_NAME_PROP, coreName);\n          params.set(CoreAdminParams.COMMIT_NAME, commitName);\n\n          log.info(\"Sending deletesnapshot request to core={} with commitName={}\", coreName, commitName);\n          ocmh.sendShardRequest(replica.getNodeName(), params, shardHandler, asyncId, requestMap);\n        }\n      }\n    }\n\n    ocmh.processResponses(shardRequestResults, shardHandler, false, null, asyncId, requestMap);\n    NamedList success = (NamedList) shardRequestResults.get(\"success\");\n    List<CoreSnapshotMetaData> replicas = new ArrayList<>();\n    if (success != null) {\n      for ( int i = 0 ; i < success.size() ; i++) {\n        NamedList resp = (NamedList)success.getVal(i);\n        // Unfortunately async processing logic doesn't provide the \"core\" name automatically.\n        String coreName = (String)resp.get(\"core\");\n        coresWithSnapshot.remove(coreName);\n      }\n    }\n\n    if (!coresWithSnapshot.isEmpty()) { // One or more failures.\n      log.warn(\"Failed to delete a snapshot for collection {} with commitName = {}. Snapshot could not be deleted for following cores {}\",\n          collectionName, commitName, coresWithSnapshot);\n\n      List<CoreSnapshotMetaData> replicasWithSnapshot = new ArrayList<>();\n      for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n        if (coresWithSnapshot.contains(m.getCoreName())) {\n          replicasWithSnapshot.add(m);\n        }\n      }\n\n      // Update the ZK meta-data to include only cores with the snapshot. This will enable users to figure out\n      // which cores still contain the named snapshot.\n      CollectionSnapshotMetaData newResult = new CollectionSnapshotMetaData(meta.get().getName(), SnapshotStatus.Failed,\n          meta.get().getCreationDate(), replicasWithSnapshot);\n      SolrSnapshotManager.updateCollectionLevelSnapshot(zkClient, collectionName, newResult);\n      log.info(\"Saved snapshot information for collection={} with commitName={} in Zookeeper as follows\", collectionName, commitName,\n          Utils.toJSON(newResult));\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed to delete snapshot on cores \" + coresWithSnapshot);\n\n    } else {\n      // Delete the ZK path so that we eliminate the references of this snapshot from collection level meta-data.\n      SolrSnapshotManager.deleteCollectionLevelSnapshot(zkClient, collectionName, commitName);\n      log.info(\"Deleted Zookeeper snapshot metdata for collection={} with commitName={}\", collectionName, commitName);\n      log.info(\"Successfully deleted snapshot for collection={} with commitName={}\", collectionName, commitName);\n    }\n  }\n\n","bugFix":["424ac616f0aeeb2a3c8b6b94084255a0bcab9628"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"59bad1cc1e7f90125a140496e79b06afcedb68ec","date":1554915399,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteSnapshotCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteSnapshotCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    String extCollectionName =  message.getStr(COLLECTION_PROP);\n    String collectionName = ocmh.zkStateReader.getAliases().resolveSimpleAlias(extCollectionName);\n    String commitName =  message.getStr(CoreAdminParams.COMMIT_NAME);\n    String asyncId = message.getStr(ASYNC);\n    Map<String, String> requestMap = new HashMap<>();\n    NamedList shardRequestResults = new NamedList();\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler(ocmh.overseer.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient());\n    SolrZkClient zkClient = ocmh.zkStateReader.getZkClient();\n\n    Optional<CollectionSnapshotMetaData> meta = SolrSnapshotManager.getCollectionLevelSnapshot(zkClient, collectionName, commitName);\n    if (!meta.isPresent()) { // Snapshot not found. Nothing to do.\n      return;\n    }\n\n    log.info(\"Deleting a snapshot for collection={} with commitName={}\", collectionName, commitName);\n\n    Set<String> existingCores = new HashSet<>();\n    for (Slice s : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica r : s.getReplicas()) {\n        existingCores.add(r.getCoreName());\n      }\n    }\n\n    Set<String> coresWithSnapshot = new HashSet<>();\n    for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n      if (existingCores.contains(m.getCoreName())) {\n        coresWithSnapshot.add(m.getCoreName());\n      }\n    }\n\n    log.info(\"Existing cores with snapshot for collection={} are {}\", collectionName, existingCores);\n    for (Slice slice : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        if (replica.getState() == State.DOWN) {\n          continue; // Since replica is down - no point sending a request.\n        }\n\n        // Note - when a snapshot is found in_progress state - it is the result of overseer\n        // failure while handling the snapshot creation. Since we don't know the exact set of\n        // replicas to contact at this point, we try on all replicas.\n        if (meta.get().getStatus() == SnapshotStatus.InProgress || coresWithSnapshot.contains(replica.getCoreName())) {\n          String coreName = replica.getStr(CORE_NAME_PROP);\n\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CoreAdminParams.ACTION, CoreAdminAction.DELETESNAPSHOT.toString());\n          params.set(NAME, slice.getName());\n          params.set(CORE_NAME_PROP, coreName);\n          params.set(CoreAdminParams.COMMIT_NAME, commitName);\n\n          log.info(\"Sending deletesnapshot request to core={} with commitName={}\", coreName, commitName);\n          ocmh.sendShardRequest(replica.getNodeName(), params, shardHandler, asyncId, requestMap);\n        }\n      }\n    }\n\n    ocmh.processResponses(shardRequestResults, shardHandler, false, null, asyncId, requestMap);\n    NamedList success = (NamedList) shardRequestResults.get(\"success\");\n    List<CoreSnapshotMetaData> replicas = new ArrayList<>();\n    if (success != null) {\n      for ( int i = 0 ; i < success.size() ; i++) {\n        NamedList resp = (NamedList)success.getVal(i);\n        // Unfortunately async processing logic doesn't provide the \"core\" name automatically.\n        String coreName = (String)resp.get(\"core\");\n        coresWithSnapshot.remove(coreName);\n      }\n    }\n\n    if (!coresWithSnapshot.isEmpty()) { // One or more failures.\n      log.warn(\"Failed to delete a snapshot for collection {} with commitName = {}. Snapshot could not be deleted for following cores {}\",\n          collectionName, commitName, coresWithSnapshot);\n\n      List<CoreSnapshotMetaData> replicasWithSnapshot = new ArrayList<>();\n      for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n        if (coresWithSnapshot.contains(m.getCoreName())) {\n          replicasWithSnapshot.add(m);\n        }\n      }\n\n      // Update the ZK meta-data to include only cores with the snapshot. This will enable users to figure out\n      // which cores still contain the named snapshot.\n      CollectionSnapshotMetaData newResult = new CollectionSnapshotMetaData(meta.get().getName(), SnapshotStatus.Failed,\n          meta.get().getCreationDate(), replicasWithSnapshot);\n      SolrSnapshotManager.updateCollectionLevelSnapshot(zkClient, collectionName, newResult);\n      log.info(\"Saved snapshot information for collection={} with commitName={} in Zookeeper as follows\", collectionName, commitName,\n          Utils.toJSON(newResult));\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed to delete snapshot on cores \" + coresWithSnapshot);\n\n    } else {\n      // Delete the ZK path so that we eliminate the references of this snapshot from collection level meta-data.\n      SolrSnapshotManager.deleteCollectionLevelSnapshot(zkClient, collectionName, commitName);\n      log.info(\"Deleted Zookeeper snapshot metdata for collection={} with commitName={}\", collectionName, commitName);\n      log.info(\"Successfully deleted snapshot for collection={} with commitName={}\", collectionName, commitName);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    String collectionName =  message.getStr(COLLECTION_PROP);\n    String commitName =  message.getStr(CoreAdminParams.COMMIT_NAME);\n    String asyncId = message.getStr(ASYNC);\n    Map<String, String> requestMap = new HashMap<>();\n    NamedList shardRequestResults = new NamedList();\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler(ocmh.overseer.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient());\n    SolrZkClient zkClient = ocmh.zkStateReader.getZkClient();\n\n    Optional<CollectionSnapshotMetaData> meta = SolrSnapshotManager.getCollectionLevelSnapshot(zkClient, collectionName, commitName);\n    if (!meta.isPresent()) { // Snapshot not found. Nothing to do.\n      return;\n    }\n\n    log.info(\"Deleting a snapshot for collection={} with commitName={}\", collectionName, commitName);\n\n    Set<String> existingCores = new HashSet<>();\n    for (Slice s : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica r : s.getReplicas()) {\n        existingCores.add(r.getCoreName());\n      }\n    }\n\n    Set<String> coresWithSnapshot = new HashSet<>();\n    for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n      if (existingCores.contains(m.getCoreName())) {\n        coresWithSnapshot.add(m.getCoreName());\n      }\n    }\n\n    log.info(\"Existing cores with snapshot for collection={} are {}\", collectionName, existingCores);\n    for (Slice slice : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        if (replica.getState() == State.DOWN) {\n          continue; // Since replica is down - no point sending a request.\n        }\n\n        // Note - when a snapshot is found in_progress state - it is the result of overseer\n        // failure while handling the snapshot creation. Since we don't know the exact set of\n        // replicas to contact at this point, we try on all replicas.\n        if (meta.get().getStatus() == SnapshotStatus.InProgress || coresWithSnapshot.contains(replica.getCoreName())) {\n          String coreName = replica.getStr(CORE_NAME_PROP);\n\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CoreAdminParams.ACTION, CoreAdminAction.DELETESNAPSHOT.toString());\n          params.set(NAME, slice.getName());\n          params.set(CORE_NAME_PROP, coreName);\n          params.set(CoreAdminParams.COMMIT_NAME, commitName);\n\n          log.info(\"Sending deletesnapshot request to core={} with commitName={}\", coreName, commitName);\n          ocmh.sendShardRequest(replica.getNodeName(), params, shardHandler, asyncId, requestMap);\n        }\n      }\n    }\n\n    ocmh.processResponses(shardRequestResults, shardHandler, false, null, asyncId, requestMap);\n    NamedList success = (NamedList) shardRequestResults.get(\"success\");\n    List<CoreSnapshotMetaData> replicas = new ArrayList<>();\n    if (success != null) {\n      for ( int i = 0 ; i < success.size() ; i++) {\n        NamedList resp = (NamedList)success.getVal(i);\n        // Unfortunately async processing logic doesn't provide the \"core\" name automatically.\n        String coreName = (String)resp.get(\"core\");\n        coresWithSnapshot.remove(coreName);\n      }\n    }\n\n    if (!coresWithSnapshot.isEmpty()) { // One or more failures.\n      log.warn(\"Failed to delete a snapshot for collection {} with commitName = {}. Snapshot could not be deleted for following cores {}\",\n          collectionName, commitName, coresWithSnapshot);\n\n      List<CoreSnapshotMetaData> replicasWithSnapshot = new ArrayList<>();\n      for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n        if (coresWithSnapshot.contains(m.getCoreName())) {\n          replicasWithSnapshot.add(m);\n        }\n      }\n\n      // Update the ZK meta-data to include only cores with the snapshot. This will enable users to figure out\n      // which cores still contain the named snapshot.\n      CollectionSnapshotMetaData newResult = new CollectionSnapshotMetaData(meta.get().getName(), SnapshotStatus.Failed,\n          meta.get().getCreationDate(), replicasWithSnapshot);\n      SolrSnapshotManager.updateCollectionLevelSnapshot(zkClient, collectionName, newResult);\n      log.info(\"Saved snapshot information for collection={} with commitName={} in Zookeeper as follows\", collectionName, commitName,\n          Utils.toJSON(newResult));\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed to delete snapshot on cores \" + coresWithSnapshot);\n\n    } else {\n      // Delete the ZK path so that we eliminate the references of this snapshot from collection level meta-data.\n      SolrSnapshotManager.deleteCollectionLevelSnapshot(zkClient, collectionName, commitName);\n      log.info(\"Deleted Zookeeper snapshot metdata for collection={} with commitName={}\", collectionName, commitName);\n      log.info(\"Successfully deleted snapshot for collection={} with commitName={}\", collectionName, commitName);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"69e6520a21709190413a63084ed135271aab1a7c","date":1556607462,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteSnapshotCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteSnapshotCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    String extCollectionName =  message.getStr(COLLECTION_PROP);\n    String collectionName = ocmh.zkStateReader.getAliases().resolveSimpleAlias(extCollectionName);\n    String commitName =  message.getStr(CoreAdminParams.COMMIT_NAME);\n    String asyncId = message.getStr(ASYNC);\n    NamedList shardRequestResults = new NamedList();\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler(ocmh.overseer.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient());\n    SolrZkClient zkClient = ocmh.zkStateReader.getZkClient();\n\n    Optional<CollectionSnapshotMetaData> meta = SolrSnapshotManager.getCollectionLevelSnapshot(zkClient, collectionName, commitName);\n    if (!meta.isPresent()) { // Snapshot not found. Nothing to do.\n      return;\n    }\n\n    log.info(\"Deleting a snapshot for collection={} with commitName={}\", collectionName, commitName);\n\n    Set<String> existingCores = new HashSet<>();\n    for (Slice s : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica r : s.getReplicas()) {\n        existingCores.add(r.getCoreName());\n      }\n    }\n\n    Set<String> coresWithSnapshot = new HashSet<>();\n    for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n      if (existingCores.contains(m.getCoreName())) {\n        coresWithSnapshot.add(m.getCoreName());\n      }\n    }\n\n    final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n    log.info(\"Existing cores with snapshot for collection={} are {}\", collectionName, existingCores);\n    for (Slice slice : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        if (replica.getState() == State.DOWN) {\n          continue; // Since replica is down - no point sending a request.\n        }\n\n        // Note - when a snapshot is found in_progress state - it is the result of overseer\n        // failure while handling the snapshot creation. Since we don't know the exact set of\n        // replicas to contact at this point, we try on all replicas.\n        if (meta.get().getStatus() == SnapshotStatus.InProgress || coresWithSnapshot.contains(replica.getCoreName())) {\n          String coreName = replica.getStr(CORE_NAME_PROP);\n\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CoreAdminParams.ACTION, CoreAdminAction.DELETESNAPSHOT.toString());\n          params.set(NAME, slice.getName());\n          params.set(CORE_NAME_PROP, coreName);\n          params.set(CoreAdminParams.COMMIT_NAME, commitName);\n\n          log.info(\"Sending deletesnapshot request to core={} with commitName={}\", coreName, commitName);\n          shardRequestTracker.sendShardRequest(replica.getNodeName(), params, shardHandler);\n        }\n      }\n    }\n\n    shardRequestTracker.processResponses(shardRequestResults, shardHandler, false, null);\n    NamedList success = (NamedList) shardRequestResults.get(\"success\");\n    List<CoreSnapshotMetaData> replicas = new ArrayList<>();\n    if (success != null) {\n      for ( int i = 0 ; i < success.size() ; i++) {\n        NamedList resp = (NamedList)success.getVal(i);\n        // Unfortunately async processing logic doesn't provide the \"core\" name automatically.\n        String coreName = (String)resp.get(\"core\");\n        coresWithSnapshot.remove(coreName);\n      }\n    }\n\n    if (!coresWithSnapshot.isEmpty()) { // One or more failures.\n      log.warn(\"Failed to delete a snapshot for collection {} with commitName = {}. Snapshot could not be deleted for following cores {}\",\n          collectionName, commitName, coresWithSnapshot);\n\n      List<CoreSnapshotMetaData> replicasWithSnapshot = new ArrayList<>();\n      for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n        if (coresWithSnapshot.contains(m.getCoreName())) {\n          replicasWithSnapshot.add(m);\n        }\n      }\n\n      // Update the ZK meta-data to include only cores with the snapshot. This will enable users to figure out\n      // which cores still contain the named snapshot.\n      CollectionSnapshotMetaData newResult = new CollectionSnapshotMetaData(meta.get().getName(), SnapshotStatus.Failed,\n          meta.get().getCreationDate(), replicasWithSnapshot);\n      SolrSnapshotManager.updateCollectionLevelSnapshot(zkClient, collectionName, newResult);\n      log.info(\"Saved snapshot information for collection={} with commitName={} in Zookeeper as follows\", collectionName, commitName,\n          Utils.toJSON(newResult));\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed to delete snapshot on cores \" + coresWithSnapshot);\n\n    } else {\n      // Delete the ZK path so that we eliminate the references of this snapshot from collection level meta-data.\n      SolrSnapshotManager.deleteCollectionLevelSnapshot(zkClient, collectionName, commitName);\n      log.info(\"Deleted Zookeeper snapshot metdata for collection={} with commitName={}\", collectionName, commitName);\n      log.info(\"Successfully deleted snapshot for collection={} with commitName={}\", collectionName, commitName);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    String extCollectionName =  message.getStr(COLLECTION_PROP);\n    String collectionName = ocmh.zkStateReader.getAliases().resolveSimpleAlias(extCollectionName);\n    String commitName =  message.getStr(CoreAdminParams.COMMIT_NAME);\n    String asyncId = message.getStr(ASYNC);\n    Map<String, String> requestMap = new HashMap<>();\n    NamedList shardRequestResults = new NamedList();\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler(ocmh.overseer.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient());\n    SolrZkClient zkClient = ocmh.zkStateReader.getZkClient();\n\n    Optional<CollectionSnapshotMetaData> meta = SolrSnapshotManager.getCollectionLevelSnapshot(zkClient, collectionName, commitName);\n    if (!meta.isPresent()) { // Snapshot not found. Nothing to do.\n      return;\n    }\n\n    log.info(\"Deleting a snapshot for collection={} with commitName={}\", collectionName, commitName);\n\n    Set<String> existingCores = new HashSet<>();\n    for (Slice s : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica r : s.getReplicas()) {\n        existingCores.add(r.getCoreName());\n      }\n    }\n\n    Set<String> coresWithSnapshot = new HashSet<>();\n    for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n      if (existingCores.contains(m.getCoreName())) {\n        coresWithSnapshot.add(m.getCoreName());\n      }\n    }\n\n    log.info(\"Existing cores with snapshot for collection={} are {}\", collectionName, existingCores);\n    for (Slice slice : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        if (replica.getState() == State.DOWN) {\n          continue; // Since replica is down - no point sending a request.\n        }\n\n        // Note - when a snapshot is found in_progress state - it is the result of overseer\n        // failure while handling the snapshot creation. Since we don't know the exact set of\n        // replicas to contact at this point, we try on all replicas.\n        if (meta.get().getStatus() == SnapshotStatus.InProgress || coresWithSnapshot.contains(replica.getCoreName())) {\n          String coreName = replica.getStr(CORE_NAME_PROP);\n\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CoreAdminParams.ACTION, CoreAdminAction.DELETESNAPSHOT.toString());\n          params.set(NAME, slice.getName());\n          params.set(CORE_NAME_PROP, coreName);\n          params.set(CoreAdminParams.COMMIT_NAME, commitName);\n\n          log.info(\"Sending deletesnapshot request to core={} with commitName={}\", coreName, commitName);\n          ocmh.sendShardRequest(replica.getNodeName(), params, shardHandler, asyncId, requestMap);\n        }\n      }\n    }\n\n    ocmh.processResponses(shardRequestResults, shardHandler, false, null, asyncId, requestMap);\n    NamedList success = (NamedList) shardRequestResults.get(\"success\");\n    List<CoreSnapshotMetaData> replicas = new ArrayList<>();\n    if (success != null) {\n      for ( int i = 0 ; i < success.size() ; i++) {\n        NamedList resp = (NamedList)success.getVal(i);\n        // Unfortunately async processing logic doesn't provide the \"core\" name automatically.\n        String coreName = (String)resp.get(\"core\");\n        coresWithSnapshot.remove(coreName);\n      }\n    }\n\n    if (!coresWithSnapshot.isEmpty()) { // One or more failures.\n      log.warn(\"Failed to delete a snapshot for collection {} with commitName = {}. Snapshot could not be deleted for following cores {}\",\n          collectionName, commitName, coresWithSnapshot);\n\n      List<CoreSnapshotMetaData> replicasWithSnapshot = new ArrayList<>();\n      for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n        if (coresWithSnapshot.contains(m.getCoreName())) {\n          replicasWithSnapshot.add(m);\n        }\n      }\n\n      // Update the ZK meta-data to include only cores with the snapshot. This will enable users to figure out\n      // which cores still contain the named snapshot.\n      CollectionSnapshotMetaData newResult = new CollectionSnapshotMetaData(meta.get().getName(), SnapshotStatus.Failed,\n          meta.get().getCreationDate(), replicasWithSnapshot);\n      SolrSnapshotManager.updateCollectionLevelSnapshot(zkClient, collectionName, newResult);\n      log.info(\"Saved snapshot information for collection={} with commitName={} in Zookeeper as follows\", collectionName, commitName,\n          Utils.toJSON(newResult));\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed to delete snapshot on cores \" + coresWithSnapshot);\n\n    } else {\n      // Delete the ZK path so that we eliminate the references of this snapshot from collection level meta-data.\n      SolrSnapshotManager.deleteCollectionLevelSnapshot(zkClient, collectionName, commitName);\n      log.info(\"Deleted Zookeeper snapshot metdata for collection={} with commitName={}\", collectionName, commitName);\n      log.info(\"Successfully deleted snapshot for collection={} with commitName={}\", collectionName, commitName);\n    }\n  }\n\n","bugFix":["424ac616f0aeeb2a3c8b6b94084255a0bcab9628"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d20dc32a40c1bd7b8b8e2354e6b0b9f956ef758c","date":1562161956,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteSnapshotCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteSnapshotCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    String extCollectionName =  message.getStr(COLLECTION_PROP);\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String collectionName;\n    if (followAliases) {\n      collectionName = ocmh.zkStateReader.getAliases().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n    String commitName =  message.getStr(CoreAdminParams.COMMIT_NAME);\n    String asyncId = message.getStr(ASYNC);\n    NamedList shardRequestResults = new NamedList();\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler(ocmh.overseer.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient());\n    SolrZkClient zkClient = ocmh.zkStateReader.getZkClient();\n\n    Optional<CollectionSnapshotMetaData> meta = SolrSnapshotManager.getCollectionLevelSnapshot(zkClient, collectionName, commitName);\n    if (!meta.isPresent()) { // Snapshot not found. Nothing to do.\n      return;\n    }\n\n    log.info(\"Deleting a snapshot for collection={} with commitName={}\", collectionName, commitName);\n\n    Set<String> existingCores = new HashSet<>();\n    for (Slice s : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica r : s.getReplicas()) {\n        existingCores.add(r.getCoreName());\n      }\n    }\n\n    Set<String> coresWithSnapshot = new HashSet<>();\n    for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n      if (existingCores.contains(m.getCoreName())) {\n        coresWithSnapshot.add(m.getCoreName());\n      }\n    }\n\n    final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n    log.info(\"Existing cores with snapshot for collection={} are {}\", collectionName, existingCores);\n    for (Slice slice : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        if (replica.getState() == State.DOWN) {\n          continue; // Since replica is down - no point sending a request.\n        }\n\n        // Note - when a snapshot is found in_progress state - it is the result of overseer\n        // failure while handling the snapshot creation. Since we don't know the exact set of\n        // replicas to contact at this point, we try on all replicas.\n        if (meta.get().getStatus() == SnapshotStatus.InProgress || coresWithSnapshot.contains(replica.getCoreName())) {\n          String coreName = replica.getStr(CORE_NAME_PROP);\n\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CoreAdminParams.ACTION, CoreAdminAction.DELETESNAPSHOT.toString());\n          params.set(NAME, slice.getName());\n          params.set(CORE_NAME_PROP, coreName);\n          params.set(CoreAdminParams.COMMIT_NAME, commitName);\n\n          log.info(\"Sending deletesnapshot request to core={} with commitName={}\", coreName, commitName);\n          shardRequestTracker.sendShardRequest(replica.getNodeName(), params, shardHandler);\n        }\n      }\n    }\n\n    shardRequestTracker.processResponses(shardRequestResults, shardHandler, false, null);\n    NamedList success = (NamedList) shardRequestResults.get(\"success\");\n    List<CoreSnapshotMetaData> replicas = new ArrayList<>();\n    if (success != null) {\n      for ( int i = 0 ; i < success.size() ; i++) {\n        NamedList resp = (NamedList)success.getVal(i);\n        // Unfortunately async processing logic doesn't provide the \"core\" name automatically.\n        String coreName = (String)resp.get(\"core\");\n        coresWithSnapshot.remove(coreName);\n      }\n    }\n\n    if (!coresWithSnapshot.isEmpty()) { // One or more failures.\n      log.warn(\"Failed to delete a snapshot for collection {} with commitName = {}. Snapshot could not be deleted for following cores {}\",\n          collectionName, commitName, coresWithSnapshot);\n\n      List<CoreSnapshotMetaData> replicasWithSnapshot = new ArrayList<>();\n      for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n        if (coresWithSnapshot.contains(m.getCoreName())) {\n          replicasWithSnapshot.add(m);\n        }\n      }\n\n      // Update the ZK meta-data to include only cores with the snapshot. This will enable users to figure out\n      // which cores still contain the named snapshot.\n      CollectionSnapshotMetaData newResult = new CollectionSnapshotMetaData(meta.get().getName(), SnapshotStatus.Failed,\n          meta.get().getCreationDate(), replicasWithSnapshot);\n      SolrSnapshotManager.updateCollectionLevelSnapshot(zkClient, collectionName, newResult);\n      log.info(\"Saved snapshot information for collection={} with commitName={} in Zookeeper as follows\", collectionName, commitName,\n          Utils.toJSON(newResult));\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed to delete snapshot on cores \" + coresWithSnapshot);\n\n    } else {\n      // Delete the ZK path so that we eliminate the references of this snapshot from collection level meta-data.\n      SolrSnapshotManager.deleteCollectionLevelSnapshot(zkClient, collectionName, commitName);\n      log.info(\"Deleted Zookeeper snapshot metdata for collection={} with commitName={}\", collectionName, commitName);\n      log.info(\"Successfully deleted snapshot for collection={} with commitName={}\", collectionName, commitName);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    String extCollectionName =  message.getStr(COLLECTION_PROP);\n    String collectionName = ocmh.zkStateReader.getAliases().resolveSimpleAlias(extCollectionName);\n    String commitName =  message.getStr(CoreAdminParams.COMMIT_NAME);\n    String asyncId = message.getStr(ASYNC);\n    NamedList shardRequestResults = new NamedList();\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler(ocmh.overseer.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient());\n    SolrZkClient zkClient = ocmh.zkStateReader.getZkClient();\n\n    Optional<CollectionSnapshotMetaData> meta = SolrSnapshotManager.getCollectionLevelSnapshot(zkClient, collectionName, commitName);\n    if (!meta.isPresent()) { // Snapshot not found. Nothing to do.\n      return;\n    }\n\n    log.info(\"Deleting a snapshot for collection={} with commitName={}\", collectionName, commitName);\n\n    Set<String> existingCores = new HashSet<>();\n    for (Slice s : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica r : s.getReplicas()) {\n        existingCores.add(r.getCoreName());\n      }\n    }\n\n    Set<String> coresWithSnapshot = new HashSet<>();\n    for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n      if (existingCores.contains(m.getCoreName())) {\n        coresWithSnapshot.add(m.getCoreName());\n      }\n    }\n\n    final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n    log.info(\"Existing cores with snapshot for collection={} are {}\", collectionName, existingCores);\n    for (Slice slice : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        if (replica.getState() == State.DOWN) {\n          continue; // Since replica is down - no point sending a request.\n        }\n\n        // Note - when a snapshot is found in_progress state - it is the result of overseer\n        // failure while handling the snapshot creation. Since we don't know the exact set of\n        // replicas to contact at this point, we try on all replicas.\n        if (meta.get().getStatus() == SnapshotStatus.InProgress || coresWithSnapshot.contains(replica.getCoreName())) {\n          String coreName = replica.getStr(CORE_NAME_PROP);\n\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CoreAdminParams.ACTION, CoreAdminAction.DELETESNAPSHOT.toString());\n          params.set(NAME, slice.getName());\n          params.set(CORE_NAME_PROP, coreName);\n          params.set(CoreAdminParams.COMMIT_NAME, commitName);\n\n          log.info(\"Sending deletesnapshot request to core={} with commitName={}\", coreName, commitName);\n          shardRequestTracker.sendShardRequest(replica.getNodeName(), params, shardHandler);\n        }\n      }\n    }\n\n    shardRequestTracker.processResponses(shardRequestResults, shardHandler, false, null);\n    NamedList success = (NamedList) shardRequestResults.get(\"success\");\n    List<CoreSnapshotMetaData> replicas = new ArrayList<>();\n    if (success != null) {\n      for ( int i = 0 ; i < success.size() ; i++) {\n        NamedList resp = (NamedList)success.getVal(i);\n        // Unfortunately async processing logic doesn't provide the \"core\" name automatically.\n        String coreName = (String)resp.get(\"core\");\n        coresWithSnapshot.remove(coreName);\n      }\n    }\n\n    if (!coresWithSnapshot.isEmpty()) { // One or more failures.\n      log.warn(\"Failed to delete a snapshot for collection {} with commitName = {}. Snapshot could not be deleted for following cores {}\",\n          collectionName, commitName, coresWithSnapshot);\n\n      List<CoreSnapshotMetaData> replicasWithSnapshot = new ArrayList<>();\n      for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n        if (coresWithSnapshot.contains(m.getCoreName())) {\n          replicasWithSnapshot.add(m);\n        }\n      }\n\n      // Update the ZK meta-data to include only cores with the snapshot. This will enable users to figure out\n      // which cores still contain the named snapshot.\n      CollectionSnapshotMetaData newResult = new CollectionSnapshotMetaData(meta.get().getName(), SnapshotStatus.Failed,\n          meta.get().getCreationDate(), replicasWithSnapshot);\n      SolrSnapshotManager.updateCollectionLevelSnapshot(zkClient, collectionName, newResult);\n      log.info(\"Saved snapshot information for collection={} with commitName={} in Zookeeper as follows\", collectionName, commitName,\n          Utils.toJSON(newResult));\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed to delete snapshot on cores \" + coresWithSnapshot);\n\n    } else {\n      // Delete the ZK path so that we eliminate the references of this snapshot from collection level meta-data.\n      SolrSnapshotManager.deleteCollectionLevelSnapshot(zkClient, collectionName, commitName);\n      log.info(\"Deleted Zookeeper snapshot metdata for collection={} with commitName={}\", collectionName, commitName);\n      log.info(\"Successfully deleted snapshot for collection={} with commitName={}\", collectionName, commitName);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6afb0ba86024b96e8b34cfc2e15562239dc36360","date":1579768208,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteSnapshotCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteSnapshotCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    String extCollectionName =  message.getStr(COLLECTION_PROP);\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String collectionName;\n    if (followAliases) {\n      collectionName = ocmh.zkStateReader.getAliases().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n    String commitName =  message.getStr(CoreAdminParams.COMMIT_NAME);\n    String asyncId = message.getStr(ASYNC);\n    NamedList shardRequestResults = new NamedList();\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler(ocmh.overseer.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient());\n    SolrZkClient zkClient = ocmh.zkStateReader.getZkClient();\n\n    Optional<CollectionSnapshotMetaData> meta = SolrSnapshotManager.getCollectionLevelSnapshot(zkClient, collectionName, commitName);\n    if (!meta.isPresent()) { // Snapshot not found. Nothing to do.\n      return;\n    }\n\n    log.info(\"Deleting a snapshot for collection={} with commitName={}\", collectionName, commitName);\n\n    Set<String> existingCores = new HashSet<>();\n    for (Slice s : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica r : s.getReplicas()) {\n        existingCores.add(r.getCoreName());\n      }\n    }\n\n    Set<String> coresWithSnapshot = new HashSet<>();\n    for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n      if (existingCores.contains(m.getCoreName())) {\n        coresWithSnapshot.add(m.getCoreName());\n      }\n    }\n\n    final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n    log.info(\"Existing cores with snapshot for collection={} are {}\", collectionName, existingCores);\n    for (Slice slice : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        if (replica.getState() == State.DOWN) {\n          continue; // Since replica is down - no point sending a request.\n        }\n\n        // Note - when a snapshot is found in_progress state - it is the result of overseer\n        // failure while handling the snapshot creation. Since we don't know the exact set of\n        // replicas to contact at this point, we try on all replicas.\n        if (meta.get().getStatus() == SnapshotStatus.InProgress || coresWithSnapshot.contains(replica.getCoreName())) {\n          String coreName = replica.getStr(CORE_NAME_PROP);\n\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CoreAdminParams.ACTION, CoreAdminAction.DELETESNAPSHOT.toString());\n          params.set(NAME, slice.getName());\n          params.set(CORE_NAME_PROP, coreName);\n          params.set(CoreAdminParams.COMMIT_NAME, commitName);\n\n          log.info(\"Sending deletesnapshot request to core={} with commitName={}\", coreName, commitName);\n          shardRequestTracker.sendShardRequest(replica.getNodeName(), params, shardHandler);\n        }\n      }\n    }\n\n    shardRequestTracker.processResponses(shardRequestResults, shardHandler, false, null);\n    NamedList success = (NamedList) shardRequestResults.get(\"success\");\n    List<CoreSnapshotMetaData> replicas = new ArrayList<>();\n    if (success != null) {\n      for ( int i = 0 ; i < success.size() ; i++) {\n        NamedList resp = (NamedList)success.getVal(i);\n        // Unfortunately async processing logic doesn't provide the \"core\" name automatically.\n        String coreName = (String)resp.get(\"core\");\n        coresWithSnapshot.remove(coreName);\n      }\n    }\n\n    if (!coresWithSnapshot.isEmpty()) { // One or more failures.\n      log.warn(\"Failed to delete a snapshot for collection {} with commitName = {}. Snapshot could not be deleted for following cores {}\",\n          collectionName, commitName, coresWithSnapshot);\n\n      List<CoreSnapshotMetaData> replicasWithSnapshot = new ArrayList<>();\n      for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n        if (coresWithSnapshot.contains(m.getCoreName())) {\n          replicasWithSnapshot.add(m);\n        }\n      }\n\n      // Update the ZK meta-data to include only cores with the snapshot. This will enable users to figure out\n      // which cores still contain the named snapshot.\n      CollectionSnapshotMetaData newResult = new CollectionSnapshotMetaData(meta.get().getName(), SnapshotStatus.Failed,\n          meta.get().getCreationDate(), replicasWithSnapshot);\n      SolrSnapshotManager.updateCollectionLevelSnapshot(zkClient, collectionName, newResult);\n      log.info(\"Saved snapshot information for collection={} with commitName={} in Zookeeper as follows: {}\", collectionName, commitName,\n          Utils.toJSON(newResult));\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed to delete snapshot on cores \" + coresWithSnapshot);\n\n    } else {\n      // Delete the ZK path so that we eliminate the references of this snapshot from collection level meta-data.\n      SolrSnapshotManager.deleteCollectionLevelSnapshot(zkClient, collectionName, commitName);\n      log.info(\"Deleted Zookeeper snapshot metdata for collection={} with commitName={}\", collectionName, commitName);\n      log.info(\"Successfully deleted snapshot for collection={} with commitName={}\", collectionName, commitName);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    String extCollectionName =  message.getStr(COLLECTION_PROP);\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String collectionName;\n    if (followAliases) {\n      collectionName = ocmh.zkStateReader.getAliases().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n    String commitName =  message.getStr(CoreAdminParams.COMMIT_NAME);\n    String asyncId = message.getStr(ASYNC);\n    NamedList shardRequestResults = new NamedList();\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler(ocmh.overseer.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient());\n    SolrZkClient zkClient = ocmh.zkStateReader.getZkClient();\n\n    Optional<CollectionSnapshotMetaData> meta = SolrSnapshotManager.getCollectionLevelSnapshot(zkClient, collectionName, commitName);\n    if (!meta.isPresent()) { // Snapshot not found. Nothing to do.\n      return;\n    }\n\n    log.info(\"Deleting a snapshot for collection={} with commitName={}\", collectionName, commitName);\n\n    Set<String> existingCores = new HashSet<>();\n    for (Slice s : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica r : s.getReplicas()) {\n        existingCores.add(r.getCoreName());\n      }\n    }\n\n    Set<String> coresWithSnapshot = new HashSet<>();\n    for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n      if (existingCores.contains(m.getCoreName())) {\n        coresWithSnapshot.add(m.getCoreName());\n      }\n    }\n\n    final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n    log.info(\"Existing cores with snapshot for collection={} are {}\", collectionName, existingCores);\n    for (Slice slice : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        if (replica.getState() == State.DOWN) {\n          continue; // Since replica is down - no point sending a request.\n        }\n\n        // Note - when a snapshot is found in_progress state - it is the result of overseer\n        // failure while handling the snapshot creation. Since we don't know the exact set of\n        // replicas to contact at this point, we try on all replicas.\n        if (meta.get().getStatus() == SnapshotStatus.InProgress || coresWithSnapshot.contains(replica.getCoreName())) {\n          String coreName = replica.getStr(CORE_NAME_PROP);\n\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CoreAdminParams.ACTION, CoreAdminAction.DELETESNAPSHOT.toString());\n          params.set(NAME, slice.getName());\n          params.set(CORE_NAME_PROP, coreName);\n          params.set(CoreAdminParams.COMMIT_NAME, commitName);\n\n          log.info(\"Sending deletesnapshot request to core={} with commitName={}\", coreName, commitName);\n          shardRequestTracker.sendShardRequest(replica.getNodeName(), params, shardHandler);\n        }\n      }\n    }\n\n    shardRequestTracker.processResponses(shardRequestResults, shardHandler, false, null);\n    NamedList success = (NamedList) shardRequestResults.get(\"success\");\n    List<CoreSnapshotMetaData> replicas = new ArrayList<>();\n    if (success != null) {\n      for ( int i = 0 ; i < success.size() ; i++) {\n        NamedList resp = (NamedList)success.getVal(i);\n        // Unfortunately async processing logic doesn't provide the \"core\" name automatically.\n        String coreName = (String)resp.get(\"core\");\n        coresWithSnapshot.remove(coreName);\n      }\n    }\n\n    if (!coresWithSnapshot.isEmpty()) { // One or more failures.\n      log.warn(\"Failed to delete a snapshot for collection {} with commitName = {}. Snapshot could not be deleted for following cores {}\",\n          collectionName, commitName, coresWithSnapshot);\n\n      List<CoreSnapshotMetaData> replicasWithSnapshot = new ArrayList<>();\n      for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n        if (coresWithSnapshot.contains(m.getCoreName())) {\n          replicasWithSnapshot.add(m);\n        }\n      }\n\n      // Update the ZK meta-data to include only cores with the snapshot. This will enable users to figure out\n      // which cores still contain the named snapshot.\n      CollectionSnapshotMetaData newResult = new CollectionSnapshotMetaData(meta.get().getName(), SnapshotStatus.Failed,\n          meta.get().getCreationDate(), replicasWithSnapshot);\n      SolrSnapshotManager.updateCollectionLevelSnapshot(zkClient, collectionName, newResult);\n      log.info(\"Saved snapshot information for collection={} with commitName={} in Zookeeper as follows\", collectionName, commitName,\n          Utils.toJSON(newResult));\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed to delete snapshot on cores \" + coresWithSnapshot);\n\n    } else {\n      // Delete the ZK path so that we eliminate the references of this snapshot from collection level meta-data.\n      SolrSnapshotManager.deleteCollectionLevelSnapshot(zkClient, collectionName, commitName);\n      log.info(\"Deleted Zookeeper snapshot metdata for collection={} with commitName={}\", collectionName, commitName);\n      log.info(\"Successfully deleted snapshot for collection={} with commitName={}\", collectionName, commitName);\n    }\n  }\n\n","bugFix":["424ac616f0aeeb2a3c8b6b94084255a0bcab9628"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4abf821a41a2fdca2a1dea148999931d22e20529","date":1587749643,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteSnapshotCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteSnapshotCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    String extCollectionName =  message.getStr(COLLECTION_PROP);\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String collectionName;\n    if (followAliases) {\n      collectionName = ocmh.zkStateReader.getAliases().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n    String commitName =  message.getStr(CoreAdminParams.COMMIT_NAME);\n    String asyncId = message.getStr(ASYNC);\n    NamedList shardRequestResults = new NamedList();\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler(ocmh.overseer.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient());\n    SolrZkClient zkClient = ocmh.zkStateReader.getZkClient();\n\n    Optional<CollectionSnapshotMetaData> meta = SolrSnapshotManager.getCollectionLevelSnapshot(zkClient, collectionName, commitName);\n    if (!meta.isPresent()) { // Snapshot not found. Nothing to do.\n      return;\n    }\n\n    log.info(\"Deleting a snapshot for collection={} with commitName={}\", collectionName, commitName);\n\n    Set<String> existingCores = new HashSet<>();\n    for (Slice s : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica r : s.getReplicas()) {\n        existingCores.add(r.getCoreName());\n      }\n    }\n\n    Set<String> coresWithSnapshot = new HashSet<>();\n    for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n      if (existingCores.contains(m.getCoreName())) {\n        coresWithSnapshot.add(m.getCoreName());\n      }\n    }\n\n    final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n    log.info(\"Existing cores with snapshot for collection={} are {}\", collectionName, existingCores);\n    for (Slice slice : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        if (replica.getState() == State.DOWN) {\n          continue; // Since replica is down - no point sending a request.\n        }\n\n        // Note - when a snapshot is found in_progress state - it is the result of overseer\n        // failure while handling the snapshot creation. Since we don't know the exact set of\n        // replicas to contact at this point, we try on all replicas.\n        if (meta.get().getStatus() == SnapshotStatus.InProgress || coresWithSnapshot.contains(replica.getCoreName())) {\n          String coreName = replica.getStr(CORE_NAME_PROP);\n\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CoreAdminParams.ACTION, CoreAdminAction.DELETESNAPSHOT.toString());\n          params.set(NAME, slice.getName());\n          params.set(CORE_NAME_PROP, coreName);\n          params.set(CoreAdminParams.COMMIT_NAME, commitName);\n\n          log.info(\"Sending deletesnapshot request to core={} with commitName={}\", coreName, commitName);\n          shardRequestTracker.sendShardRequest(replica.getNodeName(), params, shardHandler);\n        }\n      }\n    }\n\n    shardRequestTracker.processResponses(shardRequestResults, shardHandler, false, null);\n    NamedList success = (NamedList) shardRequestResults.get(\"success\");\n    List<CoreSnapshotMetaData> replicas = new ArrayList<>();\n    if (success != null) {\n      for ( int i = 0 ; i < success.size() ; i++) {\n        NamedList resp = (NamedList)success.getVal(i);\n        // Unfortunately async processing logic doesn't provide the \"core\" name automatically.\n        String coreName = (String)resp.get(\"core\");\n        coresWithSnapshot.remove(coreName);\n      }\n    }\n\n    if (!coresWithSnapshot.isEmpty()) { // One or more failures.\n      log.warn(\"Failed to delete a snapshot for collection {} with commitName = {}. Snapshot could not be deleted for following cores {}\",\n          collectionName, commitName, coresWithSnapshot);\n\n      List<CoreSnapshotMetaData> replicasWithSnapshot = new ArrayList<>();\n      for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n        if (coresWithSnapshot.contains(m.getCoreName())) {\n          replicasWithSnapshot.add(m);\n        }\n      }\n\n      // Update the ZK meta-data to include only cores with the snapshot. This will enable users to figure out\n      // which cores still contain the named snapshot.\n      CollectionSnapshotMetaData newResult = new CollectionSnapshotMetaData(meta.get().getName(), SnapshotStatus.Failed,\n          meta.get().getCreationDate(), replicasWithSnapshot);\n      SolrSnapshotManager.updateCollectionLevelSnapshot(zkClient, collectionName, newResult);\n      if (log.isInfoEnabled()) {\n        log.info(\"Saved snapshot information for collection={} with commitName={} in Zookeeper as follows: {}\", collectionName, commitName,\n            Utils.toJSON(newResult));\n      }\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed to delete snapshot on cores \" + coresWithSnapshot);\n\n    } else {\n      // Delete the ZK path so that we eliminate the references of this snapshot from collection level meta-data.\n      SolrSnapshotManager.deleteCollectionLevelSnapshot(zkClient, collectionName, commitName);\n      log.info(\"Deleted Zookeeper snapshot metdata for collection={} with commitName={}\", collectionName, commitName);\n      log.info(\"Successfully deleted snapshot for collection={} with commitName={}\", collectionName, commitName);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    String extCollectionName =  message.getStr(COLLECTION_PROP);\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String collectionName;\n    if (followAliases) {\n      collectionName = ocmh.zkStateReader.getAliases().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n    String commitName =  message.getStr(CoreAdminParams.COMMIT_NAME);\n    String asyncId = message.getStr(ASYNC);\n    NamedList shardRequestResults = new NamedList();\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler(ocmh.overseer.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient());\n    SolrZkClient zkClient = ocmh.zkStateReader.getZkClient();\n\n    Optional<CollectionSnapshotMetaData> meta = SolrSnapshotManager.getCollectionLevelSnapshot(zkClient, collectionName, commitName);\n    if (!meta.isPresent()) { // Snapshot not found. Nothing to do.\n      return;\n    }\n\n    log.info(\"Deleting a snapshot for collection={} with commitName={}\", collectionName, commitName);\n\n    Set<String> existingCores = new HashSet<>();\n    for (Slice s : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica r : s.getReplicas()) {\n        existingCores.add(r.getCoreName());\n      }\n    }\n\n    Set<String> coresWithSnapshot = new HashSet<>();\n    for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n      if (existingCores.contains(m.getCoreName())) {\n        coresWithSnapshot.add(m.getCoreName());\n      }\n    }\n\n    final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n    log.info(\"Existing cores with snapshot for collection={} are {}\", collectionName, existingCores);\n    for (Slice slice : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        if (replica.getState() == State.DOWN) {\n          continue; // Since replica is down - no point sending a request.\n        }\n\n        // Note - when a snapshot is found in_progress state - it is the result of overseer\n        // failure while handling the snapshot creation. Since we don't know the exact set of\n        // replicas to contact at this point, we try on all replicas.\n        if (meta.get().getStatus() == SnapshotStatus.InProgress || coresWithSnapshot.contains(replica.getCoreName())) {\n          String coreName = replica.getStr(CORE_NAME_PROP);\n\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CoreAdminParams.ACTION, CoreAdminAction.DELETESNAPSHOT.toString());\n          params.set(NAME, slice.getName());\n          params.set(CORE_NAME_PROP, coreName);\n          params.set(CoreAdminParams.COMMIT_NAME, commitName);\n\n          log.info(\"Sending deletesnapshot request to core={} with commitName={}\", coreName, commitName);\n          shardRequestTracker.sendShardRequest(replica.getNodeName(), params, shardHandler);\n        }\n      }\n    }\n\n    shardRequestTracker.processResponses(shardRequestResults, shardHandler, false, null);\n    NamedList success = (NamedList) shardRequestResults.get(\"success\");\n    List<CoreSnapshotMetaData> replicas = new ArrayList<>();\n    if (success != null) {\n      for ( int i = 0 ; i < success.size() ; i++) {\n        NamedList resp = (NamedList)success.getVal(i);\n        // Unfortunately async processing logic doesn't provide the \"core\" name automatically.\n        String coreName = (String)resp.get(\"core\");\n        coresWithSnapshot.remove(coreName);\n      }\n    }\n\n    if (!coresWithSnapshot.isEmpty()) { // One or more failures.\n      log.warn(\"Failed to delete a snapshot for collection {} with commitName = {}. Snapshot could not be deleted for following cores {}\",\n          collectionName, commitName, coresWithSnapshot);\n\n      List<CoreSnapshotMetaData> replicasWithSnapshot = new ArrayList<>();\n      for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n        if (coresWithSnapshot.contains(m.getCoreName())) {\n          replicasWithSnapshot.add(m);\n        }\n      }\n\n      // Update the ZK meta-data to include only cores with the snapshot. This will enable users to figure out\n      // which cores still contain the named snapshot.\n      CollectionSnapshotMetaData newResult = new CollectionSnapshotMetaData(meta.get().getName(), SnapshotStatus.Failed,\n          meta.get().getCreationDate(), replicasWithSnapshot);\n      SolrSnapshotManager.updateCollectionLevelSnapshot(zkClient, collectionName, newResult);\n      log.info(\"Saved snapshot information for collection={} with commitName={} in Zookeeper as follows: {}\", collectionName, commitName,\n          Utils.toJSON(newResult));\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed to delete snapshot on cores \" + coresWithSnapshot);\n\n    } else {\n      // Delete the ZK path so that we eliminate the references of this snapshot from collection level meta-data.\n      SolrSnapshotManager.deleteCollectionLevelSnapshot(zkClient, collectionName, commitName);\n      log.info(\"Deleted Zookeeper snapshot metdata for collection={} with commitName={}\", collectionName, commitName);\n      log.info(\"Successfully deleted snapshot for collection={} with commitName={}\", collectionName, commitName);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"86968c6cf51846df861b8f29bd85b6d9a7c9f19c","date":1591481497,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteSnapshotCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteSnapshotCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\"})\n  public void call(ClusterState state, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    String extCollectionName =  message.getStr(COLLECTION_PROP);\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String collectionName;\n    if (followAliases) {\n      collectionName = ocmh.zkStateReader.getAliases().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n    String commitName =  message.getStr(CoreAdminParams.COMMIT_NAME);\n    String asyncId = message.getStr(ASYNC);\n    @SuppressWarnings({\"rawtypes\"})\n    NamedList shardRequestResults = new NamedList();\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler(ocmh.overseer.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient());\n    SolrZkClient zkClient = ocmh.zkStateReader.getZkClient();\n\n    Optional<CollectionSnapshotMetaData> meta = SolrSnapshotManager.getCollectionLevelSnapshot(zkClient, collectionName, commitName);\n    if (!meta.isPresent()) { // Snapshot not found. Nothing to do.\n      return;\n    }\n\n    log.info(\"Deleting a snapshot for collection={} with commitName={}\", collectionName, commitName);\n\n    Set<String> existingCores = new HashSet<>();\n    for (Slice s : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica r : s.getReplicas()) {\n        existingCores.add(r.getCoreName());\n      }\n    }\n\n    Set<String> coresWithSnapshot = new HashSet<>();\n    for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n      if (existingCores.contains(m.getCoreName())) {\n        coresWithSnapshot.add(m.getCoreName());\n      }\n    }\n\n    final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n    log.info(\"Existing cores with snapshot for collection={} are {}\", collectionName, existingCores);\n    for (Slice slice : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        if (replica.getState() == State.DOWN) {\n          continue; // Since replica is down - no point sending a request.\n        }\n\n        // Note - when a snapshot is found in_progress state - it is the result of overseer\n        // failure while handling the snapshot creation. Since we don't know the exact set of\n        // replicas to contact at this point, we try on all replicas.\n        if (meta.get().getStatus() == SnapshotStatus.InProgress || coresWithSnapshot.contains(replica.getCoreName())) {\n          String coreName = replica.getStr(CORE_NAME_PROP);\n\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CoreAdminParams.ACTION, CoreAdminAction.DELETESNAPSHOT.toString());\n          params.set(NAME, slice.getName());\n          params.set(CORE_NAME_PROP, coreName);\n          params.set(CoreAdminParams.COMMIT_NAME, commitName);\n\n          log.info(\"Sending deletesnapshot request to core={} with commitName={}\", coreName, commitName);\n          shardRequestTracker.sendShardRequest(replica.getNodeName(), params, shardHandler);\n        }\n      }\n    }\n\n    shardRequestTracker.processResponses(shardRequestResults, shardHandler, false, null);\n    @SuppressWarnings({\"rawtypes\"})\n    NamedList success = (NamedList) shardRequestResults.get(\"success\");\n    List<CoreSnapshotMetaData> replicas = new ArrayList<>();\n    if (success != null) {\n      for ( int i = 0 ; i < success.size() ; i++) {\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList resp = (NamedList)success.getVal(i);\n        // Unfortunately async processing logic doesn't provide the \"core\" name automatically.\n        String coreName = (String)resp.get(\"core\");\n        coresWithSnapshot.remove(coreName);\n      }\n    }\n\n    if (!coresWithSnapshot.isEmpty()) { // One or more failures.\n      log.warn(\"Failed to delete a snapshot for collection {} with commitName = {}. Snapshot could not be deleted for following cores {}\",\n          collectionName, commitName, coresWithSnapshot);\n\n      List<CoreSnapshotMetaData> replicasWithSnapshot = new ArrayList<>();\n      for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n        if (coresWithSnapshot.contains(m.getCoreName())) {\n          replicasWithSnapshot.add(m);\n        }\n      }\n\n      // Update the ZK meta-data to include only cores with the snapshot. This will enable users to figure out\n      // which cores still contain the named snapshot.\n      CollectionSnapshotMetaData newResult = new CollectionSnapshotMetaData(meta.get().getName(), SnapshotStatus.Failed,\n          meta.get().getCreationDate(), replicasWithSnapshot);\n      SolrSnapshotManager.updateCollectionLevelSnapshot(zkClient, collectionName, newResult);\n      if (log.isInfoEnabled()) {\n        log.info(\"Saved snapshot information for collection={} with commitName={} in Zookeeper as follows: {}\", collectionName, commitName,\n            Utils.toJSON(newResult));\n      }\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed to delete snapshot on cores \" + coresWithSnapshot);\n\n    } else {\n      // Delete the ZK path so that we eliminate the references of this snapshot from collection level meta-data.\n      SolrSnapshotManager.deleteCollectionLevelSnapshot(zkClient, collectionName, commitName);\n      log.info(\"Deleted Zookeeper snapshot metdata for collection={} with commitName={}\", collectionName, commitName);\n      log.info(\"Successfully deleted snapshot for collection={} with commitName={}\", collectionName, commitName);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    String extCollectionName =  message.getStr(COLLECTION_PROP);\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String collectionName;\n    if (followAliases) {\n      collectionName = ocmh.zkStateReader.getAliases().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n    String commitName =  message.getStr(CoreAdminParams.COMMIT_NAME);\n    String asyncId = message.getStr(ASYNC);\n    NamedList shardRequestResults = new NamedList();\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler(ocmh.overseer.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient());\n    SolrZkClient zkClient = ocmh.zkStateReader.getZkClient();\n\n    Optional<CollectionSnapshotMetaData> meta = SolrSnapshotManager.getCollectionLevelSnapshot(zkClient, collectionName, commitName);\n    if (!meta.isPresent()) { // Snapshot not found. Nothing to do.\n      return;\n    }\n\n    log.info(\"Deleting a snapshot for collection={} with commitName={}\", collectionName, commitName);\n\n    Set<String> existingCores = new HashSet<>();\n    for (Slice s : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica r : s.getReplicas()) {\n        existingCores.add(r.getCoreName());\n      }\n    }\n\n    Set<String> coresWithSnapshot = new HashSet<>();\n    for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n      if (existingCores.contains(m.getCoreName())) {\n        coresWithSnapshot.add(m.getCoreName());\n      }\n    }\n\n    final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n    log.info(\"Existing cores with snapshot for collection={} are {}\", collectionName, existingCores);\n    for (Slice slice : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        if (replica.getState() == State.DOWN) {\n          continue; // Since replica is down - no point sending a request.\n        }\n\n        // Note - when a snapshot is found in_progress state - it is the result of overseer\n        // failure while handling the snapshot creation. Since we don't know the exact set of\n        // replicas to contact at this point, we try on all replicas.\n        if (meta.get().getStatus() == SnapshotStatus.InProgress || coresWithSnapshot.contains(replica.getCoreName())) {\n          String coreName = replica.getStr(CORE_NAME_PROP);\n\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CoreAdminParams.ACTION, CoreAdminAction.DELETESNAPSHOT.toString());\n          params.set(NAME, slice.getName());\n          params.set(CORE_NAME_PROP, coreName);\n          params.set(CoreAdminParams.COMMIT_NAME, commitName);\n\n          log.info(\"Sending deletesnapshot request to core={} with commitName={}\", coreName, commitName);\n          shardRequestTracker.sendShardRequest(replica.getNodeName(), params, shardHandler);\n        }\n      }\n    }\n\n    shardRequestTracker.processResponses(shardRequestResults, shardHandler, false, null);\n    NamedList success = (NamedList) shardRequestResults.get(\"success\");\n    List<CoreSnapshotMetaData> replicas = new ArrayList<>();\n    if (success != null) {\n      for ( int i = 0 ; i < success.size() ; i++) {\n        NamedList resp = (NamedList)success.getVal(i);\n        // Unfortunately async processing logic doesn't provide the \"core\" name automatically.\n        String coreName = (String)resp.get(\"core\");\n        coresWithSnapshot.remove(coreName);\n      }\n    }\n\n    if (!coresWithSnapshot.isEmpty()) { // One or more failures.\n      log.warn(\"Failed to delete a snapshot for collection {} with commitName = {}. Snapshot could not be deleted for following cores {}\",\n          collectionName, commitName, coresWithSnapshot);\n\n      List<CoreSnapshotMetaData> replicasWithSnapshot = new ArrayList<>();\n      for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n        if (coresWithSnapshot.contains(m.getCoreName())) {\n          replicasWithSnapshot.add(m);\n        }\n      }\n\n      // Update the ZK meta-data to include only cores with the snapshot. This will enable users to figure out\n      // which cores still contain the named snapshot.\n      CollectionSnapshotMetaData newResult = new CollectionSnapshotMetaData(meta.get().getName(), SnapshotStatus.Failed,\n          meta.get().getCreationDate(), replicasWithSnapshot);\n      SolrSnapshotManager.updateCollectionLevelSnapshot(zkClient, collectionName, newResult);\n      if (log.isInfoEnabled()) {\n        log.info(\"Saved snapshot information for collection={} with commitName={} in Zookeeper as follows: {}\", collectionName, commitName,\n            Utils.toJSON(newResult));\n      }\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed to delete snapshot on cores \" + coresWithSnapshot);\n\n    } else {\n      // Delete the ZK path so that we eliminate the references of this snapshot from collection level meta-data.\n      SolrSnapshotManager.deleteCollectionLevelSnapshot(zkClient, collectionName, commitName);\n      log.info(\"Deleted Zookeeper snapshot metdata for collection={} with commitName={}\", collectionName, commitName);\n      log.info(\"Successfully deleted snapshot for collection={} with commitName={}\", collectionName, commitName);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1964c059f45ae1de1877f9f0fe3ca327ea4218e8","date":1594088246,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteSnapshotCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteSnapshotCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\"})\n  public void call(ClusterState state, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    String extCollectionName =  message.getStr(COLLECTION_PROP);\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String collectionName;\n    if (followAliases) {\n      collectionName = ocmh.zkStateReader.getAliases().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n    String commitName =  message.getStr(CoreAdminParams.COMMIT_NAME);\n    String asyncId = message.getStr(ASYNC);\n    @SuppressWarnings({\"rawtypes\"})\n    NamedList shardRequestResults = new NamedList();\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n    SolrZkClient zkClient = ocmh.zkStateReader.getZkClient();\n\n    Optional<CollectionSnapshotMetaData> meta = SolrSnapshotManager.getCollectionLevelSnapshot(zkClient, collectionName, commitName);\n    if (!meta.isPresent()) { // Snapshot not found. Nothing to do.\n      return;\n    }\n\n    log.info(\"Deleting a snapshot for collection={} with commitName={}\", collectionName, commitName);\n\n    Set<String> existingCores = new HashSet<>();\n    for (Slice s : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica r : s.getReplicas()) {\n        existingCores.add(r.getCoreName());\n      }\n    }\n\n    Set<String> coresWithSnapshot = new HashSet<>();\n    for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n      if (existingCores.contains(m.getCoreName())) {\n        coresWithSnapshot.add(m.getCoreName());\n      }\n    }\n\n    final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n    log.info(\"Existing cores with snapshot for collection={} are {}\", collectionName, existingCores);\n    for (Slice slice : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        if (replica.getState() == State.DOWN) {\n          continue; // Since replica is down - no point sending a request.\n        }\n\n        // Note - when a snapshot is found in_progress state - it is the result of overseer\n        // failure while handling the snapshot creation. Since we don't know the exact set of\n        // replicas to contact at this point, we try on all replicas.\n        if (meta.get().getStatus() == SnapshotStatus.InProgress || coresWithSnapshot.contains(replica.getCoreName())) {\n          String coreName = replica.getStr(CORE_NAME_PROP);\n\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CoreAdminParams.ACTION, CoreAdminAction.DELETESNAPSHOT.toString());\n          params.set(NAME, slice.getName());\n          params.set(CORE_NAME_PROP, coreName);\n          params.set(CoreAdminParams.COMMIT_NAME, commitName);\n\n          log.info(\"Sending deletesnapshot request to core={} with commitName={}\", coreName, commitName);\n          shardRequestTracker.sendShardRequest(replica.getNodeName(), params, shardHandler);\n        }\n      }\n    }\n\n    shardRequestTracker.processResponses(shardRequestResults, shardHandler, false, null);\n    @SuppressWarnings({\"rawtypes\"})\n    NamedList success = (NamedList) shardRequestResults.get(\"success\");\n    List<CoreSnapshotMetaData> replicas = new ArrayList<>();\n    if (success != null) {\n      for ( int i = 0 ; i < success.size() ; i++) {\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList resp = (NamedList)success.getVal(i);\n        // Unfortunately async processing logic doesn't provide the \"core\" name automatically.\n        String coreName = (String)resp.get(\"core\");\n        coresWithSnapshot.remove(coreName);\n      }\n    }\n\n    if (!coresWithSnapshot.isEmpty()) { // One or more failures.\n      log.warn(\"Failed to delete a snapshot for collection {} with commitName = {}. Snapshot could not be deleted for following cores {}\",\n          collectionName, commitName, coresWithSnapshot);\n\n      List<CoreSnapshotMetaData> replicasWithSnapshot = new ArrayList<>();\n      for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n        if (coresWithSnapshot.contains(m.getCoreName())) {\n          replicasWithSnapshot.add(m);\n        }\n      }\n\n      // Update the ZK meta-data to include only cores with the snapshot. This will enable users to figure out\n      // which cores still contain the named snapshot.\n      CollectionSnapshotMetaData newResult = new CollectionSnapshotMetaData(meta.get().getName(), SnapshotStatus.Failed,\n          meta.get().getCreationDate(), replicasWithSnapshot);\n      SolrSnapshotManager.updateCollectionLevelSnapshot(zkClient, collectionName, newResult);\n      if (log.isInfoEnabled()) {\n        log.info(\"Saved snapshot information for collection={} with commitName={} in Zookeeper as follows: {}\", collectionName, commitName,\n            Utils.toJSON(newResult));\n      }\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed to delete snapshot on cores \" + coresWithSnapshot);\n\n    } else {\n      // Delete the ZK path so that we eliminate the references of this snapshot from collection level meta-data.\n      SolrSnapshotManager.deleteCollectionLevelSnapshot(zkClient, collectionName, commitName);\n      log.info(\"Deleted Zookeeper snapshot metdata for collection={} with commitName={}\", collectionName, commitName);\n      log.info(\"Successfully deleted snapshot for collection={} with commitName={}\", collectionName, commitName);\n    }\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\"})\n  public void call(ClusterState state, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    String extCollectionName =  message.getStr(COLLECTION_PROP);\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String collectionName;\n    if (followAliases) {\n      collectionName = ocmh.zkStateReader.getAliases().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n    String commitName =  message.getStr(CoreAdminParams.COMMIT_NAME);\n    String asyncId = message.getStr(ASYNC);\n    @SuppressWarnings({\"rawtypes\"})\n    NamedList shardRequestResults = new NamedList();\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler(ocmh.overseer.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient());\n    SolrZkClient zkClient = ocmh.zkStateReader.getZkClient();\n\n    Optional<CollectionSnapshotMetaData> meta = SolrSnapshotManager.getCollectionLevelSnapshot(zkClient, collectionName, commitName);\n    if (!meta.isPresent()) { // Snapshot not found. Nothing to do.\n      return;\n    }\n\n    log.info(\"Deleting a snapshot for collection={} with commitName={}\", collectionName, commitName);\n\n    Set<String> existingCores = new HashSet<>();\n    for (Slice s : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica r : s.getReplicas()) {\n        existingCores.add(r.getCoreName());\n      }\n    }\n\n    Set<String> coresWithSnapshot = new HashSet<>();\n    for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n      if (existingCores.contains(m.getCoreName())) {\n        coresWithSnapshot.add(m.getCoreName());\n      }\n    }\n\n    final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n    log.info(\"Existing cores with snapshot for collection={} are {}\", collectionName, existingCores);\n    for (Slice slice : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        if (replica.getState() == State.DOWN) {\n          continue; // Since replica is down - no point sending a request.\n        }\n\n        // Note - when a snapshot is found in_progress state - it is the result of overseer\n        // failure while handling the snapshot creation. Since we don't know the exact set of\n        // replicas to contact at this point, we try on all replicas.\n        if (meta.get().getStatus() == SnapshotStatus.InProgress || coresWithSnapshot.contains(replica.getCoreName())) {\n          String coreName = replica.getStr(CORE_NAME_PROP);\n\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CoreAdminParams.ACTION, CoreAdminAction.DELETESNAPSHOT.toString());\n          params.set(NAME, slice.getName());\n          params.set(CORE_NAME_PROP, coreName);\n          params.set(CoreAdminParams.COMMIT_NAME, commitName);\n\n          log.info(\"Sending deletesnapshot request to core={} with commitName={}\", coreName, commitName);\n          shardRequestTracker.sendShardRequest(replica.getNodeName(), params, shardHandler);\n        }\n      }\n    }\n\n    shardRequestTracker.processResponses(shardRequestResults, shardHandler, false, null);\n    @SuppressWarnings({\"rawtypes\"})\n    NamedList success = (NamedList) shardRequestResults.get(\"success\");\n    List<CoreSnapshotMetaData> replicas = new ArrayList<>();\n    if (success != null) {\n      for ( int i = 0 ; i < success.size() ; i++) {\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList resp = (NamedList)success.getVal(i);\n        // Unfortunately async processing logic doesn't provide the \"core\" name automatically.\n        String coreName = (String)resp.get(\"core\");\n        coresWithSnapshot.remove(coreName);\n      }\n    }\n\n    if (!coresWithSnapshot.isEmpty()) { // One or more failures.\n      log.warn(\"Failed to delete a snapshot for collection {} with commitName = {}. Snapshot could not be deleted for following cores {}\",\n          collectionName, commitName, coresWithSnapshot);\n\n      List<CoreSnapshotMetaData> replicasWithSnapshot = new ArrayList<>();\n      for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n        if (coresWithSnapshot.contains(m.getCoreName())) {\n          replicasWithSnapshot.add(m);\n        }\n      }\n\n      // Update the ZK meta-data to include only cores with the snapshot. This will enable users to figure out\n      // which cores still contain the named snapshot.\n      CollectionSnapshotMetaData newResult = new CollectionSnapshotMetaData(meta.get().getName(), SnapshotStatus.Failed,\n          meta.get().getCreationDate(), replicasWithSnapshot);\n      SolrSnapshotManager.updateCollectionLevelSnapshot(zkClient, collectionName, newResult);\n      if (log.isInfoEnabled()) {\n        log.info(\"Saved snapshot information for collection={} with commitName={} in Zookeeper as follows: {}\", collectionName, commitName,\n            Utils.toJSON(newResult));\n      }\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed to delete snapshot on cores \" + coresWithSnapshot);\n\n    } else {\n      // Delete the ZK path so that we eliminate the references of this snapshot from collection level meta-data.\n      SolrSnapshotManager.deleteCollectionLevelSnapshot(zkClient, collectionName, commitName);\n      log.info(\"Deleted Zookeeper snapshot metdata for collection={} with commitName={}\", collectionName, commitName);\n      log.info(\"Successfully deleted snapshot for collection={} with commitName={}\", collectionName, commitName);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c526352db87264a72a7a9ad68c1b769b81e54305","date":1598780188,"type":5,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteSnapshotCmd#call(ClusterState,CloudConfig,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteSnapshotCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\"})\n  public void call(ClusterState state, CloudConfig cloudConfig, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    String extCollectionName =  message.getStr(COLLECTION_PROP);\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String collectionName;\n    if (followAliases) {\n      collectionName = ocmh.zkStateReader.getAliases().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n    String commitName =  message.getStr(CoreAdminParams.COMMIT_NAME);\n    String asyncId = message.getStr(ASYNC);\n    @SuppressWarnings({\"rawtypes\"})\n    NamedList shardRequestResults = new NamedList();\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n    SolrZkClient zkClient = ocmh.zkStateReader.getZkClient();\n\n    Optional<CollectionSnapshotMetaData> meta = SolrSnapshotManager.getCollectionLevelSnapshot(zkClient, collectionName, commitName);\n    if (!meta.isPresent()) { // Snapshot not found. Nothing to do.\n      return;\n    }\n\n    log.info(\"Deleting a snapshot for collection={} with commitName={}\", collectionName, commitName);\n\n    Set<String> existingCores = new HashSet<>();\n    for (Slice s : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica r : s.getReplicas()) {\n        existingCores.add(r.getCoreName());\n      }\n    }\n\n    Set<String> coresWithSnapshot = new HashSet<>();\n    for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n      if (existingCores.contains(m.getCoreName())) {\n        coresWithSnapshot.add(m.getCoreName());\n      }\n    }\n\n    final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n    log.info(\"Existing cores with snapshot for collection={} are {}\", collectionName, existingCores);\n    for (Slice slice : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        if (replica.getState() == State.DOWN) {\n          continue; // Since replica is down - no point sending a request.\n        }\n\n        // Note - when a snapshot is found in_progress state - it is the result of overseer\n        // failure while handling the snapshot creation. Since we don't know the exact set of\n        // replicas to contact at this point, we try on all replicas.\n        if (meta.get().getStatus() == SnapshotStatus.InProgress || coresWithSnapshot.contains(replica.getCoreName())) {\n          String coreName = replica.getStr(CORE_NAME_PROP);\n\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CoreAdminParams.ACTION, CoreAdminAction.DELETESNAPSHOT.toString());\n          params.set(NAME, slice.getName());\n          params.set(CORE_NAME_PROP, coreName);\n          params.set(CoreAdminParams.COMMIT_NAME, commitName);\n\n          log.info(\"Sending deletesnapshot request to core={} with commitName={}\", coreName, commitName);\n          shardRequestTracker.sendShardRequest(replica.getNodeName(), params, shardHandler);\n        }\n      }\n    }\n\n    shardRequestTracker.processResponses(shardRequestResults, shardHandler, false, null);\n    @SuppressWarnings({\"rawtypes\"})\n    NamedList success = (NamedList) shardRequestResults.get(\"success\");\n    List<CoreSnapshotMetaData> replicas = new ArrayList<>();\n    if (success != null) {\n      for ( int i = 0 ; i < success.size() ; i++) {\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList resp = (NamedList)success.getVal(i);\n        // Unfortunately async processing logic doesn't provide the \"core\" name automatically.\n        String coreName = (String)resp.get(\"core\");\n        coresWithSnapshot.remove(coreName);\n      }\n    }\n\n    if (!coresWithSnapshot.isEmpty()) { // One or more failures.\n      log.warn(\"Failed to delete a snapshot for collection {} with commitName = {}. Snapshot could not be deleted for following cores {}\",\n          collectionName, commitName, coresWithSnapshot);\n\n      List<CoreSnapshotMetaData> replicasWithSnapshot = new ArrayList<>();\n      for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n        if (coresWithSnapshot.contains(m.getCoreName())) {\n          replicasWithSnapshot.add(m);\n        }\n      }\n\n      // Update the ZK meta-data to include only cores with the snapshot. This will enable users to figure out\n      // which cores still contain the named snapshot.\n      CollectionSnapshotMetaData newResult = new CollectionSnapshotMetaData(meta.get().getName(), SnapshotStatus.Failed,\n          meta.get().getCreationDate(), replicasWithSnapshot);\n      SolrSnapshotManager.updateCollectionLevelSnapshot(zkClient, collectionName, newResult);\n      if (log.isInfoEnabled()) {\n        log.info(\"Saved snapshot information for collection={} with commitName={} in Zookeeper as follows: {}\", collectionName, commitName,\n            Utils.toJSON(newResult));\n      }\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed to delete snapshot on cores \" + coresWithSnapshot);\n\n    } else {\n      // Delete the ZK path so that we eliminate the references of this snapshot from collection level meta-data.\n      SolrSnapshotManager.deleteCollectionLevelSnapshot(zkClient, collectionName, commitName);\n      log.info(\"Deleted Zookeeper snapshot metdata for collection={} with commitName={}\", collectionName, commitName);\n      log.info(\"Successfully deleted snapshot for collection={} with commitName={}\", collectionName, commitName);\n    }\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\"})\n  public void call(ClusterState state, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    String extCollectionName =  message.getStr(COLLECTION_PROP);\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String collectionName;\n    if (followAliases) {\n      collectionName = ocmh.zkStateReader.getAliases().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n    String commitName =  message.getStr(CoreAdminParams.COMMIT_NAME);\n    String asyncId = message.getStr(ASYNC);\n    @SuppressWarnings({\"rawtypes\"})\n    NamedList shardRequestResults = new NamedList();\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n    SolrZkClient zkClient = ocmh.zkStateReader.getZkClient();\n\n    Optional<CollectionSnapshotMetaData> meta = SolrSnapshotManager.getCollectionLevelSnapshot(zkClient, collectionName, commitName);\n    if (!meta.isPresent()) { // Snapshot not found. Nothing to do.\n      return;\n    }\n\n    log.info(\"Deleting a snapshot for collection={} with commitName={}\", collectionName, commitName);\n\n    Set<String> existingCores = new HashSet<>();\n    for (Slice s : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica r : s.getReplicas()) {\n        existingCores.add(r.getCoreName());\n      }\n    }\n\n    Set<String> coresWithSnapshot = new HashSet<>();\n    for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n      if (existingCores.contains(m.getCoreName())) {\n        coresWithSnapshot.add(m.getCoreName());\n      }\n    }\n\n    final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n    log.info(\"Existing cores with snapshot for collection={} are {}\", collectionName, existingCores);\n    for (Slice slice : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        if (replica.getState() == State.DOWN) {\n          continue; // Since replica is down - no point sending a request.\n        }\n\n        // Note - when a snapshot is found in_progress state - it is the result of overseer\n        // failure while handling the snapshot creation. Since we don't know the exact set of\n        // replicas to contact at this point, we try on all replicas.\n        if (meta.get().getStatus() == SnapshotStatus.InProgress || coresWithSnapshot.contains(replica.getCoreName())) {\n          String coreName = replica.getStr(CORE_NAME_PROP);\n\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CoreAdminParams.ACTION, CoreAdminAction.DELETESNAPSHOT.toString());\n          params.set(NAME, slice.getName());\n          params.set(CORE_NAME_PROP, coreName);\n          params.set(CoreAdminParams.COMMIT_NAME, commitName);\n\n          log.info(\"Sending deletesnapshot request to core={} with commitName={}\", coreName, commitName);\n          shardRequestTracker.sendShardRequest(replica.getNodeName(), params, shardHandler);\n        }\n      }\n    }\n\n    shardRequestTracker.processResponses(shardRequestResults, shardHandler, false, null);\n    @SuppressWarnings({\"rawtypes\"})\n    NamedList success = (NamedList) shardRequestResults.get(\"success\");\n    List<CoreSnapshotMetaData> replicas = new ArrayList<>();\n    if (success != null) {\n      for ( int i = 0 ; i < success.size() ; i++) {\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList resp = (NamedList)success.getVal(i);\n        // Unfortunately async processing logic doesn't provide the \"core\" name automatically.\n        String coreName = (String)resp.get(\"core\");\n        coresWithSnapshot.remove(coreName);\n      }\n    }\n\n    if (!coresWithSnapshot.isEmpty()) { // One or more failures.\n      log.warn(\"Failed to delete a snapshot for collection {} with commitName = {}. Snapshot could not be deleted for following cores {}\",\n          collectionName, commitName, coresWithSnapshot);\n\n      List<CoreSnapshotMetaData> replicasWithSnapshot = new ArrayList<>();\n      for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n        if (coresWithSnapshot.contains(m.getCoreName())) {\n          replicasWithSnapshot.add(m);\n        }\n      }\n\n      // Update the ZK meta-data to include only cores with the snapshot. This will enable users to figure out\n      // which cores still contain the named snapshot.\n      CollectionSnapshotMetaData newResult = new CollectionSnapshotMetaData(meta.get().getName(), SnapshotStatus.Failed,\n          meta.get().getCreationDate(), replicasWithSnapshot);\n      SolrSnapshotManager.updateCollectionLevelSnapshot(zkClient, collectionName, newResult);\n      if (log.isInfoEnabled()) {\n        log.info(\"Saved snapshot information for collection={} with commitName={} in Zookeeper as follows: {}\", collectionName, commitName,\n            Utils.toJSON(newResult));\n      }\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed to delete snapshot on cores \" + coresWithSnapshot);\n\n    } else {\n      // Delete the ZK path so that we eliminate the references of this snapshot from collection level meta-data.\n      SolrSnapshotManager.deleteCollectionLevelSnapshot(zkClient, collectionName, commitName);\n      log.info(\"Deleted Zookeeper snapshot metdata for collection={} with commitName={}\", collectionName, commitName);\n      log.info(\"Successfully deleted snapshot for collection={} with commitName={}\", collectionName, commitName);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e7b17e79a71117668ecbf8d3417c876e41396565","date":1598973672,"type":1,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteSnapshotCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteSnapshotCmd#call(ClusterState,CloudConfig,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\"})\n  public void call(ClusterState state, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    String extCollectionName =  message.getStr(COLLECTION_PROP);\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String collectionName;\n    if (followAliases) {\n      collectionName = ocmh.zkStateReader.getAliases().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n    String commitName =  message.getStr(CoreAdminParams.COMMIT_NAME);\n    String asyncId = message.getStr(ASYNC);\n    @SuppressWarnings({\"rawtypes\"})\n    NamedList shardRequestResults = new NamedList();\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n    SolrZkClient zkClient = ocmh.zkStateReader.getZkClient();\n\n    Optional<CollectionSnapshotMetaData> meta = SolrSnapshotManager.getCollectionLevelSnapshot(zkClient, collectionName, commitName);\n    if (!meta.isPresent()) { // Snapshot not found. Nothing to do.\n      return;\n    }\n\n    log.info(\"Deleting a snapshot for collection={} with commitName={}\", collectionName, commitName);\n\n    Set<String> existingCores = new HashSet<>();\n    for (Slice s : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica r : s.getReplicas()) {\n        existingCores.add(r.getCoreName());\n      }\n    }\n\n    Set<String> coresWithSnapshot = new HashSet<>();\n    for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n      if (existingCores.contains(m.getCoreName())) {\n        coresWithSnapshot.add(m.getCoreName());\n      }\n    }\n\n    final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n    log.info(\"Existing cores with snapshot for collection={} are {}\", collectionName, existingCores);\n    for (Slice slice : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        if (replica.getState() == State.DOWN) {\n          continue; // Since replica is down - no point sending a request.\n        }\n\n        // Note - when a snapshot is found in_progress state - it is the result of overseer\n        // failure while handling the snapshot creation. Since we don't know the exact set of\n        // replicas to contact at this point, we try on all replicas.\n        if (meta.get().getStatus() == SnapshotStatus.InProgress || coresWithSnapshot.contains(replica.getCoreName())) {\n          String coreName = replica.getStr(CORE_NAME_PROP);\n\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CoreAdminParams.ACTION, CoreAdminAction.DELETESNAPSHOT.toString());\n          params.set(NAME, slice.getName());\n          params.set(CORE_NAME_PROP, coreName);\n          params.set(CoreAdminParams.COMMIT_NAME, commitName);\n\n          log.info(\"Sending deletesnapshot request to core={} with commitName={}\", coreName, commitName);\n          shardRequestTracker.sendShardRequest(replica.getNodeName(), params, shardHandler);\n        }\n      }\n    }\n\n    shardRequestTracker.processResponses(shardRequestResults, shardHandler, false, null);\n    @SuppressWarnings({\"rawtypes\"})\n    NamedList success = (NamedList) shardRequestResults.get(\"success\");\n    List<CoreSnapshotMetaData> replicas = new ArrayList<>();\n    if (success != null) {\n      for ( int i = 0 ; i < success.size() ; i++) {\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList resp = (NamedList)success.getVal(i);\n        // Unfortunately async processing logic doesn't provide the \"core\" name automatically.\n        String coreName = (String)resp.get(\"core\");\n        coresWithSnapshot.remove(coreName);\n      }\n    }\n\n    if (!coresWithSnapshot.isEmpty()) { // One or more failures.\n      log.warn(\"Failed to delete a snapshot for collection {} with commitName = {}. Snapshot could not be deleted for following cores {}\",\n          collectionName, commitName, coresWithSnapshot);\n\n      List<CoreSnapshotMetaData> replicasWithSnapshot = new ArrayList<>();\n      for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n        if (coresWithSnapshot.contains(m.getCoreName())) {\n          replicasWithSnapshot.add(m);\n        }\n      }\n\n      // Update the ZK meta-data to include only cores with the snapshot. This will enable users to figure out\n      // which cores still contain the named snapshot.\n      CollectionSnapshotMetaData newResult = new CollectionSnapshotMetaData(meta.get().getName(), SnapshotStatus.Failed,\n          meta.get().getCreationDate(), replicasWithSnapshot);\n      SolrSnapshotManager.updateCollectionLevelSnapshot(zkClient, collectionName, newResult);\n      if (log.isInfoEnabled()) {\n        log.info(\"Saved snapshot information for collection={} with commitName={} in Zookeeper as follows: {}\", collectionName, commitName,\n            Utils.toJSON(newResult));\n      }\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed to delete snapshot on cores \" + coresWithSnapshot);\n\n    } else {\n      // Delete the ZK path so that we eliminate the references of this snapshot from collection level meta-data.\n      SolrSnapshotManager.deleteCollectionLevelSnapshot(zkClient, collectionName, commitName);\n      log.info(\"Deleted Zookeeper snapshot metdata for collection={} with commitName={}\", collectionName, commitName);\n      log.info(\"Successfully deleted snapshot for collection={} with commitName={}\", collectionName, commitName);\n    }\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\"})\n  public void call(ClusterState state, CloudConfig cloudConfig, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    String extCollectionName =  message.getStr(COLLECTION_PROP);\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    String collectionName;\n    if (followAliases) {\n      collectionName = ocmh.zkStateReader.getAliases().resolveSimpleAlias(extCollectionName);\n    } else {\n      collectionName = extCollectionName;\n    }\n    String commitName =  message.getStr(CoreAdminParams.COMMIT_NAME);\n    String asyncId = message.getStr(ASYNC);\n    @SuppressWarnings({\"rawtypes\"})\n    NamedList shardRequestResults = new NamedList();\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n    SolrZkClient zkClient = ocmh.zkStateReader.getZkClient();\n\n    Optional<CollectionSnapshotMetaData> meta = SolrSnapshotManager.getCollectionLevelSnapshot(zkClient, collectionName, commitName);\n    if (!meta.isPresent()) { // Snapshot not found. Nothing to do.\n      return;\n    }\n\n    log.info(\"Deleting a snapshot for collection={} with commitName={}\", collectionName, commitName);\n\n    Set<String> existingCores = new HashSet<>();\n    for (Slice s : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica r : s.getReplicas()) {\n        existingCores.add(r.getCoreName());\n      }\n    }\n\n    Set<String> coresWithSnapshot = new HashSet<>();\n    for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n      if (existingCores.contains(m.getCoreName())) {\n        coresWithSnapshot.add(m.getCoreName());\n      }\n    }\n\n    final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n    log.info(\"Existing cores with snapshot for collection={} are {}\", collectionName, existingCores);\n    for (Slice slice : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        if (replica.getState() == State.DOWN) {\n          continue; // Since replica is down - no point sending a request.\n        }\n\n        // Note - when a snapshot is found in_progress state - it is the result of overseer\n        // failure while handling the snapshot creation. Since we don't know the exact set of\n        // replicas to contact at this point, we try on all replicas.\n        if (meta.get().getStatus() == SnapshotStatus.InProgress || coresWithSnapshot.contains(replica.getCoreName())) {\n          String coreName = replica.getStr(CORE_NAME_PROP);\n\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CoreAdminParams.ACTION, CoreAdminAction.DELETESNAPSHOT.toString());\n          params.set(NAME, slice.getName());\n          params.set(CORE_NAME_PROP, coreName);\n          params.set(CoreAdminParams.COMMIT_NAME, commitName);\n\n          log.info(\"Sending deletesnapshot request to core={} with commitName={}\", coreName, commitName);\n          shardRequestTracker.sendShardRequest(replica.getNodeName(), params, shardHandler);\n        }\n      }\n    }\n\n    shardRequestTracker.processResponses(shardRequestResults, shardHandler, false, null);\n    @SuppressWarnings({\"rawtypes\"})\n    NamedList success = (NamedList) shardRequestResults.get(\"success\");\n    List<CoreSnapshotMetaData> replicas = new ArrayList<>();\n    if (success != null) {\n      for ( int i = 0 ; i < success.size() ; i++) {\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList resp = (NamedList)success.getVal(i);\n        // Unfortunately async processing logic doesn't provide the \"core\" name automatically.\n        String coreName = (String)resp.get(\"core\");\n        coresWithSnapshot.remove(coreName);\n      }\n    }\n\n    if (!coresWithSnapshot.isEmpty()) { // One or more failures.\n      log.warn(\"Failed to delete a snapshot for collection {} with commitName = {}. Snapshot could not be deleted for following cores {}\",\n          collectionName, commitName, coresWithSnapshot);\n\n      List<CoreSnapshotMetaData> replicasWithSnapshot = new ArrayList<>();\n      for (CoreSnapshotMetaData m : meta.get().getReplicaSnapshots()) {\n        if (coresWithSnapshot.contains(m.getCoreName())) {\n          replicasWithSnapshot.add(m);\n        }\n      }\n\n      // Update the ZK meta-data to include only cores with the snapshot. This will enable users to figure out\n      // which cores still contain the named snapshot.\n      CollectionSnapshotMetaData newResult = new CollectionSnapshotMetaData(meta.get().getName(), SnapshotStatus.Failed,\n          meta.get().getCreationDate(), replicasWithSnapshot);\n      SolrSnapshotManager.updateCollectionLevelSnapshot(zkClient, collectionName, newResult);\n      if (log.isInfoEnabled()) {\n        log.info(\"Saved snapshot information for collection={} with commitName={} in Zookeeper as follows: {}\", collectionName, commitName,\n            Utils.toJSON(newResult));\n      }\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed to delete snapshot on cores \" + coresWithSnapshot);\n\n    } else {\n      // Delete the ZK path so that we eliminate the references of this snapshot from collection level meta-data.\n      SolrSnapshotManager.deleteCollectionLevelSnapshot(zkClient, collectionName, commitName);\n      log.info(\"Deleted Zookeeper snapshot metdata for collection={} with commitName={}\", collectionName, commitName);\n      log.info(\"Successfully deleted snapshot for collection={} with commitName={}\", collectionName, commitName);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e7b17e79a71117668ecbf8d3417c876e41396565":["c526352db87264a72a7a9ad68c1b769b81e54305"],"b94236357aaa22b76c10629851fe4e376e0cea82":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"1964c059f45ae1de1877f9f0fe3ca327ea4218e8":["86968c6cf51846df861b8f29bd85b6d9a7c9f19c"],"c526352db87264a72a7a9ad68c1b769b81e54305":["1964c059f45ae1de1877f9f0fe3ca327ea4218e8"],"59bad1cc1e7f90125a140496e79b06afcedb68ec":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["b94236357aaa22b76c10629851fe4e376e0cea82"],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d20dc32a40c1bd7b8b8e2354e6b0b9f956ef758c":["69e6520a21709190413a63084ed135271aab1a7c"],"4abf821a41a2fdca2a1dea148999931d22e20529":["6afb0ba86024b96e8b34cfc2e15562239dc36360"],"86968c6cf51846df861b8f29bd85b6d9a7c9f19c":["4abf821a41a2fdca2a1dea148999931d22e20529"],"6afb0ba86024b96e8b34cfc2e15562239dc36360":["d20dc32a40c1bd7b8b8e2354e6b0b9f956ef758c"],"69e6520a21709190413a63084ed135271aab1a7c":["59bad1cc1e7f90125a140496e79b06afcedb68ec"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e7b17e79a71117668ecbf8d3417c876e41396565"]},"commit2Childs":{"e7b17e79a71117668ecbf8d3417c876e41396565":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b94236357aaa22b76c10629851fe4e376e0cea82":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"1964c059f45ae1de1877f9f0fe3ca327ea4218e8":["c526352db87264a72a7a9ad68c1b769b81e54305"],"c526352db87264a72a7a9ad68c1b769b81e54305":["e7b17e79a71117668ecbf8d3417c876e41396565"],"59bad1cc1e7f90125a140496e79b06afcedb68ec":["69e6520a21709190413a63084ed135271aab1a7c"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["59bad1cc1e7f90125a140496e79b06afcedb68ec"],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["b94236357aaa22b76c10629851fe4e376e0cea82"],"d20dc32a40c1bd7b8b8e2354e6b0b9f956ef758c":["6afb0ba86024b96e8b34cfc2e15562239dc36360"],"4abf821a41a2fdca2a1dea148999931d22e20529":["86968c6cf51846df861b8f29bd85b6d9a7c9f19c"],"86968c6cf51846df861b8f29bd85b6d9a7c9f19c":["1964c059f45ae1de1877f9f0fe3ca327ea4218e8"],"69e6520a21709190413a63084ed135271aab1a7c":["d20dc32a40c1bd7b8b8e2354e6b0b9f956ef758c"],"6afb0ba86024b96e8b34cfc2e15562239dc36360":["4abf821a41a2fdca2a1dea148999931d22e20529"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b94236357aaa22b76c10629851fe4e376e0cea82","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}