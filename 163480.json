{"path":"solr/core/src/test/org/apache/solr/cloud/ConcurrentDeleteAndCreateCollectionTest#testConcurrentCreateAndDeleteDoesNotFail().mjava","commits":[{"id":"9ba07da07950fc728766b05e28f9b21754a4acce","date":1429110306,"type":0,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ConcurrentDeleteAndCreateCollectionTest#testConcurrentCreateAndDeleteDoesNotFail().mjava","pathOld":"/dev/null","sourceNew":"  public void testConcurrentCreateAndDeleteDoesNotFail() {\n    final File configDir = getFile(\"solrj\").toPath().resolve(\"solr/configsets/configset-2/conf\").toFile();\n    final AtomicReference<Exception> failure = new AtomicReference<>();\n    final int timeToRunSec = 30;\n    final Thread[] threads = new Thread[10];\n    for (int i = 0; i < threads.length; i++) {\n      final String collectionName = \"collection\" + i;\n      uploadConfig(configDir, collectionName);\n      final SolrClient solrClient = new HttpSolrClient(solrCluster.getJettySolrRunners().get(0).getBaseUrl().toString());\n      threads[i] = new CreateDeleteCollectionThread(\"create-delete-\" + i, collectionName, timeToRunSec, solrClient, failure);\n    }\n    \n    startAll(threads);\n    joinAll(threads);\n    \n    assertNull(\"concurrent create and delete collection failed: \" + failure.get(), failure.get());\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["b9820a382c8b45d8d0154b322a2441bec5446204"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b9820a382c8b45d8d0154b322a2441bec5446204","date":1429119228,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ConcurrentDeleteAndCreateCollectionTest#testConcurrentCreateAndDeleteDoesNotFail().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ConcurrentDeleteAndCreateCollectionTest#testConcurrentCreateAndDeleteDoesNotFail().mjava","sourceNew":"  public void testConcurrentCreateAndDeleteDoesNotFail() {\n    final File configDir = getFile(\"solr\").toPath().resolve(\"configsets/configset-2/conf\").toFile();\n    final AtomicReference<Exception> failure = new AtomicReference<>();\n    final int timeToRunSec = 30;\n    final Thread[] threads = new Thread[10];\n    for (int i = 0; i < threads.length; i++) {\n      final String collectionName = \"collection\" + i;\n      uploadConfig(configDir, collectionName);\n      final SolrClient solrClient = new HttpSolrClient(solrCluster.getJettySolrRunners().get(0).getBaseUrl().toString());\n      threads[i] = new CreateDeleteCollectionThread(\"create-delete-\" + i, collectionName, timeToRunSec, solrClient, failure);\n    }\n    \n    startAll(threads);\n    joinAll(threads);\n    \n    assertNull(\"concurrent create and delete collection failed: \" + failure.get(), failure.get());\n  }\n\n","sourceOld":"  public void testConcurrentCreateAndDeleteDoesNotFail() {\n    final File configDir = getFile(\"solrj\").toPath().resolve(\"solr/configsets/configset-2/conf\").toFile();\n    final AtomicReference<Exception> failure = new AtomicReference<>();\n    final int timeToRunSec = 30;\n    final Thread[] threads = new Thread[10];\n    for (int i = 0; i < threads.length; i++) {\n      final String collectionName = \"collection\" + i;\n      uploadConfig(configDir, collectionName);\n      final SolrClient solrClient = new HttpSolrClient(solrCluster.getJettySolrRunners().get(0).getBaseUrl().toString());\n      threads[i] = new CreateDeleteCollectionThread(\"create-delete-\" + i, collectionName, timeToRunSec, solrClient, failure);\n    }\n    \n    startAll(threads);\n    joinAll(threads);\n    \n    assertNull(\"concurrent create and delete collection failed: \" + failure.get(), failure.get());\n  }\n\n","bugFix":["9ba07da07950fc728766b05e28f9b21754a4acce"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54bb8da55080e4569804e0661b83a3c72cbd8d4d","date":1429691126,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ConcurrentDeleteAndCreateCollectionTest#testConcurrentCreateAndDeleteDoesNotFail().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ConcurrentDeleteAndCreateCollectionTest#testConcurrentCreateAndDeleteDoesNotFail().mjava","sourceNew":"  public void testConcurrentCreateAndDeleteDoesNotFail() {\n    final File configDir = getFile(\"solr\").toPath().resolve(\"configsets/configset-2/conf\").toFile();\n    final AtomicReference<Exception> failure = new AtomicReference<>();\n    final int timeToRunSec = 30;\n    final Thread[] threads = new Thread[10];\n    for (int i = 0; i < threads.length; i++) {\n      final String collectionName = \"collection\" + i;\n      uploadConfig(configDir, collectionName);\n      final SolrClient solrClient = new HttpSolrClient(solrCluster.getJettySolrRunners().get(0).getBaseUrl().toString());\n      threads[i] = new CreateDeleteSearchCollectionThread(\"create-delete-search-\" + i, collectionName, collectionName, \n          timeToRunSec, solrClient, failure);\n    }\n    \n    startAll(threads);\n    joinAll(threads);\n    \n    assertNull(\"concurrent create and delete collection failed: \" + failure.get(), failure.get());\n  }\n\n","sourceOld":"  public void testConcurrentCreateAndDeleteDoesNotFail() {\n    final File configDir = getFile(\"solr\").toPath().resolve(\"configsets/configset-2/conf\").toFile();\n    final AtomicReference<Exception> failure = new AtomicReference<>();\n    final int timeToRunSec = 30;\n    final Thread[] threads = new Thread[10];\n    for (int i = 0; i < threads.length; i++) {\n      final String collectionName = \"collection\" + i;\n      uploadConfig(configDir, collectionName);\n      final SolrClient solrClient = new HttpSolrClient(solrCluster.getJettySolrRunners().get(0).getBaseUrl().toString());\n      threads[i] = new CreateDeleteCollectionThread(\"create-delete-\" + i, collectionName, timeToRunSec, solrClient, failure);\n    }\n    \n    startAll(threads);\n    joinAll(threads);\n    \n    assertNull(\"concurrent create and delete collection failed: \" + failure.get(), failure.get());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088","date":1460069869,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ConcurrentDeleteAndCreateCollectionTest#testConcurrentCreateAndDeleteDoesNotFail().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ConcurrentDeleteAndCreateCollectionTest#testConcurrentCreateAndDeleteDoesNotFail().mjava","sourceNew":"  public void testConcurrentCreateAndDeleteDoesNotFail() {\n    final File configDir = getFile(\"solr\").toPath().resolve(\"configsets/configset-2/conf\").toFile();\n    final AtomicReference<Exception> failure = new AtomicReference<>();\n    final int timeToRunSec = 30;\n    final Thread[] threads = new Thread[10];\n    for (int i = 0; i < threads.length; i++) {\n      final String collectionName = \"collection\" + i;\n      uploadConfig(configDir, collectionName);\n      final String baseUrl = solrCluster.getJettySolrRunners().get(0).getBaseUrl().toString();\n      final SolrClient solrClient = getHttpSolrClient(baseUrl);\n      threads[i] = new CreateDeleteSearchCollectionThread(\"create-delete-search-\" + i, collectionName, collectionName, \n          timeToRunSec, solrClient, failure);\n    }\n    \n    startAll(threads);\n    joinAll(threads);\n    \n    assertNull(\"concurrent create and delete collection failed: \" + failure.get(), failure.get());\n  }\n\n","sourceOld":"  public void testConcurrentCreateAndDeleteDoesNotFail() {\n    final File configDir = getFile(\"solr\").toPath().resolve(\"configsets/configset-2/conf\").toFile();\n    final AtomicReference<Exception> failure = new AtomicReference<>();\n    final int timeToRunSec = 30;\n    final Thread[] threads = new Thread[10];\n    for (int i = 0; i < threads.length; i++) {\n      final String collectionName = \"collection\" + i;\n      uploadConfig(configDir, collectionName);\n      final SolrClient solrClient = new HttpSolrClient(solrCluster.getJettySolrRunners().get(0).getBaseUrl().toString());\n      threads[i] = new CreateDeleteSearchCollectionThread(\"create-delete-search-\" + i, collectionName, collectionName, \n          timeToRunSec, solrClient, failure);\n    }\n    \n    startAll(threads);\n    joinAll(threads);\n    \n    assertNull(\"concurrent create and delete collection failed: \" + failure.get(), failure.get());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","date":1460110033,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ConcurrentDeleteAndCreateCollectionTest#testConcurrentCreateAndDeleteDoesNotFail().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ConcurrentDeleteAndCreateCollectionTest#testConcurrentCreateAndDeleteDoesNotFail().mjava","sourceNew":"  public void testConcurrentCreateAndDeleteDoesNotFail() {\n    final File configDir = getFile(\"solr\").toPath().resolve(\"configsets/configset-2/conf\").toFile();\n    final AtomicReference<Exception> failure = new AtomicReference<>();\n    final int timeToRunSec = 30;\n    final Thread[] threads = new Thread[10];\n    for (int i = 0; i < threads.length; i++) {\n      final String collectionName = \"collection\" + i;\n      uploadConfig(configDir, collectionName);\n      final String baseUrl = solrCluster.getJettySolrRunners().get(0).getBaseUrl().toString();\n      final SolrClient solrClient = getHttpSolrClient(baseUrl);\n      threads[i] = new CreateDeleteSearchCollectionThread(\"create-delete-search-\" + i, collectionName, collectionName, \n          timeToRunSec, solrClient, failure);\n    }\n    \n    startAll(threads);\n    joinAll(threads);\n    \n    assertNull(\"concurrent create and delete collection failed: \" + failure.get(), failure.get());\n  }\n\n","sourceOld":"  public void testConcurrentCreateAndDeleteDoesNotFail() {\n    final File configDir = getFile(\"solr\").toPath().resolve(\"configsets/configset-2/conf\").toFile();\n    final AtomicReference<Exception> failure = new AtomicReference<>();\n    final int timeToRunSec = 30;\n    final Thread[] threads = new Thread[10];\n    for (int i = 0; i < threads.length; i++) {\n      final String collectionName = \"collection\" + i;\n      uploadConfig(configDir, collectionName);\n      final SolrClient solrClient = new HttpSolrClient(solrCluster.getJettySolrRunners().get(0).getBaseUrl().toString());\n      threads[i] = new CreateDeleteSearchCollectionThread(\"create-delete-search-\" + i, collectionName, collectionName, \n          timeToRunSec, solrClient, failure);\n    }\n    \n    startAll(threads);\n    joinAll(threads);\n    \n    assertNull(\"concurrent create and delete collection failed: \" + failure.get(), failure.get());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e89a32cc825033ebae8bb9e1c6877c2d9d76749e","date":1476790453,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ConcurrentDeleteAndCreateCollectionTest#testConcurrentCreateAndDeleteDoesNotFail().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ConcurrentDeleteAndCreateCollectionTest#testConcurrentCreateAndDeleteDoesNotFail().mjava","sourceNew":"  public void testConcurrentCreateAndDeleteDoesNotFail() {\n    final AtomicReference<Exception> failure = new AtomicReference<>();\n    final int timeToRunSec = 30;\n    final Thread[] threads = new Thread[10];\n    for (int i = 0; i < threads.length; i++) {\n      final String collectionName = \"collection\" + i;\n      uploadConfig(configset(\"configset-2\"), collectionName);\n      final String baseUrl = solrCluster.getJettySolrRunners().get(0).getBaseUrl().toString();\n      final SolrClient solrClient = getHttpSolrClient(baseUrl);\n      threads[i] = new CreateDeleteSearchCollectionThread(\"create-delete-search-\" + i, collectionName, collectionName, \n          timeToRunSec, solrClient, failure);\n    }\n    \n    startAll(threads);\n    joinAll(threads);\n    \n    assertNull(\"concurrent create and delete collection failed: \" + failure.get(), failure.get());\n  }\n\n","sourceOld":"  public void testConcurrentCreateAndDeleteDoesNotFail() {\n    final File configDir = getFile(\"solr\").toPath().resolve(\"configsets/configset-2/conf\").toFile();\n    final AtomicReference<Exception> failure = new AtomicReference<>();\n    final int timeToRunSec = 30;\n    final Thread[] threads = new Thread[10];\n    for (int i = 0; i < threads.length; i++) {\n      final String collectionName = \"collection\" + i;\n      uploadConfig(configDir, collectionName);\n      final String baseUrl = solrCluster.getJettySolrRunners().get(0).getBaseUrl().toString();\n      final SolrClient solrClient = getHttpSolrClient(baseUrl);\n      threads[i] = new CreateDeleteSearchCollectionThread(\"create-delete-search-\" + i, collectionName, collectionName, \n          timeToRunSec, solrClient, failure);\n    }\n    \n    startAll(threads);\n    joinAll(threads);\n    \n    assertNull(\"concurrent create and delete collection failed: \" + failure.get(), failure.get());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ConcurrentDeleteAndCreateCollectionTest#testConcurrentCreateAndDeleteDoesNotFail().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ConcurrentDeleteAndCreateCollectionTest#testConcurrentCreateAndDeleteDoesNotFail().mjava","sourceNew":"  public void testConcurrentCreateAndDeleteDoesNotFail() {\n    final AtomicReference<Exception> failure = new AtomicReference<>();\n    final int timeToRunSec = 30;\n    final Thread[] threads = new Thread[10];\n    for (int i = 0; i < threads.length; i++) {\n      final String collectionName = \"collection\" + i;\n      uploadConfig(configset(\"configset-2\"), collectionName);\n      final String baseUrl = solrCluster.getJettySolrRunners().get(0).getBaseUrl().toString();\n      final SolrClient solrClient = getHttpSolrClient(baseUrl);\n      threads[i] = new CreateDeleteSearchCollectionThread(\"create-delete-search-\" + i, collectionName, collectionName, \n          timeToRunSec, solrClient, failure);\n    }\n    \n    startAll(threads);\n    joinAll(threads);\n    \n    assertNull(\"concurrent create and delete collection failed: \" + failure.get(), failure.get());\n  }\n\n","sourceOld":"  public void testConcurrentCreateAndDeleteDoesNotFail() {\n    final File configDir = getFile(\"solr\").toPath().resolve(\"configsets/configset-2/conf\").toFile();\n    final AtomicReference<Exception> failure = new AtomicReference<>();\n    final int timeToRunSec = 30;\n    final Thread[] threads = new Thread[10];\n    for (int i = 0; i < threads.length; i++) {\n      final String collectionName = \"collection\" + i;\n      uploadConfig(configDir, collectionName);\n      final String baseUrl = solrCluster.getJettySolrRunners().get(0).getBaseUrl().toString();\n      final SolrClient solrClient = getHttpSolrClient(baseUrl);\n      threads[i] = new CreateDeleteSearchCollectionThread(\"create-delete-search-\" + i, collectionName, collectionName, \n          timeToRunSec, solrClient, failure);\n    }\n    \n    startAll(threads);\n    joinAll(threads);\n    \n    assertNull(\"concurrent create and delete collection failed: \" + failure.get(), failure.get());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fb62399122765831885fcd8484970ba808ac5aaf","date":1485957512,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ConcurrentDeleteAndCreateCollectionTest#testConcurrentCreateAndDeleteDoesNotFail().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ConcurrentDeleteAndCreateCollectionTest#testConcurrentCreateAndDeleteDoesNotFail().mjava","sourceNew":"  public void testConcurrentCreateAndDeleteDoesNotFail() {\n    final AtomicReference<Exception> failure = new AtomicReference<>();\n    final int timeToRunSec = 30;\n    final CreateDeleteCollectionThread[] threads = new CreateDeleteCollectionThread[10];\n    for (int i = 0; i < threads.length; i++) {\n      final String collectionName = \"collection\" + i;\n      uploadConfig(configset(\"configset-2\"), collectionName);\n      final String baseUrl = solrCluster.getJettySolrRunners().get(0).getBaseUrl().toString();\n      final SolrClient solrClient = getHttpSolrClient(baseUrl);\n      threads[i] = new CreateDeleteSearchCollectionThread(\"create-delete-search-\" + i, collectionName, collectionName, \n          timeToRunSec, solrClient, failure);\n    }\n    \n    startAll(threads);\n    joinAll(threads);\n    \n    assertNull(\"concurrent create and delete collection failed: \" + failure.get(), failure.get());\n  }\n\n","sourceOld":"  public void testConcurrentCreateAndDeleteDoesNotFail() {\n    final AtomicReference<Exception> failure = new AtomicReference<>();\n    final int timeToRunSec = 30;\n    final Thread[] threads = new Thread[10];\n    for (int i = 0; i < threads.length; i++) {\n      final String collectionName = \"collection\" + i;\n      uploadConfig(configset(\"configset-2\"), collectionName);\n      final String baseUrl = solrCluster.getJettySolrRunners().get(0).getBaseUrl().toString();\n      final SolrClient solrClient = getHttpSolrClient(baseUrl);\n      threads[i] = new CreateDeleteSearchCollectionThread(\"create-delete-search-\" + i, collectionName, collectionName, \n          timeToRunSec, solrClient, failure);\n    }\n    \n    startAll(threads);\n    joinAll(threads);\n    \n    assertNull(\"concurrent create and delete collection failed: \" + failure.get(), failure.get());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c3523a0ab04c3002eee3896c75ea5f10f388bcc","date":1485968422,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ConcurrentDeleteAndCreateCollectionTest#testConcurrentCreateAndDeleteDoesNotFail().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ConcurrentDeleteAndCreateCollectionTest#testConcurrentCreateAndDeleteDoesNotFail().mjava","sourceNew":"  public void testConcurrentCreateAndDeleteDoesNotFail() {\n    final AtomicReference<Exception> failure = new AtomicReference<>();\n    final int timeToRunSec = 30;\n    final CreateDeleteCollectionThread[] threads = new CreateDeleteCollectionThread[10];\n    for (int i = 0; i < threads.length; i++) {\n      final String collectionName = \"collection\" + i;\n      uploadConfig(configset(\"configset-2\"), collectionName);\n      final String baseUrl = solrCluster.getJettySolrRunners().get(0).getBaseUrl().toString();\n      final SolrClient solrClient = getHttpSolrClient(baseUrl);\n      threads[i] = new CreateDeleteSearchCollectionThread(\"create-delete-search-\" + i, collectionName, collectionName, \n          timeToRunSec, solrClient, failure);\n    }\n    \n    startAll(threads);\n    joinAll(threads);\n    \n    assertNull(\"concurrent create and delete collection failed: \" + failure.get(), failure.get());\n  }\n\n","sourceOld":"  public void testConcurrentCreateAndDeleteDoesNotFail() {\n    final AtomicReference<Exception> failure = new AtomicReference<>();\n    final int timeToRunSec = 30;\n    final Thread[] threads = new Thread[10];\n    for (int i = 0; i < threads.length; i++) {\n      final String collectionName = \"collection\" + i;\n      uploadConfig(configset(\"configset-2\"), collectionName);\n      final String baseUrl = solrCluster.getJettySolrRunners().get(0).getBaseUrl().toString();\n      final SolrClient solrClient = getHttpSolrClient(baseUrl);\n      threads[i] = new CreateDeleteSearchCollectionThread(\"create-delete-search-\" + i, collectionName, collectionName, \n          timeToRunSec, solrClient, failure);\n    }\n    \n    startAll(threads);\n    joinAll(threads);\n    \n    assertNull(\"concurrent create and delete collection failed: \" + failure.get(), failure.get());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6146c07c0dee1ae1e42926167acd127fed5ef59d","date":1516129420,"type":5,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/ConcurrentDeleteAndCreateCollectionTest#testConcurrentCreateAndDeleteDoesNotFail().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ConcurrentDeleteAndCreateCollectionTest#testConcurrentCreateAndDeleteDoesNotFail().mjava","sourceNew":"  public void testConcurrentCreateAndDeleteDoesNotFail() {\n    final AtomicReference<Exception> failure = new AtomicReference<>();\n    final int timeToRunSec = 30;\n    final CreateDeleteCollectionThread[] threads = new CreateDeleteCollectionThread[10];\n    for (int i = 0; i < threads.length; i++) {\n      final String collectionName = \"collection\" + i;\n      uploadConfig(configset(\"configset-2\"), collectionName);\n      final String baseUrl = solrCluster.getJettySolrRunners().get(0).getBaseUrl().toString();\n      final SolrClient solrClient = getHttpSolrClient(baseUrl);\n      threads[i] = new CreateDeleteSearchCollectionThread(\"create-delete-search-\" + i, collectionName, collectionName, \n          timeToRunSec, solrClient, failure);\n    }\n    \n    startAll(threads);\n    joinAll(threads);\n    \n    assertNull(\"concurrent create and delete collection failed: \" + failure.get(), failure.get());\n  }\n\n","sourceOld":"  public void testConcurrentCreateAndDeleteDoesNotFail() {\n    final AtomicReference<Exception> failure = new AtomicReference<>();\n    final int timeToRunSec = 30;\n    final CreateDeleteCollectionThread[] threads = new CreateDeleteCollectionThread[10];\n    for (int i = 0; i < threads.length; i++) {\n      final String collectionName = \"collection\" + i;\n      uploadConfig(configset(\"configset-2\"), collectionName);\n      final String baseUrl = solrCluster.getJettySolrRunners().get(0).getBaseUrl().toString();\n      final SolrClient solrClient = getHttpSolrClient(baseUrl);\n      threads[i] = new CreateDeleteSearchCollectionThread(\"create-delete-search-\" + i, collectionName, collectionName, \n          timeToRunSec, solrClient, failure);\n    }\n    \n    startAll(threads);\n    joinAll(threads);\n    \n    assertNull(\"concurrent create and delete collection failed: \" + failure.get(), failure.get());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":5,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/ConcurrentDeleteAndCreateCollectionTest#testConcurrentCreateAndDeleteDoesNotFail().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ConcurrentDeleteAndCreateCollectionTest#testConcurrentCreateAndDeleteDoesNotFail().mjava","sourceNew":"  public void testConcurrentCreateAndDeleteDoesNotFail() {\n    final AtomicReference<Exception> failure = new AtomicReference<>();\n    final int timeToRunSec = 30;\n    final CreateDeleteCollectionThread[] threads = new CreateDeleteCollectionThread[10];\n    for (int i = 0; i < threads.length; i++) {\n      final String collectionName = \"collection\" + i;\n      uploadConfig(configset(\"configset-2\"), collectionName);\n      final String baseUrl = solrCluster.getJettySolrRunners().get(0).getBaseUrl().toString();\n      final SolrClient solrClient = getHttpSolrClient(baseUrl);\n      threads[i] = new CreateDeleteSearchCollectionThread(\"create-delete-search-\" + i, collectionName, collectionName, \n          timeToRunSec, solrClient, failure);\n    }\n    \n    startAll(threads);\n    joinAll(threads);\n    \n    assertNull(\"concurrent create and delete collection failed: \" + failure.get(), failure.get());\n  }\n\n","sourceOld":"  public void testConcurrentCreateAndDeleteDoesNotFail() {\n    final AtomicReference<Exception> failure = new AtomicReference<>();\n    final int timeToRunSec = 30;\n    final CreateDeleteCollectionThread[] threads = new CreateDeleteCollectionThread[10];\n    for (int i = 0; i < threads.length; i++) {\n      final String collectionName = \"collection\" + i;\n      uploadConfig(configset(\"configset-2\"), collectionName);\n      final String baseUrl = solrCluster.getJettySolrRunners().get(0).getBaseUrl().toString();\n      final SolrClient solrClient = getHttpSolrClient(baseUrl);\n      threads[i] = new CreateDeleteSearchCollectionThread(\"create-delete-search-\" + i, collectionName, collectionName, \n          timeToRunSec, solrClient, failure);\n    }\n    \n    startAll(threads);\n    joinAll(threads);\n    \n    assertNull(\"concurrent create and delete collection failed: \" + failure.get(), failure.get());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b94236357aaa22b76c10629851fe4e376e0cea82":["fb62399122765831885fcd8484970ba808ac5aaf","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"e89a32cc825033ebae8bb9e1c6877c2d9d76749e":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"54bb8da55080e4569804e0661b83a3c72cbd8d4d":["b9820a382c8b45d8d0154b322a2441bec5446204"],"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088":["54bb8da55080e4569804e0661b83a3c72cbd8d4d"],"7c3523a0ab04c3002eee3896c75ea5f10f388bcc":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","fb62399122765831885fcd8484970ba808ac5aaf"],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["fb62399122765831885fcd8484970ba808ac5aaf"],"fb62399122765831885fcd8484970ba808ac5aaf":["e89a32cc825033ebae8bb9e1c6877c2d9d76749e"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","e89a32cc825033ebae8bb9e1c6877c2d9d76749e"],"9ba07da07950fc728766b05e28f9b21754a4acce":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b9820a382c8b45d8d0154b322a2441bec5446204":["9ba07da07950fc728766b05e28f9b21754a4acce"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b":["54bb8da55080e4569804e0661b83a3c72cbd8d4d","e3c94a8b8bf47db4f968d9ae510ec8bbe1372088"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b94236357aaa22b76c10629851fe4e376e0cea82"]},"commit2Childs":{"b94236357aaa22b76c10629851fe4e376e0cea82":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e89a32cc825033ebae8bb9e1c6877c2d9d76749e":["fb62399122765831885fcd8484970ba808ac5aaf","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"54bb8da55080e4569804e0661b83a3c72cbd8d4d":["e3c94a8b8bf47db4f968d9ae510ec8bbe1372088","5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"7c3523a0ab04c3002eee3896c75ea5f10f388bcc":[],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["b94236357aaa22b76c10629851fe4e376e0cea82"],"fb62399122765831885fcd8484970ba808ac5aaf":["b94236357aaa22b76c10629851fe4e376e0cea82","7c3523a0ab04c3002eee3896c75ea5f10f388bcc","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["7c3523a0ab04c3002eee3896c75ea5f10f388bcc"],"9ba07da07950fc728766b05e28f9b21754a4acce":["b9820a382c8b45d8d0154b322a2441bec5446204"],"b9820a382c8b45d8d0154b322a2441bec5446204":["54bb8da55080e4569804e0661b83a3c72cbd8d4d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9ba07da07950fc728766b05e28f9b21754a4acce"],"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b":["e89a32cc825033ebae8bb9e1c6877c2d9d76749e","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["7c3523a0ab04c3002eee3896c75ea5f10f388bcc","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}