{"path":"solr/core/src/test/org/apache/solr/handler/admin/ThreadDumpHandlerTest#doTestOwnableSync(boolean).mjava","commits":[{"id":"e38b745e9eee882a51b0b965cc5ba8daf1009891","date":1594668544,"type":0,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/admin/ThreadDumpHandlerTest#doTestOwnableSync(boolean).mjava","pathOld":"/dev/null","sourceNew":"  public void doTestOwnableSync(final boolean checkWaitingThreadViaPolling) throws Exception {\n    assumeTrue(\"ownable sync checking not supported on this JVM\",\n               ManagementFactory.getThreadMXBean().isSynchronizerUsageSupported());\n\n    /** unique class name to show up as a lock class name in output */\n    final class TestReentrantLockStruct extends ReentrantLock { /* empty */ }\n    \n    final List<String> failures = new ArrayList<>();\n    final CountDownLatch lockIsHeldLatch = new CountDownLatch(1);\n    final CountDownLatch doneWithTestLatch = new CountDownLatch(1);\n    final ReentrantLock lock = new ReentrantLock();\n    final Thread ownerT = new Thread(() -> {\n        lock.lock();\n        try {\n          lockIsHeldLatch.countDown();\n          log.info(\"lock ownerT waiting for doneWithTestLatch to release me...\");\n          try {\n            if ( ! doneWithTestLatch.await(5, TimeUnit.SECONDS ) ){\n              failures.add(\"ownerT: never saw doneWithTestLatch release\");\n            }\n          } catch (InterruptedException ie) {\n            failures.add(\"ownerT: \" + ie.toString());\n          }\n        } finally {\n          lock.unlock();\n        }\n      }, \"test-thread-sync-lock-owner\");\n\n    // only used if checkWaitingThreadViaPolling\n    // don't start until after lockIsHeldLatch fires\n    final Thread blockedT = new Thread(() -> { \n        log.info(\"blockedT waiting for lock...\");\n        lock.lock();\n        try {\n          log.info(\"lock now unblocked\");\n        } finally {\n          lock.unlock();\n        }\n      }, \"test-thread-sync-lock-blocked\");\n    try {\n      ownerT.start();\n      if ( ! lockIsHeldLatch.await(30, TimeUnit.SECONDS ) ){\n        failures.add(\"never saw lockIsHeldLatch released\");\n        return;\n      }\n      assertQ(req(\"qt\", \"/admin/threads\", \"indent\", \"true\")\n              // lock owner 'ownerT'\n              // (which *MAY* also be waiting on doneWithTestLatch, but may not have reached that line yet)\n              , \"//lst[@name='thread'][str[@name='name'][.='test-thread-sync-lock-owner']]\"\n              + \"                     [arr[@name='synchronizers-locked']/str[contains(.,'ReentrantLock')]]\"\n              );\n      \n      if (checkWaitingThreadViaPolling) {\n        log.info(\"Also checking with blockedT thread setup via polling...\");\n        try {\n          blockedT.setPriority(Thread.MAX_PRIORITY);\n        } catch (Exception e) {\n          log.warn(\"Couldn't set blockedT priority\", e);\n        }\n        blockedT.start();\n        // there is no way to \"await\" on the situation of the 'blockedT' thread actually reaches the lock()\n        // call and WAITING in the queue ... we just have to Poll for it...\n        for (int i = 0; i < 500 && (! lock.hasQueuedThread(blockedT)); i++) {\n          Thread.sleep(10); // 10ms at a time, at most 5 sec total\n        }\n        if (lock.hasQueuedThread(blockedT)) {\n          assertQ(req(\"qt\", \"/admin/threads\", \"indent\", \"true\")\n                  // same lock owner 'ownerT'\n                  , \"//lst[@name='thread'][str[@name='name'][.='test-thread-sync-lock-owner']]\"\n                  + \"                     [arr[@name='synchronizers-locked']/str[contains(.,'ReentrantLock')]]\"\n                  // blocked thread 'blockedT', waiting on the lock\n                  , \"//lst[@name='thread'][str[@name='name'][.='test-thread-sync-lock-blocked']]\"\n                  + \"                     [str[@name='state'][.='WAITING']]\"\n                  + \"                     [lst[@name='lock-waiting'][lst[@name='owner']/str[.='test-thread-sync-lock-owner']]]\"\n                  );\n          \n        }\n      }\n    } finally {\n      lockIsHeldLatch.countDown();\n      doneWithTestLatch.countDown();\n      ownerT.join(1000);\n      assertFalse(\"ownerT is still alive\", ownerT.isAlive());\n      blockedT.join(1000);\n      assertFalse(\"blockedT is still alive\", blockedT.isAlive());\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e38b745e9eee882a51b0b965cc5ba8daf1009891":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e38b745e9eee882a51b0b965cc5ba8daf1009891"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e38b745e9eee882a51b0b965cc5ba8daf1009891"],"e38b745e9eee882a51b0b965cc5ba8daf1009891":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}