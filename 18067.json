{"path":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#raceConditionOnDeleteAndRegisterReplica(String).mjava","commits":[{"id":"28ba172425e443e0f08a49de6d73586c418d7251","date":1523970991,"type":0,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#raceConditionOnDeleteAndRegisterReplica(String).mjava","pathOld":"/dev/null","sourceNew":"  public void raceConditionOnDeleteAndRegisterReplica(String legacyCloud) throws Exception {\n    CollectionAdminRequest.setClusterProperty(ZkStateReader.LEGACY_CLOUD, legacyCloud).process(cluster.getSolrClient());\n    final String collectionName = \"raceDeleteReplica_\"+legacyCloud;\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 1, 2)\n        .process(cluster.getSolrClient());\n    waitForState(\"Expected 1x2 collections\", collectionName, clusterShape(1, 2));\n\n    Slice shard1 = getCollectionState(collectionName).getSlice(\"shard1\");\n    Replica leader = shard1.getLeader();\n    JettySolrRunner leaderJetty = getJettyForReplica(leader);\n    Replica replica1 = shard1.getReplicas(replica -> !replica.getName().equals(leader.getName())).get(0);\n    assertFalse(replica1.getName().equals(leader.getName()));\n\n    JettySolrRunner replica1Jetty = getJettyForReplica(replica1);\n\n    String replica1JettyNodeName = replica1Jetty.getNodeName();\n\n    Semaphore waitingForReplicaGetDeleted = new Semaphore(0);\n    // for safety, we only want this hook get triggered one time\n    AtomicInteger times = new AtomicInteger(0);\n    ZkContainer.testing_beforeRegisterInZk = cd -> {\n      if (cd.getCloudDescriptor() == null) return false;\n      if (replica1.getName().equals(cd.getCloudDescriptor().getCoreNodeName())\n          && collectionName.equals(cd.getCloudDescriptor().getCollectionName())) {\n        if (times.incrementAndGet() > 1) {\n          return false;\n        }\n        LOG.info(\"Running delete core {}\",cd);\n        try {\n          ZkNodeProps m = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.CORE_NAME_PROP, replica1.getCoreName(),\n              ZkStateReader.NODE_NAME_PROP, replica1.getNodeName(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.CORE_NODE_NAME_PROP, replica1.getName(),\n              ZkStateReader.BASE_URL_PROP, replica1.getBaseUrl());\n          Overseer.getStateUpdateQueue(cluster.getZkClient()).offer(Utils.toJSON(m));\n\n          boolean replicaDeleted = false;\n          TimeOut timeOut = new TimeOut(20, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n          while (!timeOut.hasTimedOut()) {\n            try {\n              ZkStateReader stateReader = replica1Jetty.getCoreContainer().getZkController().getZkStateReader();\n              stateReader.forceUpdateCollection(collectionName);\n              Slice shard = stateReader.getClusterState().getCollection(collectionName).getSlice(\"shard1\");\n              if (shard.getReplicas().size() == 1) {\n                replicaDeleted = true;\n                waitingForReplicaGetDeleted.release();\n                break;\n              }\n              Thread.sleep(500);\n            } catch (NullPointerException | SolrException e) {\n              e.printStackTrace();\n              Thread.sleep(500);\n            }\n          }\n          if (!replicaDeleted) {\n            fail(\"Timeout for waiting replica get deleted\");\n          }\n        } catch (Exception e) {\n          e.printStackTrace();\n          fail(\"Failed to delete replica\");\n        } finally {\n          //avoiding deadlock\n          waitingForReplicaGetDeleted.release();\n        }\n        return true;\n      }\n      return false;\n    };\n\n    try {\n      replica1Jetty.stop();\n      waitForNodeLeave(replica1JettyNodeName);\n      waitForState(\"Expected replica:\"+replica1+\" get down\", collectionName, (liveNodes, collectionState)\n          -> collectionState.getSlice(\"shard1\").getReplica(replica1.getName()).getState() == DOWN);\n      replica1Jetty.start();\n      waitingForReplicaGetDeleted.acquire();\n    } finally {\n      ZkContainer.testing_beforeRegisterInZk = null;\n    }\n\n    while (true) {\n      try {\n        CollectionAdminRequest.addReplicaToShard(collectionName, \"shard1\")\n            .process(cluster.getSolrClient());\n        break;\n      } catch (Exception e) {\n        // expected, when the node is not fully started\n        Thread.sleep(500);\n      }\n    }\n    waitForState(\"Expected 1x2 collections\", collectionName, clusterShape(1, 2));\n\n    String leaderJettyNodeName = leaderJetty.getNodeName();\n    leaderJetty.stop();\n    waitForNodeLeave(leaderJettyNodeName);\n\n    waitForState(\"Expected new active leader\", collectionName, (liveNodes, collectionState) -> {\n      Slice shard = collectionState.getSlice(\"shard1\");\n      Replica newLeader = shard.getLeader();\n      return newLeader != null && newLeader.getState() == Replica.State.ACTIVE && !newLeader.getName().equals(leader.getName());\n    });\n\n    leaderJetty.start();\n\n    CollectionAdminRequest.deleteCollection(collectionName).process(cluster.getSolrClient());\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ec9197593be550388d24a9ff242fbe19f90cce61","date":1524015606,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#raceConditionOnDeleteAndRegisterReplica(String).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#raceConditionOnDeleteAndRegisterReplica(String).mjava","sourceNew":"  public void raceConditionOnDeleteAndRegisterReplica(String legacyCloud) throws Exception {\n    CollectionAdminRequest.setClusterProperty(ZkStateReader.LEGACY_CLOUD, legacyCloud).process(cluster.getSolrClient());\n    final String collectionName = \"raceDeleteReplica_\"+legacyCloud;\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 1, 2)\n        .process(cluster.getSolrClient());\n    waitForState(\"Expected 1x2 collections\", collectionName, clusterShape(1, 2));\n\n    Slice shard1 = getCollectionState(collectionName).getSlice(\"shard1\");\n    Replica leader = shard1.getLeader();\n    JettySolrRunner leaderJetty = getJettyForReplica(leader);\n    Replica replica1 = shard1.getReplicas(replica -> !replica.getName().equals(leader.getName())).get(0);\n    assertFalse(replica1.getName().equals(leader.getName()));\n\n    JettySolrRunner replica1Jetty = getJettyForReplica(replica1);\n\n    String replica1JettyNodeName = replica1Jetty.getNodeName();\n\n    Semaphore waitingForReplicaGetDeleted = new Semaphore(0);\n    // for safety, we only want this hook get triggered one time\n    AtomicInteger times = new AtomicInteger(0);\n    ZkContainer.testing_beforeRegisterInZk = cd -> {\n      if (cd.getCloudDescriptor() == null) return false;\n      if (replica1.getName().equals(cd.getCloudDescriptor().getCoreNodeName())\n          && collectionName.equals(cd.getCloudDescriptor().getCollectionName())) {\n        if (times.incrementAndGet() > 1) {\n          return false;\n        }\n        LOG.info(\"Running delete core {}\",cd);\n        try {\n          ZkNodeProps m = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.CORE_NAME_PROP, replica1.getCoreName(),\n              ZkStateReader.NODE_NAME_PROP, replica1.getNodeName(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.CORE_NODE_NAME_PROP, replica1.getName(),\n              ZkStateReader.BASE_URL_PROP, replica1.getBaseUrl());\n          Overseer.getStateUpdateQueue(cluster.getZkClient()).offer(Utils.toJSON(m));\n\n          boolean replicaDeleted = false;\n          TimeOut timeOut = new TimeOut(20, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n          while (!timeOut.hasTimedOut()) {\n            try {\n              ZkStateReader stateReader = replica1Jetty.getCoreContainer().getZkController().getZkStateReader();\n              stateReader.forceUpdateCollection(collectionName);\n              Slice shard = stateReader.getClusterState().getCollection(collectionName).getSlice(\"shard1\");\n              if (shard.getReplicas().size() == 1) {\n                replicaDeleted = true;\n                waitingForReplicaGetDeleted.release();\n                break;\n              }\n              Thread.sleep(500);\n            } catch (NullPointerException | SolrException e) {\n              e.printStackTrace();\n              Thread.sleep(500);\n            }\n          }\n          if (!replicaDeleted) {\n            fail(\"Timeout for waiting replica get deleted\");\n          }\n        } catch (Exception e) {\n          e.printStackTrace();\n          fail(\"Failed to delete replica\");\n        } finally {\n          //avoiding deadlock\n          waitingForReplicaGetDeleted.release();\n        }\n        return true;\n      }\n      return false;\n    };\n\n    try {\n      replica1Jetty.stop();\n      waitForNodeLeave(replica1JettyNodeName);\n      waitForState(\"Expected replica:\"+replica1+\" get down\", collectionName, (liveNodes, collectionState)\n          -> collectionState.getSlice(\"shard1\").getReplica(replica1.getName()).getState() == DOWN);\n      replica1Jetty.start();\n      waitingForReplicaGetDeleted.acquire();\n    } finally {\n      ZkContainer.testing_beforeRegisterInZk = null;\n    }\n\n    TimeOut timeOut = new TimeOut(30, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    timeOut.waitFor(\"Timeout adding replica to shard\", () -> {\n      try {\n        CollectionAdminRequest.addReplicaToShard(collectionName, \"shard1\")\n            .process(cluster.getSolrClient());\n        return true;\n      } catch (Exception e) {\n        // expected, when the node is not fully started\n        return false;\n      }\n    });\n    waitForState(\"Expected 1x2 collections\", collectionName, clusterShape(1, 2));\n\n    String leaderJettyNodeName = leaderJetty.getNodeName();\n    leaderJetty.stop();\n    waitForNodeLeave(leaderJettyNodeName);\n\n    waitForState(\"Expected new active leader\", collectionName, (liveNodes, collectionState) -> {\n      Slice shard = collectionState.getSlice(\"shard1\");\n      Replica newLeader = shard.getLeader();\n      return newLeader != null && newLeader.getState() == Replica.State.ACTIVE && !newLeader.getName().equals(leader.getName());\n    });\n\n    leaderJetty.start();\n\n    CollectionAdminRequest.deleteCollection(collectionName).process(cluster.getSolrClient());\n  }\n\n","sourceOld":"  public void raceConditionOnDeleteAndRegisterReplica(String legacyCloud) throws Exception {\n    CollectionAdminRequest.setClusterProperty(ZkStateReader.LEGACY_CLOUD, legacyCloud).process(cluster.getSolrClient());\n    final String collectionName = \"raceDeleteReplica_\"+legacyCloud;\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 1, 2)\n        .process(cluster.getSolrClient());\n    waitForState(\"Expected 1x2 collections\", collectionName, clusterShape(1, 2));\n\n    Slice shard1 = getCollectionState(collectionName).getSlice(\"shard1\");\n    Replica leader = shard1.getLeader();\n    JettySolrRunner leaderJetty = getJettyForReplica(leader);\n    Replica replica1 = shard1.getReplicas(replica -> !replica.getName().equals(leader.getName())).get(0);\n    assertFalse(replica1.getName().equals(leader.getName()));\n\n    JettySolrRunner replica1Jetty = getJettyForReplica(replica1);\n\n    String replica1JettyNodeName = replica1Jetty.getNodeName();\n\n    Semaphore waitingForReplicaGetDeleted = new Semaphore(0);\n    // for safety, we only want this hook get triggered one time\n    AtomicInteger times = new AtomicInteger(0);\n    ZkContainer.testing_beforeRegisterInZk = cd -> {\n      if (cd.getCloudDescriptor() == null) return false;\n      if (replica1.getName().equals(cd.getCloudDescriptor().getCoreNodeName())\n          && collectionName.equals(cd.getCloudDescriptor().getCollectionName())) {\n        if (times.incrementAndGet() > 1) {\n          return false;\n        }\n        LOG.info(\"Running delete core {}\",cd);\n        try {\n          ZkNodeProps m = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.CORE_NAME_PROP, replica1.getCoreName(),\n              ZkStateReader.NODE_NAME_PROP, replica1.getNodeName(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.CORE_NODE_NAME_PROP, replica1.getName(),\n              ZkStateReader.BASE_URL_PROP, replica1.getBaseUrl());\n          Overseer.getStateUpdateQueue(cluster.getZkClient()).offer(Utils.toJSON(m));\n\n          boolean replicaDeleted = false;\n          TimeOut timeOut = new TimeOut(20, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n          while (!timeOut.hasTimedOut()) {\n            try {\n              ZkStateReader stateReader = replica1Jetty.getCoreContainer().getZkController().getZkStateReader();\n              stateReader.forceUpdateCollection(collectionName);\n              Slice shard = stateReader.getClusterState().getCollection(collectionName).getSlice(\"shard1\");\n              if (shard.getReplicas().size() == 1) {\n                replicaDeleted = true;\n                waitingForReplicaGetDeleted.release();\n                break;\n              }\n              Thread.sleep(500);\n            } catch (NullPointerException | SolrException e) {\n              e.printStackTrace();\n              Thread.sleep(500);\n            }\n          }\n          if (!replicaDeleted) {\n            fail(\"Timeout for waiting replica get deleted\");\n          }\n        } catch (Exception e) {\n          e.printStackTrace();\n          fail(\"Failed to delete replica\");\n        } finally {\n          //avoiding deadlock\n          waitingForReplicaGetDeleted.release();\n        }\n        return true;\n      }\n      return false;\n    };\n\n    try {\n      replica1Jetty.stop();\n      waitForNodeLeave(replica1JettyNodeName);\n      waitForState(\"Expected replica:\"+replica1+\" get down\", collectionName, (liveNodes, collectionState)\n          -> collectionState.getSlice(\"shard1\").getReplica(replica1.getName()).getState() == DOWN);\n      replica1Jetty.start();\n      waitingForReplicaGetDeleted.acquire();\n    } finally {\n      ZkContainer.testing_beforeRegisterInZk = null;\n    }\n\n    while (true) {\n      try {\n        CollectionAdminRequest.addReplicaToShard(collectionName, \"shard1\")\n            .process(cluster.getSolrClient());\n        break;\n      } catch (Exception e) {\n        // expected, when the node is not fully started\n        Thread.sleep(500);\n      }\n    }\n    waitForState(\"Expected 1x2 collections\", collectionName, clusterShape(1, 2));\n\n    String leaderJettyNodeName = leaderJetty.getNodeName();\n    leaderJetty.stop();\n    waitForNodeLeave(leaderJettyNodeName);\n\n    waitForState(\"Expected new active leader\", collectionName, (liveNodes, collectionState) -> {\n      Slice shard = collectionState.getSlice(\"shard1\");\n      Replica newLeader = shard.getLeader();\n      return newLeader != null && newLeader.getState() == Replica.State.ACTIVE && !newLeader.getName().equals(leader.getName());\n    });\n\n    leaderJetty.start();\n\n    CollectionAdminRequest.deleteCollection(collectionName).process(cluster.getSolrClient());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"92f789dbd1886e4b468e61b0def88b29a3f55228","date":1533844010,"type":3,"author":"Jason Gerlowski","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#raceConditionOnDeleteAndRegisterReplica(String).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#raceConditionOnDeleteAndRegisterReplica(String).mjava","sourceNew":"  public void raceConditionOnDeleteAndRegisterReplica(String legacyCloud) throws Exception {\n    CollectionAdminRequest.setClusterProperty(ZkStateReader.LEGACY_CLOUD, legacyCloud).process(cluster.getSolrClient());\n    final String collectionName = \"raceDeleteReplica_\"+legacyCloud;\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 1, 2)\n        .process(cluster.getSolrClient());\n    waitForState(\"Expected 1x2 collections\", collectionName, clusterShape(1, 2));\n\n    Slice shard1 = getCollectionState(collectionName).getSlice(\"shard1\");\n    Replica leader = shard1.getLeader();\n    JettySolrRunner leaderJetty = getJettyForReplica(leader);\n    Replica replica1 = shard1.getReplicas(replica -> !replica.getName().equals(leader.getName())).get(0);\n    assertFalse(replica1.getName().equals(leader.getName()));\n\n    JettySolrRunner replica1Jetty = getJettyForReplica(replica1);\n\n    String replica1JettyNodeName = replica1Jetty.getNodeName();\n\n    Semaphore waitingForReplicaGetDeleted = new Semaphore(0);\n    // for safety, we only want this hook get triggered one time\n    AtomicInteger times = new AtomicInteger(0);\n    ZkContainer.testing_beforeRegisterInZk = cd -> {\n      if (cd.getCloudDescriptor() == null) return false;\n      if (replica1.getName().equals(cd.getCloudDescriptor().getCoreNodeName())\n          && collectionName.equals(cd.getCloudDescriptor().getCollectionName())) {\n        if (times.incrementAndGet() > 1) {\n          return false;\n        }\n        LOG.info(\"Running delete core {}\",cd);\n\n        try {\n          ZkNodeProps m = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.CORE_NAME_PROP, replica1.getCoreName(),\n              ZkStateReader.NODE_NAME_PROP, replica1.getNodeName(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.CORE_NODE_NAME_PROP, replica1.getName(),\n              ZkStateReader.BASE_URL_PROP, replica1.getBaseUrl());\n          Overseer.getStateUpdateQueue(cluster.getZkClient()).offer(Utils.toJSON(m));\n\n          boolean replicaDeleted = false;\n          TimeOut timeOut = new TimeOut(20, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n          while (!timeOut.hasTimedOut()) {\n            try {\n              ZkStateReader stateReader = replica1Jetty.getCoreContainer().getZkController().getZkStateReader();\n              stateReader.forceUpdateCollection(collectionName);\n              Slice shard = stateReader.getClusterState().getCollection(collectionName).getSlice(\"shard1\");\n              if (shard.getReplicas().size() == 1) {\n                replicaDeleted = true;\n                waitingForReplicaGetDeleted.release();\n                break;\n              }\n              Thread.sleep(500);\n            } catch (NullPointerException | SolrException e) {\n              e.printStackTrace();\n              Thread.sleep(500);\n            }\n          }\n          if (!replicaDeleted) {\n            fail(\"Timeout for waiting replica get deleted\");\n          }\n        } catch (Exception e) {\n          e.printStackTrace();\n          fail(\"Failed to delete replica\");\n        } finally {\n          //avoiding deadlock\n          waitingForReplicaGetDeleted.release();\n        }\n        return true;\n      }\n      return false;\n    };\n\n    try {\n      replica1Jetty.stop();\n      waitForNodeLeave(replica1JettyNodeName);\n      waitForState(\"Expected replica:\"+replica1+\" get down\", collectionName, (liveNodes, collectionState)\n          -> collectionState.getSlice(\"shard1\").getReplica(replica1.getName()).getState() == DOWN);\n      replica1Jetty.start();\n      waitingForReplicaGetDeleted.acquire();\n    } finally {\n      ZkContainer.testing_beforeRegisterInZk = null;\n    }\n\n    TimeOut timeOut = new TimeOut(30, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    timeOut.waitFor(\"Timeout adding replica to shard\", () -> {\n      try {\n        CollectionAdminRequest.addReplicaToShard(collectionName, \"shard1\")\n            .process(cluster.getSolrClient());\n        return true;\n      } catch (Exception e) {\n        // expected, when the node is not fully started\n        return false;\n      }\n    });\n    waitForState(\"Expected 1x2 collections\", collectionName, clusterShape(1, 2));\n\n    String leaderJettyNodeName = leaderJetty.getNodeName();\n    leaderJetty.stop();\n    waitForNodeLeave(leaderJettyNodeName);\n\n    waitForState(\"Expected new active leader\", collectionName, (liveNodes, collectionState) -> {\n      Slice shard = collectionState.getSlice(\"shard1\");\n      Replica newLeader = shard.getLeader();\n      return newLeader != null && newLeader.getState() == Replica.State.ACTIVE && !newLeader.getName().equals(leader.getName());\n    });\n\n    leaderJetty.start();\n\n    CollectionAdminRequest.deleteCollection(collectionName).process(cluster.getSolrClient());\n  }\n\n","sourceOld":"  public void raceConditionOnDeleteAndRegisterReplica(String legacyCloud) throws Exception {\n    CollectionAdminRequest.setClusterProperty(ZkStateReader.LEGACY_CLOUD, legacyCloud).process(cluster.getSolrClient());\n    final String collectionName = \"raceDeleteReplica_\"+legacyCloud;\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 1, 2)\n        .process(cluster.getSolrClient());\n    waitForState(\"Expected 1x2 collections\", collectionName, clusterShape(1, 2));\n\n    Slice shard1 = getCollectionState(collectionName).getSlice(\"shard1\");\n    Replica leader = shard1.getLeader();\n    JettySolrRunner leaderJetty = getJettyForReplica(leader);\n    Replica replica1 = shard1.getReplicas(replica -> !replica.getName().equals(leader.getName())).get(0);\n    assertFalse(replica1.getName().equals(leader.getName()));\n\n    JettySolrRunner replica1Jetty = getJettyForReplica(replica1);\n\n    String replica1JettyNodeName = replica1Jetty.getNodeName();\n\n    Semaphore waitingForReplicaGetDeleted = new Semaphore(0);\n    // for safety, we only want this hook get triggered one time\n    AtomicInteger times = new AtomicInteger(0);\n    ZkContainer.testing_beforeRegisterInZk = cd -> {\n      if (cd.getCloudDescriptor() == null) return false;\n      if (replica1.getName().equals(cd.getCloudDescriptor().getCoreNodeName())\n          && collectionName.equals(cd.getCloudDescriptor().getCollectionName())) {\n        if (times.incrementAndGet() > 1) {\n          return false;\n        }\n        LOG.info(\"Running delete core {}\",cd);\n        try {\n          ZkNodeProps m = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.CORE_NAME_PROP, replica1.getCoreName(),\n              ZkStateReader.NODE_NAME_PROP, replica1.getNodeName(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.CORE_NODE_NAME_PROP, replica1.getName(),\n              ZkStateReader.BASE_URL_PROP, replica1.getBaseUrl());\n          Overseer.getStateUpdateQueue(cluster.getZkClient()).offer(Utils.toJSON(m));\n\n          boolean replicaDeleted = false;\n          TimeOut timeOut = new TimeOut(20, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n          while (!timeOut.hasTimedOut()) {\n            try {\n              ZkStateReader stateReader = replica1Jetty.getCoreContainer().getZkController().getZkStateReader();\n              stateReader.forceUpdateCollection(collectionName);\n              Slice shard = stateReader.getClusterState().getCollection(collectionName).getSlice(\"shard1\");\n              if (shard.getReplicas().size() == 1) {\n                replicaDeleted = true;\n                waitingForReplicaGetDeleted.release();\n                break;\n              }\n              Thread.sleep(500);\n            } catch (NullPointerException | SolrException e) {\n              e.printStackTrace();\n              Thread.sleep(500);\n            }\n          }\n          if (!replicaDeleted) {\n            fail(\"Timeout for waiting replica get deleted\");\n          }\n        } catch (Exception e) {\n          e.printStackTrace();\n          fail(\"Failed to delete replica\");\n        } finally {\n          //avoiding deadlock\n          waitingForReplicaGetDeleted.release();\n        }\n        return true;\n      }\n      return false;\n    };\n\n    try {\n      replica1Jetty.stop();\n      waitForNodeLeave(replica1JettyNodeName);\n      waitForState(\"Expected replica:\"+replica1+\" get down\", collectionName, (liveNodes, collectionState)\n          -> collectionState.getSlice(\"shard1\").getReplica(replica1.getName()).getState() == DOWN);\n      replica1Jetty.start();\n      waitingForReplicaGetDeleted.acquire();\n    } finally {\n      ZkContainer.testing_beforeRegisterInZk = null;\n    }\n\n    TimeOut timeOut = new TimeOut(30, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    timeOut.waitFor(\"Timeout adding replica to shard\", () -> {\n      try {\n        CollectionAdminRequest.addReplicaToShard(collectionName, \"shard1\")\n            .process(cluster.getSolrClient());\n        return true;\n      } catch (Exception e) {\n        // expected, when the node is not fully started\n        return false;\n      }\n    });\n    waitForState(\"Expected 1x2 collections\", collectionName, clusterShape(1, 2));\n\n    String leaderJettyNodeName = leaderJetty.getNodeName();\n    leaderJetty.stop();\n    waitForNodeLeave(leaderJettyNodeName);\n\n    waitForState(\"Expected new active leader\", collectionName, (liveNodes, collectionState) -> {\n      Slice shard = collectionState.getSlice(\"shard1\");\n      Replica newLeader = shard.getLeader();\n      return newLeader != null && newLeader.getState() == Replica.State.ACTIVE && !newLeader.getName().equals(leader.getName());\n    });\n\n    leaderJetty.start();\n\n    CollectionAdminRequest.deleteCollection(collectionName).process(cluster.getSolrClient());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd","date":1534976797,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#raceConditionOnDeleteAndRegisterReplica(String).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#raceConditionOnDeleteAndRegisterReplica(String).mjava","sourceNew":"  public void raceConditionOnDeleteAndRegisterReplica(String legacyCloud) throws Exception {\n    CollectionAdminRequest.setClusterProperty(ZkStateReader.LEGACY_CLOUD, legacyCloud).process(cluster.getSolrClient());\n    final String collectionName = \"raceDeleteReplica_\"+legacyCloud;\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 1, 2)\n        .process(cluster.getSolrClient());\n    waitForState(\"Expected 1x2 collections\", collectionName, clusterShape(1, 2));\n\n    Slice shard1 = getCollectionState(collectionName).getSlice(\"shard1\");\n    Replica leader = shard1.getLeader();\n    JettySolrRunner leaderJetty = getJettyForReplica(leader);\n    Replica replica1 = shard1.getReplicas(replica -> !replica.getName().equals(leader.getName())).get(0);\n    assertFalse(replica1.getName().equals(leader.getName()));\n\n    JettySolrRunner replica1Jetty = getJettyForReplica(replica1);\n\n    String replica1JettyNodeName = replica1Jetty.getNodeName();\n\n    Semaphore waitingForReplicaGetDeleted = new Semaphore(0);\n    // for safety, we only want this hook get triggered one time\n    AtomicInteger times = new AtomicInteger(0);\n    ZkContainer.testing_beforeRegisterInZk = cd -> {\n      if (cd.getCloudDescriptor() == null) return false;\n      if (replica1.getName().equals(cd.getCloudDescriptor().getCoreNodeName())\n          && collectionName.equals(cd.getCloudDescriptor().getCollectionName())) {\n        if (times.incrementAndGet() > 1) {\n          return false;\n        }\n        log.info(\"Running delete core {}\",cd);\n\n        try {\n          ZkNodeProps m = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.CORE_NAME_PROP, replica1.getCoreName(),\n              ZkStateReader.NODE_NAME_PROP, replica1.getNodeName(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.CORE_NODE_NAME_PROP, replica1.getName(),\n              ZkStateReader.BASE_URL_PROP, replica1.getBaseUrl());\n          Overseer.getStateUpdateQueue(cluster.getZkClient()).offer(Utils.toJSON(m));\n\n          boolean replicaDeleted = false;\n          TimeOut timeOut = new TimeOut(20, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n          while (!timeOut.hasTimedOut()) {\n            try {\n              ZkStateReader stateReader = replica1Jetty.getCoreContainer().getZkController().getZkStateReader();\n              stateReader.forceUpdateCollection(collectionName);\n              Slice shard = stateReader.getClusterState().getCollection(collectionName).getSlice(\"shard1\");\n              if (shard.getReplicas().size() == 1) {\n                replicaDeleted = true;\n                waitingForReplicaGetDeleted.release();\n                break;\n              }\n              Thread.sleep(500);\n            } catch (NullPointerException | SolrException e) {\n              e.printStackTrace();\n              Thread.sleep(500);\n            }\n          }\n          if (!replicaDeleted) {\n            fail(\"Timeout for waiting replica get deleted\");\n          }\n        } catch (Exception e) {\n          e.printStackTrace();\n          fail(\"Failed to delete replica\");\n        } finally {\n          //avoiding deadlock\n          waitingForReplicaGetDeleted.release();\n        }\n        return true;\n      }\n      return false;\n    };\n\n    try {\n      replica1Jetty.stop();\n      waitForNodeLeave(replica1JettyNodeName);\n      waitForState(\"Expected replica:\"+replica1+\" get down\", collectionName, (liveNodes, collectionState)\n          -> collectionState.getSlice(\"shard1\").getReplica(replica1.getName()).getState() == DOWN);\n      replica1Jetty.start();\n      waitingForReplicaGetDeleted.acquire();\n    } finally {\n      ZkContainer.testing_beforeRegisterInZk = null;\n    }\n\n    TimeOut timeOut = new TimeOut(30, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    timeOut.waitFor(\"Timeout adding replica to shard\", () -> {\n      try {\n        CollectionAdminRequest.addReplicaToShard(collectionName, \"shard1\")\n            .process(cluster.getSolrClient());\n        return true;\n      } catch (Exception e) {\n        // expected, when the node is not fully started\n        return false;\n      }\n    });\n    waitForState(\"Expected 1x2 collections\", collectionName, clusterShape(1, 2));\n\n    String leaderJettyNodeName = leaderJetty.getNodeName();\n    leaderJetty.stop();\n    waitForNodeLeave(leaderJettyNodeName);\n\n    waitForState(\"Expected new active leader\", collectionName, (liveNodes, collectionState) -> {\n      Slice shard = collectionState.getSlice(\"shard1\");\n      Replica newLeader = shard.getLeader();\n      return newLeader != null && newLeader.getState() == Replica.State.ACTIVE && !newLeader.getName().equals(leader.getName());\n    });\n\n    leaderJetty.start();\n\n    CollectionAdminRequest.deleteCollection(collectionName).process(cluster.getSolrClient());\n  }\n\n","sourceOld":"  public void raceConditionOnDeleteAndRegisterReplica(String legacyCloud) throws Exception {\n    CollectionAdminRequest.setClusterProperty(ZkStateReader.LEGACY_CLOUD, legacyCloud).process(cluster.getSolrClient());\n    final String collectionName = \"raceDeleteReplica_\"+legacyCloud;\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 1, 2)\n        .process(cluster.getSolrClient());\n    waitForState(\"Expected 1x2 collections\", collectionName, clusterShape(1, 2));\n\n    Slice shard1 = getCollectionState(collectionName).getSlice(\"shard1\");\n    Replica leader = shard1.getLeader();\n    JettySolrRunner leaderJetty = getJettyForReplica(leader);\n    Replica replica1 = shard1.getReplicas(replica -> !replica.getName().equals(leader.getName())).get(0);\n    assertFalse(replica1.getName().equals(leader.getName()));\n\n    JettySolrRunner replica1Jetty = getJettyForReplica(replica1);\n\n    String replica1JettyNodeName = replica1Jetty.getNodeName();\n\n    Semaphore waitingForReplicaGetDeleted = new Semaphore(0);\n    // for safety, we only want this hook get triggered one time\n    AtomicInteger times = new AtomicInteger(0);\n    ZkContainer.testing_beforeRegisterInZk = cd -> {\n      if (cd.getCloudDescriptor() == null) return false;\n      if (replica1.getName().equals(cd.getCloudDescriptor().getCoreNodeName())\n          && collectionName.equals(cd.getCloudDescriptor().getCollectionName())) {\n        if (times.incrementAndGet() > 1) {\n          return false;\n        }\n        LOG.info(\"Running delete core {}\",cd);\n\n        try {\n          ZkNodeProps m = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.CORE_NAME_PROP, replica1.getCoreName(),\n              ZkStateReader.NODE_NAME_PROP, replica1.getNodeName(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.CORE_NODE_NAME_PROP, replica1.getName(),\n              ZkStateReader.BASE_URL_PROP, replica1.getBaseUrl());\n          Overseer.getStateUpdateQueue(cluster.getZkClient()).offer(Utils.toJSON(m));\n\n          boolean replicaDeleted = false;\n          TimeOut timeOut = new TimeOut(20, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n          while (!timeOut.hasTimedOut()) {\n            try {\n              ZkStateReader stateReader = replica1Jetty.getCoreContainer().getZkController().getZkStateReader();\n              stateReader.forceUpdateCollection(collectionName);\n              Slice shard = stateReader.getClusterState().getCollection(collectionName).getSlice(\"shard1\");\n              if (shard.getReplicas().size() == 1) {\n                replicaDeleted = true;\n                waitingForReplicaGetDeleted.release();\n                break;\n              }\n              Thread.sleep(500);\n            } catch (NullPointerException | SolrException e) {\n              e.printStackTrace();\n              Thread.sleep(500);\n            }\n          }\n          if (!replicaDeleted) {\n            fail(\"Timeout for waiting replica get deleted\");\n          }\n        } catch (Exception e) {\n          e.printStackTrace();\n          fail(\"Failed to delete replica\");\n        } finally {\n          //avoiding deadlock\n          waitingForReplicaGetDeleted.release();\n        }\n        return true;\n      }\n      return false;\n    };\n\n    try {\n      replica1Jetty.stop();\n      waitForNodeLeave(replica1JettyNodeName);\n      waitForState(\"Expected replica:\"+replica1+\" get down\", collectionName, (liveNodes, collectionState)\n          -> collectionState.getSlice(\"shard1\").getReplica(replica1.getName()).getState() == DOWN);\n      replica1Jetty.start();\n      waitingForReplicaGetDeleted.acquire();\n    } finally {\n      ZkContainer.testing_beforeRegisterInZk = null;\n    }\n\n    TimeOut timeOut = new TimeOut(30, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    timeOut.waitFor(\"Timeout adding replica to shard\", () -> {\n      try {\n        CollectionAdminRequest.addReplicaToShard(collectionName, \"shard1\")\n            .process(cluster.getSolrClient());\n        return true;\n      } catch (Exception e) {\n        // expected, when the node is not fully started\n        return false;\n      }\n    });\n    waitForState(\"Expected 1x2 collections\", collectionName, clusterShape(1, 2));\n\n    String leaderJettyNodeName = leaderJetty.getNodeName();\n    leaderJetty.stop();\n    waitForNodeLeave(leaderJettyNodeName);\n\n    waitForState(\"Expected new active leader\", collectionName, (liveNodes, collectionState) -> {\n      Slice shard = collectionState.getSlice(\"shard1\");\n      Replica newLeader = shard.getLeader();\n      return newLeader != null && newLeader.getState() == Replica.State.ACTIVE && !newLeader.getName().equals(leader.getName());\n    });\n\n    leaderJetty.start();\n\n    CollectionAdminRequest.deleteCollection(collectionName).process(cluster.getSolrClient());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#raceConditionOnDeleteAndRegisterReplica(String).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#raceConditionOnDeleteAndRegisterReplica(String).mjava","sourceNew":"  public void raceConditionOnDeleteAndRegisterReplica(String legacyCloud) throws Exception {\n    \n    CollectionAdminRequest.setClusterProperty(ZkStateReader.LEGACY_CLOUD, legacyCloud).process(cluster.getSolrClient());\n    final String collectionName = \"raceDeleteReplica_\"+legacyCloud;\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 1, 2)\n        .process(cluster.getSolrClient());\n    \n    cluster.waitForActiveCollection(collectionName, 1, 2);\n    \n    waitForState(\"Expected 1x2 collections\", collectionName, clusterShape(1, 2));\n\n    Slice shard1 = getCollectionState(collectionName).getSlice(\"shard1\");\n    Replica leader = shard1.getLeader();\n    JettySolrRunner leaderJetty = getJettyForReplica(leader);\n    Replica replica1 = shard1.getReplicas(replica -> !replica.getName().equals(leader.getName())).get(0);\n    assertFalse(replica1.getName().equals(leader.getName()));\n\n    JettySolrRunner replica1Jetty = getJettyForReplica(replica1);\n\n    String replica1JettyNodeName = replica1Jetty.getNodeName();\n\n    Semaphore waitingForReplicaGetDeleted = new Semaphore(0);\n    // for safety, we only want this hook get triggered one time\n    AtomicInteger times = new AtomicInteger(0);\n    ZkContainer.testing_beforeRegisterInZk = cd -> {\n      if (cd.getCloudDescriptor() == null) return false;\n      if (replica1.getName().equals(cd.getCloudDescriptor().getCoreNodeName())\n          && collectionName.equals(cd.getCloudDescriptor().getCollectionName())) {\n        if (times.incrementAndGet() > 1) {\n          return false;\n        }\n        log.info(\"Running delete core {}\",cd);\n\n        try {\n          ZkNodeProps m = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.CORE_NAME_PROP, replica1.getCoreName(),\n              ZkStateReader.NODE_NAME_PROP, replica1.getNodeName(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.CORE_NODE_NAME_PROP, replica1.getName(),\n              ZkStateReader.BASE_URL_PROP, replica1.getBaseUrl());\n          cluster.getOpenOverseer().getStateUpdateQueue().offer(Utils.toJSON(m));\n\n          boolean replicaDeleted = false;\n          TimeOut timeOut = new TimeOut(20, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n          while (!timeOut.hasTimedOut()) {\n            try {\n              ZkStateReader stateReader = replica1Jetty.getCoreContainer().getZkController().getZkStateReader();\n              stateReader.forceUpdateCollection(collectionName);\n              Slice shard = stateReader.getClusterState().getCollection(collectionName).getSlice(\"shard1\");\n              if (shard.getReplicas().size() == 1) {\n                replicaDeleted = true;\n                waitingForReplicaGetDeleted.release();\n                break;\n              }\n              Thread.sleep(500);\n            } catch (NullPointerException | SolrException e) {\n              e.printStackTrace();\n              Thread.sleep(500);\n            }\n          }\n          if (!replicaDeleted) {\n            fail(\"Timeout for waiting replica get deleted\");\n          }\n        } catch (Exception e) {\n          e.printStackTrace();\n          fail(\"Failed to delete replica\");\n        } finally {\n          //avoiding deadlock\n          waitingForReplicaGetDeleted.release();\n        }\n        return true;\n      }\n      return false;\n    };\n\n    try {\n      replica1Jetty.stop();\n      waitForNodeLeave(replica1JettyNodeName);\n      waitForState(\"Expected replica:\"+replica1+\" get down\", collectionName, (liveNodes, collectionState)\n          -> collectionState.getSlice(\"shard1\").getReplica(replica1.getName()).getState() == DOWN);\n      replica1Jetty.start();\n      waitingForReplicaGetDeleted.acquire();\n    } finally {\n      ZkContainer.testing_beforeRegisterInZk = null;\n    }\n\n    TimeOut timeOut = new TimeOut(30, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    timeOut.waitFor(\"Timeout adding replica to shard\", () -> {\n      try {\n        CollectionAdminRequest.addReplicaToShard(collectionName, \"shard1\")\n            .process(cluster.getSolrClient());\n        return true;\n      } catch (Exception e) {\n        // expected, when the node is not fully started\n        return false;\n      }\n    });\n    waitForState(\"Expected 1x2 collections\", collectionName, clusterShape(1, 2));\n\n    shard1 = getCollectionState(collectionName).getSlice(\"shard1\");\n    Replica latestLeader = shard1.getLeader();\n    leaderJetty = getJettyForReplica(latestLeader);\n    String leaderJettyNodeName = leaderJetty.getNodeName();\n    leaderJetty.stop();\n    waitForNodeLeave(leaderJettyNodeName);\n\n    waitForState(\"Expected new active leader\", collectionName, (liveNodes, collectionState) -> {\n      Slice shard = collectionState.getSlice(\"shard1\");\n      Replica newLeader = shard.getLeader();\n      return newLeader != null && newLeader.getState() == Replica.State.ACTIVE && !newLeader.getName().equals(latestLeader.getName());\n    });\n\n    leaderJetty.start();\n\n    CollectionAdminRequest.deleteCollection(collectionName).process(cluster.getSolrClient());\n  }\n\n","sourceOld":"  public void raceConditionOnDeleteAndRegisterReplica(String legacyCloud) throws Exception {\n    CollectionAdminRequest.setClusterProperty(ZkStateReader.LEGACY_CLOUD, legacyCloud).process(cluster.getSolrClient());\n    final String collectionName = \"raceDeleteReplica_\"+legacyCloud;\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 1, 2)\n        .process(cluster.getSolrClient());\n    waitForState(\"Expected 1x2 collections\", collectionName, clusterShape(1, 2));\n\n    Slice shard1 = getCollectionState(collectionName).getSlice(\"shard1\");\n    Replica leader = shard1.getLeader();\n    JettySolrRunner leaderJetty = getJettyForReplica(leader);\n    Replica replica1 = shard1.getReplicas(replica -> !replica.getName().equals(leader.getName())).get(0);\n    assertFalse(replica1.getName().equals(leader.getName()));\n\n    JettySolrRunner replica1Jetty = getJettyForReplica(replica1);\n\n    String replica1JettyNodeName = replica1Jetty.getNodeName();\n\n    Semaphore waitingForReplicaGetDeleted = new Semaphore(0);\n    // for safety, we only want this hook get triggered one time\n    AtomicInteger times = new AtomicInteger(0);\n    ZkContainer.testing_beforeRegisterInZk = cd -> {\n      if (cd.getCloudDescriptor() == null) return false;\n      if (replica1.getName().equals(cd.getCloudDescriptor().getCoreNodeName())\n          && collectionName.equals(cd.getCloudDescriptor().getCollectionName())) {\n        if (times.incrementAndGet() > 1) {\n          return false;\n        }\n        log.info(\"Running delete core {}\",cd);\n\n        try {\n          ZkNodeProps m = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.CORE_NAME_PROP, replica1.getCoreName(),\n              ZkStateReader.NODE_NAME_PROP, replica1.getNodeName(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.CORE_NODE_NAME_PROP, replica1.getName(),\n              ZkStateReader.BASE_URL_PROP, replica1.getBaseUrl());\n          Overseer.getStateUpdateQueue(cluster.getZkClient()).offer(Utils.toJSON(m));\n\n          boolean replicaDeleted = false;\n          TimeOut timeOut = new TimeOut(20, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n          while (!timeOut.hasTimedOut()) {\n            try {\n              ZkStateReader stateReader = replica1Jetty.getCoreContainer().getZkController().getZkStateReader();\n              stateReader.forceUpdateCollection(collectionName);\n              Slice shard = stateReader.getClusterState().getCollection(collectionName).getSlice(\"shard1\");\n              if (shard.getReplicas().size() == 1) {\n                replicaDeleted = true;\n                waitingForReplicaGetDeleted.release();\n                break;\n              }\n              Thread.sleep(500);\n            } catch (NullPointerException | SolrException e) {\n              e.printStackTrace();\n              Thread.sleep(500);\n            }\n          }\n          if (!replicaDeleted) {\n            fail(\"Timeout for waiting replica get deleted\");\n          }\n        } catch (Exception e) {\n          e.printStackTrace();\n          fail(\"Failed to delete replica\");\n        } finally {\n          //avoiding deadlock\n          waitingForReplicaGetDeleted.release();\n        }\n        return true;\n      }\n      return false;\n    };\n\n    try {\n      replica1Jetty.stop();\n      waitForNodeLeave(replica1JettyNodeName);\n      waitForState(\"Expected replica:\"+replica1+\" get down\", collectionName, (liveNodes, collectionState)\n          -> collectionState.getSlice(\"shard1\").getReplica(replica1.getName()).getState() == DOWN);\n      replica1Jetty.start();\n      waitingForReplicaGetDeleted.acquire();\n    } finally {\n      ZkContainer.testing_beforeRegisterInZk = null;\n    }\n\n    TimeOut timeOut = new TimeOut(30, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    timeOut.waitFor(\"Timeout adding replica to shard\", () -> {\n      try {\n        CollectionAdminRequest.addReplicaToShard(collectionName, \"shard1\")\n            .process(cluster.getSolrClient());\n        return true;\n      } catch (Exception e) {\n        // expected, when the node is not fully started\n        return false;\n      }\n    });\n    waitForState(\"Expected 1x2 collections\", collectionName, clusterShape(1, 2));\n\n    String leaderJettyNodeName = leaderJetty.getNodeName();\n    leaderJetty.stop();\n    waitForNodeLeave(leaderJettyNodeName);\n\n    waitForState(\"Expected new active leader\", collectionName, (liveNodes, collectionState) -> {\n      Slice shard = collectionState.getSlice(\"shard1\");\n      Replica newLeader = shard.getLeader();\n      return newLeader != null && newLeader.getState() == Replica.State.ACTIVE && !newLeader.getName().equals(leader.getName());\n    });\n\n    leaderJetty.start();\n\n    CollectionAdminRequest.deleteCollection(collectionName).process(cluster.getSolrClient());\n  }\n\n","bugFix":["28ba172425e443e0f08a49de6d73586c418d7251"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8d35c84fdef07284c122012ca4000d3b7285a66e","date":1545962630,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#raceConditionOnDeleteAndRegisterReplica(String).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#raceConditionOnDeleteAndRegisterReplica(String).mjava","sourceNew":"  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // annotated on: 24-Dec-2018\n  public void raceConditionOnDeleteAndRegisterReplica(String legacyCloud) throws Exception {\n    \n    CollectionAdminRequest.setClusterProperty(ZkStateReader.LEGACY_CLOUD, legacyCloud).process(cluster.getSolrClient());\n    final String collectionName = \"raceDeleteReplica_\"+legacyCloud;\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 1, 2)\n        .process(cluster.getSolrClient());\n    \n    cluster.waitForActiveCollection(collectionName, 1, 2);\n    \n    waitForState(\"Expected 1x2 collections\", collectionName, clusterShape(1, 2));\n\n    Slice shard1 = getCollectionState(collectionName).getSlice(\"shard1\");\n    Replica leader = shard1.getLeader();\n    JettySolrRunner leaderJetty = getJettyForReplica(leader);\n    Replica replica1 = shard1.getReplicas(replica -> !replica.getName().equals(leader.getName())).get(0);\n    assertFalse(replica1.getName().equals(leader.getName()));\n\n    JettySolrRunner replica1Jetty = getJettyForReplica(replica1);\n\n    String replica1JettyNodeName = replica1Jetty.getNodeName();\n\n    Semaphore waitingForReplicaGetDeleted = new Semaphore(0);\n    // for safety, we only want this hook get triggered one time\n    AtomicInteger times = new AtomicInteger(0);\n    ZkContainer.testing_beforeRegisterInZk = cd -> {\n      if (cd.getCloudDescriptor() == null) return false;\n      if (replica1.getName().equals(cd.getCloudDescriptor().getCoreNodeName())\n          && collectionName.equals(cd.getCloudDescriptor().getCollectionName())) {\n        if (times.incrementAndGet() > 1) {\n          return false;\n        }\n        log.info(\"Running delete core {}\",cd);\n\n        try {\n          ZkNodeProps m = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.CORE_NAME_PROP, replica1.getCoreName(),\n              ZkStateReader.NODE_NAME_PROP, replica1.getNodeName(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.CORE_NODE_NAME_PROP, replica1.getName(),\n              ZkStateReader.BASE_URL_PROP, replica1.getBaseUrl());\n          cluster.getOpenOverseer().getStateUpdateQueue().offer(Utils.toJSON(m));\n\n          boolean replicaDeleted = false;\n          TimeOut timeOut = new TimeOut(20, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n          while (!timeOut.hasTimedOut()) {\n            try {\n              ZkStateReader stateReader = replica1Jetty.getCoreContainer().getZkController().getZkStateReader();\n              stateReader.forceUpdateCollection(collectionName);\n              Slice shard = stateReader.getClusterState().getCollection(collectionName).getSlice(\"shard1\");\n              if (shard.getReplicas().size() == 1) {\n                replicaDeleted = true;\n                waitingForReplicaGetDeleted.release();\n                break;\n              }\n              Thread.sleep(500);\n            } catch (NullPointerException | SolrException e) {\n              e.printStackTrace();\n              Thread.sleep(500);\n            }\n          }\n          if (!replicaDeleted) {\n            fail(\"Timeout for waiting replica get deleted\");\n          }\n        } catch (Exception e) {\n          e.printStackTrace();\n          fail(\"Failed to delete replica\");\n        } finally {\n          //avoiding deadlock\n          waitingForReplicaGetDeleted.release();\n        }\n        return true;\n      }\n      return false;\n    };\n\n    try {\n      replica1Jetty.stop();\n      waitForNodeLeave(replica1JettyNodeName);\n      waitForState(\"Expected replica:\"+replica1+\" get down\", collectionName, (liveNodes, collectionState)\n          -> collectionState.getSlice(\"shard1\").getReplica(replica1.getName()).getState() == DOWN);\n      replica1Jetty.start();\n      waitingForReplicaGetDeleted.acquire();\n    } finally {\n      ZkContainer.testing_beforeRegisterInZk = null;\n    }\n\n    TimeOut timeOut = new TimeOut(30, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    timeOut.waitFor(\"Timeout adding replica to shard\", () -> {\n      try {\n        CollectionAdminRequest.addReplicaToShard(collectionName, \"shard1\")\n            .process(cluster.getSolrClient());\n        return true;\n      } catch (Exception e) {\n        // expected, when the node is not fully started\n        return false;\n      }\n    });\n    waitForState(\"Expected 1x2 collections\", collectionName, clusterShape(1, 2));\n\n    shard1 = getCollectionState(collectionName).getSlice(\"shard1\");\n    Replica latestLeader = shard1.getLeader();\n    leaderJetty = getJettyForReplica(latestLeader);\n    String leaderJettyNodeName = leaderJetty.getNodeName();\n    leaderJetty.stop();\n    waitForNodeLeave(leaderJettyNodeName);\n\n    waitForState(\"Expected new active leader\", collectionName, (liveNodes, collectionState) -> {\n      Slice shard = collectionState.getSlice(\"shard1\");\n      Replica newLeader = shard.getLeader();\n      return newLeader != null && newLeader.getState() == Replica.State.ACTIVE && !newLeader.getName().equals(latestLeader.getName());\n    });\n\n    leaderJetty.start();\n\n    CollectionAdminRequest.deleteCollection(collectionName).process(cluster.getSolrClient());\n  }\n\n","sourceOld":"  public void raceConditionOnDeleteAndRegisterReplica(String legacyCloud) throws Exception {\n    \n    CollectionAdminRequest.setClusterProperty(ZkStateReader.LEGACY_CLOUD, legacyCloud).process(cluster.getSolrClient());\n    final String collectionName = \"raceDeleteReplica_\"+legacyCloud;\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 1, 2)\n        .process(cluster.getSolrClient());\n    \n    cluster.waitForActiveCollection(collectionName, 1, 2);\n    \n    waitForState(\"Expected 1x2 collections\", collectionName, clusterShape(1, 2));\n\n    Slice shard1 = getCollectionState(collectionName).getSlice(\"shard1\");\n    Replica leader = shard1.getLeader();\n    JettySolrRunner leaderJetty = getJettyForReplica(leader);\n    Replica replica1 = shard1.getReplicas(replica -> !replica.getName().equals(leader.getName())).get(0);\n    assertFalse(replica1.getName().equals(leader.getName()));\n\n    JettySolrRunner replica1Jetty = getJettyForReplica(replica1);\n\n    String replica1JettyNodeName = replica1Jetty.getNodeName();\n\n    Semaphore waitingForReplicaGetDeleted = new Semaphore(0);\n    // for safety, we only want this hook get triggered one time\n    AtomicInteger times = new AtomicInteger(0);\n    ZkContainer.testing_beforeRegisterInZk = cd -> {\n      if (cd.getCloudDescriptor() == null) return false;\n      if (replica1.getName().equals(cd.getCloudDescriptor().getCoreNodeName())\n          && collectionName.equals(cd.getCloudDescriptor().getCollectionName())) {\n        if (times.incrementAndGet() > 1) {\n          return false;\n        }\n        log.info(\"Running delete core {}\",cd);\n\n        try {\n          ZkNodeProps m = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.CORE_NAME_PROP, replica1.getCoreName(),\n              ZkStateReader.NODE_NAME_PROP, replica1.getNodeName(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.CORE_NODE_NAME_PROP, replica1.getName(),\n              ZkStateReader.BASE_URL_PROP, replica1.getBaseUrl());\n          cluster.getOpenOverseer().getStateUpdateQueue().offer(Utils.toJSON(m));\n\n          boolean replicaDeleted = false;\n          TimeOut timeOut = new TimeOut(20, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n          while (!timeOut.hasTimedOut()) {\n            try {\n              ZkStateReader stateReader = replica1Jetty.getCoreContainer().getZkController().getZkStateReader();\n              stateReader.forceUpdateCollection(collectionName);\n              Slice shard = stateReader.getClusterState().getCollection(collectionName).getSlice(\"shard1\");\n              if (shard.getReplicas().size() == 1) {\n                replicaDeleted = true;\n                waitingForReplicaGetDeleted.release();\n                break;\n              }\n              Thread.sleep(500);\n            } catch (NullPointerException | SolrException e) {\n              e.printStackTrace();\n              Thread.sleep(500);\n            }\n          }\n          if (!replicaDeleted) {\n            fail(\"Timeout for waiting replica get deleted\");\n          }\n        } catch (Exception e) {\n          e.printStackTrace();\n          fail(\"Failed to delete replica\");\n        } finally {\n          //avoiding deadlock\n          waitingForReplicaGetDeleted.release();\n        }\n        return true;\n      }\n      return false;\n    };\n\n    try {\n      replica1Jetty.stop();\n      waitForNodeLeave(replica1JettyNodeName);\n      waitForState(\"Expected replica:\"+replica1+\" get down\", collectionName, (liveNodes, collectionState)\n          -> collectionState.getSlice(\"shard1\").getReplica(replica1.getName()).getState() == DOWN);\n      replica1Jetty.start();\n      waitingForReplicaGetDeleted.acquire();\n    } finally {\n      ZkContainer.testing_beforeRegisterInZk = null;\n    }\n\n    TimeOut timeOut = new TimeOut(30, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    timeOut.waitFor(\"Timeout adding replica to shard\", () -> {\n      try {\n        CollectionAdminRequest.addReplicaToShard(collectionName, \"shard1\")\n            .process(cluster.getSolrClient());\n        return true;\n      } catch (Exception e) {\n        // expected, when the node is not fully started\n        return false;\n      }\n    });\n    waitForState(\"Expected 1x2 collections\", collectionName, clusterShape(1, 2));\n\n    shard1 = getCollectionState(collectionName).getSlice(\"shard1\");\n    Replica latestLeader = shard1.getLeader();\n    leaderJetty = getJettyForReplica(latestLeader);\n    String leaderJettyNodeName = leaderJetty.getNodeName();\n    leaderJetty.stop();\n    waitForNodeLeave(leaderJettyNodeName);\n\n    waitForState(\"Expected new active leader\", collectionName, (liveNodes, collectionState) -> {\n      Slice shard = collectionState.getSlice(\"shard1\");\n      Replica newLeader = shard.getLeader();\n      return newLeader != null && newLeader.getState() == Replica.State.ACTIVE && !newLeader.getName().equals(latestLeader.getName());\n    });\n\n    leaderJetty.start();\n\n    CollectionAdminRequest.deleteCollection(collectionName).process(cluster.getSolrClient());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b5c929d2716fa79d443b93a82adb1da5b578ebd8","date":1550428858,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#raceConditionOnDeleteAndRegisterReplica(String).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#raceConditionOnDeleteAndRegisterReplica(String).mjava","sourceNew":"  // commented out on: 17-Feb-2019   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // annotated on: 24-Dec-2018\n  public void raceConditionOnDeleteAndRegisterReplica(String legacyCloud) throws Exception {\n    \n    CollectionAdminRequest.setClusterProperty(ZkStateReader.LEGACY_CLOUD, legacyCloud).process(cluster.getSolrClient());\n    final String collectionName = \"raceDeleteReplica_\"+legacyCloud;\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 1, 2)\n        .process(cluster.getSolrClient());\n    \n    cluster.waitForActiveCollection(collectionName, 1, 2);\n    \n    waitForState(\"Expected 1x2 collections\", collectionName, clusterShape(1, 2));\n\n    Slice shard1 = getCollectionState(collectionName).getSlice(\"shard1\");\n    Replica leader = shard1.getLeader();\n    JettySolrRunner leaderJetty = getJettyForReplica(leader);\n    Replica replica1 = shard1.getReplicas(replica -> !replica.getName().equals(leader.getName())).get(0);\n    assertFalse(replica1.getName().equals(leader.getName()));\n\n    JettySolrRunner replica1Jetty = getJettyForReplica(replica1);\n\n    String replica1JettyNodeName = replica1Jetty.getNodeName();\n\n    Semaphore waitingForReplicaGetDeleted = new Semaphore(0);\n    // for safety, we only want this hook get triggered one time\n    AtomicInteger times = new AtomicInteger(0);\n    ZkContainer.testing_beforeRegisterInZk = cd -> {\n      if (cd.getCloudDescriptor() == null) return false;\n      if (replica1.getName().equals(cd.getCloudDescriptor().getCoreNodeName())\n          && collectionName.equals(cd.getCloudDescriptor().getCollectionName())) {\n        if (times.incrementAndGet() > 1) {\n          return false;\n        }\n        log.info(\"Running delete core {}\",cd);\n\n        try {\n          ZkNodeProps m = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.CORE_NAME_PROP, replica1.getCoreName(),\n              ZkStateReader.NODE_NAME_PROP, replica1.getNodeName(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.CORE_NODE_NAME_PROP, replica1.getName(),\n              ZkStateReader.BASE_URL_PROP, replica1.getBaseUrl());\n          cluster.getOpenOverseer().getStateUpdateQueue().offer(Utils.toJSON(m));\n\n          boolean replicaDeleted = false;\n          TimeOut timeOut = new TimeOut(20, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n          while (!timeOut.hasTimedOut()) {\n            try {\n              ZkStateReader stateReader = replica1Jetty.getCoreContainer().getZkController().getZkStateReader();\n              stateReader.forceUpdateCollection(collectionName);\n              Slice shard = stateReader.getClusterState().getCollection(collectionName).getSlice(\"shard1\");\n              if (shard.getReplicas().size() == 1) {\n                replicaDeleted = true;\n                waitingForReplicaGetDeleted.release();\n                break;\n              }\n              Thread.sleep(500);\n            } catch (NullPointerException | SolrException e) {\n              e.printStackTrace();\n              Thread.sleep(500);\n            }\n          }\n          if (!replicaDeleted) {\n            fail(\"Timeout for waiting replica get deleted\");\n          }\n        } catch (Exception e) {\n          e.printStackTrace();\n          fail(\"Failed to delete replica\");\n        } finally {\n          //avoiding deadlock\n          waitingForReplicaGetDeleted.release();\n        }\n        return true;\n      }\n      return false;\n    };\n\n    try {\n      replica1Jetty.stop();\n      waitForNodeLeave(replica1JettyNodeName);\n      waitForState(\"Expected replica:\"+replica1+\" get down\", collectionName, (liveNodes, collectionState)\n          -> collectionState.getSlice(\"shard1\").getReplica(replica1.getName()).getState() == DOWN);\n      replica1Jetty.start();\n      waitingForReplicaGetDeleted.acquire();\n    } finally {\n      ZkContainer.testing_beforeRegisterInZk = null;\n    }\n\n    TimeOut timeOut = new TimeOut(30, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    timeOut.waitFor(\"Timeout adding replica to shard\", () -> {\n      try {\n        CollectionAdminRequest.addReplicaToShard(collectionName, \"shard1\")\n            .process(cluster.getSolrClient());\n        return true;\n      } catch (Exception e) {\n        // expected, when the node is not fully started\n        return false;\n      }\n    });\n    waitForState(\"Expected 1x2 collections\", collectionName, clusterShape(1, 2));\n\n    shard1 = getCollectionState(collectionName).getSlice(\"shard1\");\n    Replica latestLeader = shard1.getLeader();\n    leaderJetty = getJettyForReplica(latestLeader);\n    String leaderJettyNodeName = leaderJetty.getNodeName();\n    leaderJetty.stop();\n    waitForNodeLeave(leaderJettyNodeName);\n\n    waitForState(\"Expected new active leader\", collectionName, (liveNodes, collectionState) -> {\n      Slice shard = collectionState.getSlice(\"shard1\");\n      Replica newLeader = shard.getLeader();\n      return newLeader != null && newLeader.getState() == Replica.State.ACTIVE && !newLeader.getName().equals(latestLeader.getName());\n    });\n\n    leaderJetty.start();\n\n    CollectionAdminRequest.deleteCollection(collectionName).process(cluster.getSolrClient());\n  }\n\n","sourceOld":"  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // annotated on: 24-Dec-2018\n  public void raceConditionOnDeleteAndRegisterReplica(String legacyCloud) throws Exception {\n    \n    CollectionAdminRequest.setClusterProperty(ZkStateReader.LEGACY_CLOUD, legacyCloud).process(cluster.getSolrClient());\n    final String collectionName = \"raceDeleteReplica_\"+legacyCloud;\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 1, 2)\n        .process(cluster.getSolrClient());\n    \n    cluster.waitForActiveCollection(collectionName, 1, 2);\n    \n    waitForState(\"Expected 1x2 collections\", collectionName, clusterShape(1, 2));\n\n    Slice shard1 = getCollectionState(collectionName).getSlice(\"shard1\");\n    Replica leader = shard1.getLeader();\n    JettySolrRunner leaderJetty = getJettyForReplica(leader);\n    Replica replica1 = shard1.getReplicas(replica -> !replica.getName().equals(leader.getName())).get(0);\n    assertFalse(replica1.getName().equals(leader.getName()));\n\n    JettySolrRunner replica1Jetty = getJettyForReplica(replica1);\n\n    String replica1JettyNodeName = replica1Jetty.getNodeName();\n\n    Semaphore waitingForReplicaGetDeleted = new Semaphore(0);\n    // for safety, we only want this hook get triggered one time\n    AtomicInteger times = new AtomicInteger(0);\n    ZkContainer.testing_beforeRegisterInZk = cd -> {\n      if (cd.getCloudDescriptor() == null) return false;\n      if (replica1.getName().equals(cd.getCloudDescriptor().getCoreNodeName())\n          && collectionName.equals(cd.getCloudDescriptor().getCollectionName())) {\n        if (times.incrementAndGet() > 1) {\n          return false;\n        }\n        log.info(\"Running delete core {}\",cd);\n\n        try {\n          ZkNodeProps m = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.CORE_NAME_PROP, replica1.getCoreName(),\n              ZkStateReader.NODE_NAME_PROP, replica1.getNodeName(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.CORE_NODE_NAME_PROP, replica1.getName(),\n              ZkStateReader.BASE_URL_PROP, replica1.getBaseUrl());\n          cluster.getOpenOverseer().getStateUpdateQueue().offer(Utils.toJSON(m));\n\n          boolean replicaDeleted = false;\n          TimeOut timeOut = new TimeOut(20, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n          while (!timeOut.hasTimedOut()) {\n            try {\n              ZkStateReader stateReader = replica1Jetty.getCoreContainer().getZkController().getZkStateReader();\n              stateReader.forceUpdateCollection(collectionName);\n              Slice shard = stateReader.getClusterState().getCollection(collectionName).getSlice(\"shard1\");\n              if (shard.getReplicas().size() == 1) {\n                replicaDeleted = true;\n                waitingForReplicaGetDeleted.release();\n                break;\n              }\n              Thread.sleep(500);\n            } catch (NullPointerException | SolrException e) {\n              e.printStackTrace();\n              Thread.sleep(500);\n            }\n          }\n          if (!replicaDeleted) {\n            fail(\"Timeout for waiting replica get deleted\");\n          }\n        } catch (Exception e) {\n          e.printStackTrace();\n          fail(\"Failed to delete replica\");\n        } finally {\n          //avoiding deadlock\n          waitingForReplicaGetDeleted.release();\n        }\n        return true;\n      }\n      return false;\n    };\n\n    try {\n      replica1Jetty.stop();\n      waitForNodeLeave(replica1JettyNodeName);\n      waitForState(\"Expected replica:\"+replica1+\" get down\", collectionName, (liveNodes, collectionState)\n          -> collectionState.getSlice(\"shard1\").getReplica(replica1.getName()).getState() == DOWN);\n      replica1Jetty.start();\n      waitingForReplicaGetDeleted.acquire();\n    } finally {\n      ZkContainer.testing_beforeRegisterInZk = null;\n    }\n\n    TimeOut timeOut = new TimeOut(30, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    timeOut.waitFor(\"Timeout adding replica to shard\", () -> {\n      try {\n        CollectionAdminRequest.addReplicaToShard(collectionName, \"shard1\")\n            .process(cluster.getSolrClient());\n        return true;\n      } catch (Exception e) {\n        // expected, when the node is not fully started\n        return false;\n      }\n    });\n    waitForState(\"Expected 1x2 collections\", collectionName, clusterShape(1, 2));\n\n    shard1 = getCollectionState(collectionName).getSlice(\"shard1\");\n    Replica latestLeader = shard1.getLeader();\n    leaderJetty = getJettyForReplica(latestLeader);\n    String leaderJettyNodeName = leaderJetty.getNodeName();\n    leaderJetty.stop();\n    waitForNodeLeave(leaderJettyNodeName);\n\n    waitForState(\"Expected new active leader\", collectionName, (liveNodes, collectionState) -> {\n      Slice shard = collectionState.getSlice(\"shard1\");\n      Replica newLeader = shard.getLeader();\n      return newLeader != null && newLeader.getState() == Replica.State.ACTIVE && !newLeader.getName().equals(latestLeader.getName());\n    });\n\n    leaderJetty.start();\n\n    CollectionAdminRequest.deleteCollection(collectionName).process(cluster.getSolrClient());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0d38e0eaeb5a3c858d8d4892a6961883aabf161","date":1563030169,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#raceConditionOnDeleteAndRegisterReplica(String).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#raceConditionOnDeleteAndRegisterReplica(String).mjava","sourceNew":"  // commented out on: 17-Feb-2019   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // annotated on: 24-Dec-2018\n  public void raceConditionOnDeleteAndRegisterReplica(String legacyCloud) throws Exception {\n    \n    CollectionAdminRequest.setClusterProperty(ZkStateReader.LEGACY_CLOUD, legacyCloud).process(cluster.getSolrClient());\n    final String collectionName = \"raceDeleteReplica_\"+legacyCloud;\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 1, 2)\n        .process(cluster.getSolrClient());\n    \n    cluster.waitForActiveCollection(collectionName, 1, 2);\n    \n    waitForState(\"Expected 1x2 collections\", collectionName, clusterShape(1, 2));\n\n    Slice shard1 = getCollectionState(collectionName).getSlice(\"shard1\");\n    Replica leader = shard1.getLeader();\n    JettySolrRunner leaderJetty = getJettyForReplica(leader);\n    Replica replica1 = shard1.getReplicas(replica -> !replica.getName().equals(leader.getName())).get(0);\n    assertFalse(replica1.getName().equals(leader.getName()));\n\n    JettySolrRunner replica1Jetty = getJettyForReplica(replica1);\n\n    String replica1JettyNodeName = replica1Jetty.getNodeName();\n\n    Semaphore waitingForReplicaGetDeleted = new Semaphore(0);\n    // for safety, we only want this hook get triggered one time\n    AtomicInteger times = new AtomicInteger(0);\n    ZkContainer.testing_beforeRegisterInZk = cd -> {\n      if (cd.getCloudDescriptor() == null) return false;\n      if (replica1.getName().equals(cd.getCloudDescriptor().getCoreNodeName())\n          && collectionName.equals(cd.getCloudDescriptor().getCollectionName())) {\n        if (times.incrementAndGet() > 1) {\n          return false;\n        }\n        log.info(\"Running delete core {}\",cd);\n\n        try {\n          ZkNodeProps m = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.CORE_NAME_PROP, replica1.getCoreName(),\n              ZkStateReader.NODE_NAME_PROP, replica1.getNodeName(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.CORE_NODE_NAME_PROP, replica1.getName(),\n              ZkStateReader.BASE_URL_PROP, replica1.getBaseUrl());\n          cluster.getOpenOverseer().getStateUpdateQueue().offer(Utils.toJSON(m));\n\n          boolean replicaDeleted = false;\n          TimeOut timeOut = new TimeOut(20, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n          while (!timeOut.hasTimedOut()) {\n            try {\n              ZkStateReader stateReader = replica1Jetty.getCoreContainer().getZkController().getZkStateReader();\n              stateReader.forceUpdateCollection(collectionName);\n              Slice shard = stateReader.getClusterState().getCollection(collectionName).getSlice(\"shard1\");\n              if (shard.getReplicas().size() == 1) {\n                replicaDeleted = true;\n                waitingForReplicaGetDeleted.release();\n                break;\n              }\n              Thread.sleep(500);\n            } catch (NullPointerException | SolrException e) {\n              e.printStackTrace();\n              Thread.sleep(500);\n            }\n          }\n          if (!replicaDeleted) {\n            fail(\"Timeout for waiting replica get deleted\");\n          }\n        } catch (Exception e) {\n          e.printStackTrace();\n          fail(\"Failed to delete replica\");\n        } finally {\n          //avoiding deadlock\n          waitingForReplicaGetDeleted.release();\n        }\n        return true;\n      }\n      return false;\n    };\n\n    try {\n      replica1Jetty.stop();\n      waitForNodeLeave(replica1JettyNodeName);\n      waitForState(\"Expected replica:\"+replica1+\" get down\", collectionName, (liveNodes, collectionState)\n          -> collectionState.getSlice(\"shard1\").getReplica(replica1.getName()).getState() == DOWN);\n      replica1Jetty.start();\n      waitingForReplicaGetDeleted.acquire();\n    } finally {\n      ZkContainer.testing_beforeRegisterInZk = null;\n    }\n\n    TimeOut timeOut = new TimeOut(30, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    timeOut.waitFor(\"Timeout adding replica to shard\", () -> {\n      try {\n        CollectionAdminRequest.addReplicaToShard(collectionName, \"shard1\")\n            .process(cluster.getSolrClient());\n        return true;\n      } catch (Exception e) {\n        // expected, when the node is not fully started\n        return false;\n      }\n    });\n    waitForState(\"Expected 1x2 collections\", collectionName, clusterShape(1, 2));\n\n    shard1 = getCollectionState(collectionName).getSlice(\"shard1\");\n    Replica latestLeader = shard1.getLeader();\n    leaderJetty = getJettyForReplica(latestLeader);\n    String leaderJettyNodeName = leaderJetty.getNodeName();\n    leaderJetty.stop();\n    waitForNodeLeave(leaderJettyNodeName);\n\n    waitForState(\"Expected new active leader\", collectionName, (liveNodes, collectionState) -> {\n      Slice shard = collectionState.getSlice(\"shard1\");\n      Replica newLeader = shard.getLeader();\n      return newLeader != null && newLeader.getState() == Replica.State.ACTIVE && !newLeader.getName().equals(latestLeader.getName());\n    });\n\n    leaderJetty.start();\n    cluster.waitForActiveCollection(collectionName, 1, 2);\n\n    CollectionAdminRequest.deleteCollection(collectionName).process(cluster.getSolrClient());\n  }\n\n","sourceOld":"  // commented out on: 17-Feb-2019   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // annotated on: 24-Dec-2018\n  public void raceConditionOnDeleteAndRegisterReplica(String legacyCloud) throws Exception {\n    \n    CollectionAdminRequest.setClusterProperty(ZkStateReader.LEGACY_CLOUD, legacyCloud).process(cluster.getSolrClient());\n    final String collectionName = \"raceDeleteReplica_\"+legacyCloud;\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 1, 2)\n        .process(cluster.getSolrClient());\n    \n    cluster.waitForActiveCollection(collectionName, 1, 2);\n    \n    waitForState(\"Expected 1x2 collections\", collectionName, clusterShape(1, 2));\n\n    Slice shard1 = getCollectionState(collectionName).getSlice(\"shard1\");\n    Replica leader = shard1.getLeader();\n    JettySolrRunner leaderJetty = getJettyForReplica(leader);\n    Replica replica1 = shard1.getReplicas(replica -> !replica.getName().equals(leader.getName())).get(0);\n    assertFalse(replica1.getName().equals(leader.getName()));\n\n    JettySolrRunner replica1Jetty = getJettyForReplica(replica1);\n\n    String replica1JettyNodeName = replica1Jetty.getNodeName();\n\n    Semaphore waitingForReplicaGetDeleted = new Semaphore(0);\n    // for safety, we only want this hook get triggered one time\n    AtomicInteger times = new AtomicInteger(0);\n    ZkContainer.testing_beforeRegisterInZk = cd -> {\n      if (cd.getCloudDescriptor() == null) return false;\n      if (replica1.getName().equals(cd.getCloudDescriptor().getCoreNodeName())\n          && collectionName.equals(cd.getCloudDescriptor().getCollectionName())) {\n        if (times.incrementAndGet() > 1) {\n          return false;\n        }\n        log.info(\"Running delete core {}\",cd);\n\n        try {\n          ZkNodeProps m = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.CORE_NAME_PROP, replica1.getCoreName(),\n              ZkStateReader.NODE_NAME_PROP, replica1.getNodeName(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.CORE_NODE_NAME_PROP, replica1.getName(),\n              ZkStateReader.BASE_URL_PROP, replica1.getBaseUrl());\n          cluster.getOpenOverseer().getStateUpdateQueue().offer(Utils.toJSON(m));\n\n          boolean replicaDeleted = false;\n          TimeOut timeOut = new TimeOut(20, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n          while (!timeOut.hasTimedOut()) {\n            try {\n              ZkStateReader stateReader = replica1Jetty.getCoreContainer().getZkController().getZkStateReader();\n              stateReader.forceUpdateCollection(collectionName);\n              Slice shard = stateReader.getClusterState().getCollection(collectionName).getSlice(\"shard1\");\n              if (shard.getReplicas().size() == 1) {\n                replicaDeleted = true;\n                waitingForReplicaGetDeleted.release();\n                break;\n              }\n              Thread.sleep(500);\n            } catch (NullPointerException | SolrException e) {\n              e.printStackTrace();\n              Thread.sleep(500);\n            }\n          }\n          if (!replicaDeleted) {\n            fail(\"Timeout for waiting replica get deleted\");\n          }\n        } catch (Exception e) {\n          e.printStackTrace();\n          fail(\"Failed to delete replica\");\n        } finally {\n          //avoiding deadlock\n          waitingForReplicaGetDeleted.release();\n        }\n        return true;\n      }\n      return false;\n    };\n\n    try {\n      replica1Jetty.stop();\n      waitForNodeLeave(replica1JettyNodeName);\n      waitForState(\"Expected replica:\"+replica1+\" get down\", collectionName, (liveNodes, collectionState)\n          -> collectionState.getSlice(\"shard1\").getReplica(replica1.getName()).getState() == DOWN);\n      replica1Jetty.start();\n      waitingForReplicaGetDeleted.acquire();\n    } finally {\n      ZkContainer.testing_beforeRegisterInZk = null;\n    }\n\n    TimeOut timeOut = new TimeOut(30, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    timeOut.waitFor(\"Timeout adding replica to shard\", () -> {\n      try {\n        CollectionAdminRequest.addReplicaToShard(collectionName, \"shard1\")\n            .process(cluster.getSolrClient());\n        return true;\n      } catch (Exception e) {\n        // expected, when the node is not fully started\n        return false;\n      }\n    });\n    waitForState(\"Expected 1x2 collections\", collectionName, clusterShape(1, 2));\n\n    shard1 = getCollectionState(collectionName).getSlice(\"shard1\");\n    Replica latestLeader = shard1.getLeader();\n    leaderJetty = getJettyForReplica(latestLeader);\n    String leaderJettyNodeName = leaderJetty.getNodeName();\n    leaderJetty.stop();\n    waitForNodeLeave(leaderJettyNodeName);\n\n    waitForState(\"Expected new active leader\", collectionName, (liveNodes, collectionState) -> {\n      Slice shard = collectionState.getSlice(\"shard1\");\n      Replica newLeader = shard.getLeader();\n      return newLeader != null && newLeader.getState() == Replica.State.ACTIVE && !newLeader.getName().equals(latestLeader.getName());\n    });\n\n    leaderJetty.start();\n\n    CollectionAdminRequest.deleteCollection(collectionName).process(cluster.getSolrClient());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5ad9c35f926b4bf8da0336d1300efc709c8d5a56","date":1591729157,"type":4,"author":"murblanc","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest#raceConditionOnDeleteAndRegisterReplica(String).mjava","sourceNew":null,"sourceOld":"  // commented out on: 17-Feb-2019   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // annotated on: 24-Dec-2018\n  public void raceConditionOnDeleteAndRegisterReplica(String legacyCloud) throws Exception {\n    \n    CollectionAdminRequest.setClusterProperty(ZkStateReader.LEGACY_CLOUD, legacyCloud).process(cluster.getSolrClient());\n    final String collectionName = \"raceDeleteReplica_\"+legacyCloud;\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 1, 2)\n        .process(cluster.getSolrClient());\n    \n    cluster.waitForActiveCollection(collectionName, 1, 2);\n    \n    waitForState(\"Expected 1x2 collections\", collectionName, clusterShape(1, 2));\n\n    Slice shard1 = getCollectionState(collectionName).getSlice(\"shard1\");\n    Replica leader = shard1.getLeader();\n    JettySolrRunner leaderJetty = getJettyForReplica(leader);\n    Replica replica1 = shard1.getReplicas(replica -> !replica.getName().equals(leader.getName())).get(0);\n    assertFalse(replica1.getName().equals(leader.getName()));\n\n    JettySolrRunner replica1Jetty = getJettyForReplica(replica1);\n\n    String replica1JettyNodeName = replica1Jetty.getNodeName();\n\n    Semaphore waitingForReplicaGetDeleted = new Semaphore(0);\n    // for safety, we only want this hook get triggered one time\n    AtomicInteger times = new AtomicInteger(0);\n    ZkContainer.testing_beforeRegisterInZk = cd -> {\n      if (cd.getCloudDescriptor() == null) return false;\n      if (replica1.getName().equals(cd.getCloudDescriptor().getCoreNodeName())\n          && collectionName.equals(cd.getCloudDescriptor().getCollectionName())) {\n        if (times.incrementAndGet() > 1) {\n          return false;\n        }\n        log.info(\"Running delete core {}\",cd);\n\n        try {\n          ZkNodeProps m = new ZkNodeProps(\n              Overseer.QUEUE_OPERATION, OverseerAction.DELETECORE.toLower(),\n              ZkStateReader.CORE_NAME_PROP, replica1.getCoreName(),\n              ZkStateReader.NODE_NAME_PROP, replica1.getNodeName(),\n              ZkStateReader.COLLECTION_PROP, collectionName,\n              ZkStateReader.CORE_NODE_NAME_PROP, replica1.getName(),\n              ZkStateReader.BASE_URL_PROP, replica1.getBaseUrl());\n          cluster.getOpenOverseer().getStateUpdateQueue().offer(Utils.toJSON(m));\n\n          boolean replicaDeleted = false;\n          TimeOut timeOut = new TimeOut(20, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n          while (!timeOut.hasTimedOut()) {\n            try {\n              ZkStateReader stateReader = replica1Jetty.getCoreContainer().getZkController().getZkStateReader();\n              stateReader.forceUpdateCollection(collectionName);\n              Slice shard = stateReader.getClusterState().getCollection(collectionName).getSlice(\"shard1\");\n              if (shard.getReplicas().size() == 1) {\n                replicaDeleted = true;\n                waitingForReplicaGetDeleted.release();\n                break;\n              }\n              Thread.sleep(500);\n            } catch (NullPointerException | SolrException e) {\n              e.printStackTrace();\n              Thread.sleep(500);\n            }\n          }\n          if (!replicaDeleted) {\n            fail(\"Timeout for waiting replica get deleted\");\n          }\n        } catch (Exception e) {\n          e.printStackTrace();\n          fail(\"Failed to delete replica\");\n        } finally {\n          //avoiding deadlock\n          waitingForReplicaGetDeleted.release();\n        }\n        return true;\n      }\n      return false;\n    };\n\n    try {\n      replica1Jetty.stop();\n      waitForNodeLeave(replica1JettyNodeName);\n      waitForState(\"Expected replica:\"+replica1+\" get down\", collectionName, (liveNodes, collectionState)\n          -> collectionState.getSlice(\"shard1\").getReplica(replica1.getName()).getState() == DOWN);\n      replica1Jetty.start();\n      waitingForReplicaGetDeleted.acquire();\n    } finally {\n      ZkContainer.testing_beforeRegisterInZk = null;\n    }\n\n    TimeOut timeOut = new TimeOut(30, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    timeOut.waitFor(\"Timeout adding replica to shard\", () -> {\n      try {\n        CollectionAdminRequest.addReplicaToShard(collectionName, \"shard1\")\n            .process(cluster.getSolrClient());\n        return true;\n      } catch (Exception e) {\n        // expected, when the node is not fully started\n        return false;\n      }\n    });\n    waitForState(\"Expected 1x2 collections\", collectionName, clusterShape(1, 2));\n\n    shard1 = getCollectionState(collectionName).getSlice(\"shard1\");\n    Replica latestLeader = shard1.getLeader();\n    leaderJetty = getJettyForReplica(latestLeader);\n    String leaderJettyNodeName = leaderJetty.getNodeName();\n    leaderJetty.stop();\n    waitForNodeLeave(leaderJettyNodeName);\n\n    waitForState(\"Expected new active leader\", collectionName, (liveNodes, collectionState) -> {\n      Slice shard = collectionState.getSlice(\"shard1\");\n      Replica newLeader = shard.getLeader();\n      return newLeader != null && newLeader.getState() == Replica.State.ACTIVE && !newLeader.getName().equals(latestLeader.getName());\n    });\n\n    leaderJetty.start();\n    cluster.waitForActiveCollection(collectionName, 1, 2);\n\n    CollectionAdminRequest.deleteCollection(collectionName).process(cluster.getSolrClient());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5ad9c35f926b4bf8da0336d1300efc709c8d5a56":["d0d38e0eaeb5a3c858d8d4892a6961883aabf161"],"d0d38e0eaeb5a3c858d8d4892a6961883aabf161":["b5c929d2716fa79d443b93a82adb1da5b578ebd8"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"92f789dbd1886e4b468e61b0def88b29a3f55228":["ec9197593be550388d24a9ff242fbe19f90cce61"],"b5c929d2716fa79d443b93a82adb1da5b578ebd8":["8d35c84fdef07284c122012ca4000d3b7285a66e"],"ec9197593be550388d24a9ff242fbe19f90cce61":["28ba172425e443e0f08a49de6d73586c418d7251"],"28ba172425e443e0f08a49de6d73586c418d7251":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"8d35c84fdef07284c122012ca4000d3b7285a66e":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["92f789dbd1886e4b468e61b0def88b29a3f55228"]},"commit2Childs":{"5ad9c35f926b4bf8da0336d1300efc709c8d5a56":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d0d38e0eaeb5a3c858d8d4892a6961883aabf161":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["8d35c84fdef07284c122012ca4000d3b7285a66e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["28ba172425e443e0f08a49de6d73586c418d7251"],"92f789dbd1886e4b468e61b0def88b29a3f55228":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"b5c929d2716fa79d443b93a82adb1da5b578ebd8":["d0d38e0eaeb5a3c858d8d4892a6961883aabf161"],"ec9197593be550388d24a9ff242fbe19f90cce61":["92f789dbd1886e4b468e61b0def88b29a3f55228"],"28ba172425e443e0f08a49de6d73586c418d7251":["ec9197593be550388d24a9ff242fbe19f90cce61"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"8d35c84fdef07284c122012ca4000d3b7285a66e":["b5c929d2716fa79d443b93a82adb1da5b578ebd8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}