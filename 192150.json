{"path":"lucene/src/java/org/apache/lucene/search/FieldCacheRangeFilter.FieldCacheDocIdSet#iterator().mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/FieldCacheRangeFilter.FieldCacheDocIdSet#iterator().mjava","pathOld":"src/java/org/apache/lucene/search/FieldCacheRangeFilter.FieldCacheDocIdSet#iterator().mjava","sourceNew":"    @Override\n    public DocIdSetIterator iterator() throws IOException {\n      // Synchronization needed because deleted docs BitVector\n      // can change after call to hasDeletions until TermDocs creation.\n      // We only use an iterator with termDocs, when this was requested (e.g. range contains 0)\n      // and the index has deletions\n      final TermDocs termDocs;\n      synchronized(reader) {\n        termDocs = isCacheable() ? null : reader.termDocs(null);\n      }\n      if (termDocs != null) {\n        // a DocIdSetIterator using TermDocs to iterate valid docIds\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          \n          @Override\n          public int docID() {\n            return doc;\n          }\n          \n          @Override\n          public int nextDoc() throws IOException {\n            do {\n              if (!termDocs.next())\n                return doc = NO_MORE_DOCS;\n            } while (!matchDoc(doc = termDocs.doc()));\n            return doc;\n          }\n          \n          @Override\n          public int advance(int target) throws IOException {\n            if (!termDocs.skipTo(target))\n              return doc = NO_MORE_DOCS;\n            while (!matchDoc(doc = termDocs.doc())) { \n              if (!termDocs.next())\n                return doc = NO_MORE_DOCS;\n            }\n            return doc;\n          }\n        };\n      } else {\n        // a DocIdSetIterator generating docIds by incrementing a variable -\n        // this one can be used if there are no deletions are on the index\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          \n          @Override\n          public int docID() {\n            return doc;\n          }\n          \n          @Override\n          public int nextDoc() {\n            try {\n              do {\n                doc++;\n              } while (!matchDoc(doc));\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n          \n          @Override\n          public int advance(int target) {\n            try {\n              doc = target;\n              while (!matchDoc(doc)) { \n                doc++;\n              }\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n        };\n      }\n    }\n\n","sourceOld":"    @Override\n    public DocIdSetIterator iterator() throws IOException {\n      // Synchronization needed because deleted docs BitVector\n      // can change after call to hasDeletions until TermDocs creation.\n      // We only use an iterator with termDocs, when this was requested (e.g. range contains 0)\n      // and the index has deletions\n      final TermDocs termDocs;\n      synchronized(reader) {\n        termDocs = isCacheable() ? null : reader.termDocs(null);\n      }\n      if (termDocs != null) {\n        // a DocIdSetIterator using TermDocs to iterate valid docIds\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          \n          @Override\n          public int docID() {\n            return doc;\n          }\n          \n          @Override\n          public int nextDoc() throws IOException {\n            do {\n              if (!termDocs.next())\n                return doc = NO_MORE_DOCS;\n            } while (!matchDoc(doc = termDocs.doc()));\n            return doc;\n          }\n          \n          @Override\n          public int advance(int target) throws IOException {\n            if (!termDocs.skipTo(target))\n              return doc = NO_MORE_DOCS;\n            while (!matchDoc(doc = termDocs.doc())) { \n              if (!termDocs.next())\n                return doc = NO_MORE_DOCS;\n            }\n            return doc;\n          }\n        };\n      } else {\n        // a DocIdSetIterator generating docIds by incrementing a variable -\n        // this one can be used if there are no deletions are on the index\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          \n          @Override\n          public int docID() {\n            return doc;\n          }\n          \n          @Override\n          public int nextDoc() {\n            try {\n              do {\n                doc++;\n              } while (!matchDoc(doc));\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n          \n          @Override\n          public int advance(int target) {\n            try {\n              doc = target;\n              while (!matchDoc(doc)) { \n                doc++;\n              }\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n        };\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"955c32f886db6f6356c9fcdea6b1f1cb4effda24","date":1270581567,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/FieldCacheRangeFilter.FieldCacheDocIdSet#iterator().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FieldCacheRangeFilter.FieldCacheDocIdSet#iterator().mjava","sourceNew":"    @Override\n    public DocIdSetIterator iterator() throws IOException {\n      // Synchronization needed because deleted docs BitVector\n      // can change after call to hasDeletions until TermDocs creation.\n      // We only use an iterator with termDocs, when this was requested (e.g.\n      // range contains 0)\n      // and the index has deletions\n\n      final Bits skipDocs;\n      synchronized (reader) {\n        if (isCacheable()) {\n          skipDocs = null;\n        } else {\n          skipDocs = MultiFields.getDeletedDocs(reader);\n        }\n      }\n      final int maxDoc = reader.maxDoc();\n\n      // a DocIdSetIterator generating docIds by\n      // incrementing a variable & checking skipDocs -\n      return new DocIdSetIterator() {\n        private int doc = -1;\n        @Override\n        public int docID() {\n          return doc;\n        }\n        \n        @Override\n        public int nextDoc() {\n          try {\n            do {\n              doc++;\n            } while ((skipDocs != null && doc < maxDoc && skipDocs.get(doc))\n                || !matchDoc(doc));\n            return doc;\n          } catch (ArrayIndexOutOfBoundsException e) {\n            return doc = NO_MORE_DOCS;\n          }\n        }\n        \n        @Override\n        public int advance(int target) {\n          try {\n            doc = target;\n            while (!matchDoc(doc)) {\n              doc++;\n            }\n            return doc;\n          } catch (ArrayIndexOutOfBoundsException e) {\n            return doc = NO_MORE_DOCS;\n          }\n\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public DocIdSetIterator iterator() throws IOException {\n      // Synchronization needed because deleted docs BitVector\n      // can change after call to hasDeletions until TermDocs creation.\n      // We only use an iterator with termDocs, when this was requested (e.g. range contains 0)\n      // and the index has deletions\n      final TermDocs termDocs;\n      synchronized(reader) {\n        termDocs = isCacheable() ? null : reader.termDocs(null);\n      }\n      if (termDocs != null) {\n        // a DocIdSetIterator using TermDocs to iterate valid docIds\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          \n          @Override\n          public int docID() {\n            return doc;\n          }\n          \n          @Override\n          public int nextDoc() throws IOException {\n            do {\n              if (!termDocs.next())\n                return doc = NO_MORE_DOCS;\n            } while (!matchDoc(doc = termDocs.doc()));\n            return doc;\n          }\n          \n          @Override\n          public int advance(int target) throws IOException {\n            if (!termDocs.skipTo(target))\n              return doc = NO_MORE_DOCS;\n            while (!matchDoc(doc = termDocs.doc())) { \n              if (!termDocs.next())\n                return doc = NO_MORE_DOCS;\n            }\n            return doc;\n          }\n        };\n      } else {\n        // a DocIdSetIterator generating docIds by incrementing a variable -\n        // this one can be used if there are no deletions are on the index\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          \n          @Override\n          public int docID() {\n            return doc;\n          }\n          \n          @Override\n          public int nextDoc() {\n            try {\n              do {\n                doc++;\n              } while (!matchDoc(doc));\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n          \n          @Override\n          public int advance(int target) {\n            try {\n              doc = target;\n              while (!matchDoc(doc)) { \n                doc++;\n              }\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n        };\n      }\n    }\n\n","bugFix":null,"bugIntro":["b43b719dab44d1ccc5ee5b6e01c50f1ee86bb76c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b43b719dab44d1ccc5ee5b6e01c50f1ee86bb76c","date":1270671893,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/FieldCacheRangeFilter.FieldCacheDocIdSet#iterator().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FieldCacheRangeFilter.FieldCacheDocIdSet#iterator().mjava","sourceNew":"    @Override\n    public DocIdSetIterator iterator() throws IOException {\n\n      final Bits skipDocs = canIgnoreDeletedDocs ? null : MultiFields.getDeletedDocs(reader);\n\n      if (skipDocs == null) {\n        // Specialization optimization disregard deletions\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          @Override\n            public int docID() {\n            return doc;\n          }\n        \n          @Override\n          public int nextDoc() {\n            try {\n              do {\n                doc++;\n              } while (!matchDoc(doc));\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n        \n          @Override\n          public int advance(int target) {\n            try {\n              doc = target;\n              while (!matchDoc(doc)) {\n                doc++;\n              }\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n        };\n      } else {\n        // Must consult deletions\n\n        final int maxDoc = reader.maxDoc();\n\n        // a DocIdSetIterator generating docIds by\n        // incrementing a variable & checking skipDocs -\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          @Override\n            public int docID() {\n            return doc;\n          }\n        \n          @Override\n          public int nextDoc() {\n            do {\n              doc++;\n              if (doc >= maxDoc) {\n                return doc = NO_MORE_DOCS;\n              }\n            } while (skipDocs.get(doc) || !matchDoc(doc));\n            return doc;\n          }\n        \n          @Override\n          public int advance(int target) {\n            for(doc=target;doc<maxDoc;doc++) {\n              if (!skipDocs.get(doc) && matchDoc(doc)) {\n                return doc;\n              }\n            }\n            return doc = NO_MORE_DOCS;\n          }\n        };\n      }\n    }\n\n","sourceOld":"    @Override\n    public DocIdSetIterator iterator() throws IOException {\n      // Synchronization needed because deleted docs BitVector\n      // can change after call to hasDeletions until TermDocs creation.\n      // We only use an iterator with termDocs, when this was requested (e.g.\n      // range contains 0)\n      // and the index has deletions\n\n      final Bits skipDocs;\n      synchronized (reader) {\n        if (isCacheable()) {\n          skipDocs = null;\n        } else {\n          skipDocs = MultiFields.getDeletedDocs(reader);\n        }\n      }\n      final int maxDoc = reader.maxDoc();\n\n      // a DocIdSetIterator generating docIds by\n      // incrementing a variable & checking skipDocs -\n      return new DocIdSetIterator() {\n        private int doc = -1;\n        @Override\n        public int docID() {\n          return doc;\n        }\n        \n        @Override\n        public int nextDoc() {\n          try {\n            do {\n              doc++;\n            } while ((skipDocs != null && doc < maxDoc && skipDocs.get(doc))\n                || !matchDoc(doc));\n            return doc;\n          } catch (ArrayIndexOutOfBoundsException e) {\n            return doc = NO_MORE_DOCS;\n          }\n        }\n        \n        @Override\n        public int advance(int target) {\n          try {\n            doc = target;\n            while (!matchDoc(doc)) {\n              doc++;\n            }\n            return doc;\n          } catch (ArrayIndexOutOfBoundsException e) {\n            return doc = NO_MORE_DOCS;\n          }\n\n        }\n      };\n    }\n\n","bugFix":["955c32f886db6f6356c9fcdea6b1f1cb4effda24","4f7c8ed26cfbf4007c46fd27a417560e932ab4d8"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"df3efec034da1483899681baabb1df029e8628c4","date":1294243646,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/FieldCacheRangeFilter.FieldCacheDocIdSet#iterator().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FieldCacheRangeFilter.FieldCacheDocIdSet#iterator().mjava","sourceNew":"    @Override\n    public DocIdSetIterator iterator() throws IOException {\n\n      final Bits skipDocs = canIgnoreDeletedDocs ? null : reader.getDeletedDocs();\n\n      if (skipDocs == null) {\n        // Specialization optimization disregard deletions\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          @Override\n            public int docID() {\n            return doc;\n          }\n        \n          @Override\n          public int nextDoc() {\n            try {\n              do {\n                doc++;\n              } while (!matchDoc(doc));\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n        \n          @Override\n          public int advance(int target) {\n            try {\n              doc = target;\n              while (!matchDoc(doc)) {\n                doc++;\n              }\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n        };\n      } else {\n        // Must consult deletions\n\n        final int maxDoc = reader.maxDoc();\n\n        // a DocIdSetIterator generating docIds by\n        // incrementing a variable & checking skipDocs -\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          @Override\n            public int docID() {\n            return doc;\n          }\n        \n          @Override\n          public int nextDoc() {\n            do {\n              doc++;\n              if (doc >= maxDoc) {\n                return doc = NO_MORE_DOCS;\n              }\n            } while (skipDocs.get(doc) || !matchDoc(doc));\n            return doc;\n          }\n        \n          @Override\n          public int advance(int target) {\n            for(doc=target;doc<maxDoc;doc++) {\n              if (!skipDocs.get(doc) && matchDoc(doc)) {\n                return doc;\n              }\n            }\n            return doc = NO_MORE_DOCS;\n          }\n        };\n      }\n    }\n\n","sourceOld":"    @Override\n    public DocIdSetIterator iterator() throws IOException {\n\n      final Bits skipDocs = canIgnoreDeletedDocs ? null : MultiFields.getDeletedDocs(reader);\n\n      if (skipDocs == null) {\n        // Specialization optimization disregard deletions\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          @Override\n            public int docID() {\n            return doc;\n          }\n        \n          @Override\n          public int nextDoc() {\n            try {\n              do {\n                doc++;\n              } while (!matchDoc(doc));\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n        \n          @Override\n          public int advance(int target) {\n            try {\n              doc = target;\n              while (!matchDoc(doc)) {\n                doc++;\n              }\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n        };\n      } else {\n        // Must consult deletions\n\n        final int maxDoc = reader.maxDoc();\n\n        // a DocIdSetIterator generating docIds by\n        // incrementing a variable & checking skipDocs -\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          @Override\n            public int docID() {\n            return doc;\n          }\n        \n          @Override\n          public int nextDoc() {\n            do {\n              doc++;\n              if (doc >= maxDoc) {\n                return doc = NO_MORE_DOCS;\n              }\n            } while (skipDocs.get(doc) || !matchDoc(doc));\n            return doc;\n          }\n        \n          @Override\n          public int advance(int target) {\n            for(doc=target;doc<maxDoc;doc++) {\n              if (!skipDocs.get(doc) && matchDoc(doc)) {\n                return doc;\n              }\n            }\n            return doc = NO_MORE_DOCS;\n          }\n        };\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"70ad682703b8585f5d0a637efec044d57ec05efb","date":1294259117,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/FieldCacheRangeFilter.FieldCacheDocIdSet#iterator().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FieldCacheRangeFilter.FieldCacheDocIdSet#iterator().mjava","sourceNew":"    @Override\n    public DocIdSetIterator iterator() throws IOException {\n\n      final Bits skipDocs = canIgnoreDeletedDocs ? null : reader.getDeletedDocs();\n\n      if (skipDocs == null) {\n        // Specialization optimization disregard deletions\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          @Override\n            public int docID() {\n            return doc;\n          }\n        \n          @Override\n          public int nextDoc() {\n            try {\n              do {\n                doc++;\n              } while (!matchDoc(doc));\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n        \n          @Override\n          public int advance(int target) {\n            try {\n              doc = target;\n              while (!matchDoc(doc)) {\n                doc++;\n              }\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n        };\n      } else {\n        // Must consult deletions\n\n        final int maxDoc = reader.maxDoc();\n\n        // a DocIdSetIterator generating docIds by\n        // incrementing a variable & checking skipDocs -\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          @Override\n            public int docID() {\n            return doc;\n          }\n        \n          @Override\n          public int nextDoc() {\n            do {\n              doc++;\n              if (doc >= maxDoc) {\n                return doc = NO_MORE_DOCS;\n              }\n            } while (skipDocs.get(doc) || !matchDoc(doc));\n            return doc;\n          }\n        \n          @Override\n          public int advance(int target) {\n            for(doc=target;doc<maxDoc;doc++) {\n              if (!skipDocs.get(doc) && matchDoc(doc)) {\n                return doc;\n              }\n            }\n            return doc = NO_MORE_DOCS;\n          }\n        };\n      }\n    }\n\n","sourceOld":"    @Override\n    public DocIdSetIterator iterator() throws IOException {\n\n      final Bits skipDocs = canIgnoreDeletedDocs ? null : MultiFields.getDeletedDocs(reader);\n\n      if (skipDocs == null) {\n        // Specialization optimization disregard deletions\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          @Override\n            public int docID() {\n            return doc;\n          }\n        \n          @Override\n          public int nextDoc() {\n            try {\n              do {\n                doc++;\n              } while (!matchDoc(doc));\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n        \n          @Override\n          public int advance(int target) {\n            try {\n              doc = target;\n              while (!matchDoc(doc)) {\n                doc++;\n              }\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n        };\n      } else {\n        // Must consult deletions\n\n        final int maxDoc = reader.maxDoc();\n\n        // a DocIdSetIterator generating docIds by\n        // incrementing a variable & checking skipDocs -\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          @Override\n            public int docID() {\n            return doc;\n          }\n        \n          @Override\n          public int nextDoc() {\n            do {\n              doc++;\n              if (doc >= maxDoc) {\n                return doc = NO_MORE_DOCS;\n              }\n            } while (skipDocs.get(doc) || !matchDoc(doc));\n            return doc;\n          }\n        \n          @Override\n          public int advance(int target) {\n            for(doc=target;doc<maxDoc;doc++) {\n              if (!skipDocs.get(doc) && matchDoc(doc)) {\n                return doc;\n              }\n            }\n            return doc = NO_MORE_DOCS;\n          }\n        };\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"868da859b43505d9d2a023bfeae6dd0c795f5295","date":1294948401,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/FieldCacheRangeFilter.FieldCacheDocIdSet#iterator().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FieldCacheRangeFilter.FieldCacheDocIdSet#iterator().mjava","sourceNew":"    @Override\n    public DocIdSetIterator iterator() throws IOException {\n\n      final Bits skipDocs = canIgnoreDeletedDocs ? null : reader.getDeletedDocs();\n\n      if (skipDocs == null) {\n        // Specialization optimization disregard deletions\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          @Override\n            public int docID() {\n            return doc;\n          }\n        \n          @Override\n          public int nextDoc() {\n            try {\n              do {\n                doc++;\n              } while (!matchDoc(doc));\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n        \n          @Override\n          public int advance(int target) {\n            try {\n              doc = target;\n              while (!matchDoc(doc)) {\n                doc++;\n              }\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n        };\n      } else {\n        // Must consult deletions\n\n        final int maxDoc = reader.maxDoc();\n\n        // a DocIdSetIterator generating docIds by\n        // incrementing a variable & checking skipDocs -\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          @Override\n            public int docID() {\n            return doc;\n          }\n        \n          @Override\n          public int nextDoc() {\n            do {\n              doc++;\n              if (doc >= maxDoc) {\n                return doc = NO_MORE_DOCS;\n              }\n            } while (skipDocs.get(doc) || !matchDoc(doc));\n            return doc;\n          }\n        \n          @Override\n          public int advance(int target) {\n            for(doc=target;doc<maxDoc;doc++) {\n              if (!skipDocs.get(doc) && matchDoc(doc)) {\n                return doc;\n              }\n            }\n            return doc = NO_MORE_DOCS;\n          }\n        };\n      }\n    }\n\n","sourceOld":"    @Override\n    public DocIdSetIterator iterator() throws IOException {\n\n      final Bits skipDocs = canIgnoreDeletedDocs ? null : MultiFields.getDeletedDocs(reader);\n\n      if (skipDocs == null) {\n        // Specialization optimization disregard deletions\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          @Override\n            public int docID() {\n            return doc;\n          }\n        \n          @Override\n          public int nextDoc() {\n            try {\n              do {\n                doc++;\n              } while (!matchDoc(doc));\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n        \n          @Override\n          public int advance(int target) {\n            try {\n              doc = target;\n              while (!matchDoc(doc)) {\n                doc++;\n              }\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n        };\n      } else {\n        // Must consult deletions\n\n        final int maxDoc = reader.maxDoc();\n\n        // a DocIdSetIterator generating docIds by\n        // incrementing a variable & checking skipDocs -\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          @Override\n            public int docID() {\n            return doc;\n          }\n        \n          @Override\n          public int nextDoc() {\n            do {\n              doc++;\n              if (doc >= maxDoc) {\n                return doc = NO_MORE_DOCS;\n              }\n            } while (skipDocs.get(doc) || !matchDoc(doc));\n            return doc;\n          }\n        \n          @Override\n          public int advance(int target) {\n            for(doc=target;doc<maxDoc;doc++) {\n              if (!skipDocs.get(doc) && matchDoc(doc)) {\n                return doc;\n              }\n            }\n            return doc = NO_MORE_DOCS;\n          }\n        };\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e7bd246bb7bc35ac22edfee9157e034dfc4e65eb","date":1309960478,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/FieldCacheRangeFilter.FieldCacheDocIdSet#iterator().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FieldCacheRangeFilter.FieldCacheDocIdSet#iterator().mjava","sourceNew":"    @Override\n    public DocIdSetIterator iterator() throws IOException {\n\n      final Bits liveDocs = canIgnoreDeletedDocs ? null : reader.getLiveDocs();\n\n      if (liveDocs == null) {\n        // Specialization optimization disregard deletions\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          @Override\n            public int docID() {\n            return doc;\n          }\n        \n          @Override\n          public int nextDoc() {\n            try {\n              do {\n                doc++;\n              } while (!matchDoc(doc));\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n        \n          @Override\n          public int advance(int target) {\n            try {\n              doc = target;\n              while (!matchDoc(doc)) {\n                doc++;\n              }\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n        };\n      } else {\n        // Must consult deletions\n\n        final int maxDoc = reader.maxDoc();\n\n        // a DocIdSetIterator generating docIds by\n        // incrementing a variable & checking liveDocs -\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          @Override\n            public int docID() {\n            return doc;\n          }\n        \n          @Override\n          public int nextDoc() {\n            do {\n              doc++;\n              if (doc >= maxDoc) {\n                return doc = NO_MORE_DOCS;\n              }\n            } while (!liveDocs.get(doc) || !matchDoc(doc));\n            return doc;\n          }\n        \n          @Override\n          public int advance(int target) {\n            for(doc=target;doc<maxDoc;doc++) {\n              if (liveDocs.get(doc) && matchDoc(doc)) {\n                return doc;\n              }\n            }\n            return doc = NO_MORE_DOCS;\n          }\n        };\n      }\n    }\n\n","sourceOld":"    @Override\n    public DocIdSetIterator iterator() throws IOException {\n\n      final Bits skipDocs = canIgnoreDeletedDocs ? null : reader.getDeletedDocs();\n\n      if (skipDocs == null) {\n        // Specialization optimization disregard deletions\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          @Override\n            public int docID() {\n            return doc;\n          }\n        \n          @Override\n          public int nextDoc() {\n            try {\n              do {\n                doc++;\n              } while (!matchDoc(doc));\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n        \n          @Override\n          public int advance(int target) {\n            try {\n              doc = target;\n              while (!matchDoc(doc)) {\n                doc++;\n              }\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n        };\n      } else {\n        // Must consult deletions\n\n        final int maxDoc = reader.maxDoc();\n\n        // a DocIdSetIterator generating docIds by\n        // incrementing a variable & checking skipDocs -\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          @Override\n            public int docID() {\n            return doc;\n          }\n        \n          @Override\n          public int nextDoc() {\n            do {\n              doc++;\n              if (doc >= maxDoc) {\n                return doc = NO_MORE_DOCS;\n              }\n            } while (skipDocs.get(doc) || !matchDoc(doc));\n            return doc;\n          }\n        \n          @Override\n          public int advance(int target) {\n            for(doc=target;doc<maxDoc;doc++) {\n              if (!skipDocs.get(doc) && matchDoc(doc)) {\n                return doc;\n              }\n            }\n            return doc = NO_MORE_DOCS;\n          }\n        };\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"817d8435e9135b756f08ce6710ab0baac51bdf88","date":1309986993,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/FieldCacheRangeFilter.FieldCacheDocIdSet#iterator().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FieldCacheRangeFilter.FieldCacheDocIdSet#iterator().mjava","sourceNew":"    @Override\n    public DocIdSetIterator iterator() throws IOException {\n\n      final Bits liveDocs = canIgnoreDeletedDocs ? null : reader.getLiveDocs();\n\n      if (liveDocs == null) {\n        // Specialization optimization disregard deletions\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          @Override\n            public int docID() {\n            return doc;\n          }\n        \n          @Override\n          public int nextDoc() {\n            try {\n              do {\n                doc++;\n              } while (!matchDoc(doc));\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n        \n          @Override\n          public int advance(int target) {\n            try {\n              doc = target;\n              while (!matchDoc(doc)) {\n                doc++;\n              }\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n        };\n      } else {\n        // Must consult deletions\n\n        final int maxDoc = reader.maxDoc();\n\n        // a DocIdSetIterator generating docIds by\n        // incrementing a variable & checking liveDocs -\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          @Override\n            public int docID() {\n            return doc;\n          }\n        \n          @Override\n          public int nextDoc() {\n            do {\n              doc++;\n              if (doc >= maxDoc) {\n                return doc = NO_MORE_DOCS;\n              }\n            } while (!liveDocs.get(doc) || !matchDoc(doc));\n            return doc;\n          }\n        \n          @Override\n          public int advance(int target) {\n            for(doc=target;doc<maxDoc;doc++) {\n              if (liveDocs.get(doc) && matchDoc(doc)) {\n                return doc;\n              }\n            }\n            return doc = NO_MORE_DOCS;\n          }\n        };\n      }\n    }\n\n","sourceOld":"    @Override\n    public DocIdSetIterator iterator() throws IOException {\n\n      final Bits skipDocs = canIgnoreDeletedDocs ? null : reader.getDeletedDocs();\n\n      if (skipDocs == null) {\n        // Specialization optimization disregard deletions\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          @Override\n            public int docID() {\n            return doc;\n          }\n        \n          @Override\n          public int nextDoc() {\n            try {\n              do {\n                doc++;\n              } while (!matchDoc(doc));\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n        \n          @Override\n          public int advance(int target) {\n            try {\n              doc = target;\n              while (!matchDoc(doc)) {\n                doc++;\n              }\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n        };\n      } else {\n        // Must consult deletions\n\n        final int maxDoc = reader.maxDoc();\n\n        // a DocIdSetIterator generating docIds by\n        // incrementing a variable & checking skipDocs -\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          @Override\n            public int docID() {\n            return doc;\n          }\n        \n          @Override\n          public int nextDoc() {\n            do {\n              doc++;\n              if (doc >= maxDoc) {\n                return doc = NO_MORE_DOCS;\n              }\n            } while (skipDocs.get(doc) || !matchDoc(doc));\n            return doc;\n          }\n        \n          @Override\n          public int advance(int target) {\n            for(doc=target;doc<maxDoc;doc++) {\n              if (!skipDocs.get(doc) && matchDoc(doc)) {\n                return doc;\n              }\n            }\n            return doc = NO_MORE_DOCS;\n          }\n        };\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d083e83f225b11e5fdd900e83d26ddb385b6955c","date":1310029438,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/FieldCacheRangeFilter.FieldCacheDocIdSet#iterator().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FieldCacheRangeFilter.FieldCacheDocIdSet#iterator().mjava","sourceNew":"    @Override\n    public DocIdSetIterator iterator() throws IOException {\n\n      final Bits liveDocs = canIgnoreDeletedDocs ? null : reader.getLiveDocs();\n\n      if (liveDocs == null) {\n        // Specialization optimization disregard deletions\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          @Override\n            public int docID() {\n            return doc;\n          }\n        \n          @Override\n          public int nextDoc() {\n            try {\n              do {\n                doc++;\n              } while (!matchDoc(doc));\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n        \n          @Override\n          public int advance(int target) {\n            try {\n              doc = target;\n              while (!matchDoc(doc)) {\n                doc++;\n              }\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n        };\n      } else {\n        // Must consult deletions\n\n        final int maxDoc = reader.maxDoc();\n\n        // a DocIdSetIterator generating docIds by\n        // incrementing a variable & checking liveDocs -\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          @Override\n            public int docID() {\n            return doc;\n          }\n        \n          @Override\n          public int nextDoc() {\n            do {\n              doc++;\n              if (doc >= maxDoc) {\n                return doc = NO_MORE_DOCS;\n              }\n            } while (!liveDocs.get(doc) || !matchDoc(doc));\n            return doc;\n          }\n        \n          @Override\n          public int advance(int target) {\n            for(doc=target;doc<maxDoc;doc++) {\n              if (liveDocs.get(doc) && matchDoc(doc)) {\n                return doc;\n              }\n            }\n            return doc = NO_MORE_DOCS;\n          }\n        };\n      }\n    }\n\n","sourceOld":"    @Override\n    public DocIdSetIterator iterator() throws IOException {\n\n      final Bits skipDocs = canIgnoreDeletedDocs ? null : reader.getDeletedDocs();\n\n      if (skipDocs == null) {\n        // Specialization optimization disregard deletions\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          @Override\n            public int docID() {\n            return doc;\n          }\n        \n          @Override\n          public int nextDoc() {\n            try {\n              do {\n                doc++;\n              } while (!matchDoc(doc));\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n        \n          @Override\n          public int advance(int target) {\n            try {\n              doc = target;\n              while (!matchDoc(doc)) {\n                doc++;\n              }\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n        };\n      } else {\n        // Must consult deletions\n\n        final int maxDoc = reader.maxDoc();\n\n        // a DocIdSetIterator generating docIds by\n        // incrementing a variable & checking skipDocs -\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          @Override\n            public int docID() {\n            return doc;\n          }\n        \n          @Override\n          public int nextDoc() {\n            do {\n              doc++;\n              if (doc >= maxDoc) {\n                return doc = NO_MORE_DOCS;\n              }\n            } while (skipDocs.get(doc) || !matchDoc(doc));\n            return doc;\n          }\n        \n          @Override\n          public int advance(int target) {\n            for(doc=target;doc<maxDoc;doc++) {\n              if (!skipDocs.get(doc) && matchDoc(doc)) {\n                return doc;\n              }\n            }\n            return doc = NO_MORE_DOCS;\n          }\n        };\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6620df8541b174097b1133a4fc370adb2e570524","date":1319544675,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/FieldCacheRangeFilter.FieldCacheDocIdSet#iterator().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FieldCacheRangeFilter.FieldCacheDocIdSet#iterator().mjava","sourceNew":"    @Override\n    public DocIdSetIterator iterator() throws IOException {\n      if (acceptDocs == null) {\n        // Specialization optimization disregard deletions\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          @Override\n            public int docID() {\n            return doc;\n          }\n        \n          @Override\n          public int nextDoc() {\n            try {\n              do {\n                doc++;\n              } while (!matchDoc(doc));\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n        \n          @Override\n          public int advance(int target) {\n            try {\n              doc = target;\n              while (!matchDoc(doc)) {\n                doc++;\n              }\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n        };\n      } else {\n        // Must consult acceptDocs\n\n        // a DocIdSetIterator generating docIds by\n        // incrementing a variable & checking acceptDocs -\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          @Override\n            public int docID() {\n            return doc;\n          }\n        \n          @Override\n          public int nextDoc() {\n            do {\n              doc++;\n              if (doc >= maxDoc) {\n                return doc = NO_MORE_DOCS;\n              }\n            } while (!acceptDocs.get(doc) || !matchDoc(doc));\n            return doc;\n          }\n        \n          @Override\n          public int advance(int target) {\n            for(doc=target;doc<maxDoc;doc++) {\n              if (acceptDocs.get(doc) && matchDoc(doc)) {\n                return doc;\n              }\n            }\n            return doc = NO_MORE_DOCS;\n          }\n        };\n      }\n    }\n\n","sourceOld":"    @Override\n    public DocIdSetIterator iterator() throws IOException {\n\n      final Bits liveDocs = canIgnoreDeletedDocs ? null : reader.getLiveDocs();\n\n      if (liveDocs == null) {\n        // Specialization optimization disregard deletions\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          @Override\n            public int docID() {\n            return doc;\n          }\n        \n          @Override\n          public int nextDoc() {\n            try {\n              do {\n                doc++;\n              } while (!matchDoc(doc));\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n        \n          @Override\n          public int advance(int target) {\n            try {\n              doc = target;\n              while (!matchDoc(doc)) {\n                doc++;\n              }\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n        };\n      } else {\n        // Must consult deletions\n\n        final int maxDoc = reader.maxDoc();\n\n        // a DocIdSetIterator generating docIds by\n        // incrementing a variable & checking liveDocs -\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          @Override\n            public int docID() {\n            return doc;\n          }\n        \n          @Override\n          public int nextDoc() {\n            do {\n              doc++;\n              if (doc >= maxDoc) {\n                return doc = NO_MORE_DOCS;\n              }\n            } while (!liveDocs.get(doc) || !matchDoc(doc));\n            return doc;\n          }\n        \n          @Override\n          public int advance(int target) {\n            for(doc=target;doc<maxDoc;doc++) {\n              if (liveDocs.get(doc) && matchDoc(doc)) {\n                return doc;\n              }\n            }\n            return doc = NO_MORE_DOCS;\n          }\n        };\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d55536a3153c541924af58559781c36228d25420","date":1322184113,"type":4,"author":"Uwe Schindler","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/search/FieldCacheRangeFilter.FieldCacheDocIdSet#iterator().mjava","sourceNew":null,"sourceOld":"    @Override\n    public DocIdSetIterator iterator() throws IOException {\n      if (acceptDocs == null) {\n        // Specialization optimization disregard deletions\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          @Override\n            public int docID() {\n            return doc;\n          }\n        \n          @Override\n          public int nextDoc() {\n            try {\n              do {\n                doc++;\n              } while (!matchDoc(doc));\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n        \n          @Override\n          public int advance(int target) {\n            try {\n              doc = target;\n              while (!matchDoc(doc)) {\n                doc++;\n              }\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n        };\n      } else {\n        // Must consult acceptDocs\n\n        // a DocIdSetIterator generating docIds by\n        // incrementing a variable & checking acceptDocs -\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          @Override\n            public int docID() {\n            return doc;\n          }\n        \n          @Override\n          public int nextDoc() {\n            do {\n              doc++;\n              if (doc >= maxDoc) {\n                return doc = NO_MORE_DOCS;\n              }\n            } while (!acceptDocs.get(doc) || !matchDoc(doc));\n            return doc;\n          }\n        \n          @Override\n          public int advance(int target) {\n            for(doc=target;doc<maxDoc;doc++) {\n              if (acceptDocs.get(doc) && matchDoc(doc)) {\n                return doc;\n              }\n            }\n            return doc = NO_MORE_DOCS;\n          }\n        };\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"70ad682703b8585f5d0a637efec044d57ec05efb":["b43b719dab44d1ccc5ee5b6e01c50f1ee86bb76c","df3efec034da1483899681baabb1df029e8628c4"],"b43b719dab44d1ccc5ee5b6e01c50f1ee86bb76c":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"6620df8541b174097b1133a4fc370adb2e570524":["e7bd246bb7bc35ac22edfee9157e034dfc4e65eb"],"e7bd246bb7bc35ac22edfee9157e034dfc4e65eb":["df3efec034da1483899681baabb1df029e8628c4"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"d55536a3153c541924af58559781c36228d25420":["6620df8541b174097b1133a4fc370adb2e570524"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["df3efec034da1483899681baabb1df029e8628c4","e7bd246bb7bc35ac22edfee9157e034dfc4e65eb"],"817d8435e9135b756f08ce6710ab0baac51bdf88":["df3efec034da1483899681baabb1df029e8628c4","e7bd246bb7bc35ac22edfee9157e034dfc4e65eb"],"df3efec034da1483899681baabb1df029e8628c4":["b43b719dab44d1ccc5ee5b6e01c50f1ee86bb76c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"868da859b43505d9d2a023bfeae6dd0c795f5295":["b43b719dab44d1ccc5ee5b6e01c50f1ee86bb76c","df3efec034da1483899681baabb1df029e8628c4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d55536a3153c541924af58559781c36228d25420"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"70ad682703b8585f5d0a637efec044d57ec05efb":[],"b43b719dab44d1ccc5ee5b6e01c50f1ee86bb76c":["70ad682703b8585f5d0a637efec044d57ec05efb","df3efec034da1483899681baabb1df029e8628c4","868da859b43505d9d2a023bfeae6dd0c795f5295"],"6620df8541b174097b1133a4fc370adb2e570524":["d55536a3153c541924af58559781c36228d25420"],"e7bd246bb7bc35ac22edfee9157e034dfc4e65eb":["6620df8541b174097b1133a4fc370adb2e570524","d083e83f225b11e5fdd900e83d26ddb385b6955c","817d8435e9135b756f08ce6710ab0baac51bdf88"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["b43b719dab44d1ccc5ee5b6e01c50f1ee86bb76c"],"d55536a3153c541924af58559781c36228d25420":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":[],"817d8435e9135b756f08ce6710ab0baac51bdf88":[],"df3efec034da1483899681baabb1df029e8628c4":["70ad682703b8585f5d0a637efec044d57ec05efb","e7bd246bb7bc35ac22edfee9157e034dfc4e65eb","d083e83f225b11e5fdd900e83d26ddb385b6955c","817d8435e9135b756f08ce6710ab0baac51bdf88","868da859b43505d9d2a023bfeae6dd0c795f5295"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"868da859b43505d9d2a023bfeae6dd0c795f5295":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["70ad682703b8585f5d0a637efec044d57ec05efb","d083e83f225b11e5fdd900e83d26ddb385b6955c","817d8435e9135b756f08ce6710ab0baac51bdf88","868da859b43505d9d2a023bfeae6dd0c795f5295","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}