{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoConcavePolygon#done(boolean).mjava","commits":[{"id":"40aa98241c87d86a0077beb8023713d93a0becfe","date":1459784560,"type":0,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoConcavePolygon#done(boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Finish the polygon, by connecting the last added point with the starting point.\n   *@param isInternalReturnEdge is true if the return edge (back to start) is an internal one.\n   */\n  public void done(final boolean isInternalReturnEdge) {\n    if (isDone)\n      throw new IllegalStateException(\"Can't call done() more than once\");\n    // If fewer than 3 points, can't do it.\n    if (points.size() < 3)\n      throw new IllegalArgumentException(\"Polygon needs at least three points.\");\n\n    if (isInternalReturnEdge)\n      isInternalEdges.set(points.size() - 1);\n\n    isDone = true;\n    \n    // Time to construct the planes.  If the polygon is truly concave then any adjacent point\n    // to a segment can provide an exterior measurement.  Note: We build the true planes\n    // here and use the logic to return what *isn't* inside all of them.\n    edges = new SidedPlane[points.size()];\n    invertedEdges = new SidedPlane[points.size()];\n    notableEdgePoints = new GeoPoint[points.size()][];\n\n    for (int i = 0; i < points.size(); i++) {\n      final GeoPoint start = points.get(i);\n      final GeoPoint end = points.get(legalIndex(i + 1));\n      final double distance = start.arcDistance(end);\n      if (distance > fullDistance)\n        fullDistance = distance;\n      final GeoPoint check = points.get(legalIndex(i + 2));\n      // Here note the flip of the sense of the sided plane!!\n      final SidedPlane sp = new SidedPlane(check, false, start, end);\n      //System.out.println(\"Created edge \"+sp+\" using start=\"+start+\" end=\"+end+\" check=\"+check);\n      edges[i] = sp;\n      invertedEdges[i] = new SidedPlane(sp);\n      notableEdgePoints[i] = new GeoPoint[]{start, end};\n    }\n    // In order to naively confirm that the polygon is concave, I would need to\n    // check every edge, and verify that every point (other than the edge endpoints)\n    // is within the edge's sided plane.  This is an order n^2 operation.  That's still\n    // not wrong, though, because everything else about polygons has a similar cost.\n    for (int edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {\n      final SidedPlane edge = edges[edgeIndex];\n      for (int pointIndex = 0; pointIndex < points.size(); pointIndex++) {\n        if (pointIndex != edgeIndex && pointIndex != legalIndex(edgeIndex + 1)) {\n          if (edge.isWithin(points.get(pointIndex)))\n            throw new IllegalArgumentException(\"Polygon is not concave: Point \" + points.get(pointIndex) + \" Edge \" + edge);\n        }\n      }\n    }\n    \n    // For each edge, create a bounds object.\n    eitherBounds = new HashMap<>(edges.length);\n    for (int edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {\n      eitherBounds.put(edges[edgeIndex], new EitherBound(invertedEdges[edgeIndex]));\n    }\n\n    // Pick an edge point arbitrarily\n    edgePoints = new GeoPoint[]{points.get(0)};\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["dc584fa95053c03d95035277a2d2aaddd537c0fa","b325b9a50d0c88c91837edc3cf8e11a5216e897a","ba81c43c13d92ea74a6388471cf358eb7068744d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"09af2c9610ce53a4b25fd99344299b40318a4a1a","date":1459876565,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoConcavePolygon#done(boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Finish the polygon, by connecting the last added point with the starting point.\n   *@param isInternalReturnEdge is true if the return edge (back to start) is an internal one.\n   */\n  public void done(final boolean isInternalReturnEdge) {\n    if (isDone)\n      throw new IllegalStateException(\"Can't call done() more than once\");\n    // If fewer than 3 points, can't do it.\n    if (points.size() < 3)\n      throw new IllegalArgumentException(\"Polygon needs at least three points.\");\n\n    if (isInternalReturnEdge)\n      isInternalEdges.set(points.size() - 1);\n\n    isDone = true;\n    \n    // Time to construct the planes.  If the polygon is truly concave then any adjacent point\n    // to a segment can provide an exterior measurement.  Note: We build the true planes\n    // here and use the logic to return what *isn't* inside all of them.\n    edges = new SidedPlane[points.size()];\n    invertedEdges = new SidedPlane[points.size()];\n    notableEdgePoints = new GeoPoint[points.size()][];\n\n    for (int i = 0; i < points.size(); i++) {\n      final GeoPoint start = points.get(i);\n      final GeoPoint end = points.get(legalIndex(i + 1));\n      final double distance = start.arcDistance(end);\n      if (distance > fullDistance)\n        fullDistance = distance;\n      final GeoPoint check = points.get(legalIndex(i + 2));\n      // Here note the flip of the sense of the sided plane!!\n      final SidedPlane sp = new SidedPlane(check, false, start, end);\n      //System.out.println(\"Created edge \"+sp+\" using start=\"+start+\" end=\"+end+\" check=\"+check);\n      edges[i] = sp;\n      invertedEdges[i] = new SidedPlane(sp);\n      notableEdgePoints[i] = new GeoPoint[]{start, end};\n    }\n    // In order to naively confirm that the polygon is concave, I would need to\n    // check every edge, and verify that every point (other than the edge endpoints)\n    // is within the edge's sided plane.  This is an order n^2 operation.  That's still\n    // not wrong, though, because everything else about polygons has a similar cost.\n    for (int edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {\n      final SidedPlane edge = edges[edgeIndex];\n      for (int pointIndex = 0; pointIndex < points.size(); pointIndex++) {\n        if (pointIndex != edgeIndex && pointIndex != legalIndex(edgeIndex + 1)) {\n          if (edge.isWithin(points.get(pointIndex)))\n            throw new IllegalArgumentException(\"Polygon is not concave: Point \" + points.get(pointIndex) + \" Edge \" + edge);\n        }\n      }\n    }\n    \n    // For each edge, create a bounds object.\n    eitherBounds = new HashMap<>(edges.length);\n    for (int edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {\n      eitherBounds.put(edges[edgeIndex], new EitherBound(invertedEdges[edgeIndex]));\n    }\n\n    // Pick an edge point arbitrarily\n    edgePoints = new GeoPoint[]{points.get(0)};\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"835b6983e267a46cbc7d3d7d82b46b2eb9a32d1e","date":1460121287,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoConcavePolygon#done(boolean).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoConcavePolygon#done(boolean).mjava","sourceNew":"  /**\n   * Finish the polygon, by connecting the last added point with the starting point.\n   *@param isInternalReturnEdge is true if the return edge (back to start) is an internal one.\n   */\n  public void done(final boolean isInternalReturnEdge) {\n    if (isDone)\n      throw new IllegalStateException(\"Can't call done() more than once\");\n    // If fewer than 3 points, can't do it.\n    if (points.size() < 3)\n      throw new IllegalArgumentException(\"Polygon needs at least three points.\");\n\n    if (isInternalReturnEdge)\n      isInternalEdges.set(points.size() - 1);\n\n    isDone = true;\n    \n    // Time to construct the planes.  If the polygon is truly concave then any adjacent point\n    // to a segment can provide an exterior measurement.  Note: We build the true planes\n    // here and use the logic to return what *isn't* inside all of them.\n    edges = new SidedPlane[points.size()];\n    invertedEdges = new SidedPlane[points.size()];\n    notableEdgePoints = new GeoPoint[points.size()][];\n\n    for (int i = 0; i < points.size(); i++) {\n      final GeoPoint start = points.get(i);\n      final GeoPoint end = points.get(legalIndex(i + 1));\n      // We have to find the next point that is not on the plane between start and end.\n      // If there is no such point, it's an error.\n      final Plane planeToFind = new Plane(start, end);\n      int endPointIndex = -1;\n      for (int j = 0; j < points.size(); j++) {\n        final int index = legalIndex(j + i + 2);\n        if (!planeToFind.evaluateIsZero(points.get(index))) {\n          endPointIndex = index;\n          break;\n        }\n      }\n      if (endPointIndex == -1) {\n        throw new IllegalArgumentException(\"Polygon points are all coplanar\");\n      }\n      final GeoPoint check = points.get(endPointIndex);\n      // Here note the flip of the sense of the sided plane!!\n      final SidedPlane sp = new SidedPlane(check, false, start, end);\n      //System.out.println(\"Created edge \"+sp+\" using start=\"+start+\" end=\"+end+\" check=\"+check);\n      edges[i] = sp;\n      invertedEdges[i] = new SidedPlane(sp);\n      notableEdgePoints[i] = new GeoPoint[]{start, end};\n    }\n    // In order to naively confirm that the polygon is concave, I would need to\n    // check every edge, and verify that every point (other than the edge endpoints)\n    // is within the edge's sided plane.  This is an order n^2 operation.  That's still\n    // not wrong, though, because everything else about polygons has a similar cost.\n    for (int edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {\n      final SidedPlane edge = edges[edgeIndex];\n      for (int pointIndex = 0; pointIndex < points.size(); pointIndex++) {\n        if (pointIndex != edgeIndex && pointIndex != legalIndex(edgeIndex + 1)) {\n          if (edge.isWithin(points.get(pointIndex)))\n            throw new IllegalArgumentException(\"Polygon is not concave: Point \" + points.get(pointIndex) + \" Edge \" + edge);\n        }\n      }\n    }\n    \n    // For each edge, create a bounds object.\n    eitherBounds = new HashMap<>(edges.length);\n    for (int edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {\n      eitherBounds.put(edges[edgeIndex], new EitherBound(invertedEdges[edgeIndex]));\n    }\n\n    // Pick an edge point arbitrarily\n    edgePoints = new GeoPoint[]{points.get(0)};\n  }\n\n","sourceOld":"  /**\n   * Finish the polygon, by connecting the last added point with the starting point.\n   *@param isInternalReturnEdge is true if the return edge (back to start) is an internal one.\n   */\n  public void done(final boolean isInternalReturnEdge) {\n    if (isDone)\n      throw new IllegalStateException(\"Can't call done() more than once\");\n    // If fewer than 3 points, can't do it.\n    if (points.size() < 3)\n      throw new IllegalArgumentException(\"Polygon needs at least three points.\");\n\n    if (isInternalReturnEdge)\n      isInternalEdges.set(points.size() - 1);\n\n    isDone = true;\n    \n    // Time to construct the planes.  If the polygon is truly concave then any adjacent point\n    // to a segment can provide an exterior measurement.  Note: We build the true planes\n    // here and use the logic to return what *isn't* inside all of them.\n    edges = new SidedPlane[points.size()];\n    invertedEdges = new SidedPlane[points.size()];\n    notableEdgePoints = new GeoPoint[points.size()][];\n\n    for (int i = 0; i < points.size(); i++) {\n      final GeoPoint start = points.get(i);\n      final GeoPoint end = points.get(legalIndex(i + 1));\n      final double distance = start.arcDistance(end);\n      if (distance > fullDistance)\n        fullDistance = distance;\n      final GeoPoint check = points.get(legalIndex(i + 2));\n      // Here note the flip of the sense of the sided plane!!\n      final SidedPlane sp = new SidedPlane(check, false, start, end);\n      //System.out.println(\"Created edge \"+sp+\" using start=\"+start+\" end=\"+end+\" check=\"+check);\n      edges[i] = sp;\n      invertedEdges[i] = new SidedPlane(sp);\n      notableEdgePoints[i] = new GeoPoint[]{start, end};\n    }\n    // In order to naively confirm that the polygon is concave, I would need to\n    // check every edge, and verify that every point (other than the edge endpoints)\n    // is within the edge's sided plane.  This is an order n^2 operation.  That's still\n    // not wrong, though, because everything else about polygons has a similar cost.\n    for (int edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {\n      final SidedPlane edge = edges[edgeIndex];\n      for (int pointIndex = 0; pointIndex < points.size(); pointIndex++) {\n        if (pointIndex != edgeIndex && pointIndex != legalIndex(edgeIndex + 1)) {\n          if (edge.isWithin(points.get(pointIndex)))\n            throw new IllegalArgumentException(\"Polygon is not concave: Point \" + points.get(pointIndex) + \" Edge \" + edge);\n        }\n      }\n    }\n    \n    // For each edge, create a bounds object.\n    eitherBounds = new HashMap<>(edges.length);\n    for (int edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {\n      eitherBounds.put(edges[edgeIndex], new EitherBound(invertedEdges[edgeIndex]));\n    }\n\n    // Pick an edge point arbitrarily\n    edgePoints = new GeoPoint[]{points.get(0)};\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"dc584fa95053c03d95035277a2d2aaddd537c0fa","date":1460232759,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoConcavePolygon#done(boolean).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoConcavePolygon#done(boolean).mjava","sourceNew":"  /**\n   * Finish the polygon, by connecting the last added point with the starting point.\n   *@param isInternalReturnEdge is true if the return edge (back to start) is an internal one.\n   */\n  public void done(final boolean isInternalReturnEdge) {\n    if (isDone)\n      throw new IllegalStateException(\"Can't call done() more than once\");\n    // If fewer than 3 points, can't do it.\n    if (points.size() < 3)\n      throw new IllegalArgumentException(\"Polygon needs at least three points.\");\n\n    if (isInternalReturnEdge)\n      isInternalEdges.set(points.size() - 1);\n\n    isDone = true;\n    \n    // Time to construct the planes.  If the polygon is truly concave then any adjacent point\n    // to a segment can provide an exterior measurement.  Note: We build the true planes\n    // here and use the logic to return what *isn't* inside all of them.\n    edges = new SidedPlane[points.size()];\n    invertedEdges = new SidedPlane[points.size()];\n    notableEdgePoints = new GeoPoint[points.size()][];\n\n    for (int i = 0; i < points.size(); i++) {\n      final GeoPoint start = points.get(i);\n      final GeoPoint end = points.get(legalIndex(i + 1));\n      // We have to find the next point that is not on the plane between start and end.\n      // If there is no such point, it's an error.\n      final Plane planeToFind = new Plane(start, end);\n      int endPointIndex = -1;\n      for (int j = 0; j < points.size(); j++) {\n        final int index = legalIndex(j + i + 2);\n        if (!planeToFind.evaluateIsZero(points.get(index))) {\n          endPointIndex = index;\n          break;\n        }\n      }\n      if (endPointIndex == -1) {\n        throw new IllegalArgumentException(\"Polygon points are all coplanar\");\n      }\n      final GeoPoint check = points.get(endPointIndex);\n      //System.out.println(\"Created edge \"+sp+\" using start=\"+start+\" end=\"+end+\" check=\"+check);\n      edges[i] = new SidedPlane(check, false, start, end);\n      invertedEdges[i] = new SidedPlane(edges[i]);\n      notableEdgePoints[i] = new GeoPoint[]{start, end};\n    }\n    // In order to naively confirm that the polygon is concave, I would need to\n    // check every edge, and verify that every point (other than the edge endpoints)\n    // is within the edge's sided plane.  This is an order n^2 operation.  That's still\n    // not wrong, though, because everything else about polygons has a similar cost.\n    for (int edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {\n      final SidedPlane edge = edges[edgeIndex];\n      for (int pointIndex = 0; pointIndex < points.size(); pointIndex++) {\n        if (pointIndex != edgeIndex && pointIndex != legalIndex(edgeIndex + 1)) {\n          if (edge.isWithin(points.get(pointIndex)))\n            throw new IllegalArgumentException(\"Polygon is not concave: Point \" + points.get(pointIndex) + \" Edge \" + edge);\n        }\n      }\n    }\n    \n    // For each edge, create a bounds object.\n    eitherBounds = new HashMap<>(edges.length);\n    for (int edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {\n      eitherBounds.put(edges[edgeIndex], new EitherBound(invertedEdges[edgeIndex]));\n    }\n\n    // Pick an edge point arbitrarily\n    edgePoints = new GeoPoint[]{points.get(0)};\n  }\n\n","sourceOld":"  /**\n   * Finish the polygon, by connecting the last added point with the starting point.\n   *@param isInternalReturnEdge is true if the return edge (back to start) is an internal one.\n   */\n  public void done(final boolean isInternalReturnEdge) {\n    if (isDone)\n      throw new IllegalStateException(\"Can't call done() more than once\");\n    // If fewer than 3 points, can't do it.\n    if (points.size() < 3)\n      throw new IllegalArgumentException(\"Polygon needs at least three points.\");\n\n    if (isInternalReturnEdge)\n      isInternalEdges.set(points.size() - 1);\n\n    isDone = true;\n    \n    // Time to construct the planes.  If the polygon is truly concave then any adjacent point\n    // to a segment can provide an exterior measurement.  Note: We build the true planes\n    // here and use the logic to return what *isn't* inside all of them.\n    edges = new SidedPlane[points.size()];\n    invertedEdges = new SidedPlane[points.size()];\n    notableEdgePoints = new GeoPoint[points.size()][];\n\n    for (int i = 0; i < points.size(); i++) {\n      final GeoPoint start = points.get(i);\n      final GeoPoint end = points.get(legalIndex(i + 1));\n      // We have to find the next point that is not on the plane between start and end.\n      // If there is no such point, it's an error.\n      final Plane planeToFind = new Plane(start, end);\n      int endPointIndex = -1;\n      for (int j = 0; j < points.size(); j++) {\n        final int index = legalIndex(j + i + 2);\n        if (!planeToFind.evaluateIsZero(points.get(index))) {\n          endPointIndex = index;\n          break;\n        }\n      }\n      if (endPointIndex == -1) {\n        throw new IllegalArgumentException(\"Polygon points are all coplanar\");\n      }\n      final GeoPoint check = points.get(endPointIndex);\n      // Here note the flip of the sense of the sided plane!!\n      final SidedPlane sp = new SidedPlane(check, false, start, end);\n      //System.out.println(\"Created edge \"+sp+\" using start=\"+start+\" end=\"+end+\" check=\"+check);\n      edges[i] = sp;\n      invertedEdges[i] = new SidedPlane(sp);\n      notableEdgePoints[i] = new GeoPoint[]{start, end};\n    }\n    // In order to naively confirm that the polygon is concave, I would need to\n    // check every edge, and verify that every point (other than the edge endpoints)\n    // is within the edge's sided plane.  This is an order n^2 operation.  That's still\n    // not wrong, though, because everything else about polygons has a similar cost.\n    for (int edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {\n      final SidedPlane edge = edges[edgeIndex];\n      for (int pointIndex = 0; pointIndex < points.size(); pointIndex++) {\n        if (pointIndex != edgeIndex && pointIndex != legalIndex(edgeIndex + 1)) {\n          if (edge.isWithin(points.get(pointIndex)))\n            throw new IllegalArgumentException(\"Polygon is not concave: Point \" + points.get(pointIndex) + \" Edge \" + edge);\n        }\n      }\n    }\n    \n    // For each edge, create a bounds object.\n    eitherBounds = new HashMap<>(edges.length);\n    for (int edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {\n      eitherBounds.put(edges[edgeIndex], new EitherBound(invertedEdges[edgeIndex]));\n    }\n\n    // Pick an edge point arbitrarily\n    edgePoints = new GeoPoint[]{points.get(0)};\n  }\n\n","bugFix":["40aa98241c87d86a0077beb8023713d93a0becfe"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f73835ebb1e6bfb1a963660f1ff4e25aa7a0a49d","date":1460455384,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoConcavePolygon#done(boolean).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoConcavePolygon#done(boolean).mjava","sourceNew":"  /**\n   * Finish the polygon, by connecting the last added point with the starting point.\n   *@param isInternalReturnEdge is true if the return edge (back to start) is an internal one.\n   */\n  public void done(final boolean isInternalReturnEdge) {\n    if (isDone)\n      throw new IllegalStateException(\"Can't call done() more than once\");\n    // If fewer than 3 points, can't do it.\n    if (points.size() < 3)\n      throw new IllegalArgumentException(\"Polygon needs at least three points.\");\n\n    if (isInternalReturnEdge)\n      isInternalEdges.set(points.size() - 1);\n\n    isDone = true;\n    \n    // Time to construct the planes.  If the polygon is truly concave then any adjacent point\n    // to a segment can provide an exterior measurement.  Note: We build the true planes\n    // here and use the logic to return what *isn't* inside all of them.\n    edges = new SidedPlane[points.size()];\n    invertedEdges = new SidedPlane[points.size()];\n    notableEdgePoints = new GeoPoint[points.size()][];\n\n    for (int i = 0; i < points.size(); i++) {\n      final GeoPoint start = points.get(i);\n      final GeoPoint end = points.get(legalIndex(i + 1));\n      // We have to find the next point that is not on the plane between start and end.\n      // If there is no such point, it's an error.\n      final Plane planeToFind = new Plane(start, end);\n      int endPointIndex = -1;\n      for (int j = 0; j < points.size(); j++) {\n        final int index = legalIndex(j + i + 2);\n        if (!planeToFind.evaluateIsZero(points.get(index))) {\n          endPointIndex = index;\n          break;\n        }\n      }\n      if (endPointIndex == -1) {\n        throw new IllegalArgumentException(\"Polygon points are all coplanar\");\n      }\n      final GeoPoint check = points.get(endPointIndex);\n      //System.out.println(\"Created edge \"+sp+\" using start=\"+start+\" end=\"+end+\" check=\"+check);\n      edges[i] = new SidedPlane(check, false, start, end);\n      invertedEdges[i] = new SidedPlane(edges[i]);\n      notableEdgePoints[i] = new GeoPoint[]{start, end};\n    }\n    // In order to naively confirm that the polygon is concave, I would need to\n    // check every edge, and verify that every point (other than the edge endpoints)\n    // is within the edge's sided plane.  This is an order n^2 operation.  That's still\n    // not wrong, though, because everything else about polygons has a similar cost.\n    for (int edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {\n      final SidedPlane edge = edges[edgeIndex];\n      for (int pointIndex = 0; pointIndex < points.size(); pointIndex++) {\n        if (pointIndex != edgeIndex && pointIndex != legalIndex(edgeIndex + 1)) {\n          if (edge.isWithin(points.get(pointIndex)))\n            throw new IllegalArgumentException(\"Polygon is not concave: Point \" + points.get(pointIndex) + \" Edge \" + edge);\n        }\n      }\n    }\n    \n    // For each edge, create a bounds object.\n    eitherBounds = new HashMap<>(edges.length);\n    for (int edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {\n      final SidedPlane edge = edges[edgeIndex];\n      final SidedPlane invertedEdge = invertedEdges[edgeIndex];\n      int bound1Index = legalIndex(edgeIndex+1);\n      while (invertedEdges[legalIndex(bound1Index)].isNumericallyIdentical(invertedEdge)) {\n        bound1Index++;\n      }\n      int bound2Index = legalIndex(edgeIndex-1);\n      while (invertedEdges[legalIndex(bound2Index)].isNumericallyIdentical(invertedEdge)) {\n        bound2Index--;\n      }\n      eitherBounds.put(edge, new EitherBound(invertedEdges[legalIndex(bound1Index)], invertedEdges[legalIndex(bound2Index)]));\n    }\n\n    // Pick an edge point arbitrarily\n    edgePoints = new GeoPoint[]{points.get(0)};\n  }\n\n","sourceOld":"  /**\n   * Finish the polygon, by connecting the last added point with the starting point.\n   *@param isInternalReturnEdge is true if the return edge (back to start) is an internal one.\n   */\n  public void done(final boolean isInternalReturnEdge) {\n    if (isDone)\n      throw new IllegalStateException(\"Can't call done() more than once\");\n    // If fewer than 3 points, can't do it.\n    if (points.size() < 3)\n      throw new IllegalArgumentException(\"Polygon needs at least three points.\");\n\n    if (isInternalReturnEdge)\n      isInternalEdges.set(points.size() - 1);\n\n    isDone = true;\n    \n    // Time to construct the planes.  If the polygon is truly concave then any adjacent point\n    // to a segment can provide an exterior measurement.  Note: We build the true planes\n    // here and use the logic to return what *isn't* inside all of them.\n    edges = new SidedPlane[points.size()];\n    invertedEdges = new SidedPlane[points.size()];\n    notableEdgePoints = new GeoPoint[points.size()][];\n\n    for (int i = 0; i < points.size(); i++) {\n      final GeoPoint start = points.get(i);\n      final GeoPoint end = points.get(legalIndex(i + 1));\n      // We have to find the next point that is not on the plane between start and end.\n      // If there is no such point, it's an error.\n      final Plane planeToFind = new Plane(start, end);\n      int endPointIndex = -1;\n      for (int j = 0; j < points.size(); j++) {\n        final int index = legalIndex(j + i + 2);\n        if (!planeToFind.evaluateIsZero(points.get(index))) {\n          endPointIndex = index;\n          break;\n        }\n      }\n      if (endPointIndex == -1) {\n        throw new IllegalArgumentException(\"Polygon points are all coplanar\");\n      }\n      final GeoPoint check = points.get(endPointIndex);\n      //System.out.println(\"Created edge \"+sp+\" using start=\"+start+\" end=\"+end+\" check=\"+check);\n      edges[i] = new SidedPlane(check, false, start, end);\n      invertedEdges[i] = new SidedPlane(edges[i]);\n      notableEdgePoints[i] = new GeoPoint[]{start, end};\n    }\n    // In order to naively confirm that the polygon is concave, I would need to\n    // check every edge, and verify that every point (other than the edge endpoints)\n    // is within the edge's sided plane.  This is an order n^2 operation.  That's still\n    // not wrong, though, because everything else about polygons has a similar cost.\n    for (int edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {\n      final SidedPlane edge = edges[edgeIndex];\n      for (int pointIndex = 0; pointIndex < points.size(); pointIndex++) {\n        if (pointIndex != edgeIndex && pointIndex != legalIndex(edgeIndex + 1)) {\n          if (edge.isWithin(points.get(pointIndex)))\n            throw new IllegalArgumentException(\"Polygon is not concave: Point \" + points.get(pointIndex) + \" Edge \" + edge);\n        }\n      }\n    }\n    \n    // For each edge, create a bounds object.\n    eitherBounds = new HashMap<>(edges.length);\n    for (int edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {\n      eitherBounds.put(edges[edgeIndex], new EitherBound(invertedEdges[edgeIndex]));\n    }\n\n    // Pick an edge point arbitrarily\n    edgePoints = new GeoPoint[]{points.get(0)};\n  }\n\n","bugFix":null,"bugIntro":["54e10c9f59e9af43a3d623fc58c2d3790f0f5cfb"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9d2d72e1014f51e87658946e08272b7efd0d52e7","date":1460578543,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoConcavePolygon#done(boolean).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoConcavePolygon#done(boolean).mjava","sourceNew":"  /**\n   * Finish the polygon, by connecting the last added point with the starting point.\n   *@param isInternalReturnEdge is true if the return edge (back to start) is an internal one.\n   */\n  public void done(final boolean isInternalReturnEdge) {\n    if (isDone)\n      throw new IllegalStateException(\"Can't call done() more than once\");\n    // If fewer than 3 points, can't do it.\n    if (points.size() < 3)\n      throw new IllegalArgumentException(\"Polygon needs at least three points.\");\n\n    if (isInternalReturnEdge)\n      isInternalEdges.set(points.size() - 1);\n\n    isDone = true;\n    \n    // Time to construct the planes.  If the polygon is truly concave then any adjacent point\n    // to a segment can provide an exterior measurement.  Note: We build the true planes\n    // here and use the logic to return what *isn't* inside all of them.\n    edges = new SidedPlane[points.size()];\n    invertedEdges = new SidedPlane[points.size()];\n    notableEdgePoints = new GeoPoint[points.size()][];\n\n    for (int i = 0; i < points.size(); i++) {\n      final GeoPoint start = points.get(i);\n      final GeoPoint end = points.get(legalIndex(i + 1));\n      // We have to find the next point that is not on the plane between start and end.\n      // If there is no such point, it's an error.\n      final Plane planeToFind = new Plane(start, end);\n      int endPointIndex = -1;\n      for (int j = 0; j < points.size(); j++) {\n        final int index = legalIndex(j + i + 2);\n        if (!planeToFind.evaluateIsZero(points.get(index))) {\n          endPointIndex = index;\n          break;\n        }\n      }\n      if (endPointIndex == -1) {\n        throw new IllegalArgumentException(\"Polygon points are all coplanar\");\n      }\n      final GeoPoint check = points.get(endPointIndex);\n      //System.out.println(\"Created edge \"+sp+\" using start=\"+start+\" end=\"+end+\" check=\"+check);\n      edges[i] = new SidedPlane(check, false, start, end);\n      invertedEdges[i] = new SidedPlane(edges[i]);\n      notableEdgePoints[i] = new GeoPoint[]{start, end};\n    }\n    /* Disable since GeoPolygonFactory does this too.\n    // In order to naively confirm that the polygon is concave, I would need to\n    // check every edge, and verify that every point (other than the edge endpoints)\n    // is within the edge's sided plane.  This is an order n^2 operation.  That's still\n    // not wrong, though, because everything else about polygons has a similar cost.\n    for (int edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {\n      final SidedPlane edge = edges[edgeIndex];\n      for (int pointIndex = 0; pointIndex < points.size(); pointIndex++) {\n        if (pointIndex != edgeIndex && pointIndex != legalIndex(edgeIndex + 1)) {\n          if (edge.isWithin(points.get(pointIndex)))\n            throw new IllegalArgumentException(\"Polygon is not concave: Point \" + points.get(pointIndex) + \" Edge \" + edge);\n        }\n      }\n    }\n    */\n    \n    // For each edge, create a bounds object.\n    eitherBounds = new HashMap<>(edges.length);\n    for (int edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {\n      final SidedPlane edge = edges[edgeIndex];\n      final SidedPlane invertedEdge = invertedEdges[edgeIndex];\n      int bound1Index = legalIndex(edgeIndex+1);\n      while (invertedEdges[legalIndex(bound1Index)].isNumericallyIdentical(invertedEdge)) {\n        bound1Index++;\n      }\n      int bound2Index = legalIndex(edgeIndex-1);\n      while (invertedEdges[legalIndex(bound2Index)].isNumericallyIdentical(invertedEdge)) {\n        bound2Index--;\n      }\n      eitherBounds.put(edge, new EitherBound(invertedEdges[legalIndex(bound1Index)], invertedEdges[legalIndex(bound2Index)]));\n    }\n\n    // Pick an edge point arbitrarily\n    edgePoints = new GeoPoint[]{points.get(0)};\n  }\n\n","sourceOld":"  /**\n   * Finish the polygon, by connecting the last added point with the starting point.\n   *@param isInternalReturnEdge is true if the return edge (back to start) is an internal one.\n   */\n  public void done(final boolean isInternalReturnEdge) {\n    if (isDone)\n      throw new IllegalStateException(\"Can't call done() more than once\");\n    // If fewer than 3 points, can't do it.\n    if (points.size() < 3)\n      throw new IllegalArgumentException(\"Polygon needs at least three points.\");\n\n    if (isInternalReturnEdge)\n      isInternalEdges.set(points.size() - 1);\n\n    isDone = true;\n    \n    // Time to construct the planes.  If the polygon is truly concave then any adjacent point\n    // to a segment can provide an exterior measurement.  Note: We build the true planes\n    // here and use the logic to return what *isn't* inside all of them.\n    edges = new SidedPlane[points.size()];\n    invertedEdges = new SidedPlane[points.size()];\n    notableEdgePoints = new GeoPoint[points.size()][];\n\n    for (int i = 0; i < points.size(); i++) {\n      final GeoPoint start = points.get(i);\n      final GeoPoint end = points.get(legalIndex(i + 1));\n      // We have to find the next point that is not on the plane between start and end.\n      // If there is no such point, it's an error.\n      final Plane planeToFind = new Plane(start, end);\n      int endPointIndex = -1;\n      for (int j = 0; j < points.size(); j++) {\n        final int index = legalIndex(j + i + 2);\n        if (!planeToFind.evaluateIsZero(points.get(index))) {\n          endPointIndex = index;\n          break;\n        }\n      }\n      if (endPointIndex == -1) {\n        throw new IllegalArgumentException(\"Polygon points are all coplanar\");\n      }\n      final GeoPoint check = points.get(endPointIndex);\n      //System.out.println(\"Created edge \"+sp+\" using start=\"+start+\" end=\"+end+\" check=\"+check);\n      edges[i] = new SidedPlane(check, false, start, end);\n      invertedEdges[i] = new SidedPlane(edges[i]);\n      notableEdgePoints[i] = new GeoPoint[]{start, end};\n    }\n    // In order to naively confirm that the polygon is concave, I would need to\n    // check every edge, and verify that every point (other than the edge endpoints)\n    // is within the edge's sided plane.  This is an order n^2 operation.  That's still\n    // not wrong, though, because everything else about polygons has a similar cost.\n    for (int edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {\n      final SidedPlane edge = edges[edgeIndex];\n      for (int pointIndex = 0; pointIndex < points.size(); pointIndex++) {\n        if (pointIndex != edgeIndex && pointIndex != legalIndex(edgeIndex + 1)) {\n          if (edge.isWithin(points.get(pointIndex)))\n            throw new IllegalArgumentException(\"Polygon is not concave: Point \" + points.get(pointIndex) + \" Edge \" + edge);\n        }\n      }\n    }\n    \n    // For each edge, create a bounds object.\n    eitherBounds = new HashMap<>(edges.length);\n    for (int edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {\n      final SidedPlane edge = edges[edgeIndex];\n      final SidedPlane invertedEdge = invertedEdges[edgeIndex];\n      int bound1Index = legalIndex(edgeIndex+1);\n      while (invertedEdges[legalIndex(bound1Index)].isNumericallyIdentical(invertedEdge)) {\n        bound1Index++;\n      }\n      int bound2Index = legalIndex(edgeIndex-1);\n      while (invertedEdges[legalIndex(bound2Index)].isNumericallyIdentical(invertedEdge)) {\n        bound2Index--;\n      }\n      eitherBounds.put(edge, new EitherBound(invertedEdges[legalIndex(bound1Index)], invertedEdges[legalIndex(bound2Index)]));\n    }\n\n    // Pick an edge point arbitrarily\n    edgePoints = new GeoPoint[]{points.get(0)};\n  }\n\n","bugFix":null,"bugIntro":["b325b9a50d0c88c91837edc3cf8e11a5216e897a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b325b9a50d0c88c91837edc3cf8e11a5216e897a","date":1461357451,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoConcavePolygon#done(boolean).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoConcavePolygon#done(boolean).mjava","sourceNew":"  /**\n   * Finish the polygon, by connecting the last added point with the starting point.\n   *@param isInternalReturnEdge is true if the return edge (back to start) is an internal one.\n   */\n  public void done(final boolean isInternalReturnEdge) {\n    if (isDone)\n      throw new IllegalStateException(\"Can't call done() more than once\");\n    // If fewer than 3 points, can't do it.\n    if (points.size() < 3)\n      throw new IllegalArgumentException(\"Polygon needs at least three points.\");\n\n    if (isInternalReturnEdge)\n      isInternalEdges.set(points.size() - 1);\n\n    isDone = true;\n    \n    // Time to construct the planes.  If the polygon is truly concave then any adjacent point\n    // to a segment can provide an exterior measurement.  Note: We build the true planes\n    // here and use the logic to return what *isn't* inside all of them.\n    edges = new SidedPlane[points.size()];\n    invertedEdges = new SidedPlane[points.size()];\n    notableEdgePoints = new GeoPoint[points.size()][];\n\n    for (int i = 0; i < points.size(); i++) {\n      final GeoPoint start = points.get(i);\n      final GeoPoint end = points.get(legalIndex(i + 1));\n      // We have to find the next point that is not on the plane between start and end.\n      // If there is no such point, it's an error.\n      final Plane planeToFind = new Plane(start, end);\n      int endPointIndex = -1;\n      for (int j = 0; j < points.size(); j++) {\n        final int index = legalIndex(j + i + 2);\n        if (!planeToFind.evaluateIsZero(points.get(index))) {\n          endPointIndex = index;\n          break;\n        }\n      }\n      if (endPointIndex == -1) {\n        throw new IllegalArgumentException(\"Polygon points are all coplanar\");\n      }\n      final GeoPoint check = points.get(endPointIndex);\n      //System.out.println(\"Created edge \"+sp+\" using start=\"+start+\" end=\"+end+\" check=\"+check);\n      edges[i] = new SidedPlane(check, false, start, end);\n      invertedEdges[i] = new SidedPlane(edges[i]);\n      notableEdgePoints[i] = new GeoPoint[]{start, end};\n    }\n    \n    // For each edge, create a bounds object.\n    eitherBounds = new HashMap<>(edges.length);\n    for (int edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {\n      final SidedPlane edge = edges[edgeIndex];\n      final SidedPlane invertedEdge = invertedEdges[edgeIndex];\n      int bound1Index = legalIndex(edgeIndex+1);\n      while (invertedEdges[legalIndex(bound1Index)].isNumericallyIdentical(invertedEdge)) {\n        bound1Index++;\n      }\n      int bound2Index = legalIndex(edgeIndex-1);\n      while (invertedEdges[legalIndex(bound2Index)].isNumericallyIdentical(invertedEdge)) {\n        bound2Index--;\n      }\n      eitherBounds.put(edge, new EitherBound(invertedEdges[legalIndex(bound1Index)], invertedEdges[legalIndex(bound2Index)]));\n    }\n\n    // Pick an edge point arbitrarily\n    edgePoints = new GeoPoint[]{points.get(0)};\n\n    if (isWithinHoles(points.get(0))) {\n      throw new IllegalArgumentException(\"Polygon edge intersects a polygon hole; not allowed\");\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Finish the polygon, by connecting the last added point with the starting point.\n   *@param isInternalReturnEdge is true if the return edge (back to start) is an internal one.\n   */\n  public void done(final boolean isInternalReturnEdge) {\n    if (isDone)\n      throw new IllegalStateException(\"Can't call done() more than once\");\n    // If fewer than 3 points, can't do it.\n    if (points.size() < 3)\n      throw new IllegalArgumentException(\"Polygon needs at least three points.\");\n\n    if (isInternalReturnEdge)\n      isInternalEdges.set(points.size() - 1);\n\n    isDone = true;\n    \n    // Time to construct the planes.  If the polygon is truly concave then any adjacent point\n    // to a segment can provide an exterior measurement.  Note: We build the true planes\n    // here and use the logic to return what *isn't* inside all of them.\n    edges = new SidedPlane[points.size()];\n    invertedEdges = new SidedPlane[points.size()];\n    notableEdgePoints = new GeoPoint[points.size()][];\n\n    for (int i = 0; i < points.size(); i++) {\n      final GeoPoint start = points.get(i);\n      final GeoPoint end = points.get(legalIndex(i + 1));\n      // We have to find the next point that is not on the plane between start and end.\n      // If there is no such point, it's an error.\n      final Plane planeToFind = new Plane(start, end);\n      int endPointIndex = -1;\n      for (int j = 0; j < points.size(); j++) {\n        final int index = legalIndex(j + i + 2);\n        if (!planeToFind.evaluateIsZero(points.get(index))) {\n          endPointIndex = index;\n          break;\n        }\n      }\n      if (endPointIndex == -1) {\n        throw new IllegalArgumentException(\"Polygon points are all coplanar\");\n      }\n      final GeoPoint check = points.get(endPointIndex);\n      //System.out.println(\"Created edge \"+sp+\" using start=\"+start+\" end=\"+end+\" check=\"+check);\n      edges[i] = new SidedPlane(check, false, start, end);\n      invertedEdges[i] = new SidedPlane(edges[i]);\n      notableEdgePoints[i] = new GeoPoint[]{start, end};\n    }\n    /* Disable since GeoPolygonFactory does this too.\n    // In order to naively confirm that the polygon is concave, I would need to\n    // check every edge, and verify that every point (other than the edge endpoints)\n    // is within the edge's sided plane.  This is an order n^2 operation.  That's still\n    // not wrong, though, because everything else about polygons has a similar cost.\n    for (int edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {\n      final SidedPlane edge = edges[edgeIndex];\n      for (int pointIndex = 0; pointIndex < points.size(); pointIndex++) {\n        if (pointIndex != edgeIndex && pointIndex != legalIndex(edgeIndex + 1)) {\n          if (edge.isWithin(points.get(pointIndex)))\n            throw new IllegalArgumentException(\"Polygon is not concave: Point \" + points.get(pointIndex) + \" Edge \" + edge);\n        }\n      }\n    }\n    */\n    \n    // For each edge, create a bounds object.\n    eitherBounds = new HashMap<>(edges.length);\n    for (int edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {\n      final SidedPlane edge = edges[edgeIndex];\n      final SidedPlane invertedEdge = invertedEdges[edgeIndex];\n      int bound1Index = legalIndex(edgeIndex+1);\n      while (invertedEdges[legalIndex(bound1Index)].isNumericallyIdentical(invertedEdge)) {\n        bound1Index++;\n      }\n      int bound2Index = legalIndex(edgeIndex-1);\n      while (invertedEdges[legalIndex(bound2Index)].isNumericallyIdentical(invertedEdge)) {\n        bound2Index--;\n      }\n      eitherBounds.put(edge, new EitherBound(invertedEdges[legalIndex(bound1Index)], invertedEdges[legalIndex(bound2Index)]));\n    }\n\n    // Pick an edge point arbitrarily\n    edgePoints = new GeoPoint[]{points.get(0)};\n  }\n\n","bugFix":["9d2d72e1014f51e87658946e08272b7efd0d52e7","40aa98241c87d86a0077beb8023713d93a0becfe"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ba81c43c13d92ea74a6388471cf358eb7068744d","date":1461408282,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoConcavePolygon#done(boolean).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoConcavePolygon#done(boolean).mjava","sourceNew":"  /**\n   * Finish the polygon, by connecting the last added point with the starting point.\n   *@param isInternalReturnEdge is true if the return edge (back to start) is an internal one.\n   */\n  public void done(final boolean isInternalReturnEdge) {\n    if (isDone)\n      throw new IllegalStateException(\"Can't call done() more than once\");\n    // If fewer than 3 points, can't do it.\n    if (points.size() < 3)\n      throw new IllegalArgumentException(\"Polygon needs at least three points.\");\n\n    if (isInternalReturnEdge)\n      isInternalEdges.set(points.size() - 1);\n\n    isDone = true;\n    \n    // Time to construct the planes.  If the polygon is truly concave then any adjacent point\n    // to a segment can provide an exterior measurement.  Note: We build the true planes\n    // here and use the logic to return what *isn't* inside all of them.\n    edges = new SidedPlane[points.size()];\n    invertedEdges = new SidedPlane[points.size()];\n    notableEdgePoints = new GeoPoint[points.size()][];\n\n    for (int i = 0; i < points.size(); i++) {\n      final GeoPoint start = points.get(i);\n      final GeoPoint end = points.get(legalIndex(i + 1));\n      // We have to find the next point that is not on the plane between start and end.\n      // If there is no such point, it's an error.\n      final Plane planeToFind = new Plane(start, end);\n      int endPointIndex = -1;\n      for (int j = 0; j < points.size(); j++) {\n        final int index = legalIndex(j + i + 2);\n        if (!planeToFind.evaluateIsZero(points.get(index))) {\n          endPointIndex = index;\n          break;\n        }\n      }\n      if (endPointIndex == -1) {\n        throw new IllegalArgumentException(\"Polygon points are all coplanar\");\n      }\n      final GeoPoint check = points.get(endPointIndex);\n      //System.out.println(\"Created edge \"+sp+\" using start=\"+start+\" end=\"+end+\" check=\"+check);\n      edges[i] = new SidedPlane(check, false, start, end);\n      invertedEdges[i] = new SidedPlane(edges[i]);\n      notableEdgePoints[i] = new GeoPoint[]{start, end};\n    }\n    \n    // For each edge, create a bounds object.\n    eitherBounds = new HashMap<>(edges.length);\n    for (int edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {\n      final SidedPlane edge = edges[edgeIndex];\n      final SidedPlane invertedEdge = invertedEdges[edgeIndex];\n      int bound1Index = legalIndex(edgeIndex+1);\n      while (invertedEdges[legalIndex(bound1Index)].isNumericallyIdentical(invertedEdge)) {\n        bound1Index++;\n      }\n      int bound2Index = legalIndex(edgeIndex-1);\n      while (invertedEdges[legalIndex(bound2Index)].isNumericallyIdentical(invertedEdge)) {\n        bound2Index--;\n      }\n      eitherBounds.put(edge, new EitherBound(invertedEdges[legalIndex(bound1Index)], invertedEdges[legalIndex(bound2Index)]));\n    }\n\n    // Pick an edge point arbitrarily from the outer polygon.  Glom this together with all edge points from\n    // inner polygons.\n    int edgePointCount = 1;\n    if (holes != null) {\n      for (final GeoPolygon hole : holes) {\n        edgePointCount += hole.getEdgePoints().length;\n      }\n    }\n    edgePoints = new GeoPoint[edgePointCount];\n    edgePointCount = 0;\n    edgePoints[edgePointCount++] = points.get(0);\n    if (holes != null) {\n      for (final GeoPolygon hole : holes) {\n        final GeoPoint[] holeEdgePoints = hole.getEdgePoints();\n        for (final GeoPoint p : holeEdgePoints) {\n          edgePoints[edgePointCount++] = p;\n        }\n      }\n    }\n\n    if (isWithinHoles(points.get(0))) {\n      throw new IllegalArgumentException(\"Polygon edge intersects a polygon hole; not allowed\");\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Finish the polygon, by connecting the last added point with the starting point.\n   *@param isInternalReturnEdge is true if the return edge (back to start) is an internal one.\n   */\n  public void done(final boolean isInternalReturnEdge) {\n    if (isDone)\n      throw new IllegalStateException(\"Can't call done() more than once\");\n    // If fewer than 3 points, can't do it.\n    if (points.size() < 3)\n      throw new IllegalArgumentException(\"Polygon needs at least three points.\");\n\n    if (isInternalReturnEdge)\n      isInternalEdges.set(points.size() - 1);\n\n    isDone = true;\n    \n    // Time to construct the planes.  If the polygon is truly concave then any adjacent point\n    // to a segment can provide an exterior measurement.  Note: We build the true planes\n    // here and use the logic to return what *isn't* inside all of them.\n    edges = new SidedPlane[points.size()];\n    invertedEdges = new SidedPlane[points.size()];\n    notableEdgePoints = new GeoPoint[points.size()][];\n\n    for (int i = 0; i < points.size(); i++) {\n      final GeoPoint start = points.get(i);\n      final GeoPoint end = points.get(legalIndex(i + 1));\n      // We have to find the next point that is not on the plane between start and end.\n      // If there is no such point, it's an error.\n      final Plane planeToFind = new Plane(start, end);\n      int endPointIndex = -1;\n      for (int j = 0; j < points.size(); j++) {\n        final int index = legalIndex(j + i + 2);\n        if (!planeToFind.evaluateIsZero(points.get(index))) {\n          endPointIndex = index;\n          break;\n        }\n      }\n      if (endPointIndex == -1) {\n        throw new IllegalArgumentException(\"Polygon points are all coplanar\");\n      }\n      final GeoPoint check = points.get(endPointIndex);\n      //System.out.println(\"Created edge \"+sp+\" using start=\"+start+\" end=\"+end+\" check=\"+check);\n      edges[i] = new SidedPlane(check, false, start, end);\n      invertedEdges[i] = new SidedPlane(edges[i]);\n      notableEdgePoints[i] = new GeoPoint[]{start, end};\n    }\n    \n    // For each edge, create a bounds object.\n    eitherBounds = new HashMap<>(edges.length);\n    for (int edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {\n      final SidedPlane edge = edges[edgeIndex];\n      final SidedPlane invertedEdge = invertedEdges[edgeIndex];\n      int bound1Index = legalIndex(edgeIndex+1);\n      while (invertedEdges[legalIndex(bound1Index)].isNumericallyIdentical(invertedEdge)) {\n        bound1Index++;\n      }\n      int bound2Index = legalIndex(edgeIndex-1);\n      while (invertedEdges[legalIndex(bound2Index)].isNumericallyIdentical(invertedEdge)) {\n        bound2Index--;\n      }\n      eitherBounds.put(edge, new EitherBound(invertedEdges[legalIndex(bound1Index)], invertedEdges[legalIndex(bound2Index)]));\n    }\n\n    // Pick an edge point arbitrarily\n    edgePoints = new GeoPoint[]{points.get(0)};\n\n    if (isWithinHoles(points.get(0))) {\n      throw new IllegalArgumentException(\"Polygon edge intersects a polygon hole; not allowed\");\n    }\n\n  }\n\n","bugFix":["40aa98241c87d86a0077beb8023713d93a0becfe"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f7f901826e47f75f810d7aae24b0455d21ea1fe2","date":1461678892,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoConcavePolygon#done(boolean).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoConcavePolygon#done(boolean).mjava","sourceNew":"  /**\n   * Finish the polygon, by connecting the last added point with the starting point.\n   *@param isInternalReturnEdge is true if the return edge (back to start) is an internal one.\n   */\n  public void done(final boolean isInternalReturnEdge) {\n    if (isDone)\n      throw new IllegalStateException(\"Can't call done() more than once\");\n    // If fewer than 3 points, can't do it.\n    if (points.size() < 3)\n      throw new IllegalArgumentException(\"Polygon needs at least three points.\");\n\n    if (isInternalReturnEdge)\n      isInternalEdges.set(points.size() - 1);\n\n    isDone = true;\n    \n    // Time to construct the planes.  If the polygon is truly concave then any adjacent point\n    // to a segment can provide an exterior measurement.  Note: We build the true planes\n    // here and use the logic to return what *isn't* inside all of them.\n    edges = new SidedPlane[points.size()];\n    invertedEdges = new SidedPlane[points.size()];\n    notableEdgePoints = new GeoPoint[points.size()][];\n\n    for (int i = 0; i < points.size(); i++) {\n      final GeoPoint start = points.get(i);\n      final GeoPoint end = points.get(legalIndex(i + 1));\n      // We have to find the next point that is not on the plane between start and end.\n      // If there is no such point, it's an error.\n      final Plane planeToFind = new Plane(start, end);\n      int endPointIndex = -1;\n      for (int j = 0; j < points.size(); j++) {\n        final int index = legalIndex(j + i + 2);\n        if (!planeToFind.evaluateIsZero(points.get(index))) {\n          endPointIndex = index;\n          break;\n        }\n      }\n      if (endPointIndex == -1) {\n        throw new IllegalArgumentException(\"Polygon points are all coplanar\");\n      }\n      final GeoPoint check = points.get(endPointIndex);\n      //System.out.println(\"Created edge \"+sp+\" using start=\"+start+\" end=\"+end+\" check=\"+check);\n      edges[i] = new SidedPlane(check, false, start, end);\n      invertedEdges[i] = new SidedPlane(edges[i]);\n      notableEdgePoints[i] = new GeoPoint[]{start, end};\n    }\n    \n    // For each edge, create a bounds object.\n    eitherBounds = new HashMap<>(edges.length);\n    for (int edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {\n      final SidedPlane edge = edges[edgeIndex];\n      final SidedPlane invertedEdge = invertedEdges[edgeIndex];\n      int bound1Index = legalIndex(edgeIndex+1);\n      while (invertedEdges[legalIndex(bound1Index)].isNumericallyIdentical(invertedEdge)) {\n        bound1Index++;\n      }\n      int bound2Index = legalIndex(edgeIndex-1);\n      while (invertedEdges[legalIndex(bound2Index)].isNumericallyIdentical(invertedEdge)) {\n        bound2Index--;\n      }\n      eitherBounds.put(edge, new EitherBound(invertedEdges[legalIndex(bound1Index)], invertedEdges[legalIndex(bound2Index)]));\n    }\n\n    // Pick an edge point arbitrarily from the outer polygon.  Glom this together with all edge points from\n    // inner polygons.\n    int edgePointCount = 1;\n    if (holes != null) {\n      for (final GeoPolygon hole : holes) {\n        edgePointCount += hole.getEdgePoints().length;\n      }\n    }\n    edgePoints = new GeoPoint[edgePointCount];\n    edgePointCount = 0;\n    edgePoints[edgePointCount++] = points.get(0);\n    if (holes != null) {\n      for (final GeoPolygon hole : holes) {\n        final GeoPoint[] holeEdgePoints = hole.getEdgePoints();\n        for (final GeoPoint p : holeEdgePoints) {\n          edgePoints[edgePointCount++] = p;\n        }\n      }\n    }\n\n    if (isWithinHoles(points.get(0))) {\n      throw new IllegalArgumentException(\"Polygon edge intersects a polygon hole; not allowed\");\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Finish the polygon, by connecting the last added point with the starting point.\n   *@param isInternalReturnEdge is true if the return edge (back to start) is an internal one.\n   */\n  public void done(final boolean isInternalReturnEdge) {\n    if (isDone)\n      throw new IllegalStateException(\"Can't call done() more than once\");\n    // If fewer than 3 points, can't do it.\n    if (points.size() < 3)\n      throw new IllegalArgumentException(\"Polygon needs at least three points.\");\n\n    if (isInternalReturnEdge)\n      isInternalEdges.set(points.size() - 1);\n\n    isDone = true;\n    \n    // Time to construct the planes.  If the polygon is truly concave then any adjacent point\n    // to a segment can provide an exterior measurement.  Note: We build the true planes\n    // here and use the logic to return what *isn't* inside all of them.\n    edges = new SidedPlane[points.size()];\n    invertedEdges = new SidedPlane[points.size()];\n    notableEdgePoints = new GeoPoint[points.size()][];\n\n    for (int i = 0; i < points.size(); i++) {\n      final GeoPoint start = points.get(i);\n      final GeoPoint end = points.get(legalIndex(i + 1));\n      // We have to find the next point that is not on the plane between start and end.\n      // If there is no such point, it's an error.\n      final Plane planeToFind = new Plane(start, end);\n      int endPointIndex = -1;\n      for (int j = 0; j < points.size(); j++) {\n        final int index = legalIndex(j + i + 2);\n        if (!planeToFind.evaluateIsZero(points.get(index))) {\n          endPointIndex = index;\n          break;\n        }\n      }\n      if (endPointIndex == -1) {\n        throw new IllegalArgumentException(\"Polygon points are all coplanar\");\n      }\n      final GeoPoint check = points.get(endPointIndex);\n      //System.out.println(\"Created edge \"+sp+\" using start=\"+start+\" end=\"+end+\" check=\"+check);\n      edges[i] = new SidedPlane(check, false, start, end);\n      invertedEdges[i] = new SidedPlane(edges[i]);\n      notableEdgePoints[i] = new GeoPoint[]{start, end};\n    }\n    /* Disable since GeoPolygonFactory does this too.\n    // In order to naively confirm that the polygon is concave, I would need to\n    // check every edge, and verify that every point (other than the edge endpoints)\n    // is within the edge's sided plane.  This is an order n^2 operation.  That's still\n    // not wrong, though, because everything else about polygons has a similar cost.\n    for (int edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {\n      final SidedPlane edge = edges[edgeIndex];\n      for (int pointIndex = 0; pointIndex < points.size(); pointIndex++) {\n        if (pointIndex != edgeIndex && pointIndex != legalIndex(edgeIndex + 1)) {\n          if (edge.isWithin(points.get(pointIndex)))\n            throw new IllegalArgumentException(\"Polygon is not concave: Point \" + points.get(pointIndex) + \" Edge \" + edge);\n        }\n      }\n    }\n    */\n    \n    // For each edge, create a bounds object.\n    eitherBounds = new HashMap<>(edges.length);\n    for (int edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {\n      final SidedPlane edge = edges[edgeIndex];\n      final SidedPlane invertedEdge = invertedEdges[edgeIndex];\n      int bound1Index = legalIndex(edgeIndex+1);\n      while (invertedEdges[legalIndex(bound1Index)].isNumericallyIdentical(invertedEdge)) {\n        bound1Index++;\n      }\n      int bound2Index = legalIndex(edgeIndex-1);\n      while (invertedEdges[legalIndex(bound2Index)].isNumericallyIdentical(invertedEdge)) {\n        bound2Index--;\n      }\n      eitherBounds.put(edge, new EitherBound(invertedEdges[legalIndex(bound1Index)], invertedEdges[legalIndex(bound2Index)]));\n    }\n\n    // Pick an edge point arbitrarily\n    edgePoints = new GeoPoint[]{points.get(0)};\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bd7a250b817d38fdb6f0411589342b46d249c5cf","date":1465297838,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoConcavePolygon#done(boolean).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoConcavePolygon#done(boolean).mjava","sourceNew":"  /**\n   * Finish the polygon, by connecting the last added point with the starting point.\n   *@param isInternalReturnEdge is true if the return edge (back to start) is an internal one.\n   */\n  public void done(final boolean isInternalReturnEdge) {\n    if (isDone)\n      throw new IllegalStateException(\"Can't call done() more than once\");\n    // If fewer than 3 points, can't do it.\n    if (points.size() < 3)\n      throw new IllegalArgumentException(\"Polygon needs at least three points.\");\n\n    if (isInternalReturnEdge)\n      isInternalEdges.set(points.size() - 1);\n\n    isDone = true;\n    \n    // Time to construct the planes.  If the polygon is truly concave then any adjacent point\n    // to a segment can provide an exterior measurement.  Note: We build the true planes\n    // here and use the logic to return what *isn't* inside all of them.\n    edges = new SidedPlane[points.size()];\n    invertedEdges = new SidedPlane[points.size()];\n    notableEdgePoints = new GeoPoint[points.size()][];\n\n    for (int i = 0; i < points.size(); i++) {\n      final GeoPoint start = points.get(i);\n      final GeoPoint end = points.get(legalIndex(i + 1));\n      // We have to find the next point that is not on the plane between start and end.\n      // If there is no such point, it's an error.\n      final Plane planeToFind = new Plane(start, end);\n      int endPointIndex = -1;\n      for (int j = 0; j < points.size(); j++) {\n        final int index = legalIndex(j + i + 2);\n        if (!planeToFind.evaluateIsZero(points.get(index))) {\n          endPointIndex = index;\n          break;\n        }\n      }\n      if (endPointIndex == -1) {\n        throw new IllegalArgumentException(\"Polygon points are all coplanar\");\n      }\n      final GeoPoint check = points.get(endPointIndex);\n      //System.out.println(\"Created edge \"+sp+\" using start=\"+start+\" end=\"+end+\" check=\"+check);\n      edges[i] = new SidedPlane(check, false, start, end);\n      invertedEdges[i] = new SidedPlane(edges[i]);\n      notableEdgePoints[i] = new GeoPoint[]{start, end};\n    }\n    \n    // For each edge, create a bounds object.\n    eitherBounds = new HashMap<>(edges.length);\n    intersectionBounds = new HashMap<>(edges.length);\n    edgePlanes = new HashMap<>(edges.length);\n    for (int edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {\n      final SidedPlane edge = edges[edgeIndex];\n      final SidedPlane invertedEdge = invertedEdges[edgeIndex];\n      int bound1Index = legalIndex(edgeIndex+1);\n      while (invertedEdges[legalIndex(bound1Index)].isNumericallyIdentical(invertedEdge)) {\n        bound1Index++;\n      }\n      int bound2Index = legalIndex(edgeIndex-1);\n      int otherIndex = bound2Index;\n      final SidedPlane otherEdge;\n      final SidedPlane otherInvertedEdge;\n      if (invertedEdges[legalIndex(otherIndex)].isNumericallyIdentical(invertedEdge)) {\n        otherInvertedEdge = null;\n        otherEdge = null;\n      } else {\n        otherInvertedEdge = invertedEdges[legalIndex(otherIndex)];\n        otherEdge = edges[legalIndex(otherIndex)];\n      }\n      while (invertedEdges[legalIndex(bound2Index)].isNumericallyIdentical(invertedEdge)) {\n        bound2Index--;\n      }\n      eitherBounds.put(edge, new EitherBound(invertedEdges[legalIndex(bound1Index)], invertedEdges[legalIndex(bound2Index)]));\n      // For intersections, we look at the point at the intersection between the previous edge and this one.  We need to locate the \n      // Intersection bounds needs to look even further forwards/backwards\n      if (otherInvertedEdge != null) {\n        while (invertedEdges[legalIndex(otherIndex)].isNumericallyIdentical(otherInvertedEdge)) {\n          otherIndex--;\n        }\n        intersectionBounds.put(edge, new EitherBound(invertedEdges[legalIndex(otherIndex)], invertedEdges[legalIndex(bound2Index)]));\n        edgePlanes.put(edge, otherEdge);\n      }\n    }\n\n    // Pick an edge point arbitrarily from the outer polygon.  Glom this together with all edge points from\n    // inner polygons.\n    int edgePointCount = 1;\n    if (holes != null) {\n      for (final GeoPolygon hole : holes) {\n        edgePointCount += hole.getEdgePoints().length;\n      }\n    }\n    edgePoints = new GeoPoint[edgePointCount];\n    edgePointCount = 0;\n    edgePoints[edgePointCount++] = points.get(0);\n    if (holes != null) {\n      for (final GeoPolygon hole : holes) {\n        final GeoPoint[] holeEdgePoints = hole.getEdgePoints();\n        for (final GeoPoint p : holeEdgePoints) {\n          edgePoints[edgePointCount++] = p;\n        }\n      }\n    }\n\n    if (isWithinHoles(points.get(0))) {\n      throw new IllegalArgumentException(\"Polygon edge intersects a polygon hole; not allowed\");\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Finish the polygon, by connecting the last added point with the starting point.\n   *@param isInternalReturnEdge is true if the return edge (back to start) is an internal one.\n   */\n  public void done(final boolean isInternalReturnEdge) {\n    if (isDone)\n      throw new IllegalStateException(\"Can't call done() more than once\");\n    // If fewer than 3 points, can't do it.\n    if (points.size() < 3)\n      throw new IllegalArgumentException(\"Polygon needs at least three points.\");\n\n    if (isInternalReturnEdge)\n      isInternalEdges.set(points.size() - 1);\n\n    isDone = true;\n    \n    // Time to construct the planes.  If the polygon is truly concave then any adjacent point\n    // to a segment can provide an exterior measurement.  Note: We build the true planes\n    // here and use the logic to return what *isn't* inside all of them.\n    edges = new SidedPlane[points.size()];\n    invertedEdges = new SidedPlane[points.size()];\n    notableEdgePoints = new GeoPoint[points.size()][];\n\n    for (int i = 0; i < points.size(); i++) {\n      final GeoPoint start = points.get(i);\n      final GeoPoint end = points.get(legalIndex(i + 1));\n      // We have to find the next point that is not on the plane between start and end.\n      // If there is no such point, it's an error.\n      final Plane planeToFind = new Plane(start, end);\n      int endPointIndex = -1;\n      for (int j = 0; j < points.size(); j++) {\n        final int index = legalIndex(j + i + 2);\n        if (!planeToFind.evaluateIsZero(points.get(index))) {\n          endPointIndex = index;\n          break;\n        }\n      }\n      if (endPointIndex == -1) {\n        throw new IllegalArgumentException(\"Polygon points are all coplanar\");\n      }\n      final GeoPoint check = points.get(endPointIndex);\n      //System.out.println(\"Created edge \"+sp+\" using start=\"+start+\" end=\"+end+\" check=\"+check);\n      edges[i] = new SidedPlane(check, false, start, end);\n      invertedEdges[i] = new SidedPlane(edges[i]);\n      notableEdgePoints[i] = new GeoPoint[]{start, end};\n    }\n    \n    // For each edge, create a bounds object.\n    eitherBounds = new HashMap<>(edges.length);\n    for (int edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {\n      final SidedPlane edge = edges[edgeIndex];\n      final SidedPlane invertedEdge = invertedEdges[edgeIndex];\n      int bound1Index = legalIndex(edgeIndex+1);\n      while (invertedEdges[legalIndex(bound1Index)].isNumericallyIdentical(invertedEdge)) {\n        bound1Index++;\n      }\n      int bound2Index = legalIndex(edgeIndex-1);\n      while (invertedEdges[legalIndex(bound2Index)].isNumericallyIdentical(invertedEdge)) {\n        bound2Index--;\n      }\n      eitherBounds.put(edge, new EitherBound(invertedEdges[legalIndex(bound1Index)], invertedEdges[legalIndex(bound2Index)]));\n    }\n\n    // Pick an edge point arbitrarily from the outer polygon.  Glom this together with all edge points from\n    // inner polygons.\n    int edgePointCount = 1;\n    if (holes != null) {\n      for (final GeoPolygon hole : holes) {\n        edgePointCount += hole.getEdgePoints().length;\n      }\n    }\n    edgePoints = new GeoPoint[edgePointCount];\n    edgePointCount = 0;\n    edgePoints[edgePointCount++] = points.get(0);\n    if (holes != null) {\n      for (final GeoPolygon hole : holes) {\n        final GeoPoint[] holeEdgePoints = hole.getEdgePoints();\n        for (final GeoPoint p : holeEdgePoints) {\n          edgePoints[edgePointCount++] = p;\n        }\n      }\n    }\n\n    if (isWithinHoles(points.get(0))) {\n      throw new IllegalArgumentException(\"Polygon edge intersects a polygon hole; not allowed\");\n    }\n\n  }\n\n","bugFix":null,"bugIntro":["f9369473490cca80a5b92824279ebc7df00dc255"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"54e10c9f59e9af43a3d623fc58c2d3790f0f5cfb","date":1471692938,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoConcavePolygon#done(boolean).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoConcavePolygon#done(boolean).mjava","sourceNew":"  /**\n   * Finish the polygon, by connecting the last added point with the starting point.\n   *@param isInternalReturnEdge is true if the return edge (back to start) is an internal one.\n   */\n  public void done(final boolean isInternalReturnEdge) {\n    if (isDone)\n      throw new IllegalStateException(\"Can't call done() more than once\");\n    // If fewer than 3 points, can't do it.\n    if (points.size() < 3)\n      throw new IllegalArgumentException(\"Polygon needs at least three points.\");\n\n    if (isInternalReturnEdge)\n      isInternalEdges.set(points.size() - 1);\n\n    isDone = true;\n    \n    // Time to construct the planes.  If the polygon is truly concave then any adjacent point\n    // to a segment can provide an exterior measurement.  Note: We build the true planes\n    // here and use the logic to return what *isn't* inside all of them.\n    edges = new SidedPlane[points.size()];\n    invertedEdges = new SidedPlane[points.size()];\n    notableEdgePoints = new GeoPoint[points.size()][];\n\n    for (int i = 0; i < points.size(); i++) {\n      final GeoPoint start = points.get(i);\n      final GeoPoint end = points.get(legalIndex(i + 1));\n      // We have to find the next point that is not on the plane between start and end.\n      // If there is no such point, it's an error.\n      final Plane planeToFind = new Plane(start, end);\n      int endPointIndex = -1;\n      for (int j = 0; j < points.size(); j++) {\n        final int index = legalIndex(j + i + 2);\n        if (!planeToFind.evaluateIsZero(points.get(index))) {\n          endPointIndex = index;\n          break;\n        }\n      }\n      if (endPointIndex == -1) {\n        throw new IllegalArgumentException(\"Polygon points are all coplanar\");\n      }\n      final GeoPoint check = points.get(endPointIndex);\n      //System.out.println(\"Created edge \"+sp+\" using start=\"+start+\" end=\"+end+\" check=\"+check);\n      edges[i] = new SidedPlane(check, false, start, end);\n      invertedEdges[i] = new SidedPlane(edges[i]);\n      notableEdgePoints[i] = new GeoPoint[]{start, end};\n    }\n    \n    // For each edge, create a bounds object.\n    eitherBounds = new HashMap<>(edges.length);\n    intersectionBounds = new HashMap<>(edges.length);\n    edgePlanes = new HashMap<>(edges.length);\n    for (int edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {\n      final SidedPlane edge = edges[edgeIndex];\n      final SidedPlane invertedEdge = invertedEdges[edgeIndex];\n      int bound1Index = legalIndex(edgeIndex+1);\n      while (invertedEdges[legalIndex(bound1Index)].isNumericallyIdentical(invertedEdge)) {\n        bound1Index++;\n      }\n      int bound2Index = legalIndex(edgeIndex-1);\n      int otherIndex = bound2Index;\n      final SidedPlane otherEdge;\n      final SidedPlane otherInvertedEdge;\n      if (invertedEdges[legalIndex(otherIndex)].isNumericallyIdentical(invertedEdge)) {\n        otherInvertedEdge = null;\n        otherEdge = null;\n      } else {\n        otherInvertedEdge = invertedEdges[legalIndex(otherIndex)];\n        otherEdge = edges[legalIndex(otherIndex)];\n      }\n      while (invertedEdges[legalIndex(bound2Index)].isNumericallyIdentical(invertedEdge)) {\n        bound2Index--;\n      }\n      bound1Index = legalIndex(bound1Index);\n      bound2Index = legalIndex(bound2Index);\n      // Also confirm that all interior points are within the bounds\n      int startingIndex = bound2Index;\n      while (true) {\n        startingIndex = legalIndex(startingIndex+1);\n        if (startingIndex == bound1Index) {\n          break;\n        }\n        final GeoPoint interiorPoint = points.get(startingIndex);\n        if (!invertedEdges[bound1Index].isWithin(interiorPoint) || !invertedEdges[bound2Index].isWithin(interiorPoint)) {\n          throw new IllegalArgumentException(\"Concave polygon has a side that is more than 180 degrees\");\n        }\n      }\n      eitherBounds.put(edge, new EitherBound(invertedEdges[bound1Index], invertedEdges[bound2Index]));\n      // For intersections, we look at the point at the intersection between the previous edge and this one.  We need to locate the \n      // Intersection bounds needs to look even further forwards/backwards\n      if (otherInvertedEdge != null) {\n        while (invertedEdges[legalIndex(otherIndex)].isNumericallyIdentical(otherInvertedEdge)) {\n          otherIndex--;\n        }\n        intersectionBounds.put(edge, new EitherBound(invertedEdges[legalIndex(otherIndex)], invertedEdges[legalIndex(bound2Index)]));\n        edgePlanes.put(edge, otherEdge);\n      }\n    }\n\n    // Pick an edge point arbitrarily from the outer polygon.  Glom this together with all edge points from\n    // inner polygons.\n    int edgePointCount = 1;\n    if (holes != null) {\n      for (final GeoPolygon hole : holes) {\n        edgePointCount += hole.getEdgePoints().length;\n      }\n    }\n    edgePoints = new GeoPoint[edgePointCount];\n    edgePointCount = 0;\n    edgePoints[edgePointCount++] = points.get(0);\n    if (holes != null) {\n      for (final GeoPolygon hole : holes) {\n        final GeoPoint[] holeEdgePoints = hole.getEdgePoints();\n        for (final GeoPoint p : holeEdgePoints) {\n          edgePoints[edgePointCount++] = p;\n        }\n      }\n    }\n\n    if (isWithinHoles(points.get(0))) {\n      throw new IllegalArgumentException(\"Polygon edge intersects a polygon hole; not allowed\");\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Finish the polygon, by connecting the last added point with the starting point.\n   *@param isInternalReturnEdge is true if the return edge (back to start) is an internal one.\n   */\n  public void done(final boolean isInternalReturnEdge) {\n    if (isDone)\n      throw new IllegalStateException(\"Can't call done() more than once\");\n    // If fewer than 3 points, can't do it.\n    if (points.size() < 3)\n      throw new IllegalArgumentException(\"Polygon needs at least three points.\");\n\n    if (isInternalReturnEdge)\n      isInternalEdges.set(points.size() - 1);\n\n    isDone = true;\n    \n    // Time to construct the planes.  If the polygon is truly concave then any adjacent point\n    // to a segment can provide an exterior measurement.  Note: We build the true planes\n    // here and use the logic to return what *isn't* inside all of them.\n    edges = new SidedPlane[points.size()];\n    invertedEdges = new SidedPlane[points.size()];\n    notableEdgePoints = new GeoPoint[points.size()][];\n\n    for (int i = 0; i < points.size(); i++) {\n      final GeoPoint start = points.get(i);\n      final GeoPoint end = points.get(legalIndex(i + 1));\n      // We have to find the next point that is not on the plane between start and end.\n      // If there is no such point, it's an error.\n      final Plane planeToFind = new Plane(start, end);\n      int endPointIndex = -1;\n      for (int j = 0; j < points.size(); j++) {\n        final int index = legalIndex(j + i + 2);\n        if (!planeToFind.evaluateIsZero(points.get(index))) {\n          endPointIndex = index;\n          break;\n        }\n      }\n      if (endPointIndex == -1) {\n        throw new IllegalArgumentException(\"Polygon points are all coplanar\");\n      }\n      final GeoPoint check = points.get(endPointIndex);\n      //System.out.println(\"Created edge \"+sp+\" using start=\"+start+\" end=\"+end+\" check=\"+check);\n      edges[i] = new SidedPlane(check, false, start, end);\n      invertedEdges[i] = new SidedPlane(edges[i]);\n      notableEdgePoints[i] = new GeoPoint[]{start, end};\n    }\n    \n    // For each edge, create a bounds object.\n    eitherBounds = new HashMap<>(edges.length);\n    intersectionBounds = new HashMap<>(edges.length);\n    edgePlanes = new HashMap<>(edges.length);\n    for (int edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {\n      final SidedPlane edge = edges[edgeIndex];\n      final SidedPlane invertedEdge = invertedEdges[edgeIndex];\n      int bound1Index = legalIndex(edgeIndex+1);\n      while (invertedEdges[legalIndex(bound1Index)].isNumericallyIdentical(invertedEdge)) {\n        bound1Index++;\n      }\n      int bound2Index = legalIndex(edgeIndex-1);\n      int otherIndex = bound2Index;\n      final SidedPlane otherEdge;\n      final SidedPlane otherInvertedEdge;\n      if (invertedEdges[legalIndex(otherIndex)].isNumericallyIdentical(invertedEdge)) {\n        otherInvertedEdge = null;\n        otherEdge = null;\n      } else {\n        otherInvertedEdge = invertedEdges[legalIndex(otherIndex)];\n        otherEdge = edges[legalIndex(otherIndex)];\n      }\n      while (invertedEdges[legalIndex(bound2Index)].isNumericallyIdentical(invertedEdge)) {\n        bound2Index--;\n      }\n      eitherBounds.put(edge, new EitherBound(invertedEdges[legalIndex(bound1Index)], invertedEdges[legalIndex(bound2Index)]));\n      // For intersections, we look at the point at the intersection between the previous edge and this one.  We need to locate the \n      // Intersection bounds needs to look even further forwards/backwards\n      if (otherInvertedEdge != null) {\n        while (invertedEdges[legalIndex(otherIndex)].isNumericallyIdentical(otherInvertedEdge)) {\n          otherIndex--;\n        }\n        intersectionBounds.put(edge, new EitherBound(invertedEdges[legalIndex(otherIndex)], invertedEdges[legalIndex(bound2Index)]));\n        edgePlanes.put(edge, otherEdge);\n      }\n    }\n\n    // Pick an edge point arbitrarily from the outer polygon.  Glom this together with all edge points from\n    // inner polygons.\n    int edgePointCount = 1;\n    if (holes != null) {\n      for (final GeoPolygon hole : holes) {\n        edgePointCount += hole.getEdgePoints().length;\n      }\n    }\n    edgePoints = new GeoPoint[edgePointCount];\n    edgePointCount = 0;\n    edgePoints[edgePointCount++] = points.get(0);\n    if (holes != null) {\n      for (final GeoPolygon hole : holes) {\n        final GeoPoint[] holeEdgePoints = hole.getEdgePoints();\n        for (final GeoPoint p : holeEdgePoints) {\n          edgePoints[edgePointCount++] = p;\n        }\n      }\n    }\n\n    if (isWithinHoles(points.get(0))) {\n      throw new IllegalArgumentException(\"Polygon edge intersects a polygon hole; not allowed\");\n    }\n\n  }\n\n","bugFix":["f73835ebb1e6bfb1a963660f1ff4e25aa7a0a49d"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f9369473490cca80a5b92824279ebc7df00dc255","date":1472162990,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoConcavePolygon#done(boolean).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoConcavePolygon#done(boolean).mjava","sourceNew":"  /**\n   * Finish the polygon, by connecting the last added point with the starting point.\n   *@param isInternalReturnEdge is true if the return edge (back to start) is an internal one.\n   */\n  public void done(final boolean isInternalReturnEdge) {\n    if (isDone)\n      throw new IllegalStateException(\"Can't call done() more than once\");\n    // If fewer than 3 points, can't do it.\n    if (points.size() < 3)\n      throw new IllegalArgumentException(\"Polygon needs at least three points.\");\n\n    if (isInternalReturnEdge)\n      isInternalEdges.set(points.size() - 1);\n\n    isDone = true;\n    \n    // Time to construct the planes.  If the polygon is truly concave then any adjacent point\n    // to a segment can provide an exterior measurement.  Note: We build the true planes\n    // here and use the logic to return what *isn't* inside all of them.\n    edges = new SidedPlane[points.size()];\n    invertedEdges = new SidedPlane[points.size()];\n    notableEdgePoints = new GeoPoint[points.size()][];\n\n    for (int i = 0; i < points.size(); i++) {\n      final GeoPoint start = points.get(i);\n      final GeoPoint end = points.get(legalIndex(i + 1));\n      // We have to find the next point that is not on the plane between start and end.\n      // If there is no such point, it's an error.\n      final Plane planeToFind = new Plane(start, end);\n      int endPointIndex = -1;\n      for (int j = 0; j < points.size(); j++) {\n        final int index = legalIndex(j + i + 2);\n        if (!planeToFind.evaluateIsZero(points.get(index))) {\n          endPointIndex = index;\n          break;\n        }\n      }\n      if (endPointIndex == -1) {\n        throw new IllegalArgumentException(\"Polygon points are all coplanar\");\n      }\n      final GeoPoint check = points.get(endPointIndex);\n      //System.out.println(\"Created edge \"+sp+\" using start=\"+start+\" end=\"+end+\" check=\"+check);\n      edges[i] = new SidedPlane(check, false, start, end);\n      invertedEdges[i] = new SidedPlane(edges[i]);\n      notableEdgePoints[i] = new GeoPoint[]{start, end};\n    }\n    \n    // For each edge, create a bounds object.\n    eitherBounds = new HashMap<>(edges.length);\n    prevBrotherMap = new HashMap<>(edges.length);\n    nextBrotherMap = new HashMap<>(edges.length);\n    for (int edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {\n      final SidedPlane edge = edges[edgeIndex];\n      final SidedPlane invertedEdge = invertedEdges[edgeIndex];\n      int bound1Index = legalIndex(edgeIndex+1);\n      while (invertedEdges[legalIndex(bound1Index)].isNumericallyIdentical(invertedEdge)) {\n        bound1Index++;\n      }\n      int bound2Index = legalIndex(edgeIndex-1);\n      while (invertedEdges[legalIndex(bound2Index)].isNumericallyIdentical(invertedEdge)) {\n        bound2Index--;\n      }\n      bound1Index = legalIndex(bound1Index);\n      bound2Index = legalIndex(bound2Index);\n      // Also confirm that all interior points are within the bounds\n      int startingIndex = bound2Index;\n      while (true) {\n        startingIndex = legalIndex(startingIndex+1);\n        if (startingIndex == bound1Index) {\n          break;\n        }\n        final GeoPoint interiorPoint = points.get(startingIndex);\n        if (!invertedEdges[bound1Index].isWithin(interiorPoint) || !invertedEdges[bound2Index].isWithin(interiorPoint)) {\n          throw new IllegalArgumentException(\"Concave polygon has a side that is more than 180 degrees\");\n        }\n      }\n      eitherBounds.put(edge, new EitherBound(invertedEdges[bound1Index], invertedEdges[bound2Index]));\n      // When we are done with this cycle, we'll need to build the intersection bound for each edge and its brother.\n      // For now, keep track of the relationships.\n      nextBrotherMap.put(invertedEdge, invertedEdges[bound1Index]);\n      prevBrotherMap.put(invertedEdge, invertedEdges[bound2Index]);\n    }\n\n    // Pick an edge point arbitrarily from the outer polygon.  Glom this together with all edge points from\n    // inner polygons.\n    int edgePointCount = 1;\n    if (holes != null) {\n      for (final GeoPolygon hole : holes) {\n        edgePointCount += hole.getEdgePoints().length;\n      }\n    }\n    edgePoints = new GeoPoint[edgePointCount];\n    edgePointCount = 0;\n    edgePoints[edgePointCount++] = points.get(0);\n    if (holes != null) {\n      for (final GeoPolygon hole : holes) {\n        final GeoPoint[] holeEdgePoints = hole.getEdgePoints();\n        for (final GeoPoint p : holeEdgePoints) {\n          edgePoints[edgePointCount++] = p;\n        }\n      }\n    }\n\n    if (isWithinHoles(points.get(0))) {\n      throw new IllegalArgumentException(\"Polygon edge intersects a polygon hole; not allowed\");\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Finish the polygon, by connecting the last added point with the starting point.\n   *@param isInternalReturnEdge is true if the return edge (back to start) is an internal one.\n   */\n  public void done(final boolean isInternalReturnEdge) {\n    if (isDone)\n      throw new IllegalStateException(\"Can't call done() more than once\");\n    // If fewer than 3 points, can't do it.\n    if (points.size() < 3)\n      throw new IllegalArgumentException(\"Polygon needs at least three points.\");\n\n    if (isInternalReturnEdge)\n      isInternalEdges.set(points.size() - 1);\n\n    isDone = true;\n    \n    // Time to construct the planes.  If the polygon is truly concave then any adjacent point\n    // to a segment can provide an exterior measurement.  Note: We build the true planes\n    // here and use the logic to return what *isn't* inside all of them.\n    edges = new SidedPlane[points.size()];\n    invertedEdges = new SidedPlane[points.size()];\n    notableEdgePoints = new GeoPoint[points.size()][];\n\n    for (int i = 0; i < points.size(); i++) {\n      final GeoPoint start = points.get(i);\n      final GeoPoint end = points.get(legalIndex(i + 1));\n      // We have to find the next point that is not on the plane between start and end.\n      // If there is no such point, it's an error.\n      final Plane planeToFind = new Plane(start, end);\n      int endPointIndex = -1;\n      for (int j = 0; j < points.size(); j++) {\n        final int index = legalIndex(j + i + 2);\n        if (!planeToFind.evaluateIsZero(points.get(index))) {\n          endPointIndex = index;\n          break;\n        }\n      }\n      if (endPointIndex == -1) {\n        throw new IllegalArgumentException(\"Polygon points are all coplanar\");\n      }\n      final GeoPoint check = points.get(endPointIndex);\n      //System.out.println(\"Created edge \"+sp+\" using start=\"+start+\" end=\"+end+\" check=\"+check);\n      edges[i] = new SidedPlane(check, false, start, end);\n      invertedEdges[i] = new SidedPlane(edges[i]);\n      notableEdgePoints[i] = new GeoPoint[]{start, end};\n    }\n    \n    // For each edge, create a bounds object.\n    eitherBounds = new HashMap<>(edges.length);\n    intersectionBounds = new HashMap<>(edges.length);\n    edgePlanes = new HashMap<>(edges.length);\n    for (int edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {\n      final SidedPlane edge = edges[edgeIndex];\n      final SidedPlane invertedEdge = invertedEdges[edgeIndex];\n      int bound1Index = legalIndex(edgeIndex+1);\n      while (invertedEdges[legalIndex(bound1Index)].isNumericallyIdentical(invertedEdge)) {\n        bound1Index++;\n      }\n      int bound2Index = legalIndex(edgeIndex-1);\n      int otherIndex = bound2Index;\n      final SidedPlane otherEdge;\n      final SidedPlane otherInvertedEdge;\n      if (invertedEdges[legalIndex(otherIndex)].isNumericallyIdentical(invertedEdge)) {\n        otherInvertedEdge = null;\n        otherEdge = null;\n      } else {\n        otherInvertedEdge = invertedEdges[legalIndex(otherIndex)];\n        otherEdge = edges[legalIndex(otherIndex)];\n      }\n      while (invertedEdges[legalIndex(bound2Index)].isNumericallyIdentical(invertedEdge)) {\n        bound2Index--;\n      }\n      bound1Index = legalIndex(bound1Index);\n      bound2Index = legalIndex(bound2Index);\n      // Also confirm that all interior points are within the bounds\n      int startingIndex = bound2Index;\n      while (true) {\n        startingIndex = legalIndex(startingIndex+1);\n        if (startingIndex == bound1Index) {\n          break;\n        }\n        final GeoPoint interiorPoint = points.get(startingIndex);\n        if (!invertedEdges[bound1Index].isWithin(interiorPoint) || !invertedEdges[bound2Index].isWithin(interiorPoint)) {\n          throw new IllegalArgumentException(\"Concave polygon has a side that is more than 180 degrees\");\n        }\n      }\n      eitherBounds.put(edge, new EitherBound(invertedEdges[bound1Index], invertedEdges[bound2Index]));\n      // For intersections, we look at the point at the intersection between the previous edge and this one.  We need to locate the \n      // Intersection bounds needs to look even further forwards/backwards\n      if (otherInvertedEdge != null) {\n        while (invertedEdges[legalIndex(otherIndex)].isNumericallyIdentical(otherInvertedEdge)) {\n          otherIndex--;\n        }\n        intersectionBounds.put(edge, new EitherBound(invertedEdges[legalIndex(otherIndex)], invertedEdges[legalIndex(bound2Index)]));\n        edgePlanes.put(edge, otherEdge);\n      }\n    }\n\n    // Pick an edge point arbitrarily from the outer polygon.  Glom this together with all edge points from\n    // inner polygons.\n    int edgePointCount = 1;\n    if (holes != null) {\n      for (final GeoPolygon hole : holes) {\n        edgePointCount += hole.getEdgePoints().length;\n      }\n    }\n    edgePoints = new GeoPoint[edgePointCount];\n    edgePointCount = 0;\n    edgePoints[edgePointCount++] = points.get(0);\n    if (holes != null) {\n      for (final GeoPolygon hole : holes) {\n        final GeoPoint[] holeEdgePoints = hole.getEdgePoints();\n        for (final GeoPoint p : holeEdgePoints) {\n          edgePoints[edgePointCount++] = p;\n        }\n      }\n    }\n\n    if (isWithinHoles(points.get(0))) {\n      throw new IllegalArgumentException(\"Polygon edge intersects a polygon hole; not allowed\");\n    }\n\n  }\n\n","bugFix":["bd7a250b817d38fdb6f0411589342b46d249c5cf"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoConcavePolygon#done(boolean).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoConcavePolygon#done(boolean).mjava","sourceNew":"  /**\n   * Finish the polygon, by connecting the last added point with the starting point.\n   *@param isInternalReturnEdge is true if the return edge (back to start) is an internal one.\n   */\n  public void done(final boolean isInternalReturnEdge) {\n    if (isDone)\n      throw new IllegalStateException(\"Can't call done() more than once\");\n    // If fewer than 3 points, can't do it.\n    if (points.size() < 3)\n      throw new IllegalArgumentException(\"Polygon needs at least three points.\");\n\n    if (isInternalReturnEdge)\n      isInternalEdges.set(points.size() - 1);\n\n    isDone = true;\n    \n    // Time to construct the planes.  If the polygon is truly concave then any adjacent point\n    // to a segment can provide an exterior measurement.  Note: We build the true planes\n    // here and use the logic to return what *isn't* inside all of them.\n    edges = new SidedPlane[points.size()];\n    invertedEdges = new SidedPlane[points.size()];\n    notableEdgePoints = new GeoPoint[points.size()][];\n\n    for (int i = 0; i < points.size(); i++) {\n      final GeoPoint start = points.get(i);\n      final GeoPoint end = points.get(legalIndex(i + 1));\n      // We have to find the next point that is not on the plane between start and end.\n      // If there is no such point, it's an error.\n      final Plane planeToFind = new Plane(start, end);\n      int endPointIndex = -1;\n      for (int j = 0; j < points.size(); j++) {\n        final int index = legalIndex(j + i + 2);\n        if (!planeToFind.evaluateIsZero(points.get(index))) {\n          endPointIndex = index;\n          break;\n        }\n      }\n      if (endPointIndex == -1) {\n        throw new IllegalArgumentException(\"Polygon points are all coplanar\");\n      }\n      final GeoPoint check = points.get(endPointIndex);\n      //System.out.println(\"Created edge \"+sp+\" using start=\"+start+\" end=\"+end+\" check=\"+check);\n      edges[i] = new SidedPlane(check, false, start, end);\n      invertedEdges[i] = new SidedPlane(edges[i]);\n      notableEdgePoints[i] = new GeoPoint[]{start, end};\n    }\n    \n    // For each edge, create a bounds object.\n    eitherBounds = new HashMap<>(edges.length);\n    prevBrotherMap = new HashMap<>(edges.length);\n    nextBrotherMap = new HashMap<>(edges.length);\n    for (int edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {\n      final SidedPlane edge = edges[edgeIndex];\n      final SidedPlane invertedEdge = invertedEdges[edgeIndex];\n      int bound1Index = legalIndex(edgeIndex+1);\n      while (invertedEdges[legalIndex(bound1Index)].isNumericallyIdentical(invertedEdge)) {\n        bound1Index++;\n      }\n      int bound2Index = legalIndex(edgeIndex-1);\n      while (invertedEdges[legalIndex(bound2Index)].isNumericallyIdentical(invertedEdge)) {\n        bound2Index--;\n      }\n      bound1Index = legalIndex(bound1Index);\n      bound2Index = legalIndex(bound2Index);\n      // Also confirm that all interior points are within the bounds\n      int startingIndex = bound2Index;\n      while (true) {\n        startingIndex = legalIndex(startingIndex+1);\n        if (startingIndex == bound1Index) {\n          break;\n        }\n        final GeoPoint interiorPoint = points.get(startingIndex);\n        if (!invertedEdges[bound1Index].isWithin(interiorPoint) || !invertedEdges[bound2Index].isWithin(interiorPoint)) {\n          throw new IllegalArgumentException(\"Concave polygon has a side that is more than 180 degrees\");\n        }\n      }\n      eitherBounds.put(edge, new EitherBound(invertedEdges[bound1Index], invertedEdges[bound2Index]));\n      // When we are done with this cycle, we'll need to build the intersection bound for each edge and its brother.\n      // For now, keep track of the relationships.\n      nextBrotherMap.put(invertedEdge, invertedEdges[bound1Index]);\n      prevBrotherMap.put(invertedEdge, invertedEdges[bound2Index]);\n    }\n\n    // Pick an edge point arbitrarily from the outer polygon.  Glom this together with all edge points from\n    // inner polygons.\n    int edgePointCount = 1;\n    if (holes != null) {\n      for (final GeoPolygon hole : holes) {\n        edgePointCount += hole.getEdgePoints().length;\n      }\n    }\n    edgePoints = new GeoPoint[edgePointCount];\n    edgePointCount = 0;\n    edgePoints[edgePointCount++] = points.get(0);\n    if (holes != null) {\n      for (final GeoPolygon hole : holes) {\n        final GeoPoint[] holeEdgePoints = hole.getEdgePoints();\n        for (final GeoPoint p : holeEdgePoints) {\n          edgePoints[edgePointCount++] = p;\n        }\n      }\n    }\n\n    if (isWithinHoles(points.get(0))) {\n      throw new IllegalArgumentException(\"Polygon edge intersects a polygon hole; not allowed\");\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Finish the polygon, by connecting the last added point with the starting point.\n   *@param isInternalReturnEdge is true if the return edge (back to start) is an internal one.\n   */\n  public void done(final boolean isInternalReturnEdge) {\n    if (isDone)\n      throw new IllegalStateException(\"Can't call done() more than once\");\n    // If fewer than 3 points, can't do it.\n    if (points.size() < 3)\n      throw new IllegalArgumentException(\"Polygon needs at least three points.\");\n\n    if (isInternalReturnEdge)\n      isInternalEdges.set(points.size() - 1);\n\n    isDone = true;\n    \n    // Time to construct the planes.  If the polygon is truly concave then any adjacent point\n    // to a segment can provide an exterior measurement.  Note: We build the true planes\n    // here and use the logic to return what *isn't* inside all of them.\n    edges = new SidedPlane[points.size()];\n    invertedEdges = new SidedPlane[points.size()];\n    notableEdgePoints = new GeoPoint[points.size()][];\n\n    for (int i = 0; i < points.size(); i++) {\n      final GeoPoint start = points.get(i);\n      final GeoPoint end = points.get(legalIndex(i + 1));\n      // We have to find the next point that is not on the plane between start and end.\n      // If there is no such point, it's an error.\n      final Plane planeToFind = new Plane(start, end);\n      int endPointIndex = -1;\n      for (int j = 0; j < points.size(); j++) {\n        final int index = legalIndex(j + i + 2);\n        if (!planeToFind.evaluateIsZero(points.get(index))) {\n          endPointIndex = index;\n          break;\n        }\n      }\n      if (endPointIndex == -1) {\n        throw new IllegalArgumentException(\"Polygon points are all coplanar\");\n      }\n      final GeoPoint check = points.get(endPointIndex);\n      //System.out.println(\"Created edge \"+sp+\" using start=\"+start+\" end=\"+end+\" check=\"+check);\n      edges[i] = new SidedPlane(check, false, start, end);\n      invertedEdges[i] = new SidedPlane(edges[i]);\n      notableEdgePoints[i] = new GeoPoint[]{start, end};\n    }\n    \n    // For each edge, create a bounds object.\n    eitherBounds = new HashMap<>(edges.length);\n    for (int edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {\n      final SidedPlane edge = edges[edgeIndex];\n      final SidedPlane invertedEdge = invertedEdges[edgeIndex];\n      int bound1Index = legalIndex(edgeIndex+1);\n      while (invertedEdges[legalIndex(bound1Index)].isNumericallyIdentical(invertedEdge)) {\n        bound1Index++;\n      }\n      int bound2Index = legalIndex(edgeIndex-1);\n      while (invertedEdges[legalIndex(bound2Index)].isNumericallyIdentical(invertedEdge)) {\n        bound2Index--;\n      }\n      eitherBounds.put(edge, new EitherBound(invertedEdges[legalIndex(bound1Index)], invertedEdges[legalIndex(bound2Index)]));\n    }\n\n    // Pick an edge point arbitrarily from the outer polygon.  Glom this together with all edge points from\n    // inner polygons.\n    int edgePointCount = 1;\n    if (holes != null) {\n      for (final GeoPolygon hole : holes) {\n        edgePointCount += hole.getEdgePoints().length;\n      }\n    }\n    edgePoints = new GeoPoint[edgePointCount];\n    edgePointCount = 0;\n    edgePoints[edgePointCount++] = points.get(0);\n    if (holes != null) {\n      for (final GeoPolygon hole : holes) {\n        final GeoPoint[] holeEdgePoints = hole.getEdgePoints();\n        for (final GeoPoint p : holeEdgePoints) {\n          edgePoints[edgePointCount++] = p;\n        }\n      }\n    }\n\n    if (isWithinHoles(points.get(0))) {\n      throw new IllegalArgumentException(\"Polygon edge intersects a polygon hole; not allowed\");\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"44c3a4ebfa1a780298de8b00afc0722c16233080","date":1522505029,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoConcavePolygon#done(boolean).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoConcavePolygon#done(boolean).mjava","sourceNew":"  /**\n   * Finish the polygon, by connecting the last added point with the starting point.\n   *@param isInternalReturnEdge is true if the return edge (back to start) is an internal one.\n   */\n  public void done(final boolean isInternalReturnEdge) {\n    if (isDone)\n      throw new IllegalStateException(\"Can't call done() more than once\");\n    // If fewer than 3 points, can't do it.\n    if (points.size() < 3)\n      throw new IllegalArgumentException(\"Polygon needs at least three points.\");\n\n    if (isInternalReturnEdge)\n      isInternalEdges.set(points.size() - 1);\n\n    isDone = true;\n    \n    // Time to construct the planes.  If the polygon is truly concave then any adjacent point\n    // to a segment can provide an exterior measurement.  Note: We build the true planes\n    // here and use the logic to return what *isn't* inside all of them.\n    edges = new SidedPlane[points.size()];\n    invertedEdges = new SidedPlane[points.size()];\n    notableEdgePoints = new GeoPoint[points.size()][];\n\n    for (int i = 0; i < points.size(); i++) {\n      final GeoPoint start = points.get(i);\n      final GeoPoint end = points.get(legalIndex(i + 1));\n      // We have to find the next point that is not on the plane between start and end.\n      // If there is no such point, it's an error.\n      final Plane planeToFind = new Plane(start, end);\n      int endPointIndex = -1;\n      for (int j = 0; j < points.size(); j++) {\n        final int index = legalIndex(j + i + 2);\n        if (!planeToFind.evaluateIsZero(points.get(index))) {\n          endPointIndex = index;\n          break;\n        }\n      }\n      if (endPointIndex == -1) {\n        throw new IllegalArgumentException(\"Polygon points are all coplanar\");\n      }\n      final GeoPoint check = points.get(endPointIndex);\n      //System.out.println(\"Created edge \"+sp+\" using start=\"+start+\" end=\"+end+\" check=\"+check);\n      edges[i] = new SidedPlane(check, false, start, end);\n      invertedEdges[i] = new SidedPlane(edges[i]);\n      notableEdgePoints[i] = new GeoPoint[]{start, end};\n    }\n    \n    // For each edge, create a bounds object.\n    eitherBounds = new HashMap<>(edges.length);\n    prevBrotherMap = new HashMap<>(edges.length);\n    nextBrotherMap = new HashMap<>(edges.length);\n    for (int edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {\n      final SidedPlane edge = edges[edgeIndex];\n      final SidedPlane invertedEdge = invertedEdges[edgeIndex];\n      int bound1Index = legalIndex(edgeIndex+1);\n      while (invertedEdges[bound1Index].isNumericallyIdentical(invertedEdge)) {\n        if (bound1Index == edgeIndex) {\n          throw new IllegalArgumentException(\"Constructed planes are all coplanar: \"+points);\n        }\n        bound1Index = legalIndex(bound1Index + 1);\n      }\n      int bound2Index = legalIndex(edgeIndex-1);\n      while (invertedEdges[bound2Index].isNumericallyIdentical(invertedEdge)) {\n        if (bound2Index == edgeIndex) {\n          throw new IllegalArgumentException(\"Constructed planes are all coplanar: \"+points);\n        }\n        bound2Index = legalIndex(bound2Index - 1);\n      }\n      // Also confirm that all interior points are within the bounds\n      int startingIndex = bound2Index;\n      while (true) {\n        startingIndex = legalIndex(startingIndex+1);\n        if (startingIndex == bound1Index) {\n          break;\n        }\n        final GeoPoint interiorPoint = points.get(startingIndex);\n        if (!invertedEdges[bound1Index].isWithin(interiorPoint) || !invertedEdges[bound2Index].isWithin(interiorPoint)) {\n          throw new IllegalArgumentException(\"Concave polygon has a side that is more than 180 degrees\");\n        }\n      }\n      eitherBounds.put(edge, new EitherBound(invertedEdges[bound1Index], invertedEdges[bound2Index]));\n      // When we are done with this cycle, we'll need to build the intersection bound for each edge and its brother.\n      // For now, keep track of the relationships.\n      nextBrotherMap.put(invertedEdge, invertedEdges[bound1Index]);\n      prevBrotherMap.put(invertedEdge, invertedEdges[bound2Index]);\n    }\n\n    // Pick an edge point arbitrarily from the outer polygon.  Glom this together with all edge points from\n    // inner polygons.\n    int edgePointCount = 1;\n    if (holes != null) {\n      for (final GeoPolygon hole : holes) {\n        edgePointCount += hole.getEdgePoints().length;\n      }\n    }\n    edgePoints = new GeoPoint[edgePointCount];\n    edgePointCount = 0;\n    edgePoints[edgePointCount++] = points.get(0);\n    if (holes != null) {\n      for (final GeoPolygon hole : holes) {\n        final GeoPoint[] holeEdgePoints = hole.getEdgePoints();\n        for (final GeoPoint p : holeEdgePoints) {\n          edgePoints[edgePointCount++] = p;\n        }\n      }\n    }\n\n    if (isWithinHoles(points.get(0))) {\n      throw new IllegalArgumentException(\"Polygon edge intersects a polygon hole; not allowed\");\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Finish the polygon, by connecting the last added point with the starting point.\n   *@param isInternalReturnEdge is true if the return edge (back to start) is an internal one.\n   */\n  public void done(final boolean isInternalReturnEdge) {\n    if (isDone)\n      throw new IllegalStateException(\"Can't call done() more than once\");\n    // If fewer than 3 points, can't do it.\n    if (points.size() < 3)\n      throw new IllegalArgumentException(\"Polygon needs at least three points.\");\n\n    if (isInternalReturnEdge)\n      isInternalEdges.set(points.size() - 1);\n\n    isDone = true;\n    \n    // Time to construct the planes.  If the polygon is truly concave then any adjacent point\n    // to a segment can provide an exterior measurement.  Note: We build the true planes\n    // here and use the logic to return what *isn't* inside all of them.\n    edges = new SidedPlane[points.size()];\n    invertedEdges = new SidedPlane[points.size()];\n    notableEdgePoints = new GeoPoint[points.size()][];\n\n    for (int i = 0; i < points.size(); i++) {\n      final GeoPoint start = points.get(i);\n      final GeoPoint end = points.get(legalIndex(i + 1));\n      // We have to find the next point that is not on the plane between start and end.\n      // If there is no such point, it's an error.\n      final Plane planeToFind = new Plane(start, end);\n      int endPointIndex = -1;\n      for (int j = 0; j < points.size(); j++) {\n        final int index = legalIndex(j + i + 2);\n        if (!planeToFind.evaluateIsZero(points.get(index))) {\n          endPointIndex = index;\n          break;\n        }\n      }\n      if (endPointIndex == -1) {\n        throw new IllegalArgumentException(\"Polygon points are all coplanar\");\n      }\n      final GeoPoint check = points.get(endPointIndex);\n      //System.out.println(\"Created edge \"+sp+\" using start=\"+start+\" end=\"+end+\" check=\"+check);\n      edges[i] = new SidedPlane(check, false, start, end);\n      invertedEdges[i] = new SidedPlane(edges[i]);\n      notableEdgePoints[i] = new GeoPoint[]{start, end};\n    }\n    \n    // For each edge, create a bounds object.\n    eitherBounds = new HashMap<>(edges.length);\n    prevBrotherMap = new HashMap<>(edges.length);\n    nextBrotherMap = new HashMap<>(edges.length);\n    for (int edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {\n      final SidedPlane edge = edges[edgeIndex];\n      final SidedPlane invertedEdge = invertedEdges[edgeIndex];\n      int bound1Index = legalIndex(edgeIndex+1);\n      while (invertedEdges[legalIndex(bound1Index)].isNumericallyIdentical(invertedEdge)) {\n        bound1Index++;\n      }\n      int bound2Index = legalIndex(edgeIndex-1);\n      while (invertedEdges[legalIndex(bound2Index)].isNumericallyIdentical(invertedEdge)) {\n        bound2Index--;\n      }\n      bound1Index = legalIndex(bound1Index);\n      bound2Index = legalIndex(bound2Index);\n      // Also confirm that all interior points are within the bounds\n      int startingIndex = bound2Index;\n      while (true) {\n        startingIndex = legalIndex(startingIndex+1);\n        if (startingIndex == bound1Index) {\n          break;\n        }\n        final GeoPoint interiorPoint = points.get(startingIndex);\n        if (!invertedEdges[bound1Index].isWithin(interiorPoint) || !invertedEdges[bound2Index].isWithin(interiorPoint)) {\n          throw new IllegalArgumentException(\"Concave polygon has a side that is more than 180 degrees\");\n        }\n      }\n      eitherBounds.put(edge, new EitherBound(invertedEdges[bound1Index], invertedEdges[bound2Index]));\n      // When we are done with this cycle, we'll need to build the intersection bound for each edge and its brother.\n      // For now, keep track of the relationships.\n      nextBrotherMap.put(invertedEdge, invertedEdges[bound1Index]);\n      prevBrotherMap.put(invertedEdge, invertedEdges[bound2Index]);\n    }\n\n    // Pick an edge point arbitrarily from the outer polygon.  Glom this together with all edge points from\n    // inner polygons.\n    int edgePointCount = 1;\n    if (holes != null) {\n      for (final GeoPolygon hole : holes) {\n        edgePointCount += hole.getEdgePoints().length;\n      }\n    }\n    edgePoints = new GeoPoint[edgePointCount];\n    edgePointCount = 0;\n    edgePoints[edgePointCount++] = points.get(0);\n    if (holes != null) {\n      for (final GeoPolygon hole : holes) {\n        final GeoPoint[] holeEdgePoints = hole.getEdgePoints();\n        for (final GeoPoint p : holeEdgePoints) {\n          edgePoints[edgePointCount++] = p;\n        }\n      }\n    }\n\n    if (isWithinHoles(points.get(0))) {\n      throw new IllegalArgumentException(\"Polygon edge intersects a polygon hole; not allowed\");\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"54e10c9f59e9af43a3d623fc58c2d3790f0f5cfb":["bd7a250b817d38fdb6f0411589342b46d249c5cf"],"f7f901826e47f75f810d7aae24b0455d21ea1fe2":["9d2d72e1014f51e87658946e08272b7efd0d52e7","ba81c43c13d92ea74a6388471cf358eb7068744d"],"9d2d72e1014f51e87658946e08272b7efd0d52e7":["f73835ebb1e6bfb1a963660f1ff4e25aa7a0a49d"],"bd7a250b817d38fdb6f0411589342b46d249c5cf":["f7f901826e47f75f810d7aae24b0455d21ea1fe2"],"f9369473490cca80a5b92824279ebc7df00dc255":["54e10c9f59e9af43a3d623fc58c2d3790f0f5cfb"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["f7f901826e47f75f810d7aae24b0455d21ea1fe2","f9369473490cca80a5b92824279ebc7df00dc255"],"44c3a4ebfa1a780298de8b00afc0722c16233080":["f9369473490cca80a5b92824279ebc7df00dc255"],"09af2c9610ce53a4b25fd99344299b40318a4a1a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","40aa98241c87d86a0077beb8023713d93a0becfe"],"dc584fa95053c03d95035277a2d2aaddd537c0fa":["835b6983e267a46cbc7d3d7d82b46b2eb9a32d1e"],"835b6983e267a46cbc7d3d7d82b46b2eb9a32d1e":["40aa98241c87d86a0077beb8023713d93a0becfe"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b325b9a50d0c88c91837edc3cf8e11a5216e897a":["9d2d72e1014f51e87658946e08272b7efd0d52e7"],"40aa98241c87d86a0077beb8023713d93a0becfe":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f73835ebb1e6bfb1a963660f1ff4e25aa7a0a49d":["dc584fa95053c03d95035277a2d2aaddd537c0fa"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["44c3a4ebfa1a780298de8b00afc0722c16233080"],"ba81c43c13d92ea74a6388471cf358eb7068744d":["b325b9a50d0c88c91837edc3cf8e11a5216e897a"]},"commit2Childs":{"54e10c9f59e9af43a3d623fc58c2d3790f0f5cfb":["f9369473490cca80a5b92824279ebc7df00dc255"],"f7f901826e47f75f810d7aae24b0455d21ea1fe2":["bd7a250b817d38fdb6f0411589342b46d249c5cf","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"9d2d72e1014f51e87658946e08272b7efd0d52e7":["f7f901826e47f75f810d7aae24b0455d21ea1fe2","b325b9a50d0c88c91837edc3cf8e11a5216e897a"],"bd7a250b817d38fdb6f0411589342b46d249c5cf":["54e10c9f59e9af43a3d623fc58c2d3790f0f5cfb"],"f9369473490cca80a5b92824279ebc7df00dc255":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","44c3a4ebfa1a780298de8b00afc0722c16233080"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"44c3a4ebfa1a780298de8b00afc0722c16233080":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"09af2c9610ce53a4b25fd99344299b40318a4a1a":[],"dc584fa95053c03d95035277a2d2aaddd537c0fa":["f73835ebb1e6bfb1a963660f1ff4e25aa7a0a49d"],"835b6983e267a46cbc7d3d7d82b46b2eb9a32d1e":["dc584fa95053c03d95035277a2d2aaddd537c0fa"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["09af2c9610ce53a4b25fd99344299b40318a4a1a","40aa98241c87d86a0077beb8023713d93a0becfe"],"b325b9a50d0c88c91837edc3cf8e11a5216e897a":["ba81c43c13d92ea74a6388471cf358eb7068744d"],"40aa98241c87d86a0077beb8023713d93a0becfe":["09af2c9610ce53a4b25fd99344299b40318a4a1a","835b6983e267a46cbc7d3d7d82b46b2eb9a32d1e"],"f73835ebb1e6bfb1a963660f1ff4e25aa7a0a49d":["9d2d72e1014f51e87658946e08272b7efd0d52e7"],"ba81c43c13d92ea74a6388471cf358eb7068744d":["f7f901826e47f75f810d7aae24b0455d21ea1fe2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","09af2c9610ce53a4b25fd99344299b40318a4a1a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}