{"path":"contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/GDataServerRegistry#[E-extends-ServerComponent]_registerComponent(Class[E],ComponentConfiguration).mjava","commits":[{"id":"4055ae1e0f6bbe8fa4c1069a11adee5e57b518fe","date":1166036663,"type":1,"author":"Simon Willnauer","isMerge":false,"pathNew":"contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/GDataServerRegistry#[E-extends-ServerComponent]_registerComponent(Class[E],ComponentConfiguration).mjava","pathOld":"contrib/gdata-server/src/core/java/org/apache/lucene/gdata/server/registry/GDataServerRegistry#[E-extends-ServerComponent]_registerComponent(Class[E],ComponentConfiguration).mjava","sourceNew":"    /**\n     * All registered {@link ServerComponent} registered via this method are\n     * available via the\n     * {@link GDataServerRegistry#lookup(Class, ComponentType)} method. For each\n     * {@link ComponentType} there will be one single instance registered in the\n     * registry.\n     * <p>\n     * Eventually this method invokes the initialize method of the\n     * ServerComponent interface to prepare the component to be available via\n     * the lookup service\n     * </p>\n     * \n     * @param <E> -\n     *            The interface of the component to register\n     * @param componentClass -\n     *            a implementation of a ServerComponent interface to register in\n     *            the registry\n     * @param configuration -\n     *            the component configuration {@link ComponentConfiguration}\n     * @throws RegistryException -\n     *             if the provided class does not implement the\n     *             {@link ServerComponent} interface, if the mandatory\n     *             annotations not visible at runtime or not set, if the super\n     *             type provided by the {@link ComponentType} for the class to\n     *             register is not a super type of the class or if the\n     *             invocation of the {@link ServerComponent#initialize()} method\n     *             throws an exception.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <E extends ServerComponent> void registerComponent(\n            final Class<E> componentClass,\n            final ComponentConfiguration configuration)\n            throws RegistryException {\n\n        if (componentClass == null)\n            throw new IllegalArgumentException(\n                    \"component class must not be null\");\n\n        if (!ReflectionUtils.implementsType(componentClass,\n                ServerComponent.class))\n            throw new RegistryException(\n                    \"can not register component. the given class does not implement ServerComponent interface -- \"\n                            + componentClass.getName());\n        try {\n\n            Component annotation = componentClass\n                    .getAnnotation(Component.class);\n            if (annotation == null)\n                throw new RegistryException(\n                        \"can not register component. the given class is not a component -- \"\n                                + componentClass.getName());\n            ComponentType type = annotation.componentType();\n            if (this.componentMap.containsKey(type))\n                throw new RegistryException(\"component already registered -- \"\n                        + type.name());\n            Class superType = type.getClass().getField(type.name())\n                    .getAnnotation(SuperType.class).superType();\n            if (!ReflectionUtils.isTypeOf(componentClass, superType))\n                throw new RegistryException(\"Considered super type <\"\n                        + superType.getName() + \"> is not a super type of <\"\n                        + componentClass + \">\");\n            ServerComponent comp = componentClass.newInstance();\n            if (configuration == null) {\n                if (LOG.isInfoEnabled())\n                    LOG.info(\"no configuration for ComponentType: \"\n                            + type.name());\n            } else\n                configureComponent(comp, type, configuration);\n            comp.initialize();\n            ComponentBean bean = new ComponentBean(comp, superType);\n\n            this.componentMap.put(type, bean);\n            if (ReflectionUtils.implementsType(componentClass,\n                    ScopeVisitor.class))\n                this.registerScopeVisitor((ScopeVisitor) comp);\n        } catch (Exception e) {\n            throw new RegistryException(\"Can not register component -- \"\n                    + e.getMessage(), e);\n        }\n\n    }\n\n","sourceOld":"    /**\n     * All registered {@link ServerComponent} registered via this method are\n     * available via the\n     * {@link GDataServerRegistry#lookup(Class, ComponentType)} method. For each\n     * {@link ComponentType} there will be one single instance registered in the\n     * registry.\n     * <p>\n     * Eventually this method invokes the initialize method of the\n     * ServerComponent interface to prepare the component to be available via\n     * the lookup service\n     * </p>\n     * \n     * @param <E> -\n     *            The interface of the component to register\n     * @param componentClass -\n     *            a implementation of a ServerComponent interface to register in\n     *            the registry\n     * @param configuration -\n     *            the component configuration {@link ComponentConfiguration}\n     * @throws RegistryException -\n     *             if the provided class does not implement the\n     *             {@link ServerComponent} interface, if the mandatory\n     *             annotations not visible at runtime or not set, if the super\n     *             type provided by the {@link ComponentType} for the class to\n     *             register is not a super type of the class or if the\n     *             invocation of the {@link ServerComponent#initialize()} method\n     *             throws an exception.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <E extends ServerComponent> void registerComponent(\n            final Class<E> componentClass,\n            final ComponentConfiguration configuration)\n            throws RegistryException {\n\n        if (componentClass == null)\n            throw new IllegalArgumentException(\n                    \"component class must not be null\");\n\n        if (!ReflectionUtils.implementsType(componentClass,\n                ServerComponent.class))\n            throw new RegistryException(\n                    \"can not register component. the given class does not implement ServerComponent interface -- \"\n                            + componentClass.getName());\n        try {\n\n            Component annotation = componentClass\n                    .getAnnotation(Component.class);\n            if (annotation == null)\n                throw new RegistryException(\n                        \"can not register component. the given class is not a component -- \"\n                                + componentClass.getName());\n            ComponentType type = annotation.componentType();\n            if (this.componentMap.containsKey(type))\n                throw new RegistryException(\"component already registered -- \"\n                        + type.name());\n            Class superType = type.getClass().getField(type.name())\n                    .getAnnotation(SuperType.class).superType();\n            if (!ReflectionUtils.isTypeOf(componentClass, superType))\n                throw new RegistryException(\"Considered super type <\"\n                        + superType.getName() + \"> is not a super type of <\"\n                        + componentClass + \">\");\n            ServerComponent comp = componentClass.newInstance();\n            if (configuration == null) {\n                if (LOG.isInfoEnabled())\n                    LOG.info(\"no configuration for ComponentType: \"\n                            + type.name());\n            } else\n                configureComponent(comp, type, configuration);\n            comp.initialize();\n            ComponentBean bean = new ComponentBean(comp, superType);\n\n            this.componentMap.put(type, bean);\n            if (ReflectionUtils.implementsType(componentClass,\n                    ScopeVisitor.class))\n                this.registerScopeVisitor((ScopeVisitor) comp);\n        } catch (Exception e) {\n            throw new RegistryException(\"Can not register component -- \"\n                    + e.getMessage(), e);\n        }\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"353a38bbb8d8067d74d6039986c7ce44c2f6cdbe","date":1195519587,"type":4,"author":"Michael Busch","isMerge":false,"pathNew":"/dev/null","pathOld":"contrib/gdata-server/src/core/src/java/org/apache/lucene/gdata/server/registry/GDataServerRegistry#[E-extends-ServerComponent]_registerComponent(Class[E],ComponentConfiguration).mjava","sourceNew":null,"sourceOld":"    /**\n     * All registered {@link ServerComponent} registered via this method are\n     * available via the\n     * {@link GDataServerRegistry#lookup(Class, ComponentType)} method. For each\n     * {@link ComponentType} there will be one single instance registered in the\n     * registry.\n     * <p>\n     * Eventually this method invokes the initialize method of the\n     * ServerComponent interface to prepare the component to be available via\n     * the lookup service\n     * </p>\n     * \n     * @param <E> -\n     *            The interface of the component to register\n     * @param componentClass -\n     *            a implementation of a ServerComponent interface to register in\n     *            the registry\n     * @param configuration -\n     *            the component configuration {@link ComponentConfiguration}\n     * @throws RegistryException -\n     *             if the provided class does not implement the\n     *             {@link ServerComponent} interface, if the mandatory\n     *             annotations not visible at runtime or not set, if the super\n     *             type provided by the {@link ComponentType} for the class to\n     *             register is not a super type of the class or if the\n     *             invocation of the {@link ServerComponent#initialize()} method\n     *             throws an exception.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <E extends ServerComponent> void registerComponent(\n            final Class<E> componentClass,\n            final ComponentConfiguration configuration)\n            throws RegistryException {\n\n        if (componentClass == null)\n            throw new IllegalArgumentException(\n                    \"component class must not be null\");\n\n        if (!ReflectionUtils.implementsType(componentClass,\n                ServerComponent.class))\n            throw new RegistryException(\n                    \"can not register component. the given class does not implement ServerComponent interface -- \"\n                            + componentClass.getName());\n        try {\n\n            Component annotation = componentClass\n                    .getAnnotation(Component.class);\n            if (annotation == null)\n                throw new RegistryException(\n                        \"can not register component. the given class is not a component -- \"\n                                + componentClass.getName());\n            ComponentType type = annotation.componentType();\n            if (this.componentMap.containsKey(type))\n                throw new RegistryException(\"component already registered -- \"\n                        + type.name());\n            Class superType = type.getClass().getField(type.name())\n                    .getAnnotation(SuperType.class).superType();\n            if (!ReflectionUtils.isTypeOf(componentClass, superType))\n                throw new RegistryException(\"Considered super type <\"\n                        + superType.getName() + \"> is not a super type of <\"\n                        + componentClass + \">\");\n            ServerComponent comp = componentClass.newInstance();\n            if (configuration == null) {\n                if (LOG.isInfoEnabled())\n                    LOG.info(\"no configuration for ComponentType: \"\n                            + type.name());\n            } else\n                configureComponent(comp, type, configuration);\n            comp.initialize();\n            ComponentBean bean = new ComponentBean(comp, superType);\n\n            this.componentMap.put(type, bean);\n            if (ReflectionUtils.implementsType(componentClass,\n                    ScopeVisitor.class))\n                this.registerScopeVisitor((ScopeVisitor) comp);\n        } catch (Exception e) {\n            throw new RegistryException(\"Can not register component -- \"\n                    + e.getMessage(), e);\n        }\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"4055ae1e0f6bbe8fa4c1069a11adee5e57b518fe":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"353a38bbb8d8067d74d6039986c7ce44c2f6cdbe":["4055ae1e0f6bbe8fa4c1069a11adee5e57b518fe"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["353a38bbb8d8067d74d6039986c7ce44c2f6cdbe"]},"commit2Childs":{"4055ae1e0f6bbe8fa4c1069a11adee5e57b518fe":["353a38bbb8d8067d74d6039986c7ce44c2f6cdbe"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4055ae1e0f6bbe8fa4c1069a11adee5e57b518fe"],"353a38bbb8d8067d74d6039986c7ce44c2f6cdbe":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}