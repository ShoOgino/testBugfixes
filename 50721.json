{"path":"backwards/src/java/org/apache/lucene/index/TermVectorsReader#readTermVector(String,long,TermVectorMapper).mjava","commits":[{"id":"480d01e5b0ef8efb136d51670fec297ae5ae2c9c","date":1268821447,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"backwards/src/java/org/apache/lucene/index/TermVectorsReader#readTermVector(String,long,TermVectorMapper).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * \n   * @param field The field to read in\n   * @param tvfPointer The pointer within the tvf file where we should start reading\n   * @param mapper The mapper used to map the TermVector\n   * @throws IOException\n   */ \n  private void readTermVector(String field, long tvfPointer, TermVectorMapper mapper)\n          throws IOException {\n\n    // Now read the data from specified position\n    //We don't need to offset by the FORMAT here since the pointer already includes the offset\n    tvf.seek(tvfPointer);\n\n    int numTerms = tvf.readVInt();\n    //System.out.println(\"Num Terms: \" + numTerms);\n    // If no terms - return a constant empty termvector. However, this should never occur!\n    if (numTerms == 0) \n      return;\n    \n    boolean storePositions;\n    boolean storeOffsets;\n    \n    if (format >= FORMAT_VERSION){\n      byte bits = tvf.readByte();\n      storePositions = (bits & STORE_POSITIONS_WITH_TERMVECTOR) != 0;\n      storeOffsets = (bits & STORE_OFFSET_WITH_TERMVECTOR) != 0;\n    }\n    else{\n      tvf.readVInt();\n      storePositions = false;\n      storeOffsets = false;\n    }\n    mapper.setExpectations(field, numTerms, storeOffsets, storePositions);\n    int start = 0;\n    int deltaLength = 0;\n    int totalLength = 0;\n    byte[] byteBuffer;\n    char[] charBuffer;\n    final boolean preUTF8 = format < FORMAT_UTF8_LENGTH_IN_BYTES;\n\n    // init the buffers\n    if (preUTF8) {\n      charBuffer = new char[10];\n      byteBuffer = null;\n    } else {\n      charBuffer = null;\n      byteBuffer = new byte[20];\n    }\n\n    for (int i = 0; i < numTerms; i++) {\n      start = tvf.readVInt();\n      deltaLength = tvf.readVInt();\n      totalLength = start + deltaLength;\n\n      final String term;\n      \n      if (preUTF8) {\n        // Term stored as java chars\n        if (charBuffer.length < totalLength) {\n          char[] newCharBuffer = new char[(int) (1.5*totalLength)];\n          System.arraycopy(charBuffer, 0, newCharBuffer, 0, start);\n          charBuffer = newCharBuffer;\n        }\n        tvf.readChars(charBuffer, start, deltaLength);\n        term = new String(charBuffer, 0, totalLength);\n      } else {\n        // Term stored as utf8 bytes\n        if (byteBuffer.length < totalLength) {\n          byte[] newByteBuffer = new byte[(int) (1.5*totalLength)];\n          System.arraycopy(byteBuffer, 0, newByteBuffer, 0, start);\n          byteBuffer = newByteBuffer;\n        }\n        tvf.readBytes(byteBuffer, start, deltaLength);\n        term = new String(byteBuffer, 0, totalLength, \"UTF-8\");\n      }\n      int freq = tvf.readVInt();\n      int [] positions = null;\n      if (storePositions) { //read in the positions\n        //does the mapper even care about positions?\n        if (mapper.isIgnoringPositions() == false) {\n          positions = new int[freq];\n          int prevPosition = 0;\n          for (int j = 0; j < freq; j++)\n          {\n            positions[j] = prevPosition + tvf.readVInt();\n            prevPosition = positions[j];\n          }\n        } else {\n          //we need to skip over the positions.  Since these are VInts, I don't believe there is anyway to know for sure how far to skip\n          //\n          for (int j = 0; j < freq; j++)\n          {\n            tvf.readVInt();\n          }\n        }\n      }\n      TermVectorOffsetInfo[] offsets = null;\n      if (storeOffsets) {\n        //does the mapper even care about offsets?\n        if (mapper.isIgnoringOffsets() == false) {\n          offsets = new TermVectorOffsetInfo[freq];\n          int prevOffset = 0;\n          for (int j = 0; j < freq; j++) {\n            int startOffset = prevOffset + tvf.readVInt();\n            int endOffset = startOffset + tvf.readVInt();\n            offsets[j] = new TermVectorOffsetInfo(startOffset, endOffset);\n            prevOffset = endOffset;\n          }\n        } else {\n          for (int j = 0; j < freq; j++){\n            tvf.readVInt();\n            tvf.readVInt();\n          }\n        }\n      }\n      mapper.map(term, freq, offsets, positions);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/backwards/src/java/org/apache/lucene/index/TermVectorsReader#readTermVector(String,long,TermVectorMapper).mjava","pathOld":"backwards/src/java/org/apache/lucene/index/TermVectorsReader#readTermVector(String,long,TermVectorMapper).mjava","sourceNew":"  /**\n   * \n   * @param field The field to read in\n   * @param tvfPointer The pointer within the tvf file where we should start reading\n   * @param mapper The mapper used to map the TermVector\n   * @throws IOException\n   */ \n  private void readTermVector(String field, long tvfPointer, TermVectorMapper mapper)\n          throws IOException {\n\n    // Now read the data from specified position\n    //We don't need to offset by the FORMAT here since the pointer already includes the offset\n    tvf.seek(tvfPointer);\n\n    int numTerms = tvf.readVInt();\n    //System.out.println(\"Num Terms: \" + numTerms);\n    // If no terms - return a constant empty termvector. However, this should never occur!\n    if (numTerms == 0) \n      return;\n    \n    boolean storePositions;\n    boolean storeOffsets;\n    \n    if (format >= FORMAT_VERSION){\n      byte bits = tvf.readByte();\n      storePositions = (bits & STORE_POSITIONS_WITH_TERMVECTOR) != 0;\n      storeOffsets = (bits & STORE_OFFSET_WITH_TERMVECTOR) != 0;\n    }\n    else{\n      tvf.readVInt();\n      storePositions = false;\n      storeOffsets = false;\n    }\n    mapper.setExpectations(field, numTerms, storeOffsets, storePositions);\n    int start = 0;\n    int deltaLength = 0;\n    int totalLength = 0;\n    byte[] byteBuffer;\n    char[] charBuffer;\n    final boolean preUTF8 = format < FORMAT_UTF8_LENGTH_IN_BYTES;\n\n    // init the buffers\n    if (preUTF8) {\n      charBuffer = new char[10];\n      byteBuffer = null;\n    } else {\n      charBuffer = null;\n      byteBuffer = new byte[20];\n    }\n\n    for (int i = 0; i < numTerms; i++) {\n      start = tvf.readVInt();\n      deltaLength = tvf.readVInt();\n      totalLength = start + deltaLength;\n\n      final String term;\n      \n      if (preUTF8) {\n        // Term stored as java chars\n        if (charBuffer.length < totalLength) {\n          char[] newCharBuffer = new char[(int) (1.5*totalLength)];\n          System.arraycopy(charBuffer, 0, newCharBuffer, 0, start);\n          charBuffer = newCharBuffer;\n        }\n        tvf.readChars(charBuffer, start, deltaLength);\n        term = new String(charBuffer, 0, totalLength);\n      } else {\n        // Term stored as utf8 bytes\n        if (byteBuffer.length < totalLength) {\n          byte[] newByteBuffer = new byte[(int) (1.5*totalLength)];\n          System.arraycopy(byteBuffer, 0, newByteBuffer, 0, start);\n          byteBuffer = newByteBuffer;\n        }\n        tvf.readBytes(byteBuffer, start, deltaLength);\n        term = new String(byteBuffer, 0, totalLength, \"UTF-8\");\n      }\n      int freq = tvf.readVInt();\n      int [] positions = null;\n      if (storePositions) { //read in the positions\n        //does the mapper even care about positions?\n        if (mapper.isIgnoringPositions() == false) {\n          positions = new int[freq];\n          int prevPosition = 0;\n          for (int j = 0; j < freq; j++)\n          {\n            positions[j] = prevPosition + tvf.readVInt();\n            prevPosition = positions[j];\n          }\n        } else {\n          //we need to skip over the positions.  Since these are VInts, I don't believe there is anyway to know for sure how far to skip\n          //\n          for (int j = 0; j < freq; j++)\n          {\n            tvf.readVInt();\n          }\n        }\n      }\n      TermVectorOffsetInfo[] offsets = null;\n      if (storeOffsets) {\n        //does the mapper even care about offsets?\n        if (mapper.isIgnoringOffsets() == false) {\n          offsets = new TermVectorOffsetInfo[freq];\n          int prevOffset = 0;\n          for (int j = 0; j < freq; j++) {\n            int startOffset = prevOffset + tvf.readVInt();\n            int endOffset = startOffset + tvf.readVInt();\n            offsets[j] = new TermVectorOffsetInfo(startOffset, endOffset);\n            prevOffset = endOffset;\n          }\n        } else {\n          for (int j = 0; j < freq; j++){\n            tvf.readVInt();\n            tvf.readVInt();\n          }\n        }\n      }\n      mapper.map(term, freq, offsets, positions);\n    }\n  }\n\n","sourceOld":"  /**\n   * \n   * @param field The field to read in\n   * @param tvfPointer The pointer within the tvf file where we should start reading\n   * @param mapper The mapper used to map the TermVector\n   * @throws IOException\n   */ \n  private void readTermVector(String field, long tvfPointer, TermVectorMapper mapper)\n          throws IOException {\n\n    // Now read the data from specified position\n    //We don't need to offset by the FORMAT here since the pointer already includes the offset\n    tvf.seek(tvfPointer);\n\n    int numTerms = tvf.readVInt();\n    //System.out.println(\"Num Terms: \" + numTerms);\n    // If no terms - return a constant empty termvector. However, this should never occur!\n    if (numTerms == 0) \n      return;\n    \n    boolean storePositions;\n    boolean storeOffsets;\n    \n    if (format >= FORMAT_VERSION){\n      byte bits = tvf.readByte();\n      storePositions = (bits & STORE_POSITIONS_WITH_TERMVECTOR) != 0;\n      storeOffsets = (bits & STORE_OFFSET_WITH_TERMVECTOR) != 0;\n    }\n    else{\n      tvf.readVInt();\n      storePositions = false;\n      storeOffsets = false;\n    }\n    mapper.setExpectations(field, numTerms, storeOffsets, storePositions);\n    int start = 0;\n    int deltaLength = 0;\n    int totalLength = 0;\n    byte[] byteBuffer;\n    char[] charBuffer;\n    final boolean preUTF8 = format < FORMAT_UTF8_LENGTH_IN_BYTES;\n\n    // init the buffers\n    if (preUTF8) {\n      charBuffer = new char[10];\n      byteBuffer = null;\n    } else {\n      charBuffer = null;\n      byteBuffer = new byte[20];\n    }\n\n    for (int i = 0; i < numTerms; i++) {\n      start = tvf.readVInt();\n      deltaLength = tvf.readVInt();\n      totalLength = start + deltaLength;\n\n      final String term;\n      \n      if (preUTF8) {\n        // Term stored as java chars\n        if (charBuffer.length < totalLength) {\n          char[] newCharBuffer = new char[(int) (1.5*totalLength)];\n          System.arraycopy(charBuffer, 0, newCharBuffer, 0, start);\n          charBuffer = newCharBuffer;\n        }\n        tvf.readChars(charBuffer, start, deltaLength);\n        term = new String(charBuffer, 0, totalLength);\n      } else {\n        // Term stored as utf8 bytes\n        if (byteBuffer.length < totalLength) {\n          byte[] newByteBuffer = new byte[(int) (1.5*totalLength)];\n          System.arraycopy(byteBuffer, 0, newByteBuffer, 0, start);\n          byteBuffer = newByteBuffer;\n        }\n        tvf.readBytes(byteBuffer, start, deltaLength);\n        term = new String(byteBuffer, 0, totalLength, \"UTF-8\");\n      }\n      int freq = tvf.readVInt();\n      int [] positions = null;\n      if (storePositions) { //read in the positions\n        //does the mapper even care about positions?\n        if (mapper.isIgnoringPositions() == false) {\n          positions = new int[freq];\n          int prevPosition = 0;\n          for (int j = 0; j < freq; j++)\n          {\n            positions[j] = prevPosition + tvf.readVInt();\n            prevPosition = positions[j];\n          }\n        } else {\n          //we need to skip over the positions.  Since these are VInts, I don't believe there is anyway to know for sure how far to skip\n          //\n          for (int j = 0; j < freq; j++)\n          {\n            tvf.readVInt();\n          }\n        }\n      }\n      TermVectorOffsetInfo[] offsets = null;\n      if (storeOffsets) {\n        //does the mapper even care about offsets?\n        if (mapper.isIgnoringOffsets() == false) {\n          offsets = new TermVectorOffsetInfo[freq];\n          int prevOffset = 0;\n          for (int j = 0; j < freq; j++) {\n            int startOffset = prevOffset + tvf.readVInt();\n            int endOffset = startOffset + tvf.readVInt();\n            offsets[j] = new TermVectorOffsetInfo(startOffset, endOffset);\n            prevOffset = endOffset;\n          }\n        } else {\n          for (int j = 0; j < freq; j++){\n            tvf.readVInt();\n            tvf.readVInt();\n          }\n        }\n      }\n      mapper.map(term, freq, offsets, positions);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"480d01e5b0ef8efb136d51670fec297ae5ae2c9c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["480d01e5b0ef8efb136d51670fec297ae5ae2c9c"]},"commit2Childs":{"480d01e5b0ef8efb136d51670fec297ae5ae2c9c":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["480d01e5b0ef8efb136d51670fec297ae5ae2c9c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}