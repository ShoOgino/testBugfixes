{"path":"backwards/src/java/org/apache/lucene/search/FieldCacheRangeFilter.FieldCacheDocIdSet#iterator().mjava","commits":[{"id":"480d01e5b0ef8efb136d51670fec297ae5ae2c9c","date":1268821447,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"backwards/src/java/org/apache/lucene/search/FieldCacheRangeFilter.FieldCacheDocIdSet#iterator().mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public DocIdSetIterator iterator() throws IOException {\n      // Synchronization needed because deleted docs BitVector\n      // can change after call to hasDeletions until TermDocs creation.\n      // We only use an iterator with termDocs, when this was requested (e.g. range contains 0)\n      // and the index has deletions\n      final TermDocs termDocs;\n      synchronized(reader) {\n        termDocs = isCacheable() ? null : reader.termDocs(null);\n      }\n      if (termDocs != null) {\n        // a DocIdSetIterator using TermDocs to iterate valid docIds\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          \n          @Override\n          public int docID() {\n            return doc;\n          }\n          \n          @Override\n          public int nextDoc() throws IOException {\n            do {\n              if (!termDocs.next())\n                return doc = NO_MORE_DOCS;\n            } while (!matchDoc(doc = termDocs.doc()));\n            return doc;\n          }\n          \n          @Override\n          public int advance(int target) throws IOException {\n            if (!termDocs.skipTo(target))\n              return doc = NO_MORE_DOCS;\n            while (!matchDoc(doc = termDocs.doc())) { \n              if (!termDocs.next())\n                return doc = NO_MORE_DOCS;\n            }\n            return doc;\n          }\n        };\n      } else {\n        // a DocIdSetIterator generating docIds by incrementing a variable -\n        // this one can be used if there are no deletions are on the index\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          \n          @Override\n          public int docID() {\n            return doc;\n          }\n          \n          @Override\n          public int nextDoc() {\n            try {\n              do {\n                doc++;\n              } while (!matchDoc(doc));\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n          \n          @Override\n          public int advance(int target) {\n            try {\n              doc = target;\n              while (!matchDoc(doc)) { \n                doc++;\n              }\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n        };\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/backwards/src/java/org/apache/lucene/search/FieldCacheRangeFilter.FieldCacheDocIdSet#iterator().mjava","pathOld":"backwards/src/java/org/apache/lucene/search/FieldCacheRangeFilter.FieldCacheDocIdSet#iterator().mjava","sourceNew":"    @Override\n    public DocIdSetIterator iterator() throws IOException {\n      // Synchronization needed because deleted docs BitVector\n      // can change after call to hasDeletions until TermDocs creation.\n      // We only use an iterator with termDocs, when this was requested (e.g. range contains 0)\n      // and the index has deletions\n      final TermDocs termDocs;\n      synchronized(reader) {\n        termDocs = isCacheable() ? null : reader.termDocs(null);\n      }\n      if (termDocs != null) {\n        // a DocIdSetIterator using TermDocs to iterate valid docIds\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          \n          @Override\n          public int docID() {\n            return doc;\n          }\n          \n          @Override\n          public int nextDoc() throws IOException {\n            do {\n              if (!termDocs.next())\n                return doc = NO_MORE_DOCS;\n            } while (!matchDoc(doc = termDocs.doc()));\n            return doc;\n          }\n          \n          @Override\n          public int advance(int target) throws IOException {\n            if (!termDocs.skipTo(target))\n              return doc = NO_MORE_DOCS;\n            while (!matchDoc(doc = termDocs.doc())) { \n              if (!termDocs.next())\n                return doc = NO_MORE_DOCS;\n            }\n            return doc;\n          }\n        };\n      } else {\n        // a DocIdSetIterator generating docIds by incrementing a variable -\n        // this one can be used if there are no deletions are on the index\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          \n          @Override\n          public int docID() {\n            return doc;\n          }\n          \n          @Override\n          public int nextDoc() {\n            try {\n              do {\n                doc++;\n              } while (!matchDoc(doc));\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n          \n          @Override\n          public int advance(int target) {\n            try {\n              doc = target;\n              while (!matchDoc(doc)) { \n                doc++;\n              }\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n        };\n      }\n    }\n\n","sourceOld":"    @Override\n    public DocIdSetIterator iterator() throws IOException {\n      // Synchronization needed because deleted docs BitVector\n      // can change after call to hasDeletions until TermDocs creation.\n      // We only use an iterator with termDocs, when this was requested (e.g. range contains 0)\n      // and the index has deletions\n      final TermDocs termDocs;\n      synchronized(reader) {\n        termDocs = isCacheable() ? null : reader.termDocs(null);\n      }\n      if (termDocs != null) {\n        // a DocIdSetIterator using TermDocs to iterate valid docIds\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          \n          @Override\n          public int docID() {\n            return doc;\n          }\n          \n          @Override\n          public int nextDoc() throws IOException {\n            do {\n              if (!termDocs.next())\n                return doc = NO_MORE_DOCS;\n            } while (!matchDoc(doc = termDocs.doc()));\n            return doc;\n          }\n          \n          @Override\n          public int advance(int target) throws IOException {\n            if (!termDocs.skipTo(target))\n              return doc = NO_MORE_DOCS;\n            while (!matchDoc(doc = termDocs.doc())) { \n              if (!termDocs.next())\n                return doc = NO_MORE_DOCS;\n            }\n            return doc;\n          }\n        };\n      } else {\n        // a DocIdSetIterator generating docIds by incrementing a variable -\n        // this one can be used if there are no deletions are on the index\n        return new DocIdSetIterator() {\n          private int doc = -1;\n          \n          @Override\n          public int docID() {\n            return doc;\n          }\n          \n          @Override\n          public int nextDoc() {\n            try {\n              do {\n                doc++;\n              } while (!matchDoc(doc));\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n          \n          @Override\n          public int advance(int target) {\n            try {\n              doc = target;\n              while (!matchDoc(doc)) { \n                doc++;\n              }\n              return doc;\n            } catch (ArrayIndexOutOfBoundsException e) {\n              return doc = NO_MORE_DOCS;\n            }\n          }\n        };\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"480d01e5b0ef8efb136d51670fec297ae5ae2c9c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["480d01e5b0ef8efb136d51670fec297ae5ae2c9c"]},"commit2Childs":{"480d01e5b0ef8efb136d51670fec297ae5ae2c9c":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["480d01e5b0ef8efb136d51670fec297ae5ae2c9c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}