{"path":"lucene/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldPhraseList#FieldPhraseList(FieldTermStack,FieldQuery,int).mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldPhraseList#FieldPhraseList(FieldTermStack,FieldQuery,int).mjava","pathOld":"lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldPhraseList#FieldPhraseList(FieldTermStack,FieldQuery,int).mjava","sourceNew":"  /**\n   * a constructor.\n   * \n   * @param fieldTermStack FieldTermStack object\n   * @param fieldQuery FieldQuery object\n   * @param phraseLimit maximum size of phraseList\n   */\n  public FieldPhraseList( FieldTermStack fieldTermStack, FieldQuery fieldQuery, int phraseLimit){\n    final String field = fieldTermStack.getFieldName();\n\n    LinkedList<TermInfo> phraseCandidate = new LinkedList<TermInfo>();\n    QueryPhraseMap currMap = null;\n    QueryPhraseMap nextMap = null;\n    while( !fieldTermStack.isEmpty() && (phraseList.size() < phraseLimit) )\n    {      \n      phraseCandidate.clear();\n\n      TermInfo ti = fieldTermStack.pop();\n      currMap = fieldQuery.getFieldTermMap( field, ti.getText() );\n\n      // if not found, discard top TermInfo from stack, then try next element\n      if( currMap == null ) continue;\n      \n      // if found, search the longest phrase\n      phraseCandidate.add( ti );\n      while( true ){\n        ti = fieldTermStack.pop();\n        nextMap = null;\n        if( ti != null )\n          nextMap = currMap.getTermMap( ti.getText() );\n        if( ti == null || nextMap == null ){\n          if( ti != null )\n            fieldTermStack.push( ti );\n          if( currMap.isValidTermOrPhrase( phraseCandidate ) ){\n            addIfNoOverlap( new WeightedPhraseInfo( phraseCandidate, currMap.getBoost(), currMap.getTermOrPhraseNumber() ) );\n          }\n          else{\n            while( phraseCandidate.size() > 1 ){\n              fieldTermStack.push( phraseCandidate.removeLast() );\n              currMap = fieldQuery.searchPhrase( field, phraseCandidate );\n              if( currMap != null ){\n                addIfNoOverlap( new WeightedPhraseInfo( phraseCandidate, currMap.getBoost(), currMap.getTermOrPhraseNumber() ) );\n                break;\n              }\n            }\n          }\n          break;\n        }\n        else{\n          phraseCandidate.add( ti );\n          currMap = nextMap;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * a constructor.\n   * \n   * @param fieldTermStack FieldTermStack object\n   * @param fieldQuery FieldQuery object\n   * @param phraseLimit maximum size of phraseList\n   */\n  public FieldPhraseList( FieldTermStack fieldTermStack, FieldQuery fieldQuery, int phraseLimit){\n    final String field = fieldTermStack.getFieldName();\n\n    LinkedList<TermInfo> phraseCandidate = new LinkedList<TermInfo>();\n    QueryPhraseMap currMap = null;\n    QueryPhraseMap nextMap = null;\n    while( !fieldTermStack.isEmpty() && (phraseList.size() < phraseLimit) )\n    {      \n      phraseCandidate.clear();\n\n      TermInfo ti = fieldTermStack.pop();\n      currMap = fieldQuery.getFieldTermMap( field, ti.getText() );\n\n      // if not found, discard top TermInfo from stack, then try next element\n      if( currMap == null ) continue;\n      \n      // if found, search the longest phrase\n      phraseCandidate.add( ti );\n      while( true ){\n        ti = fieldTermStack.pop();\n        nextMap = null;\n        if( ti != null )\n          nextMap = currMap.getTermMap( ti.getText() );\n        if( ti == null || nextMap == null ){\n          if( ti != null )\n            fieldTermStack.push( ti );\n          if( currMap.isValidTermOrPhrase( phraseCandidate ) ){\n            addIfNoOverlap( new WeightedPhraseInfo( phraseCandidate, currMap.getBoost(), currMap.getTermOrPhraseNumber() ) );\n          }\n          else{\n            while( phraseCandidate.size() > 1 ){\n              fieldTermStack.push( phraseCandidate.removeLast() );\n              currMap = fieldQuery.searchPhrase( field, phraseCandidate );\n              if( currMap != null ){\n                addIfNoOverlap( new WeightedPhraseInfo( phraseCandidate, currMap.getBoost(), currMap.getTermOrPhraseNumber() ) );\n                break;\n              }\n            }\n          }\n          break;\n        }\n        else{\n          phraseCandidate.add( ti );\n          currMap = nextMap;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9f3f873f902c9e3821591809929b6f1283bc0298","date":1338822342,"type":3,"author":"Koji Sekiguchi","isMerge":false,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldPhraseList#FieldPhraseList(FieldTermStack,FieldQuery,int).mjava","pathOld":"lucene/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldPhraseList#FieldPhraseList(FieldTermStack,FieldQuery,int).mjava","sourceNew":"  /**\n   * a constructor.\n   * \n   * @param fieldTermStack FieldTermStack object\n   * @param fieldQuery FieldQuery object\n   * @param phraseLimit maximum size of phraseList\n   */\n  public FieldPhraseList( FieldTermStack fieldTermStack, FieldQuery fieldQuery, int phraseLimit ){\n    final String field = fieldTermStack.getFieldName();\n\n    LinkedList<TermInfo> phraseCandidate = new LinkedList<TermInfo>();\n    QueryPhraseMap currMap = null;\n    QueryPhraseMap nextMap = null;\n    while( !fieldTermStack.isEmpty() && (phraseList.size() < phraseLimit) )\n    {      \n      phraseCandidate.clear();\n\n      TermInfo ti = fieldTermStack.pop();\n      currMap = fieldQuery.getFieldTermMap( field, ti.getText() );\n\n      // if not found, discard top TermInfo from stack, then try next element\n      if( currMap == null ) continue;\n      \n      // if found, search the longest phrase\n      phraseCandidate.add( ti );\n      while( true ){\n        ti = fieldTermStack.pop();\n        nextMap = null;\n        if( ti != null )\n          nextMap = currMap.getTermMap( ti.getText() );\n        if( ti == null || nextMap == null ){\n          if( ti != null )\n            fieldTermStack.push( ti );\n          if( currMap.isValidTermOrPhrase( phraseCandidate ) ){\n            addIfNoOverlap( new WeightedPhraseInfo( phraseCandidate, currMap.getBoost(), currMap.getTermOrPhraseNumber() ) );\n          }\n          else{\n            while( phraseCandidate.size() > 1 ){\n              fieldTermStack.push( phraseCandidate.removeLast() );\n              currMap = fieldQuery.searchPhrase( field, phraseCandidate );\n              if( currMap != null ){\n                addIfNoOverlap( new WeightedPhraseInfo( phraseCandidate, currMap.getBoost(), currMap.getTermOrPhraseNumber() ) );\n                break;\n              }\n            }\n          }\n          break;\n        }\n        else{\n          phraseCandidate.add( ti );\n          currMap = nextMap;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * a constructor.\n   * \n   * @param fieldTermStack FieldTermStack object\n   * @param fieldQuery FieldQuery object\n   * @param phraseLimit maximum size of phraseList\n   */\n  public FieldPhraseList( FieldTermStack fieldTermStack, FieldQuery fieldQuery, int phraseLimit){\n    final String field = fieldTermStack.getFieldName();\n\n    LinkedList<TermInfo> phraseCandidate = new LinkedList<TermInfo>();\n    QueryPhraseMap currMap = null;\n    QueryPhraseMap nextMap = null;\n    while( !fieldTermStack.isEmpty() && (phraseList.size() < phraseLimit) )\n    {      \n      phraseCandidate.clear();\n\n      TermInfo ti = fieldTermStack.pop();\n      currMap = fieldQuery.getFieldTermMap( field, ti.getText() );\n\n      // if not found, discard top TermInfo from stack, then try next element\n      if( currMap == null ) continue;\n      \n      // if found, search the longest phrase\n      phraseCandidate.add( ti );\n      while( true ){\n        ti = fieldTermStack.pop();\n        nextMap = null;\n        if( ti != null )\n          nextMap = currMap.getTermMap( ti.getText() );\n        if( ti == null || nextMap == null ){\n          if( ti != null )\n            fieldTermStack.push( ti );\n          if( currMap.isValidTermOrPhrase( phraseCandidate ) ){\n            addIfNoOverlap( new WeightedPhraseInfo( phraseCandidate, currMap.getBoost(), currMap.getTermOrPhraseNumber() ) );\n          }\n          else{\n            while( phraseCandidate.size() > 1 ){\n              fieldTermStack.push( phraseCandidate.removeLast() );\n              currMap = fieldQuery.searchPhrase( field, phraseCandidate );\n              if( currMap != null ){\n                addIfNoOverlap( new WeightedPhraseInfo( phraseCandidate, currMap.getBoost(), currMap.getTermOrPhraseNumber() ) );\n                break;\n              }\n            }\n          }\n          break;\n        }\n        else{\n          phraseCandidate.add( ti );\n          currMap = nextMap;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4de9b9325d973e4bc4c97eb91fe119eafa6caa99","date":1365179986,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldPhraseList#FieldPhraseList(FieldTermStack,FieldQuery,int).mjava","pathOld":"lucene/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldPhraseList#FieldPhraseList(FieldTermStack,FieldQuery,int).mjava","sourceNew":"  /**\n   * a constructor.\n   * \n   * @param fieldTermStack FieldTermStack object\n   * @param fieldQuery FieldQuery object\n   * @param phraseLimit maximum size of phraseList\n   */\n  public FieldPhraseList( FieldTermStack fieldTermStack, FieldQuery fieldQuery, int phraseLimit ){\n    final String field = fieldTermStack.getFieldName();\n\n    LinkedList<TermInfo> phraseCandidate = new LinkedList<TermInfo>();\n    QueryPhraseMap currMap = null;\n    QueryPhraseMap nextMap = null;\n    while( !fieldTermStack.isEmpty() && (phraseList.size() < phraseLimit) )\n    {      \n      phraseCandidate.clear();\n\n      TermInfo ti = fieldTermStack.pop();\n      currMap = fieldQuery.getFieldTermMap( field, ti.getText() );\n\n      // if not found, discard top TermInfo from stack, then try next element\n      if( currMap == null ) continue;\n      \n      // if found, search the longest phrase\n      phraseCandidate.add( ti );\n      while( true ){\n        ti = fieldTermStack.pop();\n        nextMap = null;\n        if( ti != null )\n          nextMap = currMap.getTermMap( ti.getText() );\n        if( ti == null || nextMap == null ){\n          if( ti != null ) \n            fieldTermStack.push( ti );\n          if( currMap.isValidTermOrPhrase( phraseCandidate ) ){\n            addIfNoOverlap( new WeightedPhraseInfo( phraseCandidate, currMap.getBoost(), currMap.getTermOrPhraseNumber() ) );\n          }\n          else{\n            while( phraseCandidate.size() > 1 ){\n              fieldTermStack.push( phraseCandidate.removeLast() );\n              currMap = fieldQuery.searchPhrase( field, phraseCandidate );\n              if( currMap != null ){\n                addIfNoOverlap( new WeightedPhraseInfo( phraseCandidate, currMap.getBoost(), currMap.getTermOrPhraseNumber() ) );\n                break;\n              }\n            }\n          }\n          break;\n        }\n        else{\n          phraseCandidate.add( ti );\n          currMap = nextMap;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * a constructor.\n   * \n   * @param fieldTermStack FieldTermStack object\n   * @param fieldQuery FieldQuery object\n   * @param phraseLimit maximum size of phraseList\n   */\n  public FieldPhraseList( FieldTermStack fieldTermStack, FieldQuery fieldQuery, int phraseLimit ){\n    final String field = fieldTermStack.getFieldName();\n\n    LinkedList<TermInfo> phraseCandidate = new LinkedList<TermInfo>();\n    QueryPhraseMap currMap = null;\n    QueryPhraseMap nextMap = null;\n    while( !fieldTermStack.isEmpty() && (phraseList.size() < phraseLimit) )\n    {      \n      phraseCandidate.clear();\n\n      TermInfo ti = fieldTermStack.pop();\n      currMap = fieldQuery.getFieldTermMap( field, ti.getText() );\n\n      // if not found, discard top TermInfo from stack, then try next element\n      if( currMap == null ) continue;\n      \n      // if found, search the longest phrase\n      phraseCandidate.add( ti );\n      while( true ){\n        ti = fieldTermStack.pop();\n        nextMap = null;\n        if( ti != null )\n          nextMap = currMap.getTermMap( ti.getText() );\n        if( ti == null || nextMap == null ){\n          if( ti != null )\n            fieldTermStack.push( ti );\n          if( currMap.isValidTermOrPhrase( phraseCandidate ) ){\n            addIfNoOverlap( new WeightedPhraseInfo( phraseCandidate, currMap.getBoost(), currMap.getTermOrPhraseNumber() ) );\n          }\n          else{\n            while( phraseCandidate.size() > 1 ){\n              fieldTermStack.push( phraseCandidate.removeLast() );\n              currMap = fieldQuery.searchPhrase( field, phraseCandidate );\n              if( currMap != null ){\n                addIfNoOverlap( new WeightedPhraseInfo( phraseCandidate, currMap.getBoost(), currMap.getTermOrPhraseNumber() ) );\n                break;\n              }\n            }\n          }\n          break;\n        }\n        else{\n          phraseCandidate.add( ti );\n          currMap = nextMap;\n        }\n      }\n    }\n  }\n\n","bugFix":["f5677ab05eb69cf61643b4c82187f841ca2f3345"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7327eec6fde8afb35c01f6234cb50c42a7c737d3","date":1374238360,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldPhraseList#FieldPhraseList(FieldTermStack,FieldQuery,int).mjava","pathOld":"lucene/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldPhraseList#FieldPhraseList(FieldTermStack,FieldQuery,int).mjava","sourceNew":"  /**\n   * a constructor.\n   * \n   * @param fieldTermStack FieldTermStack object\n   * @param fieldQuery FieldQuery object\n   * @param phraseLimit maximum size of phraseList\n   */\n  public FieldPhraseList( FieldTermStack fieldTermStack, FieldQuery fieldQuery, int phraseLimit ){\n    final String field = fieldTermStack.getFieldName();\n\n    @SuppressWarnings(\"unchecked\")\n    Deque<TermInfo>[] termStacks = new Deque[] {new ArrayDeque<TermInfo>()};\n    for (TermInfo ti = fieldTermStack.pop(); ti != null; ti = fieldTermStack.pop()) {\n      // If there are tokens at the same position, compute all combinations\n      if (!fieldTermStack.isEmpty() && fieldTermStack.peek().getPosition() == ti.getPosition()) {\n        List<TermInfo> samePositionTermInfos = new ArrayList<>(2);\n        samePositionTermInfos.add(ti);\n        samePositionTermInfos.add(fieldTermStack.pop());\n        while (!fieldTermStack.isEmpty() && fieldTermStack.peek().getPosition() == ti.getPosition()) {\n          samePositionTermInfos.add(fieldTermStack.pop());\n        }\n        final int numTokensAtSamePosition = samePositionTermInfos.size();\n        @SuppressWarnings(\"unchecked\")\n        Deque<TermInfo>[] newTermStacks = new Deque[termStacks.length * numTokensAtSamePosition];\n        for (int i = 0, k = 0; i < termStacks.length; ++i) {\n          for (int j = 0; j < numTokensAtSamePosition; ++j) {\n            if (j == numTokensAtSamePosition - 1) {\n              newTermStacks[k] = termStacks[i];\n            } else {\n              newTermStacks[k] = new ArrayDeque<>(termStacks[i]);\n            }\n            newTermStacks[k++].offer(samePositionTermInfos.get(j));\n          }\n        }\n        termStacks = newTermStacks;\n      } else {\n        for (Deque<TermInfo> d : termStacks) {\n          d.offer(ti);\n        }\n      }\n    }\n\n    for (Deque<TermInfo> d : termStacks) {\n      extractPhrases(field, d, fieldQuery, phraseLimit);\n    }\n  }\n\n","sourceOld":"  /**\n   * a constructor.\n   * \n   * @param fieldTermStack FieldTermStack object\n   * @param fieldQuery FieldQuery object\n   * @param phraseLimit maximum size of phraseList\n   */\n  public FieldPhraseList( FieldTermStack fieldTermStack, FieldQuery fieldQuery, int phraseLimit ){\n    final String field = fieldTermStack.getFieldName();\n\n    LinkedList<TermInfo> phraseCandidate = new LinkedList<TermInfo>();\n    QueryPhraseMap currMap = null;\n    QueryPhraseMap nextMap = null;\n    while( !fieldTermStack.isEmpty() && (phraseList.size() < phraseLimit) )\n    {      \n      phraseCandidate.clear();\n\n      TermInfo ti = fieldTermStack.pop();\n      currMap = fieldQuery.getFieldTermMap( field, ti.getText() );\n\n      // if not found, discard top TermInfo from stack, then try next element\n      if( currMap == null ) continue;\n      \n      // if found, search the longest phrase\n      phraseCandidate.add( ti );\n      while( true ){\n        ti = fieldTermStack.pop();\n        nextMap = null;\n        if( ti != null )\n          nextMap = currMap.getTermMap( ti.getText() );\n        if( ti == null || nextMap == null ){\n          if( ti != null ) \n            fieldTermStack.push( ti );\n          if( currMap.isValidTermOrPhrase( phraseCandidate ) ){\n            addIfNoOverlap( new WeightedPhraseInfo( phraseCandidate, currMap.getBoost(), currMap.getTermOrPhraseNumber() ) );\n          }\n          else{\n            while( phraseCandidate.size() > 1 ){\n              fieldTermStack.push( phraseCandidate.removeLast() );\n              currMap = fieldQuery.searchPhrase( field, phraseCandidate );\n              if( currMap != null ){\n                addIfNoOverlap( new WeightedPhraseInfo( phraseCandidate, currMap.getBoost(), currMap.getTermOrPhraseNumber() ) );\n                break;\n              }\n            }\n          }\n          break;\n        }\n        else{\n          phraseCandidate.add( ti );\n          currMap = nextMap;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"47d6c59c2165ec476da09e8ececaaf1776aaca46","date":1374512348,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldPhraseList#FieldPhraseList(FieldTermStack,FieldQuery,int).mjava","pathOld":"lucene/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldPhraseList#FieldPhraseList(FieldTermStack,FieldQuery,int).mjava","sourceNew":"  /**\n   * a constructor.\n   * \n   * @param fieldTermStack FieldTermStack object\n   * @param fieldQuery FieldQuery object\n   * @param phraseLimit maximum size of phraseList\n   */\n  public FieldPhraseList( FieldTermStack fieldTermStack, FieldQuery fieldQuery, int phraseLimit ){\n    final String field = fieldTermStack.getFieldName();\n\n    QueryPhraseMap qpm = fieldQuery.getRootMap(field);\n    if (qpm != null) {\n      LinkedList<TermInfo> phraseCandidate = new LinkedList<TermInfo>();\n      extractPhrases(fieldTermStack.termList, qpm, phraseCandidate, 0);\n      assert phraseCandidate.size() == 0;\n    }\n  }\n\n","sourceOld":"  /**\n   * a constructor.\n   * \n   * @param fieldTermStack FieldTermStack object\n   * @param fieldQuery FieldQuery object\n   * @param phraseLimit maximum size of phraseList\n   */\n  public FieldPhraseList( FieldTermStack fieldTermStack, FieldQuery fieldQuery, int phraseLimit ){\n    final String field = fieldTermStack.getFieldName();\n\n    @SuppressWarnings(\"unchecked\")\n    Deque<TermInfo>[] termStacks = new Deque[] {new ArrayDeque<TermInfo>()};\n    for (TermInfo ti = fieldTermStack.pop(); ti != null; ti = fieldTermStack.pop()) {\n      // If there are tokens at the same position, compute all combinations\n      if (!fieldTermStack.isEmpty() && fieldTermStack.peek().getPosition() == ti.getPosition()) {\n        List<TermInfo> samePositionTermInfos = new ArrayList<>(2);\n        samePositionTermInfos.add(ti);\n        samePositionTermInfos.add(fieldTermStack.pop());\n        while (!fieldTermStack.isEmpty() && fieldTermStack.peek().getPosition() == ti.getPosition()) {\n          samePositionTermInfos.add(fieldTermStack.pop());\n        }\n        final int numTokensAtSamePosition = samePositionTermInfos.size();\n        @SuppressWarnings(\"unchecked\")\n        Deque<TermInfo>[] newTermStacks = new Deque[termStacks.length * numTokensAtSamePosition];\n        for (int i = 0, k = 0; i < termStacks.length; ++i) {\n          for (int j = 0; j < numTokensAtSamePosition; ++j) {\n            if (j == numTokensAtSamePosition - 1) {\n              newTermStacks[k] = termStacks[i];\n            } else {\n              newTermStacks[k] = new ArrayDeque<>(termStacks[i]);\n            }\n            newTermStacks[k++].offer(samePositionTermInfos.get(j));\n          }\n        }\n        termStacks = newTermStacks;\n      } else {\n        for (Deque<TermInfo> d : termStacks) {\n          d.offer(ti);\n        }\n      }\n    }\n\n    for (Deque<TermInfo> d : termStacks) {\n      extractPhrases(field, d, fieldQuery, phraseLimit);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","date":1376366778,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldPhraseList#FieldPhraseList(FieldTermStack,FieldQuery,int).mjava","pathOld":"lucene/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldPhraseList#FieldPhraseList(FieldTermStack,FieldQuery,int).mjava","sourceNew":"  /**\n   * a constructor.\n   * \n   * @param fieldTermStack FieldTermStack object\n   * @param fieldQuery FieldQuery object\n   * @param phraseLimit maximum size of phraseList\n   */\n  public FieldPhraseList( FieldTermStack fieldTermStack, FieldQuery fieldQuery, int phraseLimit ){\n    final String field = fieldTermStack.getFieldName();\n\n    QueryPhraseMap qpm = fieldQuery.getRootMap(field);\n    if (qpm != null) {\n      LinkedList<TermInfo> phraseCandidate = new LinkedList<TermInfo>();\n      extractPhrases(fieldTermStack.termList, qpm, phraseCandidate, 0);\n      assert phraseCandidate.size() == 0;\n    }\n  }\n\n","sourceOld":"  /**\n   * a constructor.\n   * \n   * @param fieldTermStack FieldTermStack object\n   * @param fieldQuery FieldQuery object\n   * @param phraseLimit maximum size of phraseList\n   */\n  public FieldPhraseList( FieldTermStack fieldTermStack, FieldQuery fieldQuery, int phraseLimit ){\n    final String field = fieldTermStack.getFieldName();\n\n    LinkedList<TermInfo> phraseCandidate = new LinkedList<TermInfo>();\n    QueryPhraseMap currMap = null;\n    QueryPhraseMap nextMap = null;\n    while( !fieldTermStack.isEmpty() && (phraseList.size() < phraseLimit) )\n    {      \n      phraseCandidate.clear();\n\n      TermInfo ti = fieldTermStack.pop();\n      currMap = fieldQuery.getFieldTermMap( field, ti.getText() );\n\n      // if not found, discard top TermInfo from stack, then try next element\n      if( currMap == null ) continue;\n      \n      // if found, search the longest phrase\n      phraseCandidate.add( ti );\n      while( true ){\n        ti = fieldTermStack.pop();\n        nextMap = null;\n        if( ti != null )\n          nextMap = currMap.getTermMap( ti.getText() );\n        if( ti == null || nextMap == null ){\n          if( ti != null ) \n            fieldTermStack.push( ti );\n          if( currMap.isValidTermOrPhrase( phraseCandidate ) ){\n            addIfNoOverlap( new WeightedPhraseInfo( phraseCandidate, currMap.getBoost(), currMap.getTermOrPhraseNumber() ) );\n          }\n          else{\n            while( phraseCandidate.size() > 1 ){\n              fieldTermStack.push( phraseCandidate.removeLast() );\n              currMap = fieldQuery.searchPhrase( field, phraseCandidate );\n              if( currMap != null ){\n                addIfNoOverlap( new WeightedPhraseInfo( phraseCandidate, currMap.getBoost(), currMap.getTermOrPhraseNumber() ) );\n                break;\n              }\n            }\n          }\n          break;\n        }\n        else{\n          phraseCandidate.add( ti );\n          currMap = nextMap;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cfd0cdef6d792d7bc9c123a4d51723e2ba3f6e08","date":1378464767,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldPhraseList#FieldPhraseList(FieldTermStack,FieldQuery,int).mjava","pathOld":"lucene/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldPhraseList#FieldPhraseList(FieldTermStack,FieldQuery,int).mjava","sourceNew":"  /**\n   * a constructor.\n   * \n   * @param fieldTermStack FieldTermStack object\n   * @param fieldQuery FieldQuery object\n   * @param phraseLimit maximum size of phraseList\n   */\n  public FieldPhraseList( FieldTermStack fieldTermStack, FieldQuery fieldQuery, int phraseLimit ){\n    final String field = fieldTermStack.getFieldName();\n\n    LinkedList<TermInfo> phraseCandidate = new LinkedList<TermInfo>();\n    QueryPhraseMap currMap = null;\n    QueryPhraseMap nextMap = null;\n    while( !fieldTermStack.isEmpty() && (phraseList.size() < phraseLimit) )\n    {      \n      phraseCandidate.clear();\n\n      TermInfo ti = fieldTermStack.pop();\n      currMap = fieldQuery.getFieldTermMap( field, ti.getText() );\n\n      // if not found, discard top TermInfo from stack, then try next element\n      if( currMap == null ) continue;\n      \n      // if found, search the longest phrase\n      phraseCandidate.add( ti );\n      while( true ){\n        ti = fieldTermStack.pop();\n        nextMap = null;\n        if( ti != null )\n          nextMap = currMap.getTermMap( ti.getText() );\n        if( ti == null || nextMap == null ){\n          if( ti != null ) \n            fieldTermStack.push( ti );\n          if( currMap.isValidTermOrPhrase( phraseCandidate ) ){\n            addIfNoOverlap( new WeightedPhraseInfo( phraseCandidate, currMap.getBoost(), currMap.getTermOrPhraseNumber() ) );\n          }\n          else{\n            while( phraseCandidate.size() > 1 ){\n              fieldTermStack.push( phraseCandidate.removeLast() );\n              currMap = fieldQuery.searchPhrase( field, phraseCandidate );\n              if( currMap != null ){\n                addIfNoOverlap( new WeightedPhraseInfo( phraseCandidate, currMap.getBoost(), currMap.getTermOrPhraseNumber() ) );\n                break;\n              }\n            }\n          }\n          break;\n        }\n        else{\n          phraseCandidate.add( ti );\n          currMap = nextMap;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * a constructor.\n   * \n   * @param fieldTermStack FieldTermStack object\n   * @param fieldQuery FieldQuery object\n   * @param phraseLimit maximum size of phraseList\n   */\n  public FieldPhraseList( FieldTermStack fieldTermStack, FieldQuery fieldQuery, int phraseLimit ){\n    final String field = fieldTermStack.getFieldName();\n\n    QueryPhraseMap qpm = fieldQuery.getRootMap(field);\n    if (qpm != null) {\n      LinkedList<TermInfo> phraseCandidate = new LinkedList<TermInfo>();\n      extractPhrases(fieldTermStack.termList, qpm, phraseCandidate, 0);\n      assert phraseCandidate.size() == 0;\n    }\n  }\n\n","bugFix":null,"bugIntro":["0c066f7f6446f2d91513e81976f4b070a38763c7"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldPhraseList#FieldPhraseList(FieldTermStack,FieldQuery,int).mjava","pathOld":"lucene/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldPhraseList#FieldPhraseList(FieldTermStack,FieldQuery,int).mjava","sourceNew":"  /**\n   * a constructor.\n   * \n   * @param fieldTermStack FieldTermStack object\n   * @param fieldQuery FieldQuery object\n   * @param phraseLimit maximum size of phraseList\n   */\n  public FieldPhraseList( FieldTermStack fieldTermStack, FieldQuery fieldQuery, int phraseLimit ){\n    final String field = fieldTermStack.getFieldName();\n\n    LinkedList<TermInfo> phraseCandidate = new LinkedList<>();\n    QueryPhraseMap currMap = null;\n    QueryPhraseMap nextMap = null;\n    while( !fieldTermStack.isEmpty() && (phraseList.size() < phraseLimit) )\n    {      \n      phraseCandidate.clear();\n\n      TermInfo ti = fieldTermStack.pop();\n      currMap = fieldQuery.getFieldTermMap( field, ti.getText() );\n\n      // if not found, discard top TermInfo from stack, then try next element\n      if( currMap == null ) continue;\n      \n      // if found, search the longest phrase\n      phraseCandidate.add( ti );\n      while( true ){\n        ti = fieldTermStack.pop();\n        nextMap = null;\n        if( ti != null )\n          nextMap = currMap.getTermMap( ti.getText() );\n        if( ti == null || nextMap == null ){\n          if( ti != null ) \n            fieldTermStack.push( ti );\n          if( currMap.isValidTermOrPhrase( phraseCandidate ) ){\n            addIfNoOverlap( new WeightedPhraseInfo( phraseCandidate, currMap.getBoost(), currMap.getTermOrPhraseNumber() ) );\n          }\n          else{\n            while( phraseCandidate.size() > 1 ){\n              fieldTermStack.push( phraseCandidate.removeLast() );\n              currMap = fieldQuery.searchPhrase( field, phraseCandidate );\n              if( currMap != null ){\n                addIfNoOverlap( new WeightedPhraseInfo( phraseCandidate, currMap.getBoost(), currMap.getTermOrPhraseNumber() ) );\n                break;\n              }\n            }\n          }\n          break;\n        }\n        else{\n          phraseCandidate.add( ti );\n          currMap = nextMap;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * a constructor.\n   * \n   * @param fieldTermStack FieldTermStack object\n   * @param fieldQuery FieldQuery object\n   * @param phraseLimit maximum size of phraseList\n   */\n  public FieldPhraseList( FieldTermStack fieldTermStack, FieldQuery fieldQuery, int phraseLimit ){\n    final String field = fieldTermStack.getFieldName();\n\n    LinkedList<TermInfo> phraseCandidate = new LinkedList<TermInfo>();\n    QueryPhraseMap currMap = null;\n    QueryPhraseMap nextMap = null;\n    while( !fieldTermStack.isEmpty() && (phraseList.size() < phraseLimit) )\n    {      \n      phraseCandidate.clear();\n\n      TermInfo ti = fieldTermStack.pop();\n      currMap = fieldQuery.getFieldTermMap( field, ti.getText() );\n\n      // if not found, discard top TermInfo from stack, then try next element\n      if( currMap == null ) continue;\n      \n      // if found, search the longest phrase\n      phraseCandidate.add( ti );\n      while( true ){\n        ti = fieldTermStack.pop();\n        nextMap = null;\n        if( ti != null )\n          nextMap = currMap.getTermMap( ti.getText() );\n        if( ti == null || nextMap == null ){\n          if( ti != null ) \n            fieldTermStack.push( ti );\n          if( currMap.isValidTermOrPhrase( phraseCandidate ) ){\n            addIfNoOverlap( new WeightedPhraseInfo( phraseCandidate, currMap.getBoost(), currMap.getTermOrPhraseNumber() ) );\n          }\n          else{\n            while( phraseCandidate.size() > 1 ){\n              fieldTermStack.push( phraseCandidate.removeLast() );\n              currMap = fieldQuery.searchPhrase( field, phraseCandidate );\n              if( currMap != null ){\n                addIfNoOverlap( new WeightedPhraseInfo( phraseCandidate, currMap.getBoost(), currMap.getTermOrPhraseNumber() ) );\n                break;\n              }\n            }\n          }\n          break;\n        }\n        else{\n          phraseCandidate.add( ti );\n          currMap = nextMap;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0c066f7f6446f2d91513e81976f4b070a38763c7","date":1395242366,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldPhraseList#FieldPhraseList(FieldTermStack,FieldQuery,int).mjava","pathOld":"lucene/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldPhraseList#FieldPhraseList(FieldTermStack,FieldQuery,int).mjava","sourceNew":"  /**\n   * a constructor.\n   * \n   * @param fieldTermStack FieldTermStack object\n   * @param fieldQuery FieldQuery object\n   * @param phraseLimit maximum size of phraseList\n   */\n  public FieldPhraseList( FieldTermStack fieldTermStack, FieldQuery fieldQuery, int phraseLimit ){\n    final String field = fieldTermStack.getFieldName();\n\n    LinkedList<TermInfo> phraseCandidate = new LinkedList<>();\n    QueryPhraseMap currMap = null;\n    QueryPhraseMap nextMap = null;\n    while( !fieldTermStack.isEmpty() && (phraseList.size() < phraseLimit) )\n    {      \n      phraseCandidate.clear();\n\n      TermInfo ti = null;\n      TermInfo first = null;\n      \n      first = ti = fieldTermStack.pop();\n      currMap = fieldQuery.getFieldTermMap( field, ti.getText() );\n      while (currMap == null && ti.getNext() != first) {\n        ti = ti.getNext();\n        currMap = fieldQuery.getFieldTermMap( field, ti.getText() );\n      }\n\n      // if not found, discard top TermInfo from stack, then try next element\n      if( currMap == null ) continue;\n      \n      // if found, search the longest phrase\n      phraseCandidate.add( ti );\n      while( true ){\n        first = ti = fieldTermStack.pop();\n        nextMap = null;\n        if( ti != null ) {\n          nextMap = currMap.getTermMap( ti.getText() );\n          while (nextMap == null && ti.getNext() != first) {\n            ti = ti.getNext();\n            nextMap = currMap.getTermMap( ti.getText() );\n          }\n        }\n        if( ti == null || nextMap == null ){\n          if( ti != null ) \n            fieldTermStack.push( ti );\n          if( currMap.isValidTermOrPhrase( phraseCandidate ) ){\n            addIfNoOverlap( new WeightedPhraseInfo( phraseCandidate, currMap.getBoost(), currMap.getTermOrPhraseNumber() ) );\n          }\n          else{\n            while( phraseCandidate.size() > 1 ){\n              fieldTermStack.push( phraseCandidate.removeLast() );\n              currMap = fieldQuery.searchPhrase( field, phraseCandidate );\n              if( currMap != null ){\n                addIfNoOverlap( new WeightedPhraseInfo( phraseCandidate, currMap.getBoost(), currMap.getTermOrPhraseNumber() ) );\n                break;\n              }\n            }\n          }\n          break;\n        }\n        else{\n          phraseCandidate.add( ti );\n          currMap = nextMap;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * a constructor.\n   * \n   * @param fieldTermStack FieldTermStack object\n   * @param fieldQuery FieldQuery object\n   * @param phraseLimit maximum size of phraseList\n   */\n  public FieldPhraseList( FieldTermStack fieldTermStack, FieldQuery fieldQuery, int phraseLimit ){\n    final String field = fieldTermStack.getFieldName();\n\n    LinkedList<TermInfo> phraseCandidate = new LinkedList<>();\n    QueryPhraseMap currMap = null;\n    QueryPhraseMap nextMap = null;\n    while( !fieldTermStack.isEmpty() && (phraseList.size() < phraseLimit) )\n    {      \n      phraseCandidate.clear();\n\n      TermInfo ti = fieldTermStack.pop();\n      currMap = fieldQuery.getFieldTermMap( field, ti.getText() );\n\n      // if not found, discard top TermInfo from stack, then try next element\n      if( currMap == null ) continue;\n      \n      // if found, search the longest phrase\n      phraseCandidate.add( ti );\n      while( true ){\n        ti = fieldTermStack.pop();\n        nextMap = null;\n        if( ti != null )\n          nextMap = currMap.getTermMap( ti.getText() );\n        if( ti == null || nextMap == null ){\n          if( ti != null ) \n            fieldTermStack.push( ti );\n          if( currMap.isValidTermOrPhrase( phraseCandidate ) ){\n            addIfNoOverlap( new WeightedPhraseInfo( phraseCandidate, currMap.getBoost(), currMap.getTermOrPhraseNumber() ) );\n          }\n          else{\n            while( phraseCandidate.size() > 1 ){\n              fieldTermStack.push( phraseCandidate.removeLast() );\n              currMap = fieldQuery.searchPhrase( field, phraseCandidate );\n              if( currMap != null ){\n                addIfNoOverlap( new WeightedPhraseInfo( phraseCandidate, currMap.getBoost(), currMap.getTermOrPhraseNumber() ) );\n                break;\n              }\n            }\n          }\n          break;\n        }\n        else{\n          phraseCandidate.add( ti );\n          currMap = nextMap;\n        }\n      }\n    }\n  }\n\n","bugFix":["cfd0cdef6d792d7bc9c123a4d51723e2ba3f6e08"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"47d6c59c2165ec476da09e8ececaaf1776aaca46":["7327eec6fde8afb35c01f6234cb50c42a7c737d3"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["cfd0cdef6d792d7bc9c123a4d51723e2ba3f6e08"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":["4de9b9325d973e4bc4c97eb91fe119eafa6caa99"],"7327eec6fde8afb35c01f6234cb50c42a7c737d3":["4de9b9325d973e4bc4c97eb91fe119eafa6caa99"],"4de9b9325d973e4bc4c97eb91fe119eafa6caa99":["9f3f873f902c9e3821591809929b6f1283bc0298"],"0c066f7f6446f2d91513e81976f4b070a38763c7":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"9f3f873f902c9e3821591809929b6f1283bc0298":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"cfd0cdef6d792d7bc9c123a4d51723e2ba3f6e08":["47d6c59c2165ec476da09e8ececaaf1776aaca46"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0c066f7f6446f2d91513e81976f4b070a38763c7"]},"commit2Childs":{"47d6c59c2165ec476da09e8ececaaf1776aaca46":["cfd0cdef6d792d7bc9c123a4d51723e2ba3f6e08"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["0c066f7f6446f2d91513e81976f4b070a38763c7"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["9f3f873f902c9e3821591809929b6f1283bc0298"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":[],"7327eec6fde8afb35c01f6234cb50c42a7c737d3":["47d6c59c2165ec476da09e8ececaaf1776aaca46"],"4de9b9325d973e4bc4c97eb91fe119eafa6caa99":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","7327eec6fde8afb35c01f6234cb50c42a7c737d3"],"0c066f7f6446f2d91513e81976f4b070a38763c7":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9f3f873f902c9e3821591809929b6f1283bc0298":["4de9b9325d973e4bc4c97eb91fe119eafa6caa99"],"cfd0cdef6d792d7bc9c123a4d51723e2ba3f6e08":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}