{"path":"solr/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","commits":[{"id":"ec58fb7921964848d01bea54f8ec4a2ac813eaeb","date":1295476876,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokens  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokens, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<NamedList>();\n\n    final int[] positions = new int[tokens.size()];\n    int position = 0;    \n    for (int i = 0, c = tokens.size(); i < c; i++) {\n      AttributeSource token = tokens.get(i);\n      position += token.addAttribute(PositionIncrementAttribute.class).getPositionIncrement();\n      positions[i] = position;\n    }\n    \n    // sort the tokens by absoulte position\n    new SorterTemplate() {\n      @Override\n      protected void swap(int i, int j) {\n        Collections.swap(tokens, i, j);\n      }\n      \n      @Override\n      protected int compare(int i, int j) {\n        return positions[i] - positions[j];\n      }\n\n      @Override\n      protected void setPivot(int i) {\n        pivot = positions[i];\n      }\n  \n      @Override\n      protected int comparePivot(int j) {\n        return pivot - positions[j];\n      }\n      \n      private int pivot;\n    }.mergeSort(0, tokens.size() - 1);\n\n    FieldType fieldType = context.getFieldType();\n\n    final BytesRef rawBytes = new BytesRef();\n    final CharArr textBuf = new CharArr();\n    for (int i = 0, c = tokens.size(); i < c; i++) {\n      AttributeSource token = tokens.get(i);\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<Object>();\n      token.getAttribute(TermToBytesRefAttribute.class).toBytesRef(rawBytes);\n\n      textBuf.reset();\n      fieldType.indexedToReadable(rawBytes, textBuf);\n      final String text = textBuf.toString();\n\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      tokenNamedList.add(\"position\", positions[i]);\n\n      token.reflectWith(new AttributeReflector() {\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof Payload) {\n            final Payload p = (Payload) value;\n            value = new BytesRef(p.getData()).toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ba7fd61ba5cb8882a293be3e8196670f8f1d0796","date":1295483860,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","pathOld":"solr/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","sourceNew":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokens  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokens, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<NamedList>();\n\n    final int[] positions = new int[tokens.size()];\n    int position = 0;    \n    for (int i = 0, c = tokens.size(); i < c; i++) {\n      AttributeSource token = tokens.get(i);\n      position += token.addAttribute(PositionIncrementAttribute.class).getPositionIncrement();\n      positions[i] = position;\n    }\n    \n    // sort the tokens by absoulte position\n    new SorterTemplate() {\n      @Override\n      protected void swap(int i, int j) {\n        final int p = positions[i];\n        positions[i] = positions[j];\n        positions[j] = p;\n        Collections.swap(tokens, i, j);\n      }\n      \n      @Override\n      protected int compare(int i, int j) {\n        return positions[i] - positions[j];\n      }\n\n      @Override\n      protected void setPivot(int i) {\n        pivot = positions[i];\n      }\n  \n      @Override\n      protected int comparePivot(int j) {\n        return pivot - positions[j];\n      }\n      \n      private int pivot;\n    }.mergeSort(0, tokens.size() - 1);\n\n    FieldType fieldType = context.getFieldType();\n\n    final BytesRef rawBytes = new BytesRef();\n    final CharArr textBuf = new CharArr();\n    for (int i = 0, c = tokens.size(); i < c; i++) {\n      AttributeSource token = tokens.get(i);\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<Object>();\n      token.getAttribute(TermToBytesRefAttribute.class).toBytesRef(rawBytes);\n\n      textBuf.reset();\n      fieldType.indexedToReadable(rawBytes, textBuf);\n      final String text = textBuf.toString();\n\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      tokenNamedList.add(\"position\", positions[i]);\n\n      token.reflectWith(new AttributeReflector() {\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof Payload) {\n            final Payload p = (Payload) value;\n            value = new BytesRef(p.getData()).toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","sourceOld":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokens  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokens, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<NamedList>();\n\n    final int[] positions = new int[tokens.size()];\n    int position = 0;    \n    for (int i = 0, c = tokens.size(); i < c; i++) {\n      AttributeSource token = tokens.get(i);\n      position += token.addAttribute(PositionIncrementAttribute.class).getPositionIncrement();\n      positions[i] = position;\n    }\n    \n    // sort the tokens by absoulte position\n    new SorterTemplate() {\n      @Override\n      protected void swap(int i, int j) {\n        Collections.swap(tokens, i, j);\n      }\n      \n      @Override\n      protected int compare(int i, int j) {\n        return positions[i] - positions[j];\n      }\n\n      @Override\n      protected void setPivot(int i) {\n        pivot = positions[i];\n      }\n  \n      @Override\n      protected int comparePivot(int j) {\n        return pivot - positions[j];\n      }\n      \n      private int pivot;\n    }.mergeSort(0, tokens.size() - 1);\n\n    FieldType fieldType = context.getFieldType();\n\n    final BytesRef rawBytes = new BytesRef();\n    final CharArr textBuf = new CharArr();\n    for (int i = 0, c = tokens.size(); i < c; i++) {\n      AttributeSource token = tokens.get(i);\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<Object>();\n      token.getAttribute(TermToBytesRefAttribute.class).toBytesRef(rawBytes);\n\n      textBuf.reset();\n      fieldType.indexedToReadable(rawBytes, textBuf);\n      final String text = textBuf.toString();\n\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      tokenNamedList.add(\"position\", positions[i]);\n\n      token.reflectWith(new AttributeReflector() {\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof Payload) {\n            final Payload p = (Payload) value;\n            value = new BytesRef(p.getData()).toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e79a6d080bdd5b2a8f56342cf571b5476de04180","date":1295638686,"type":0,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokens  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokens, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<NamedList>();\n\n    final int[] positions = new int[tokens.size()];\n    int position = 0;    \n    for (int i = 0, c = tokens.size(); i < c; i++) {\n      AttributeSource token = tokens.get(i);\n      position += token.addAttribute(PositionIncrementAttribute.class).getPositionIncrement();\n      positions[i] = position;\n    }\n    \n    // sort the tokens by absoulte position\n    new SorterTemplate() {\n      @Override\n      protected void swap(int i, int j) {\n        final int p = positions[i];\n        positions[i] = positions[j];\n        positions[j] = p;\n        Collections.swap(tokens, i, j);\n      }\n      \n      @Override\n      protected int compare(int i, int j) {\n        return positions[i] - positions[j];\n      }\n\n      @Override\n      protected void setPivot(int i) {\n        pivot = positions[i];\n      }\n  \n      @Override\n      protected int comparePivot(int j) {\n        return pivot - positions[j];\n      }\n      \n      private int pivot;\n    }.mergeSort(0, tokens.size() - 1);\n\n    FieldType fieldType = context.getFieldType();\n\n    final BytesRef rawBytes = new BytesRef();\n    final CharArr textBuf = new CharArr();\n    for (int i = 0, c = tokens.size(); i < c; i++) {\n      AttributeSource token = tokens.get(i);\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<Object>();\n      token.getAttribute(TermToBytesRefAttribute.class).toBytesRef(rawBytes);\n\n      textBuf.reset();\n      fieldType.indexedToReadable(rawBytes, textBuf);\n      final String text = textBuf.toString();\n\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      tokenNamedList.add(\"position\", positions[i]);\n\n      token.reflectWith(new AttributeReflector() {\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof Payload) {\n            final Payload p = (Payload) value;\n            value = new BytesRef(p.getData()).toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokens  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokens, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<NamedList>();\n\n    final int[] positions = new int[tokens.size()];\n    int position = 0;    \n    for (int i = 0, c = tokens.size(); i < c; i++) {\n      AttributeSource token = tokens.get(i);\n      position += token.addAttribute(PositionIncrementAttribute.class).getPositionIncrement();\n      positions[i] = position;\n    }\n    \n    // sort the tokens by absoulte position\n    new SorterTemplate() {\n      @Override\n      protected void swap(int i, int j) {\n        final int p = positions[i];\n        positions[i] = positions[j];\n        positions[j] = p;\n        Collections.swap(tokens, i, j);\n      }\n      \n      @Override\n      protected int compare(int i, int j) {\n        return positions[i] - positions[j];\n      }\n\n      @Override\n      protected void setPivot(int i) {\n        pivot = positions[i];\n      }\n  \n      @Override\n      protected int comparePivot(int j) {\n        return pivot - positions[j];\n      }\n      \n      private int pivot;\n    }.mergeSort(0, tokens.size() - 1);\n\n    FieldType fieldType = context.getFieldType();\n\n    final BytesRef rawBytes = new BytesRef();\n    final CharArr textBuf = new CharArr();\n    for (int i = 0, c = tokens.size(); i < c; i++) {\n      AttributeSource token = tokens.get(i);\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<Object>();\n      token.getAttribute(TermToBytesRefAttribute.class).toBytesRef(rawBytes);\n\n      textBuf.reset();\n      fieldType.indexedToReadable(rawBytes, textBuf);\n      final String text = textBuf.toString();\n\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      tokenNamedList.add(\"position\", positions[i]);\n\n      token.reflectWith(new AttributeReflector() {\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof Payload) {\n            final Payload p = (Payload) value;\n            value = new BytesRef(p.getData()).toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b3d07f1ae3b58102f36f3393c397d78ba4e547a4","date":1300715535,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","pathOld":"solr/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","sourceNew":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokens  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokens, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<NamedList>();\n\n    final int[] positions = new int[tokens.size()];\n    int position = 0;    \n    for (int i = 0, c = tokens.size(); i < c; i++) {\n      AttributeSource token = tokens.get(i);\n      position += token.addAttribute(PositionIncrementAttribute.class).getPositionIncrement();\n      positions[i] = position;\n    }\n    \n    // sort the tokens by absoulte position\n    new SorterTemplate() {\n      @Override\n      protected void swap(int i, int j) {\n        final int p = positions[i];\n        positions[i] = positions[j];\n        positions[j] = p;\n        Collections.swap(tokens, i, j);\n      }\n      \n      @Override\n      protected int compare(int i, int j) {\n        return positions[i] - positions[j];\n      }\n\n      @Override\n      protected void setPivot(int i) {\n        pivot = positions[i];\n      }\n  \n      @Override\n      protected int comparePivot(int j) {\n        return pivot - positions[j];\n      }\n      \n      private int pivot;\n    }.mergeSort(0, tokens.size() - 1);\n\n    FieldType fieldType = context.getFieldType();\n\n    final CharArr textBuf = new CharArr();\n    for (int i = 0, c = tokens.size(); i < c; i++) {\n      AttributeSource token = tokens.get(i);\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<Object>();\n      final TermToBytesRefAttribute termAtt = token.getAttribute(TermToBytesRefAttribute.class);\n      BytesRef rawBytes = termAtt.getBytesRef();\n      termAtt.fillBytesRef();\n\n      textBuf.reset();\n      fieldType.indexedToReadable(rawBytes, textBuf);\n      final String text = textBuf.toString();\n\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      tokenNamedList.add(\"position\", positions[i]);\n\n      token.reflectWith(new AttributeReflector() {\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof Payload) {\n            final Payload p = (Payload) value;\n            value = new BytesRef(p.getData()).toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","sourceOld":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokens  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokens, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<NamedList>();\n\n    final int[] positions = new int[tokens.size()];\n    int position = 0;    \n    for (int i = 0, c = tokens.size(); i < c; i++) {\n      AttributeSource token = tokens.get(i);\n      position += token.addAttribute(PositionIncrementAttribute.class).getPositionIncrement();\n      positions[i] = position;\n    }\n    \n    // sort the tokens by absoulte position\n    new SorterTemplate() {\n      @Override\n      protected void swap(int i, int j) {\n        final int p = positions[i];\n        positions[i] = positions[j];\n        positions[j] = p;\n        Collections.swap(tokens, i, j);\n      }\n      \n      @Override\n      protected int compare(int i, int j) {\n        return positions[i] - positions[j];\n      }\n\n      @Override\n      protected void setPivot(int i) {\n        pivot = positions[i];\n      }\n  \n      @Override\n      protected int comparePivot(int j) {\n        return pivot - positions[j];\n      }\n      \n      private int pivot;\n    }.mergeSort(0, tokens.size() - 1);\n\n    FieldType fieldType = context.getFieldType();\n\n    final BytesRef rawBytes = new BytesRef();\n    final CharArr textBuf = new CharArr();\n    for (int i = 0, c = tokens.size(); i < c; i++) {\n      AttributeSource token = tokens.get(i);\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<Object>();\n      token.getAttribute(TermToBytesRefAttribute.class).toBytesRef(rawBytes);\n\n      textBuf.reset();\n      fieldType.indexedToReadable(rawBytes, textBuf);\n      final String text = textBuf.toString();\n\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      tokenNamedList.add(\"position\", positions[i]);\n\n      token.reflectWith(new AttributeReflector() {\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof Payload) {\n            final Payload p = (Payload) value;\n            value = new BytesRef(p.getData()).toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","bugFix":null,"bugIntro":["fb1921ba901ad34c1b448d0b8c98a563dfea7dd9","fb1921ba901ad34c1b448d0b8c98a563dfea7dd9","fb1921ba901ad34c1b448d0b8c98a563dfea7dd9"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d619839baa8ce5503e496b94a9e42ad6f079293f","date":1301309428,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","pathOld":"solr/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","sourceNew":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokens  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokens, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<NamedList>();\n\n    final int[] positions = new int[tokens.size()];\n    int position = 0;    \n    for (int i = 0, c = tokens.size(); i < c; i++) {\n      AttributeSource token = tokens.get(i);\n      position += token.addAttribute(PositionIncrementAttribute.class).getPositionIncrement();\n      positions[i] = position;\n    }\n    \n    // sort the tokens by absoulte position\n    new SorterTemplate() {\n      @Override\n      protected void swap(int i, int j) {\n        final int p = positions[i];\n        positions[i] = positions[j];\n        positions[j] = p;\n        Collections.swap(tokens, i, j);\n      }\n      \n      @Override\n      protected int compare(int i, int j) {\n        return positions[i] - positions[j];\n      }\n\n      @Override\n      protected void setPivot(int i) {\n        pivot = positions[i];\n      }\n  \n      @Override\n      protected int comparePivot(int j) {\n        return pivot - positions[j];\n      }\n      \n      private int pivot;\n    }.mergeSort(0, tokens.size() - 1);\n\n    FieldType fieldType = context.getFieldType();\n\n    final CharArr textBuf = new CharArr();\n    for (int i = 0, c = tokens.size(); i < c; i++) {\n      AttributeSource token = tokens.get(i);\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<Object>();\n      final TermToBytesRefAttribute termAtt = token.getAttribute(TermToBytesRefAttribute.class);\n      BytesRef rawBytes = termAtt.getBytesRef();\n      termAtt.fillBytesRef();\n\n      textBuf.reset();\n      fieldType.indexedToReadable(rawBytes, textBuf);\n      final String text = textBuf.toString();\n\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      tokenNamedList.add(\"position\", positions[i]);\n\n      token.reflectWith(new AttributeReflector() {\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof Payload) {\n            final Payload p = (Payload) value;\n            value = new BytesRef(p.getData()).toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","sourceOld":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokens  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokens, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<NamedList>();\n\n    final int[] positions = new int[tokens.size()];\n    int position = 0;    \n    for (int i = 0, c = tokens.size(); i < c; i++) {\n      AttributeSource token = tokens.get(i);\n      position += token.addAttribute(PositionIncrementAttribute.class).getPositionIncrement();\n      positions[i] = position;\n    }\n    \n    // sort the tokens by absoulte position\n    new SorterTemplate() {\n      @Override\n      protected void swap(int i, int j) {\n        final int p = positions[i];\n        positions[i] = positions[j];\n        positions[j] = p;\n        Collections.swap(tokens, i, j);\n      }\n      \n      @Override\n      protected int compare(int i, int j) {\n        return positions[i] - positions[j];\n      }\n\n      @Override\n      protected void setPivot(int i) {\n        pivot = positions[i];\n      }\n  \n      @Override\n      protected int comparePivot(int j) {\n        return pivot - positions[j];\n      }\n      \n      private int pivot;\n    }.mergeSort(0, tokens.size() - 1);\n\n    FieldType fieldType = context.getFieldType();\n\n    final BytesRef rawBytes = new BytesRef();\n    final CharArr textBuf = new CharArr();\n    for (int i = 0, c = tokens.size(); i < c; i++) {\n      AttributeSource token = tokens.get(i);\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<Object>();\n      token.getAttribute(TermToBytesRefAttribute.class).toBytesRef(rawBytes);\n\n      textBuf.reset();\n      fieldType.indexedToReadable(rawBytes, textBuf);\n      final String text = textBuf.toString();\n\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      tokenNamedList.add(\"position\", positions[i]);\n\n      token.reflectWith(new AttributeReflector() {\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof Payload) {\n            final Payload p = (Payload) value;\n            value = new BytesRef(p.getData()).toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c0ef0193974807e4bddf5432a6b0287fe4d6c9df","date":1301476645,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","pathOld":"solr/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","sourceNew":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokens  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokens, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<NamedList>();\n\n    final int[] positions = new int[tokens.size()];\n    int position = 0;    \n    for (int i = 0, c = tokens.size(); i < c; i++) {\n      AttributeSource token = tokens.get(i);\n      position += token.addAttribute(PositionIncrementAttribute.class).getPositionIncrement();\n      positions[i] = position;\n    }\n    \n    // sort the tokens by absoulte position\n    new SorterTemplate() {\n      @Override\n      protected void swap(int i, int j) {\n        final int p = positions[i];\n        positions[i] = positions[j];\n        positions[j] = p;\n        Collections.swap(tokens, i, j);\n      }\n      \n      @Override\n      protected int compare(int i, int j) {\n        return positions[i] - positions[j];\n      }\n\n      @Override\n      protected void setPivot(int i) {\n        pivot = positions[i];\n      }\n  \n      @Override\n      protected int comparePivot(int j) {\n        return pivot - positions[j];\n      }\n      \n      private int pivot;\n    }.mergeSort(0, tokens.size() - 1);\n\n    FieldType fieldType = context.getFieldType();\n\n    final CharArr textBuf = new CharArr();\n    for (int i = 0, c = tokens.size(); i < c; i++) {\n      AttributeSource token = tokens.get(i);\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<Object>();\n      final TermToBytesRefAttribute termAtt = token.getAttribute(TermToBytesRefAttribute.class);\n      BytesRef rawBytes = termAtt.getBytesRef();\n      termAtt.fillBytesRef();\n\n      textBuf.reset();\n      fieldType.indexedToReadable(rawBytes, textBuf);\n      final String text = textBuf.toString();\n\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      tokenNamedList.add(\"position\", positions[i]);\n\n      token.reflectWith(new AttributeReflector() {\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof Payload) {\n            final Payload p = (Payload) value;\n            value = new BytesRef(p.getData()).toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","sourceOld":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokens  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokens, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<NamedList>();\n\n    final int[] positions = new int[tokens.size()];\n    int position = 0;    \n    for (int i = 0, c = tokens.size(); i < c; i++) {\n      AttributeSource token = tokens.get(i);\n      position += token.addAttribute(PositionIncrementAttribute.class).getPositionIncrement();\n      positions[i] = position;\n    }\n    \n    // sort the tokens by absoulte position\n    new SorterTemplate() {\n      @Override\n      protected void swap(int i, int j) {\n        final int p = positions[i];\n        positions[i] = positions[j];\n        positions[j] = p;\n        Collections.swap(tokens, i, j);\n      }\n      \n      @Override\n      protected int compare(int i, int j) {\n        return positions[i] - positions[j];\n      }\n\n      @Override\n      protected void setPivot(int i) {\n        pivot = positions[i];\n      }\n  \n      @Override\n      protected int comparePivot(int j) {\n        return pivot - positions[j];\n      }\n      \n      private int pivot;\n    }.mergeSort(0, tokens.size() - 1);\n\n    FieldType fieldType = context.getFieldType();\n\n    final BytesRef rawBytes = new BytesRef();\n    final CharArr textBuf = new CharArr();\n    for (int i = 0, c = tokens.size(); i < c; i++) {\n      AttributeSource token = tokens.get(i);\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<Object>();\n      token.getAttribute(TermToBytesRefAttribute.class).toBytesRef(rawBytes);\n\n      textBuf.reset();\n      fieldType.indexedToReadable(rawBytes, textBuf);\n      final String text = textBuf.toString();\n\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      tokenNamedList.add(\"position\", positions[i]);\n\n      token.reflectWith(new AttributeReflector() {\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof Payload) {\n            final Payload p = (Payload) value;\n            value = new BytesRef(p.getData()).toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a1b3a24d5d9b47345473ff564f5cc127a7b526b4","date":1306277076,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","pathOld":"solr/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","sourceNew":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokens  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokens, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<NamedList>();\n\n    final int[] positions = new int[tokens.size()];\n    int position = 0;    \n    for (int i = 0, c = tokens.size(); i < c; i++) {\n      AttributeSource token = tokens.get(i);\n      position += token.addAttribute(PositionIncrementAttribute.class).getPositionIncrement();\n      positions[i] = position;\n    }\n    \n    // sort the tokens by absoulte position\n    new SorterTemplate() {\n      @Override\n      protected void swap(int i, int j) {\n        final int p = positions[i];\n        positions[i] = positions[j];\n        positions[j] = p;\n        Collections.swap(tokens, i, j);\n      }\n      \n      @Override\n      protected int compare(int i, int j) {\n        return positions[i] - positions[j];\n      }\n\n      @Override\n      protected void setPivot(int i) {\n        pivot = positions[i];\n      }\n  \n      @Override\n      protected int comparePivot(int j) {\n        return pivot - positions[j];\n      }\n      \n      private int pivot;\n    }.mergeSort(0, tokens.size() - 1);\n\n    FieldType fieldType = context.getFieldType();\n\n    for (int i = 0, c = tokens.size(); i < c; i++) {\n      AttributeSource token = tokens.get(i);\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<Object>();\n      final TermToBytesRefAttribute termAtt = token.getAttribute(TermToBytesRefAttribute.class);\n      BytesRef rawBytes = termAtt.getBytesRef();\n      termAtt.fillBytesRef();\n      final String text = fieldType.indexedToReadable(rawBytes, new CharsRef(rawBytes.length)).toString();\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      tokenNamedList.add(\"position\", positions[i]);\n\n      token.reflectWith(new AttributeReflector() {\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof Payload) {\n            final Payload p = (Payload) value;\n            value = new BytesRef(p.getData()).toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","sourceOld":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokens  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokens, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<NamedList>();\n\n    final int[] positions = new int[tokens.size()];\n    int position = 0;    \n    for (int i = 0, c = tokens.size(); i < c; i++) {\n      AttributeSource token = tokens.get(i);\n      position += token.addAttribute(PositionIncrementAttribute.class).getPositionIncrement();\n      positions[i] = position;\n    }\n    \n    // sort the tokens by absoulte position\n    new SorterTemplate() {\n      @Override\n      protected void swap(int i, int j) {\n        final int p = positions[i];\n        positions[i] = positions[j];\n        positions[j] = p;\n        Collections.swap(tokens, i, j);\n      }\n      \n      @Override\n      protected int compare(int i, int j) {\n        return positions[i] - positions[j];\n      }\n\n      @Override\n      protected void setPivot(int i) {\n        pivot = positions[i];\n      }\n  \n      @Override\n      protected int comparePivot(int j) {\n        return pivot - positions[j];\n      }\n      \n      private int pivot;\n    }.mergeSort(0, tokens.size() - 1);\n\n    FieldType fieldType = context.getFieldType();\n\n    final CharArr textBuf = new CharArr();\n    for (int i = 0, c = tokens.size(); i < c; i++) {\n      AttributeSource token = tokens.get(i);\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<Object>();\n      final TermToBytesRefAttribute termAtt = token.getAttribute(TermToBytesRefAttribute.class);\n      BytesRef rawBytes = termAtt.getBytesRef();\n      termAtt.fillBytesRef();\n\n      textBuf.reset();\n      fieldType.indexedToReadable(rawBytes, textBuf);\n      final String text = textBuf.toString();\n\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      tokenNamedList.add(\"position\", positions[i]);\n\n      token.reflectWith(new AttributeReflector() {\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof Payload) {\n            final Payload p = (Payload) value;\n            value = new BytesRef(p.getData()).toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","bugFix":null,"bugIntro":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","date":1306767085,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","pathOld":"solr/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","sourceNew":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokens  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokens, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<NamedList>();\n\n    final int[] positions = new int[tokens.size()];\n    int position = 0;    \n    for (int i = 0, c = tokens.size(); i < c; i++) {\n      AttributeSource token = tokens.get(i);\n      position += token.addAttribute(PositionIncrementAttribute.class).getPositionIncrement();\n      positions[i] = position;\n    }\n    \n    // sort the tokens by absoulte position\n    new SorterTemplate() {\n      @Override\n      protected void swap(int i, int j) {\n        final int p = positions[i];\n        positions[i] = positions[j];\n        positions[j] = p;\n        Collections.swap(tokens, i, j);\n      }\n      \n      @Override\n      protected int compare(int i, int j) {\n        return positions[i] - positions[j];\n      }\n\n      @Override\n      protected void setPivot(int i) {\n        pivot = positions[i];\n      }\n  \n      @Override\n      protected int comparePivot(int j) {\n        return pivot - positions[j];\n      }\n      \n      private int pivot;\n    }.mergeSort(0, tokens.size() - 1);\n\n    FieldType fieldType = context.getFieldType();\n\n    for (int i = 0, c = tokens.size(); i < c; i++) {\n      AttributeSource token = tokens.get(i);\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<Object>();\n      final TermToBytesRefAttribute termAtt = token.getAttribute(TermToBytesRefAttribute.class);\n      BytesRef rawBytes = termAtt.getBytesRef();\n      termAtt.fillBytesRef();\n      final String text = fieldType.indexedToReadable(rawBytes, new CharsRef(rawBytes.length)).toString();\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      tokenNamedList.add(\"position\", positions[i]);\n\n      token.reflectWith(new AttributeReflector() {\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof Payload) {\n            final Payload p = (Payload) value;\n            value = new BytesRef(p.getData()).toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","sourceOld":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokens  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokens, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<NamedList>();\n\n    final int[] positions = new int[tokens.size()];\n    int position = 0;    \n    for (int i = 0, c = tokens.size(); i < c; i++) {\n      AttributeSource token = tokens.get(i);\n      position += token.addAttribute(PositionIncrementAttribute.class).getPositionIncrement();\n      positions[i] = position;\n    }\n    \n    // sort the tokens by absoulte position\n    new SorterTemplate() {\n      @Override\n      protected void swap(int i, int j) {\n        final int p = positions[i];\n        positions[i] = positions[j];\n        positions[j] = p;\n        Collections.swap(tokens, i, j);\n      }\n      \n      @Override\n      protected int compare(int i, int j) {\n        return positions[i] - positions[j];\n      }\n\n      @Override\n      protected void setPivot(int i) {\n        pivot = positions[i];\n      }\n  \n      @Override\n      protected int comparePivot(int j) {\n        return pivot - positions[j];\n      }\n      \n      private int pivot;\n    }.mergeSort(0, tokens.size() - 1);\n\n    FieldType fieldType = context.getFieldType();\n\n    final CharArr textBuf = new CharArr();\n    for (int i = 0, c = tokens.size(); i < c; i++) {\n      AttributeSource token = tokens.get(i);\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<Object>();\n      final TermToBytesRefAttribute termAtt = token.getAttribute(TermToBytesRefAttribute.class);\n      BytesRef rawBytes = termAtt.getBytesRef();\n      termAtt.fillBytesRef();\n\n      textBuf.reset();\n      fieldType.indexedToReadable(rawBytes, textBuf);\n      final String text = textBuf.toString();\n\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      tokenNamedList.add(\"position\", positions[i]);\n\n      token.reflectWith(new AttributeReflector() {\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof Payload) {\n            final Payload p = (Payload) value;\n            value = new BytesRef(p.getData()).toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2e10cb22a8bdb44339e282925a29182bb2f3174d","date":1306841137,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","pathOld":"solr/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","sourceNew":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokens  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokens, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<NamedList>();\n\n    final int[] positions = new int[tokens.size()];\n    int position = 0;    \n    for (int i = 0, c = tokens.size(); i < c; i++) {\n      AttributeSource token = tokens.get(i);\n      position += token.addAttribute(PositionIncrementAttribute.class).getPositionIncrement();\n      positions[i] = position;\n    }\n    \n    // sort the tokens by absoulte position\n    new SorterTemplate() {\n      @Override\n      protected void swap(int i, int j) {\n        final int p = positions[i];\n        positions[i] = positions[j];\n        positions[j] = p;\n        Collections.swap(tokens, i, j);\n      }\n      \n      @Override\n      protected int compare(int i, int j) {\n        return positions[i] - positions[j];\n      }\n\n      @Override\n      protected void setPivot(int i) {\n        pivot = positions[i];\n      }\n  \n      @Override\n      protected int comparePivot(int j) {\n        return pivot - positions[j];\n      }\n      \n      private int pivot;\n    }.mergeSort(0, tokens.size() - 1);\n\n    FieldType fieldType = context.getFieldType();\n\n    for (int i = 0, c = tokens.size(); i < c; i++) {\n      AttributeSource token = tokens.get(i);\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<Object>();\n      final TermToBytesRefAttribute termAtt = token.getAttribute(TermToBytesRefAttribute.class);\n      BytesRef rawBytes = termAtt.getBytesRef();\n      termAtt.fillBytesRef();\n      final String text = fieldType.indexedToReadable(rawBytes, new CharsRef(rawBytes.length)).toString();\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      tokenNamedList.add(\"position\", positions[i]);\n\n      token.reflectWith(new AttributeReflector() {\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof Payload) {\n            final Payload p = (Payload) value;\n            value = new BytesRef(p.getData()).toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","sourceOld":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokens  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokens, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<NamedList>();\n\n    final int[] positions = new int[tokens.size()];\n    int position = 0;    \n    for (int i = 0, c = tokens.size(); i < c; i++) {\n      AttributeSource token = tokens.get(i);\n      position += token.addAttribute(PositionIncrementAttribute.class).getPositionIncrement();\n      positions[i] = position;\n    }\n    \n    // sort the tokens by absoulte position\n    new SorterTemplate() {\n      @Override\n      protected void swap(int i, int j) {\n        final int p = positions[i];\n        positions[i] = positions[j];\n        positions[j] = p;\n        Collections.swap(tokens, i, j);\n      }\n      \n      @Override\n      protected int compare(int i, int j) {\n        return positions[i] - positions[j];\n      }\n\n      @Override\n      protected void setPivot(int i) {\n        pivot = positions[i];\n      }\n  \n      @Override\n      protected int comparePivot(int j) {\n        return pivot - positions[j];\n      }\n      \n      private int pivot;\n    }.mergeSort(0, tokens.size() - 1);\n\n    FieldType fieldType = context.getFieldType();\n\n    final CharArr textBuf = new CharArr();\n    for (int i = 0, c = tokens.size(); i < c; i++) {\n      AttributeSource token = tokens.get(i);\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<Object>();\n      final TermToBytesRefAttribute termAtt = token.getAttribute(TermToBytesRefAttribute.class);\n      BytesRef rawBytes = termAtt.getBytesRef();\n      termAtt.fillBytesRef();\n\n      textBuf.reset();\n      fieldType.indexedToReadable(rawBytes, textBuf);\n      final String text = textBuf.toString();\n\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      tokenNamedList.add(\"position\", positions[i]);\n\n      token.reflectWith(new AttributeReflector() {\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof Payload) {\n            final Payload p = (Payload) value;\n            value = new BytesRef(p.getData()).toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0487f900016b7da69f089f740e28192189ef3972","date":1307810819,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","pathOld":"solr/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","sourceNew":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokens  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokenList, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<NamedList>();\n    final FieldType fieldType = context.getFieldType();\n    final AttributeSource[] tokens = tokenList.toArray(new AttributeSource[tokenList.size()]);\n    \n    // sort the tokens by absoulte position\n    ArrayUtil.mergeSort(tokens, new Comparator<AttributeSource>() {\n      public int compare(AttributeSource a, AttributeSource b) {\n        return arrayCompare(\n          a.getAttribute(TokenTrackingAttribute.class).getPositions(),\n          b.getAttribute(TokenTrackingAttribute.class).getPositions()\n        );\n      }\n      \n      private int arrayCompare(int[] a, int[] b) {\n        int p = 0;\n        final int stop = Math.min(a.length, b.length);\n        while(p < stop) {\n          int diff = a[p] - b[p];\n          if (diff != 0) return diff;\n          p++;\n        }\n        // One is a prefix of the other, or, they are equal:\n        return a.length - b.length;\n      }\n    });\n\n    for (int i = 0; i < tokens.length; i++) {\n      AttributeSource token = tokens[i];\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<Object>();\n      final TermToBytesRefAttribute termAtt = token.getAttribute(TermToBytesRefAttribute.class);\n      BytesRef rawBytes = termAtt.getBytesRef();\n      termAtt.fillBytesRef();\n      final String text = fieldType.indexedToReadable(rawBytes, new CharsRef(rawBytes.length)).toString();\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      token.reflectWith(new AttributeReflector() {\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof Payload) {\n            final Payload p = (Payload) value;\n            value = new BytesRef(p.getData()).toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","sourceOld":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokens  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokens, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<NamedList>();\n\n    final int[] positions = new int[tokens.size()];\n    int position = 0;    \n    for (int i = 0, c = tokens.size(); i < c; i++) {\n      AttributeSource token = tokens.get(i);\n      position += token.addAttribute(PositionIncrementAttribute.class).getPositionIncrement();\n      positions[i] = position;\n    }\n    \n    // sort the tokens by absoulte position\n    new SorterTemplate() {\n      @Override\n      protected void swap(int i, int j) {\n        final int p = positions[i];\n        positions[i] = positions[j];\n        positions[j] = p;\n        Collections.swap(tokens, i, j);\n      }\n      \n      @Override\n      protected int compare(int i, int j) {\n        return positions[i] - positions[j];\n      }\n\n      @Override\n      protected void setPivot(int i) {\n        pivot = positions[i];\n      }\n  \n      @Override\n      protected int comparePivot(int j) {\n        return pivot - positions[j];\n      }\n      \n      private int pivot;\n    }.mergeSort(0, tokens.size() - 1);\n\n    FieldType fieldType = context.getFieldType();\n\n    for (int i = 0, c = tokens.size(); i < c; i++) {\n      AttributeSource token = tokens.get(i);\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<Object>();\n      final TermToBytesRefAttribute termAtt = token.getAttribute(TermToBytesRefAttribute.class);\n      BytesRef rawBytes = termAtt.getBytesRef();\n      termAtt.fillBytesRef();\n      final String text = fieldType.indexedToReadable(rawBytes, new CharsRef(rawBytes.length)).toString();\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      tokenNamedList.add(\"position\", positions[i]);\n\n      token.reflectWith(new AttributeReflector() {\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof Payload) {\n            final Payload p = (Payload) value;\n            value = new BytesRef(p.getData()).toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9ed208afa1e7aa98899ddb1dedfddedddf898253","date":1308079587,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","pathOld":"solr/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","sourceNew":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokens  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokenList, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<NamedList>();\n    final FieldType fieldType = context.getFieldType();\n    final AttributeSource[] tokens = tokenList.toArray(new AttributeSource[tokenList.size()]);\n    \n    // sort the tokens by absoulte position\n    ArrayUtil.mergeSort(tokens, new Comparator<AttributeSource>() {\n      public int compare(AttributeSource a, AttributeSource b) {\n        return arrayCompare(\n          a.getAttribute(TokenTrackingAttribute.class).getPositions(),\n          b.getAttribute(TokenTrackingAttribute.class).getPositions()\n        );\n      }\n      \n      private int arrayCompare(int[] a, int[] b) {\n        int p = 0;\n        final int stop = Math.min(a.length, b.length);\n        while(p < stop) {\n          int diff = a[p] - b[p];\n          if (diff != 0) return diff;\n          p++;\n        }\n        // One is a prefix of the other, or, they are equal:\n        return a.length - b.length;\n      }\n    });\n\n    for (int i = 0; i < tokens.length; i++) {\n      AttributeSource token = tokens[i];\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<Object>();\n      final TermToBytesRefAttribute termAtt = token.getAttribute(TermToBytesRefAttribute.class);\n      BytesRef rawBytes = termAtt.getBytesRef();\n      termAtt.fillBytesRef();\n      final String text = fieldType.indexedToReadable(rawBytes, new CharsRef(rawBytes.length)).toString();\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      token.reflectWith(new AttributeReflector() {\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof Payload) {\n            final Payload p = (Payload) value;\n            value = new BytesRef(p.getData()).toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","sourceOld":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokens  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokens, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<NamedList>();\n\n    final int[] positions = new int[tokens.size()];\n    int position = 0;    \n    for (int i = 0, c = tokens.size(); i < c; i++) {\n      AttributeSource token = tokens.get(i);\n      position += token.addAttribute(PositionIncrementAttribute.class).getPositionIncrement();\n      positions[i] = position;\n    }\n    \n    // sort the tokens by absoulte position\n    new SorterTemplate() {\n      @Override\n      protected void swap(int i, int j) {\n        final int p = positions[i];\n        positions[i] = positions[j];\n        positions[j] = p;\n        Collections.swap(tokens, i, j);\n      }\n      \n      @Override\n      protected int compare(int i, int j) {\n        return positions[i] - positions[j];\n      }\n\n      @Override\n      protected void setPivot(int i) {\n        pivot = positions[i];\n      }\n  \n      @Override\n      protected int comparePivot(int j) {\n        return pivot - positions[j];\n      }\n      \n      private int pivot;\n    }.mergeSort(0, tokens.size() - 1);\n\n    FieldType fieldType = context.getFieldType();\n\n    for (int i = 0, c = tokens.size(); i < c; i++) {\n      AttributeSource token = tokens.get(i);\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<Object>();\n      final TermToBytesRefAttribute termAtt = token.getAttribute(TermToBytesRefAttribute.class);\n      BytesRef rawBytes = termAtt.getBytesRef();\n      termAtt.fillBytesRef();\n      final String text = fieldType.indexedToReadable(rawBytes, new CharsRef(rawBytes.length)).toString();\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      tokenNamedList.add(\"position\", positions[i]);\n\n      token.reflectWith(new AttributeReflector() {\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof Payload) {\n            final Payload p = (Payload) value;\n            value = new BytesRef(p.getData()).toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","pathOld":"solr/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","sourceNew":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokens  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokenList, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<NamedList>();\n    final FieldType fieldType = context.getFieldType();\n    final AttributeSource[] tokens = tokenList.toArray(new AttributeSource[tokenList.size()]);\n    \n    // sort the tokens by absoulte position\n    ArrayUtil.mergeSort(tokens, new Comparator<AttributeSource>() {\n      public int compare(AttributeSource a, AttributeSource b) {\n        return arrayCompare(\n          a.getAttribute(TokenTrackingAttribute.class).getPositions(),\n          b.getAttribute(TokenTrackingAttribute.class).getPositions()\n        );\n      }\n      \n      private int arrayCompare(int[] a, int[] b) {\n        int p = 0;\n        final int stop = Math.min(a.length, b.length);\n        while(p < stop) {\n          int diff = a[p] - b[p];\n          if (diff != 0) return diff;\n          p++;\n        }\n        // One is a prefix of the other, or, they are equal:\n        return a.length - b.length;\n      }\n    });\n\n    for (int i = 0; i < tokens.length; i++) {\n      AttributeSource token = tokens[i];\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<Object>();\n      final TermToBytesRefAttribute termAtt = token.getAttribute(TermToBytesRefAttribute.class);\n      BytesRef rawBytes = termAtt.getBytesRef();\n      termAtt.fillBytesRef();\n      final String text = fieldType.indexedToReadable(rawBytes, new CharsRef(rawBytes.length)).toString();\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      token.reflectWith(new AttributeReflector() {\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof Payload) {\n            final Payload p = (Payload) value;\n            value = new BytesRef(p.getData()).toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","sourceOld":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokens  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokenList, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<NamedList>();\n    final FieldType fieldType = context.getFieldType();\n    final AttributeSource[] tokens = tokenList.toArray(new AttributeSource[tokenList.size()]);\n    \n    // sort the tokens by absoulte position\n    ArrayUtil.mergeSort(tokens, new Comparator<AttributeSource>() {\n      public int compare(AttributeSource a, AttributeSource b) {\n        return arrayCompare(\n          a.getAttribute(TokenTrackingAttribute.class).getPositions(),\n          b.getAttribute(TokenTrackingAttribute.class).getPositions()\n        );\n      }\n      \n      private int arrayCompare(int[] a, int[] b) {\n        int p = 0;\n        final int stop = Math.min(a.length, b.length);\n        while(p < stop) {\n          int diff = a[p] - b[p];\n          if (diff != 0) return diff;\n          p++;\n        }\n        // One is a prefix of the other, or, they are equal:\n        return a.length - b.length;\n      }\n    });\n\n    for (int i = 0; i < tokens.length; i++) {\n      AttributeSource token = tokens[i];\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<Object>();\n      final TermToBytesRefAttribute termAtt = token.getAttribute(TermToBytesRefAttribute.class);\n      BytesRef rawBytes = termAtt.getBytesRef();\n      termAtt.fillBytesRef();\n      final String text = fieldType.indexedToReadable(rawBytes, new CharsRef(rawBytes.length)).toString();\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      token.reflectWith(new AttributeReflector() {\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof Payload) {\n            final Payload p = (Payload) value;\n            value = new BytesRef(p.getData()).toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","pathOld":"solr/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","sourceNew":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokens  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokenList, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<NamedList>();\n    final FieldType fieldType = context.getFieldType();\n    final AttributeSource[] tokens = tokenList.toArray(new AttributeSource[tokenList.size()]);\n    \n    // sort the tokens by absoulte position\n    ArrayUtil.mergeSort(tokens, new Comparator<AttributeSource>() {\n      public int compare(AttributeSource a, AttributeSource b) {\n        return arrayCompare(\n          a.getAttribute(TokenTrackingAttribute.class).getPositions(),\n          b.getAttribute(TokenTrackingAttribute.class).getPositions()\n        );\n      }\n      \n      private int arrayCompare(int[] a, int[] b) {\n        int p = 0;\n        final int stop = Math.min(a.length, b.length);\n        while(p < stop) {\n          int diff = a[p] - b[p];\n          if (diff != 0) return diff;\n          p++;\n        }\n        // One is a prefix of the other, or, they are equal:\n        return a.length - b.length;\n      }\n    });\n\n    for (int i = 0; i < tokens.length; i++) {\n      AttributeSource token = tokens[i];\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<Object>();\n      final TermToBytesRefAttribute termAtt = token.getAttribute(TermToBytesRefAttribute.class);\n      BytesRef rawBytes = termAtt.getBytesRef();\n      termAtt.fillBytesRef();\n      final String text = fieldType.indexedToReadable(rawBytes, new CharsRef(rawBytes.length)).toString();\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      token.reflectWith(new AttributeReflector() {\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof Payload) {\n            final Payload p = (Payload) value;\n            value = new BytesRef(p.getData()).toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","sourceOld":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokens  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokenList, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<NamedList>();\n    final FieldType fieldType = context.getFieldType();\n    final AttributeSource[] tokens = tokenList.toArray(new AttributeSource[tokenList.size()]);\n    \n    // sort the tokens by absoulte position\n    ArrayUtil.mergeSort(tokens, new Comparator<AttributeSource>() {\n      public int compare(AttributeSource a, AttributeSource b) {\n        return arrayCompare(\n          a.getAttribute(TokenTrackingAttribute.class).getPositions(),\n          b.getAttribute(TokenTrackingAttribute.class).getPositions()\n        );\n      }\n      \n      private int arrayCompare(int[] a, int[] b) {\n        int p = 0;\n        final int stop = Math.min(a.length, b.length);\n        while(p < stop) {\n          int diff = a[p] - b[p];\n          if (diff != 0) return diff;\n          p++;\n        }\n        // One is a prefix of the other, or, they are equal:\n        return a.length - b.length;\n      }\n    });\n\n    for (int i = 0; i < tokens.length; i++) {\n      AttributeSource token = tokens[i];\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<Object>();\n      final TermToBytesRefAttribute termAtt = token.getAttribute(TermToBytesRefAttribute.class);\n      BytesRef rawBytes = termAtt.getBytesRef();\n      termAtt.fillBytesRef();\n      final String text = fieldType.indexedToReadable(rawBytes, new CharsRef(rawBytes.length)).toString();\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      token.reflectWith(new AttributeReflector() {\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof Payload) {\n            final Payload p = (Payload) value;\n            value = new BytesRef(p.getData()).toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","pathOld":"solr/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase#convertTokensToNamedLists(List[AttributeSource],AnalysisContext).mjava","sourceNew":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokens  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokenList, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<NamedList>();\n    final FieldType fieldType = context.getFieldType();\n    final AttributeSource[] tokens = tokenList.toArray(new AttributeSource[tokenList.size()]);\n    \n    // sort the tokens by absoulte position\n    ArrayUtil.mergeSort(tokens, new Comparator<AttributeSource>() {\n      public int compare(AttributeSource a, AttributeSource b) {\n        return arrayCompare(\n          a.getAttribute(TokenTrackingAttribute.class).getPositions(),\n          b.getAttribute(TokenTrackingAttribute.class).getPositions()\n        );\n      }\n      \n      private int arrayCompare(int[] a, int[] b) {\n        int p = 0;\n        final int stop = Math.min(a.length, b.length);\n        while(p < stop) {\n          int diff = a[p] - b[p];\n          if (diff != 0) return diff;\n          p++;\n        }\n        // One is a prefix of the other, or, they are equal:\n        return a.length - b.length;\n      }\n    });\n\n    for (int i = 0; i < tokens.length; i++) {\n      AttributeSource token = tokens[i];\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<Object>();\n      final TermToBytesRefAttribute termAtt = token.getAttribute(TermToBytesRefAttribute.class);\n      BytesRef rawBytes = termAtt.getBytesRef();\n      termAtt.fillBytesRef();\n      final String text = fieldType.indexedToReadable(rawBytes, new CharsRef(rawBytes.length)).toString();\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      token.reflectWith(new AttributeReflector() {\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof Payload) {\n            final Payload p = (Payload) value;\n            value = new BytesRef(p.getData()).toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","sourceOld":"  /**\n   * Converts the list of Tokens to a list of NamedLists representing the tokens.\n   *\n   * @param tokens  Tokens to convert\n   * @param context The analysis context\n   *\n   * @return List of NamedLists containing the relevant information taken from the tokens\n   */\n  private List<NamedList> convertTokensToNamedLists(final List<AttributeSource> tokenList, AnalysisContext context) {\n    final List<NamedList> tokensNamedLists = new ArrayList<NamedList>();\n    final FieldType fieldType = context.getFieldType();\n    final AttributeSource[] tokens = tokenList.toArray(new AttributeSource[tokenList.size()]);\n    \n    // sort the tokens by absoulte position\n    ArrayUtil.mergeSort(tokens, new Comparator<AttributeSource>() {\n      public int compare(AttributeSource a, AttributeSource b) {\n        return arrayCompare(\n          a.getAttribute(TokenTrackingAttribute.class).getPositions(),\n          b.getAttribute(TokenTrackingAttribute.class).getPositions()\n        );\n      }\n      \n      private int arrayCompare(int[] a, int[] b) {\n        int p = 0;\n        final int stop = Math.min(a.length, b.length);\n        while(p < stop) {\n          int diff = a[p] - b[p];\n          if (diff != 0) return diff;\n          p++;\n        }\n        // One is a prefix of the other, or, they are equal:\n        return a.length - b.length;\n      }\n    });\n\n    for (int i = 0; i < tokens.length; i++) {\n      AttributeSource token = tokens[i];\n      final NamedList<Object> tokenNamedList = new SimpleOrderedMap<Object>();\n      final TermToBytesRefAttribute termAtt = token.getAttribute(TermToBytesRefAttribute.class);\n      BytesRef rawBytes = termAtt.getBytesRef();\n      termAtt.fillBytesRef();\n      final String text = fieldType.indexedToReadable(rawBytes, new CharsRef(rawBytes.length)).toString();\n      tokenNamedList.add(\"text\", text);\n      \n      if (token.hasAttribute(CharTermAttribute.class)) {\n        final String rawText = token.getAttribute(CharTermAttribute.class).toString();\n        if (!rawText.equals(text)) {\n          tokenNamedList.add(\"raw_text\", rawText);\n        }\n      }\n\n      tokenNamedList.add(\"raw_bytes\", rawBytes.toString());\n\n      if (context.getTermsToMatch().contains(rawBytes)) {\n        tokenNamedList.add(\"match\", true);\n      }\n\n      token.reflectWith(new AttributeReflector() {\n        public void reflect(Class<? extends Attribute> attClass, String key, Object value) {\n          // leave out position and bytes term\n          if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (CharTermAttribute.class.isAssignableFrom(attClass))\n            return;\n          if (PositionIncrementAttribute.class.isAssignableFrom(attClass))\n            return;\n          \n          String k = attClass.getName() + '#' + key;\n          \n          // map keys for \"standard attributes\":\n          if (ATTRIBUTE_MAPPING.containsKey(k)) {\n            k = ATTRIBUTE_MAPPING.get(k);\n          }\n          \n          if (value instanceof Payload) {\n            final Payload p = (Payload) value;\n            value = new BytesRef(p.getData()).toString();\n          }\n\n          tokenNamedList.add(k, value);\n        }\n      });\n\n      tokensNamedLists.add(tokenNamedList);\n    }\n\n    return tokensNamedLists;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"c26f00b574427b55127e869b935845554afde1fa":["0487f900016b7da69f089f740e28192189ef3972","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"ba7fd61ba5cb8882a293be3e8196670f8f1d0796":["ec58fb7921964848d01bea54f8ec4a2ac813eaeb"],"0487f900016b7da69f089f740e28192189ef3972":["a1b3a24d5d9b47345473ff564f5cc127a7b526b4"],"ec58fb7921964848d01bea54f8ec4a2ac813eaeb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"9ed208afa1e7aa98899ddb1dedfddedddf898253":["5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","0487f900016b7da69f089f740e28192189ef3972"],"e79a6d080bdd5b2a8f56342cf571b5476de04180":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ba7fd61ba5cb8882a293be3e8196670f8f1d0796"],"c0ef0193974807e4bddf5432a6b0287fe4d6c9df":["e79a6d080bdd5b2a8f56342cf571b5476de04180","b3d07f1ae3b58102f36f3393c397d78ba4e547a4"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["9ed208afa1e7aa98899ddb1dedfddedddf898253"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":["b3d07f1ae3b58102f36f3393c397d78ba4e547a4","a1b3a24d5d9b47345473ff564f5cc127a7b526b4"],"d619839baa8ce5503e496b94a9e42ad6f079293f":["29ef99d61cda9641b6250bf9567329a6e65f901d","b3d07f1ae3b58102f36f3393c397d78ba4e547a4"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ba7fd61ba5cb8882a293be3e8196670f8f1d0796"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a258fbb26824fd104ed795e5d9033d2d040049ee":["0487f900016b7da69f089f740e28192189ef3972"],"a1b3a24d5d9b47345473ff564f5cc127a7b526b4":["b3d07f1ae3b58102f36f3393c397d78ba4e547a4"],"b3d07f1ae3b58102f36f3393c397d78ba4e547a4":["ba7fd61ba5cb8882a293be3e8196670f8f1d0796"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c26f00b574427b55127e869b935845554afde1fa"],"2e10cb22a8bdb44339e282925a29182bb2f3174d":["d619839baa8ce5503e496b94a9e42ad6f079293f","a1b3a24d5d9b47345473ff564f5cc127a7b526b4"]},"commit2Childs":{"c26f00b574427b55127e869b935845554afde1fa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ba7fd61ba5cb8882a293be3e8196670f8f1d0796":["e79a6d080bdd5b2a8f56342cf571b5476de04180","29ef99d61cda9641b6250bf9567329a6e65f901d","b3d07f1ae3b58102f36f3393c397d78ba4e547a4"],"0487f900016b7da69f089f740e28192189ef3972":["c26f00b574427b55127e869b935845554afde1fa","9ed208afa1e7aa98899ddb1dedfddedddf898253","a258fbb26824fd104ed795e5d9033d2d040049ee"],"ec58fb7921964848d01bea54f8ec4a2ac813eaeb":["ba7fd61ba5cb8882a293be3e8196670f8f1d0796"],"9ed208afa1e7aa98899ddb1dedfddedddf898253":["c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"e79a6d080bdd5b2a8f56342cf571b5476de04180":["c0ef0193974807e4bddf5432a6b0287fe4d6c9df"],"c0ef0193974807e4bddf5432a6b0287fe4d6c9df":[],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":["9ed208afa1e7aa98899ddb1dedfddedddf898253"],"d619839baa8ce5503e496b94a9e42ad6f079293f":["2e10cb22a8bdb44339e282925a29182bb2f3174d"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["d619839baa8ce5503e496b94a9e42ad6f079293f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ec58fb7921964848d01bea54f8ec4a2ac813eaeb","e79a6d080bdd5b2a8f56342cf571b5476de04180","29ef99d61cda9641b6250bf9567329a6e65f901d"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"a1b3a24d5d9b47345473ff564f5cc127a7b526b4":["0487f900016b7da69f089f740e28192189ef3972","5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","2e10cb22a8bdb44339e282925a29182bb2f3174d"],"b3d07f1ae3b58102f36f3393c397d78ba4e547a4":["c0ef0193974807e4bddf5432a6b0287fe4d6c9df","5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","d619839baa8ce5503e496b94a9e42ad6f079293f","a1b3a24d5d9b47345473ff564f5cc127a7b526b4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"2e10cb22a8bdb44339e282925a29182bb2f3174d":[]},"heads":["c0ef0193974807e4bddf5432a6b0287fe4d6c9df","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817","2e10cb22a8bdb44339e282925a29182bb2f3174d"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}