{"path":"lucene/core/src/java/org/apache/lucene/search/ReferenceManager#acquire().mjava","commits":[{"id":"6e81b0b3c14cf61c8ec366450276ab80654f7d0d","date":1329233774,"type":0,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ReferenceManager#acquire().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Obtain the current reference. You must match every call to acquire with one\n   * call to {@link #release}; it's best to do so in a finally clause, and set\n   * the reference to {@code null} to prevent accidental usage after it has been\n   * released.\n   */\n  public final G acquire() {\n    G ref;\n    do {\n      if ((ref = current) == null) {\n        throw new AlreadyClosedException(REFERENCE_MANAGER_IS_CLOSED_MSG);\n      }\n    } while (!tryIncRef(ref));\n    return ref;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["a1f28fab1ce3257f40d2785ec556ab9624eae2bf"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b6d8a16d4f11021a8b59ff7a66277da1fda4a3ef","date":1351890270,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ReferenceManager#acquire().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/ReferenceManager#acquire().mjava","sourceNew":"  /**\n   * Obtain the current reference. You must match every call to acquire with one\n   * call to {@link #release}; it's best to do so in a finally clause, and set\n   * the reference to {@code null} to prevent accidental usage after it has been\n   * released.\n   * @throws AlreadyClosedException if the reference manager has been {@link #close() closed}. \n   */\n  public final G acquire() {\n    G ref;\n    do {\n      if ((ref = current) == null) {\n        throw new AlreadyClosedException(REFERENCE_MANAGER_IS_CLOSED_MSG);\n      }\n    } while (!tryIncRef(ref));\n    return ref;\n  }\n\n","sourceOld":"  /**\n   * Obtain the current reference. You must match every call to acquire with one\n   * call to {@link #release}; it's best to do so in a finally clause, and set\n   * the reference to {@code null} to prevent accidental usage after it has been\n   * released.\n   */\n  public final G acquire() {\n    G ref;\n    do {\n      if ((ref = current) == null) {\n        throw new AlreadyClosedException(REFERENCE_MANAGER_IS_CLOSED_MSG);\n      }\n    } while (!tryIncRef(ref));\n    return ref;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"77925d097d69ba9a9806554c5afe4779fafa142d","date":1365611122,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ReferenceManager#acquire().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/ReferenceManager#acquire().mjava","sourceNew":"  /**\n   * Obtain the current reference. You must match every call to acquire with one\n   * call to {@link #release}; it's best to do so in a finally clause, and set\n   * the reference to {@code null} to prevent accidental usage after it has been\n   * released.\n   * @throws AlreadyClosedException if the reference manager has been {@link #close() closed}. \n   */\n  public final G acquire() throws IOException {\n    G ref;\n    do {\n      if ((ref = current) == null) {\n        throw new AlreadyClosedException(REFERENCE_MANAGER_IS_CLOSED_MSG);\n      }\n    } while (!tryIncRef(ref));\n    return ref;\n  }\n\n","sourceOld":"  /**\n   * Obtain the current reference. You must match every call to acquire with one\n   * call to {@link #release}; it's best to do so in a finally clause, and set\n   * the reference to {@code null} to prevent accidental usage after it has been\n   * released.\n   * @throws AlreadyClosedException if the reference manager has been {@link #close() closed}. \n   */\n  public final G acquire() {\n    G ref;\n    do {\n      if ((ref = current) == null) {\n        throw new AlreadyClosedException(REFERENCE_MANAGER_IS_CLOSED_MSG);\n      }\n    } while (!tryIncRef(ref));\n    return ref;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"19275ba31e621f6da1b83bf13af75233876fd3d4","date":1374846698,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ReferenceManager#acquire().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/ReferenceManager#acquire().mjava","sourceNew":"  /**\n   * Obtain the current reference. You must match every call to acquire with one\n   * call to {@link #release}; it's best to do so in a finally clause, and set\n   * the reference to {@code null} to prevent accidental usage after it has been\n   * released.\n   * @throws AlreadyClosedException if the reference manager has been {@link #close() closed}. \n   */\n  public final G acquire() throws IOException {\n    G ref;\n    do {\n      if ((ref = current) == null) {\n        throw new AlreadyClosedException(REFERENCE_MANAGER_IS_CLOSED_MSG);\n      }\n    } while (!tryIncRef(ref));\n    return ref;\n  }\n\n","sourceOld":"  /**\n   * Obtain the current reference. You must match every call to acquire with one\n   * call to {@link #release}; it's best to do so in a finally clause, and set\n   * the reference to {@code null} to prevent accidental usage after it has been\n   * released.\n   * @throws AlreadyClosedException if the reference manager has been {@link #close() closed}. \n   */\n  public final G acquire() throws IOException {\n    G ref;\n    do {\n      if ((ref = current) == null) {\n        throw new AlreadyClosedException(REFERENCE_MANAGER_IS_CLOSED_MSG);\n      }\n    } while (!tryIncRef(ref));\n    return ref;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","date":1376366778,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ReferenceManager#acquire().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/ReferenceManager#acquire().mjava","sourceNew":"  /**\n   * Obtain the current reference. You must match every call to acquire with one\n   * call to {@link #release}; it's best to do so in a finally clause, and set\n   * the reference to {@code null} to prevent accidental usage after it has been\n   * released.\n   * @throws AlreadyClosedException if the reference manager has been {@link #close() closed}. \n   */\n  public final G acquire() throws IOException {\n    G ref;\n    do {\n      if ((ref = current) == null) {\n        throw new AlreadyClosedException(REFERENCE_MANAGER_IS_CLOSED_MSG);\n      }\n    } while (!tryIncRef(ref));\n    return ref;\n  }\n\n","sourceOld":"  /**\n   * Obtain the current reference. You must match every call to acquire with one\n   * call to {@link #release}; it's best to do so in a finally clause, and set\n   * the reference to {@code null} to prevent accidental usage after it has been\n   * released.\n   * @throws AlreadyClosedException if the reference manager has been {@link #close() closed}. \n   */\n  public final G acquire() throws IOException {\n    G ref;\n    do {\n      if ((ref = current) == null) {\n        throw new AlreadyClosedException(REFERENCE_MANAGER_IS_CLOSED_MSG);\n      }\n    } while (!tryIncRef(ref));\n    return ref;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a1f28fab1ce3257f40d2785ec556ab9624eae2bf","date":1391717376,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ReferenceManager#acquire().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/ReferenceManager#acquire().mjava","sourceNew":"  /**\n   * Obtain the current reference. You must match every call to acquire with one\n   * call to {@link #release}; it's best to do so in a finally clause, and set\n   * the reference to {@code null} to prevent accidental usage after it has been\n   * released.\n   * @throws AlreadyClosedException if the reference manager has been {@link #close() closed}. \n   */\n  public final G acquire() throws IOException {\n    G ref;\n\n    do {\n      if ((ref = current) == null) {\n        throw new AlreadyClosedException(REFERENCE_MANAGER_IS_CLOSED_MSG);\n      }\n      if (tryIncRef(ref)) {\n        return ref;\n      }\n      if (getRefCount(ref) == 0 && current == ref) {\n        assert ref != null;\n        /* if we can't increment the reader but we are\n           still the current reference the RM is in a\n           illegal states since we can't make any progress\n           anymore. The reference is closed but the RM still\n           holds on to it as the actual instance.\n           This can only happen if somebody outside of the RM\n           decrements the refcount without a corresponding increment\n           since the RM assigns the new reference before counting down\n           the reference. */\n        throw new IllegalStateException(\"The managed reference has already closed - this is likely a bug when the reference count is modified outside of the ReferenceManager\");\n      }\n    } while (true);\n  }\n\n","sourceOld":"  /**\n   * Obtain the current reference. You must match every call to acquire with one\n   * call to {@link #release}; it's best to do so in a finally clause, and set\n   * the reference to {@code null} to prevent accidental usage after it has been\n   * released.\n   * @throws AlreadyClosedException if the reference manager has been {@link #close() closed}. \n   */\n  public final G acquire() throws IOException {\n    G ref;\n    do {\n      if ((ref = current) == null) {\n        throw new AlreadyClosedException(REFERENCE_MANAGER_IS_CLOSED_MSG);\n      }\n    } while (!tryIncRef(ref));\n    return ref;\n  }\n\n","bugFix":["6e81b0b3c14cf61c8ec366450276ab80654f7d0d"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"77925d097d69ba9a9806554c5afe4779fafa142d":["b6d8a16d4f11021a8b59ff7a66277da1fda4a3ef"],"b6d8a16d4f11021a8b59ff7a66277da1fda4a3ef":["6e81b0b3c14cf61c8ec366450276ab80654f7d0d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":["77925d097d69ba9a9806554c5afe4779fafa142d"],"19275ba31e621f6da1b83bf13af75233876fd3d4":["77925d097d69ba9a9806554c5afe4779fafa142d"],"a1f28fab1ce3257f40d2785ec556ab9624eae2bf":["19275ba31e621f6da1b83bf13af75233876fd3d4"],"6e81b0b3c14cf61c8ec366450276ab80654f7d0d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a1f28fab1ce3257f40d2785ec556ab9624eae2bf"]},"commit2Childs":{"77925d097d69ba9a9806554c5afe4779fafa142d":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","19275ba31e621f6da1b83bf13af75233876fd3d4"],"b6d8a16d4f11021a8b59ff7a66277da1fda4a3ef":["77925d097d69ba9a9806554c5afe4779fafa142d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6e81b0b3c14cf61c8ec366450276ab80654f7d0d"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":[],"19275ba31e621f6da1b83bf13af75233876fd3d4":["a1f28fab1ce3257f40d2785ec556ab9624eae2bf"],"a1f28fab1ce3257f40d2785ec556ab9624eae2bf":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6e81b0b3c14cf61c8ec366450276ab80654f7d0d":["b6d8a16d4f11021a8b59ff7a66277da1fda4a3ef"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}