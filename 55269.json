{"path":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/RandomGeoPolygonTest#testComparePolygons(double).mjava","commits":[{"id":"dfd30bf34a6f7f23d1d1c7188427856736263380","date":1524741267,"type":0,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/RandomGeoPolygonTest#testComparePolygons(double).mjava","pathOld":"/dev/null","sourceNew":"  private void testComparePolygons(double limitDistance) {\n    final PlanetModel planetModel = randomPlanetModel();\n    //Create polygon points using a reference point and a maximum distance to the point\n    final GeoPoint referencePoint;\n    if (random().nextBoolean()) {\n     referencePoint = getBiasedPoint(planetModel);\n    } else {\n      referencePoint = randomGeoPoint(planetModel);\n    }\n    final int n = random().nextInt(4) + 4;\n    final List<GeoPoint> points = new ArrayList<>(n);\n    List<GeoPoint> orderedPoints = null;\n    GeoPolygon polygon = null;\n    GeoPolygon largePolygon = null;\n    do {\n      double maxDistance = random().nextDouble() * limitDistance;\n      //if distance is too small we can fail\n      //building the polygon.\n      while (maxDistance < 1e-7) {\n        maxDistance = random().nextDouble() * limitDistance;\n      }\n      for (int i = 0; i < n; i++) {\n        while (true) {\n          final double distance = BiasedNumbers.randomDoubleBetween(random(), 0, maxDistance);// random().nextDouble() * maxDistance;\n          final double bearing = random().nextDouble() * 2 * Math.PI;\n          final GeoPoint p = planetModel.surfacePointOnBearing(referencePoint, distance, bearing);\n          if (!contains(p, points)) {\n            if (points.size() > 1 && Plane.arePointsCoplanar(points.get(points.size() - 1), points.get(points.size() - 2), p)) {\n              continue;\n            }\n            points.add(p);\n            break;\n          }\n        }\n      }\n      //order points so we don't get crossing edges\n      orderedPoints = orderPoints(points);\n      if (random().nextBoolean() && random().nextBoolean()) {\n        Collections.reverse(orderedPoints);\n      }\n      final GeoPolygonFactory.PolygonDescription polygonDescription = new GeoPolygonFactory.PolygonDescription(orderedPoints);\n\n      try {\n        polygon = GeoPolygonFactory.makeGeoPolygon(planetModel, polygonDescription);\n      } catch (Exception e) {\n        final StringBuilder buffer = new StringBuilder(\"Polygon failed to build with an exception:\\n\");\n        buffer.append(points.toString() + \"\\n\");\n        buffer.append(\"WKT:\" + getWKT(orderedPoints));\n        buffer.append(e.toString());\n        fail(buffer.toString());\n      }\n      if (polygon == null) {\n        final StringBuilder buffer = new StringBuilder(\"Polygon failed to build:\\n\");\n        buffer.append(points.toString() + \"\\n\");\n        buffer.append(\"WKT:\" + getWKT(orderedPoints));\n        fail(buffer.toString());\n      }\n      try {\n        largePolygon = GeoPolygonFactory.makeLargeGeoPolygon(planetModel, Collections.singletonList(polygonDescription));\n      } catch (Exception e) {\n        final StringBuilder buffer = new StringBuilder(\"Large polygon failed to build with an exception:\\n\");\n        buffer.append(points.toString() + \"\\n\");\n        buffer.append(\"WKT:\" + getWKT(orderedPoints));\n        buffer.append(e.toString());\n        fail(buffer.toString());\n      }\n      if (largePolygon == null) {\n        StringBuilder buffer = new StringBuilder(\"Large polygon failed to build:\\n\");\n        buffer.append(points.toString() + \"\\n\");\n        buffer.append(\"WKT:\" + getWKT(orderedPoints));\n        fail(buffer.toString());\n      }\n    } while(polygon.getClass().equals(largePolygon.getClass()));\n    //Some of these do not work but it seems it s from the way the point is created\n    //GeoPoint centerOfMass = getCenterOfMass(planetModel, orderedPoints);\n    //checkPoint(polygon, largePolygon, centerOfMass, orderedPoints);\n    //checkPoint(polygon, largePolygon, new GeoPoint(-centerOfMass.x, -centerOfMass.y, -centerOfMass.z), orderedPoints);\n    //checkPoint(polygon, largePolygon, new GeoPoint(centerOfMass.x, -centerOfMass.y, -centerOfMass.z), orderedPoints);\n    //checkPoint(polygon, largePolygon, new GeoPoint(centerOfMass.x, centerOfMass.y, -centerOfMass.z), orderedPoints);\n    //checkPoint(polygon, largePolygon, new GeoPoint(-centerOfMass.x, -centerOfMass.y, centerOfMass.z), orderedPoints);\n    //checkPoint(polygon, largePolygon, new GeoPoint(-centerOfMass.x, centerOfMass.y, -centerOfMass.z), orderedPoints);\n    //checkPoint(polygon, largePolygon, new GeoPoint(centerOfMass.x, -centerOfMass.y, centerOfMass.z), orderedPoints);\n    for(int i = 0; i < 100000; i++) {\n      final GeoPoint point;\n      if (random().nextBoolean()) {\n        point = getBiasedPoint(planetModel);\n      } else {\n        point = randomGeoPoint(planetModel);\n      }\n      checkPoint(polygon, largePolygon, point, orderedPoints);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b614d077b1c13d0ed0aa1dbacbd206d0ea75dc4e","date":1528454846,"type":3,"author":"ivera","isMerge":false,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/RandomGeoPolygonTest#testComparePolygons(double).mjava","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/RandomGeoPolygonTest#testComparePolygons(double).mjava","sourceNew":"  private void testComparePolygons(double limitDistance) {\n    final PlanetModel planetModel = randomPlanetModel();\n    //Create polygon points using a reference point and a maximum distance to the point\n    final GeoPoint referencePoint;\n    if (random().nextBoolean()) {\n     referencePoint = getBiasedPoint(planetModel);\n    } else {\n      referencePoint = randomGeoPoint(planetModel);\n    }\n    final int n = random().nextInt(4) + 4;\n\n    List<GeoPoint> orderedPoints = null;\n    GeoPolygon polygon = null;\n    GeoPolygon largePolygon = null;\n    do {\n      final List<GeoPoint> points = new ArrayList<>(n);\n      double maxDistance = random().nextDouble() * limitDistance;\n      //if distance is too small we can fail\n      //building the polygon.\n      while (maxDistance < 1e-7) {\n        maxDistance = random().nextDouble() * limitDistance;\n      }\n      for (int i = 0; i < n; i++) {\n        while (true) {\n          final double distance = BiasedNumbers.randomDoubleBetween(random(), 0, maxDistance);// random().nextDouble() * maxDistance;\n          final double bearing = random().nextDouble() * 2 * Math.PI;\n          final GeoPoint p = planetModel.surfacePointOnBearing(referencePoint, distance, bearing);\n          if (!contains(p, points)) {\n            if (points.size() > 1 && Plane.arePointsCoplanar(points.get(points.size() - 1), points.get(points.size() - 2), p)) {\n              continue;\n            }\n            points.add(p);\n            break;\n          }\n        }\n      }\n      //order points so we don't get crossing edges\n      orderedPoints = orderPoints(points);\n      if (random().nextBoolean() && random().nextBoolean()) {\n        Collections.reverse(orderedPoints);\n      }\n      final GeoPolygonFactory.PolygonDescription polygonDescription = new GeoPolygonFactory.PolygonDescription(orderedPoints);\n\n      try {\n        polygon = GeoPolygonFactory.makeGeoPolygon(planetModel, polygonDescription);\n      } catch (Exception e) {\n        final StringBuilder buffer = new StringBuilder(\"Polygon failed to build with an exception:\\n\");\n        buffer.append(points.toString() + \"\\n\");\n        buffer.append(\"WKT:\" + getWKT(orderedPoints));\n        buffer.append(e.toString());\n        fail(buffer.toString());\n      }\n      if (polygon == null) {\n        final StringBuilder buffer = new StringBuilder(\"Polygon failed to build:\\n\");\n        buffer.append(points.toString() + \"\\n\");\n        buffer.append(\"WKT:\" + getWKT(orderedPoints));\n        fail(buffer.toString());\n      }\n      try {\n        largePolygon = GeoPolygonFactory.makeLargeGeoPolygon(planetModel, Collections.singletonList(polygonDescription));\n      } catch (Exception e) {\n        final StringBuilder buffer = new StringBuilder(\"Large polygon failed to build with an exception:\\n\");\n        buffer.append(points.toString() + \"\\n\");\n        buffer.append(\"WKT:\" + getWKT(orderedPoints));\n        buffer.append(e.toString());\n        fail(buffer.toString());\n      }\n      if (largePolygon == null) {\n        StringBuilder buffer = new StringBuilder(\"Large polygon failed to build:\\n\");\n        buffer.append(points.toString() + \"\\n\");\n        buffer.append(\"WKT:\" + getWKT(orderedPoints));\n        fail(buffer.toString());\n      }\n    } while(polygon.getClass().equals(largePolygon.getClass()));\n    //Some of these do not work but it seems it s from the way the point is created\n    //GeoPoint centerOfMass = getCenterOfMass(planetModel, orderedPoints);\n    //checkPoint(polygon, largePolygon, centerOfMass, orderedPoints);\n    //checkPoint(polygon, largePolygon, new GeoPoint(-centerOfMass.x, -centerOfMass.y, -centerOfMass.z), orderedPoints);\n    //checkPoint(polygon, largePolygon, new GeoPoint(centerOfMass.x, -centerOfMass.y, -centerOfMass.z), orderedPoints);\n    //checkPoint(polygon, largePolygon, new GeoPoint(centerOfMass.x, centerOfMass.y, -centerOfMass.z), orderedPoints);\n    //checkPoint(polygon, largePolygon, new GeoPoint(-centerOfMass.x, -centerOfMass.y, centerOfMass.z), orderedPoints);\n    //checkPoint(polygon, largePolygon, new GeoPoint(-centerOfMass.x, centerOfMass.y, -centerOfMass.z), orderedPoints);\n    //checkPoint(polygon, largePolygon, new GeoPoint(centerOfMass.x, -centerOfMass.y, centerOfMass.z), orderedPoints);\n    for(int i = 0; i < 100000; i++) {\n      final GeoPoint point;\n      if (random().nextBoolean()) {\n        point = getBiasedPoint(planetModel);\n      } else {\n        point = randomGeoPoint(planetModel);\n      }\n      checkPoint(polygon, largePolygon, point, orderedPoints);\n    }\n  }\n\n","sourceOld":"  private void testComparePolygons(double limitDistance) {\n    final PlanetModel planetModel = randomPlanetModel();\n    //Create polygon points using a reference point and a maximum distance to the point\n    final GeoPoint referencePoint;\n    if (random().nextBoolean()) {\n     referencePoint = getBiasedPoint(planetModel);\n    } else {\n      referencePoint = randomGeoPoint(planetModel);\n    }\n    final int n = random().nextInt(4) + 4;\n    final List<GeoPoint> points = new ArrayList<>(n);\n    List<GeoPoint> orderedPoints = null;\n    GeoPolygon polygon = null;\n    GeoPolygon largePolygon = null;\n    do {\n      double maxDistance = random().nextDouble() * limitDistance;\n      //if distance is too small we can fail\n      //building the polygon.\n      while (maxDistance < 1e-7) {\n        maxDistance = random().nextDouble() * limitDistance;\n      }\n      for (int i = 0; i < n; i++) {\n        while (true) {\n          final double distance = BiasedNumbers.randomDoubleBetween(random(), 0, maxDistance);// random().nextDouble() * maxDistance;\n          final double bearing = random().nextDouble() * 2 * Math.PI;\n          final GeoPoint p = planetModel.surfacePointOnBearing(referencePoint, distance, bearing);\n          if (!contains(p, points)) {\n            if (points.size() > 1 && Plane.arePointsCoplanar(points.get(points.size() - 1), points.get(points.size() - 2), p)) {\n              continue;\n            }\n            points.add(p);\n            break;\n          }\n        }\n      }\n      //order points so we don't get crossing edges\n      orderedPoints = orderPoints(points);\n      if (random().nextBoolean() && random().nextBoolean()) {\n        Collections.reverse(orderedPoints);\n      }\n      final GeoPolygonFactory.PolygonDescription polygonDescription = new GeoPolygonFactory.PolygonDescription(orderedPoints);\n\n      try {\n        polygon = GeoPolygonFactory.makeGeoPolygon(planetModel, polygonDescription);\n      } catch (Exception e) {\n        final StringBuilder buffer = new StringBuilder(\"Polygon failed to build with an exception:\\n\");\n        buffer.append(points.toString() + \"\\n\");\n        buffer.append(\"WKT:\" + getWKT(orderedPoints));\n        buffer.append(e.toString());\n        fail(buffer.toString());\n      }\n      if (polygon == null) {\n        final StringBuilder buffer = new StringBuilder(\"Polygon failed to build:\\n\");\n        buffer.append(points.toString() + \"\\n\");\n        buffer.append(\"WKT:\" + getWKT(orderedPoints));\n        fail(buffer.toString());\n      }\n      try {\n        largePolygon = GeoPolygonFactory.makeLargeGeoPolygon(planetModel, Collections.singletonList(polygonDescription));\n      } catch (Exception e) {\n        final StringBuilder buffer = new StringBuilder(\"Large polygon failed to build with an exception:\\n\");\n        buffer.append(points.toString() + \"\\n\");\n        buffer.append(\"WKT:\" + getWKT(orderedPoints));\n        buffer.append(e.toString());\n        fail(buffer.toString());\n      }\n      if (largePolygon == null) {\n        StringBuilder buffer = new StringBuilder(\"Large polygon failed to build:\\n\");\n        buffer.append(points.toString() + \"\\n\");\n        buffer.append(\"WKT:\" + getWKT(orderedPoints));\n        fail(buffer.toString());\n      }\n    } while(polygon.getClass().equals(largePolygon.getClass()));\n    //Some of these do not work but it seems it s from the way the point is created\n    //GeoPoint centerOfMass = getCenterOfMass(planetModel, orderedPoints);\n    //checkPoint(polygon, largePolygon, centerOfMass, orderedPoints);\n    //checkPoint(polygon, largePolygon, new GeoPoint(-centerOfMass.x, -centerOfMass.y, -centerOfMass.z), orderedPoints);\n    //checkPoint(polygon, largePolygon, new GeoPoint(centerOfMass.x, -centerOfMass.y, -centerOfMass.z), orderedPoints);\n    //checkPoint(polygon, largePolygon, new GeoPoint(centerOfMass.x, centerOfMass.y, -centerOfMass.z), orderedPoints);\n    //checkPoint(polygon, largePolygon, new GeoPoint(-centerOfMass.x, -centerOfMass.y, centerOfMass.z), orderedPoints);\n    //checkPoint(polygon, largePolygon, new GeoPoint(-centerOfMass.x, centerOfMass.y, -centerOfMass.z), orderedPoints);\n    //checkPoint(polygon, largePolygon, new GeoPoint(centerOfMass.x, -centerOfMass.y, centerOfMass.z), orderedPoints);\n    for(int i = 0; i < 100000; i++) {\n      final GeoPoint point;\n      if (random().nextBoolean()) {\n        point = getBiasedPoint(planetModel);\n      } else {\n        point = randomGeoPoint(planetModel);\n      }\n      checkPoint(polygon, largePolygon, point, orderedPoints);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/RandomGeoPolygonTest#testComparePolygons(double).mjava","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/RandomGeoPolygonTest#testComparePolygons(double).mjava","sourceNew":"  private void testComparePolygons(double limitDistance) {\n    final PlanetModel planetModel = randomPlanetModel();\n    //Create polygon points using a reference point and a maximum distance to the point\n    final GeoPoint referencePoint;\n    if (random().nextBoolean()) {\n     referencePoint = getBiasedPoint(planetModel);\n    } else {\n      referencePoint = randomGeoPoint(planetModel);\n    }\n    final int n = random().nextInt(4) + 4;\n\n    List<GeoPoint> orderedPoints = null;\n    GeoPolygon polygon = null;\n    GeoPolygon largePolygon = null;\n    do {\n      final List<GeoPoint> points = new ArrayList<>(n);\n      double maxDistance = random().nextDouble() * limitDistance;\n      //if distance is too small we can fail\n      //building the polygon.\n      while (maxDistance < 1e-7) {\n        maxDistance = random().nextDouble() * limitDistance;\n      }\n      for (int i = 0; i < n; i++) {\n        while (true) {\n          final double distance = BiasedNumbers.randomDoubleBetween(random(), 0, maxDistance);// random().nextDouble() * maxDistance;\n          final double bearing = random().nextDouble() * 2 * Math.PI;\n          final GeoPoint p = planetModel.surfacePointOnBearing(referencePoint, distance, bearing);\n          if (!contains(p, points)) {\n            if (points.size() > 1 && Plane.arePointsCoplanar(points.get(points.size() - 1), points.get(points.size() - 2), p)) {\n              continue;\n            }\n            points.add(p);\n            break;\n          }\n        }\n      }\n      //order points so we don't get crossing edges\n      orderedPoints = orderPoints(points);\n      if (random().nextBoolean() && random().nextBoolean()) {\n        Collections.reverse(orderedPoints);\n      }\n      final GeoPolygonFactory.PolygonDescription polygonDescription = new GeoPolygonFactory.PolygonDescription(orderedPoints);\n\n      try {\n        polygon = GeoPolygonFactory.makeGeoPolygon(planetModel, polygonDescription);\n      } catch (Exception e) {\n        final StringBuilder buffer = new StringBuilder(\"Polygon failed to build with an exception:\\n\");\n        buffer.append(points.toString() + \"\\n\");\n        buffer.append(\"WKT:\" + getWKT(orderedPoints));\n        buffer.append(e.toString());\n        fail(buffer.toString());\n      }\n      if (polygon == null) {\n        final StringBuilder buffer = new StringBuilder(\"Polygon failed to build:\\n\");\n        buffer.append(points.toString() + \"\\n\");\n        buffer.append(\"WKT:\" + getWKT(orderedPoints));\n        fail(buffer.toString());\n      }\n      try {\n        largePolygon = GeoPolygonFactory.makeLargeGeoPolygon(planetModel, Collections.singletonList(polygonDescription));\n      } catch (Exception e) {\n        final StringBuilder buffer = new StringBuilder(\"Large polygon failed to build with an exception:\\n\");\n        buffer.append(points.toString() + \"\\n\");\n        buffer.append(\"WKT:\" + getWKT(orderedPoints));\n        buffer.append(e.toString());\n        fail(buffer.toString());\n      }\n      if (largePolygon == null) {\n        StringBuilder buffer = new StringBuilder(\"Large polygon failed to build:\\n\");\n        buffer.append(points.toString() + \"\\n\");\n        buffer.append(\"WKT:\" + getWKT(orderedPoints));\n        fail(buffer.toString());\n      }\n    } while(polygon.getClass().equals(largePolygon.getClass()));\n    //Some of these do not work but it seems it s from the way the point is created\n    //GeoPoint centerOfMass = getCenterOfMass(planetModel, orderedPoints);\n    //checkPoint(polygon, largePolygon, centerOfMass, orderedPoints);\n    //checkPoint(polygon, largePolygon, new GeoPoint(-centerOfMass.x, -centerOfMass.y, -centerOfMass.z), orderedPoints);\n    //checkPoint(polygon, largePolygon, new GeoPoint(centerOfMass.x, -centerOfMass.y, -centerOfMass.z), orderedPoints);\n    //checkPoint(polygon, largePolygon, new GeoPoint(centerOfMass.x, centerOfMass.y, -centerOfMass.z), orderedPoints);\n    //checkPoint(polygon, largePolygon, new GeoPoint(-centerOfMass.x, -centerOfMass.y, centerOfMass.z), orderedPoints);\n    //checkPoint(polygon, largePolygon, new GeoPoint(-centerOfMass.x, centerOfMass.y, -centerOfMass.z), orderedPoints);\n    //checkPoint(polygon, largePolygon, new GeoPoint(centerOfMass.x, -centerOfMass.y, centerOfMass.z), orderedPoints);\n    for(int i = 0; i < 100000; i++) {\n      final GeoPoint point;\n      if (random().nextBoolean()) {\n        point = getBiasedPoint(planetModel);\n      } else {\n        point = randomGeoPoint(planetModel);\n      }\n      checkPoint(polygon, largePolygon, point, orderedPoints);\n    }\n  }\n\n","sourceOld":"  private void testComparePolygons(double limitDistance) {\n    final PlanetModel planetModel = randomPlanetModel();\n    //Create polygon points using a reference point and a maximum distance to the point\n    final GeoPoint referencePoint;\n    if (random().nextBoolean()) {\n     referencePoint = getBiasedPoint(planetModel);\n    } else {\n      referencePoint = randomGeoPoint(planetModel);\n    }\n    final int n = random().nextInt(4) + 4;\n    final List<GeoPoint> points = new ArrayList<>(n);\n    List<GeoPoint> orderedPoints = null;\n    GeoPolygon polygon = null;\n    GeoPolygon largePolygon = null;\n    do {\n      double maxDistance = random().nextDouble() * limitDistance;\n      //if distance is too small we can fail\n      //building the polygon.\n      while (maxDistance < 1e-7) {\n        maxDistance = random().nextDouble() * limitDistance;\n      }\n      for (int i = 0; i < n; i++) {\n        while (true) {\n          final double distance = BiasedNumbers.randomDoubleBetween(random(), 0, maxDistance);// random().nextDouble() * maxDistance;\n          final double bearing = random().nextDouble() * 2 * Math.PI;\n          final GeoPoint p = planetModel.surfacePointOnBearing(referencePoint, distance, bearing);\n          if (!contains(p, points)) {\n            if (points.size() > 1 && Plane.arePointsCoplanar(points.get(points.size() - 1), points.get(points.size() - 2), p)) {\n              continue;\n            }\n            points.add(p);\n            break;\n          }\n        }\n      }\n      //order points so we don't get crossing edges\n      orderedPoints = orderPoints(points);\n      if (random().nextBoolean() && random().nextBoolean()) {\n        Collections.reverse(orderedPoints);\n      }\n      final GeoPolygonFactory.PolygonDescription polygonDescription = new GeoPolygonFactory.PolygonDescription(orderedPoints);\n\n      try {\n        polygon = GeoPolygonFactory.makeGeoPolygon(planetModel, polygonDescription);\n      } catch (Exception e) {\n        final StringBuilder buffer = new StringBuilder(\"Polygon failed to build with an exception:\\n\");\n        buffer.append(points.toString() + \"\\n\");\n        buffer.append(\"WKT:\" + getWKT(orderedPoints));\n        buffer.append(e.toString());\n        fail(buffer.toString());\n      }\n      if (polygon == null) {\n        final StringBuilder buffer = new StringBuilder(\"Polygon failed to build:\\n\");\n        buffer.append(points.toString() + \"\\n\");\n        buffer.append(\"WKT:\" + getWKT(orderedPoints));\n        fail(buffer.toString());\n      }\n      try {\n        largePolygon = GeoPolygonFactory.makeLargeGeoPolygon(planetModel, Collections.singletonList(polygonDescription));\n      } catch (Exception e) {\n        final StringBuilder buffer = new StringBuilder(\"Large polygon failed to build with an exception:\\n\");\n        buffer.append(points.toString() + \"\\n\");\n        buffer.append(\"WKT:\" + getWKT(orderedPoints));\n        buffer.append(e.toString());\n        fail(buffer.toString());\n      }\n      if (largePolygon == null) {\n        StringBuilder buffer = new StringBuilder(\"Large polygon failed to build:\\n\");\n        buffer.append(points.toString() + \"\\n\");\n        buffer.append(\"WKT:\" + getWKT(orderedPoints));\n        fail(buffer.toString());\n      }\n    } while(polygon.getClass().equals(largePolygon.getClass()));\n    //Some of these do not work but it seems it s from the way the point is created\n    //GeoPoint centerOfMass = getCenterOfMass(planetModel, orderedPoints);\n    //checkPoint(polygon, largePolygon, centerOfMass, orderedPoints);\n    //checkPoint(polygon, largePolygon, new GeoPoint(-centerOfMass.x, -centerOfMass.y, -centerOfMass.z), orderedPoints);\n    //checkPoint(polygon, largePolygon, new GeoPoint(centerOfMass.x, -centerOfMass.y, -centerOfMass.z), orderedPoints);\n    //checkPoint(polygon, largePolygon, new GeoPoint(centerOfMass.x, centerOfMass.y, -centerOfMass.z), orderedPoints);\n    //checkPoint(polygon, largePolygon, new GeoPoint(-centerOfMass.x, -centerOfMass.y, centerOfMass.z), orderedPoints);\n    //checkPoint(polygon, largePolygon, new GeoPoint(-centerOfMass.x, centerOfMass.y, -centerOfMass.z), orderedPoints);\n    //checkPoint(polygon, largePolygon, new GeoPoint(centerOfMass.x, -centerOfMass.y, centerOfMass.z), orderedPoints);\n    for(int i = 0; i < 100000; i++) {\n      final GeoPoint point;\n      if (random().nextBoolean()) {\n        point = getBiasedPoint(planetModel);\n      } else {\n        point = randomGeoPoint(planetModel);\n      }\n      checkPoint(polygon, largePolygon, point, orderedPoints);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/RandomGeoPolygonTest#testComparePolygons(double).mjava","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/RandomGeoPolygonTest#testComparePolygons(double).mjava","sourceNew":"  private void testComparePolygons(double limitDistance) {\n    final PlanetModel planetModel = randomPlanetModel();\n    //Create polygon points using a reference point and a maximum distance to the point\n    final GeoPoint referencePoint;\n    if (random().nextBoolean()) {\n     referencePoint = getBiasedPoint(planetModel);\n    } else {\n      referencePoint = randomGeoPoint(planetModel);\n    }\n    final int n = random().nextInt(4) + 4;\n\n    List<GeoPoint> orderedPoints = null;\n    GeoPolygon polygon = null;\n    GeoPolygon largePolygon = null;\n    do {\n      final List<GeoPoint> points = new ArrayList<>(n);\n      double maxDistance = random().nextDouble() * limitDistance;\n      //if distance is too small we can fail\n      //building the polygon.\n      while (maxDistance < 1e-7) {\n        maxDistance = random().nextDouble() * limitDistance;\n      }\n      for (int i = 0; i < n; i++) {\n        while (true) {\n          final double distance = BiasedNumbers.randomDoubleBetween(random(), 0, maxDistance);// random().nextDouble() * maxDistance;\n          final double bearing = random().nextDouble() * 2 * Math.PI;\n          final GeoPoint p = planetModel.surfacePointOnBearing(referencePoint, distance, bearing);\n          if (!contains(p, points)) {\n            if (points.size() > 1 && Plane.arePointsCoplanar(points.get(points.size() - 1), points.get(points.size() - 2), p)) {\n              continue;\n            }\n            points.add(p);\n            break;\n          }\n        }\n      }\n      //order points so we don't get crossing edges\n      orderedPoints = orderPoints(points);\n      if (random().nextBoolean() && random().nextBoolean()) {\n        Collections.reverse(orderedPoints);\n      }\n      final GeoPolygonFactory.PolygonDescription polygonDescription = new GeoPolygonFactory.PolygonDescription(orderedPoints);\n\n      try {\n        polygon = GeoPolygonFactory.makeGeoPolygon(planetModel, polygonDescription);\n      } catch (Exception e) {\n        final StringBuilder buffer = new StringBuilder(\"Polygon failed to build with an exception:\\n\");\n        buffer.append(points.toString() + \"\\n\");\n        buffer.append(\"WKT:\" + getWKT(orderedPoints));\n        buffer.append(e.toString());\n        fail(buffer.toString());\n      }\n      if (polygon == null) {\n        final StringBuilder buffer = new StringBuilder(\"Polygon failed to build:\\n\");\n        buffer.append(points.toString() + \"\\n\");\n        buffer.append(\"WKT:\" + getWKT(orderedPoints));\n        fail(buffer.toString());\n      }\n      try {\n        largePolygon = GeoPolygonFactory.makeLargeGeoPolygon(planetModel, Collections.singletonList(polygonDescription));\n      } catch (Exception e) {\n        final StringBuilder buffer = new StringBuilder(\"Large polygon failed to build with an exception:\\n\");\n        buffer.append(points.toString() + \"\\n\");\n        buffer.append(\"WKT:\" + getWKT(orderedPoints));\n        buffer.append(e.toString());\n        fail(buffer.toString());\n      }\n      if (largePolygon == null) {\n        StringBuilder buffer = new StringBuilder(\"Large polygon failed to build:\\n\");\n        buffer.append(points.toString() + \"\\n\");\n        buffer.append(\"WKT:\" + getWKT(orderedPoints));\n        fail(buffer.toString());\n      }\n    } while(polygon.getClass().equals(largePolygon.getClass()));\n    //Some of these do not work but it seems it s from the way the point is created\n    //GeoPoint centerOfMass = getCenterOfMass(planetModel, orderedPoints);\n    //checkPoint(polygon, largePolygon, centerOfMass, orderedPoints);\n    //checkPoint(polygon, largePolygon, new GeoPoint(-centerOfMass.x, -centerOfMass.y, -centerOfMass.z), orderedPoints);\n    //checkPoint(polygon, largePolygon, new GeoPoint(centerOfMass.x, -centerOfMass.y, -centerOfMass.z), orderedPoints);\n    //checkPoint(polygon, largePolygon, new GeoPoint(centerOfMass.x, centerOfMass.y, -centerOfMass.z), orderedPoints);\n    //checkPoint(polygon, largePolygon, new GeoPoint(-centerOfMass.x, -centerOfMass.y, centerOfMass.z), orderedPoints);\n    //checkPoint(polygon, largePolygon, new GeoPoint(-centerOfMass.x, centerOfMass.y, -centerOfMass.z), orderedPoints);\n    //checkPoint(polygon, largePolygon, new GeoPoint(centerOfMass.x, -centerOfMass.y, centerOfMass.z), orderedPoints);\n    for(int i = 0; i < 100000; i++) {\n      final GeoPoint point;\n      if (random().nextBoolean()) {\n        point = getBiasedPoint(planetModel);\n      } else {\n        point = randomGeoPoint(planetModel);\n      }\n      checkPoint(polygon, largePolygon, point, orderedPoints);\n    }\n  }\n\n","sourceOld":"  private void testComparePolygons(double limitDistance) {\n    final PlanetModel planetModel = randomPlanetModel();\n    //Create polygon points using a reference point and a maximum distance to the point\n    final GeoPoint referencePoint;\n    if (random().nextBoolean()) {\n     referencePoint = getBiasedPoint(planetModel);\n    } else {\n      referencePoint = randomGeoPoint(planetModel);\n    }\n    final int n = random().nextInt(4) + 4;\n    final List<GeoPoint> points = new ArrayList<>(n);\n    List<GeoPoint> orderedPoints = null;\n    GeoPolygon polygon = null;\n    GeoPolygon largePolygon = null;\n    do {\n      double maxDistance = random().nextDouble() * limitDistance;\n      //if distance is too small we can fail\n      //building the polygon.\n      while (maxDistance < 1e-7) {\n        maxDistance = random().nextDouble() * limitDistance;\n      }\n      for (int i = 0; i < n; i++) {\n        while (true) {\n          final double distance = BiasedNumbers.randomDoubleBetween(random(), 0, maxDistance);// random().nextDouble() * maxDistance;\n          final double bearing = random().nextDouble() * 2 * Math.PI;\n          final GeoPoint p = planetModel.surfacePointOnBearing(referencePoint, distance, bearing);\n          if (!contains(p, points)) {\n            if (points.size() > 1 && Plane.arePointsCoplanar(points.get(points.size() - 1), points.get(points.size() - 2), p)) {\n              continue;\n            }\n            points.add(p);\n            break;\n          }\n        }\n      }\n      //order points so we don't get crossing edges\n      orderedPoints = orderPoints(points);\n      if (random().nextBoolean() && random().nextBoolean()) {\n        Collections.reverse(orderedPoints);\n      }\n      final GeoPolygonFactory.PolygonDescription polygonDescription = new GeoPolygonFactory.PolygonDescription(orderedPoints);\n\n      try {\n        polygon = GeoPolygonFactory.makeGeoPolygon(planetModel, polygonDescription);\n      } catch (Exception e) {\n        final StringBuilder buffer = new StringBuilder(\"Polygon failed to build with an exception:\\n\");\n        buffer.append(points.toString() + \"\\n\");\n        buffer.append(\"WKT:\" + getWKT(orderedPoints));\n        buffer.append(e.toString());\n        fail(buffer.toString());\n      }\n      if (polygon == null) {\n        final StringBuilder buffer = new StringBuilder(\"Polygon failed to build:\\n\");\n        buffer.append(points.toString() + \"\\n\");\n        buffer.append(\"WKT:\" + getWKT(orderedPoints));\n        fail(buffer.toString());\n      }\n      try {\n        largePolygon = GeoPolygonFactory.makeLargeGeoPolygon(planetModel, Collections.singletonList(polygonDescription));\n      } catch (Exception e) {\n        final StringBuilder buffer = new StringBuilder(\"Large polygon failed to build with an exception:\\n\");\n        buffer.append(points.toString() + \"\\n\");\n        buffer.append(\"WKT:\" + getWKT(orderedPoints));\n        buffer.append(e.toString());\n        fail(buffer.toString());\n      }\n      if (largePolygon == null) {\n        StringBuilder buffer = new StringBuilder(\"Large polygon failed to build:\\n\");\n        buffer.append(points.toString() + \"\\n\");\n        buffer.append(\"WKT:\" + getWKT(orderedPoints));\n        fail(buffer.toString());\n      }\n    } while(polygon.getClass().equals(largePolygon.getClass()));\n    //Some of these do not work but it seems it s from the way the point is created\n    //GeoPoint centerOfMass = getCenterOfMass(planetModel, orderedPoints);\n    //checkPoint(polygon, largePolygon, centerOfMass, orderedPoints);\n    //checkPoint(polygon, largePolygon, new GeoPoint(-centerOfMass.x, -centerOfMass.y, -centerOfMass.z), orderedPoints);\n    //checkPoint(polygon, largePolygon, new GeoPoint(centerOfMass.x, -centerOfMass.y, -centerOfMass.z), orderedPoints);\n    //checkPoint(polygon, largePolygon, new GeoPoint(centerOfMass.x, centerOfMass.y, -centerOfMass.z), orderedPoints);\n    //checkPoint(polygon, largePolygon, new GeoPoint(-centerOfMass.x, -centerOfMass.y, centerOfMass.z), orderedPoints);\n    //checkPoint(polygon, largePolygon, new GeoPoint(-centerOfMass.x, centerOfMass.y, -centerOfMass.z), orderedPoints);\n    //checkPoint(polygon, largePolygon, new GeoPoint(centerOfMass.x, -centerOfMass.y, centerOfMass.z), orderedPoints);\n    for(int i = 0; i < 100000; i++) {\n      final GeoPoint point;\n      if (random().nextBoolean()) {\n        point = getBiasedPoint(planetModel);\n      } else {\n        point = randomGeoPoint(planetModel);\n      }\n      checkPoint(polygon, largePolygon, point, orderedPoints);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["dfd30bf34a6f7f23d1d1c7188427856736263380","b614d077b1c13d0ed0aa1dbacbd206d0ea75dc4e"],"dfd30bf34a6f7f23d1d1c7188427856736263380":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b614d077b1c13d0ed0aa1dbacbd206d0ea75dc4e":["dfd30bf34a6f7f23d1d1c7188427856736263380"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b614d077b1c13d0ed0aa1dbacbd206d0ea75dc4e"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["dfd30bf34a6f7f23d1d1c7188427856736263380","b614d077b1c13d0ed0aa1dbacbd206d0ea75dc4e"]},"commit2Childs":{"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"dfd30bf34a6f7f23d1d1c7188427856736263380":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","b614d077b1c13d0ed0aa1dbacbd206d0ea75dc4e","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"b614d077b1c13d0ed0aa1dbacbd206d0ea75dc4e":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["dfd30bf34a6f7f23d1d1c7188427856736263380"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}