{"path":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#testOverseerRole().mjava","commits":[{"id":"5b15576cafd8b5d06857055c28f26912321937e3","date":1396452121,"type":1,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#testOverseerRole().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#addOverseerRole2ExistingNodes().mjava","sourceNew":"  private void testOverseerRole() throws Exception {\n    String collectionName = \"testOverseerCol\";\n\n    createCollection(collectionName, client);\n\n    waitForRecoveriesToFinish(collectionName, false);\n    List<String> l = OverseerCollectionProcessor.getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) ;\n\n    log.info(\"All nodes {}\", l);\n    String currentLeader = OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient());\n    log.info(\"Current leader {} \", currentLeader);\n    l.remove(currentLeader);\n\n    Collections.shuffle(l);\n    String overseerDesignate = l.get(0);\n    log.info(\"overseerDesignate {}\",overseerDesignate);\n    setOverseerRole(CollectionAction.ADDROLE,overseerDesignate);\n\n    long timeout = System.currentTimeMillis()+15000;\n\n    boolean leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      if(overseerDesignate.equals(OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()))){\n        log.info(\"overseer designate is the new overseer\");\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    assertTrue(\"could not set the new overseer . expected \"+\n        overseerDesignate + \" current order : \" +\n        getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) +\n        \" ldr :\"+ OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()) ,leaderchanged);\n\n\n\n    //add another node as overseer\n\n\n    l.remove(overseerDesignate);\n\n    Collections.shuffle(l);\n\n    String anotherOverseer = l.get(0);\n    log.info(\"Adding another overseer designate {}\", anotherOverseer);\n    setOverseerRole(CollectionAction.ADDROLE, anotherOverseer);\n\n    timeout = System.currentTimeMillis()+10000;\n    leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      List<String> sortedNodeNames = getSortedOverseerNodeNames(client.getZkStateReader().getZkClient());\n      if(sortedNodeNames.get(1) .equals(anotherOverseer) || sortedNodeNames.get(0).equals(anotherOverseer)){\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n\n    assertTrue(\"New overseer not the frontrunner : \"+ getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) + \" expected : \"+ anotherOverseer, leaderchanged);\n\n\n    String currentOverseer = getLeaderNode(client.getZkStateReader().getZkClient());\n\n    String killedOverseer = currentOverseer;\n\n    log.info(\"Current Overseer {}\", currentOverseer);\n    Pattern pattern = Pattern.compile(\"(.*):(\\\\d*)(.*)\");\n    Matcher m = pattern.matcher(currentOverseer);\n    JettySolrRunner stoppedJetty =null;\n\n    if(m.matches()){\n      String hostPort =  m.group(1)+\":\"+m.group(2);\n\n      log.info(\"hostPort : {}\", hostPort);\n\n      for (JettySolrRunner jetty : jettys) {\n        String s = jetty.getBaseUrl().toString();\n        if(s.contains(hostPort)){\n          log.info(\"leader node {}\",s);\n          ChaosMonkey.stop(jetty);\n          stoppedJetty = jetty;\n          timeout = System.currentTimeMillis()+10000;\n          leaderchanged = false;\n          for(;System.currentTimeMillis() < timeout;){\n            currentOverseer =  getLeaderNode(client.getZkStateReader().getZkClient());\n            if(anotherOverseer.equals(currentOverseer)){\n              leaderchanged =true;\n              break;\n            }\n            Thread.sleep(100);\n          }\n          assertTrue(\"New overseer designate has not become the overseer, expected : \"+ anotherOverseer + \"actual : \"+ currentOverseer, leaderchanged);\n        }\n\n      }\n\n    }\n\n    ChaosMonkey.start(stoppedJetty);\n\n    timeout = System.currentTimeMillis()+10000;\n    leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      List<String> sortedNodeNames = getSortedOverseerNodeNames(client.getZkStateReader().getZkClient());\n      if(sortedNodeNames.get(1).equals(killedOverseer) || sortedNodeNames.get(0).equals(killedOverseer)){\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n\n    assertTrue(\"New overseer not the frontrunner : \"+ getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) + \" expected : \"+ killedOverseer, leaderchanged);\n\n  }\n\n","sourceOld":"  private void addOverseerRole2ExistingNodes() throws Exception {\n    String collectionName = \"testOverseerCol\";\n\n    createCollection(collectionName, client);\n\n    waitForRecoveriesToFinish(collectionName, false);\n    List<String> l = OverseerCollectionProcessor.getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) ;\n\n    log.info(\"All nodes {}\", l);\n    String currentLeader = OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient());\n    log.info(\"Current leader {} \", currentLeader);\n    l.remove(currentLeader);\n\n    Collections.shuffle(l);\n    String overseerDesignate = l.get(0);\n    log.info(\"overseerDesignate {}\",overseerDesignate);\n    setOverseerRole(CollectionAction.ADDROLE,overseerDesignate);\n\n    long timeout = System.currentTimeMillis()+15000;\n\n    boolean leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      if(overseerDesignate.equals(OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()))){\n        log.info(\"overseer designate is the new overseer\");\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    assertTrue(\"could not set the new overseer . expected \"+\n        overseerDesignate + \" current order : \" +\n        getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) +\n        \" ldr :\"+ OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()) ,leaderchanged);\n\n\n\n    //add another node as overseer\n\n\n    l.remove(overseerDesignate);\n\n    Collections.shuffle(l);\n\n    String anotherOverseer = l.get(0);\n    log.info(\"Adding another overseer designate {}\", anotherOverseer);\n    setOverseerRole(CollectionAction.ADDROLE, anotherOverseer);\n\n    timeout = System.currentTimeMillis()+10000;\n    leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      List<String> sortedNodeNames = getSortedOverseerNodeNames(client.getZkStateReader().getZkClient());\n      if(sortedNodeNames.get(1) .equals(anotherOverseer) || sortedNodeNames.get(0).equals(anotherOverseer)){\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n\n    assertTrue(\"New overseer not the frontrunner : \"+ getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) + \" expected : \"+ anotherOverseer, leaderchanged);\n\n\n    String currentOverseer = getLeaderNode(client.getZkStateReader().getZkClient());\n\n    String killedOverseer = currentOverseer;\n\n    log.info(\"Current Overseer {}\", currentOverseer);\n    Pattern pattern = Pattern.compile(\"(.*):(\\\\d*)(.*)\");\n    Matcher m = pattern.matcher(currentOverseer);\n    JettySolrRunner stoppedJetty =null;\n\n    if(m.matches()){\n      String hostPort =  m.group(1)+\":\"+m.group(2);\n\n      log.info(\"hostPort : {}\", hostPort);\n\n      for (JettySolrRunner jetty : jettys) {\n        String s = jetty.getBaseUrl().toString();\n        if(s.contains(hostPort)){\n          log.info(\"leader node {}\",s);\n          ChaosMonkey.stop(jetty);\n          stoppedJetty = jetty;\n          timeout = System.currentTimeMillis()+10000;\n          leaderchanged = false;\n          for(;System.currentTimeMillis() < timeout;){\n            currentOverseer =  getLeaderNode(client.getZkStateReader().getZkClient());\n            if(anotherOverseer.equals(currentOverseer)){\n              leaderchanged =true;\n              break;\n            }\n            Thread.sleep(100);\n          }\n          assertTrue(\"New overseer designate has not become the overseer, expected : \"+ anotherOverseer + \"actual : \"+ currentOverseer, leaderchanged);\n        }\n\n      }\n\n    }\n\n    ChaosMonkey.start(stoppedJetty);\n\n    timeout = System.currentTimeMillis()+10000;\n    leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      List<String> sortedNodeNames = getSortedOverseerNodeNames(client.getZkStateReader().getZkClient());\n      if(sortedNodeNames.get(1).equals(killedOverseer) || sortedNodeNames.get(0).equals(killedOverseer)){\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n\n    assertTrue(\"New overseer not the frontrunner : \"+ getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) + \" expected : \"+ killedOverseer, leaderchanged);\n\n\n\n\n\n    client.shutdown();\n\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5eb2511ababf862ea11e10761c70ee560cd84510","date":1396607225,"type":1,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#testOverseerRole().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#addOverseerRole2ExistingNodes().mjava","sourceNew":"  private void testOverseerRole() throws Exception {\n    String collectionName = \"testOverseerCol\";\n\n    createCollection(collectionName, client);\n\n    waitForRecoveriesToFinish(collectionName, false);\n    List<String> l = OverseerCollectionProcessor.getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) ;\n\n    log.info(\"All nodes {}\", l);\n    String currentLeader = OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient());\n    log.info(\"Current leader {} \", currentLeader);\n    l.remove(currentLeader);\n\n    Collections.shuffle(l);\n    String overseerDesignate = l.get(0);\n    log.info(\"overseerDesignate {}\",overseerDesignate);\n    setOverseerRole(CollectionAction.ADDROLE,overseerDesignate);\n\n    long timeout = System.currentTimeMillis()+15000;\n\n    boolean leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      if(overseerDesignate.equals(OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()))){\n        log.info(\"overseer designate is the new overseer\");\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    assertTrue(\"could not set the new overseer . expected \"+\n        overseerDesignate + \" current order : \" +\n        getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) +\n        \" ldr :\"+ OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()) ,leaderchanged);\n\n\n\n    //add another node as overseer\n\n\n    l.remove(overseerDesignate);\n\n    Collections.shuffle(l);\n\n    String anotherOverseer = l.get(0);\n    log.info(\"Adding another overseer designate {}\", anotherOverseer);\n    setOverseerRole(CollectionAction.ADDROLE, anotherOverseer);\n\n    timeout = System.currentTimeMillis()+10000;\n    leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      List<String> sortedNodeNames = getSortedOverseerNodeNames(client.getZkStateReader().getZkClient());\n      if(sortedNodeNames.get(1) .equals(anotherOverseer) || sortedNodeNames.get(0).equals(anotherOverseer)){\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n\n    assertTrue(\"New overseer not the frontrunner : \"+ getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) + \" expected : \"+ anotherOverseer, leaderchanged);\n\n\n    String currentOverseer = getLeaderNode(client.getZkStateReader().getZkClient());\n\n    String killedOverseer = currentOverseer;\n\n    log.info(\"Current Overseer {}\", currentOverseer);\n    Pattern pattern = Pattern.compile(\"(.*):(\\\\d*)(.*)\");\n    Matcher m = pattern.matcher(currentOverseer);\n    JettySolrRunner stoppedJetty =null;\n\n    if(m.matches()){\n      String hostPort =  m.group(1)+\":\"+m.group(2);\n\n      log.info(\"hostPort : {}\", hostPort);\n\n      for (JettySolrRunner jetty : jettys) {\n        String s = jetty.getBaseUrl().toString();\n        if(s.contains(hostPort)){\n          log.info(\"leader node {}\",s);\n          ChaosMonkey.stop(jetty);\n          stoppedJetty = jetty;\n          timeout = System.currentTimeMillis()+10000;\n          leaderchanged = false;\n          for(;System.currentTimeMillis() < timeout;){\n            currentOverseer =  getLeaderNode(client.getZkStateReader().getZkClient());\n            if(anotherOverseer.equals(currentOverseer)){\n              leaderchanged =true;\n              break;\n            }\n            Thread.sleep(100);\n          }\n          assertTrue(\"New overseer designate has not become the overseer, expected : \"+ anotherOverseer + \"actual : \"+ currentOverseer, leaderchanged);\n        }\n\n      }\n\n    }\n\n    ChaosMonkey.start(stoppedJetty);\n\n    timeout = System.currentTimeMillis()+10000;\n    leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      List<String> sortedNodeNames = getSortedOverseerNodeNames(client.getZkStateReader().getZkClient());\n      if(sortedNodeNames.get(1).equals(killedOverseer) || sortedNodeNames.get(0).equals(killedOverseer)){\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n\n    assertTrue(\"New overseer not the frontrunner : \"+ getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) + \" expected : \"+ killedOverseer, leaderchanged);\n\n  }\n\n","sourceOld":"  private void addOverseerRole2ExistingNodes() throws Exception {\n    String collectionName = \"testOverseerCol\";\n\n    createCollection(collectionName, client);\n\n    waitForRecoveriesToFinish(collectionName, false);\n    List<String> l = OverseerCollectionProcessor.getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) ;\n\n    log.info(\"All nodes {}\", l);\n    String currentLeader = OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient());\n    log.info(\"Current leader {} \", currentLeader);\n    l.remove(currentLeader);\n\n    Collections.shuffle(l);\n    String overseerDesignate = l.get(0);\n    log.info(\"overseerDesignate {}\",overseerDesignate);\n    setOverseerRole(CollectionAction.ADDROLE,overseerDesignate);\n\n    long timeout = System.currentTimeMillis()+15000;\n\n    boolean leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      if(overseerDesignate.equals(OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()))){\n        log.info(\"overseer designate is the new overseer\");\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    assertTrue(\"could not set the new overseer . expected \"+\n        overseerDesignate + \" current order : \" +\n        getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) +\n        \" ldr :\"+ OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()) ,leaderchanged);\n\n\n\n    //add another node as overseer\n\n\n    l.remove(overseerDesignate);\n\n    Collections.shuffle(l);\n\n    String anotherOverseer = l.get(0);\n    log.info(\"Adding another overseer designate {}\", anotherOverseer);\n    setOverseerRole(CollectionAction.ADDROLE, anotherOverseer);\n\n    timeout = System.currentTimeMillis()+10000;\n    leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      List<String> sortedNodeNames = getSortedOverseerNodeNames(client.getZkStateReader().getZkClient());\n      if(sortedNodeNames.get(1) .equals(anotherOverseer) || sortedNodeNames.get(0).equals(anotherOverseer)){\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n\n    assertTrue(\"New overseer not the frontrunner : \"+ getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) + \" expected : \"+ anotherOverseer, leaderchanged);\n\n\n    String currentOverseer = getLeaderNode(client.getZkStateReader().getZkClient());\n\n    String killedOverseer = currentOverseer;\n\n    log.info(\"Current Overseer {}\", currentOverseer);\n    Pattern pattern = Pattern.compile(\"(.*):(\\\\d*)(.*)\");\n    Matcher m = pattern.matcher(currentOverseer);\n    JettySolrRunner stoppedJetty =null;\n\n    if(m.matches()){\n      String hostPort =  m.group(1)+\":\"+m.group(2);\n\n      log.info(\"hostPort : {}\", hostPort);\n\n      for (JettySolrRunner jetty : jettys) {\n        String s = jetty.getBaseUrl().toString();\n        if(s.contains(hostPort)){\n          log.info(\"leader node {}\",s);\n          ChaosMonkey.stop(jetty);\n          stoppedJetty = jetty;\n          timeout = System.currentTimeMillis()+10000;\n          leaderchanged = false;\n          for(;System.currentTimeMillis() < timeout;){\n            currentOverseer =  getLeaderNode(client.getZkStateReader().getZkClient());\n            if(anotherOverseer.equals(currentOverseer)){\n              leaderchanged =true;\n              break;\n            }\n            Thread.sleep(100);\n          }\n          assertTrue(\"New overseer designate has not become the overseer, expected : \"+ anotherOverseer + \"actual : \"+ currentOverseer, leaderchanged);\n        }\n\n      }\n\n    }\n\n    ChaosMonkey.start(stoppedJetty);\n\n    timeout = System.currentTimeMillis()+10000;\n    leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      List<String> sortedNodeNames = getSortedOverseerNodeNames(client.getZkStateReader().getZkClient());\n      if(sortedNodeNames.get(1).equals(killedOverseer) || sortedNodeNames.get(0).equals(killedOverseer)){\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n\n    assertTrue(\"New overseer not the frontrunner : \"+ getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) + \" expected : \"+ killedOverseer, leaderchanged);\n\n\n\n\n\n    client.shutdown();\n\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6762551dad139aaedf252c353553e7bdbf7daffe","date":1396779167,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#testOverseerRole().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#testOverseerRole().mjava","sourceNew":"  private void testOverseerRole() throws Exception {\n    String collectionName = \"testOverseerCol\";\n\n    createCollection(collectionName, client);\n\n    waitForRecoveriesToFinish(collectionName, false);\n    List<String> l = OverseerCollectionProcessor.getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) ;\n\n    log.info(\"All nodes {}\", l);\n    String currentLeader = OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient());\n    log.info(\"Current leader {} \", currentLeader);\n    l.remove(currentLeader);\n\n    Collections.shuffle(l);\n    String overseerDesignate = l.get(0);\n    log.info(\"overseerDesignate {}\",overseerDesignate);\n    setOverseerRole(CollectionAction.ADDROLE,overseerDesignate);\n\n    long timeout = System.currentTimeMillis()+15000;\n\n    boolean leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      if(overseerDesignate.equals(OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()))){\n        log.info(\"overseer designate is the new overseer\");\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    assertTrue(\"could not set the new overseer . expected \"+\n        overseerDesignate + \" current order : \" +\n        getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) +\n        \" ldr :\"+ OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()) ,leaderchanged);\n\n\n\n    //add another node as overseer\n\n\n    l.remove(overseerDesignate);\n\n    Collections.shuffle(l);\n\n    String anotherOverseer = l.get(0);\n    log.info(\"Adding another overseer designate {}\", anotherOverseer);\n    setOverseerRole(CollectionAction.ADDROLE, anotherOverseer);\n\n    timeout = System.currentTimeMillis()+10000;\n    leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      List<String> sortedNodeNames = getSortedOverseerNodeNames(client.getZkStateReader().getZkClient());\n      if(sortedNodeNames.get(1) .equals(anotherOverseer) || sortedNodeNames.get(0).equals(anotherOverseer)){\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n\n    assertTrue(\"New overseer not the frontrunner : \"+ getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) + \" expected : \"+ anotherOverseer, leaderchanged);\n\n\n    String currentOverseer = getLeaderNode(client.getZkStateReader().getZkClient());\n\n    String killedOverseer = currentOverseer;\n\n    log.info(\"Current Overseer {}\", currentOverseer);\n    Pattern pattern = Pattern.compile(\"(.*):(\\\\d*)(.*)\");\n    Matcher m = pattern.matcher(currentOverseer);\n    JettySolrRunner stoppedJetty =null;\n\n    String hostPort = null;\n    StringBuilder sb = new StringBuilder();\n    if(m.matches()){\n      hostPort =  m.group(1)+\":\"+m.group(2);\n\n      log.info(\"hostPort : {}\", hostPort);\n\n      for (JettySolrRunner jetty : jettys) {\n        String s = jetty.getBaseUrl().toString();\n        sb.append(s).append(\" , \");\n        if(s.contains(hostPort)){\n          log.info(\"leader node {}\",s);\n          ChaosMonkey.stop(jetty);\n          stoppedJetty = jetty;\n          timeout = System.currentTimeMillis()+10000;\n          leaderchanged = false;\n          for(;System.currentTimeMillis() < timeout;){\n            currentOverseer =  getLeaderNode(client.getZkStateReader().getZkClient());\n            if(anotherOverseer.equals(currentOverseer)){\n              leaderchanged =true;\n              break;\n            }\n            Thread.sleep(100);\n          }\n          assertTrue(\"New overseer designate has not become the overseer, expected : \"+ anotherOverseer + \"actual : \"+ currentOverseer, leaderchanged);\n        }\n\n      }\n\n    } else{\n      fail(\"pattern didn't match for\"+currentOverseer );\n    }\n\n    if(stoppedJetty !=null) {\n      ChaosMonkey.start(stoppedJetty);\n\n      timeout = System.currentTimeMillis() + 10000;\n      leaderchanged = false;\n      for (; System.currentTimeMillis() < timeout; ) {\n        List<String> sortedNodeNames = getSortedOverseerNodeNames(client.getZkStateReader().getZkClient());\n        if (sortedNodeNames.get(1).equals(killedOverseer) || sortedNodeNames.get(0).equals(killedOverseer)) {\n          leaderchanged = true;\n          break;\n        }\n        Thread.sleep(100);\n      }\n\n      assertTrue(\"New overseer not the frontrunner : \" + getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) + \" expected : \" + killedOverseer, leaderchanged);\n    } else {\n      log.warn(\"The jetty where the overseer {} is running could not be located in {}\",hostPort,sb);\n    }\n  }\n\n","sourceOld":"  private void testOverseerRole() throws Exception {\n    String collectionName = \"testOverseerCol\";\n\n    createCollection(collectionName, client);\n\n    waitForRecoveriesToFinish(collectionName, false);\n    List<String> l = OverseerCollectionProcessor.getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) ;\n\n    log.info(\"All nodes {}\", l);\n    String currentLeader = OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient());\n    log.info(\"Current leader {} \", currentLeader);\n    l.remove(currentLeader);\n\n    Collections.shuffle(l);\n    String overseerDesignate = l.get(0);\n    log.info(\"overseerDesignate {}\",overseerDesignate);\n    setOverseerRole(CollectionAction.ADDROLE,overseerDesignate);\n\n    long timeout = System.currentTimeMillis()+15000;\n\n    boolean leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      if(overseerDesignate.equals(OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()))){\n        log.info(\"overseer designate is the new overseer\");\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    assertTrue(\"could not set the new overseer . expected \"+\n        overseerDesignate + \" current order : \" +\n        getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) +\n        \" ldr :\"+ OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()) ,leaderchanged);\n\n\n\n    //add another node as overseer\n\n\n    l.remove(overseerDesignate);\n\n    Collections.shuffle(l);\n\n    String anotherOverseer = l.get(0);\n    log.info(\"Adding another overseer designate {}\", anotherOverseer);\n    setOverseerRole(CollectionAction.ADDROLE, anotherOverseer);\n\n    timeout = System.currentTimeMillis()+10000;\n    leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      List<String> sortedNodeNames = getSortedOverseerNodeNames(client.getZkStateReader().getZkClient());\n      if(sortedNodeNames.get(1) .equals(anotherOverseer) || sortedNodeNames.get(0).equals(anotherOverseer)){\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n\n    assertTrue(\"New overseer not the frontrunner : \"+ getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) + \" expected : \"+ anotherOverseer, leaderchanged);\n\n\n    String currentOverseer = getLeaderNode(client.getZkStateReader().getZkClient());\n\n    String killedOverseer = currentOverseer;\n\n    log.info(\"Current Overseer {}\", currentOverseer);\n    Pattern pattern = Pattern.compile(\"(.*):(\\\\d*)(.*)\");\n    Matcher m = pattern.matcher(currentOverseer);\n    JettySolrRunner stoppedJetty =null;\n\n    if(m.matches()){\n      String hostPort =  m.group(1)+\":\"+m.group(2);\n\n      log.info(\"hostPort : {}\", hostPort);\n\n      for (JettySolrRunner jetty : jettys) {\n        String s = jetty.getBaseUrl().toString();\n        if(s.contains(hostPort)){\n          log.info(\"leader node {}\",s);\n          ChaosMonkey.stop(jetty);\n          stoppedJetty = jetty;\n          timeout = System.currentTimeMillis()+10000;\n          leaderchanged = false;\n          for(;System.currentTimeMillis() < timeout;){\n            currentOverseer =  getLeaderNode(client.getZkStateReader().getZkClient());\n            if(anotherOverseer.equals(currentOverseer)){\n              leaderchanged =true;\n              break;\n            }\n            Thread.sleep(100);\n          }\n          assertTrue(\"New overseer designate has not become the overseer, expected : \"+ anotherOverseer + \"actual : \"+ currentOverseer, leaderchanged);\n        }\n\n      }\n\n    }\n\n    ChaosMonkey.start(stoppedJetty);\n\n    timeout = System.currentTimeMillis()+10000;\n    leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      List<String> sortedNodeNames = getSortedOverseerNodeNames(client.getZkStateReader().getZkClient());\n      if(sortedNodeNames.get(1).equals(killedOverseer) || sortedNodeNames.get(0).equals(killedOverseer)){\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n\n    assertTrue(\"New overseer not the frontrunner : \"+ getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) + \" expected : \"+ killedOverseer, leaderchanged);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7d996c36bf85996da326201b915c87d41449d7f5","date":1403084374,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#testOverseerRole().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#testOverseerRole().mjava","sourceNew":"  private void testOverseerRole() throws Exception {\n    String collectionName = \"testOverseerCol\";\n\n    createCollection(collectionName, client);\n\n    waitForRecoveriesToFinish(collectionName, false);\n    List<String> l = OverseerCollectionProcessor.getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) ;\n\n    log.info(\"All nodes {}\", l);\n    String currentLeader = OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient());\n    log.info(\"Current leader {} \", currentLeader);\n    l.remove(currentLeader);\n\n    Collections.shuffle(l);\n    String overseerDesignate = l.get(0);\n    log.info(\"overseerDesignate {}\",overseerDesignate);\n    setOverseerRole(CollectionAction.ADDROLE,overseerDesignate);\n\n    long timeout = System.currentTimeMillis()+15000;\n\n    boolean leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      if(overseerDesignate.equals(OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()))){\n        log.info(\"overseer designate is the new overseer\");\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    assertTrue(\"could not set the new overseer . expected \"+\n        overseerDesignate + \" current order : \" +\n        getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) +\n        \" ldr :\"+ OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()) ,leaderchanged);\n\n\n\n    //add another node as overseer\n\n\n    l.remove(overseerDesignate);\n\n    Collections.shuffle(l);\n\n    String anotherOverseer = l.get(0);\n    log.info(\"Adding another overseer designate {}\", anotherOverseer);\n    setOverseerRole(CollectionAction.ADDROLE, anotherOverseer);\n\n    String currentOverseer = getLeaderNode(client.getZkStateReader().getZkClient());\n\n    log.info(\"Current Overseer {}\", currentOverseer);\n\n    String hostPort = currentOverseer.substring(0,currentOverseer.indexOf('_'));\n\n    StringBuilder sb = new StringBuilder();\n//\n//\n    log.info(\"hostPort : {}\", hostPort);\n\n    JettySolrRunner leaderJetty = null;\n\n    for (JettySolrRunner jetty : jettys) {\n      String s = jetty.getBaseUrl().toString();\n      log.info(\"jetTy {}\",s);\n      sb.append(s).append(\" , \");\n      if (s.contains(hostPort)) {\n        leaderJetty = jetty;\n        break;\n      }\n    }\n\n    assertNotNull(\"Could not find a jetty2 kill\",  leaderJetty);\n\n    log.info(\"leader node {}\", leaderJetty.getBaseUrl());\n    log.info (\"current election Queue\", OverseerCollectionProcessor.getSortedElectionNodes(client.getZkStateReader().getZkClient()));\n    ChaosMonkey.stop(leaderJetty);\n    timeout = System.currentTimeMillis() + 10000;\n    leaderchanged = false;\n    for (; System.currentTimeMillis() < timeout; ) {\n      currentOverseer = getLeaderNode(client.getZkStateReader().getZkClient());\n      if (anotherOverseer.equals(currentOverseer)) {\n        leaderchanged = true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    assertTrue(\"New overseer designate has not become the overseer, expected : \" + anotherOverseer + \"actual : \" + getLeaderNode(client.getZkStateReader().getZkClient()), leaderchanged);\n  }\n\n","sourceOld":"  private void testOverseerRole() throws Exception {\n    String collectionName = \"testOverseerCol\";\n\n    createCollection(collectionName, client);\n\n    waitForRecoveriesToFinish(collectionName, false);\n    List<String> l = OverseerCollectionProcessor.getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) ;\n\n    log.info(\"All nodes {}\", l);\n    String currentLeader = OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient());\n    log.info(\"Current leader {} \", currentLeader);\n    l.remove(currentLeader);\n\n    Collections.shuffle(l);\n    String overseerDesignate = l.get(0);\n    log.info(\"overseerDesignate {}\",overseerDesignate);\n    setOverseerRole(CollectionAction.ADDROLE,overseerDesignate);\n\n    long timeout = System.currentTimeMillis()+15000;\n\n    boolean leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      if(overseerDesignate.equals(OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()))){\n        log.info(\"overseer designate is the new overseer\");\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    assertTrue(\"could not set the new overseer . expected \"+\n        overseerDesignate + \" current order : \" +\n        getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) +\n        \" ldr :\"+ OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()) ,leaderchanged);\n\n\n\n    //add another node as overseer\n\n\n    l.remove(overseerDesignate);\n\n    Collections.shuffle(l);\n\n    String anotherOverseer = l.get(0);\n    log.info(\"Adding another overseer designate {}\", anotherOverseer);\n    setOverseerRole(CollectionAction.ADDROLE, anotherOverseer);\n\n    timeout = System.currentTimeMillis()+10000;\n    leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      List<String> sortedNodeNames = getSortedOverseerNodeNames(client.getZkStateReader().getZkClient());\n      if(sortedNodeNames.get(1) .equals(anotherOverseer) || sortedNodeNames.get(0).equals(anotherOverseer)){\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n\n    assertTrue(\"New overseer not the frontrunner : \"+ getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) + \" expected : \"+ anotherOverseer, leaderchanged);\n\n\n    String currentOverseer = getLeaderNode(client.getZkStateReader().getZkClient());\n\n    String killedOverseer = currentOverseer;\n\n    log.info(\"Current Overseer {}\", currentOverseer);\n    Pattern pattern = Pattern.compile(\"(.*):(\\\\d*)(.*)\");\n    Matcher m = pattern.matcher(currentOverseer);\n    JettySolrRunner stoppedJetty =null;\n\n    String hostPort = null;\n    StringBuilder sb = new StringBuilder();\n    if(m.matches()){\n      hostPort =  m.group(1)+\":\"+m.group(2);\n\n      log.info(\"hostPort : {}\", hostPort);\n\n      for (JettySolrRunner jetty : jettys) {\n        String s = jetty.getBaseUrl().toString();\n        sb.append(s).append(\" , \");\n        if(s.contains(hostPort)){\n          log.info(\"leader node {}\",s);\n          ChaosMonkey.stop(jetty);\n          stoppedJetty = jetty;\n          timeout = System.currentTimeMillis()+10000;\n          leaderchanged = false;\n          for(;System.currentTimeMillis() < timeout;){\n            currentOverseer =  getLeaderNode(client.getZkStateReader().getZkClient());\n            if(anotherOverseer.equals(currentOverseer)){\n              leaderchanged =true;\n              break;\n            }\n            Thread.sleep(100);\n          }\n          assertTrue(\"New overseer designate has not become the overseer, expected : \"+ anotherOverseer + \"actual : \"+ currentOverseer, leaderchanged);\n        }\n\n      }\n\n    } else{\n      fail(\"pattern didn't match for\"+currentOverseer );\n    }\n\n    if(stoppedJetty !=null) {\n      ChaosMonkey.start(stoppedJetty);\n\n      timeout = System.currentTimeMillis() + 10000;\n      leaderchanged = false;\n      for (; System.currentTimeMillis() < timeout; ) {\n        List<String> sortedNodeNames = getSortedOverseerNodeNames(client.getZkStateReader().getZkClient());\n        if (sortedNodeNames.get(1).equals(killedOverseer) || sortedNodeNames.get(0).equals(killedOverseer)) {\n          leaderchanged = true;\n          break;\n        }\n        Thread.sleep(100);\n      }\n\n      assertTrue(\"New overseer not the frontrunner : \" + getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) + \" expected : \" + killedOverseer, leaderchanged);\n    } else {\n      log.warn(\"The jetty where the overseer {} is running could not be located in {}\",hostPort,sb);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e57c73924f3b8c19defa62e96bfa34a4922d49c2","date":1403106358,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#testOverseerRole().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#testOverseerRole().mjava","sourceNew":"  private void testOverseerRole() throws Exception {\n    String collectionName = \"testOverseerCol\";\n\n    createCollection(collectionName, client);\n\n    waitForRecoveriesToFinish(collectionName, false);\n    List<String> l = OverseerCollectionProcessor.getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) ;\n\n    log.info(\"All nodes {}\", l);\n    String currentLeader = OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient());\n    log.info(\"Current leader {} \", currentLeader);\n    l.remove(currentLeader);\n\n    Collections.shuffle(l);\n    String overseerDesignate = l.get(0);\n    log.info(\"overseerDesignate {}\",overseerDesignate);\n    setOverseerRole(CollectionAction.ADDROLE,overseerDesignate);\n\n    long timeout = System.currentTimeMillis()+15000;\n\n    boolean leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      if(overseerDesignate.equals(OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()))){\n        log.info(\"overseer designate is the new overseer\");\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    assertTrue(\"could not set the new overseer . expected \"+\n        overseerDesignate + \" current order : \" +\n        getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) +\n        \" ldr :\"+ OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()) ,leaderchanged);\n\n\n\n    //add another node as overseer\n\n\n    l.remove(overseerDesignate);\n\n    Collections.shuffle(l);\n\n    String anotherOverseer = l.get(0);\n    log.info(\"Adding another overseer designate {}\", anotherOverseer);\n    setOverseerRole(CollectionAction.ADDROLE, anotherOverseer);\n\n    String currentOverseer = getLeaderNode(client.getZkStateReader().getZkClient());\n\n    log.info(\"Current Overseer {}\", currentOverseer);\n\n    String hostPort = currentOverseer.substring(0,currentOverseer.indexOf('_'));\n\n    StringBuilder sb = new StringBuilder();\n//\n//\n    log.info(\"hostPort : {}\", hostPort);\n\n    JettySolrRunner leaderJetty = null;\n\n    for (JettySolrRunner jetty : jettys) {\n      String s = jetty.getBaseUrl().toString();\n      log.info(\"jetTy {}\",s);\n      sb.append(s).append(\" , \");\n      if (s.contains(hostPort)) {\n        leaderJetty = jetty;\n        break;\n      }\n    }\n\n    assertNotNull(\"Could not find a jetty2 kill\",  leaderJetty);\n\n    log.info(\"leader node {}\", leaderJetty.getBaseUrl());\n    log.info (\"current election Queue\", OverseerCollectionProcessor.getSortedElectionNodes(client.getZkStateReader().getZkClient()));\n    ChaosMonkey.stop(leaderJetty);\n    timeout = System.currentTimeMillis() + 10000;\n    leaderchanged = false;\n    for (; System.currentTimeMillis() < timeout; ) {\n      currentOverseer = getLeaderNode(client.getZkStateReader().getZkClient());\n      if (anotherOverseer.equals(currentOverseer)) {\n        leaderchanged = true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    assertTrue(\"New overseer designate has not become the overseer, expected : \" + anotherOverseer + \"actual : \" + getLeaderNode(client.getZkStateReader().getZkClient()), leaderchanged);\n  }\n\n","sourceOld":"  private void testOverseerRole() throws Exception {\n    String collectionName = \"testOverseerCol\";\n\n    createCollection(collectionName, client);\n\n    waitForRecoveriesToFinish(collectionName, false);\n    List<String> l = OverseerCollectionProcessor.getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) ;\n\n    log.info(\"All nodes {}\", l);\n    String currentLeader = OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient());\n    log.info(\"Current leader {} \", currentLeader);\n    l.remove(currentLeader);\n\n    Collections.shuffle(l);\n    String overseerDesignate = l.get(0);\n    log.info(\"overseerDesignate {}\",overseerDesignate);\n    setOverseerRole(CollectionAction.ADDROLE,overseerDesignate);\n\n    long timeout = System.currentTimeMillis()+15000;\n\n    boolean leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      if(overseerDesignate.equals(OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()))){\n        log.info(\"overseer designate is the new overseer\");\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    assertTrue(\"could not set the new overseer . expected \"+\n        overseerDesignate + \" current order : \" +\n        getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) +\n        \" ldr :\"+ OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()) ,leaderchanged);\n\n\n\n    //add another node as overseer\n\n\n    l.remove(overseerDesignate);\n\n    Collections.shuffle(l);\n\n    String anotherOverseer = l.get(0);\n    log.info(\"Adding another overseer designate {}\", anotherOverseer);\n    setOverseerRole(CollectionAction.ADDROLE, anotherOverseer);\n\n    timeout = System.currentTimeMillis()+10000;\n    leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      List<String> sortedNodeNames = getSortedOverseerNodeNames(client.getZkStateReader().getZkClient());\n      if(sortedNodeNames.get(1) .equals(anotherOverseer) || sortedNodeNames.get(0).equals(anotherOverseer)){\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n\n    assertTrue(\"New overseer not the frontrunner : \"+ getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) + \" expected : \"+ anotherOverseer, leaderchanged);\n\n\n    String currentOverseer = getLeaderNode(client.getZkStateReader().getZkClient());\n\n    String killedOverseer = currentOverseer;\n\n    log.info(\"Current Overseer {}\", currentOverseer);\n    Pattern pattern = Pattern.compile(\"(.*):(\\\\d*)(.*)\");\n    Matcher m = pattern.matcher(currentOverseer);\n    JettySolrRunner stoppedJetty =null;\n\n    String hostPort = null;\n    StringBuilder sb = new StringBuilder();\n    if(m.matches()){\n      hostPort =  m.group(1)+\":\"+m.group(2);\n\n      log.info(\"hostPort : {}\", hostPort);\n\n      for (JettySolrRunner jetty : jettys) {\n        String s = jetty.getBaseUrl().toString();\n        sb.append(s).append(\" , \");\n        if(s.contains(hostPort)){\n          log.info(\"leader node {}\",s);\n          ChaosMonkey.stop(jetty);\n          stoppedJetty = jetty;\n          timeout = System.currentTimeMillis()+10000;\n          leaderchanged = false;\n          for(;System.currentTimeMillis() < timeout;){\n            currentOverseer =  getLeaderNode(client.getZkStateReader().getZkClient());\n            if(anotherOverseer.equals(currentOverseer)){\n              leaderchanged =true;\n              break;\n            }\n            Thread.sleep(100);\n          }\n          assertTrue(\"New overseer designate has not become the overseer, expected : \"+ anotherOverseer + \"actual : \"+ currentOverseer, leaderchanged);\n        }\n\n      }\n\n    } else{\n      fail(\"pattern didn't match for\"+currentOverseer );\n    }\n\n    if(stoppedJetty !=null) {\n      ChaosMonkey.start(stoppedJetty);\n\n      timeout = System.currentTimeMillis() + 10000;\n      leaderchanged = false;\n      for (; System.currentTimeMillis() < timeout; ) {\n        List<String> sortedNodeNames = getSortedOverseerNodeNames(client.getZkStateReader().getZkClient());\n        if (sortedNodeNames.get(1).equals(killedOverseer) || sortedNodeNames.get(0).equals(killedOverseer)) {\n          leaderchanged = true;\n          break;\n        }\n        Thread.sleep(100);\n      }\n\n      assertTrue(\"New overseer not the frontrunner : \" + getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) + \" expected : \" + killedOverseer, leaderchanged);\n    } else {\n      log.warn(\"The jetty where the overseer {} is running could not be located in {}\",hostPort,sb);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"103857ec20f79f31c7a00310a91ed001b9a6ef17","date":1412698959,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#testOverseerRole().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#testOverseerRole().mjava","sourceNew":"  private void testOverseerRole() throws Exception {\n    String collectionName = \"testOverseerCol\";\n\n    createCollection(collectionName, client);\n\n    waitForRecoveriesToFinish(collectionName, false);\n    List<String> l = OverseerCollectionProcessor.getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) ;\n\n    log.info(\"All nodes {}\", l);\n    String currentLeader = OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient());\n    log.info(\"Current leader {} \", currentLeader);\n    l.remove(currentLeader);\n\n    Collections.shuffle(l, random());\n    String overseerDesignate = l.get(0);\n    log.info(\"overseerDesignate {}\",overseerDesignate);\n    setOverseerRole(CollectionAction.ADDROLE,overseerDesignate);\n\n    long timeout = System.currentTimeMillis()+15000;\n\n    boolean leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      if(overseerDesignate.equals(OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()))){\n        log.info(\"overseer designate is the new overseer\");\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    assertTrue(\"could not set the new overseer . expected \"+\n        overseerDesignate + \" current order : \" +\n        getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) +\n        \" ldr :\"+ OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()) ,leaderchanged);\n\n\n\n    //add another node as overseer\n\n\n    l.remove(overseerDesignate);\n\n    Collections.shuffle(l, random());\n\n    String anotherOverseer = l.get(0);\n    log.info(\"Adding another overseer designate {}\", anotherOverseer);\n    setOverseerRole(CollectionAction.ADDROLE, anotherOverseer);\n\n    String currentOverseer = getLeaderNode(client.getZkStateReader().getZkClient());\n\n    log.info(\"Current Overseer {}\", currentOverseer);\n\n    String hostPort = currentOverseer.substring(0,currentOverseer.indexOf('_'));\n\n    StringBuilder sb = new StringBuilder();\n//\n//\n    log.info(\"hostPort : {}\", hostPort);\n\n    JettySolrRunner leaderJetty = null;\n\n    for (JettySolrRunner jetty : jettys) {\n      String s = jetty.getBaseUrl().toString();\n      log.info(\"jetTy {}\",s);\n      sb.append(s).append(\" , \");\n      if (s.contains(hostPort)) {\n        leaderJetty = jetty;\n        break;\n      }\n    }\n\n    assertNotNull(\"Could not find a jetty2 kill\",  leaderJetty);\n\n    log.info(\"leader node {}\", leaderJetty.getBaseUrl());\n    log.info (\"current election Queue\", OverseerCollectionProcessor.getSortedElectionNodes(client.getZkStateReader().getZkClient()));\n    ChaosMonkey.stop(leaderJetty);\n    timeout = System.currentTimeMillis() + 10000;\n    leaderchanged = false;\n    for (; System.currentTimeMillis() < timeout; ) {\n      currentOverseer = getLeaderNode(client.getZkStateReader().getZkClient());\n      if (anotherOverseer.equals(currentOverseer)) {\n        leaderchanged = true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    assertTrue(\"New overseer designate has not become the overseer, expected : \" + anotherOverseer + \"actual : \" + getLeaderNode(client.getZkStateReader().getZkClient()), leaderchanged);\n  }\n\n","sourceOld":"  private void testOverseerRole() throws Exception {\n    String collectionName = \"testOverseerCol\";\n\n    createCollection(collectionName, client);\n\n    waitForRecoveriesToFinish(collectionName, false);\n    List<String> l = OverseerCollectionProcessor.getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) ;\n\n    log.info(\"All nodes {}\", l);\n    String currentLeader = OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient());\n    log.info(\"Current leader {} \", currentLeader);\n    l.remove(currentLeader);\n\n    Collections.shuffle(l);\n    String overseerDesignate = l.get(0);\n    log.info(\"overseerDesignate {}\",overseerDesignate);\n    setOverseerRole(CollectionAction.ADDROLE,overseerDesignate);\n\n    long timeout = System.currentTimeMillis()+15000;\n\n    boolean leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      if(overseerDesignate.equals(OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()))){\n        log.info(\"overseer designate is the new overseer\");\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    assertTrue(\"could not set the new overseer . expected \"+\n        overseerDesignate + \" current order : \" +\n        getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) +\n        \" ldr :\"+ OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()) ,leaderchanged);\n\n\n\n    //add another node as overseer\n\n\n    l.remove(overseerDesignate);\n\n    Collections.shuffle(l);\n\n    String anotherOverseer = l.get(0);\n    log.info(\"Adding another overseer designate {}\", anotherOverseer);\n    setOverseerRole(CollectionAction.ADDROLE, anotherOverseer);\n\n    String currentOverseer = getLeaderNode(client.getZkStateReader().getZkClient());\n\n    log.info(\"Current Overseer {}\", currentOverseer);\n\n    String hostPort = currentOverseer.substring(0,currentOverseer.indexOf('_'));\n\n    StringBuilder sb = new StringBuilder();\n//\n//\n    log.info(\"hostPort : {}\", hostPort);\n\n    JettySolrRunner leaderJetty = null;\n\n    for (JettySolrRunner jetty : jettys) {\n      String s = jetty.getBaseUrl().toString();\n      log.info(\"jetTy {}\",s);\n      sb.append(s).append(\" , \");\n      if (s.contains(hostPort)) {\n        leaderJetty = jetty;\n        break;\n      }\n    }\n\n    assertNotNull(\"Could not find a jetty2 kill\",  leaderJetty);\n\n    log.info(\"leader node {}\", leaderJetty.getBaseUrl());\n    log.info (\"current election Queue\", OverseerCollectionProcessor.getSortedElectionNodes(client.getZkStateReader().getZkClient()));\n    ChaosMonkey.stop(leaderJetty);\n    timeout = System.currentTimeMillis() + 10000;\n    leaderchanged = false;\n    for (; System.currentTimeMillis() < timeout; ) {\n      currentOverseer = getLeaderNode(client.getZkStateReader().getZkClient());\n      if (anotherOverseer.equals(currentOverseer)) {\n        leaderchanged = true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    assertTrue(\"New overseer designate has not become the overseer, expected : \" + anotherOverseer + \"actual : \" + getLeaderNode(client.getZkStateReader().getZkClient()), leaderchanged);\n  }\n\n","bugFix":["44de42d869f7d8e5235d43c4ad9a99f520363a2f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55980207f1977bd1463465de1659b821347e2fa8","date":1413336386,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#testOverseerRole().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#testOverseerRole().mjava","sourceNew":"  private void testOverseerRole() throws Exception {\n    String collectionName = \"testOverseerCol\";\n\n    createCollection(collectionName, client);\n\n    waitForRecoveriesToFinish(collectionName, false);\n    List<String> l = OverseerCollectionProcessor.getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) ;\n\n    log.info(\"All nodes {}\", l);\n    String currentLeader = OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient());\n    log.info(\"Current leader {} \", currentLeader);\n    l.remove(currentLeader);\n\n    Collections.shuffle(l, random());\n    String overseerDesignate = l.get(0);\n    log.info(\"overseerDesignate {}\",overseerDesignate);\n    setOverseerRole(CollectionAction.ADDROLE,overseerDesignate);\n\n    long timeout = System.currentTimeMillis()+15000;\n\n    boolean leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      if(overseerDesignate.equals(OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()))){\n        log.info(\"overseer designate is the new overseer\");\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    assertTrue(\"could not set the new overseer . expected \"+\n        overseerDesignate + \" current order : \" +\n        getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) +\n        \" ldr :\"+ OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()) ,leaderchanged);\n\n\n\n    //add another node as overseer\n\n\n    l.remove(overseerDesignate);\n\n    Collections.shuffle(l, random());\n\n    String anotherOverseer = l.get(0);\n    log.info(\"Adding another overseer designate {}\", anotherOverseer);\n    setOverseerRole(CollectionAction.ADDROLE, anotherOverseer);\n\n    String currentOverseer = getLeaderNode(client.getZkStateReader().getZkClient());\n\n    log.info(\"Current Overseer {}\", currentOverseer);\n\n    String hostPort = currentOverseer.substring(0,currentOverseer.indexOf('_'));\n\n    StringBuilder sb = new StringBuilder();\n//\n//\n    log.info(\"hostPort : {}\", hostPort);\n\n    JettySolrRunner leaderJetty = null;\n\n    for (JettySolrRunner jetty : jettys) {\n      String s = jetty.getBaseUrl().toString();\n      log.info(\"jetTy {}\",s);\n      sb.append(s).append(\" , \");\n      if (s.contains(hostPort)) {\n        leaderJetty = jetty;\n        break;\n      }\n    }\n\n    assertNotNull(\"Could not find a jetty2 kill\",  leaderJetty);\n\n    log.info(\"leader node {}\", leaderJetty.getBaseUrl());\n    log.info (\"current election Queue\", OverseerCollectionProcessor.getSortedElectionNodes(client.getZkStateReader().getZkClient()));\n    ChaosMonkey.stop(leaderJetty);\n    timeout = System.currentTimeMillis() + 10000;\n    leaderchanged = false;\n    for (; System.currentTimeMillis() < timeout; ) {\n      currentOverseer = getLeaderNode(client.getZkStateReader().getZkClient());\n      if (anotherOverseer.equals(currentOverseer)) {\n        leaderchanged = true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    assertTrue(\"New overseer designate has not become the overseer, expected : \" + anotherOverseer + \"actual : \" + getLeaderNode(client.getZkStateReader().getZkClient()), leaderchanged);\n  }\n\n","sourceOld":"  private void testOverseerRole() throws Exception {\n    String collectionName = \"testOverseerCol\";\n\n    createCollection(collectionName, client);\n\n    waitForRecoveriesToFinish(collectionName, false);\n    List<String> l = OverseerCollectionProcessor.getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) ;\n\n    log.info(\"All nodes {}\", l);\n    String currentLeader = OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient());\n    log.info(\"Current leader {} \", currentLeader);\n    l.remove(currentLeader);\n\n    Collections.shuffle(l);\n    String overseerDesignate = l.get(0);\n    log.info(\"overseerDesignate {}\",overseerDesignate);\n    setOverseerRole(CollectionAction.ADDROLE,overseerDesignate);\n\n    long timeout = System.currentTimeMillis()+15000;\n\n    boolean leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      if(overseerDesignate.equals(OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()))){\n        log.info(\"overseer designate is the new overseer\");\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    assertTrue(\"could not set the new overseer . expected \"+\n        overseerDesignate + \" current order : \" +\n        getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) +\n        \" ldr :\"+ OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()) ,leaderchanged);\n\n\n\n    //add another node as overseer\n\n\n    l.remove(overseerDesignate);\n\n    Collections.shuffle(l);\n\n    String anotherOverseer = l.get(0);\n    log.info(\"Adding another overseer designate {}\", anotherOverseer);\n    setOverseerRole(CollectionAction.ADDROLE, anotherOverseer);\n\n    String currentOverseer = getLeaderNode(client.getZkStateReader().getZkClient());\n\n    log.info(\"Current Overseer {}\", currentOverseer);\n\n    String hostPort = currentOverseer.substring(0,currentOverseer.indexOf('_'));\n\n    StringBuilder sb = new StringBuilder();\n//\n//\n    log.info(\"hostPort : {}\", hostPort);\n\n    JettySolrRunner leaderJetty = null;\n\n    for (JettySolrRunner jetty : jettys) {\n      String s = jetty.getBaseUrl().toString();\n      log.info(\"jetTy {}\",s);\n      sb.append(s).append(\" , \");\n      if (s.contains(hostPort)) {\n        leaderJetty = jetty;\n        break;\n      }\n    }\n\n    assertNotNull(\"Could not find a jetty2 kill\",  leaderJetty);\n\n    log.info(\"leader node {}\", leaderJetty.getBaseUrl());\n    log.info (\"current election Queue\", OverseerCollectionProcessor.getSortedElectionNodes(client.getZkStateReader().getZkClient()));\n    ChaosMonkey.stop(leaderJetty);\n    timeout = System.currentTimeMillis() + 10000;\n    leaderchanged = false;\n    for (; System.currentTimeMillis() < timeout; ) {\n      currentOverseer = getLeaderNode(client.getZkStateReader().getZkClient());\n      if (anotherOverseer.equals(currentOverseer)) {\n        leaderchanged = true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    assertTrue(\"New overseer designate has not become the overseer, expected : \" + anotherOverseer + \"actual : \" + getLeaderNode(client.getZkStateReader().getZkClient()), leaderchanged);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5455c7b3fed6c1671990a44c19071cb0488c2c25","date":1413557414,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#testOverseerRole().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#testOverseerRole().mjava","sourceNew":"  private void testOverseerRole() throws Exception {\n    String collectionName = \"testOverseerCol\";\n\n    createCollection(collectionName, client);\n\n    waitForRecoveriesToFinish(collectionName, false);\n    List<String> l = OverseerCollectionProcessor.getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) ;\n\n    log.info(\"All nodes {}\", l);\n    String currentLeader = OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient());\n    log.info(\"Current leader {} \", currentLeader);\n    l.remove(currentLeader);\n\n    Collections.shuffle(l, random());\n    String overseerDesignate = l.get(0);\n    log.info(\"overseerDesignate {}\",overseerDesignate);\n    setOverseerRole(CollectionAction.ADDROLE,overseerDesignate);\n\n    long timeout = System.currentTimeMillis()+15000;\n\n    boolean leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      if(overseerDesignate.equals(OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()))){\n        log.info(\"overseer designate is the new overseer\");\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    assertTrue(\"could not set the new overseer . expected \"+\n        overseerDesignate + \" current order : \" +\n        getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) +\n        \" ldr :\"+ OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()) ,leaderchanged);\n\n\n\n    //add another node as overseer\n\n\n    l.remove(overseerDesignate);\n\n    Collections.shuffle(l, random());\n\n    String anotherOverseer = l.get(0);\n    log.info(\"Adding another overseer designate {}\", anotherOverseer);\n    setOverseerRole(CollectionAction.ADDROLE, anotherOverseer);\n\n    String currentOverseer = getLeaderNode(client.getZkStateReader().getZkClient());\n\n    log.info(\"Current Overseer {}\", currentOverseer);\n\n    String hostPort = currentOverseer.substring(0,currentOverseer.indexOf('_'));\n\n    StringBuilder sb = new StringBuilder();\n//\n//\n    log.info(\"hostPort : {}\", hostPort);\n\n    JettySolrRunner leaderJetty = null;\n\n    for (JettySolrRunner jetty : jettys) {\n      String s = jetty.getBaseUrl().toString();\n      log.info(\"jetTy {}\",s);\n      sb.append(s).append(\" , \");\n      if (s.contains(hostPort)) {\n        leaderJetty = jetty;\n        break;\n      }\n    }\n\n    assertNotNull(\"Could not find a jetty2 kill\",  leaderJetty);\n\n    log.info(\"leader node {}\", leaderJetty.getBaseUrl());\n    log.info (\"current election Queue\",\n        OverseerCollectionProcessor.getSortedElectionNodes(client.getZkStateReader().getZkClient(),\n            OverseerElectionContext.PATH + LeaderElector.ELECTION_NODE));\n    ChaosMonkey.stop(leaderJetty);\n    timeout = System.currentTimeMillis() + 10000;\n    leaderchanged = false;\n    for (; System.currentTimeMillis() < timeout; ) {\n      currentOverseer = getLeaderNode(client.getZkStateReader().getZkClient());\n      if (anotherOverseer.equals(currentOverseer)) {\n        leaderchanged = true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    assertTrue(\"New overseer designate has not become the overseer, expected : \" + anotherOverseer + \"actual : \" + getLeaderNode(client.getZkStateReader().getZkClient()), leaderchanged);\n  }\n\n","sourceOld":"  private void testOverseerRole() throws Exception {\n    String collectionName = \"testOverseerCol\";\n\n    createCollection(collectionName, client);\n\n    waitForRecoveriesToFinish(collectionName, false);\n    List<String> l = OverseerCollectionProcessor.getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) ;\n\n    log.info(\"All nodes {}\", l);\n    String currentLeader = OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient());\n    log.info(\"Current leader {} \", currentLeader);\n    l.remove(currentLeader);\n\n    Collections.shuffle(l, random());\n    String overseerDesignate = l.get(0);\n    log.info(\"overseerDesignate {}\",overseerDesignate);\n    setOverseerRole(CollectionAction.ADDROLE,overseerDesignate);\n\n    long timeout = System.currentTimeMillis()+15000;\n\n    boolean leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      if(overseerDesignate.equals(OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()))){\n        log.info(\"overseer designate is the new overseer\");\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    assertTrue(\"could not set the new overseer . expected \"+\n        overseerDesignate + \" current order : \" +\n        getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) +\n        \" ldr :\"+ OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()) ,leaderchanged);\n\n\n\n    //add another node as overseer\n\n\n    l.remove(overseerDesignate);\n\n    Collections.shuffle(l, random());\n\n    String anotherOverseer = l.get(0);\n    log.info(\"Adding another overseer designate {}\", anotherOverseer);\n    setOverseerRole(CollectionAction.ADDROLE, anotherOverseer);\n\n    String currentOverseer = getLeaderNode(client.getZkStateReader().getZkClient());\n\n    log.info(\"Current Overseer {}\", currentOverseer);\n\n    String hostPort = currentOverseer.substring(0,currentOverseer.indexOf('_'));\n\n    StringBuilder sb = new StringBuilder();\n//\n//\n    log.info(\"hostPort : {}\", hostPort);\n\n    JettySolrRunner leaderJetty = null;\n\n    for (JettySolrRunner jetty : jettys) {\n      String s = jetty.getBaseUrl().toString();\n      log.info(\"jetTy {}\",s);\n      sb.append(s).append(\" , \");\n      if (s.contains(hostPort)) {\n        leaderJetty = jetty;\n        break;\n      }\n    }\n\n    assertNotNull(\"Could not find a jetty2 kill\",  leaderJetty);\n\n    log.info(\"leader node {}\", leaderJetty.getBaseUrl());\n    log.info (\"current election Queue\", OverseerCollectionProcessor.getSortedElectionNodes(client.getZkStateReader().getZkClient()));\n    ChaosMonkey.stop(leaderJetty);\n    timeout = System.currentTimeMillis() + 10000;\n    leaderchanged = false;\n    for (; System.currentTimeMillis() < timeout; ) {\n      currentOverseer = getLeaderNode(client.getZkStateReader().getZkClient());\n      if (anotherOverseer.equals(currentOverseer)) {\n        leaderchanged = true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    assertTrue(\"New overseer designate has not become the overseer, expected : \" + anotherOverseer + \"actual : \" + getLeaderNode(client.getZkStateReader().getZkClient()), leaderchanged);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a22eafe3f72a4c2945eaad9547e6c78816978f4","date":1413956657,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#testOverseerRole().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#testOverseerRole().mjava","sourceNew":"  private void testOverseerRole() throws Exception {\n    String collectionName = \"testOverseerCol\";\n\n    createCollection(collectionName, client);\n\n    waitForRecoveriesToFinish(collectionName, false);\n    List<String> l = OverseerCollectionProcessor.getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) ;\n\n    log.info(\"All nodes {}\", l);\n    String currentLeader = OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient());\n    log.info(\"Current leader {} \", currentLeader);\n    l.remove(currentLeader);\n\n    Collections.shuffle(l, random());\n    String overseerDesignate = l.get(0);\n    log.info(\"overseerDesignate {}\",overseerDesignate);\n    setOverseerRole(CollectionAction.ADDROLE,overseerDesignate);\n\n    long timeout = System.currentTimeMillis()+15000;\n\n    boolean leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      if(overseerDesignate.equals(OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()))){\n        log.info(\"overseer designate is the new overseer\");\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    assertTrue(\"could not set the new overseer . expected \"+\n        overseerDesignate + \" current order : \" +\n        getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) +\n        \" ldr :\"+ OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()) ,leaderchanged);\n\n\n\n    //add another node as overseer\n\n\n    l.remove(overseerDesignate);\n\n    Collections.shuffle(l, random());\n\n    String anotherOverseer = l.get(0);\n    log.info(\"Adding another overseer designate {}\", anotherOverseer);\n    setOverseerRole(CollectionAction.ADDROLE, anotherOverseer);\n\n    String currentOverseer = getLeaderNode(client.getZkStateReader().getZkClient());\n\n    log.info(\"Current Overseer {}\", currentOverseer);\n\n    String hostPort = currentOverseer.substring(0,currentOverseer.indexOf('_'));\n\n    StringBuilder sb = new StringBuilder();\n//\n//\n    log.info(\"hostPort : {}\", hostPort);\n\n    JettySolrRunner leaderJetty = null;\n\n    for (JettySolrRunner jetty : jettys) {\n      String s = jetty.getBaseUrl().toString();\n      log.info(\"jetTy {}\",s);\n      sb.append(s).append(\" , \");\n      if (s.contains(hostPort)) {\n        leaderJetty = jetty;\n        break;\n      }\n    }\n\n    assertNotNull(\"Could not find a jetty2 kill\",  leaderJetty);\n\n    log.info(\"leader node {}\", leaderJetty.getBaseUrl());\n    log.info (\"current election Queue\",\n        OverseerCollectionProcessor.getSortedElectionNodes(client.getZkStateReader().getZkClient(),\n            OverseerElectionContext.PATH + LeaderElector.ELECTION_NODE));\n    ChaosMonkey.stop(leaderJetty);\n    timeout = System.currentTimeMillis() + 10000;\n    leaderchanged = false;\n    for (; System.currentTimeMillis() < timeout; ) {\n      currentOverseer = getLeaderNode(client.getZkStateReader().getZkClient());\n      if (anotherOverseer.equals(currentOverseer)) {\n        leaderchanged = true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    assertTrue(\"New overseer designate has not become the overseer, expected : \" + anotherOverseer + \"actual : \" + getLeaderNode(client.getZkStateReader().getZkClient()), leaderchanged);\n  }\n\n","sourceOld":"  private void testOverseerRole() throws Exception {\n    String collectionName = \"testOverseerCol\";\n\n    createCollection(collectionName, client);\n\n    waitForRecoveriesToFinish(collectionName, false);\n    List<String> l = OverseerCollectionProcessor.getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) ;\n\n    log.info(\"All nodes {}\", l);\n    String currentLeader = OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient());\n    log.info(\"Current leader {} \", currentLeader);\n    l.remove(currentLeader);\n\n    Collections.shuffle(l, random());\n    String overseerDesignate = l.get(0);\n    log.info(\"overseerDesignate {}\",overseerDesignate);\n    setOverseerRole(CollectionAction.ADDROLE,overseerDesignate);\n\n    long timeout = System.currentTimeMillis()+15000;\n\n    boolean leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      if(overseerDesignate.equals(OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()))){\n        log.info(\"overseer designate is the new overseer\");\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    assertTrue(\"could not set the new overseer . expected \"+\n        overseerDesignate + \" current order : \" +\n        getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) +\n        \" ldr :\"+ OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()) ,leaderchanged);\n\n\n\n    //add another node as overseer\n\n\n    l.remove(overseerDesignate);\n\n    Collections.shuffle(l, random());\n\n    String anotherOverseer = l.get(0);\n    log.info(\"Adding another overseer designate {}\", anotherOverseer);\n    setOverseerRole(CollectionAction.ADDROLE, anotherOverseer);\n\n    String currentOverseer = getLeaderNode(client.getZkStateReader().getZkClient());\n\n    log.info(\"Current Overseer {}\", currentOverseer);\n\n    String hostPort = currentOverseer.substring(0,currentOverseer.indexOf('_'));\n\n    StringBuilder sb = new StringBuilder();\n//\n//\n    log.info(\"hostPort : {}\", hostPort);\n\n    JettySolrRunner leaderJetty = null;\n\n    for (JettySolrRunner jetty : jettys) {\n      String s = jetty.getBaseUrl().toString();\n      log.info(\"jetTy {}\",s);\n      sb.append(s).append(\" , \");\n      if (s.contains(hostPort)) {\n        leaderJetty = jetty;\n        break;\n      }\n    }\n\n    assertNotNull(\"Could not find a jetty2 kill\",  leaderJetty);\n\n    log.info(\"leader node {}\", leaderJetty.getBaseUrl());\n    log.info (\"current election Queue\", OverseerCollectionProcessor.getSortedElectionNodes(client.getZkStateReader().getZkClient()));\n    ChaosMonkey.stop(leaderJetty);\n    timeout = System.currentTimeMillis() + 10000;\n    leaderchanged = false;\n    for (; System.currentTimeMillis() < timeout; ) {\n      currentOverseer = getLeaderNode(client.getZkStateReader().getZkClient());\n      if (anotherOverseer.equals(currentOverseer)) {\n        leaderchanged = true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    assertTrue(\"New overseer designate has not become the overseer, expected : \" + anotherOverseer + \"actual : \" + getLeaderNode(client.getZkStateReader().getZkClient()), leaderchanged);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2bf454e5dea7bb5bcf27f8332ded09afcc4b6a1b","date":1432801743,"type":5,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#testOverseerRole(CloudSolrClient).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#testOverseerRole().mjava","sourceNew":"  private void testOverseerRole(CloudSolrClient client) throws Exception {\n    String collectionName = \"testOverseerCol\";\n\n    createCollection(collectionName, client);\n\n    waitForRecoveriesToFinish(collectionName, false);\n    List<String> l = OverseerCollectionProcessor.getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) ;\n\n    log.info(\"All nodes {}\", l);\n    String currentLeader = OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient());\n    log.info(\"Current leader {} \", currentLeader);\n    l.remove(currentLeader);\n\n    Collections.shuffle(l, random());\n    String overseerDesignate = l.get(0);\n    log.info(\"overseerDesignate {}\",overseerDesignate);\n    setOverseerRole(client, CollectionAction.ADDROLE,overseerDesignate);\n\n    long timeout = System.currentTimeMillis()+15000;\n\n    boolean leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      if(overseerDesignate.equals(OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()))){\n        log.info(\"overseer designate is the new overseer\");\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    assertTrue(\"could not set the new overseer . expected \"+\n        overseerDesignate + \" current order : \" +\n        getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) +\n        \" ldr :\"+ OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()) ,leaderchanged);\n\n\n\n    //add another node as overseer\n\n\n    l.remove(overseerDesignate);\n\n    Collections.shuffle(l, random());\n\n    String anotherOverseer = l.get(0);\n    log.info(\"Adding another overseer designate {}\", anotherOverseer);\n    setOverseerRole(client, CollectionAction.ADDROLE, anotherOverseer);\n\n    String currentOverseer = getLeaderNode(client.getZkStateReader().getZkClient());\n\n    log.info(\"Current Overseer {}\", currentOverseer);\n\n    String hostPort = currentOverseer.substring(0,currentOverseer.indexOf('_'));\n\n    StringBuilder sb = new StringBuilder();\n//\n//\n    log.info(\"hostPort : {}\", hostPort);\n\n    JettySolrRunner leaderJetty = null;\n\n    for (JettySolrRunner jetty : jettys) {\n      String s = jetty.getBaseUrl().toString();\n      log.info(\"jetTy {}\",s);\n      sb.append(s).append(\" , \");\n      if (s.contains(hostPort)) {\n        leaderJetty = jetty;\n        break;\n      }\n    }\n\n    assertNotNull(\"Could not find a jetty2 kill\",  leaderJetty);\n\n    log.info(\"leader node {}\", leaderJetty.getBaseUrl());\n    log.info (\"current election Queue\",\n        OverseerCollectionProcessor.getSortedElectionNodes(client.getZkStateReader().getZkClient(),\n            OverseerElectionContext.PATH + LeaderElector.ELECTION_NODE));\n    ChaosMonkey.stop(leaderJetty);\n    timeout = System.currentTimeMillis() + 10000;\n    leaderchanged = false;\n    for (; System.currentTimeMillis() < timeout; ) {\n      currentOverseer = getLeaderNode(client.getZkStateReader().getZkClient());\n      if (anotherOverseer.equals(currentOverseer)) {\n        leaderchanged = true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    assertTrue(\"New overseer designate has not become the overseer, expected : \" + anotherOverseer + \"actual : \" + getLeaderNode(client.getZkStateReader().getZkClient()), leaderchanged);\n  }\n\n","sourceOld":"  private void testOverseerRole() throws Exception {\n    String collectionName = \"testOverseerCol\";\n\n    createCollection(collectionName, client);\n\n    waitForRecoveriesToFinish(collectionName, false);\n    List<String> l = OverseerCollectionProcessor.getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) ;\n\n    log.info(\"All nodes {}\", l);\n    String currentLeader = OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient());\n    log.info(\"Current leader {} \", currentLeader);\n    l.remove(currentLeader);\n\n    Collections.shuffle(l, random());\n    String overseerDesignate = l.get(0);\n    log.info(\"overseerDesignate {}\",overseerDesignate);\n    setOverseerRole(CollectionAction.ADDROLE,overseerDesignate);\n\n    long timeout = System.currentTimeMillis()+15000;\n\n    boolean leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      if(overseerDesignate.equals(OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()))){\n        log.info(\"overseer designate is the new overseer\");\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    assertTrue(\"could not set the new overseer . expected \"+\n        overseerDesignate + \" current order : \" +\n        getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) +\n        \" ldr :\"+ OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()) ,leaderchanged);\n\n\n\n    //add another node as overseer\n\n\n    l.remove(overseerDesignate);\n\n    Collections.shuffle(l, random());\n\n    String anotherOverseer = l.get(0);\n    log.info(\"Adding another overseer designate {}\", anotherOverseer);\n    setOverseerRole(CollectionAction.ADDROLE, anotherOverseer);\n\n    String currentOverseer = getLeaderNode(client.getZkStateReader().getZkClient());\n\n    log.info(\"Current Overseer {}\", currentOverseer);\n\n    String hostPort = currentOverseer.substring(0,currentOverseer.indexOf('_'));\n\n    StringBuilder sb = new StringBuilder();\n//\n//\n    log.info(\"hostPort : {}\", hostPort);\n\n    JettySolrRunner leaderJetty = null;\n\n    for (JettySolrRunner jetty : jettys) {\n      String s = jetty.getBaseUrl().toString();\n      log.info(\"jetTy {}\",s);\n      sb.append(s).append(\" , \");\n      if (s.contains(hostPort)) {\n        leaderJetty = jetty;\n        break;\n      }\n    }\n\n    assertNotNull(\"Could not find a jetty2 kill\",  leaderJetty);\n\n    log.info(\"leader node {}\", leaderJetty.getBaseUrl());\n    log.info (\"current election Queue\",\n        OverseerCollectionProcessor.getSortedElectionNodes(client.getZkStateReader().getZkClient(),\n            OverseerElectionContext.PATH + LeaderElector.ELECTION_NODE));\n    ChaosMonkey.stop(leaderJetty);\n    timeout = System.currentTimeMillis() + 10000;\n    leaderchanged = false;\n    for (; System.currentTimeMillis() < timeout; ) {\n      currentOverseer = getLeaderNode(client.getZkStateReader().getZkClient());\n      if (anotherOverseer.equals(currentOverseer)) {\n        leaderchanged = true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    assertTrue(\"New overseer designate has not become the overseer, expected : \" + anotherOverseer + \"actual : \" + getLeaderNode(client.getZkStateReader().getZkClient()), leaderchanged);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"636a04bc82e662bf141a55f1d10f52e1c76c727b","date":1483014160,"type":1,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#testOverseerRole().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#testOverseerRole(CloudSolrClient).mjava","sourceNew":"  @Test\n  public void testOverseerRole() throws Exception {\n\n    List<String> l = OverseerCollectionConfigSetProcessor.getSortedOverseerNodeNames(zkClient()) ;\n\n    log.info(\"All nodes {}\", l);\n    String currentLeader = OverseerCollectionConfigSetProcessor.getLeaderNode(zkClient());\n    log.info(\"Current leader {} \", currentLeader);\n    l.remove(currentLeader);\n\n    Collections.shuffle(l, random());\n    String overseerDesignate = l.get(0);\n    log.info(\"overseerDesignate {}\", overseerDesignate);\n\n    CollectionAdminRequest.addRole(overseerDesignate, \"overseer\").process(cluster.getSolrClient());\n\n    TimeOut timeout = new TimeOut(15, TimeUnit.SECONDS);\n\n    boolean leaderchanged = false;\n    for (;!timeout.hasTimedOut();) {\n      if (overseerDesignate.equals(OverseerCollectionConfigSetProcessor.getLeaderNode(zkClient()))) {\n        log.info(\"overseer designate is the new overseer\");\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    assertTrue(\"could not set the new overseer . expected \"+\n        overseerDesignate + \" current order : \" +\n        getSortedOverseerNodeNames(zkClient()) +\n        \" ldr :\"+ OverseerCollectionConfigSetProcessor.getLeaderNode(zkClient()) ,leaderchanged);\n\n    //add another node as overseer\n    l.remove(overseerDesignate);\n    Collections.shuffle(l, random());\n\n    String anotherOverseer = l.get(0);\n    log.info(\"Adding another overseer designate {}\", anotherOverseer);\n    CollectionAdminRequest.addRole(anotherOverseer, \"overseer\").process(cluster.getSolrClient());\n\n    String currentOverseer = getLeaderNode(zkClient());\n\n    log.info(\"Current Overseer {}\", currentOverseer);\n\n    String hostPort = currentOverseer.substring(0, currentOverseer.indexOf('_'));\n\n    StringBuilder sb = new StringBuilder();\n    log.info(\"hostPort : {}\", hostPort);\n\n    JettySolrRunner leaderJetty = null;\n\n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      String s = jetty.getBaseUrl().toString();\n      log.info(\"jetTy {}\",s);\n      sb.append(s).append(\" , \");\n      if (s.contains(hostPort)) {\n        leaderJetty = jetty;\n        break;\n      }\n    }\n\n    assertNotNull(\"Could not find a jetty2 kill\",  leaderJetty);\n\n    log.info(\"leader node {}\", leaderJetty.getBaseUrl());\n    log.info(\"current election Queue\",\n        OverseerCollectionConfigSetProcessor.getSortedElectionNodes(zkClient(), \"/overseer_elect/election\"));\n    ChaosMonkey.stop(leaderJetty);\n    timeout = new TimeOut(10, TimeUnit.SECONDS);\n    leaderchanged = false;\n    for (; !timeout.hasTimedOut(); ) {\n      currentOverseer = getLeaderNode(zkClient());\n      if (anotherOverseer.equals(currentOverseer)) {\n        leaderchanged = true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    assertTrue(\"New overseer designate has not become the overseer, expected : \" + anotherOverseer + \"actual : \" + getLeaderNode(zkClient()), leaderchanged);\n  }\n\n","sourceOld":"  private void testOverseerRole(CloudSolrClient client) throws Exception {\n    String collectionName = \"testOverseerCol\";\n\n    createCollection(collectionName, client);\n\n    waitForRecoveriesToFinish(collectionName, false);\n    List<String> l = OverseerCollectionConfigSetProcessor.getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) ;\n\n    log.info(\"All nodes {}\", l);\n    String currentLeader = OverseerCollectionConfigSetProcessor.getLeaderNode(client.getZkStateReader().getZkClient());\n    log.info(\"Current leader {} \", currentLeader);\n    l.remove(currentLeader);\n\n    Collections.shuffle(l, random());\n    String overseerDesignate = l.get(0);\n    log.info(\"overseerDesignate {}\",overseerDesignate);\n    setOverseerRole(client, CollectionAction.ADDROLE,overseerDesignate);\n\n    TimeOut timeout = new TimeOut(15, TimeUnit.SECONDS);\n\n    boolean leaderchanged = false;\n    for(;!timeout.hasTimedOut();){\n      if(overseerDesignate.equals(OverseerCollectionConfigSetProcessor.getLeaderNode(client.getZkStateReader().getZkClient()))){\n        log.info(\"overseer designate is the new overseer\");\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    assertTrue(\"could not set the new overseer . expected \"+\n        overseerDesignate + \" current order : \" +\n        getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) +\n        \" ldr :\"+ OverseerCollectionConfigSetProcessor.getLeaderNode(client.getZkStateReader().getZkClient()) ,leaderchanged);\n\n\n\n    //add another node as overseer\n\n\n    l.remove(overseerDesignate);\n\n    Collections.shuffle(l, random());\n\n    String anotherOverseer = l.get(0);\n    log.info(\"Adding another overseer designate {}\", anotherOverseer);\n    setOverseerRole(client, CollectionAction.ADDROLE, anotherOverseer);\n\n    String currentOverseer = getLeaderNode(client.getZkStateReader().getZkClient());\n\n    log.info(\"Current Overseer {}\", currentOverseer);\n\n    String hostPort = currentOverseer.substring(0,currentOverseer.indexOf('_'));\n\n    StringBuilder sb = new StringBuilder();\n//\n//\n    log.info(\"hostPort : {}\", hostPort);\n\n    JettySolrRunner leaderJetty = null;\n\n    for (JettySolrRunner jetty : jettys) {\n      String s = jetty.getBaseUrl().toString();\n      log.info(\"jetTy {}\",s);\n      sb.append(s).append(\" , \");\n      if (s.contains(hostPort)) {\n        leaderJetty = jetty;\n        break;\n      }\n    }\n\n    assertNotNull(\"Could not find a jetty2 kill\",  leaderJetty);\n\n    log.info(\"leader node {}\", leaderJetty.getBaseUrl());\n    log.info (\"current election Queue\",\n        OverseerCollectionConfigSetProcessor.getSortedElectionNodes(client.getZkStateReader().getZkClient(),\n            \"/overseer_elect/election\"));\n    ChaosMonkey.stop(leaderJetty);\n    timeout = new TimeOut(10, TimeUnit.SECONDS);\n    leaderchanged = false;\n    for (; !timeout.hasTimedOut(); ) {\n      currentOverseer = getLeaderNode(client.getZkStateReader().getZkClient());\n      if (anotherOverseer.equals(currentOverseer)) {\n        leaderchanged = true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    assertTrue(\"New overseer designate has not become the overseer, expected : \" + anotherOverseer + \"actual : \" + getLeaderNode(client.getZkStateReader().getZkClient()), leaderchanged);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f03e4bed5023ec3ef93a771b8888cae991cf448d","date":1483469262,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#testOverseerRole().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testOverseerRole() throws Exception {\n\n    List<String> l = OverseerCollectionConfigSetProcessor.getSortedOverseerNodeNames(zkClient()) ;\n\n    log.info(\"All nodes {}\", l);\n    String currentLeader = OverseerCollectionConfigSetProcessor.getLeaderNode(zkClient());\n    log.info(\"Current leader {} \", currentLeader);\n    l.remove(currentLeader);\n\n    Collections.shuffle(l, random());\n    String overseerDesignate = l.get(0);\n    log.info(\"overseerDesignate {}\", overseerDesignate);\n\n    CollectionAdminRequest.addRole(overseerDesignate, \"overseer\").process(cluster.getSolrClient());\n\n    TimeOut timeout = new TimeOut(15, TimeUnit.SECONDS);\n\n    boolean leaderchanged = false;\n    for (;!timeout.hasTimedOut();) {\n      if (overseerDesignate.equals(OverseerCollectionConfigSetProcessor.getLeaderNode(zkClient()))) {\n        log.info(\"overseer designate is the new overseer\");\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    assertTrue(\"could not set the new overseer . expected \"+\n        overseerDesignate + \" current order : \" +\n        getSortedOverseerNodeNames(zkClient()) +\n        \" ldr :\"+ OverseerCollectionConfigSetProcessor.getLeaderNode(zkClient()) ,leaderchanged);\n\n    //add another node as overseer\n    l.remove(overseerDesignate);\n    Collections.shuffle(l, random());\n\n    String anotherOverseer = l.get(0);\n    log.info(\"Adding another overseer designate {}\", anotherOverseer);\n    CollectionAdminRequest.addRole(anotherOverseer, \"overseer\").process(cluster.getSolrClient());\n\n    String currentOverseer = getLeaderNode(zkClient());\n\n    log.info(\"Current Overseer {}\", currentOverseer);\n\n    String hostPort = currentOverseer.substring(0, currentOverseer.indexOf('_'));\n\n    StringBuilder sb = new StringBuilder();\n    log.info(\"hostPort : {}\", hostPort);\n\n    JettySolrRunner leaderJetty = null;\n\n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      String s = jetty.getBaseUrl().toString();\n      log.info(\"jetTy {}\",s);\n      sb.append(s).append(\" , \");\n      if (s.contains(hostPort)) {\n        leaderJetty = jetty;\n        break;\n      }\n    }\n\n    assertNotNull(\"Could not find a jetty2 kill\",  leaderJetty);\n\n    log.info(\"leader node {}\", leaderJetty.getBaseUrl());\n    log.info(\"current election Queue\",\n        OverseerCollectionConfigSetProcessor.getSortedElectionNodes(zkClient(), \"/overseer_elect/election\"));\n    ChaosMonkey.stop(leaderJetty);\n    timeout = new TimeOut(10, TimeUnit.SECONDS);\n    leaderchanged = false;\n    for (; !timeout.hasTimedOut(); ) {\n      currentOverseer = getLeaderNode(zkClient());\n      if (anotherOverseer.equals(currentOverseer)) {\n        leaderchanged = true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    assertTrue(\"New overseer designate has not become the overseer, expected : \" + anotherOverseer + \"actual : \" + getLeaderNode(zkClient()), leaderchanged);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"42d6fc6d08217c412f5a576929068b6e678deaf6","date":1484847963,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#testOverseerRole().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#testOverseerRole().mjava","sourceNew":"  @Test\n  public void testOverseerRole() throws Exception {\n\n    logOverseerState();\n    List<String> nodes = OverseerCollectionConfigSetProcessor.getSortedOverseerNodeNames(zkClient());\n    String overseer1 = OverseerCollectionConfigSetProcessor.getLeaderNode(zkClient());\n    nodes.remove(overseer1);\n\n    Collections.shuffle(nodes, random());\n    String overseer2 = nodes.get(0);\n    log.info(\"### Setting overseer designate {}\", overseer2);\n\n    CollectionAdminRequest.addRole(overseer2, \"overseer\").process(cluster.getSolrClient());\n\n    waitForNewOverseer(15, overseer2);\n\n    //add another node as overseer\n    nodes.remove(overseer2);\n    Collections.shuffle(nodes, random());\n\n    String overseer3 = nodes.get(0);\n    log.info(\"### Adding another overseer designate {}\", overseer3);\n    CollectionAdminRequest.addRole(overseer3, \"overseer\").process(cluster.getSolrClient());\n\n    // kill the current overseer, and check that the new designate becomes the new overseer\n    JettySolrRunner leaderJetty = getOverseerJetty();\n    logOverseerState();\n\n    ChaosMonkey.stop(leaderJetty);\n    waitForNewOverseer(10, overseer3);\n\n    // add another node as overseer\n    nodes.remove(overseer3);\n    Collections.shuffle(nodes, random());\n    String overseer4 = nodes.get(0);\n    log.info(\"### Adding last overseer designate {}\", overseer4);\n    CollectionAdminRequest.addRole(overseer4, \"overseer\").process(cluster.getSolrClient());\n    logOverseerState();\n\n    // remove the overseer role from the current overseer\n    CollectionAdminRequest.removeRole(overseer3, \"overseer\").process(cluster.getSolrClient());\n    waitForNewOverseer(15, overseer4);\n\n    // Add it back again - we now have two delegates, 4 and 3\n    CollectionAdminRequest.addRole(overseer3, \"overseer\").process(cluster.getSolrClient());\n\n    // explicitly tell the overseer to quit\n    String leaderId = OverseerCollectionConfigSetProcessor.getLeaderId(zkClient());\n    String leader = OverseerCollectionConfigSetProcessor.getLeaderNode(zkClient());\n    log.info(\"### Sending QUIT to overseer {}\", leader);\n    Overseer.getStateUpdateQueue(zkClient())\n        .offer(Utils.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.QUIT.toLower(),\n            \"id\", leaderId)));\n\n    waitForNewOverseer(10, s -> Objects.equals(leader, s) == false);\n\n    logOverseerState();\n    assertTrue(\"The old leader should have rejoined election\",\n        OverseerCollectionConfigSetProcessor.getSortedOverseerNodeNames(zkClient()).contains(leader));\n\n  }\n\n","sourceOld":"  @Test\n  public void testOverseerRole() throws Exception {\n\n    List<String> l = OverseerCollectionConfigSetProcessor.getSortedOverseerNodeNames(zkClient()) ;\n\n    log.info(\"All nodes {}\", l);\n    String currentLeader = OverseerCollectionConfigSetProcessor.getLeaderNode(zkClient());\n    log.info(\"Current leader {} \", currentLeader);\n    l.remove(currentLeader);\n\n    Collections.shuffle(l, random());\n    String overseerDesignate = l.get(0);\n    log.info(\"overseerDesignate {}\", overseerDesignate);\n\n    CollectionAdminRequest.addRole(overseerDesignate, \"overseer\").process(cluster.getSolrClient());\n\n    TimeOut timeout = new TimeOut(15, TimeUnit.SECONDS);\n\n    boolean leaderchanged = false;\n    for (;!timeout.hasTimedOut();) {\n      if (overseerDesignate.equals(OverseerCollectionConfigSetProcessor.getLeaderNode(zkClient()))) {\n        log.info(\"overseer designate is the new overseer\");\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    assertTrue(\"could not set the new overseer . expected \"+\n        overseerDesignate + \" current order : \" +\n        getSortedOverseerNodeNames(zkClient()) +\n        \" ldr :\"+ OverseerCollectionConfigSetProcessor.getLeaderNode(zkClient()) ,leaderchanged);\n\n    //add another node as overseer\n    l.remove(overseerDesignate);\n    Collections.shuffle(l, random());\n\n    String anotherOverseer = l.get(0);\n    log.info(\"Adding another overseer designate {}\", anotherOverseer);\n    CollectionAdminRequest.addRole(anotherOverseer, \"overseer\").process(cluster.getSolrClient());\n\n    String currentOverseer = getLeaderNode(zkClient());\n\n    log.info(\"Current Overseer {}\", currentOverseer);\n\n    String hostPort = currentOverseer.substring(0, currentOverseer.indexOf('_'));\n\n    StringBuilder sb = new StringBuilder();\n    log.info(\"hostPort : {}\", hostPort);\n\n    JettySolrRunner leaderJetty = null;\n\n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      String s = jetty.getBaseUrl().toString();\n      log.info(\"jetTy {}\",s);\n      sb.append(s).append(\" , \");\n      if (s.contains(hostPort)) {\n        leaderJetty = jetty;\n        break;\n      }\n    }\n\n    assertNotNull(\"Could not find a jetty2 kill\",  leaderJetty);\n\n    log.info(\"leader node {}\", leaderJetty.getBaseUrl());\n    log.info(\"current election Queue\",\n        OverseerCollectionConfigSetProcessor.getSortedElectionNodes(zkClient(), \"/overseer_elect/election\"));\n    ChaosMonkey.stop(leaderJetty);\n    timeout = new TimeOut(10, TimeUnit.SECONDS);\n    leaderchanged = false;\n    for (; !timeout.hasTimedOut(); ) {\n      currentOverseer = getLeaderNode(zkClient());\n      if (anotherOverseer.equals(currentOverseer)) {\n        leaderchanged = true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    assertTrue(\"New overseer designate has not become the overseer, expected : \" + anotherOverseer + \"actual : \" + getLeaderNode(zkClient()), leaderchanged);\n  }\n\n","bugFix":["636a04bc82e662bf141a55f1d10f52e1c76c727b"],"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"90a682dc1bfd188ef61cc28373c7f5d700b4ac75","date":1485186128,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#testOverseerRole().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#testOverseerRole().mjava","sourceNew":"  @Test\n  public void testOverseerRole() throws Exception {\n\n    logOverseerState();\n    List<String> nodes = OverseerCollectionConfigSetProcessor.getSortedOverseerNodeNames(zkClient());\n    String overseer1 = OverseerCollectionConfigSetProcessor.getLeaderNode(zkClient());\n    nodes.remove(overseer1);\n\n    Collections.shuffle(nodes, random());\n    String overseer2 = nodes.get(0);\n    log.info(\"### Setting overseer designate {}\", overseer2);\n\n    CollectionAdminRequest.addRole(overseer2, \"overseer\").process(cluster.getSolrClient());\n\n    waitForNewOverseer(15, overseer2);\n\n    //add another node as overseer\n    nodes.remove(overseer2);\n    Collections.shuffle(nodes, random());\n\n    String overseer3 = nodes.get(0);\n    log.info(\"### Adding another overseer designate {}\", overseer3);\n    CollectionAdminRequest.addRole(overseer3, \"overseer\").process(cluster.getSolrClient());\n\n    // kill the current overseer, and check that the new designate becomes the new overseer\n    JettySolrRunner leaderJetty = getOverseerJetty();\n    logOverseerState();\n\n    ChaosMonkey.stop(leaderJetty);\n    waitForNewOverseer(10, overseer3);\n\n    // add another node as overseer\n    nodes.remove(overseer3);\n    Collections.shuffle(nodes, random());\n    String overseer4 = nodes.get(0);\n    log.info(\"### Adding last overseer designate {}\", overseer4);\n    CollectionAdminRequest.addRole(overseer4, \"overseer\").process(cluster.getSolrClient());\n    logOverseerState();\n\n    // remove the overseer role from the current overseer\n    CollectionAdminRequest.removeRole(overseer3, \"overseer\").process(cluster.getSolrClient());\n    waitForNewOverseer(15, overseer4);\n\n    // Add it back again - we now have two delegates, 4 and 3\n    CollectionAdminRequest.addRole(overseer3, \"overseer\").process(cluster.getSolrClient());\n\n    // explicitly tell the overseer to quit\n    String leaderId = OverseerCollectionConfigSetProcessor.getLeaderId(zkClient());\n    String leader = OverseerCollectionConfigSetProcessor.getLeaderNode(zkClient());\n    log.info(\"### Sending QUIT to overseer {}\", leader);\n    Overseer.getStateUpdateQueue(zkClient())\n        .offer(Utils.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.QUIT.toLower(),\n            \"id\", leaderId)));\n\n    waitForNewOverseer(10, s -> Objects.equals(leader, s) == false);\n\n    logOverseerState();\n    assertTrue(\"The old leader should have rejoined election\",\n        OverseerCollectionConfigSetProcessor.getSortedOverseerNodeNames(zkClient()).contains(leader));\n\n  }\n\n","sourceOld":"  @Test\n  public void testOverseerRole() throws Exception {\n\n    List<String> l = OverseerCollectionConfigSetProcessor.getSortedOverseerNodeNames(zkClient()) ;\n\n    log.info(\"All nodes {}\", l);\n    String currentLeader = OverseerCollectionConfigSetProcessor.getLeaderNode(zkClient());\n    log.info(\"Current leader {} \", currentLeader);\n    l.remove(currentLeader);\n\n    Collections.shuffle(l, random());\n    String overseerDesignate = l.get(0);\n    log.info(\"overseerDesignate {}\", overseerDesignate);\n\n    CollectionAdminRequest.addRole(overseerDesignate, \"overseer\").process(cluster.getSolrClient());\n\n    TimeOut timeout = new TimeOut(15, TimeUnit.SECONDS);\n\n    boolean leaderchanged = false;\n    for (;!timeout.hasTimedOut();) {\n      if (overseerDesignate.equals(OverseerCollectionConfigSetProcessor.getLeaderNode(zkClient()))) {\n        log.info(\"overseer designate is the new overseer\");\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    assertTrue(\"could not set the new overseer . expected \"+\n        overseerDesignate + \" current order : \" +\n        getSortedOverseerNodeNames(zkClient()) +\n        \" ldr :\"+ OverseerCollectionConfigSetProcessor.getLeaderNode(zkClient()) ,leaderchanged);\n\n    //add another node as overseer\n    l.remove(overseerDesignate);\n    Collections.shuffle(l, random());\n\n    String anotherOverseer = l.get(0);\n    log.info(\"Adding another overseer designate {}\", anotherOverseer);\n    CollectionAdminRequest.addRole(anotherOverseer, \"overseer\").process(cluster.getSolrClient());\n\n    String currentOverseer = getLeaderNode(zkClient());\n\n    log.info(\"Current Overseer {}\", currentOverseer);\n\n    String hostPort = currentOverseer.substring(0, currentOverseer.indexOf('_'));\n\n    StringBuilder sb = new StringBuilder();\n    log.info(\"hostPort : {}\", hostPort);\n\n    JettySolrRunner leaderJetty = null;\n\n    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n      String s = jetty.getBaseUrl().toString();\n      log.info(\"jetTy {}\",s);\n      sb.append(s).append(\" , \");\n      if (s.contains(hostPort)) {\n        leaderJetty = jetty;\n        break;\n      }\n    }\n\n    assertNotNull(\"Could not find a jetty2 kill\",  leaderJetty);\n\n    log.info(\"leader node {}\", leaderJetty.getBaseUrl());\n    log.info(\"current election Queue\",\n        OverseerCollectionConfigSetProcessor.getSortedElectionNodes(zkClient(), \"/overseer_elect/election\"));\n    ChaosMonkey.stop(leaderJetty);\n    timeout = new TimeOut(10, TimeUnit.SECONDS);\n    leaderchanged = false;\n    for (; !timeout.hasTimedOut(); ) {\n      currentOverseer = getLeaderNode(zkClient());\n      if (anotherOverseer.equals(currentOverseer)) {\n        leaderchanged = true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    assertTrue(\"New overseer designate has not become the overseer, expected : \" + anotherOverseer + \"actual : \" + getLeaderNode(zkClient()), leaderchanged);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d75295502d9d3f7995ae901a065be971191fcf8f","date":1486939427,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#testOverseerRole().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#testOverseerRole().mjava","sourceNew":"  @Test\n  public void testOverseerRole() throws Exception {\n\n    logOverseerState();\n    List<String> nodes = OverseerCollectionConfigSetProcessor.getSortedOverseerNodeNames(zkClient());\n    String overseer1 = OverseerCollectionConfigSetProcessor.getLeaderNode(zkClient());\n    nodes.remove(overseer1);\n\n    Collections.shuffle(nodes, random());\n    String overseer2 = nodes.get(0);\n    log.info(\"### Setting overseer designate {}\", overseer2);\n\n    CollectionAdminRequest.addRole(overseer2, \"overseer\").process(cluster.getSolrClient());\n\n    waitForNewOverseer(15, overseer2);\n\n    //add another node as overseer\n    nodes.remove(overseer2);\n    Collections.shuffle(nodes, random());\n\n    String overseer3 = nodes.get(0);\n    log.info(\"### Adding another overseer designate {}\", overseer3);\n    CollectionAdminRequest.addRole(overseer3, \"overseer\").process(cluster.getSolrClient());\n\n    // kill the current overseer, and check that the new designate becomes the new overseer\n    JettySolrRunner leaderJetty = getOverseerJetty();\n    logOverseerState();\n\n    ChaosMonkey.stop(leaderJetty);\n    waitForNewOverseer(10, overseer3);\n\n    // add another node as overseer\n    nodes.remove(overseer3);\n    Collections.shuffle(nodes, random());\n    String overseer4 = nodes.get(0);\n    log.info(\"### Adding last overseer designate {}\", overseer4);\n    CollectionAdminRequest.addRole(overseer4, \"overseer\").process(cluster.getSolrClient());\n    logOverseerState();\n\n    // remove the overseer role from the current overseer\n    CollectionAdminRequest.removeRole(overseer3, \"overseer\").process(cluster.getSolrClient());\n    waitForNewOverseer(15, overseer4);\n\n    // Add it back again - we now have two delegates, 4 and 3\n    CollectionAdminRequest.addRole(overseer3, \"overseer\").process(cluster.getSolrClient());\n\n    // explicitly tell the overseer to quit\n    String leaderId = OverseerCollectionConfigSetProcessor.getLeaderId(zkClient());\n    String leader = OverseerCollectionConfigSetProcessor.getLeaderNode(zkClient());\n    log.info(\"### Sending QUIT to overseer {}\", leader);\n    Overseer.getStateUpdateQueue(zkClient())\n        .offer(Utils.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.QUIT.toLower(),\n            \"id\", leaderId)));\n\n    waitForNewOverseer(15, s -> Objects.equals(leader, s) == false);\n\n    Thread.sleep(1000);\n    \n    logOverseerState();\n    assertTrue(\"The old leader should have rejoined election\",\n        OverseerCollectionConfigSetProcessor.getSortedOverseerNodeNames(zkClient()).contains(leader));\n\n  }\n\n","sourceOld":"  @Test\n  public void testOverseerRole() throws Exception {\n\n    logOverseerState();\n    List<String> nodes = OverseerCollectionConfigSetProcessor.getSortedOverseerNodeNames(zkClient());\n    String overseer1 = OverseerCollectionConfigSetProcessor.getLeaderNode(zkClient());\n    nodes.remove(overseer1);\n\n    Collections.shuffle(nodes, random());\n    String overseer2 = nodes.get(0);\n    log.info(\"### Setting overseer designate {}\", overseer2);\n\n    CollectionAdminRequest.addRole(overseer2, \"overseer\").process(cluster.getSolrClient());\n\n    waitForNewOverseer(15, overseer2);\n\n    //add another node as overseer\n    nodes.remove(overseer2);\n    Collections.shuffle(nodes, random());\n\n    String overseer3 = nodes.get(0);\n    log.info(\"### Adding another overseer designate {}\", overseer3);\n    CollectionAdminRequest.addRole(overseer3, \"overseer\").process(cluster.getSolrClient());\n\n    // kill the current overseer, and check that the new designate becomes the new overseer\n    JettySolrRunner leaderJetty = getOverseerJetty();\n    logOverseerState();\n\n    ChaosMonkey.stop(leaderJetty);\n    waitForNewOverseer(10, overseer3);\n\n    // add another node as overseer\n    nodes.remove(overseer3);\n    Collections.shuffle(nodes, random());\n    String overseer4 = nodes.get(0);\n    log.info(\"### Adding last overseer designate {}\", overseer4);\n    CollectionAdminRequest.addRole(overseer4, \"overseer\").process(cluster.getSolrClient());\n    logOverseerState();\n\n    // remove the overseer role from the current overseer\n    CollectionAdminRequest.removeRole(overseer3, \"overseer\").process(cluster.getSolrClient());\n    waitForNewOverseer(15, overseer4);\n\n    // Add it back again - we now have two delegates, 4 and 3\n    CollectionAdminRequest.addRole(overseer3, \"overseer\").process(cluster.getSolrClient());\n\n    // explicitly tell the overseer to quit\n    String leaderId = OverseerCollectionConfigSetProcessor.getLeaderId(zkClient());\n    String leader = OverseerCollectionConfigSetProcessor.getLeaderNode(zkClient());\n    log.info(\"### Sending QUIT to overseer {}\", leader);\n    Overseer.getStateUpdateQueue(zkClient())\n        .offer(Utils.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.QUIT.toLower(),\n            \"id\", leaderId)));\n\n    waitForNewOverseer(10, s -> Objects.equals(leader, s) == false);\n\n    logOverseerState();\n    assertTrue(\"The old leader should have rejoined election\",\n        OverseerCollectionConfigSetProcessor.getSortedOverseerNodeNames(zkClient()).contains(leader));\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4bab9eeea60eefbea2957be27b8d1923095df771","date":1525498218,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#testOverseerRole().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#testOverseerRole().mjava","sourceNew":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 04-May-2018\n  public void testOverseerRole() throws Exception {\n\n    logOverseerState();\n    List<String> nodes = OverseerCollectionConfigSetProcessor.getSortedOverseerNodeNames(zkClient());\n    String overseer1 = OverseerCollectionConfigSetProcessor.getLeaderNode(zkClient());\n    nodes.remove(overseer1);\n\n    Collections.shuffle(nodes, random());\n    String overseer2 = nodes.get(0);\n    log.info(\"### Setting overseer designate {}\", overseer2);\n\n    CollectionAdminRequest.addRole(overseer2, \"overseer\").process(cluster.getSolrClient());\n\n    waitForNewOverseer(15, overseer2);\n\n    //add another node as overseer\n    nodes.remove(overseer2);\n    Collections.shuffle(nodes, random());\n\n    String overseer3 = nodes.get(0);\n    log.info(\"### Adding another overseer designate {}\", overseer3);\n    CollectionAdminRequest.addRole(overseer3, \"overseer\").process(cluster.getSolrClient());\n\n    // kill the current overseer, and check that the new designate becomes the new overseer\n    JettySolrRunner leaderJetty = getOverseerJetty();\n    logOverseerState();\n\n    ChaosMonkey.stop(leaderJetty);\n    waitForNewOverseer(10, overseer3);\n\n    // add another node as overseer\n    nodes.remove(overseer3);\n    Collections.shuffle(nodes, random());\n    String overseer4 = nodes.get(0);\n    log.info(\"### Adding last overseer designate {}\", overseer4);\n    CollectionAdminRequest.addRole(overseer4, \"overseer\").process(cluster.getSolrClient());\n    logOverseerState();\n\n    // remove the overseer role from the current overseer\n    CollectionAdminRequest.removeRole(overseer3, \"overseer\").process(cluster.getSolrClient());\n    waitForNewOverseer(15, overseer4);\n\n    // Add it back again - we now have two delegates, 4 and 3\n    CollectionAdminRequest.addRole(overseer3, \"overseer\").process(cluster.getSolrClient());\n\n    // explicitly tell the overseer to quit\n    String leaderId = OverseerCollectionConfigSetProcessor.getLeaderId(zkClient());\n    String leader = OverseerCollectionConfigSetProcessor.getLeaderNode(zkClient());\n    log.info(\"### Sending QUIT to overseer {}\", leader);\n    Overseer.getStateUpdateQueue(zkClient())\n        .offer(Utils.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.QUIT.toLower(),\n            \"id\", leaderId)));\n\n    waitForNewOverseer(15, s -> Objects.equals(leader, s) == false);\n\n    Thread.sleep(1000);\n    \n    logOverseerState();\n    assertTrue(\"The old leader should have rejoined election\",\n        OverseerCollectionConfigSetProcessor.getSortedOverseerNodeNames(zkClient()).contains(leader));\n\n  }\n\n","sourceOld":"  @Test\n  public void testOverseerRole() throws Exception {\n\n    logOverseerState();\n    List<String> nodes = OverseerCollectionConfigSetProcessor.getSortedOverseerNodeNames(zkClient());\n    String overseer1 = OverseerCollectionConfigSetProcessor.getLeaderNode(zkClient());\n    nodes.remove(overseer1);\n\n    Collections.shuffle(nodes, random());\n    String overseer2 = nodes.get(0);\n    log.info(\"### Setting overseer designate {}\", overseer2);\n\n    CollectionAdminRequest.addRole(overseer2, \"overseer\").process(cluster.getSolrClient());\n\n    waitForNewOverseer(15, overseer2);\n\n    //add another node as overseer\n    nodes.remove(overseer2);\n    Collections.shuffle(nodes, random());\n\n    String overseer3 = nodes.get(0);\n    log.info(\"### Adding another overseer designate {}\", overseer3);\n    CollectionAdminRequest.addRole(overseer3, \"overseer\").process(cluster.getSolrClient());\n\n    // kill the current overseer, and check that the new designate becomes the new overseer\n    JettySolrRunner leaderJetty = getOverseerJetty();\n    logOverseerState();\n\n    ChaosMonkey.stop(leaderJetty);\n    waitForNewOverseer(10, overseer3);\n\n    // add another node as overseer\n    nodes.remove(overseer3);\n    Collections.shuffle(nodes, random());\n    String overseer4 = nodes.get(0);\n    log.info(\"### Adding last overseer designate {}\", overseer4);\n    CollectionAdminRequest.addRole(overseer4, \"overseer\").process(cluster.getSolrClient());\n    logOverseerState();\n\n    // remove the overseer role from the current overseer\n    CollectionAdminRequest.removeRole(overseer3, \"overseer\").process(cluster.getSolrClient());\n    waitForNewOverseer(15, overseer4);\n\n    // Add it back again - we now have two delegates, 4 and 3\n    CollectionAdminRequest.addRole(overseer3, \"overseer\").process(cluster.getSolrClient());\n\n    // explicitly tell the overseer to quit\n    String leaderId = OverseerCollectionConfigSetProcessor.getLeaderId(zkClient());\n    String leader = OverseerCollectionConfigSetProcessor.getLeaderNode(zkClient());\n    log.info(\"### Sending QUIT to overseer {}\", leader);\n    Overseer.getStateUpdateQueue(zkClient())\n        .offer(Utils.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.QUIT.toLower(),\n            \"id\", leaderId)));\n\n    waitForNewOverseer(15, s -> Objects.equals(leader, s) == false);\n\n    Thread.sleep(1000);\n    \n    logOverseerState();\n    assertTrue(\"The old leader should have rejoined election\",\n        OverseerCollectionConfigSetProcessor.getSortedOverseerNodeNames(zkClient()).contains(leader));\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"05a3c9b5f1dfb39879069eb1dac3ca104d3e4108","date":1533256859,"type":3,"author":"Erick","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#testOverseerRole().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#testOverseerRole().mjava","sourceNew":"  @Test\n  //commented 2-Aug-2018 @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 04-May-2018\n  public void testOverseerRole() throws Exception {\n\n    logOverseerState();\n    List<String> nodes = OverseerCollectionConfigSetProcessor.getSortedOverseerNodeNames(zkClient());\n    String overseer1 = OverseerCollectionConfigSetProcessor.getLeaderNode(zkClient());\n    nodes.remove(overseer1);\n\n    Collections.shuffle(nodes, random());\n    String overseer2 = nodes.get(0);\n    log.info(\"### Setting overseer designate {}\", overseer2);\n\n    CollectionAdminRequest.addRole(overseer2, \"overseer\").process(cluster.getSolrClient());\n\n    waitForNewOverseer(15, overseer2);\n\n    //add another node as overseer\n    nodes.remove(overseer2);\n    Collections.shuffle(nodes, random());\n\n    String overseer3 = nodes.get(0);\n    log.info(\"### Adding another overseer designate {}\", overseer3);\n    CollectionAdminRequest.addRole(overseer3, \"overseer\").process(cluster.getSolrClient());\n\n    // kill the current overseer, and check that the new designate becomes the new overseer\n    JettySolrRunner leaderJetty = getOverseerJetty();\n    logOverseerState();\n\n    ChaosMonkey.stop(leaderJetty);\n    waitForNewOverseer(10, overseer3);\n\n    // add another node as overseer\n    nodes.remove(overseer3);\n    Collections.shuffle(nodes, random());\n    String overseer4 = nodes.get(0);\n    log.info(\"### Adding last overseer designate {}\", overseer4);\n    CollectionAdminRequest.addRole(overseer4, \"overseer\").process(cluster.getSolrClient());\n    logOverseerState();\n\n    // remove the overseer role from the current overseer\n    CollectionAdminRequest.removeRole(overseer3, \"overseer\").process(cluster.getSolrClient());\n    waitForNewOverseer(15, overseer4);\n\n    // Add it back again - we now have two delegates, 4 and 3\n    CollectionAdminRequest.addRole(overseer3, \"overseer\").process(cluster.getSolrClient());\n\n    // explicitly tell the overseer to quit\n    String leaderId = OverseerCollectionConfigSetProcessor.getLeaderId(zkClient());\n    String leader = OverseerCollectionConfigSetProcessor.getLeaderNode(zkClient());\n    log.info(\"### Sending QUIT to overseer {}\", leader);\n    Overseer.getStateUpdateQueue(zkClient())\n        .offer(Utils.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.QUIT.toLower(),\n            \"id\", leaderId)));\n\n    waitForNewOverseer(15, s -> Objects.equals(leader, s) == false);\n\n    Thread.sleep(1000);\n    \n    logOverseerState();\n    assertTrue(\"The old leader should have rejoined election\",\n        OverseerCollectionConfigSetProcessor.getSortedOverseerNodeNames(zkClient()).contains(leader));\n\n  }\n\n","sourceOld":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 04-May-2018\n  public void testOverseerRole() throws Exception {\n\n    logOverseerState();\n    List<String> nodes = OverseerCollectionConfigSetProcessor.getSortedOverseerNodeNames(zkClient());\n    String overseer1 = OverseerCollectionConfigSetProcessor.getLeaderNode(zkClient());\n    nodes.remove(overseer1);\n\n    Collections.shuffle(nodes, random());\n    String overseer2 = nodes.get(0);\n    log.info(\"### Setting overseer designate {}\", overseer2);\n\n    CollectionAdminRequest.addRole(overseer2, \"overseer\").process(cluster.getSolrClient());\n\n    waitForNewOverseer(15, overseer2);\n\n    //add another node as overseer\n    nodes.remove(overseer2);\n    Collections.shuffle(nodes, random());\n\n    String overseer3 = nodes.get(0);\n    log.info(\"### Adding another overseer designate {}\", overseer3);\n    CollectionAdminRequest.addRole(overseer3, \"overseer\").process(cluster.getSolrClient());\n\n    // kill the current overseer, and check that the new designate becomes the new overseer\n    JettySolrRunner leaderJetty = getOverseerJetty();\n    logOverseerState();\n\n    ChaosMonkey.stop(leaderJetty);\n    waitForNewOverseer(10, overseer3);\n\n    // add another node as overseer\n    nodes.remove(overseer3);\n    Collections.shuffle(nodes, random());\n    String overseer4 = nodes.get(0);\n    log.info(\"### Adding last overseer designate {}\", overseer4);\n    CollectionAdminRequest.addRole(overseer4, \"overseer\").process(cluster.getSolrClient());\n    logOverseerState();\n\n    // remove the overseer role from the current overseer\n    CollectionAdminRequest.removeRole(overseer3, \"overseer\").process(cluster.getSolrClient());\n    waitForNewOverseer(15, overseer4);\n\n    // Add it back again - we now have two delegates, 4 and 3\n    CollectionAdminRequest.addRole(overseer3, \"overseer\").process(cluster.getSolrClient());\n\n    // explicitly tell the overseer to quit\n    String leaderId = OverseerCollectionConfigSetProcessor.getLeaderId(zkClient());\n    String leader = OverseerCollectionConfigSetProcessor.getLeaderNode(zkClient());\n    log.info(\"### Sending QUIT to overseer {}\", leader);\n    Overseer.getStateUpdateQueue(zkClient())\n        .offer(Utils.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.QUIT.toLower(),\n            \"id\", leaderId)));\n\n    waitForNewOverseer(15, s -> Objects.equals(leader, s) == false);\n\n    Thread.sleep(1000);\n    \n    logOverseerState();\n    assertTrue(\"The old leader should have rejoined election\",\n        OverseerCollectionConfigSetProcessor.getSortedOverseerNodeNames(zkClient()).contains(leader));\n\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f7ba5de6e78dd9b7518e92274a8a4cf8823a9c4a","date":1536291831,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#testOverseerRole().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#testOverseerRole().mjava","sourceNew":"  @Test\n  //commented 2-Aug-2018 @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 04-May-2018\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 6-Sep-2018\n  public void testOverseerRole() throws Exception {\n\n    logOverseerState();\n    List<String> nodes = OverseerCollectionConfigSetProcessor.getSortedOverseerNodeNames(zkClient());\n    String overseer1 = OverseerCollectionConfigSetProcessor.getLeaderNode(zkClient());\n    nodes.remove(overseer1);\n\n    Collections.shuffle(nodes, random());\n    String overseer2 = nodes.get(0);\n    log.info(\"### Setting overseer designate {}\", overseer2);\n\n    CollectionAdminRequest.addRole(overseer2, \"overseer\").process(cluster.getSolrClient());\n\n    waitForNewOverseer(15, overseer2);\n\n    //add another node as overseer\n    nodes.remove(overseer2);\n    Collections.shuffle(nodes, random());\n\n    String overseer3 = nodes.get(0);\n    log.info(\"### Adding another overseer designate {}\", overseer3);\n    CollectionAdminRequest.addRole(overseer3, \"overseer\").process(cluster.getSolrClient());\n\n    // kill the current overseer, and check that the new designate becomes the new overseer\n    JettySolrRunner leaderJetty = getOverseerJetty();\n    logOverseerState();\n\n    ChaosMonkey.stop(leaderJetty);\n    waitForNewOverseer(10, overseer3);\n\n    // add another node as overseer\n    nodes.remove(overseer3);\n    Collections.shuffle(nodes, random());\n    String overseer4 = nodes.get(0);\n    log.info(\"### Adding last overseer designate {}\", overseer4);\n    CollectionAdminRequest.addRole(overseer4, \"overseer\").process(cluster.getSolrClient());\n    logOverseerState();\n\n    // remove the overseer role from the current overseer\n    CollectionAdminRequest.removeRole(overseer3, \"overseer\").process(cluster.getSolrClient());\n    waitForNewOverseer(15, overseer4);\n\n    // Add it back again - we now have two delegates, 4 and 3\n    CollectionAdminRequest.addRole(overseer3, \"overseer\").process(cluster.getSolrClient());\n\n    // explicitly tell the overseer to quit\n    String leaderId = OverseerCollectionConfigSetProcessor.getLeaderId(zkClient());\n    String leader = OverseerCollectionConfigSetProcessor.getLeaderNode(zkClient());\n    log.info(\"### Sending QUIT to overseer {}\", leader);\n    Overseer.getStateUpdateQueue(zkClient())\n        .offer(Utils.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.QUIT.toLower(),\n            \"id\", leaderId)));\n\n    waitForNewOverseer(15, s -> Objects.equals(leader, s) == false);\n\n    Thread.sleep(1000);\n    \n    logOverseerState();\n    assertTrue(\"The old leader should have rejoined election\",\n        OverseerCollectionConfigSetProcessor.getSortedOverseerNodeNames(zkClient()).contains(leader));\n\n  }\n\n","sourceOld":"  @Test\n  //commented 2-Aug-2018 @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 04-May-2018\n  public void testOverseerRole() throws Exception {\n\n    logOverseerState();\n    List<String> nodes = OverseerCollectionConfigSetProcessor.getSortedOverseerNodeNames(zkClient());\n    String overseer1 = OverseerCollectionConfigSetProcessor.getLeaderNode(zkClient());\n    nodes.remove(overseer1);\n\n    Collections.shuffle(nodes, random());\n    String overseer2 = nodes.get(0);\n    log.info(\"### Setting overseer designate {}\", overseer2);\n\n    CollectionAdminRequest.addRole(overseer2, \"overseer\").process(cluster.getSolrClient());\n\n    waitForNewOverseer(15, overseer2);\n\n    //add another node as overseer\n    nodes.remove(overseer2);\n    Collections.shuffle(nodes, random());\n\n    String overseer3 = nodes.get(0);\n    log.info(\"### Adding another overseer designate {}\", overseer3);\n    CollectionAdminRequest.addRole(overseer3, \"overseer\").process(cluster.getSolrClient());\n\n    // kill the current overseer, and check that the new designate becomes the new overseer\n    JettySolrRunner leaderJetty = getOverseerJetty();\n    logOverseerState();\n\n    ChaosMonkey.stop(leaderJetty);\n    waitForNewOverseer(10, overseer3);\n\n    // add another node as overseer\n    nodes.remove(overseer3);\n    Collections.shuffle(nodes, random());\n    String overseer4 = nodes.get(0);\n    log.info(\"### Adding last overseer designate {}\", overseer4);\n    CollectionAdminRequest.addRole(overseer4, \"overseer\").process(cluster.getSolrClient());\n    logOverseerState();\n\n    // remove the overseer role from the current overseer\n    CollectionAdminRequest.removeRole(overseer3, \"overseer\").process(cluster.getSolrClient());\n    waitForNewOverseer(15, overseer4);\n\n    // Add it back again - we now have two delegates, 4 and 3\n    CollectionAdminRequest.addRole(overseer3, \"overseer\").process(cluster.getSolrClient());\n\n    // explicitly tell the overseer to quit\n    String leaderId = OverseerCollectionConfigSetProcessor.getLeaderId(zkClient());\n    String leader = OverseerCollectionConfigSetProcessor.getLeaderNode(zkClient());\n    log.info(\"### Sending QUIT to overseer {}\", leader);\n    Overseer.getStateUpdateQueue(zkClient())\n        .offer(Utils.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.QUIT.toLower(),\n            \"id\", leaderId)));\n\n    waitForNewOverseer(15, s -> Objects.equals(leader, s) == false);\n\n    Thread.sleep(1000);\n    \n    logOverseerState();\n    assertTrue(\"The old leader should have rejoined election\",\n        OverseerCollectionConfigSetProcessor.getSortedOverseerNodeNames(zkClient()).contains(leader));\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"44dd40f6c2c1465aebf4677bab10f696c7ea18d8","date":1539566013,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#testOverseerRole().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#testOverseerRole().mjava","sourceNew":"  @Test\n  //commented 2-Aug-2018 @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 04-May-2018\n  //Commented 14-Oct-2018 @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 6-Sep-2018\n  public void testOverseerRole() throws Exception {\n\n    logOverseerState();\n    List<String> nodes = OverseerCollectionConfigSetProcessor.getSortedOverseerNodeNames(zkClient());\n    String overseer1 = OverseerCollectionConfigSetProcessor.getLeaderNode(zkClient());\n    nodes.remove(overseer1);\n\n    Collections.shuffle(nodes, random());\n    String overseer2 = nodes.get(0);\n    log.info(\"### Setting overseer designate {}\", overseer2);\n\n    CollectionAdminRequest.addRole(overseer2, \"overseer\").process(cluster.getSolrClient());\n\n    waitForNewOverseer(15, overseer2);\n\n    //add another node as overseer\n    nodes.remove(overseer2);\n    Collections.shuffle(nodes, random());\n\n    String overseer3 = nodes.get(0);\n    log.info(\"### Adding another overseer designate {}\", overseer3);\n    CollectionAdminRequest.addRole(overseer3, \"overseer\").process(cluster.getSolrClient());\n\n    // kill the current overseer, and check that the new designate becomes the new overseer\n    JettySolrRunner leaderJetty = getOverseerJetty();\n    logOverseerState();\n\n    ChaosMonkey.stop(leaderJetty);\n    waitForNewOverseer(10, overseer3);\n\n    // add another node as overseer\n    nodes.remove(overseer3);\n    Collections.shuffle(nodes, random());\n    String overseer4 = nodes.get(0);\n    log.info(\"### Adding last overseer designate {}\", overseer4);\n    CollectionAdminRequest.addRole(overseer4, \"overseer\").process(cluster.getSolrClient());\n    logOverseerState();\n\n    // remove the overseer role from the current overseer\n    CollectionAdminRequest.removeRole(overseer3, \"overseer\").process(cluster.getSolrClient());\n    waitForNewOverseer(15, overseer4);\n\n    // Add it back again - we now have two delegates, 4 and 3\n    CollectionAdminRequest.addRole(overseer3, \"overseer\").process(cluster.getSolrClient());\n\n    // explicitly tell the overseer to quit\n    String leaderId = OverseerCollectionConfigSetProcessor.getLeaderId(zkClient());\n    String leader = OverseerCollectionConfigSetProcessor.getLeaderNode(zkClient());\n    log.info(\"### Sending QUIT to overseer {}\", leader);\n    Overseer.getStateUpdateQueue(zkClient())\n        .offer(Utils.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.QUIT.toLower(),\n            \"id\", leaderId)));\n\n    waitForNewOverseer(15, s -> Objects.equals(leader, s) == false);\n\n    Thread.sleep(1000);\n    \n    logOverseerState();\n    assertTrue(\"The old leader should have rejoined election\",\n        OverseerCollectionConfigSetProcessor.getSortedOverseerNodeNames(zkClient()).contains(leader));\n\n  }\n\n","sourceOld":"  @Test\n  //commented 2-Aug-2018 @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 04-May-2018\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 6-Sep-2018\n  public void testOverseerRole() throws Exception {\n\n    logOverseerState();\n    List<String> nodes = OverseerCollectionConfigSetProcessor.getSortedOverseerNodeNames(zkClient());\n    String overseer1 = OverseerCollectionConfigSetProcessor.getLeaderNode(zkClient());\n    nodes.remove(overseer1);\n\n    Collections.shuffle(nodes, random());\n    String overseer2 = nodes.get(0);\n    log.info(\"### Setting overseer designate {}\", overseer2);\n\n    CollectionAdminRequest.addRole(overseer2, \"overseer\").process(cluster.getSolrClient());\n\n    waitForNewOverseer(15, overseer2);\n\n    //add another node as overseer\n    nodes.remove(overseer2);\n    Collections.shuffle(nodes, random());\n\n    String overseer3 = nodes.get(0);\n    log.info(\"### Adding another overseer designate {}\", overseer3);\n    CollectionAdminRequest.addRole(overseer3, \"overseer\").process(cluster.getSolrClient());\n\n    // kill the current overseer, and check that the new designate becomes the new overseer\n    JettySolrRunner leaderJetty = getOverseerJetty();\n    logOverseerState();\n\n    ChaosMonkey.stop(leaderJetty);\n    waitForNewOverseer(10, overseer3);\n\n    // add another node as overseer\n    nodes.remove(overseer3);\n    Collections.shuffle(nodes, random());\n    String overseer4 = nodes.get(0);\n    log.info(\"### Adding last overseer designate {}\", overseer4);\n    CollectionAdminRequest.addRole(overseer4, \"overseer\").process(cluster.getSolrClient());\n    logOverseerState();\n\n    // remove the overseer role from the current overseer\n    CollectionAdminRequest.removeRole(overseer3, \"overseer\").process(cluster.getSolrClient());\n    waitForNewOverseer(15, overseer4);\n\n    // Add it back again - we now have two delegates, 4 and 3\n    CollectionAdminRequest.addRole(overseer3, \"overseer\").process(cluster.getSolrClient());\n\n    // explicitly tell the overseer to quit\n    String leaderId = OverseerCollectionConfigSetProcessor.getLeaderId(zkClient());\n    String leader = OverseerCollectionConfigSetProcessor.getLeaderNode(zkClient());\n    log.info(\"### Sending QUIT to overseer {}\", leader);\n    Overseer.getStateUpdateQueue(zkClient())\n        .offer(Utils.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.QUIT.toLower(),\n            \"id\", leaderId)));\n\n    waitForNewOverseer(15, s -> Objects.equals(leader, s) == false);\n\n    Thread.sleep(1000);\n    \n    logOverseerState();\n    assertTrue(\"The old leader should have rejoined election\",\n        OverseerCollectionConfigSetProcessor.getSortedOverseerNodeNames(zkClient()).contains(leader));\n\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#testOverseerRole().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#testOverseerRole().mjava","sourceNew":"  @Test\n  public void testOverseerRole() throws Exception {\n\n    logOverseerState();\n    List<String> nodes = OverseerCollectionConfigSetProcessor.getSortedOverseerNodeNames(zkClient());\n    String overseer1 = OverseerCollectionConfigSetProcessor.getLeaderNode(zkClient());\n    nodes.remove(overseer1);\n\n    Collections.shuffle(nodes, random());\n    String overseer2 = nodes.get(0);\n    log.info(\"### Setting overseer designate {}\", overseer2);\n\n    CollectionAdminRequest.addRole(overseer2, \"overseer\").process(cluster.getSolrClient());\n\n    waitForNewOverseer(15, overseer2);\n\n    //add another node as overseer\n    nodes.remove(overseer2);\n    Collections.shuffle(nodes, random());\n\n    String overseer3 = nodes.get(0);\n    log.info(\"### Adding another overseer designate {}\", overseer3);\n    CollectionAdminRequest.addRole(overseer3, \"overseer\").process(cluster.getSolrClient());\n\n    // kill the current overseer, and check that the new designate becomes the new overseer\n    JettySolrRunner leaderJetty = getOverseerJetty();\n    logOverseerState();\n\n    leaderJetty.stop();\n    waitForNewOverseer(10, overseer3);\n\n    // add another node as overseer\n    nodes.remove(overseer3);\n    Collections.shuffle(nodes, random());\n    String overseer4 = nodes.get(0);\n    log.info(\"### Adding last overseer designate {}\", overseer4);\n    CollectionAdminRequest.addRole(overseer4, \"overseer\").process(cluster.getSolrClient());\n    logOverseerState();\n\n    // remove the overseer role from the current overseer\n    CollectionAdminRequest.removeRole(overseer3, \"overseer\").process(cluster.getSolrClient());\n    waitForNewOverseer(15, overseer4);\n\n    // Add it back again - we now have two delegates, 4 and 3\n    CollectionAdminRequest.addRole(overseer3, \"overseer\").process(cluster.getSolrClient());\n\n    // explicitly tell the overseer to quit\n    String leaderId = OverseerCollectionConfigSetProcessor.getLeaderId(zkClient());\n    String leader = OverseerCollectionConfigSetProcessor.getLeaderNode(zkClient());\n    log.info(\"### Sending QUIT to overseer {}\", leader);\n    getOverseerJetty().getCoreContainer().getZkController().getOverseer().getStateUpdateQueue()\n        .offer(Utils.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.QUIT.toLower(),\n            \"id\", leaderId)));\n\n    waitForNewOverseer(15, s -> Objects.equals(leader, s) == false);\n\n    Thread.sleep(1000);\n    \n    logOverseerState();\n    assertTrue(\"The old leader should have rejoined election\",\n        OverseerCollectionConfigSetProcessor.getSortedOverseerNodeNames(zkClient()).contains(leader));\n\n  }\n\n","sourceOld":"  @Test\n  //commented 2-Aug-2018 @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 04-May-2018\n  //Commented 14-Oct-2018 @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 6-Sep-2018\n  public void testOverseerRole() throws Exception {\n\n    logOverseerState();\n    List<String> nodes = OverseerCollectionConfigSetProcessor.getSortedOverseerNodeNames(zkClient());\n    String overseer1 = OverseerCollectionConfigSetProcessor.getLeaderNode(zkClient());\n    nodes.remove(overseer1);\n\n    Collections.shuffle(nodes, random());\n    String overseer2 = nodes.get(0);\n    log.info(\"### Setting overseer designate {}\", overseer2);\n\n    CollectionAdminRequest.addRole(overseer2, \"overseer\").process(cluster.getSolrClient());\n\n    waitForNewOverseer(15, overseer2);\n\n    //add another node as overseer\n    nodes.remove(overseer2);\n    Collections.shuffle(nodes, random());\n\n    String overseer3 = nodes.get(0);\n    log.info(\"### Adding another overseer designate {}\", overseer3);\n    CollectionAdminRequest.addRole(overseer3, \"overseer\").process(cluster.getSolrClient());\n\n    // kill the current overseer, and check that the new designate becomes the new overseer\n    JettySolrRunner leaderJetty = getOverseerJetty();\n    logOverseerState();\n\n    ChaosMonkey.stop(leaderJetty);\n    waitForNewOverseer(10, overseer3);\n\n    // add another node as overseer\n    nodes.remove(overseer3);\n    Collections.shuffle(nodes, random());\n    String overseer4 = nodes.get(0);\n    log.info(\"### Adding last overseer designate {}\", overseer4);\n    CollectionAdminRequest.addRole(overseer4, \"overseer\").process(cluster.getSolrClient());\n    logOverseerState();\n\n    // remove the overseer role from the current overseer\n    CollectionAdminRequest.removeRole(overseer3, \"overseer\").process(cluster.getSolrClient());\n    waitForNewOverseer(15, overseer4);\n\n    // Add it back again - we now have two delegates, 4 and 3\n    CollectionAdminRequest.addRole(overseer3, \"overseer\").process(cluster.getSolrClient());\n\n    // explicitly tell the overseer to quit\n    String leaderId = OverseerCollectionConfigSetProcessor.getLeaderId(zkClient());\n    String leader = OverseerCollectionConfigSetProcessor.getLeaderNode(zkClient());\n    log.info(\"### Sending QUIT to overseer {}\", leader);\n    Overseer.getStateUpdateQueue(zkClient())\n        .offer(Utils.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.QUIT.toLower(),\n            \"id\", leaderId)));\n\n    waitForNewOverseer(15, s -> Objects.equals(leader, s) == false);\n\n    Thread.sleep(1000);\n    \n    logOverseerState();\n    assertTrue(\"The old leader should have rejoined election\",\n        OverseerCollectionConfigSetProcessor.getSortedOverseerNodeNames(zkClient()).contains(leader));\n\n  }\n\n","bugFix":["42d6fc6d08217c412f5a576929068b6e678deaf6","05a3c9b5f1dfb39879069eb1dac3ca104d3e4108","636a04bc82e662bf141a55f1d10f52e1c76c727b","44dd40f6c2c1465aebf4677bab10f696c7ea18d8"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"631022b03d06792c2b320d2264e643c3e9496289","date":1556909947,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#testOverseerRole().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#testOverseerRole().mjava","sourceNew":"  @Test\n  public void testOverseerRole() throws Exception {\n\n    logOverseerState();\n    List<String> nodes = OverseerCollectionConfigSetProcessor.getSortedOverseerNodeNames(zkClient());\n    // Remove the OVERSEER role, in case it was already assigned by another test in this suite\n    for (String node: nodes) {\n      CollectionAdminRequest.removeRole(node, \"overseer\").process(cluster.getSolrClient());\n    }\n    String overseer1 = OverseerCollectionConfigSetProcessor.getLeaderNode(zkClient());\n    nodes.remove(overseer1);\n\n    Collections.shuffle(nodes, random());\n    String overseer2 = nodes.get(0);\n    log.info(\"### Setting overseer designate {}\", overseer2);\n\n    CollectionAdminRequest.addRole(overseer2, \"overseer\").process(cluster.getSolrClient());\n\n    waitForNewOverseer(15, overseer2, false);\n\n    //add another node as overseer\n    nodes.remove(overseer2);\n    Collections.shuffle(nodes, random());\n\n    String overseer3 = nodes.get(0);\n    log.info(\"### Adding another overseer designate {}\", overseer3);\n    CollectionAdminRequest.addRole(overseer3, \"overseer\").process(cluster.getSolrClient());\n\n    // kill the current overseer, and check that the new designate becomes the new overseer\n    JettySolrRunner leaderJetty = getOverseerJetty();\n    logOverseerState();\n\n    leaderJetty.stop();\n    waitForNewOverseer(10, overseer3, false);\n\n    // add another node as overseer\n    nodes.remove(overseer3);\n    Collections.shuffle(nodes, random());\n    String overseer4 = nodes.get(0);\n    log.info(\"### Adding last overseer designate {}\", overseer4);\n    CollectionAdminRequest.addRole(overseer4, \"overseer\").process(cluster.getSolrClient());\n    logOverseerState();\n\n    // remove the overseer role from the current overseer\n    CollectionAdminRequest.removeRole(overseer3, \"overseer\").process(cluster.getSolrClient());\n    waitForNewOverseer(15, overseer4, false);\n\n    // Add it back again - we now have two delegates, 4 and 3\n    CollectionAdminRequest.addRole(overseer3, \"overseer\").process(cluster.getSolrClient());\n\n    // explicitly tell the overseer to quit\n    String leaderId = OverseerCollectionConfigSetProcessor.getLeaderId(zkClient());\n    String leader = OverseerCollectionConfigSetProcessor.getLeaderNode(zkClient());\n    log.info(\"### Sending QUIT to overseer {}\", leader);\n    getOverseerJetty().getCoreContainer().getZkController().getOverseer().getStateUpdateQueue()\n        .offer(Utils.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.QUIT.toLower(),\n            \"id\", leaderId)));\n\n    waitForNewOverseer(15, s -> Objects.equals(leader, s) == false, false);\n\n    Thread.sleep(1000);\n    \n    logOverseerState();\n    assertTrue(\"The old leader should have rejoined election\",\n        OverseerCollectionConfigSetProcessor.getSortedOverseerNodeNames(zkClient()).contains(leader));\n\n    leaderJetty.start(); // starting this back, just for good measure\n  }\n\n","sourceOld":"  @Test\n  public void testOverseerRole() throws Exception {\n\n    logOverseerState();\n    List<String> nodes = OverseerCollectionConfigSetProcessor.getSortedOverseerNodeNames(zkClient());\n    String overseer1 = OverseerCollectionConfigSetProcessor.getLeaderNode(zkClient());\n    nodes.remove(overseer1);\n\n    Collections.shuffle(nodes, random());\n    String overseer2 = nodes.get(0);\n    log.info(\"### Setting overseer designate {}\", overseer2);\n\n    CollectionAdminRequest.addRole(overseer2, \"overseer\").process(cluster.getSolrClient());\n\n    waitForNewOverseer(15, overseer2);\n\n    //add another node as overseer\n    nodes.remove(overseer2);\n    Collections.shuffle(nodes, random());\n\n    String overseer3 = nodes.get(0);\n    log.info(\"### Adding another overseer designate {}\", overseer3);\n    CollectionAdminRequest.addRole(overseer3, \"overseer\").process(cluster.getSolrClient());\n\n    // kill the current overseer, and check that the new designate becomes the new overseer\n    JettySolrRunner leaderJetty = getOverseerJetty();\n    logOverseerState();\n\n    leaderJetty.stop();\n    waitForNewOverseer(10, overseer3);\n\n    // add another node as overseer\n    nodes.remove(overseer3);\n    Collections.shuffle(nodes, random());\n    String overseer4 = nodes.get(0);\n    log.info(\"### Adding last overseer designate {}\", overseer4);\n    CollectionAdminRequest.addRole(overseer4, \"overseer\").process(cluster.getSolrClient());\n    logOverseerState();\n\n    // remove the overseer role from the current overseer\n    CollectionAdminRequest.removeRole(overseer3, \"overseer\").process(cluster.getSolrClient());\n    waitForNewOverseer(15, overseer4);\n\n    // Add it back again - we now have two delegates, 4 and 3\n    CollectionAdminRequest.addRole(overseer3, \"overseer\").process(cluster.getSolrClient());\n\n    // explicitly tell the overseer to quit\n    String leaderId = OverseerCollectionConfigSetProcessor.getLeaderId(zkClient());\n    String leader = OverseerCollectionConfigSetProcessor.getLeaderNode(zkClient());\n    log.info(\"### Sending QUIT to overseer {}\", leader);\n    getOverseerJetty().getCoreContainer().getZkController().getOverseer().getStateUpdateQueue()\n        .offer(Utils.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.QUIT.toLower(),\n            \"id\", leaderId)));\n\n    waitForNewOverseer(15, s -> Objects.equals(leader, s) == false);\n\n    Thread.sleep(1000);\n    \n    logOverseerState();\n    assertTrue(\"The old leader should have rejoined election\",\n        OverseerCollectionConfigSetProcessor.getSortedOverseerNodeNames(zkClient()).contains(leader));\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"44dd40f6c2c1465aebf4677bab10f696c7ea18d8":["f7ba5de6e78dd9b7518e92274a8a4cf8823a9c4a"],"5eb2511ababf862ea11e10761c70ee560cd84510":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","5b15576cafd8b5d06857055c28f26912321937e3"],"631022b03d06792c2b320d2264e643c3e9496289":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"05a3c9b5f1dfb39879069eb1dac3ca104d3e4108":["4bab9eeea60eefbea2957be27b8d1923095df771"],"7d996c36bf85996da326201b915c87d41449d7f5":["6762551dad139aaedf252c353553e7bdbf7daffe"],"55980207f1977bd1463465de1659b821347e2fa8":["7d996c36bf85996da326201b915c87d41449d7f5","103857ec20f79f31c7a00310a91ed001b9a6ef17"],"d75295502d9d3f7995ae901a065be971191fcf8f":["42d6fc6d08217c412f5a576929068b6e678deaf6"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["44dd40f6c2c1465aebf4677bab10f696c7ea18d8"],"e57c73924f3b8c19defa62e96bfa34a4922d49c2":["6762551dad139aaedf252c353553e7bdbf7daffe","7d996c36bf85996da326201b915c87d41449d7f5"],"42d6fc6d08217c412f5a576929068b6e678deaf6":["636a04bc82e662bf141a55f1d10f52e1c76c727b"],"5455c7b3fed6c1671990a44c19071cb0488c2c25":["103857ec20f79f31c7a00310a91ed001b9a6ef17"],"6762551dad139aaedf252c353553e7bdbf7daffe":["5b15576cafd8b5d06857055c28f26912321937e3"],"90a682dc1bfd188ef61cc28373c7f5d700b4ac75":["f03e4bed5023ec3ef93a771b8888cae991cf448d","42d6fc6d08217c412f5a576929068b6e678deaf6"],"f03e4bed5023ec3ef93a771b8888cae991cf448d":["2bf454e5dea7bb5bcf27f8332ded09afcc4b6a1b","636a04bc82e662bf141a55f1d10f52e1c76c727b"],"2bf454e5dea7bb5bcf27f8332ded09afcc4b6a1b":["5455c7b3fed6c1671990a44c19071cb0488c2c25"],"636a04bc82e662bf141a55f1d10f52e1c76c727b":["2bf454e5dea7bb5bcf27f8332ded09afcc4b6a1b"],"0a22eafe3f72a4c2945eaad9547e6c78816978f4":["55980207f1977bd1463465de1659b821347e2fa8","5455c7b3fed6c1671990a44c19071cb0488c2c25"],"5b15576cafd8b5d06857055c28f26912321937e3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4bab9eeea60eefbea2957be27b8d1923095df771":["d75295502d9d3f7995ae901a065be971191fcf8f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f7ba5de6e78dd9b7518e92274a8a4cf8823a9c4a":["05a3c9b5f1dfb39879069eb1dac3ca104d3e4108"],"103857ec20f79f31c7a00310a91ed001b9a6ef17":["7d996c36bf85996da326201b915c87d41449d7f5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["631022b03d06792c2b320d2264e643c3e9496289"]},"commit2Childs":{"44dd40f6c2c1465aebf4677bab10f696c7ea18d8":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"5eb2511ababf862ea11e10761c70ee560cd84510":[],"631022b03d06792c2b320d2264e643c3e9496289":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"05a3c9b5f1dfb39879069eb1dac3ca104d3e4108":["f7ba5de6e78dd9b7518e92274a8a4cf8823a9c4a"],"7d996c36bf85996da326201b915c87d41449d7f5":["55980207f1977bd1463465de1659b821347e2fa8","e57c73924f3b8c19defa62e96bfa34a4922d49c2","103857ec20f79f31c7a00310a91ed001b9a6ef17"],"55980207f1977bd1463465de1659b821347e2fa8":["0a22eafe3f72a4c2945eaad9547e6c78816978f4"],"d75295502d9d3f7995ae901a065be971191fcf8f":["4bab9eeea60eefbea2957be27b8d1923095df771"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["631022b03d06792c2b320d2264e643c3e9496289"],"e57c73924f3b8c19defa62e96bfa34a4922d49c2":[],"42d6fc6d08217c412f5a576929068b6e678deaf6":["d75295502d9d3f7995ae901a065be971191fcf8f","90a682dc1bfd188ef61cc28373c7f5d700b4ac75"],"5455c7b3fed6c1671990a44c19071cb0488c2c25":["2bf454e5dea7bb5bcf27f8332ded09afcc4b6a1b","0a22eafe3f72a4c2945eaad9547e6c78816978f4"],"6762551dad139aaedf252c353553e7bdbf7daffe":["7d996c36bf85996da326201b915c87d41449d7f5","e57c73924f3b8c19defa62e96bfa34a4922d49c2"],"90a682dc1bfd188ef61cc28373c7f5d700b4ac75":[],"f03e4bed5023ec3ef93a771b8888cae991cf448d":["90a682dc1bfd188ef61cc28373c7f5d700b4ac75"],"2bf454e5dea7bb5bcf27f8332ded09afcc4b6a1b":["f03e4bed5023ec3ef93a771b8888cae991cf448d","636a04bc82e662bf141a55f1d10f52e1c76c727b"],"636a04bc82e662bf141a55f1d10f52e1c76c727b":["42d6fc6d08217c412f5a576929068b6e678deaf6","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"0a22eafe3f72a4c2945eaad9547e6c78816978f4":[],"5b15576cafd8b5d06857055c28f26912321937e3":["5eb2511ababf862ea11e10761c70ee560cd84510","6762551dad139aaedf252c353553e7bdbf7daffe"],"4bab9eeea60eefbea2957be27b8d1923095df771":["05a3c9b5f1dfb39879069eb1dac3ca104d3e4108"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5eb2511ababf862ea11e10761c70ee560cd84510","5b15576cafd8b5d06857055c28f26912321937e3"],"f7ba5de6e78dd9b7518e92274a8a4cf8823a9c4a":["44dd40f6c2c1465aebf4677bab10f696c7ea18d8"],"103857ec20f79f31c7a00310a91ed001b9a6ef17":["55980207f1977bd1463465de1659b821347e2fa8","5455c7b3fed6c1671990a44c19071cb0488c2c25"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["5eb2511ababf862ea11e10761c70ee560cd84510","e57c73924f3b8c19defa62e96bfa34a4922d49c2","90a682dc1bfd188ef61cc28373c7f5d700b4ac75","0a22eafe3f72a4c2945eaad9547e6c78816978f4","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}