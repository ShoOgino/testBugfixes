{"path":"src/java/org/apache/lucene/index/IndexReader#commit().mjava","commits":[{"id":"f653aecb322b74d99e6ecdb93765e453a3d7aa71","date":1082107025,"type":0,"author":"Christoph Goller","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexReader#commit().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Commit changes resulting from delete, undeleteAll, or setNorm operations\n   * \n   * @throws IOException\n   */\n  protected final synchronized void commit() throws IOException{\n    if(hasChanges){\n      if(directoryOwner){\n        synchronized (directory) {      // in- & inter-process sync\n           new Lock.With(directory.makeLock(IndexWriter.COMMIT_LOCK_NAME),\n                   IndexWriter.COMMIT_LOCK_TIMEOUT) {\n             public Object doBody() throws IOException {\n               doCommit();\n               segmentInfos.write(directory);\n               return null;\n             }\n           }.run();\n         }\n        if (writeLock != null) {\n          writeLock.release();  // release write lock\n          writeLock = null;\n        }\n      }\n      else\n        doCommit();\n    }\n    hasChanges = false;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["1b54a9bc667895a2095a886184bf69a3179e63df"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"284c1d3c8b19931bf6f312fae7470487f5d9e580","date":1163805527,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexReader#commit().mjava","pathOld":"src/java/org/apache/lucene/index/IndexReader#commit().mjava","sourceNew":"  /**\n   * Commit changes resulting from delete, undeleteAll, or setNorm operations\n   * \n   * @throws IOException\n   */\n  protected final synchronized void commit() throws IOException{\n    if(hasChanges){\n      if (deleter == null) {\n        // In the MultiReader case, we share this deleter\n        // across all SegmentReaders:\n        setDeleter(new IndexFileDeleter(segmentInfos, directory));\n        deleter.deleteFiles();\n      }\n      if(directoryOwner){\n        deleter.clearPendingFiles();\n        doCommit();\n        String oldInfoFileName = segmentInfos.getCurrentSegmentFileName();\n        segmentInfos.write(directory);\n        // Attempt to delete all files we just obsoleted:\n\n        deleter.deleteFile(oldInfoFileName);\n        deleter.commitPendingFiles();\n        deleter.deleteFiles();\n        if (writeLock != null) {\n          writeLock.release();  // release write lock\n          writeLock = null;\n        }\n      }\n      else\n        doCommit();\n    }\n    hasChanges = false;\n  }\n\n","sourceOld":"  /**\n   * Commit changes resulting from delete, undeleteAll, or setNorm operations\n   * \n   * @throws IOException\n   */\n  protected final synchronized void commit() throws IOException{\n    if(hasChanges){\n      if(directoryOwner){\n        synchronized (directory) {      // in- & inter-process sync\n           new Lock.With(directory.makeLock(IndexWriter.COMMIT_LOCK_NAME),\n                   IndexWriter.COMMIT_LOCK_TIMEOUT) {\n             public Object doBody() throws IOException {\n               doCommit();\n               segmentInfos.write(directory);\n               return null;\n             }\n           }.run();\n         }\n        if (writeLock != null) {\n          writeLock.release();  // release write lock\n          writeLock = null;\n        }\n      }\n      else\n        doCommit();\n    }\n    hasChanges = false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"eeefd99c477417e5c7c574228461ebafe92469d4","date":1166460329,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexReader#commit().mjava","pathOld":"src/java/org/apache/lucene/index/IndexReader#commit().mjava","sourceNew":"  /**\n   * Commit changes resulting from delete, undeleteAll, or\n   * setNorm operations\n   *\n   * If an exception is hit, then either no changes or all\n   * changes will have been committed to the index\n   * (transactional semantics).\n   * \n   * @throws IOException\n   */\n  protected final synchronized void commit() throws IOException{\n    if(hasChanges){\n      if (deleter == null) {\n        // In the MultiReader case, we share this deleter\n        // across all SegmentReaders:\n        setDeleter(new IndexFileDeleter(segmentInfos, directory));\n        deleter.deleteFiles();\n      }\n      if(directoryOwner){\n\n        // Should not be necessary: no prior commit should\n        // have left pending files, so just defensive:\n        deleter.clearPendingFiles();\n\n        String oldInfoFileName = segmentInfos.getCurrentSegmentFileName();\n        String nextSegmentsFileName = segmentInfos.getNextSegmentFileName();\n\n        // Checkpoint the state we are about to change, in\n        // case we have to roll back:\n        startCommit();\n\n        boolean success = false;\n        try {\n          doCommit();\n          segmentInfos.write(directory);\n          success = true;\n        } finally {\n\n          if (!success) {\n\n            // Rollback changes that were made to\n            // SegmentInfos but failed to get [fully]\n            // committed.  This way this reader instance\n            // remains consistent (matched to what's\n            // actually in the index):\n            rollbackCommit();\n\n            // Erase any pending files that we were going to delete:\n            deleter.clearPendingFiles();\n\n            // Remove possibly partially written next\n            // segments file:\n            deleter.deleteFile(nextSegmentsFileName);\n\n            // Recompute deletable files & remove them (so\n            // partially written .del files, etc, are\n            // removed):\n            deleter.findDeletableFiles();\n            deleter.deleteFiles();\n          }\n        }\n\n        // Attempt to delete all files we just obsoleted:\n        deleter.deleteFile(oldInfoFileName);\n        deleter.commitPendingFiles();\n\n        if (writeLock != null) {\n          writeLock.release();  // release write lock\n          writeLock = null;\n        }\n      }\n      else\n        doCommit();\n    }\n    hasChanges = false;\n  }\n\n","sourceOld":"  /**\n   * Commit changes resulting from delete, undeleteAll, or setNorm operations\n   * \n   * @throws IOException\n   */\n  protected final synchronized void commit() throws IOException{\n    if(hasChanges){\n      if (deleter == null) {\n        // In the MultiReader case, we share this deleter\n        // across all SegmentReaders:\n        setDeleter(new IndexFileDeleter(segmentInfos, directory));\n        deleter.deleteFiles();\n      }\n      if(directoryOwner){\n        deleter.clearPendingFiles();\n        doCommit();\n        String oldInfoFileName = segmentInfos.getCurrentSegmentFileName();\n        segmentInfos.write(directory);\n        // Attempt to delete all files we just obsoleted:\n\n        deleter.deleteFile(oldInfoFileName);\n        deleter.commitPendingFiles();\n        deleter.deleteFiles();\n        if (writeLock != null) {\n          writeLock.release();  // release write lock\n          writeLock = null;\n        }\n      }\n      else\n        doCommit();\n    }\n    hasChanges = false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ae7060e0429fd7a6868913ef9f585e1470bdff4e","date":1166571682,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexReader#commit().mjava","pathOld":"src/java/org/apache/lucene/index/IndexReader#commit().mjava","sourceNew":"  /**\n   * Commit changes resulting from delete, undeleteAll, or\n   * setNorm operations\n   *\n   * If an exception is hit, then either no changes or all\n   * changes will have been committed to the index\n   * (transactional semantics).\n   * \n   * @throws IOException\n   */\n  protected final synchronized void commit() throws IOException{\n    if(hasChanges){\n      if (deleter == null) {\n        // In the MultiReader case, we share this deleter\n        // across all SegmentReaders:\n        setDeleter(new IndexFileDeleter(segmentInfos, directory));\n      }\n      if(directoryOwner){\n\n        // Should not be necessary: no prior commit should\n        // have left pending files, so just defensive:\n        deleter.clearPendingFiles();\n\n        String oldInfoFileName = segmentInfos.getCurrentSegmentFileName();\n        String nextSegmentsFileName = segmentInfos.getNextSegmentFileName();\n\n        // Checkpoint the state we are about to change, in\n        // case we have to roll back:\n        startCommit();\n\n        boolean success = false;\n        try {\n          doCommit();\n          segmentInfos.write(directory);\n          success = true;\n        } finally {\n\n          if (!success) {\n\n            // Rollback changes that were made to\n            // SegmentInfos but failed to get [fully]\n            // committed.  This way this reader instance\n            // remains consistent (matched to what's\n            // actually in the index):\n            rollbackCommit();\n\n            // Erase any pending files that we were going to delete:\n            deleter.clearPendingFiles();\n\n            // Remove possibly partially written next\n            // segments file:\n            deleter.deleteFile(nextSegmentsFileName);\n\n            // Recompute deletable files & remove them (so\n            // partially written .del files, etc, are\n            // removed):\n            deleter.findDeletableFiles();\n            deleter.deleteFiles();\n          }\n        }\n\n        // Attempt to delete all files we just obsoleted:\n        deleter.deleteFile(oldInfoFileName);\n        deleter.commitPendingFiles();\n\n        if (writeLock != null) {\n          writeLock.release();  // release write lock\n          writeLock = null;\n        }\n      }\n      else\n        doCommit();\n    }\n    hasChanges = false;\n  }\n\n","sourceOld":"  /**\n   * Commit changes resulting from delete, undeleteAll, or\n   * setNorm operations\n   *\n   * If an exception is hit, then either no changes or all\n   * changes will have been committed to the index\n   * (transactional semantics).\n   * \n   * @throws IOException\n   */\n  protected final synchronized void commit() throws IOException{\n    if(hasChanges){\n      if (deleter == null) {\n        // In the MultiReader case, we share this deleter\n        // across all SegmentReaders:\n        setDeleter(new IndexFileDeleter(segmentInfos, directory));\n        deleter.deleteFiles();\n      }\n      if(directoryOwner){\n\n        // Should not be necessary: no prior commit should\n        // have left pending files, so just defensive:\n        deleter.clearPendingFiles();\n\n        String oldInfoFileName = segmentInfos.getCurrentSegmentFileName();\n        String nextSegmentsFileName = segmentInfos.getNextSegmentFileName();\n\n        // Checkpoint the state we are about to change, in\n        // case we have to roll back:\n        startCommit();\n\n        boolean success = false;\n        try {\n          doCommit();\n          segmentInfos.write(directory);\n          success = true;\n        } finally {\n\n          if (!success) {\n\n            // Rollback changes that were made to\n            // SegmentInfos but failed to get [fully]\n            // committed.  This way this reader instance\n            // remains consistent (matched to what's\n            // actually in the index):\n            rollbackCommit();\n\n            // Erase any pending files that we were going to delete:\n            deleter.clearPendingFiles();\n\n            // Remove possibly partially written next\n            // segments file:\n            deleter.deleteFile(nextSegmentsFileName);\n\n            // Recompute deletable files & remove them (so\n            // partially written .del files, etc, are\n            // removed):\n            deleter.findDeletableFiles();\n            deleter.deleteFiles();\n          }\n        }\n\n        // Attempt to delete all files we just obsoleted:\n        deleter.deleteFile(oldInfoFileName);\n        deleter.commitPendingFiles();\n\n        if (writeLock != null) {\n          writeLock.release();  // release write lock\n          writeLock = null;\n        }\n      }\n      else\n        doCommit();\n    }\n    hasChanges = false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1b54a9bc667895a2095a886184bf69a3179e63df","date":1172088096,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexReader#commit().mjava","pathOld":"src/java/org/apache/lucene/index/IndexReader#commit().mjava","sourceNew":"  /**\n   * Commit changes resulting from delete, undeleteAll, or\n   * setNorm operations\n   *\n   * If an exception is hit, then either no changes or all\n   * changes will have been committed to the index\n   * (transactional semantics).\n   * @throws IOException if there is a low-level IO error\n   */\n  protected final synchronized void commit() throws IOException {\n    if(hasChanges){\n      if (deleter == null) {\n        // In the MultiReader case, we share this deleter\n        // across all SegmentReaders:\n        setDeleter(new IndexFileDeleter(segmentInfos, directory));\n      }\n      if(directoryOwner){\n\n        // Should not be necessary: no prior commit should\n        // have left pending files, so just defensive:\n        deleter.clearPendingFiles();\n\n        String oldInfoFileName = segmentInfos.getCurrentSegmentFileName();\n        String nextSegmentsFileName = segmentInfos.getNextSegmentFileName();\n\n        // Checkpoint the state we are about to change, in\n        // case we have to roll back:\n        startCommit();\n\n        boolean success = false;\n        try {\n          doCommit();\n          segmentInfos.write(directory);\n          success = true;\n        } finally {\n\n          if (!success) {\n\n            // Rollback changes that were made to\n            // SegmentInfos but failed to get [fully]\n            // committed.  This way this reader instance\n            // remains consistent (matched to what's\n            // actually in the index):\n            rollbackCommit();\n\n            // Erase any pending files that we were going to delete:\n            deleter.clearPendingFiles();\n\n            // Remove possibly partially written next\n            // segments file:\n            deleter.deleteFile(nextSegmentsFileName);\n\n            // Recompute deletable files & remove them (so\n            // partially written .del files, etc, are\n            // removed):\n            deleter.findDeletableFiles();\n            deleter.deleteFiles();\n          }\n        }\n\n        // Attempt to delete all files we just obsoleted:\n        deleter.deleteFile(oldInfoFileName);\n        deleter.commitPendingFiles();\n\n        if (writeLock != null) {\n          writeLock.release();  // release write lock\n          writeLock = null;\n        }\n      }\n      else\n        doCommit();\n    }\n    hasChanges = false;\n  }\n\n","sourceOld":"  /**\n   * Commit changes resulting from delete, undeleteAll, or\n   * setNorm operations\n   *\n   * If an exception is hit, then either no changes or all\n   * changes will have been committed to the index\n   * (transactional semantics).\n   * \n   * @throws IOException\n   */\n  protected final synchronized void commit() throws IOException{\n    if(hasChanges){\n      if (deleter == null) {\n        // In the MultiReader case, we share this deleter\n        // across all SegmentReaders:\n        setDeleter(new IndexFileDeleter(segmentInfos, directory));\n      }\n      if(directoryOwner){\n\n        // Should not be necessary: no prior commit should\n        // have left pending files, so just defensive:\n        deleter.clearPendingFiles();\n\n        String oldInfoFileName = segmentInfos.getCurrentSegmentFileName();\n        String nextSegmentsFileName = segmentInfos.getNextSegmentFileName();\n\n        // Checkpoint the state we are about to change, in\n        // case we have to roll back:\n        startCommit();\n\n        boolean success = false;\n        try {\n          doCommit();\n          segmentInfos.write(directory);\n          success = true;\n        } finally {\n\n          if (!success) {\n\n            // Rollback changes that were made to\n            // SegmentInfos but failed to get [fully]\n            // committed.  This way this reader instance\n            // remains consistent (matched to what's\n            // actually in the index):\n            rollbackCommit();\n\n            // Erase any pending files that we were going to delete:\n            deleter.clearPendingFiles();\n\n            // Remove possibly partially written next\n            // segments file:\n            deleter.deleteFile(nextSegmentsFileName);\n\n            // Recompute deletable files & remove them (so\n            // partially written .del files, etc, are\n            // removed):\n            deleter.findDeletableFiles();\n            deleter.deleteFiles();\n          }\n        }\n\n        // Attempt to delete all files we just obsoleted:\n        deleter.deleteFile(oldInfoFileName);\n        deleter.commitPendingFiles();\n\n        if (writeLock != null) {\n          writeLock.release();  // release write lock\n          writeLock = null;\n        }\n      }\n      else\n        doCommit();\n    }\n    hasChanges = false;\n  }\n\n","bugFix":["f653aecb322b74d99e6ecdb93765e453a3d7aa71"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8b6187898fc4413ccd18229711786550a280383c","date":1173776782,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexReader#commit().mjava","pathOld":"src/java/org/apache/lucene/index/IndexReader#commit().mjava","sourceNew":"  /**\n   * Commit changes resulting from delete, undeleteAll, or\n   * setNorm operations\n   *\n   * If an exception is hit, then either no changes or all\n   * changes will have been committed to the index\n   * (transactional semantics).\n   * @throws IOException if there is a low-level IO error\n   */\n  protected final synchronized void commit() throws IOException {\n    if(hasChanges){\n      if(directoryOwner){\n\n        // Default deleter (for backwards compatibility) is\n        // KeepOnlyLastCommitDeleter:\n        IndexFileDeleter deleter =  new IndexFileDeleter(directory,\n                                                         deletionPolicy == null ? new KeepOnlyLastCommitDeletionPolicy() : deletionPolicy,\n                                                         segmentInfos, null);\n\n        // Checkpoint the state we are about to change, in\n        // case we have to roll back:\n        startCommit();\n\n        boolean success = false;\n        try {\n          doCommit();\n          segmentInfos.write(directory);\n          success = true;\n        } finally {\n\n          if (!success) {\n\n            // Rollback changes that were made to\n            // SegmentInfos but failed to get [fully]\n            // committed.  This way this reader instance\n            // remains consistent (matched to what's\n            // actually in the index):\n            rollbackCommit();\n\n            // Recompute deletable files & remove them (so\n            // partially written .del files, etc, are\n            // removed):\n            deleter.refresh();\n          }\n        }\n\n        // Have the deleter remove any now unreferenced\n        // files due to this commit:\n        deleter.checkpoint(segmentInfos, true);\n\n        if (writeLock != null) {\n          writeLock.release();  // release write lock\n          writeLock = null;\n        }\n      }\n      else\n        doCommit();\n    }\n    hasChanges = false;\n  }\n\n","sourceOld":"  /**\n   * Commit changes resulting from delete, undeleteAll, or\n   * setNorm operations\n   *\n   * If an exception is hit, then either no changes or all\n   * changes will have been committed to the index\n   * (transactional semantics).\n   * @throws IOException if there is a low-level IO error\n   */\n  protected final synchronized void commit() throws IOException {\n    if(hasChanges){\n      if (deleter == null) {\n        // In the MultiReader case, we share this deleter\n        // across all SegmentReaders:\n        setDeleter(new IndexFileDeleter(segmentInfos, directory));\n      }\n      if(directoryOwner){\n\n        // Should not be necessary: no prior commit should\n        // have left pending files, so just defensive:\n        deleter.clearPendingFiles();\n\n        String oldInfoFileName = segmentInfos.getCurrentSegmentFileName();\n        String nextSegmentsFileName = segmentInfos.getNextSegmentFileName();\n\n        // Checkpoint the state we are about to change, in\n        // case we have to roll back:\n        startCommit();\n\n        boolean success = false;\n        try {\n          doCommit();\n          segmentInfos.write(directory);\n          success = true;\n        } finally {\n\n          if (!success) {\n\n            // Rollback changes that were made to\n            // SegmentInfos but failed to get [fully]\n            // committed.  This way this reader instance\n            // remains consistent (matched to what's\n            // actually in the index):\n            rollbackCommit();\n\n            // Erase any pending files that we were going to delete:\n            deleter.clearPendingFiles();\n\n            // Remove possibly partially written next\n            // segments file:\n            deleter.deleteFile(nextSegmentsFileName);\n\n            // Recompute deletable files & remove them (so\n            // partially written .del files, etc, are\n            // removed):\n            deleter.findDeletableFiles();\n            deleter.deleteFiles();\n          }\n        }\n\n        // Attempt to delete all files we just obsoleted:\n        deleter.deleteFile(oldInfoFileName);\n        deleter.commitPendingFiles();\n\n        if (writeLock != null) {\n          writeLock.release();  // release write lock\n          writeLock = null;\n        }\n      }\n      else\n        doCommit();\n    }\n    hasChanges = false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4350b17bd363cd13a95171b8df1ca62ea4c3e71c","date":1183562198,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexReader#commit().mjava","pathOld":"src/java/org/apache/lucene/index/IndexReader#commit().mjava","sourceNew":"  /**\n   * Commit changes resulting from delete, undeleteAll, or\n   * setNorm operations\n   *\n   * If an exception is hit, then either no changes or all\n   * changes will have been committed to the index\n   * (transactional semantics).\n   * @throws IOException if there is a low-level IO error\n   */\n  protected final synchronized void commit() throws IOException {\n    if(hasChanges){\n      if(directoryOwner){\n\n        // Default deleter (for backwards compatibility) is\n        // KeepOnlyLastCommitDeleter:\n        IndexFileDeleter deleter =  new IndexFileDeleter(directory,\n                                                         deletionPolicy == null ? new KeepOnlyLastCommitDeletionPolicy() : deletionPolicy,\n                                                         segmentInfos, null, null);\n\n        // Checkpoint the state we are about to change, in\n        // case we have to roll back:\n        startCommit();\n\n        boolean success = false;\n        try {\n          doCommit();\n          segmentInfos.write(directory);\n          success = true;\n        } finally {\n\n          if (!success) {\n\n            // Rollback changes that were made to\n            // SegmentInfos but failed to get [fully]\n            // committed.  This way this reader instance\n            // remains consistent (matched to what's\n            // actually in the index):\n            rollbackCommit();\n\n            // Recompute deletable files & remove them (so\n            // partially written .del files, etc, are\n            // removed):\n            deleter.refresh();\n          }\n        }\n\n        // Have the deleter remove any now unreferenced\n        // files due to this commit:\n        deleter.checkpoint(segmentInfos, true);\n\n        if (writeLock != null) {\n          writeLock.release();  // release write lock\n          writeLock = null;\n        }\n      }\n      else\n        doCommit();\n    }\n    hasChanges = false;\n  }\n\n","sourceOld":"  /**\n   * Commit changes resulting from delete, undeleteAll, or\n   * setNorm operations\n   *\n   * If an exception is hit, then either no changes or all\n   * changes will have been committed to the index\n   * (transactional semantics).\n   * @throws IOException if there is a low-level IO error\n   */\n  protected final synchronized void commit() throws IOException {\n    if(hasChanges){\n      if(directoryOwner){\n\n        // Default deleter (for backwards compatibility) is\n        // KeepOnlyLastCommitDeleter:\n        IndexFileDeleter deleter =  new IndexFileDeleter(directory,\n                                                         deletionPolicy == null ? new KeepOnlyLastCommitDeletionPolicy() : deletionPolicy,\n                                                         segmentInfos, null);\n\n        // Checkpoint the state we are about to change, in\n        // case we have to roll back:\n        startCommit();\n\n        boolean success = false;\n        try {\n          doCommit();\n          segmentInfos.write(directory);\n          success = true;\n        } finally {\n\n          if (!success) {\n\n            // Rollback changes that were made to\n            // SegmentInfos but failed to get [fully]\n            // committed.  This way this reader instance\n            // remains consistent (matched to what's\n            // actually in the index):\n            rollbackCommit();\n\n            // Recompute deletable files & remove them (so\n            // partially written .del files, etc, are\n            // removed):\n            deleter.refresh();\n          }\n        }\n\n        // Have the deleter remove any now unreferenced\n        // files due to this commit:\n        deleter.checkpoint(segmentInfos, true);\n\n        if (writeLock != null) {\n          writeLock.release();  // release write lock\n          writeLock = null;\n        }\n      }\n      else\n        doCommit();\n    }\n    hasChanges = false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"125b5699f11b58d9be0820c6ce8b1648812902e8","date":1190273227,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexReader#commit().mjava","pathOld":"src/java/org/apache/lucene/index/IndexReader#commit().mjava","sourceNew":"  /**\n   * Commit changes resulting from delete, undeleteAll, or\n   * setNorm operations\n   *\n   * If an exception is hit, then either no changes or all\n   * changes will have been committed to the index\n   * (transactional semantics).\n   * @throws IOException if there is a low-level IO error\n   */\n  protected final synchronized void commit() throws IOException {\n    if(hasChanges){\n      doCommit();\n    }\n    hasChanges = false;\n  }\n\n","sourceOld":"  /**\n   * Commit changes resulting from delete, undeleteAll, or\n   * setNorm operations\n   *\n   * If an exception is hit, then either no changes or all\n   * changes will have been committed to the index\n   * (transactional semantics).\n   * @throws IOException if there is a low-level IO error\n   */\n  protected final synchronized void commit() throws IOException {\n    if(hasChanges){\n      if(directoryOwner){\n\n        // Default deleter (for backwards compatibility) is\n        // KeepOnlyLastCommitDeleter:\n        IndexFileDeleter deleter =  new IndexFileDeleter(directory,\n                                                         deletionPolicy == null ? new KeepOnlyLastCommitDeletionPolicy() : deletionPolicy,\n                                                         segmentInfos, null, null);\n\n        // Checkpoint the state we are about to change, in\n        // case we have to roll back:\n        startCommit();\n\n        boolean success = false;\n        try {\n          doCommit();\n          segmentInfos.write(directory);\n          success = true;\n        } finally {\n\n          if (!success) {\n\n            // Rollback changes that were made to\n            // SegmentInfos but failed to get [fully]\n            // committed.  This way this reader instance\n            // remains consistent (matched to what's\n            // actually in the index):\n            rollbackCommit();\n\n            // Recompute deletable files & remove them (so\n            // partially written .del files, etc, are\n            // removed):\n            deleter.refresh();\n          }\n        }\n\n        // Have the deleter remove any now unreferenced\n        // files due to this commit:\n        deleter.checkpoint(segmentInfos, true);\n\n        if (writeLock != null) {\n          writeLock.release();  // release write lock\n          writeLock = null;\n        }\n      }\n      else\n        doCommit();\n    }\n    hasChanges = false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f664ea05e4a031c766b6bff0cefcd6f3833fbb81","date":1235737223,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexReader#commit().mjava","pathOld":"src/java/org/apache/lucene/index/IndexReader#commit().mjava","sourceNew":"  /**\n   * Commit changes resulting from delete, undeleteAll, or\n   * setNorm operations\n   *\n   * If an exception is hit, then either no changes or all\n   * changes will have been committed to the index\n   * (transactional semantics).\n   * @throws IOException if there is a low-level IO error\n   */\n  protected final synchronized void commit() throws IOException {\n    commit(null);\n  }\n\n","sourceOld":"  /**\n   * Commit changes resulting from delete, undeleteAll, or\n   * setNorm operations\n   *\n   * If an exception is hit, then either no changes or all\n   * changes will have been committed to the index\n   * (transactional semantics).\n   * @throws IOException if there is a low-level IO error\n   */\n  protected final synchronized void commit() throws IOException {\n    if(hasChanges){\n      doCommit();\n    }\n    hasChanges = false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexReader#commit().mjava","pathOld":"src/java/org/apache/lucene/index/IndexReader#commit().mjava","sourceNew":"  /**\n   * Commit changes resulting from delete, undeleteAll, or\n   * setNorm operations\n   *\n   * If an exception is hit, then either no changes or all\n   * changes will have been committed to the index\n   * (transactional semantics).\n   * @throws IOException if there is a low-level IO error\n   */\n  protected final synchronized void commit() throws IOException {\n    commit(null);\n  }\n\n","sourceOld":"  /**\n   * Commit changes resulting from delete, undeleteAll, or\n   * setNorm operations\n   *\n   * If an exception is hit, then either no changes or all\n   * changes will have been committed to the index\n   * (transactional semantics).\n   * @throws IOException if there is a low-level IO error\n   */\n  protected final synchronized void commit() throws IOException {\n    commit(null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"125b5699f11b58d9be0820c6ce8b1648812902e8":["4350b17bd363cd13a95171b8df1ca62ea4c3e71c"],"f664ea05e4a031c766b6bff0cefcd6f3833fbb81":["125b5699f11b58d9be0820c6ce8b1648812902e8"],"eeefd99c477417e5c7c574228461ebafe92469d4":["284c1d3c8b19931bf6f312fae7470487f5d9e580"],"284c1d3c8b19931bf6f312fae7470487f5d9e580":["f653aecb322b74d99e6ecdb93765e453a3d7aa71"],"1b54a9bc667895a2095a886184bf69a3179e63df":["ae7060e0429fd7a6868913ef9f585e1470bdff4e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8b6187898fc4413ccd18229711786550a280383c":["1b54a9bc667895a2095a886184bf69a3179e63df"],"f653aecb322b74d99e6ecdb93765e453a3d7aa71":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ae7060e0429fd7a6868913ef9f585e1470bdff4e":["eeefd99c477417e5c7c574228461ebafe92469d4"],"4350b17bd363cd13a95171b8df1ca62ea4c3e71c":["8b6187898fc4413ccd18229711786550a280383c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["f664ea05e4a031c766b6bff0cefcd6f3833fbb81"]},"commit2Childs":{"125b5699f11b58d9be0820c6ce8b1648812902e8":["f664ea05e4a031c766b6bff0cefcd6f3833fbb81"],"f664ea05e4a031c766b6bff0cefcd6f3833fbb81":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"eeefd99c477417e5c7c574228461ebafe92469d4":["ae7060e0429fd7a6868913ef9f585e1470bdff4e"],"284c1d3c8b19931bf6f312fae7470487f5d9e580":["eeefd99c477417e5c7c574228461ebafe92469d4"],"1b54a9bc667895a2095a886184bf69a3179e63df":["8b6187898fc4413ccd18229711786550a280383c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f653aecb322b74d99e6ecdb93765e453a3d7aa71"],"8b6187898fc4413ccd18229711786550a280383c":["4350b17bd363cd13a95171b8df1ca62ea4c3e71c"],"f653aecb322b74d99e6ecdb93765e453a3d7aa71":["284c1d3c8b19931bf6f312fae7470487f5d9e580"],"ae7060e0429fd7a6868913ef9f585e1470bdff4e":["1b54a9bc667895a2095a886184bf69a3179e63df"],"4350b17bd363cd13a95171b8df1ca62ea4c3e71c":["125b5699f11b58d9be0820c6ce8b1648812902e8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}