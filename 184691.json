{"path":"lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.LongCache#createValue(AtomicReader,Entry,boolean).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.LongCache#createValue(AtomicReader,Entry,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FieldCacheImpl.LongCache#createValue(AtomicReader,Entry,boolean).mjava","sourceNew":"    @Override\n    protected Object createValue(AtomicReader reader, Entry entryKey, boolean setDocsWithField)\n        throws IOException {\n      String field = entryKey.field;\n      FieldCache.LongParser parser = (FieldCache.LongParser) entryKey.custom;\n      if (parser == null) {\n        try {\n          return wrapper.getLongs(reader, field, DEFAULT_LONG_PARSER, setDocsWithField);\n        } catch (NumberFormatException ne) {\n          return wrapper.getLongs(reader, field, NUMERIC_UTILS_LONG_PARSER, setDocsWithField);\n        }\n      }\n      final int maxDoc = reader.maxDoc();\n      long[] retArray = null;\n\n      Terms terms = reader.terms(field);\n      FixedBitSet docsWithField = null;\n      if (terms != null) {\n        if (setDocsWithField) {\n          final int termsDocCount = terms.getDocCount();\n          assert termsDocCount <= maxDoc;\n          if (termsDocCount == maxDoc) {\n            // Fast case: all docs have this field:\n            wrapper.setDocsWithField(reader, field, new Bits.MatchAllBits(maxDoc));\n            setDocsWithField = false;\n          }\n        }\n        final TermsEnum termsEnum = terms.iterator(null);\n        DocsEnum docs = null;\n        try {\n          while(true) {\n            final BytesRef term = termsEnum.next();\n            if (term == null) {\n              break;\n            }\n            final long termval = parser.parseLong(term);\n            if (retArray == null) {\n              // late init so numeric fields don't double allocate\n              retArray = new long[maxDoc];\n            }\n\n            docs = termsEnum.docs(null, docs, false);\n            while (true) {\n              final int docID = docs.nextDoc();\n              if (docID == DocsEnum.NO_MORE_DOCS) {\n                break;\n              }\n              retArray[docID] = termval;\n              if (setDocsWithField) {\n                if (docsWithField == null) {\n                  // Lazy init\n                  docsWithField = new FixedBitSet(maxDoc);\n                }\n                docsWithField.set(docID);\n              }\n            }\n          }\n        } catch (StopFillCacheException stop) {\n        }\n      }\n\n      if (retArray == null) {\n        // no values\n        retArray = new long[maxDoc];\n      }\n      if (setDocsWithField) {\n        wrapper.setDocsWithField(reader, field, docsWithField);\n      }\n      return retArray;\n    }\n\n","sourceOld":"    @Override\n    protected Object createValue(AtomicReader reader, Entry entryKey, boolean setDocsWithField)\n        throws IOException {\n      String field = entryKey.field;\n      FieldCache.LongParser parser = (FieldCache.LongParser) entryKey.custom;\n      if (parser == null) {\n        try {\n          return wrapper.getLongs(reader, field, DEFAULT_LONG_PARSER, setDocsWithField);\n        } catch (NumberFormatException ne) {\n          return wrapper.getLongs(reader, field, NUMERIC_UTILS_LONG_PARSER, setDocsWithField);\n        }\n      }\n      final int maxDoc = reader.maxDoc();\n      long[] retArray = null;\n\n      Terms terms = reader.terms(field);\n      FixedBitSet docsWithField = null;\n      if (terms != null) {\n        if (setDocsWithField) {\n          final int termsDocCount = terms.getDocCount();\n          assert termsDocCount <= maxDoc;\n          if (termsDocCount == maxDoc) {\n            // Fast case: all docs have this field:\n            wrapper.setDocsWithField(reader, field, new Bits.MatchAllBits(maxDoc));\n            setDocsWithField = false;\n          }\n        }\n        final TermsEnum termsEnum = terms.iterator(null);\n        DocsEnum docs = null;\n        try {\n          while(true) {\n            final BytesRef term = termsEnum.next();\n            if (term == null) {\n              break;\n            }\n            final long termval = parser.parseLong(term);\n            if (retArray == null) {\n              // late init so numeric fields don't double allocate\n              retArray = new long[maxDoc];\n            }\n\n            docs = termsEnum.docs(null, docs, false);\n            while (true) {\n              final int docID = docs.nextDoc();\n              if (docID == DocsEnum.NO_MORE_DOCS) {\n                break;\n              }\n              retArray[docID] = termval;\n              if (setDocsWithField) {\n                if (docsWithField == null) {\n                  // Lazy init\n                  docsWithField = new FixedBitSet(maxDoc);\n                }\n                docsWithField.set(docID);\n              }\n            }\n          }\n        } catch (StopFillCacheException stop) {\n        }\n      }\n\n      if (retArray == null) {\n        // no values\n        retArray = new long[maxDoc];\n      }\n      if (setDocsWithField) {\n        wrapper.setDocsWithField(reader, field, docsWithField);\n      }\n      return retArray;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f08557cdb6c60ac7b88a9342c983a20cd236e74f","date":1330954480,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.LongCache#createValue(AtomicReader,Entry,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.LongCache#createValue(AtomicReader,Entry,boolean).mjava","sourceNew":"    @Override\n    protected Object createValue(AtomicReader reader, Entry entryKey, boolean setDocsWithField)\n        throws IOException {\n      String field = entryKey.field;\n      FieldCache.LongParser parser = (FieldCache.LongParser) entryKey.custom;\n      if (parser == null) {\n        try {\n          return wrapper.getLongs(reader, field, DEFAULT_LONG_PARSER, setDocsWithField);\n        } catch (NumberFormatException ne) {\n          return wrapper.getLongs(reader, field, NUMERIC_UTILS_LONG_PARSER, setDocsWithField);\n        }\n      }\n      final int maxDoc = reader.maxDoc();\n      long[] retArray = null;\n\n      Terms terms = reader.terms(field);\n      FixedBitSet docsWithField = null;\n      if (terms != null) {\n        if (setDocsWithField) {\n          final int termsDocCount = terms.getDocCount();\n          assert termsDocCount <= maxDoc;\n          if (termsDocCount == maxDoc) {\n            // Fast case: all docs have this field:\n            wrapper.setDocsWithField(reader, field, new Bits.MatchAllBits(maxDoc));\n            setDocsWithField = false;\n          }\n        }\n        final TermsEnum termsEnum = terms.iterator(null);\n        DocsEnum docs = null;\n        try {\n          while(true) {\n            final BytesRef term = termsEnum.next();\n            if (term == null) {\n              break;\n            }\n            final long termval = parser.parseLong(term);\n            if (retArray == null) {\n              // late init so numeric fields don't double allocate\n              retArray = new long[maxDoc];\n            }\n\n            docs = termsEnum.docs(null, docs, false);\n            while (true) {\n              final int docID = docs.nextDoc();\n              if (docID == DocIdSetIterator.NO_MORE_DOCS) {\n                break;\n              }\n              retArray[docID] = termval;\n              if (setDocsWithField) {\n                if (docsWithField == null) {\n                  // Lazy init\n                  docsWithField = new FixedBitSet(maxDoc);\n                }\n                docsWithField.set(docID);\n              }\n            }\n          }\n        } catch (StopFillCacheException stop) {\n        }\n      }\n\n      if (retArray == null) {\n        // no values\n        retArray = new long[maxDoc];\n      }\n      if (setDocsWithField) {\n        wrapper.setDocsWithField(reader, field, docsWithField);\n      }\n      return retArray;\n    }\n\n","sourceOld":"    @Override\n    protected Object createValue(AtomicReader reader, Entry entryKey, boolean setDocsWithField)\n        throws IOException {\n      String field = entryKey.field;\n      FieldCache.LongParser parser = (FieldCache.LongParser) entryKey.custom;\n      if (parser == null) {\n        try {\n          return wrapper.getLongs(reader, field, DEFAULT_LONG_PARSER, setDocsWithField);\n        } catch (NumberFormatException ne) {\n          return wrapper.getLongs(reader, field, NUMERIC_UTILS_LONG_PARSER, setDocsWithField);\n        }\n      }\n      final int maxDoc = reader.maxDoc();\n      long[] retArray = null;\n\n      Terms terms = reader.terms(field);\n      FixedBitSet docsWithField = null;\n      if (terms != null) {\n        if (setDocsWithField) {\n          final int termsDocCount = terms.getDocCount();\n          assert termsDocCount <= maxDoc;\n          if (termsDocCount == maxDoc) {\n            // Fast case: all docs have this field:\n            wrapper.setDocsWithField(reader, field, new Bits.MatchAllBits(maxDoc));\n            setDocsWithField = false;\n          }\n        }\n        final TermsEnum termsEnum = terms.iterator(null);\n        DocsEnum docs = null;\n        try {\n          while(true) {\n            final BytesRef term = termsEnum.next();\n            if (term == null) {\n              break;\n            }\n            final long termval = parser.parseLong(term);\n            if (retArray == null) {\n              // late init so numeric fields don't double allocate\n              retArray = new long[maxDoc];\n            }\n\n            docs = termsEnum.docs(null, docs, false);\n            while (true) {\n              final int docID = docs.nextDoc();\n              if (docID == DocsEnum.NO_MORE_DOCS) {\n                break;\n              }\n              retArray[docID] = termval;\n              if (setDocsWithField) {\n                if (docsWithField == null) {\n                  // Lazy init\n                  docsWithField = new FixedBitSet(maxDoc);\n                }\n                docsWithField.set(docID);\n              }\n            }\n          }\n        } catch (StopFillCacheException stop) {\n        }\n      }\n\n      if (retArray == null) {\n        // no values\n        retArray = new long[maxDoc];\n      }\n      if (setDocsWithField) {\n        wrapper.setDocsWithField(reader, field, docsWithField);\n      }\n      return retArray;\n    }\n\n","bugFix":null,"bugIntro":["edc944077593063d718a895a9d7afdf6895d6685"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.LongCache#createValue(AtomicReader,Entry,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.LongCache#createValue(AtomicReader,Entry,boolean).mjava","sourceNew":"    @Override\n    protected Object createValue(AtomicReader reader, Entry entryKey, boolean setDocsWithField)\n        throws IOException {\n      String field = entryKey.field;\n      FieldCache.LongParser parser = (FieldCache.LongParser) entryKey.custom;\n      if (parser == null) {\n        try {\n          return wrapper.getLongs(reader, field, DEFAULT_LONG_PARSER, setDocsWithField);\n        } catch (NumberFormatException ne) {\n          return wrapper.getLongs(reader, field, NUMERIC_UTILS_LONG_PARSER, setDocsWithField);\n        }\n      }\n      final int maxDoc = reader.maxDoc();\n      long[] retArray = null;\n\n      Terms terms = reader.terms(field);\n      FixedBitSet docsWithField = null;\n      if (terms != null) {\n        if (setDocsWithField) {\n          final int termsDocCount = terms.getDocCount();\n          assert termsDocCount <= maxDoc;\n          if (termsDocCount == maxDoc) {\n            // Fast case: all docs have this field:\n            wrapper.setDocsWithField(reader, field, new Bits.MatchAllBits(maxDoc));\n            setDocsWithField = false;\n          }\n        }\n        final TermsEnum termsEnum = terms.iterator(null);\n        DocsEnum docs = null;\n        try {\n          while(true) {\n            final BytesRef term = termsEnum.next();\n            if (term == null) {\n              break;\n            }\n            final long termval = parser.parseLong(term);\n            if (retArray == null) {\n              // late init so numeric fields don't double allocate\n              retArray = new long[maxDoc];\n            }\n\n            docs = termsEnum.docs(null, docs, false);\n            while (true) {\n              final int docID = docs.nextDoc();\n              if (docID == DocIdSetIterator.NO_MORE_DOCS) {\n                break;\n              }\n              retArray[docID] = termval;\n              if (setDocsWithField) {\n                if (docsWithField == null) {\n                  // Lazy init\n                  docsWithField = new FixedBitSet(maxDoc);\n                }\n                docsWithField.set(docID);\n              }\n            }\n          }\n        } catch (StopFillCacheException stop) {\n        }\n      }\n\n      if (retArray == null) {\n        // no values\n        retArray = new long[maxDoc];\n      }\n      if (setDocsWithField) {\n        wrapper.setDocsWithField(reader, field, docsWithField);\n      }\n      return retArray;\n    }\n\n","sourceOld":"    @Override\n    protected Object createValue(AtomicReader reader, Entry entryKey, boolean setDocsWithField)\n        throws IOException {\n      String field = entryKey.field;\n      FieldCache.LongParser parser = (FieldCache.LongParser) entryKey.custom;\n      if (parser == null) {\n        try {\n          return wrapper.getLongs(reader, field, DEFAULT_LONG_PARSER, setDocsWithField);\n        } catch (NumberFormatException ne) {\n          return wrapper.getLongs(reader, field, NUMERIC_UTILS_LONG_PARSER, setDocsWithField);\n        }\n      }\n      final int maxDoc = reader.maxDoc();\n      long[] retArray = null;\n\n      Terms terms = reader.terms(field);\n      FixedBitSet docsWithField = null;\n      if (terms != null) {\n        if (setDocsWithField) {\n          final int termsDocCount = terms.getDocCount();\n          assert termsDocCount <= maxDoc;\n          if (termsDocCount == maxDoc) {\n            // Fast case: all docs have this field:\n            wrapper.setDocsWithField(reader, field, new Bits.MatchAllBits(maxDoc));\n            setDocsWithField = false;\n          }\n        }\n        final TermsEnum termsEnum = terms.iterator(null);\n        DocsEnum docs = null;\n        try {\n          while(true) {\n            final BytesRef term = termsEnum.next();\n            if (term == null) {\n              break;\n            }\n            final long termval = parser.parseLong(term);\n            if (retArray == null) {\n              // late init so numeric fields don't double allocate\n              retArray = new long[maxDoc];\n            }\n\n            docs = termsEnum.docs(null, docs, false);\n            while (true) {\n              final int docID = docs.nextDoc();\n              if (docID == DocsEnum.NO_MORE_DOCS) {\n                break;\n              }\n              retArray[docID] = termval;\n              if (setDocsWithField) {\n                if (docsWithField == null) {\n                  // Lazy init\n                  docsWithField = new FixedBitSet(maxDoc);\n                }\n                docsWithField.set(docID);\n              }\n            }\n          }\n        } catch (StopFillCacheException stop) {\n        }\n      }\n\n      if (retArray == null) {\n        // no values\n        retArray = new long[maxDoc];\n      }\n      if (setDocsWithField) {\n        wrapper.setDocsWithField(reader, field, docsWithField);\n      }\n      return retArray;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e7ae10c50f71c27f38db329bd22245ebc97196fd","date":1339941370,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.LongCache#createValue(AtomicReader,Entry,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.LongCache#createValue(AtomicReader,Entry,boolean).mjava","sourceNew":"    @Override\n    protected Object createValue(AtomicReader reader, Entry entryKey, boolean setDocsWithField)\n        throws IOException {\n      String field = entryKey.field;\n      FieldCache.LongParser parser = (FieldCache.LongParser) entryKey.custom;\n      if (parser == null) {\n        try {\n          return wrapper.getLongs(reader, field, DEFAULT_LONG_PARSER, setDocsWithField);\n        } catch (NumberFormatException ne) {\n          return wrapper.getLongs(reader, field, NUMERIC_UTILS_LONG_PARSER, setDocsWithField);\n        }\n      }\n      final int maxDoc = reader.maxDoc();\n      long[] retArray = null;\n\n      Terms terms = reader.terms(field);\n      FixedBitSet docsWithField = null;\n      if (terms != null) {\n        if (setDocsWithField) {\n          final int termsDocCount = terms.getDocCount();\n          assert termsDocCount <= maxDoc;\n          if (termsDocCount == maxDoc) {\n            // Fast case: all docs have this field:\n            wrapper.setDocsWithField(reader, field, new Bits.MatchAllBits(maxDoc));\n            setDocsWithField = false;\n          }\n        }\n        final TermsEnum termsEnum = terms.iterator(null);\n        DocsEnum docs = null;\n        try {\n          while(true) {\n            final BytesRef term = termsEnum.next();\n            if (term == null) {\n              break;\n            }\n            final long termval = parser.parseLong(term);\n            if (retArray == null) {\n              // late init so numeric fields don't double allocate\n              retArray = new long[maxDoc];\n            }\n\n            docs = termsEnum.docs(null, docs, false);\n            while (true) {\n              final int docID = docs.nextDoc();\n              if (docID == DocIdSetIterator.NO_MORE_DOCS) {\n                break;\n              }\n              retArray[docID] = termval;\n              if (setDocsWithField) {\n                if (docsWithField == null) {\n                  // Lazy init\n                  docsWithField = new FixedBitSet(maxDoc);\n                }\n                docsWithField.set(docID);\n              }\n            }\n          }\n        } catch (FieldCache.StopFillCacheException stop) {\n        }\n      }\n\n      if (retArray == null) {\n        // no values\n        retArray = new long[maxDoc];\n      }\n      if (setDocsWithField) {\n        wrapper.setDocsWithField(reader, field, docsWithField);\n      }\n      return retArray;\n    }\n\n","sourceOld":"    @Override\n    protected Object createValue(AtomicReader reader, Entry entryKey, boolean setDocsWithField)\n        throws IOException {\n      String field = entryKey.field;\n      FieldCache.LongParser parser = (FieldCache.LongParser) entryKey.custom;\n      if (parser == null) {\n        try {\n          return wrapper.getLongs(reader, field, DEFAULT_LONG_PARSER, setDocsWithField);\n        } catch (NumberFormatException ne) {\n          return wrapper.getLongs(reader, field, NUMERIC_UTILS_LONG_PARSER, setDocsWithField);\n        }\n      }\n      final int maxDoc = reader.maxDoc();\n      long[] retArray = null;\n\n      Terms terms = reader.terms(field);\n      FixedBitSet docsWithField = null;\n      if (terms != null) {\n        if (setDocsWithField) {\n          final int termsDocCount = terms.getDocCount();\n          assert termsDocCount <= maxDoc;\n          if (termsDocCount == maxDoc) {\n            // Fast case: all docs have this field:\n            wrapper.setDocsWithField(reader, field, new Bits.MatchAllBits(maxDoc));\n            setDocsWithField = false;\n          }\n        }\n        final TermsEnum termsEnum = terms.iterator(null);\n        DocsEnum docs = null;\n        try {\n          while(true) {\n            final BytesRef term = termsEnum.next();\n            if (term == null) {\n              break;\n            }\n            final long termval = parser.parseLong(term);\n            if (retArray == null) {\n              // late init so numeric fields don't double allocate\n              retArray = new long[maxDoc];\n            }\n\n            docs = termsEnum.docs(null, docs, false);\n            while (true) {\n              final int docID = docs.nextDoc();\n              if (docID == DocIdSetIterator.NO_MORE_DOCS) {\n                break;\n              }\n              retArray[docID] = termval;\n              if (setDocsWithField) {\n                if (docsWithField == null) {\n                  // Lazy init\n                  docsWithField = new FixedBitSet(maxDoc);\n                }\n                docsWithField.set(docID);\n              }\n            }\n          }\n        } catch (StopFillCacheException stop) {\n        }\n      }\n\n      if (retArray == null) {\n        // no values\n        retArray = new long[maxDoc];\n      }\n      if (setDocsWithField) {\n        wrapper.setDocsWithField(reader, field, docsWithField);\n      }\n      return retArray;\n    }\n\n","bugFix":["382fe3a6ca9745891afebda9b9a57cc158305545"],"bugIntro":["edc944077593063d718a895a9d7afdf6895d6685"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"02331260bb246364779cb6f04919ca47900d01bb","date":1343749884,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.LongCache#createValue(AtomicReader,Entry,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.LongCache#createValue(AtomicReader,Entry,boolean).mjava","sourceNew":"    @Override\n    protected Object createValue(AtomicReader reader, Entry entryKey, boolean setDocsWithField)\n        throws IOException {\n      String field = entryKey.field;\n      FieldCache.LongParser parser = (FieldCache.LongParser) entryKey.custom;\n      if (parser == null) {\n        try {\n          return wrapper.getLongs(reader, field, DEFAULT_LONG_PARSER, setDocsWithField);\n        } catch (NumberFormatException ne) {\n          return wrapper.getLongs(reader, field, NUMERIC_UTILS_LONG_PARSER, setDocsWithField);\n        }\n      }\n      final int maxDoc = reader.maxDoc();\n      long[] retArray = null;\n\n      Terms terms = reader.terms(field);\n      FixedBitSet docsWithField = null;\n      if (terms != null) {\n        if (setDocsWithField) {\n          final int termsDocCount = terms.getDocCount();\n          assert termsDocCount <= maxDoc;\n          if (termsDocCount == maxDoc) {\n            // Fast case: all docs have this field:\n            wrapper.setDocsWithField(reader, field, new Bits.MatchAllBits(maxDoc));\n            setDocsWithField = false;\n          }\n        }\n        final TermsEnum termsEnum = terms.iterator(null);\n        DocsEnum docs = null;\n        try {\n          while(true) {\n            final BytesRef term = termsEnum.next();\n            if (term == null) {\n              break;\n            }\n            final long termval = parser.parseLong(term);\n            if (retArray == null) {\n              // late init so numeric fields don't double allocate\n              retArray = new long[maxDoc];\n            }\n\n            docs = termsEnum.docs(null, docs, 0);\n            while (true) {\n              final int docID = docs.nextDoc();\n              if (docID == DocIdSetIterator.NO_MORE_DOCS) {\n                break;\n              }\n              retArray[docID] = termval;\n              if (setDocsWithField) {\n                if (docsWithField == null) {\n                  // Lazy init\n                  docsWithField = new FixedBitSet(maxDoc);\n                }\n                docsWithField.set(docID);\n              }\n            }\n          }\n        } catch (FieldCache.StopFillCacheException stop) {\n        }\n      }\n\n      if (retArray == null) {\n        // no values\n        retArray = new long[maxDoc];\n      }\n      if (setDocsWithField) {\n        wrapper.setDocsWithField(reader, field, docsWithField);\n      }\n      return retArray;\n    }\n\n","sourceOld":"    @Override\n    protected Object createValue(AtomicReader reader, Entry entryKey, boolean setDocsWithField)\n        throws IOException {\n      String field = entryKey.field;\n      FieldCache.LongParser parser = (FieldCache.LongParser) entryKey.custom;\n      if (parser == null) {\n        try {\n          return wrapper.getLongs(reader, field, DEFAULT_LONG_PARSER, setDocsWithField);\n        } catch (NumberFormatException ne) {\n          return wrapper.getLongs(reader, field, NUMERIC_UTILS_LONG_PARSER, setDocsWithField);\n        }\n      }\n      final int maxDoc = reader.maxDoc();\n      long[] retArray = null;\n\n      Terms terms = reader.terms(field);\n      FixedBitSet docsWithField = null;\n      if (terms != null) {\n        if (setDocsWithField) {\n          final int termsDocCount = terms.getDocCount();\n          assert termsDocCount <= maxDoc;\n          if (termsDocCount == maxDoc) {\n            // Fast case: all docs have this field:\n            wrapper.setDocsWithField(reader, field, new Bits.MatchAllBits(maxDoc));\n            setDocsWithField = false;\n          }\n        }\n        final TermsEnum termsEnum = terms.iterator(null);\n        DocsEnum docs = null;\n        try {\n          while(true) {\n            final BytesRef term = termsEnum.next();\n            if (term == null) {\n              break;\n            }\n            final long termval = parser.parseLong(term);\n            if (retArray == null) {\n              // late init so numeric fields don't double allocate\n              retArray = new long[maxDoc];\n            }\n\n            docs = termsEnum.docs(null, docs, false);\n            while (true) {\n              final int docID = docs.nextDoc();\n              if (docID == DocIdSetIterator.NO_MORE_DOCS) {\n                break;\n              }\n              retArray[docID] = termval;\n              if (setDocsWithField) {\n                if (docsWithField == null) {\n                  // Lazy init\n                  docsWithField = new FixedBitSet(maxDoc);\n                }\n                docsWithField.set(docID);\n              }\n            }\n          }\n        } catch (FieldCache.StopFillCacheException stop) {\n        }\n      }\n\n      if (retArray == null) {\n        // no values\n        retArray = new long[maxDoc];\n      }\n      if (setDocsWithField) {\n        wrapper.setDocsWithField(reader, field, docsWithField);\n      }\n      return retArray;\n    }\n\n","bugFix":["872cff1d3a554e0cd64014cd97f88d3002b0f491"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","date":1343768312,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.LongCache#createValue(AtomicReader,Entry,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.LongCache#createValue(AtomicReader,Entry,boolean).mjava","sourceNew":"    @Override\n    protected Object createValue(AtomicReader reader, Entry entryKey, boolean setDocsWithField)\n        throws IOException {\n      String field = entryKey.field;\n      FieldCache.LongParser parser = (FieldCache.LongParser) entryKey.custom;\n      if (parser == null) {\n        try {\n          return wrapper.getLongs(reader, field, DEFAULT_LONG_PARSER, setDocsWithField);\n        } catch (NumberFormatException ne) {\n          return wrapper.getLongs(reader, field, NUMERIC_UTILS_LONG_PARSER, setDocsWithField);\n        }\n      }\n      final int maxDoc = reader.maxDoc();\n      long[] retArray = null;\n\n      Terms terms = reader.terms(field);\n      FixedBitSet docsWithField = null;\n      if (terms != null) {\n        if (setDocsWithField) {\n          final int termsDocCount = terms.getDocCount();\n          assert termsDocCount <= maxDoc;\n          if (termsDocCount == maxDoc) {\n            // Fast case: all docs have this field:\n            wrapper.setDocsWithField(reader, field, new Bits.MatchAllBits(maxDoc));\n            setDocsWithField = false;\n          }\n        }\n        final TermsEnum termsEnum = terms.iterator(null);\n        DocsEnum docs = null;\n        try {\n          while(true) {\n            final BytesRef term = termsEnum.next();\n            if (term == null) {\n              break;\n            }\n            final long termval = parser.parseLong(term);\n            if (retArray == null) {\n              // late init so numeric fields don't double allocate\n              retArray = new long[maxDoc];\n            }\n\n            docs = termsEnum.docs(null, docs, 0);\n            while (true) {\n              final int docID = docs.nextDoc();\n              if (docID == DocIdSetIterator.NO_MORE_DOCS) {\n                break;\n              }\n              retArray[docID] = termval;\n              if (setDocsWithField) {\n                if (docsWithField == null) {\n                  // Lazy init\n                  docsWithField = new FixedBitSet(maxDoc);\n                }\n                docsWithField.set(docID);\n              }\n            }\n          }\n        } catch (FieldCache.StopFillCacheException stop) {\n        }\n      }\n\n      if (retArray == null) {\n        // no values\n        retArray = new long[maxDoc];\n      }\n      if (setDocsWithField) {\n        wrapper.setDocsWithField(reader, field, docsWithField);\n      }\n      return retArray;\n    }\n\n","sourceOld":"    @Override\n    protected Object createValue(AtomicReader reader, Entry entryKey, boolean setDocsWithField)\n        throws IOException {\n      String field = entryKey.field;\n      FieldCache.LongParser parser = (FieldCache.LongParser) entryKey.custom;\n      if (parser == null) {\n        try {\n          return wrapper.getLongs(reader, field, DEFAULT_LONG_PARSER, setDocsWithField);\n        } catch (NumberFormatException ne) {\n          return wrapper.getLongs(reader, field, NUMERIC_UTILS_LONG_PARSER, setDocsWithField);\n        }\n      }\n      final int maxDoc = reader.maxDoc();\n      long[] retArray = null;\n\n      Terms terms = reader.terms(field);\n      FixedBitSet docsWithField = null;\n      if (terms != null) {\n        if (setDocsWithField) {\n          final int termsDocCount = terms.getDocCount();\n          assert termsDocCount <= maxDoc;\n          if (termsDocCount == maxDoc) {\n            // Fast case: all docs have this field:\n            wrapper.setDocsWithField(reader, field, new Bits.MatchAllBits(maxDoc));\n            setDocsWithField = false;\n          }\n        }\n        final TermsEnum termsEnum = terms.iterator(null);\n        DocsEnum docs = null;\n        try {\n          while(true) {\n            final BytesRef term = termsEnum.next();\n            if (term == null) {\n              break;\n            }\n            final long termval = parser.parseLong(term);\n            if (retArray == null) {\n              // late init so numeric fields don't double allocate\n              retArray = new long[maxDoc];\n            }\n\n            docs = termsEnum.docs(null, docs, false);\n            while (true) {\n              final int docID = docs.nextDoc();\n              if (docID == DocIdSetIterator.NO_MORE_DOCS) {\n                break;\n              }\n              retArray[docID] = termval;\n              if (setDocsWithField) {\n                if (docsWithField == null) {\n                  // Lazy init\n                  docsWithField = new FixedBitSet(maxDoc);\n                }\n                docsWithField.set(docID);\n              }\n            }\n          }\n        } catch (FieldCache.StopFillCacheException stop) {\n        }\n      }\n\n      if (retArray == null) {\n        // no values\n        retArray = new long[maxDoc];\n      }\n      if (setDocsWithField) {\n        wrapper.setDocsWithField(reader, field, docsWithField);\n      }\n      return retArray;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.LongCache#createValue(AtomicReader,Entry,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.LongCache#createValue(AtomicReader,Entry,boolean).mjava","sourceNew":"    @Override\n    protected Object createValue(AtomicReader reader, Entry entryKey, boolean setDocsWithField)\n        throws IOException {\n      String field = entryKey.field;\n      FieldCache.LongParser parser = (FieldCache.LongParser) entryKey.custom;\n      if (parser == null) {\n        try {\n          return wrapper.getLongs(reader, field, DEFAULT_LONG_PARSER, setDocsWithField);\n        } catch (NumberFormatException ne) {\n          return wrapper.getLongs(reader, field, NUMERIC_UTILS_LONG_PARSER, setDocsWithField);\n        }\n      }\n      final int maxDoc = reader.maxDoc();\n      long[] retArray = null;\n\n      Terms terms = reader.terms(field);\n      FixedBitSet docsWithField = null;\n      if (terms != null) {\n        if (setDocsWithField) {\n          final int termsDocCount = terms.getDocCount();\n          assert termsDocCount <= maxDoc;\n          if (termsDocCount == maxDoc) {\n            // Fast case: all docs have this field:\n            wrapper.setDocsWithField(reader, field, new Bits.MatchAllBits(maxDoc));\n            setDocsWithField = false;\n          }\n        }\n        final TermsEnum termsEnum = terms.iterator(null);\n        DocsEnum docs = null;\n        try {\n          while(true) {\n            final BytesRef term = termsEnum.next();\n            if (term == null) {\n              break;\n            }\n            final long termval = parser.parseLong(term);\n            if (retArray == null) {\n              // late init so numeric fields don't double allocate\n              retArray = new long[maxDoc];\n            }\n\n            docs = termsEnum.docs(null, docs, 0);\n            while (true) {\n              final int docID = docs.nextDoc();\n              if (docID == DocIdSetIterator.NO_MORE_DOCS) {\n                break;\n              }\n              retArray[docID] = termval;\n              if (setDocsWithField) {\n                if (docsWithField == null) {\n                  // Lazy init\n                  docsWithField = new FixedBitSet(maxDoc);\n                }\n                docsWithField.set(docID);\n              }\n            }\n          }\n        } catch (FieldCache.StopFillCacheException stop) {\n        }\n      }\n\n      if (retArray == null) {\n        // no values\n        retArray = new long[maxDoc];\n      }\n      if (setDocsWithField) {\n        wrapper.setDocsWithField(reader, field, docsWithField);\n      }\n      return retArray;\n    }\n\n","sourceOld":"    @Override\n    protected Object createValue(AtomicReader reader, Entry entryKey, boolean setDocsWithField)\n        throws IOException {\n      String field = entryKey.field;\n      FieldCache.LongParser parser = (FieldCache.LongParser) entryKey.custom;\n      if (parser == null) {\n        try {\n          return wrapper.getLongs(reader, field, DEFAULT_LONG_PARSER, setDocsWithField);\n        } catch (NumberFormatException ne) {\n          return wrapper.getLongs(reader, field, NUMERIC_UTILS_LONG_PARSER, setDocsWithField);\n        }\n      }\n      final int maxDoc = reader.maxDoc();\n      long[] retArray = null;\n\n      Terms terms = reader.terms(field);\n      FixedBitSet docsWithField = null;\n      if (terms != null) {\n        if (setDocsWithField) {\n          final int termsDocCount = terms.getDocCount();\n          assert termsDocCount <= maxDoc;\n          if (termsDocCount == maxDoc) {\n            // Fast case: all docs have this field:\n            wrapper.setDocsWithField(reader, field, new Bits.MatchAllBits(maxDoc));\n            setDocsWithField = false;\n          }\n        }\n        final TermsEnum termsEnum = terms.iterator(null);\n        DocsEnum docs = null;\n        try {\n          while(true) {\n            final BytesRef term = termsEnum.next();\n            if (term == null) {\n              break;\n            }\n            final long termval = parser.parseLong(term);\n            if (retArray == null) {\n              // late init so numeric fields don't double allocate\n              retArray = new long[maxDoc];\n            }\n\n            docs = termsEnum.docs(null, docs, false);\n            while (true) {\n              final int docID = docs.nextDoc();\n              if (docID == DocIdSetIterator.NO_MORE_DOCS) {\n                break;\n              }\n              retArray[docID] = termval;\n              if (setDocsWithField) {\n                if (docsWithField == null) {\n                  // Lazy init\n                  docsWithField = new FixedBitSet(maxDoc);\n                }\n                docsWithField.set(docID);\n              }\n            }\n          }\n        } catch (FieldCache.StopFillCacheException stop) {\n        }\n      }\n\n      if (retArray == null) {\n        // no values\n        retArray = new long[maxDoc];\n      }\n      if (setDocsWithField) {\n        wrapper.setDocsWithField(reader, field, docsWithField);\n      }\n      return retArray;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f45457a742a53533c348c4b990b1c579ff364467","date":1353197071,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.LongCache#createValue(AtomicReader,Entry,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.LongCache#createValue(AtomicReader,Entry,boolean).mjava","sourceNew":"    @Override\n    protected Object createValue(AtomicReader reader, Entry entryKey, boolean setDocsWithField)\n        throws IOException {\n      LongParser parser = (LongParser) entryKey.custom;\n      if (parser == null) {\n        // Confusing: must delegate to wrapper (vs simply\n        // setting parser =\n        // DEFAULT_LONG_PARSER/NUMERIC_UTILS_LONG_PARSER) so\n        // cache key includes\n        // DEFAULT_LONG_PARSER/NUMERIC_UTILS_LONG_PARSER:\n        try {\n          return wrapper.getLongs(reader, entryKey.field, DEFAULT_LONG_PARSER, setDocsWithField);\n        } catch (NumberFormatException ne) {\n          return wrapper.getLongs(reader, entryKey.field, NUMERIC_UTILS_LONG_PARSER, setDocsWithField);\n        }\n      }\n\n      final LongParser finalParser = parser;\n      // nocommit how to avoid double alloc in numeric field\n      // case ...\n      final long[] values = new long[reader.maxDoc()];\n\n      Uninvert u = new Uninvert() {\n        private long currentValue;\n\n        @Override\n        public void visitTerm(BytesRef term) {\n          currentValue = finalParser.parseLong(term);\n        }\n\n        @Override\n        public void visitDoc(int docID) {\n          values[docID] = currentValue;\n        }\n      };\n\n      u.uninvert(reader, entryKey.field, setDocsWithField);\n\n      if (setDocsWithField) {\n        wrapper.setDocsWithField(reader, entryKey.field, u.docsWithField);\n      }\n\n      return new LongsFromArray(values);\n    }\n\n","sourceOld":"    @Override\n    protected Object createValue(AtomicReader reader, Entry entryKey, boolean setDocsWithField)\n        throws IOException {\n      String field = entryKey.field;\n      FieldCache.LongParser parser = (FieldCache.LongParser) entryKey.custom;\n      if (parser == null) {\n        try {\n          return wrapper.getLongs(reader, field, DEFAULT_LONG_PARSER, setDocsWithField);\n        } catch (NumberFormatException ne) {\n          return wrapper.getLongs(reader, field, NUMERIC_UTILS_LONG_PARSER, setDocsWithField);\n        }\n      }\n      final int maxDoc = reader.maxDoc();\n      long[] retArray = null;\n\n      Terms terms = reader.terms(field);\n      FixedBitSet docsWithField = null;\n      if (terms != null) {\n        if (setDocsWithField) {\n          final int termsDocCount = terms.getDocCount();\n          assert termsDocCount <= maxDoc;\n          if (termsDocCount == maxDoc) {\n            // Fast case: all docs have this field:\n            wrapper.setDocsWithField(reader, field, new Bits.MatchAllBits(maxDoc));\n            setDocsWithField = false;\n          }\n        }\n        final TermsEnum termsEnum = terms.iterator(null);\n        DocsEnum docs = null;\n        try {\n          while(true) {\n            final BytesRef term = termsEnum.next();\n            if (term == null) {\n              break;\n            }\n            final long termval = parser.parseLong(term);\n            if (retArray == null) {\n              // late init so numeric fields don't double allocate\n              retArray = new long[maxDoc];\n            }\n\n            docs = termsEnum.docs(null, docs, 0);\n            while (true) {\n              final int docID = docs.nextDoc();\n              if (docID == DocIdSetIterator.NO_MORE_DOCS) {\n                break;\n              }\n              retArray[docID] = termval;\n              if (setDocsWithField) {\n                if (docsWithField == null) {\n                  // Lazy init\n                  docsWithField = new FixedBitSet(maxDoc);\n                }\n                docsWithField.set(docID);\n              }\n            }\n          }\n        } catch (FieldCache.StopFillCacheException stop) {\n        }\n      }\n\n      if (retArray == null) {\n        // no values\n        retArray = new long[maxDoc];\n      }\n      if (setDocsWithField) {\n        wrapper.setDocsWithField(reader, field, docsWithField);\n      }\n      return retArray;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a4d374b2bebd0d52acaa61038fbf23068620fba7","date":1353240004,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.LongCache#createValue(AtomicReader,Entry,boolean).mjava","sourceNew":null,"sourceOld":"    @Override\n    protected Object createValue(AtomicReader reader, Entry entryKey, boolean setDocsWithField)\n        throws IOException {\n      LongParser parser = (LongParser) entryKey.custom;\n      if (parser == null) {\n        // Confusing: must delegate to wrapper (vs simply\n        // setting parser =\n        // DEFAULT_LONG_PARSER/NUMERIC_UTILS_LONG_PARSER) so\n        // cache key includes\n        // DEFAULT_LONG_PARSER/NUMERIC_UTILS_LONG_PARSER:\n        try {\n          return wrapper.getLongs(reader, entryKey.field, DEFAULT_LONG_PARSER, setDocsWithField);\n        } catch (NumberFormatException ne) {\n          return wrapper.getLongs(reader, entryKey.field, NUMERIC_UTILS_LONG_PARSER, setDocsWithField);\n        }\n      }\n\n      final LongParser finalParser = parser;\n      // nocommit how to avoid double alloc in numeric field\n      // case ...\n      final long[] values = new long[reader.maxDoc()];\n\n      Uninvert u = new Uninvert() {\n        private long currentValue;\n\n        @Override\n        public void visitTerm(BytesRef term) {\n          currentValue = finalParser.parseLong(term);\n        }\n\n        @Override\n        public void visitDoc(int docID) {\n          values[docID] = currentValue;\n        }\n      };\n\n      u.uninvert(reader, entryKey.field, setDocsWithField);\n\n      if (setDocsWithField) {\n        wrapper.setDocsWithField(reader, entryKey.field, u.docsWithField);\n      }\n\n      return new LongsFromArray(values);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"15250ca94ba8ab3bcdd476daf6bf3f3febb92640","date":1355200097,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.LongCache#createValue(AtomicReader,Entry,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.LongCache#createValue(AtomicReader,Entry,boolean).mjava","sourceNew":"    @Override\n    protected Object createValue(AtomicReader reader, Entry entryKey, boolean setDocsWithField)\n        throws IOException {\n      String field = entryKey.field;\n      FieldCache.LongParser parser = (FieldCache.LongParser) entryKey.custom;\n      if (parser == null) {\n        try {\n          return wrapper.getLongs(reader, field, DEFAULT_LONG_PARSER, setDocsWithField);\n        } catch (NumberFormatException ne) {\n          return wrapper.getLongs(reader, field, NUMERIC_UTILS_LONG_PARSER, setDocsWithField);\n        }\n      }\n      final int maxDoc = reader.maxDoc();\n      long[] retArray = null;\n\n      Terms terms = reader.terms(field);\n      FixedBitSet docsWithField = null;\n      if (terms != null) {\n        if (setDocsWithField) {\n          final int termsDocCount = terms.getDocCount();\n          assert termsDocCount <= maxDoc;\n          if (termsDocCount == maxDoc) {\n            // Fast case: all docs have this field:\n            wrapper.setDocsWithField(reader, field, new Bits.MatchAllBits(maxDoc));\n            setDocsWithField = false;\n          }\n        }\n        final TermsEnum termsEnum = terms.iterator(null);\n        DocsEnum docs = null;\n        try {\n          while(true) {\n            final BytesRef term = termsEnum.next();\n            if (term == null) {\n              break;\n            }\n            final long termval = parser.parseLong(term);\n            if (retArray == null) {\n              // late init so numeric fields don't double allocate\n              retArray = new long[maxDoc];\n            }\n\n            docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);\n            while (true) {\n              final int docID = docs.nextDoc();\n              if (docID == DocIdSetIterator.NO_MORE_DOCS) {\n                break;\n              }\n              retArray[docID] = termval;\n              if (setDocsWithField) {\n                if (docsWithField == null) {\n                  // Lazy init\n                  docsWithField = new FixedBitSet(maxDoc);\n                }\n                docsWithField.set(docID);\n              }\n            }\n          }\n        } catch (FieldCache.StopFillCacheException stop) {\n        }\n      }\n\n      if (retArray == null) {\n        // no values\n        retArray = new long[maxDoc];\n      }\n      if (setDocsWithField) {\n        wrapper.setDocsWithField(reader, field, docsWithField);\n      }\n      return retArray;\n    }\n\n","sourceOld":"    @Override\n    protected Object createValue(AtomicReader reader, Entry entryKey, boolean setDocsWithField)\n        throws IOException {\n      String field = entryKey.field;\n      FieldCache.LongParser parser = (FieldCache.LongParser) entryKey.custom;\n      if (parser == null) {\n        try {\n          return wrapper.getLongs(reader, field, DEFAULT_LONG_PARSER, setDocsWithField);\n        } catch (NumberFormatException ne) {\n          return wrapper.getLongs(reader, field, NUMERIC_UTILS_LONG_PARSER, setDocsWithField);\n        }\n      }\n      final int maxDoc = reader.maxDoc();\n      long[] retArray = null;\n\n      Terms terms = reader.terms(field);\n      FixedBitSet docsWithField = null;\n      if (terms != null) {\n        if (setDocsWithField) {\n          final int termsDocCount = terms.getDocCount();\n          assert termsDocCount <= maxDoc;\n          if (termsDocCount == maxDoc) {\n            // Fast case: all docs have this field:\n            wrapper.setDocsWithField(reader, field, new Bits.MatchAllBits(maxDoc));\n            setDocsWithField = false;\n          }\n        }\n        final TermsEnum termsEnum = terms.iterator(null);\n        DocsEnum docs = null;\n        try {\n          while(true) {\n            final BytesRef term = termsEnum.next();\n            if (term == null) {\n              break;\n            }\n            final long termval = parser.parseLong(term);\n            if (retArray == null) {\n              // late init so numeric fields don't double allocate\n              retArray = new long[maxDoc];\n            }\n\n            docs = termsEnum.docs(null, docs, 0);\n            while (true) {\n              final int docID = docs.nextDoc();\n              if (docID == DocIdSetIterator.NO_MORE_DOCS) {\n                break;\n              }\n              retArray[docID] = termval;\n              if (setDocsWithField) {\n                if (docsWithField == null) {\n                  // Lazy init\n                  docsWithField = new FixedBitSet(maxDoc);\n                }\n                docsWithField.set(docID);\n              }\n            }\n          }\n        } catch (FieldCache.StopFillCacheException stop) {\n        }\n      }\n\n      if (retArray == null) {\n        // no values\n        retArray = new long[maxDoc];\n      }\n      if (setDocsWithField) {\n        wrapper.setDocsWithField(reader, field, docsWithField);\n      }\n      return retArray;\n    }\n\n","bugFix":null,"bugIntro":["edc944077593063d718a895a9d7afdf6895d6685"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"edc944077593063d718a895a9d7afdf6895d6685","date":1360052675,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.LongCache#createValue(AtomicReader,Entry,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.LongCache#createValue(AtomicReader,Entry,boolean).mjava","sourceNew":"    @Override\n    protected Object createValue(AtomicReader reader, Entry entryKey, boolean setDocsWithField)\n        throws IOException {\n      String field = entryKey.field;\n      FieldCache.LongParser parser = (FieldCache.LongParser) entryKey.custom;\n      if (parser == null) {\n        try {\n          return wrapper.getLongs(reader, field, DEFAULT_LONG_PARSER, setDocsWithField);\n        } catch (NumberFormatException ne) {\n          return wrapper.getLongs(reader, field, NUMERIC_UTILS_LONG_PARSER, setDocsWithField);\n        }\n      }\n      final int maxDoc = reader.maxDoc();\n      long[] retArray = null;\n\n      Terms terms = reader.terms(field);\n      FixedBitSet docsWithField = null;\n      if (terms != null) {\n        if (setDocsWithField) {\n          final int termsDocCount = terms.getDocCount();\n          assert termsDocCount <= maxDoc;\n          if (termsDocCount == maxDoc) {\n            // Fast case: all docs have this field:\n            wrapper.setDocsWithField(reader, field, new Bits.MatchAllBits(maxDoc));\n            setDocsWithField = false;\n          }\n        }\n        final TermsEnum termsEnum = parser.termsEnum(terms);\n        assert termsEnum != null : \"TermsEnum must not be null\";\n        DocsEnum docs = null;\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final long termval = parser.parseLong(term);\n          if (retArray == null) {\n            // late init so numeric fields don't double allocate\n            retArray = new long[maxDoc];\n          }\n\n          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);\n          while (true) {\n            final int docID = docs.nextDoc();\n            if (docID == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            retArray[docID] = termval;\n            if (setDocsWithField) {\n              if (docsWithField == null) {\n                // Lazy init\n                docsWithField = new FixedBitSet(maxDoc);\n              }\n              docsWithField.set(docID);\n            }\n          }\n        }\n      }\n\n      if (retArray == null) {\n        // no values\n        retArray = new long[maxDoc];\n      }\n      if (setDocsWithField) {\n        wrapper.setDocsWithField(reader, field, docsWithField);\n      }\n      return retArray;\n    }\n\n","sourceOld":"    @Override\n    protected Object createValue(AtomicReader reader, Entry entryKey, boolean setDocsWithField)\n        throws IOException {\n      String field = entryKey.field;\n      FieldCache.LongParser parser = (FieldCache.LongParser) entryKey.custom;\n      if (parser == null) {\n        try {\n          return wrapper.getLongs(reader, field, DEFAULT_LONG_PARSER, setDocsWithField);\n        } catch (NumberFormatException ne) {\n          return wrapper.getLongs(reader, field, NUMERIC_UTILS_LONG_PARSER, setDocsWithField);\n        }\n      }\n      final int maxDoc = reader.maxDoc();\n      long[] retArray = null;\n\n      Terms terms = reader.terms(field);\n      FixedBitSet docsWithField = null;\n      if (terms != null) {\n        if (setDocsWithField) {\n          final int termsDocCount = terms.getDocCount();\n          assert termsDocCount <= maxDoc;\n          if (termsDocCount == maxDoc) {\n            // Fast case: all docs have this field:\n            wrapper.setDocsWithField(reader, field, new Bits.MatchAllBits(maxDoc));\n            setDocsWithField = false;\n          }\n        }\n        final TermsEnum termsEnum = terms.iterator(null);\n        DocsEnum docs = null;\n        try {\n          while(true) {\n            final BytesRef term = termsEnum.next();\n            if (term == null) {\n              break;\n            }\n            final long termval = parser.parseLong(term);\n            if (retArray == null) {\n              // late init so numeric fields don't double allocate\n              retArray = new long[maxDoc];\n            }\n\n            docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);\n            while (true) {\n              final int docID = docs.nextDoc();\n              if (docID == DocIdSetIterator.NO_MORE_DOCS) {\n                break;\n              }\n              retArray[docID] = termval;\n              if (setDocsWithField) {\n                if (docsWithField == null) {\n                  // Lazy init\n                  docsWithField = new FixedBitSet(maxDoc);\n                }\n                docsWithField.set(docID);\n              }\n            }\n          }\n        } catch (FieldCache.StopFillCacheException stop) {\n        }\n      }\n\n      if (retArray == null) {\n        // no values\n        retArray = new long[maxDoc];\n      }\n      if (setDocsWithField) {\n        wrapper.setDocsWithField(reader, field, docsWithField);\n      }\n      return retArray;\n    }\n\n","bugFix":["f08557cdb6c60ac7b88a9342c983a20cd236e74f","15250ca94ba8ab3bcdd476daf6bf3f3febb92640","3cc749c053615f5871f3b95715fe292f34e70a53","382fe3a6ca9745891afebda9b9a57cc158305545","e7ae10c50f71c27f38db329bd22245ebc97196fd"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":4,"author":"Robert Muir","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.LongCache#createValue(AtomicReader,Entry,boolean).mjava","sourceNew":null,"sourceOld":"    @Override\n    protected Object createValue(AtomicReader reader, Entry entryKey, boolean setDocsWithField)\n        throws IOException {\n      String field = entryKey.field;\n      FieldCache.LongParser parser = (FieldCache.LongParser) entryKey.custom;\n      if (parser == null) {\n        try {\n          return wrapper.getLongs(reader, field, DEFAULT_LONG_PARSER, setDocsWithField);\n        } catch (NumberFormatException ne) {\n          return wrapper.getLongs(reader, field, NUMERIC_UTILS_LONG_PARSER, setDocsWithField);\n        }\n      }\n      final int maxDoc = reader.maxDoc();\n      long[] retArray = null;\n\n      Terms terms = reader.terms(field);\n      FixedBitSet docsWithField = null;\n      if (terms != null) {\n        if (setDocsWithField) {\n          final int termsDocCount = terms.getDocCount();\n          assert termsDocCount <= maxDoc;\n          if (termsDocCount == maxDoc) {\n            // Fast case: all docs have this field:\n            wrapper.setDocsWithField(reader, field, new Bits.MatchAllBits(maxDoc));\n            setDocsWithField = false;\n          }\n        }\n        final TermsEnum termsEnum = parser.termsEnum(terms);\n        assert termsEnum != null : \"TermsEnum must not be null\";\n        DocsEnum docs = null;\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n          final long termval = parser.parseLong(term);\n          if (retArray == null) {\n            // late init so numeric fields don't double allocate\n            retArray = new long[maxDoc];\n          }\n\n          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);\n          while (true) {\n            final int docID = docs.nextDoc();\n            if (docID == DocIdSetIterator.NO_MORE_DOCS) {\n              break;\n            }\n            retArray[docID] = termval;\n            if (setDocsWithField) {\n              if (docsWithField == null) {\n                // Lazy init\n                docsWithField = new FixedBitSet(maxDoc);\n              }\n              docsWithField.set(docID);\n            }\n          }\n        }\n      }\n\n      if (retArray == null) {\n        // no values\n        retArray = new long[maxDoc];\n      }\n      if (setDocsWithField) {\n        wrapper.setDocsWithField(reader, field, docsWithField);\n      }\n      return retArray;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e7ae10c50f71c27f38db329bd22245ebc97196fd":["f08557cdb6c60ac7b88a9342c983a20cd236e74f"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","f08557cdb6c60ac7b88a9342c983a20cd236e74f"],"f08557cdb6c60ac7b88a9342c983a20cd236e74f":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a4d374b2bebd0d52acaa61038fbf23068620fba7":["f45457a742a53533c348c4b990b1c579ff364467"],"f45457a742a53533c348c4b990b1c579ff364467":["02331260bb246364779cb6f04919ca47900d01bb"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["edc944077593063d718a895a9d7afdf6895d6685","a4d374b2bebd0d52acaa61038fbf23068620fba7"],"15250ca94ba8ab3bcdd476daf6bf3f3febb92640":["02331260bb246364779cb6f04919ca47900d01bb"],"edc944077593063d718a895a9d7afdf6895d6685":["15250ca94ba8ab3bcdd476daf6bf3f3febb92640"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":["e7ae10c50f71c27f38db329bd22245ebc97196fd","02331260bb246364779cb6f04919ca47900d01bb"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["e7ae10c50f71c27f38db329bd22245ebc97196fd","02331260bb246364779cb6f04919ca47900d01bb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"02331260bb246364779cb6f04919ca47900d01bb":["e7ae10c50f71c27f38db329bd22245ebc97196fd"]},"commit2Childs":{"e7ae10c50f71c27f38db329bd22245ebc97196fd":["b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","d6f074e73200c07d54f242d3880a8da5a35ff97b","02331260bb246364779cb6f04919ca47900d01bb"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"f08557cdb6c60ac7b88a9342c983a20cd236e74f":["e7ae10c50f71c27f38db329bd22245ebc97196fd","9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","f08557cdb6c60ac7b88a9342c983a20cd236e74f"],"a4d374b2bebd0d52acaa61038fbf23068620fba7":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"f45457a742a53533c348c4b990b1c579ff364467":["a4d374b2bebd0d52acaa61038fbf23068620fba7"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"15250ca94ba8ab3bcdd476daf6bf3f3febb92640":["edc944077593063d718a895a9d7afdf6895d6685"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"edc944077593063d718a895a9d7afdf6895d6685":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":[],"d6f074e73200c07d54f242d3880a8da5a35ff97b":[],"02331260bb246364779cb6f04919ca47900d01bb":["f45457a742a53533c348c4b990b1c579ff364467","15250ca94ba8ab3bcdd476daf6bf3f3febb92640","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","d6f074e73200c07d54f242d3880a8da5a35ff97b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}