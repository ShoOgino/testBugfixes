{"path":"lucene/sandbox/src/java/org/apache/lucene/search/CoveringQuery#CoveringQuery(Collection[Query],LongValuesSource).mjava","commits":[{"id":"7d5484fcfd752ec7a2ff2ed6a860c539fdf92da8","date":1503307834,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/search/CoveringQuery#CoveringQuery(Collection[Query],LongValuesSource).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Sole constructor.\n   * @param queries Sub queries to match.\n   * @param minimumNumberMatch Per-document long value that records how many queries\n   *                           should match. Values that are less than 1 are treated\n   *                           like <tt>1</tt>: only documents that have at least one\n   *                           matching clause will be considered matches. Documents\n   *                           that do not have a value for <tt>minimumNumberMatch</tt>\n   *                           do not match.\n   */\n  public CoveringQuery(Collection<Query> queries, LongValuesSource minimumNumberMatch) {\n    if (queries.size() > BooleanQuery.getMaxClauseCount()) {\n      throw new BooleanQuery.TooManyClauses();\n    }\n    if (minimumNumberMatch.needsScores()) {\n      throw new IllegalArgumentException(\"The minimum number of matches may not depend on the score.\");\n    }\n    this.queries = new Multiset<>();\n    this.queries.addAll(queries);\n    this.minimumNumberMatch = Objects.requireNonNull(minimumNumberMatch);\n    this.hashCode = computeHashCode();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a8e4fbf51a35a1292b838d83f793794c274932a1","date":1503371298,"type":0,"author":"Cao Manh Dat","isMerge":true,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/search/CoveringQuery#CoveringQuery(Collection[Query],LongValuesSource).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Sole constructor.\n   * @param queries Sub queries to match.\n   * @param minimumNumberMatch Per-document long value that records how many queries\n   *                           should match. Values that are less than 1 are treated\n   *                           like <tt>1</tt>: only documents that have at least one\n   *                           matching clause will be considered matches. Documents\n   *                           that do not have a value for <tt>minimumNumberMatch</tt>\n   *                           do not match.\n   */\n  public CoveringQuery(Collection<Query> queries, LongValuesSource minimumNumberMatch) {\n    if (queries.size() > BooleanQuery.getMaxClauseCount()) {\n      throw new BooleanQuery.TooManyClauses();\n    }\n    if (minimumNumberMatch.needsScores()) {\n      throw new IllegalArgumentException(\"The minimum number of matches may not depend on the score.\");\n    }\n    this.queries = new Multiset<>();\n    this.queries.addAll(queries);\n    this.minimumNumberMatch = Objects.requireNonNull(minimumNumberMatch);\n    this.hashCode = computeHashCode();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a7809d1d753b67f48b1a706e17034bf8b624ea3","date":1504366927,"type":0,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/search/CoveringQuery#CoveringQuery(Collection[Query],LongValuesSource).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Sole constructor.\n   * @param queries Sub queries to match.\n   * @param minimumNumberMatch Per-document long value that records how many queries\n   *                           should match. Values that are less than 1 are treated\n   *                           like <tt>1</tt>: only documents that have at least one\n   *                           matching clause will be considered matches. Documents\n   *                           that do not have a value for <tt>minimumNumberMatch</tt>\n   *                           do not match.\n   */\n  public CoveringQuery(Collection<Query> queries, LongValuesSource minimumNumberMatch) {\n    if (queries.size() > BooleanQuery.getMaxClauseCount()) {\n      throw new BooleanQuery.TooManyClauses();\n    }\n    if (minimumNumberMatch.needsScores()) {\n      throw new IllegalArgumentException(\"The minimum number of matches may not depend on the score.\");\n    }\n    this.queries = new Multiset<>();\n    this.queries.addAll(queries);\n    this.minimumNumberMatch = Objects.requireNonNull(minimumNumberMatch);\n    this.hashCode = computeHashCode();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"36c70eb3b44de4355a7168b762cadc0f1cf194bc","date":1561542955,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/search/CoveringQuery#CoveringQuery(Collection[Query],LongValuesSource).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/search/CoveringQuery#CoveringQuery(Collection[Query],LongValuesSource).mjava","sourceNew":"  /**\n   * Sole constructor.\n   * @param queries Sub queries to match.\n   * @param minimumNumberMatch Per-document long value that records how many queries\n   *                           should match. Values that are less than 1 are treated\n   *                           like <tt>1</tt>: only documents that have at least one\n   *                           matching clause will be considered matches. Documents\n   *                           that do not have a value for <tt>minimumNumberMatch</tt>\n   *                           do not match.\n   */\n  public CoveringQuery(Collection<Query> queries, LongValuesSource minimumNumberMatch) {\n    if (queries.size() > IndexSearcher.getMaxClauseCount()) {\n      throw new IndexSearcher.TooManyClauses();\n    }\n    if (minimumNumberMatch.needsScores()) {\n      throw new IllegalArgumentException(\"The minimum number of matches may not depend on the score.\");\n    }\n    this.queries = new Multiset<>();\n    this.queries.addAll(queries);\n    this.minimumNumberMatch = Objects.requireNonNull(minimumNumberMatch);\n    this.hashCode = computeHashCode();\n  }\n\n","sourceOld":"  /**\n   * Sole constructor.\n   * @param queries Sub queries to match.\n   * @param minimumNumberMatch Per-document long value that records how many queries\n   *                           should match. Values that are less than 1 are treated\n   *                           like <tt>1</tt>: only documents that have at least one\n   *                           matching clause will be considered matches. Documents\n   *                           that do not have a value for <tt>minimumNumberMatch</tt>\n   *                           do not match.\n   */\n  public CoveringQuery(Collection<Query> queries, LongValuesSource minimumNumberMatch) {\n    if (queries.size() > BooleanQuery.getMaxClauseCount()) {\n      throw new BooleanQuery.TooManyClauses();\n    }\n    if (minimumNumberMatch.needsScores()) {\n      throw new IllegalArgumentException(\"The minimum number of matches may not depend on the score.\");\n    }\n    this.queries = new Multiset<>();\n    this.queries.addAll(queries);\n    this.minimumNumberMatch = Objects.requireNonNull(minimumNumberMatch);\n    this.hashCode = computeHashCode();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe90d104db258964b96e50418b9caa0c156eafda","date":1561555614,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/search/CoveringQuery#CoveringQuery(Collection[Query],LongValuesSource).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/search/CoveringQuery#CoveringQuery(Collection[Query],LongValuesSource).mjava","sourceNew":"  /**\n   * Sole constructor.\n   * @param queries Sub queries to match.\n   * @param minimumNumberMatch Per-document long value that records how many queries\n   *                           should match. Values that are less than 1 are treated\n   *                           like <tt>1</tt>: only documents that have at least one\n   *                           matching clause will be considered matches. Documents\n   *                           that do not have a value for <tt>minimumNumberMatch</tt>\n   *                           do not match.\n   */\n  public CoveringQuery(Collection<Query> queries, LongValuesSource minimumNumberMatch) {\n    if (queries.size() > IndexSearcher.getMaxClauseCount()) {\n      throw new IndexSearcher.TooManyClauses();\n    }\n    if (minimumNumberMatch.needsScores()) {\n      throw new IllegalArgumentException(\"The minimum number of matches may not depend on the score.\");\n    }\n    this.queries = new Multiset<>();\n    this.queries.addAll(queries);\n    this.minimumNumberMatch = Objects.requireNonNull(minimumNumberMatch);\n    this.hashCode = computeHashCode();\n\n    this.ramBytesUsed = BASE_RAM_BYTES +\n        RamUsageEstimator.sizeOfObject(this.queries, RamUsageEstimator.QUERY_DEFAULT_RAM_BYTES_USED);\n  }\n\n","sourceOld":"  /**\n   * Sole constructor.\n   * @param queries Sub queries to match.\n   * @param minimumNumberMatch Per-document long value that records how many queries\n   *                           should match. Values that are less than 1 are treated\n   *                           like <tt>1</tt>: only documents that have at least one\n   *                           matching clause will be considered matches. Documents\n   *                           that do not have a value for <tt>minimumNumberMatch</tt>\n   *                           do not match.\n   */\n  public CoveringQuery(Collection<Query> queries, LongValuesSource minimumNumberMatch) {\n    if (queries.size() > IndexSearcher.getMaxClauseCount()) {\n      throw new IndexSearcher.TooManyClauses();\n    }\n    if (minimumNumberMatch.needsScores()) {\n      throw new IllegalArgumentException(\"The minimum number of matches may not depend on the score.\");\n    }\n    this.queries = new Multiset<>();\n    this.queries.addAll(queries);\n    this.minimumNumberMatch = Objects.requireNonNull(minimumNumberMatch);\n    this.hashCode = computeHashCode();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9e3751ad4cc85eb979419cf5469dfba266eae56a","date":1581046252,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/search/CoveringQuery#CoveringQuery(Collection[Query],LongValuesSource).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/search/CoveringQuery#CoveringQuery(Collection[Query],LongValuesSource).mjava","sourceNew":"  /**\n   * Sole constructor.\n   * @param queries Sub queries to match.\n   * @param minimumNumberMatch Per-document long value that records how many queries\n   *                           should match. Values that are less than 1 are treated\n   *                           like <code>1</code>: only documents that have at least one\n   *                           matching clause will be considered matches. Documents\n   *                           that do not have a value for <code>minimumNumberMatch</code>\n   *                           do not match.\n   */\n  public CoveringQuery(Collection<Query> queries, LongValuesSource minimumNumberMatch) {\n    if (queries.size() > IndexSearcher.getMaxClauseCount()) {\n      throw new IndexSearcher.TooManyClauses();\n    }\n    if (minimumNumberMatch.needsScores()) {\n      throw new IllegalArgumentException(\"The minimum number of matches may not depend on the score.\");\n    }\n    this.queries = new Multiset<>();\n    this.queries.addAll(queries);\n    this.minimumNumberMatch = Objects.requireNonNull(minimumNumberMatch);\n    this.hashCode = computeHashCode();\n\n    this.ramBytesUsed = BASE_RAM_BYTES +\n        RamUsageEstimator.sizeOfObject(this.queries, RamUsageEstimator.QUERY_DEFAULT_RAM_BYTES_USED);\n  }\n\n","sourceOld":"  /**\n   * Sole constructor.\n   * @param queries Sub queries to match.\n   * @param minimumNumberMatch Per-document long value that records how many queries\n   *                           should match. Values that are less than 1 are treated\n   *                           like <tt>1</tt>: only documents that have at least one\n   *                           matching clause will be considered matches. Documents\n   *                           that do not have a value for <tt>minimumNumberMatch</tt>\n   *                           do not match.\n   */\n  public CoveringQuery(Collection<Query> queries, LongValuesSource minimumNumberMatch) {\n    if (queries.size() > IndexSearcher.getMaxClauseCount()) {\n      throw new IndexSearcher.TooManyClauses();\n    }\n    if (minimumNumberMatch.needsScores()) {\n      throw new IllegalArgumentException(\"The minimum number of matches may not depend on the score.\");\n    }\n    this.queries = new Multiset<>();\n    this.queries.addAll(queries);\n    this.minimumNumberMatch = Objects.requireNonNull(minimumNumberMatch);\n    this.hashCode = computeHashCode();\n\n    this.ramBytesUsed = BASE_RAM_BYTES +\n        RamUsageEstimator.sizeOfObject(this.queries, RamUsageEstimator.QUERY_DEFAULT_RAM_BYTES_USED);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9e3751ad4cc85eb979419cf5469dfba266eae56a":["fe90d104db258964b96e50418b9caa0c156eafda"],"fe90d104db258964b96e50418b9caa0c156eafda":["36c70eb3b44de4355a7168b762cadc0f1cf194bc"],"3a7809d1d753b67f48b1a706e17034bf8b624ea3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","a8e4fbf51a35a1292b838d83f793794c274932a1"],"7d5484fcfd752ec7a2ff2ed6a860c539fdf92da8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"36c70eb3b44de4355a7168b762cadc0f1cf194bc":["a8e4fbf51a35a1292b838d83f793794c274932a1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9e3751ad4cc85eb979419cf5469dfba266eae56a"],"a8e4fbf51a35a1292b838d83f793794c274932a1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","7d5484fcfd752ec7a2ff2ed6a860c539fdf92da8"]},"commit2Childs":{"9e3751ad4cc85eb979419cf5469dfba266eae56a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"fe90d104db258964b96e50418b9caa0c156eafda":["9e3751ad4cc85eb979419cf5469dfba266eae56a"],"3a7809d1d753b67f48b1a706e17034bf8b624ea3":[],"7d5484fcfd752ec7a2ff2ed6a860c539fdf92da8":["a8e4fbf51a35a1292b838d83f793794c274932a1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a7809d1d753b67f48b1a706e17034bf8b624ea3","7d5484fcfd752ec7a2ff2ed6a860c539fdf92da8","a8e4fbf51a35a1292b838d83f793794c274932a1"],"36c70eb3b44de4355a7168b762cadc0f1cf194bc":["fe90d104db258964b96e50418b9caa0c156eafda"],"a8e4fbf51a35a1292b838d83f793794c274932a1":["3a7809d1d753b67f48b1a706e17034bf8b624ea3","36c70eb3b44de4355a7168b762cadc0f1cf194bc"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["3a7809d1d753b67f48b1a706e17034bf8b624ea3","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}