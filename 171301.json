{"path":"lucene/src/java/org/apache/lucene/index/MultiReader#initialize(IndexReader[],boolean).mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/MultiReader#initialize(IndexReader[],boolean).mjava","pathOld":"src/java/org/apache/lucene/index/MultiReader#initialize(IndexReader[],boolean).mjava","sourceNew":"  private void initialize(IndexReader[] subReaders, boolean closeSubReaders) {\n    this.subReaders =  subReaders.clone();\n    starts = new int[subReaders.length + 1];    // build starts array\n    decrefOnClose = new boolean[subReaders.length];\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      maxDoc += subReaders[i].maxDoc();      // compute maxDocs\n\n      if (!closeSubReaders) {\n        subReaders[i].incRef();\n        decrefOnClose[i] = true;\n      } else {\n        decrefOnClose[i] = false;\n      }\n      \n      if (subReaders[i].hasDeletions())\n        hasDeletions = true;\n    }\n    starts[subReaders.length] = maxDoc;\n  }\n\n","sourceOld":"  private void initialize(IndexReader[] subReaders, boolean closeSubReaders) {\n    this.subReaders =  subReaders.clone();\n    starts = new int[subReaders.length + 1];    // build starts array\n    decrefOnClose = new boolean[subReaders.length];\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      maxDoc += subReaders[i].maxDoc();      // compute maxDocs\n\n      if (!closeSubReaders) {\n        subReaders[i].incRef();\n        decrefOnClose[i] = true;\n      } else {\n        decrefOnClose[i] = false;\n      }\n      \n      if (subReaders[i].hasDeletions())\n        hasDeletions = true;\n    }\n    starts[subReaders.length] = maxDoc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"955c32f886db6f6356c9fcdea6b1f1cb4effda24","date":1270581567,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/MultiReader#initialize(IndexReader[],boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/MultiReader#initialize(IndexReader[],boolean).mjava","sourceNew":"  private void initialize(IndexReader[] subReaders, boolean closeSubReaders) throws IOException {\n    this.subReaders =  subReaders.clone();\n    starts = new int[subReaders.length + 1];    // build starts array\n    decrefOnClose = new boolean[subReaders.length];\n\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      maxDoc += subReaders[i].maxDoc();      // compute maxDocs\n\n      if (!closeSubReaders) {\n        subReaders[i].incRef();\n        decrefOnClose[i] = true;\n      } else {\n        decrefOnClose[i] = false;\n      }\n      \n      if (subReaders[i].hasDeletions()) {\n        hasDeletions = true;\n      }\n\n      final ReaderUtil.Slice slice = new ReaderUtil.Slice(starts[i],\n                                                          subReaders[i].maxDoc(),\n                                                          i);\n      subReaderToSlice.put(subReaders[i], slice);\n    }\n\n    starts[subReaders.length] = maxDoc;\n  }\n\n","sourceOld":"  private void initialize(IndexReader[] subReaders, boolean closeSubReaders) {\n    this.subReaders =  subReaders.clone();\n    starts = new int[subReaders.length + 1];    // build starts array\n    decrefOnClose = new boolean[subReaders.length];\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      maxDoc += subReaders[i].maxDoc();      // compute maxDocs\n\n      if (!closeSubReaders) {\n        subReaders[i].incRef();\n        decrefOnClose[i] = true;\n      } else {\n        decrefOnClose[i] = false;\n      }\n      \n      if (subReaders[i].hasDeletions())\n        hasDeletions = true;\n    }\n    starts[subReaders.length] = maxDoc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2dadf0f3286a34a0fee6e788ffce88624bf2984e","date":1294260428,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/MultiReader#initialize(IndexReader[],boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/MultiReader#initialize(IndexReader[],boolean).mjava","sourceNew":"  private ReaderContext initialize(IndexReader[] subReaders, boolean closeSubReaders) throws IOException {\n    this.subReaders =  subReaders.clone();\n    starts = new int[subReaders.length + 1];    // build starts array\n    decrefOnClose = new boolean[subReaders.length];\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      maxDoc += subReaders[i].maxDoc();      // compute maxDocs\n\n      if (!closeSubReaders) {\n        subReaders[i].incRef();\n        decrefOnClose[i] = true;\n      } else {\n        decrefOnClose[i] = false;\n      }\n      \n      if (subReaders[i].hasDeletions()) {\n        hasDeletions = true;\n      }\n    }\n    starts[subReaders.length] = maxDoc;\n    return ReaderUtil.buildReaderContext(this);\n  }\n\n","sourceOld":"  private void initialize(IndexReader[] subReaders, boolean closeSubReaders) throws IOException {\n    this.subReaders =  subReaders.clone();\n    starts = new int[subReaders.length + 1];    // build starts array\n    decrefOnClose = new boolean[subReaders.length];\n\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      maxDoc += subReaders[i].maxDoc();      // compute maxDocs\n\n      if (!closeSubReaders) {\n        subReaders[i].incRef();\n        decrefOnClose[i] = true;\n      } else {\n        decrefOnClose[i] = false;\n      }\n      \n      if (subReaders[i].hasDeletions()) {\n        hasDeletions = true;\n      }\n\n      final ReaderUtil.Slice slice = new ReaderUtil.Slice(starts[i],\n                                                          subReaders[i].maxDoc(),\n                                                          i);\n      subReaderToSlice.put(subReaders[i], slice);\n    }\n\n    starts[subReaders.length] = maxDoc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"868da859b43505d9d2a023bfeae6dd0c795f5295","date":1294948401,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/MultiReader#initialize(IndexReader[],boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/MultiReader#initialize(IndexReader[],boolean).mjava","sourceNew":"  private ReaderContext initialize(IndexReader[] subReaders, boolean closeSubReaders) throws IOException {\n    this.subReaders =  subReaders.clone();\n    starts = new int[subReaders.length + 1];    // build starts array\n    decrefOnClose = new boolean[subReaders.length];\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      maxDoc += subReaders[i].maxDoc();      // compute maxDocs\n\n      if (!closeSubReaders) {\n        subReaders[i].incRef();\n        decrefOnClose[i] = true;\n      } else {\n        decrefOnClose[i] = false;\n      }\n      \n      if (subReaders[i].hasDeletions()) {\n        hasDeletions = true;\n      }\n    }\n    starts[subReaders.length] = maxDoc;\n    return ReaderUtil.buildReaderContext(this);\n  }\n\n","sourceOld":"  private void initialize(IndexReader[] subReaders, boolean closeSubReaders) throws IOException {\n    this.subReaders =  subReaders.clone();\n    starts = new int[subReaders.length + 1];    // build starts array\n    decrefOnClose = new boolean[subReaders.length];\n\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      maxDoc += subReaders[i].maxDoc();      // compute maxDocs\n\n      if (!closeSubReaders) {\n        subReaders[i].incRef();\n        decrefOnClose[i] = true;\n      } else {\n        decrefOnClose[i] = false;\n      }\n      \n      if (subReaders[i].hasDeletions()) {\n        hasDeletions = true;\n      }\n\n      final ReaderUtil.Slice slice = new ReaderUtil.Slice(starts[i],\n                                                          subReaders[i].maxDoc(),\n                                                          i);\n      subReaderToSlice.put(subReaders[i], slice);\n    }\n\n    starts[subReaders.length] = maxDoc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cdd3a20c3f7b8db3ed0313a58cb6304f9b5bc340","date":1295995357,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/MultiReader#initialize(IndexReader[],boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/MultiReader#initialize(IndexReader[],boolean).mjava","sourceNew":"  private ReaderContext initialize(IndexReader[] subReaders, boolean closeSubReaders) throws IOException {\n    this.subReaders =  subReaders.clone();\n    starts = new int[subReaders.length + 1];    // build starts array\n    decrefOnClose = new boolean[subReaders.length];\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      maxDoc += subReaders[i].maxDoc();      // compute maxDocs\n\n      if (!closeSubReaders) {\n        subReaders[i].incRef();\n        decrefOnClose[i] = true;\n      } else {\n        decrefOnClose[i] = false;\n      }\n      \n      if (subReaders[i].hasDeletions()) {\n        hasDeletions = true;\n      }\n    }\n    starts[subReaders.length] = maxDoc;\n    readerFinishedListeners = Collections.synchronizedSet(new HashSet<ReaderFinishedListener>());\n    return ReaderUtil.buildReaderContext(this);\n  }\n\n","sourceOld":"  private ReaderContext initialize(IndexReader[] subReaders, boolean closeSubReaders) throws IOException {\n    this.subReaders =  subReaders.clone();\n    starts = new int[subReaders.length + 1];    // build starts array\n    decrefOnClose = new boolean[subReaders.length];\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      maxDoc += subReaders[i].maxDoc();      // compute maxDocs\n\n      if (!closeSubReaders) {\n        subReaders[i].incRef();\n        decrefOnClose[i] = true;\n      } else {\n        decrefOnClose[i] = false;\n      }\n      \n      if (subReaders[i].hasDeletions()) {\n        hasDeletions = true;\n      }\n    }\n    starts[subReaders.length] = maxDoc;\n    return ReaderUtil.buildReaderContext(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ed47693b1e536083c1fa52f3c2994098f3154d3c","date":1296080277,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/MultiReader#initialize(IndexReader[],boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/MultiReader#initialize(IndexReader[],boolean).mjava","sourceNew":"  private ReaderContext initialize(IndexReader[] subReaders, boolean closeSubReaders) throws IOException {\n    this.subReaders =  subReaders.clone();\n    starts = new int[subReaders.length + 1];    // build starts array\n    decrefOnClose = new boolean[subReaders.length];\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      maxDoc += subReaders[i].maxDoc();      // compute maxDocs\n\n      if (!closeSubReaders) {\n        subReaders[i].incRef();\n        decrefOnClose[i] = true;\n      } else {\n        decrefOnClose[i] = false;\n      }\n      \n      if (subReaders[i].hasDeletions()) {\n        hasDeletions = true;\n      }\n    }\n    starts[subReaders.length] = maxDoc;\n    readerFinishedListeners = new MapBackedSet<ReaderFinishedListener>(new ConcurrentHashMap<ReaderFinishedListener,Boolean>());\n    return ReaderUtil.buildReaderContext(this);\n  }\n\n","sourceOld":"  private ReaderContext initialize(IndexReader[] subReaders, boolean closeSubReaders) throws IOException {\n    this.subReaders =  subReaders.clone();\n    starts = new int[subReaders.length + 1];    // build starts array\n    decrefOnClose = new boolean[subReaders.length];\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      maxDoc += subReaders[i].maxDoc();      // compute maxDocs\n\n      if (!closeSubReaders) {\n        subReaders[i].incRef();\n        decrefOnClose[i] = true;\n      } else {\n        decrefOnClose[i] = false;\n      }\n      \n      if (subReaders[i].hasDeletions()) {\n        hasDeletions = true;\n      }\n    }\n    starts[subReaders.length] = maxDoc;\n    readerFinishedListeners = Collections.synchronizedSet(new HashSet<ReaderFinishedListener>());\n    return ReaderUtil.buildReaderContext(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/MultiReader#initialize(IndexReader[],boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/MultiReader#initialize(IndexReader[],boolean).mjava","sourceNew":"  private ReaderContext initialize(IndexReader[] subReaders, boolean closeSubReaders) throws IOException {\n    this.subReaders =  subReaders.clone();\n    starts = new int[subReaders.length + 1];    // build starts array\n    decrefOnClose = new boolean[subReaders.length];\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      maxDoc += subReaders[i].maxDoc();      // compute maxDocs\n\n      if (!closeSubReaders) {\n        subReaders[i].incRef();\n        decrefOnClose[i] = true;\n      } else {\n        decrefOnClose[i] = false;\n      }\n      \n      if (subReaders[i].hasDeletions()) {\n        hasDeletions = true;\n      }\n    }\n    starts[subReaders.length] = maxDoc;\n    readerFinishedListeners = new MapBackedSet<ReaderFinishedListener>(new ConcurrentHashMap<ReaderFinishedListener,Boolean>());\n    return ReaderUtil.buildReaderContext(this);\n  }\n\n","sourceOld":"  private void initialize(IndexReader[] subReaders, boolean closeSubReaders) throws IOException {\n    this.subReaders =  subReaders.clone();\n    starts = new int[subReaders.length + 1];    // build starts array\n    decrefOnClose = new boolean[subReaders.length];\n\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      maxDoc += subReaders[i].maxDoc();      // compute maxDocs\n\n      if (!closeSubReaders) {\n        subReaders[i].incRef();\n        decrefOnClose[i] = true;\n      } else {\n        decrefOnClose[i] = false;\n      }\n      \n      if (subReaders[i].hasDeletions()) {\n        hasDeletions = true;\n      }\n\n      final ReaderUtil.Slice slice = new ReaderUtil.Slice(starts[i],\n                                                          subReaders[i].maxDoc(),\n                                                          i);\n      subReaderToSlice.put(subReaders[i], slice);\n    }\n\n    starts[subReaders.length] = maxDoc;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/MultiReader#initialize(IndexReader[],boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/MultiReader#initialize(IndexReader[],boolean).mjava","sourceNew":"  private ReaderContext initialize(IndexReader[] subReaders, boolean closeSubReaders) throws IOException {\n    this.subReaders =  subReaders.clone();\n    starts = new int[subReaders.length + 1];    // build starts array\n    decrefOnClose = new boolean[subReaders.length];\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      maxDoc += subReaders[i].maxDoc();      // compute maxDocs\n\n      if (!closeSubReaders) {\n        subReaders[i].incRef();\n        decrefOnClose[i] = true;\n      } else {\n        decrefOnClose[i] = false;\n      }\n      \n      if (subReaders[i].hasDeletions()) {\n        hasDeletions = true;\n      }\n    }\n    starts[subReaders.length] = maxDoc;\n    readerFinishedListeners = new MapBackedSet<ReaderFinishedListener>(new ConcurrentHashMap<ReaderFinishedListener,Boolean>());\n    return ReaderUtil.buildReaderContext(this);\n  }\n\n","sourceOld":"  private ReaderContext initialize(IndexReader[] subReaders, boolean closeSubReaders) throws IOException {\n    this.subReaders =  subReaders.clone();\n    starts = new int[subReaders.length + 1];    // build starts array\n    decrefOnClose = new boolean[subReaders.length];\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      maxDoc += subReaders[i].maxDoc();      // compute maxDocs\n\n      if (!closeSubReaders) {\n        subReaders[i].incRef();\n        decrefOnClose[i] = true;\n      } else {\n        decrefOnClose[i] = false;\n      }\n      \n      if (subReaders[i].hasDeletions()) {\n        hasDeletions = true;\n      }\n    }\n    starts[subReaders.length] = maxDoc;\n    return ReaderUtil.buildReaderContext(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6e2df1cc3e8621670ff46d098e43b7dd3f66eaf4","date":1323543613,"type":4,"author":"Uwe Schindler","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/index/MultiReader#initialize(IndexReader[],boolean).mjava","sourceNew":null,"sourceOld":"  private ReaderContext initialize(IndexReader[] subReaders, boolean closeSubReaders) throws IOException {\n    this.subReaders =  subReaders.clone();\n    starts = new int[subReaders.length + 1];    // build starts array\n    decrefOnClose = new boolean[subReaders.length];\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      maxDoc += subReaders[i].maxDoc();      // compute maxDocs\n\n      if (!closeSubReaders) {\n        subReaders[i].incRef();\n        decrefOnClose[i] = true;\n      } else {\n        decrefOnClose[i] = false;\n      }\n      \n      if (subReaders[i].hasDeletions()) {\n        hasDeletions = true;\n      }\n    }\n    starts[subReaders.length] = maxDoc;\n    readerFinishedListeners = new MapBackedSet<ReaderFinishedListener>(new ConcurrentHashMap<ReaderFinishedListener,Boolean>());\n    return ReaderUtil.buildReaderContext(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","date":1323720782,"type":4,"author":"Robert Muir","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/index/MultiReader#initialize(IndexReader[],boolean).mjava","sourceNew":null,"sourceOld":"  private ReaderContext initialize(IndexReader[] subReaders, boolean closeSubReaders) throws IOException {\n    this.subReaders =  subReaders.clone();\n    starts = new int[subReaders.length + 1];    // build starts array\n    decrefOnClose = new boolean[subReaders.length];\n    for (int i = 0; i < subReaders.length; i++) {\n      starts[i] = maxDoc;\n      maxDoc += subReaders[i].maxDoc();      // compute maxDocs\n\n      if (!closeSubReaders) {\n        subReaders[i].incRef();\n        decrefOnClose[i] = true;\n      } else {\n        decrefOnClose[i] = false;\n      }\n      \n      if (subReaders[i].hasDeletions()) {\n        hasDeletions = true;\n      }\n    }\n    starts[subReaders.length] = maxDoc;\n    readerFinishedListeners = new MapBackedSet<ReaderFinishedListener>(new ConcurrentHashMap<ReaderFinishedListener,Boolean>());\n    return ReaderUtil.buildReaderContext(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"cdd3a20c3f7b8db3ed0313a58cb6304f9b5bc340":["2dadf0f3286a34a0fee6e788ffce88624bf2984e"],"6e2df1cc3e8621670ff46d098e43b7dd3f66eaf4":["ed47693b1e536083c1fa52f3c2994098f3154d3c"],"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c":["ed47693b1e536083c1fa52f3c2994098f3154d3c","6e2df1cc3e8621670ff46d098e43b7dd3f66eaf4"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["955c32f886db6f6356c9fcdea6b1f1cb4effda24","ed47693b1e536083c1fa52f3c2994098f3154d3c"],"2dadf0f3286a34a0fee6e788ffce88624bf2984e":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"ed47693b1e536083c1fa52f3c2994098f3154d3c":["cdd3a20c3f7b8db3ed0313a58cb6304f9b5bc340"],"868da859b43505d9d2a023bfeae6dd0c795f5295":["955c32f886db6f6356c9fcdea6b1f1cb4effda24","2dadf0f3286a34a0fee6e788ffce88624bf2984e"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["868da859b43505d9d2a023bfeae6dd0c795f5295","ed47693b1e536083c1fa52f3c2994098f3154d3c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6e2df1cc3e8621670ff46d098e43b7dd3f66eaf4"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"cdd3a20c3f7b8db3ed0313a58cb6304f9b5bc340":["ed47693b1e536083c1fa52f3c2994098f3154d3c"],"6e2df1cc3e8621670ff46d098e43b7dd3f66eaf4":["93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c":[],"29ef99d61cda9641b6250bf9567329a6e65f901d":[],"2dadf0f3286a34a0fee6e788ffce88624bf2984e":["cdd3a20c3f7b8db3ed0313a58cb6304f9b5bc340","868da859b43505d9d2a023bfeae6dd0c795f5295"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["29ef99d61cda9641b6250bf9567329a6e65f901d","2dadf0f3286a34a0fee6e788ffce88624bf2984e","868da859b43505d9d2a023bfeae6dd0c795f5295"],"ed47693b1e536083c1fa52f3c2994098f3154d3c":["6e2df1cc3e8621670ff46d098e43b7dd3f66eaf4","93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","29ef99d61cda9641b6250bf9567329a6e65f901d","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"868da859b43505d9d2a023bfeae6dd0c795f5295":["bde51b089eb7f86171eb3406e38a274743f9b7ac"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","29ef99d61cda9641b6250bf9567329a6e65f901d","bde51b089eb7f86171eb3406e38a274743f9b7ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}