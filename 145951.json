{"path":"solr/core/src/java/org/apache/solr/util/hll/BigEndianAscendingWordSerializer#writeWord(long).mjava","commits":[{"id":"6d8714f9ceaaff94f0968d1c2d037978c3fde569","date":1437042727,"type":0,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/hll/BigEndianAscendingWordSerializer#writeWord(long).mjava","pathOld":"/dev/null","sourceNew":"    /* (non-Javadoc)\n     * @see net.agkn.hll.serialization.IWordSerializer#writeWord(long)\n     * @throws RuntimeException if the number of words written is greater than the\n     *         <code>wordCount</code> parameter in the constructor.\n     */\n    @Override\n    public void writeWord(final long word) {\n        if(wordsWritten == wordCount) {\n            throw new RuntimeException(\"Cannot write more words, backing array full!\");\n        }\n\n        int bitsLeftInWord = wordLength;\n\n        while(bitsLeftInWord > 0) {\n            // Move to the next byte if the current one is fully packed.\n            if(bitsLeftInByte == 0) {\n                byteIndex++;\n                bitsLeftInByte = BITS_PER_BYTE;\n            }\n\n            final long consumedMask;\n            if(bitsLeftInWord == 64) {\n                consumedMask = ~0L;\n            } else {\n                consumedMask = ((1L << bitsLeftInWord) - 1L);\n            }\n\n            // Fix how many bits will be written in this cycle. Choose the\n            // smaller of the remaining bits in the word or byte.\n            final int numberOfBitsToWrite = Math.min(bitsLeftInByte, bitsLeftInWord);\n            final int bitsInByteRemainingAfterWrite = (bitsLeftInByte - numberOfBitsToWrite);\n\n            // In general, we write the highest bits of the word first, so we\n            // strip the highest bits that were consumed in previous cycles.\n            final long remainingBitsOfWordToWrite = (word & consumedMask);\n\n            final long bitsThatTheByteCanAccept;\n            // If there is more left in the word than can be written to this\n            // byte, shift off the bits that can't be written off the bottom.\n            if(bitsLeftInWord > numberOfBitsToWrite) {\n                bitsThatTheByteCanAccept = (remainingBitsOfWordToWrite >>> (bitsLeftInWord - bitsLeftInByte));\n            } else {\n                // If the byte can accept all remaining bits, there is no need\n                // to shift off the bits that won't be written in this cycle.\n                bitsThatTheByteCanAccept = remainingBitsOfWordToWrite;\n            }\n\n            // Align the word bits to write up against the byte bits that have\n            // already been written. This shift may do nothing if the remainder\n            // of the byte is being consumed in this cycle.\n            final long alignedBits = (bitsThatTheByteCanAccept << bitsInByteRemainingAfterWrite);\n\n            // Update the byte with the alignedBits.\n            bytes[byteIndex] |= (byte)alignedBits;\n\n            // Update state with bit count written.\n            bitsLeftInWord -= numberOfBitsToWrite;\n            bitsLeftInByte = bitsInByteRemainingAfterWrite;\n        }\n\n        wordsWritten ++;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3b5ee4c66244bdfcc4796a114519d47701b2c026","date":1437132013,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/util/hll/BigEndianAscendingWordSerializer#writeWord(long).mjava","pathOld":"/dev/null","sourceNew":"    /* (non-Javadoc)\n     * @see net.agkn.hll.serialization.IWordSerializer#writeWord(long)\n     * @throws RuntimeException if the number of words written is greater than the\n     *         <code>wordCount</code> parameter in the constructor.\n     */\n    @Override\n    public void writeWord(final long word) {\n        if(wordsWritten == wordCount) {\n            throw new RuntimeException(\"Cannot write more words, backing array full!\");\n        }\n\n        int bitsLeftInWord = wordLength;\n\n        while(bitsLeftInWord > 0) {\n            // Move to the next byte if the current one is fully packed.\n            if(bitsLeftInByte == 0) {\n                byteIndex++;\n                bitsLeftInByte = BITS_PER_BYTE;\n            }\n\n            final long consumedMask;\n            if(bitsLeftInWord == 64) {\n                consumedMask = ~0L;\n            } else {\n                consumedMask = ((1L << bitsLeftInWord) - 1L);\n            }\n\n            // Fix how many bits will be written in this cycle. Choose the\n            // smaller of the remaining bits in the word or byte.\n            final int numberOfBitsToWrite = Math.min(bitsLeftInByte, bitsLeftInWord);\n            final int bitsInByteRemainingAfterWrite = (bitsLeftInByte - numberOfBitsToWrite);\n\n            // In general, we write the highest bits of the word first, so we\n            // strip the highest bits that were consumed in previous cycles.\n            final long remainingBitsOfWordToWrite = (word & consumedMask);\n\n            final long bitsThatTheByteCanAccept;\n            // If there is more left in the word than can be written to this\n            // byte, shift off the bits that can't be written off the bottom.\n            if(bitsLeftInWord > numberOfBitsToWrite) {\n                bitsThatTheByteCanAccept = (remainingBitsOfWordToWrite >>> (bitsLeftInWord - bitsLeftInByte));\n            } else {\n                // If the byte can accept all remaining bits, there is no need\n                // to shift off the bits that won't be written in this cycle.\n                bitsThatTheByteCanAccept = remainingBitsOfWordToWrite;\n            }\n\n            // Align the word bits to write up against the byte bits that have\n            // already been written. This shift may do nothing if the remainder\n            // of the byte is being consumed in this cycle.\n            final long alignedBits = (bitsThatTheByteCanAccept << bitsInByteRemainingAfterWrite);\n\n            // Update the byte with the alignedBits.\n            bytes[byteIndex] |= (byte)alignedBits;\n\n            // Update state with bit count written.\n            bitsLeftInWord -= numberOfBitsToWrite;\n            bitsLeftInByte = bitsInByteRemainingAfterWrite;\n        }\n\n        wordsWritten ++;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3b5ee4c66244bdfcc4796a114519d47701b2c026":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6d8714f9ceaaff94f0968d1c2d037978c3fde569"],"6d8714f9ceaaff94f0968d1c2d037978c3fde569":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3b5ee4c66244bdfcc4796a114519d47701b2c026"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3b5ee4c66244bdfcc4796a114519d47701b2c026","6d8714f9ceaaff94f0968d1c2d037978c3fde569"],"3b5ee4c66244bdfcc4796a114519d47701b2c026":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6d8714f9ceaaff94f0968d1c2d037978c3fde569":["3b5ee4c66244bdfcc4796a114519d47701b2c026"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}