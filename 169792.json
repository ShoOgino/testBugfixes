{"path":"solr/core/src/test/org/apache/solr/cloud/api/collections/ShardSplitTest#testSplitAfterFailedSplit().mjava","commits":[{"id":"6146c07c0dee1ae1e42926167acd127fed5ef59d","date":1516129420,"type":1,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/ShardSplitTest#testSplitAfterFailedSplit().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ShardSplitTest#testSplitAfterFailedSplit().mjava","sourceNew":"  /**\n   * Used to test that we can split a shard when a previous split event\n   * left sub-shards in construction or recovery state.\n   *\n   * See SOLR-9439\n   */\n  @Test\n  public void testSplitAfterFailedSplit() throws Exception {\n    waitForThingsToLevelOut(15);\n\n    TestInjection.splitFailureBeforeReplicaCreation = \"true:100\"; // we definitely want split to fail\n    try {\n      try {\n        CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n        splitShard.setShardName(SHARD1);\n        splitShard.process(cloudClient);\n        fail(\"Shard split was not supposed to succeed after failure injection!\");\n      } catch (Exception e) {\n        // expected\n      }\n\n      // assert that sub-shards cores exist and sub-shard is in construction state\n      ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n      zkStateReader.forceUpdateCollection(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n      ClusterState state = zkStateReader.getClusterState();\n      DocCollection collection = state.getCollection(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n\n      Slice shard10 = collection.getSlice(SHARD1_0);\n      assertEquals(Slice.State.CONSTRUCTION, shard10.getState());\n      assertEquals(1, shard10.getReplicas().size());\n\n      Slice shard11 = collection.getSlice(SHARD1_1);\n      assertEquals(Slice.State.CONSTRUCTION, shard11.getState());\n      assertEquals(1, shard11.getReplicas().size());\n\n      // lets retry the split\n      TestInjection.reset(); // let the split succeed\n      try {\n        CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n        splitShard.setShardName(SHARD1);\n        splitShard.process(cloudClient);\n        // Yay!\n      } catch (Exception e) {\n        log.error(\"Shard split failed\", e);\n        fail(\"Shard split did not succeed after a previous failed split attempt left sub-shards in construction state\");\n      }\n\n    } finally {\n      TestInjection.reset();\n    }\n  }\n\n","sourceOld":"  /**\n   * Used to test that we can split a shard when a previous split event\n   * left sub-shards in construction or recovery state.\n   *\n   * See SOLR-9439\n   */\n  @Test\n  public void testSplitAfterFailedSplit() throws Exception {\n    waitForThingsToLevelOut(15);\n\n    TestInjection.splitFailureBeforeReplicaCreation = \"true:100\"; // we definitely want split to fail\n    try {\n      try {\n        CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n        splitShard.setShardName(SHARD1);\n        splitShard.process(cloudClient);\n        fail(\"Shard split was not supposed to succeed after failure injection!\");\n      } catch (Exception e) {\n        // expected\n      }\n\n      // assert that sub-shards cores exist and sub-shard is in construction state\n      ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n      zkStateReader.forceUpdateCollection(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n      ClusterState state = zkStateReader.getClusterState();\n      DocCollection collection = state.getCollection(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n\n      Slice shard10 = collection.getSlice(SHARD1_0);\n      assertEquals(Slice.State.CONSTRUCTION, shard10.getState());\n      assertEquals(1, shard10.getReplicas().size());\n\n      Slice shard11 = collection.getSlice(SHARD1_1);\n      assertEquals(Slice.State.CONSTRUCTION, shard11.getState());\n      assertEquals(1, shard11.getReplicas().size());\n\n      // lets retry the split\n      TestInjection.reset(); // let the split succeed\n      try {\n        CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n        splitShard.setShardName(SHARD1);\n        splitShard.process(cloudClient);\n        // Yay!\n      } catch (Exception e) {\n        log.error(\"Shard split failed\", e);\n        fail(\"Shard split did not succeed after a previous failed split attempt left sub-shards in construction state\");\n      }\n\n    } finally {\n      TestInjection.reset();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":1,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/ShardSplitTest#testSplitAfterFailedSplit().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ShardSplitTest#testSplitAfterFailedSplit().mjava","sourceNew":"  /**\n   * Used to test that we can split a shard when a previous split event\n   * left sub-shards in construction or recovery state.\n   *\n   * See SOLR-9439\n   */\n  @Test\n  public void testSplitAfterFailedSplit() throws Exception {\n    waitForThingsToLevelOut(15);\n\n    TestInjection.splitFailureBeforeReplicaCreation = \"true:100\"; // we definitely want split to fail\n    try {\n      try {\n        CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n        splitShard.setShardName(SHARD1);\n        splitShard.process(cloudClient);\n        fail(\"Shard split was not supposed to succeed after failure injection!\");\n      } catch (Exception e) {\n        // expected\n      }\n\n      // assert that sub-shards cores exist and sub-shard is in construction state\n      ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n      zkStateReader.forceUpdateCollection(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n      ClusterState state = zkStateReader.getClusterState();\n      DocCollection collection = state.getCollection(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n\n      Slice shard10 = collection.getSlice(SHARD1_0);\n      assertEquals(Slice.State.CONSTRUCTION, shard10.getState());\n      assertEquals(1, shard10.getReplicas().size());\n\n      Slice shard11 = collection.getSlice(SHARD1_1);\n      assertEquals(Slice.State.CONSTRUCTION, shard11.getState());\n      assertEquals(1, shard11.getReplicas().size());\n\n      // lets retry the split\n      TestInjection.reset(); // let the split succeed\n      try {\n        CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n        splitShard.setShardName(SHARD1);\n        splitShard.process(cloudClient);\n        // Yay!\n      } catch (Exception e) {\n        log.error(\"Shard split failed\", e);\n        fail(\"Shard split did not succeed after a previous failed split attempt left sub-shards in construction state\");\n      }\n\n    } finally {\n      TestInjection.reset();\n    }\n  }\n\n","sourceOld":"  /**\n   * Used to test that we can split a shard when a previous split event\n   * left sub-shards in construction or recovery state.\n   *\n   * See SOLR-9439\n   */\n  @Test\n  public void testSplitAfterFailedSplit() throws Exception {\n    waitForThingsToLevelOut(15);\n\n    TestInjection.splitFailureBeforeReplicaCreation = \"true:100\"; // we definitely want split to fail\n    try {\n      try {\n        CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n        splitShard.setShardName(SHARD1);\n        splitShard.process(cloudClient);\n        fail(\"Shard split was not supposed to succeed after failure injection!\");\n      } catch (Exception e) {\n        // expected\n      }\n\n      // assert that sub-shards cores exist and sub-shard is in construction state\n      ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n      zkStateReader.forceUpdateCollection(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n      ClusterState state = zkStateReader.getClusterState();\n      DocCollection collection = state.getCollection(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n\n      Slice shard10 = collection.getSlice(SHARD1_0);\n      assertEquals(Slice.State.CONSTRUCTION, shard10.getState());\n      assertEquals(1, shard10.getReplicas().size());\n\n      Slice shard11 = collection.getSlice(SHARD1_1);\n      assertEquals(Slice.State.CONSTRUCTION, shard11.getState());\n      assertEquals(1, shard11.getReplicas().size());\n\n      // lets retry the split\n      TestInjection.reset(); // let the split succeed\n      try {\n        CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n        splitShard.setShardName(SHARD1);\n        splitShard.process(cloudClient);\n        // Yay!\n      } catch (Exception e) {\n        log.error(\"Shard split failed\", e);\n        fail(\"Shard split did not succeed after a previous failed split attempt left sub-shards in construction state\");\n      }\n\n    } finally {\n      TestInjection.reset();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7e16ac84f9e5d560008fe1554462ff8b853b3d3c","date":1520142134,"type":3,"author":"Erick","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/ShardSplitTest#testSplitAfterFailedSplit().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/api/collections/ShardSplitTest#testSplitAfterFailedSplit().mjava","sourceNew":"  /**\n   * Used to test that we can split a shard when a previous split event\n   * left sub-shards in construction or recovery state.\n   *\n   * See SOLR-9439\n   */\n  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void testSplitAfterFailedSplit() throws Exception {\n    waitForThingsToLevelOut(15);\n\n    TestInjection.splitFailureBeforeReplicaCreation = \"true:100\"; // we definitely want split to fail\n    try {\n      try {\n        CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n        splitShard.setShardName(SHARD1);\n        splitShard.process(cloudClient);\n        fail(\"Shard split was not supposed to succeed after failure injection!\");\n      } catch (Exception e) {\n        // expected\n      }\n\n      // assert that sub-shards cores exist and sub-shard is in construction state\n      ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n      zkStateReader.forceUpdateCollection(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n      ClusterState state = zkStateReader.getClusterState();\n      DocCollection collection = state.getCollection(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n\n      Slice shard10 = collection.getSlice(SHARD1_0);\n      assertEquals(Slice.State.CONSTRUCTION, shard10.getState());\n      assertEquals(1, shard10.getReplicas().size());\n\n      Slice shard11 = collection.getSlice(SHARD1_1);\n      assertEquals(Slice.State.CONSTRUCTION, shard11.getState());\n      assertEquals(1, shard11.getReplicas().size());\n\n      // lets retry the split\n      TestInjection.reset(); // let the split succeed\n      try {\n        CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n        splitShard.setShardName(SHARD1);\n        splitShard.process(cloudClient);\n        // Yay!\n      } catch (Exception e) {\n        log.error(\"Shard split failed\", e);\n        fail(\"Shard split did not succeed after a previous failed split attempt left sub-shards in construction state\");\n      }\n\n    } finally {\n      TestInjection.reset();\n    }\n  }\n\n","sourceOld":"  /**\n   * Used to test that we can split a shard when a previous split event\n   * left sub-shards in construction or recovery state.\n   *\n   * See SOLR-9439\n   */\n  @Test\n  public void testSplitAfterFailedSplit() throws Exception {\n    waitForThingsToLevelOut(15);\n\n    TestInjection.splitFailureBeforeReplicaCreation = \"true:100\"; // we definitely want split to fail\n    try {\n      try {\n        CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n        splitShard.setShardName(SHARD1);\n        splitShard.process(cloudClient);\n        fail(\"Shard split was not supposed to succeed after failure injection!\");\n      } catch (Exception e) {\n        // expected\n      }\n\n      // assert that sub-shards cores exist and sub-shard is in construction state\n      ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n      zkStateReader.forceUpdateCollection(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n      ClusterState state = zkStateReader.getClusterState();\n      DocCollection collection = state.getCollection(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n\n      Slice shard10 = collection.getSlice(SHARD1_0);\n      assertEquals(Slice.State.CONSTRUCTION, shard10.getState());\n      assertEquals(1, shard10.getReplicas().size());\n\n      Slice shard11 = collection.getSlice(SHARD1_1);\n      assertEquals(Slice.State.CONSTRUCTION, shard11.getState());\n      assertEquals(1, shard11.getReplicas().size());\n\n      // lets retry the split\n      TestInjection.reset(); // let the split succeed\n      try {\n        CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n        splitShard.setShardName(SHARD1);\n        splitShard.process(cloudClient);\n        // Yay!\n      } catch (Exception e) {\n        log.error(\"Shard split failed\", e);\n        fail(\"Shard split did not succeed after a previous failed split attempt left sub-shards in construction state\");\n      }\n\n    } finally {\n      TestInjection.reset();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"685af99397b6da31116a2cac747ed255d217d080","date":1530038134,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/ShardSplitTest#testSplitAfterFailedSplit().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/api/collections/ShardSplitTest#testSplitAfterFailedSplit().mjava","sourceNew":"  /**\n   * Used to test that we can split a shard when a previous split event\n   * left sub-shards in construction or recovery state.\n   *\n   * See SOLR-9439\n   */\n  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void testSplitAfterFailedSplit() throws Exception {\n    waitForThingsToLevelOut(15);\n\n    TestInjection.splitFailureBeforeReplicaCreation = \"true:100\"; // we definitely want split to fail\n    try {\n      try {\n        CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n        splitShard.setShardName(SHARD1);\n        splitShard.process(cloudClient);\n        fail(\"Shard split was not supposed to succeed after failure injection!\");\n      } catch (Exception e) {\n        // expected\n      }\n\n      // assert that sub-shards cores exist and sub-shard is in construction state\n      ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n      zkStateReader.forceUpdateCollection(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n      ClusterState state = zkStateReader.getClusterState();\n      DocCollection collection = state.getCollection(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n\n      // should be cleaned up\n      Slice shard10 = collection.getSlice(SHARD1_0);\n      assertNull(shard10);\n\n      Slice shard11 = collection.getSlice(SHARD1_1);\n      assertNull(shard11);\n\n      // lets retry the split\n      TestInjection.reset(); // let the split succeed\n      try {\n        CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n        splitShard.setShardName(SHARD1);\n        splitShard.process(cloudClient);\n        // Yay!\n      } catch (Exception e) {\n        log.error(\"Shard split failed\", e);\n        fail(\"Shard split did not succeed after a previous failed split attempt left sub-shards in construction state\");\n      }\n\n    } finally {\n      TestInjection.reset();\n    }\n  }\n\n","sourceOld":"  /**\n   * Used to test that we can split a shard when a previous split event\n   * left sub-shards in construction or recovery state.\n   *\n   * See SOLR-9439\n   */\n  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void testSplitAfterFailedSplit() throws Exception {\n    waitForThingsToLevelOut(15);\n\n    TestInjection.splitFailureBeforeReplicaCreation = \"true:100\"; // we definitely want split to fail\n    try {\n      try {\n        CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n        splitShard.setShardName(SHARD1);\n        splitShard.process(cloudClient);\n        fail(\"Shard split was not supposed to succeed after failure injection!\");\n      } catch (Exception e) {\n        // expected\n      }\n\n      // assert that sub-shards cores exist and sub-shard is in construction state\n      ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n      zkStateReader.forceUpdateCollection(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n      ClusterState state = zkStateReader.getClusterState();\n      DocCollection collection = state.getCollection(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n\n      Slice shard10 = collection.getSlice(SHARD1_0);\n      assertEquals(Slice.State.CONSTRUCTION, shard10.getState());\n      assertEquals(1, shard10.getReplicas().size());\n\n      Slice shard11 = collection.getSlice(SHARD1_1);\n      assertEquals(Slice.State.CONSTRUCTION, shard11.getState());\n      assertEquals(1, shard11.getReplicas().size());\n\n      // lets retry the split\n      TestInjection.reset(); // let the split succeed\n      try {\n        CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n        splitShard.setShardName(SHARD1);\n        splitShard.process(cloudClient);\n        // Yay!\n      } catch (Exception e) {\n        log.error(\"Shard split failed\", e);\n        fail(\"Shard split did not succeed after a previous failed split attempt left sub-shards in construction state\");\n      }\n\n    } finally {\n      TestInjection.reset();\n    }\n  }\n\n","bugFix":["d1d231959c9d0545adc421b7a2fefa7db47300d8"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f607a0a2e930f55385c7a24afb68ef661ef7e3ee","date":1530823671,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/ShardSplitTest#testSplitAfterFailedSplit().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/api/collections/ShardSplitTest#testSplitAfterFailedSplit().mjava","sourceNew":"  /**\n   * Used to test that we can split a shard when a previous split event\n   * left sub-shards in construction or recovery state.\n   *\n   * See SOLR-9439\n   */\n  @Test\n  //05-Jul-2018 @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void testSplitAfterFailedSplit() throws Exception {\n    waitForThingsToLevelOut(15);\n\n    TestInjection.splitFailureBeforeReplicaCreation = \"true:100\"; // we definitely want split to fail\n    try {\n      try {\n        CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n        splitShard.setShardName(SHARD1);\n        splitShard.process(cloudClient);\n        fail(\"Shard split was not supposed to succeed after failure injection!\");\n      } catch (Exception e) {\n        // expected\n      }\n\n      // assert that sub-shards cores exist and sub-shard is in construction state\n      ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n      zkStateReader.forceUpdateCollection(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n      ClusterState state = zkStateReader.getClusterState();\n      DocCollection collection = state.getCollection(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n\n      // should be cleaned up\n      Slice shard10 = collection.getSlice(SHARD1_0);\n      assertNull(shard10);\n\n      Slice shard11 = collection.getSlice(SHARD1_1);\n      assertNull(shard11);\n\n      // lets retry the split\n      TestInjection.reset(); // let the split succeed\n      try {\n        CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n        splitShard.setShardName(SHARD1);\n        splitShard.process(cloudClient);\n        // Yay!\n      } catch (Exception e) {\n        log.error(\"Shard split failed\", e);\n        fail(\"Shard split did not succeed after a previous failed split attempt left sub-shards in construction state\");\n      }\n\n    } finally {\n      TestInjection.reset();\n    }\n  }\n\n","sourceOld":"  /**\n   * Used to test that we can split a shard when a previous split event\n   * left sub-shards in construction or recovery state.\n   *\n   * See SOLR-9439\n   */\n  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void testSplitAfterFailedSplit() throws Exception {\n    waitForThingsToLevelOut(15);\n\n    TestInjection.splitFailureBeforeReplicaCreation = \"true:100\"; // we definitely want split to fail\n    try {\n      try {\n        CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n        splitShard.setShardName(SHARD1);\n        splitShard.process(cloudClient);\n        fail(\"Shard split was not supposed to succeed after failure injection!\");\n      } catch (Exception e) {\n        // expected\n      }\n\n      // assert that sub-shards cores exist and sub-shard is in construction state\n      ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n      zkStateReader.forceUpdateCollection(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n      ClusterState state = zkStateReader.getClusterState();\n      DocCollection collection = state.getCollection(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n\n      // should be cleaned up\n      Slice shard10 = collection.getSlice(SHARD1_0);\n      assertNull(shard10);\n\n      Slice shard11 = collection.getSlice(SHARD1_1);\n      assertNull(shard11);\n\n      // lets retry the split\n      TestInjection.reset(); // let the split succeed\n      try {\n        CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n        splitShard.setShardName(SHARD1);\n        splitShard.process(cloudClient);\n        // Yay!\n      } catch (Exception e) {\n        log.error(\"Shard split failed\", e);\n        fail(\"Shard split did not succeed after a previous failed split attempt left sub-shards in construction state\");\n      }\n\n    } finally {\n      TestInjection.reset();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/ShardSplitTest#testSplitAfterFailedSplit().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/api/collections/ShardSplitTest#testSplitAfterFailedSplit().mjava","sourceNew":"  /**\n   * Used to test that we can split a shard when a previous split event\n   * left sub-shards in construction or recovery state.\n   *\n   * See SOLR-9439\n   */\n  @Test\n  //05-Jul-2018 @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void testSplitAfterFailedSplit() throws Exception {\n    waitForThingsToLevelOut(15);\n\n    TestInjection.splitFailureBeforeReplicaCreation = \"true:100\"; // we definitely want split to fail\n    try {\n      try {\n        CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n        splitShard.setShardName(SHARD1);\n        splitShard.process(cloudClient);\n        fail(\"Shard split was not supposed to succeed after failure injection!\");\n      } catch (Exception e) {\n        // expected\n      }\n\n      // assert that sub-shards cores exist and sub-shard is in construction state\n      ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n      zkStateReader.forceUpdateCollection(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n      ClusterState state = zkStateReader.getClusterState();\n      DocCollection collection = state.getCollection(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n\n      // should be cleaned up\n      Slice shard10 = collection.getSlice(SHARD1_0);\n      assertNull(shard10);\n\n      Slice shard11 = collection.getSlice(SHARD1_1);\n      assertNull(shard11);\n\n      // lets retry the split\n      TestInjection.reset(); // let the split succeed\n      try {\n        CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n        splitShard.setShardName(SHARD1);\n        splitShard.process(cloudClient);\n        // Yay!\n      } catch (Exception e) {\n        log.error(\"Shard split failed\", e);\n        fail(\"Shard split did not succeed after a previous failed split attempt left sub-shards in construction state\");\n      }\n\n    } finally {\n      TestInjection.reset();\n    }\n  }\n\n","sourceOld":"  /**\n   * Used to test that we can split a shard when a previous split event\n   * left sub-shards in construction or recovery state.\n   *\n   * See SOLR-9439\n   */\n  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void testSplitAfterFailedSplit() throws Exception {\n    waitForThingsToLevelOut(15);\n\n    TestInjection.splitFailureBeforeReplicaCreation = \"true:100\"; // we definitely want split to fail\n    try {\n      try {\n        CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n        splitShard.setShardName(SHARD1);\n        splitShard.process(cloudClient);\n        fail(\"Shard split was not supposed to succeed after failure injection!\");\n      } catch (Exception e) {\n        // expected\n      }\n\n      // assert that sub-shards cores exist and sub-shard is in construction state\n      ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n      zkStateReader.forceUpdateCollection(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n      ClusterState state = zkStateReader.getClusterState();\n      DocCollection collection = state.getCollection(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n\n      Slice shard10 = collection.getSlice(SHARD1_0);\n      assertEquals(Slice.State.CONSTRUCTION, shard10.getState());\n      assertEquals(1, shard10.getReplicas().size());\n\n      Slice shard11 = collection.getSlice(SHARD1_1);\n      assertEquals(Slice.State.CONSTRUCTION, shard11.getState());\n      assertEquals(1, shard11.getReplicas().size());\n\n      // lets retry the split\n      TestInjection.reset(); // let the split succeed\n      try {\n        CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n        splitShard.setShardName(SHARD1);\n        splitShard.process(cloudClient);\n        // Yay!\n      } catch (Exception e) {\n        log.error(\"Shard split failed\", e);\n        fail(\"Shard split did not succeed after a previous failed split attempt left sub-shards in construction state\");\n      }\n\n    } finally {\n      TestInjection.reset();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/ShardSplitTest#testSplitAfterFailedSplit().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/api/collections/ShardSplitTest#testSplitAfterFailedSplit().mjava","sourceNew":"  /**\n   * Used to test that we can split a shard when a previous split event\n   * left sub-shards in construction or recovery state.\n   *\n   * See SOLR-9439\n   */\n  @Test\n  //05-Jul-2018 @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void testSplitAfterFailedSplit() throws Exception {\n    waitForThingsToLevelOut(15);\n\n    TestInjection.splitFailureBeforeReplicaCreation = \"true:100\"; // we definitely want split to fail\n    try {\n      try {\n        CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n        splitShard.setShardName(SHARD1);\n        splitShard.process(cloudClient);\n        fail(\"Shard split was not supposed to succeed after failure injection!\");\n      } catch (Exception e) {\n        // expected\n      }\n\n      // assert that sub-shards cores exist and sub-shard is in construction state\n      ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n      zkStateReader.forceUpdateCollection(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n      ClusterState state = zkStateReader.getClusterState();\n      DocCollection collection = state.getCollection(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n\n      // should be cleaned up\n      Slice shard10 = collection.getSlice(SHARD1_0);\n      assertNull(shard10);\n\n      Slice shard11 = collection.getSlice(SHARD1_1);\n      assertNull(shard11);\n\n      // lets retry the split\n      TestInjection.reset(); // let the split succeed\n      try {\n        CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n        splitShard.setShardName(SHARD1);\n        splitShard.process(cloudClient);\n        // Yay!\n      } catch (Exception e) {\n        log.error(\"Shard split failed\", e);\n        fail(\"Shard split did not succeed after a previous failed split attempt left sub-shards in construction state\");\n      }\n\n    } finally {\n      TestInjection.reset();\n    }\n  }\n\n","sourceOld":"  /**\n   * Used to test that we can split a shard when a previous split event\n   * left sub-shards in construction or recovery state.\n   *\n   * See SOLR-9439\n   */\n  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void testSplitAfterFailedSplit() throws Exception {\n    waitForThingsToLevelOut(15);\n\n    TestInjection.splitFailureBeforeReplicaCreation = \"true:100\"; // we definitely want split to fail\n    try {\n      try {\n        CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n        splitShard.setShardName(SHARD1);\n        splitShard.process(cloudClient);\n        fail(\"Shard split was not supposed to succeed after failure injection!\");\n      } catch (Exception e) {\n        // expected\n      }\n\n      // assert that sub-shards cores exist and sub-shard is in construction state\n      ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n      zkStateReader.forceUpdateCollection(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n      ClusterState state = zkStateReader.getClusterState();\n      DocCollection collection = state.getCollection(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n\n      Slice shard10 = collection.getSlice(SHARD1_0);\n      assertEquals(Slice.State.CONSTRUCTION, shard10.getState());\n      assertEquals(1, shard10.getReplicas().size());\n\n      Slice shard11 = collection.getSlice(SHARD1_1);\n      assertEquals(Slice.State.CONSTRUCTION, shard11.getState());\n      assertEquals(1, shard11.getReplicas().size());\n\n      // lets retry the split\n      TestInjection.reset(); // let the split succeed\n      try {\n        CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n        splitShard.setShardName(SHARD1);\n        splitShard.process(cloudClient);\n        // Yay!\n      } catch (Exception e) {\n        log.error(\"Shard split failed\", e);\n        fail(\"Shard split did not succeed after a previous failed split attempt left sub-shards in construction state\");\n      }\n\n    } finally {\n      TestInjection.reset();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0bf7adf1ef036dfc4a41cfc97d66997a0d54a0ca","date":1534412996,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/ShardSplitTest#testSplitAfterFailedSplit().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/api/collections/ShardSplitTest#testSplitAfterFailedSplit().mjava","sourceNew":"  /**\n   * Used to test that we can split a shard when a previous split event\n   * left sub-shards in construction or recovery state.\n   *\n   * See SOLR-9439\n   */\n  @Test\n  //05-Jul-2018 @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void testSplitAfterFailedSplit() throws Exception {\n    waitForThingsToLevelOut(15);\n\n    TestInjection.splitFailureBeforeReplicaCreation = \"true:100\"; // we definitely want split to fail\n    try {\n      splitAfterFailedSplit();\n    } finally {\n      TestInjection.reset();\n    }\n  }\n\n","sourceOld":"  /**\n   * Used to test that we can split a shard when a previous split event\n   * left sub-shards in construction or recovery state.\n   *\n   * See SOLR-9439\n   */\n  @Test\n  //05-Jul-2018 @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void testSplitAfterFailedSplit() throws Exception {\n    waitForThingsToLevelOut(15);\n\n    TestInjection.splitFailureBeforeReplicaCreation = \"true:100\"; // we definitely want split to fail\n    try {\n      try {\n        CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n        splitShard.setShardName(SHARD1);\n        splitShard.process(cloudClient);\n        fail(\"Shard split was not supposed to succeed after failure injection!\");\n      } catch (Exception e) {\n        // expected\n      }\n\n      // assert that sub-shards cores exist and sub-shard is in construction state\n      ZkStateReader zkStateReader = cloudClient.getZkStateReader();\n      zkStateReader.forceUpdateCollection(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n      ClusterState state = zkStateReader.getClusterState();\n      DocCollection collection = state.getCollection(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n\n      // should be cleaned up\n      Slice shard10 = collection.getSlice(SHARD1_0);\n      assertNull(shard10);\n\n      Slice shard11 = collection.getSlice(SHARD1_1);\n      assertNull(shard11);\n\n      // lets retry the split\n      TestInjection.reset(); // let the split succeed\n      try {\n        CollectionAdminRequest.SplitShard splitShard = CollectionAdminRequest.splitShard(AbstractDistribZkTestBase.DEFAULT_COLLECTION);\n        splitShard.setShardName(SHARD1);\n        splitShard.process(cloudClient);\n        // Yay!\n      } catch (Exception e) {\n        log.error(\"Shard split failed\", e);\n        fail(\"Shard split did not succeed after a previous failed split attempt left sub-shards in construction state\");\n      }\n\n    } finally {\n      TestInjection.reset();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"14076e7b40405aa1f08702d8df762d08b5d44f70","date":1537071979,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/ShardSplitTest#testSplitAfterFailedSplit().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/api/collections/ShardSplitTest#testSplitAfterFailedSplit().mjava","sourceNew":"  /**\n   * Used to test that we can split a shard when a previous split event\n   * left sub-shards in construction or recovery state.\n   *\n   * See SOLR-9439\n   */\n  @Test\n  //05-Jul-2018 @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // added 15-Sep-2018\n  public void testSplitAfterFailedSplit() throws Exception {\n    waitForThingsToLevelOut(15);\n\n    TestInjection.splitFailureBeforeReplicaCreation = \"true:100\"; // we definitely want split to fail\n    try {\n      splitAfterFailedSplit();\n    } finally {\n      TestInjection.reset();\n    }\n  }\n\n","sourceOld":"  /**\n   * Used to test that we can split a shard when a previous split event\n   * left sub-shards in construction or recovery state.\n   *\n   * See SOLR-9439\n   */\n  @Test\n  //05-Jul-2018 @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void testSplitAfterFailedSplit() throws Exception {\n    waitForThingsToLevelOut(15);\n\n    TestInjection.splitFailureBeforeReplicaCreation = \"true:100\"; // we definitely want split to fail\n    try {\n      splitAfterFailedSplit();\n    } finally {\n      TestInjection.reset();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8d35c84fdef07284c122012ca4000d3b7285a66e","date":1545962630,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/ShardSplitTest#testSplitAfterFailedSplit().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/api/collections/ShardSplitTest#testSplitAfterFailedSplit().mjava","sourceNew":"  /**\n   * Used to test that we can split a shard when a previous split event\n   * left sub-shards in construction or recovery state.\n   *\n   * See SOLR-9439\n   */\n  @Test\n  //05-Jul-2018 @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  // commented out on: 24-Dec-2018   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // added 15-Sep-2018\n  public void testSplitAfterFailedSplit() throws Exception {\n    waitForThingsToLevelOut(15);\n\n    TestInjection.splitFailureBeforeReplicaCreation = \"true:100\"; // we definitely want split to fail\n    try {\n      splitAfterFailedSplit();\n    } finally {\n      TestInjection.reset();\n    }\n  }\n\n","sourceOld":"  /**\n   * Used to test that we can split a shard when a previous split event\n   * left sub-shards in construction or recovery state.\n   *\n   * See SOLR-9439\n   */\n  @Test\n  //05-Jul-2018 @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // added 15-Sep-2018\n  public void testSplitAfterFailedSplit() throws Exception {\n    waitForThingsToLevelOut(15);\n\n    TestInjection.splitFailureBeforeReplicaCreation = \"true:100\"; // we definitely want split to fail\n    try {\n      splitAfterFailedSplit();\n    } finally {\n      TestInjection.reset();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"add1e7dd742ea533ff4318cea83ca0a1f669f662","date":1585262285,"type":3,"author":"Mike Drob","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/ShardSplitTest#testSplitAfterFailedSplit().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/api/collections/ShardSplitTest#testSplitAfterFailedSplit().mjava","sourceNew":"  /**\n   * Used to test that we can split a shard when a previous split event\n   * left sub-shards in construction or recovery state.\n   *\n   * See SOLR-9439\n   */\n  @Test\n  //05-Jul-2018 @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  // commented out on: 24-Dec-2018   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // added 15-Sep-2018\n  public void testSplitAfterFailedSplit() throws Exception {\n    waitForThingsToLevelOut(15, TimeUnit.SECONDS);\n\n    TestInjection.splitFailureBeforeReplicaCreation = \"true:100\"; // we definitely want split to fail\n    try {\n      splitAfterFailedSplit();\n    } finally {\n      TestInjection.reset();\n    }\n  }\n\n","sourceOld":"  /**\n   * Used to test that we can split a shard when a previous split event\n   * left sub-shards in construction or recovery state.\n   *\n   * See SOLR-9439\n   */\n  @Test\n  //05-Jul-2018 @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  // commented out on: 24-Dec-2018   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // added 15-Sep-2018\n  public void testSplitAfterFailedSplit() throws Exception {\n    waitForThingsToLevelOut(15);\n\n    TestInjection.splitFailureBeforeReplicaCreation = \"true:100\"; // we definitely want split to fail\n    try {\n      splitAfterFailedSplit();\n    } finally {\n      TestInjection.reset();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7e16ac84f9e5d560008fe1554462ff8b853b3d3c":["b94236357aaa22b76c10629851fe4e376e0cea82"],"b94236357aaa22b76c10629851fe4e376e0cea82":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"685af99397b6da31116a2cac747ed255d217d080":["7e16ac84f9e5d560008fe1554462ff8b853b3d3c"],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"14076e7b40405aa1f08702d8df762d08b5d44f70":["0bf7adf1ef036dfc4a41cfc97d66997a0d54a0ca"],"8d35c84fdef07284c122012ca4000d3b7285a66e":["14076e7b40405aa1f08702d8df762d08b5d44f70"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["7e16ac84f9e5d560008fe1554462ff8b853b3d3c","f607a0a2e930f55385c7a24afb68ef661ef7e3ee"],"0bf7adf1ef036dfc4a41cfc97d66997a0d54a0ca":["f607a0a2e930f55385c7a24afb68ef661ef7e3ee"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"add1e7dd742ea533ff4318cea83ca0a1f669f662":["8d35c84fdef07284c122012ca4000d3b7285a66e"],"f607a0a2e930f55385c7a24afb68ef661ef7e3ee":["685af99397b6da31116a2cac747ed255d217d080"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["add1e7dd742ea533ff4318cea83ca0a1f669f662"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["7e16ac84f9e5d560008fe1554462ff8b853b3d3c","f607a0a2e930f55385c7a24afb68ef661ef7e3ee"]},"commit2Childs":{"7e16ac84f9e5d560008fe1554462ff8b853b3d3c":["685af99397b6da31116a2cac747ed255d217d080","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"b94236357aaa22b76c10629851fe4e376e0cea82":["7e16ac84f9e5d560008fe1554462ff8b853b3d3c"],"685af99397b6da31116a2cac747ed255d217d080":["f607a0a2e930f55385c7a24afb68ef661ef7e3ee"],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["b94236357aaa22b76c10629851fe4e376e0cea82"],"14076e7b40405aa1f08702d8df762d08b5d44f70":["8d35c84fdef07284c122012ca4000d3b7285a66e"],"8d35c84fdef07284c122012ca4000d3b7285a66e":["add1e7dd742ea533ff4318cea83ca0a1f669f662"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b94236357aaa22b76c10629851fe4e376e0cea82","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"0bf7adf1ef036dfc4a41cfc97d66997a0d54a0ca":["14076e7b40405aa1f08702d8df762d08b5d44f70"],"add1e7dd742ea533ff4318cea83ca0a1f669f662":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f607a0a2e930f55385c7a24afb68ef661ef7e3ee":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","0bf7adf1ef036dfc4a41cfc97d66997a0d54a0ca","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}