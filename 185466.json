{"path":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint#nearest(IndexSearcher,String,double,double,int).mjava","commits":[{"id":"b01431682e11036a1a7d757a3fa7c1f903fb2c45","date":1460646145,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint#nearest(IndexSearcher,String,double,double,int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Finds the {@code topN} nearest indexed points to the provided point, according to Haversine distance.\n   * This is functionally equivalent to running {@link MatchAllDocsQuery} with a {@link #newDistanceSort},\n   * but is far more efficient since it takes advantage of properties the indexed BKD tree.  Currently this\n   * only works with {@link Lucene60PointsFormat} (used by the default codec).\n   */\n  public static TopFieldDocs nearest(IndexSearcher s, String fieldName, double latitude, double longitude, int n) throws IOException {\n    List<BKDReader> readers = new ArrayList<>();\n    List<Integer> docBases = new ArrayList<>();\n    List<Bits> liveDocs = new ArrayList<>();\n    int totalHits = 0;\n    for(LeafReaderContext leaf : s.getIndexReader().leaves()) {\n      PointValues points = leaf.reader().getPointValues();\n      if (points != null) {\n        if (points instanceof Lucene60PointsReader == false) {\n          throw new IllegalArgumentException(\"can only run on Lucene60PointsReader points implementation, but got \" + points);\n        }\n        totalHits += points.getDocCount(fieldName);\n        BKDReader reader = ((Lucene60PointsReader) points).getBKDReader(fieldName);\n        if (reader != null) {\n          readers.add(reader);\n          docBases.add(leaf.docBase);\n          liveDocs.add(leaf.reader().getLiveDocs());\n        }\n      }\n    }\n\n    NearestNeighbor.NearestHit[] hits = NearestNeighbor.nearest(latitude, longitude, readers, liveDocs, docBases, n);\n\n    // Convert to TopFieldDocs:\n    ScoreDoc[] scoreDocs = new ScoreDoc[hits.length];\n    for(int i=0;i<hits.length;i++) {\n      NearestNeighbor.NearestHit hit = hits[i];\n      scoreDocs[i] = new FieldDoc(hit.docID, 0.0f, new Object[] {Double.valueOf(hit.distanceMeters)});\n    }\n    return new TopFieldDocs(totalHits, scoreDocs, null, 0.0f);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"20525bc1c12e6c61555b30ae60d9c1d2d005024f","date":1460745922,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint#nearest(IndexSearcher,String,double,double,int).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint#nearest(IndexSearcher,String,double,double,int).mjava","sourceNew":"  /**\n   * Finds the {@code n} nearest indexed points to the provided point, according to Haversine distance.\n   * <p>\n   * This is functionally equivalent to running {@link MatchAllDocsQuery} with a {@link #newDistanceSort},\n   * but is far more efficient since it takes advantage of properties the indexed BKD tree.  Currently this\n   * only works with {@link Lucene60PointsFormat} (used by the default codec).\n   * <p>\n   * Documents are ordered by ascending distance from the location. The value returned in {@link FieldDoc} for\n   * the hits contains a Double instance with the distance in meters.\n   * \n   * @param searcher IndexSearcher to find nearest points from.\n   * @param field field name. must not be null.\n   * @param latitude latitude at the center: must be within standard +/-90 coordinate bounds.\n   * @param longitude longitude at the center: must be within standard +/-180 coordinate bounds.\n   * @param n the number of nearest neighbors to retrieve.\n   * @return TopFieldDocs containing documents ordered by distance.\n   * @throws IllegalArgumentException if the underlying PointValues is not a {@code Lucene60PointsReader} (this is a current limitation).\n   * @throws IOException if an IOException occurs while finding the points.\n   */\n  // TODO: what about multi-valued documents? what happens?\n  // TODO: parameter checking, what if i pass a negative n, bogus latitude, null field,etc?\n  public static TopFieldDocs nearest(IndexSearcher searcher, String field, double latitude, double longitude, int n) throws IOException {\n    List<BKDReader> readers = new ArrayList<>();\n    List<Integer> docBases = new ArrayList<>();\n    List<Bits> liveDocs = new ArrayList<>();\n    int totalHits = 0;\n    for(LeafReaderContext leaf : searcher.getIndexReader().leaves()) {\n      PointValues points = leaf.reader().getPointValues();\n      if (points != null) {\n        if (points instanceof Lucene60PointsReader == false) {\n          throw new IllegalArgumentException(\"can only run on Lucene60PointsReader points implementation, but got \" + points);\n        }\n        totalHits += points.getDocCount(field);\n        BKDReader reader = ((Lucene60PointsReader) points).getBKDReader(field);\n        if (reader != null) {\n          readers.add(reader);\n          docBases.add(leaf.docBase);\n          liveDocs.add(leaf.reader().getLiveDocs());\n        }\n      }\n    }\n\n    NearestNeighbor.NearestHit[] hits = NearestNeighbor.nearest(latitude, longitude, readers, liveDocs, docBases, n);\n\n    // Convert to TopFieldDocs:\n    ScoreDoc[] scoreDocs = new ScoreDoc[hits.length];\n    for(int i=0;i<hits.length;i++) {\n      NearestNeighbor.NearestHit hit = hits[i];\n      scoreDocs[i] = new FieldDoc(hit.docID, 0.0f, new Object[] {Double.valueOf(hit.distanceMeters)});\n    }\n    return new TopFieldDocs(totalHits, scoreDocs, null, 0.0f);\n  }\n\n","sourceOld":"  /**\n   * Finds the {@code topN} nearest indexed points to the provided point, according to Haversine distance.\n   * This is functionally equivalent to running {@link MatchAllDocsQuery} with a {@link #newDistanceSort},\n   * but is far more efficient since it takes advantage of properties the indexed BKD tree.  Currently this\n   * only works with {@link Lucene60PointsFormat} (used by the default codec).\n   */\n  public static TopFieldDocs nearest(IndexSearcher s, String fieldName, double latitude, double longitude, int n) throws IOException {\n    List<BKDReader> readers = new ArrayList<>();\n    List<Integer> docBases = new ArrayList<>();\n    List<Bits> liveDocs = new ArrayList<>();\n    int totalHits = 0;\n    for(LeafReaderContext leaf : s.getIndexReader().leaves()) {\n      PointValues points = leaf.reader().getPointValues();\n      if (points != null) {\n        if (points instanceof Lucene60PointsReader == false) {\n          throw new IllegalArgumentException(\"can only run on Lucene60PointsReader points implementation, but got \" + points);\n        }\n        totalHits += points.getDocCount(fieldName);\n        BKDReader reader = ((Lucene60PointsReader) points).getBKDReader(fieldName);\n        if (reader != null) {\n          readers.add(reader);\n          docBases.add(leaf.docBase);\n          liveDocs.add(leaf.reader().getLiveDocs());\n        }\n      }\n    }\n\n    NearestNeighbor.NearestHit[] hits = NearestNeighbor.nearest(latitude, longitude, readers, liveDocs, docBases, n);\n\n    // Convert to TopFieldDocs:\n    ScoreDoc[] scoreDocs = new ScoreDoc[hits.length];\n    for(int i=0;i<hits.length;i++) {\n      NearestNeighbor.NearestHit hit = hits[i];\n      scoreDocs[i] = new FieldDoc(hit.docID, 0.0f, new Object[] {Double.valueOf(hit.distanceMeters)});\n    }\n    return new TopFieldDocs(totalHits, scoreDocs, null, 0.0f);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d925740d44a439905255b03982e9c8cf281c01a4","date":1460753738,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint#nearest(IndexSearcher,String,double,double,int).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint#nearest(IndexSearcher,String,double,double,int).mjava","sourceNew":"  /**\n   * Finds the {@code n} nearest indexed points to the provided point, according to Haversine distance.\n   * <p>\n   * This is functionally equivalent to running {@link MatchAllDocsQuery} with a {@link #newDistanceSort},\n   * but is far more efficient since it takes advantage of properties the indexed BKD tree.  Currently this\n   * only works with {@link Lucene60PointsFormat} (used by the default codec).  Multi-valued fields are\n   * currently not de-duplicated, so if a document had multiple instances of the specified field that\n   * make it into the top n, that document will appear more than once.\n   * <p>\n   * Documents are ordered by ascending distance from the location. The value returned in {@link FieldDoc} for\n   * the hits contains a Double instance with the distance in meters.\n   * \n   * @param searcher IndexSearcher to find nearest points from.\n   * @param field field name. must not be null.\n   * @param latitude latitude at the center: must be within standard +/-90 coordinate bounds.\n   * @param longitude longitude at the center: must be within standard +/-180 coordinate bounds.\n   * @param n the number of nearest neighbors to retrieve.\n   * @return TopFieldDocs containing documents ordered by distance, where the field value for each {@link FieldDoc} is the distance in meters\n   * @throws IllegalArgumentException if the underlying PointValues is not a {@code Lucene60PointsReader} (this is a current limitation), or\n   *         if {@code field} or {@code searcher} is null, or if {@code latitude}, {@code longitude} or {@code n} are out-of-bounds\n   * @throws IOException if an IOException occurs while finding the points.\n   */\n  // TODO: what about multi-valued documents? what happens?\n  public static TopFieldDocs nearest(IndexSearcher searcher, String field, double latitude, double longitude, int n) throws IOException {\n    GeoUtils.checkLatitude(latitude);\n    GeoUtils.checkLongitude(longitude);\n    if (n < 1) {\n      throw new IllegalArgumentException(\"n must be at least 1; got \" + n);\n    }\n    if (field == null) {\n      throw new IllegalArgumentException(\"field must not be null\");\n    }\n    if (searcher == null) {\n      throw new IllegalArgumentException(\"searcher must not be null\");\n    }\n    List<BKDReader> readers = new ArrayList<>();\n    List<Integer> docBases = new ArrayList<>();\n    List<Bits> liveDocs = new ArrayList<>();\n    int totalHits = 0;\n    for(LeafReaderContext leaf : searcher.getIndexReader().leaves()) {\n      PointValues points = leaf.reader().getPointValues();\n      if (points != null) {\n        if (points instanceof Lucene60PointsReader == false) {\n          throw new IllegalArgumentException(\"can only run on Lucene60PointsReader points implementation, but got \" + points);\n        }\n        totalHits += points.getDocCount(field);\n        BKDReader reader = ((Lucene60PointsReader) points).getBKDReader(field);\n        if (reader != null) {\n          readers.add(reader);\n          docBases.add(leaf.docBase);\n          liveDocs.add(leaf.reader().getLiveDocs());\n        }\n      }\n    }\n\n    NearestNeighbor.NearestHit[] hits = NearestNeighbor.nearest(latitude, longitude, readers, liveDocs, docBases, n);\n\n    // Convert to TopFieldDocs:\n    ScoreDoc[] scoreDocs = new ScoreDoc[hits.length];\n    for(int i=0;i<hits.length;i++) {\n      NearestNeighbor.NearestHit hit = hits[i];\n      scoreDocs[i] = new FieldDoc(hit.docID, 0.0f, new Object[] {Double.valueOf(hit.distanceMeters)});\n    }\n    return new TopFieldDocs(totalHits, scoreDocs, null, 0.0f);\n  }\n\n","sourceOld":"  /**\n   * Finds the {@code n} nearest indexed points to the provided point, according to Haversine distance.\n   * <p>\n   * This is functionally equivalent to running {@link MatchAllDocsQuery} with a {@link #newDistanceSort},\n   * but is far more efficient since it takes advantage of properties the indexed BKD tree.  Currently this\n   * only works with {@link Lucene60PointsFormat} (used by the default codec).\n   * <p>\n   * Documents are ordered by ascending distance from the location. The value returned in {@link FieldDoc} for\n   * the hits contains a Double instance with the distance in meters.\n   * \n   * @param searcher IndexSearcher to find nearest points from.\n   * @param field field name. must not be null.\n   * @param latitude latitude at the center: must be within standard +/-90 coordinate bounds.\n   * @param longitude longitude at the center: must be within standard +/-180 coordinate bounds.\n   * @param n the number of nearest neighbors to retrieve.\n   * @return TopFieldDocs containing documents ordered by distance.\n   * @throws IllegalArgumentException if the underlying PointValues is not a {@code Lucene60PointsReader} (this is a current limitation).\n   * @throws IOException if an IOException occurs while finding the points.\n   */\n  // TODO: what about multi-valued documents? what happens?\n  // TODO: parameter checking, what if i pass a negative n, bogus latitude, null field,etc?\n  public static TopFieldDocs nearest(IndexSearcher searcher, String field, double latitude, double longitude, int n) throws IOException {\n    List<BKDReader> readers = new ArrayList<>();\n    List<Integer> docBases = new ArrayList<>();\n    List<Bits> liveDocs = new ArrayList<>();\n    int totalHits = 0;\n    for(LeafReaderContext leaf : searcher.getIndexReader().leaves()) {\n      PointValues points = leaf.reader().getPointValues();\n      if (points != null) {\n        if (points instanceof Lucene60PointsReader == false) {\n          throw new IllegalArgumentException(\"can only run on Lucene60PointsReader points implementation, but got \" + points);\n        }\n        totalHits += points.getDocCount(field);\n        BKDReader reader = ((Lucene60PointsReader) points).getBKDReader(field);\n        if (reader != null) {\n          readers.add(reader);\n          docBases.add(leaf.docBase);\n          liveDocs.add(leaf.reader().getLiveDocs());\n        }\n      }\n    }\n\n    NearestNeighbor.NearestHit[] hits = NearestNeighbor.nearest(latitude, longitude, readers, liveDocs, docBases, n);\n\n    // Convert to TopFieldDocs:\n    ScoreDoc[] scoreDocs = new ScoreDoc[hits.length];\n    for(int i=0;i<hits.length;i++) {\n      NearestNeighbor.NearestHit hit = hits[i];\n      scoreDocs[i] = new FieldDoc(hit.docID, 0.0f, new Object[] {Double.valueOf(hit.distanceMeters)});\n    }\n    return new TopFieldDocs(totalHits, scoreDocs, null, 0.0f);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"73457c9372b4f2f962ca916788a5fe9e1f644a9f","date":1460794059,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint#nearest(IndexSearcher,String,double,double,int).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint#nearest(IndexSearcher,String,double,double,int).mjava","sourceNew":"  /**\n   * Finds the {@code n} nearest indexed points to the provided point, according to Haversine distance.\n   * <p>\n   * This is functionally equivalent to running {@link MatchAllDocsQuery} with a {@link #newDistanceSort},\n   * but is far more efficient since it takes advantage of properties the indexed BKD tree.  Currently this\n   * only works with {@link Lucene60PointsFormat} (used by the default codec).  Multi-valued fields are\n   * currently not de-duplicated, so if a document had multiple instances of the specified field that\n   * make it into the top n, that document will appear more than once.\n   * <p>\n   * Documents are ordered by ascending distance from the location. The value returned in {@link FieldDoc} for\n   * the hits contains a Double instance with the distance in meters.\n   * \n   * @param searcher IndexSearcher to find nearest points from.\n   * @param field field name. must not be null.\n   * @param latitude latitude at the center: must be within standard +/-90 coordinate bounds.\n   * @param longitude longitude at the center: must be within standard +/-180 coordinate bounds.\n   * @param n the number of nearest neighbors to retrieve.\n   * @return TopFieldDocs containing documents ordered by distance, where the field value for each {@link FieldDoc} is the distance in meters\n   * @throws IllegalArgumentException if the underlying PointValues is not a {@code Lucene60PointsReader} (this is a current limitation), or\n   *         if {@code field} or {@code searcher} is null, or if {@code latitude}, {@code longitude} or {@code n} are out-of-bounds\n   * @throws IOException if an IOException occurs while finding the points.\n   */\n  // TODO: what about multi-valued documents? what happens?\n  public static TopFieldDocs nearest(IndexSearcher searcher, String field, double latitude, double longitude, int n) throws IOException {\n    GeoUtils.checkLatitude(latitude);\n    GeoUtils.checkLongitude(longitude);\n    if (n < 1) {\n      throw new IllegalArgumentException(\"n must be at least 1; got \" + n);\n    }\n    if (field == null) {\n      throw new IllegalArgumentException(\"field must not be null\");\n    }\n    if (searcher == null) {\n      throw new IllegalArgumentException(\"searcher must not be null\");\n    }\n    List<BKDReader> readers = new ArrayList<>();\n    List<Integer> docBases = new ArrayList<>();\n    List<Bits> liveDocs = new ArrayList<>();\n    int totalHits = 0;\n    for(LeafReaderContext leaf : searcher.getIndexReader().leaves()) {\n      PointValues points = leaf.reader().getPointValues();\n      if (points != null) {\n        if (points instanceof Lucene60PointsReader == false) {\n          throw new IllegalArgumentException(\"can only run on Lucene60PointsReader points implementation, but got \" + points);\n        }\n        totalHits += points.getDocCount(field);\n        BKDReader reader = ((Lucene60PointsReader) points).getBKDReader(field);\n        if (reader != null) {\n          readers.add(reader);\n          docBases.add(leaf.docBase);\n          liveDocs.add(leaf.reader().getLiveDocs());\n        }\n      }\n    }\n\n    NearestNeighbor.NearestHit[] hits = NearestNeighbor.nearest(latitude, longitude, readers, liveDocs, docBases, n);\n\n    // Convert to TopFieldDocs:\n    ScoreDoc[] scoreDocs = new ScoreDoc[hits.length];\n    for(int i=0;i<hits.length;i++) {\n      NearestNeighbor.NearestHit hit = hits[i];\n      scoreDocs[i] = new FieldDoc(hit.docID, 0.0f, new Object[] {Double.valueOf(hit.distanceMeters)});\n    }\n    return new TopFieldDocs(totalHits, scoreDocs, null, 0.0f);\n  }\n\n","sourceOld":"  /**\n   * Finds the {@code topN} nearest indexed points to the provided point, according to Haversine distance.\n   * This is functionally equivalent to running {@link MatchAllDocsQuery} with a {@link #newDistanceSort},\n   * but is far more efficient since it takes advantage of properties the indexed BKD tree.  Currently this\n   * only works with {@link Lucene60PointsFormat} (used by the default codec).\n   */\n  public static TopFieldDocs nearest(IndexSearcher s, String fieldName, double latitude, double longitude, int n) throws IOException {\n    List<BKDReader> readers = new ArrayList<>();\n    List<Integer> docBases = new ArrayList<>();\n    List<Bits> liveDocs = new ArrayList<>();\n    int totalHits = 0;\n    for(LeafReaderContext leaf : s.getIndexReader().leaves()) {\n      PointValues points = leaf.reader().getPointValues();\n      if (points != null) {\n        if (points instanceof Lucene60PointsReader == false) {\n          throw new IllegalArgumentException(\"can only run on Lucene60PointsReader points implementation, but got \" + points);\n        }\n        totalHits += points.getDocCount(fieldName);\n        BKDReader reader = ((Lucene60PointsReader) points).getBKDReader(fieldName);\n        if (reader != null) {\n          readers.add(reader);\n          docBases.add(leaf.docBase);\n          liveDocs.add(leaf.reader().getLiveDocs());\n        }\n      }\n    }\n\n    NearestNeighbor.NearestHit[] hits = NearestNeighbor.nearest(latitude, longitude, readers, liveDocs, docBases, n);\n\n    // Convert to TopFieldDocs:\n    ScoreDoc[] scoreDocs = new ScoreDoc[hits.length];\n    for(int i=0;i<hits.length;i++) {\n      NearestNeighbor.NearestHit hit = hits[i];\n      scoreDocs[i] = new FieldDoc(hit.docID, 0.0f, new Object[] {Double.valueOf(hit.distanceMeters)});\n    }\n    return new TopFieldDocs(totalHits, scoreDocs, null, 0.0f);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cc75470f235495b4ac71f43bba9b503023f7f2d0","date":1461532530,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint#nearest(IndexSearcher,String,double,double,int).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint#nearest(IndexSearcher,String,double,double,int).mjava","sourceNew":"  /**\n   * Finds the {@code n} nearest indexed points to the provided point, according to Haversine distance.\n   * <p>\n   * This is functionally equivalent to running {@link MatchAllDocsQuery} with a {@link LatLonDocValuesField#newDistanceSort},\n   * but is far more efficient since it takes advantage of properties the indexed BKD tree.  Currently this\n   * only works with {@link Lucene60PointsFormat} (used by the default codec).  Multi-valued fields are\n   * currently not de-duplicated, so if a document had multiple instances of the specified field that\n   * make it into the top n, that document will appear more than once.\n   * <p>\n   * Documents are ordered by ascending distance from the location. The value returned in {@link FieldDoc} for\n   * the hits contains a Double instance with the distance in meters.\n   * \n   * @param searcher IndexSearcher to find nearest points from.\n   * @param field field name. must not be null.\n   * @param latitude latitude at the center: must be within standard +/-90 coordinate bounds.\n   * @param longitude longitude at the center: must be within standard +/-180 coordinate bounds.\n   * @param n the number of nearest neighbors to retrieve.\n   * @return TopFieldDocs containing documents ordered by distance, where the field value for each {@link FieldDoc} is the distance in meters\n   * @throws IllegalArgumentException if the underlying PointValues is not a {@code Lucene60PointsReader} (this is a current limitation), or\n   *         if {@code field} or {@code searcher} is null, or if {@code latitude}, {@code longitude} or {@code n} are out-of-bounds\n   * @throws IOException if an IOException occurs while finding the points.\n   */\n  // TODO: what about multi-valued documents? what happens?\n  public static TopFieldDocs nearest(IndexSearcher searcher, String field, double latitude, double longitude, int n) throws IOException {\n    GeoUtils.checkLatitude(latitude);\n    GeoUtils.checkLongitude(longitude);\n    if (n < 1) {\n      throw new IllegalArgumentException(\"n must be at least 1; got \" + n);\n    }\n    if (field == null) {\n      throw new IllegalArgumentException(\"field must not be null\");\n    }\n    if (searcher == null) {\n      throw new IllegalArgumentException(\"searcher must not be null\");\n    }\n    List<BKDReader> readers = new ArrayList<>();\n    List<Integer> docBases = new ArrayList<>();\n    List<Bits> liveDocs = new ArrayList<>();\n    int totalHits = 0;\n    for(LeafReaderContext leaf : searcher.getIndexReader().leaves()) {\n      PointValues points = leaf.reader().getPointValues();\n      if (points != null) {\n        if (points instanceof Lucene60PointsReader == false) {\n          throw new IllegalArgumentException(\"can only run on Lucene60PointsReader points implementation, but got \" + points);\n        }\n        totalHits += points.getDocCount(field);\n        BKDReader reader = ((Lucene60PointsReader) points).getBKDReader(field);\n        if (reader != null) {\n          readers.add(reader);\n          docBases.add(leaf.docBase);\n          liveDocs.add(leaf.reader().getLiveDocs());\n        }\n      }\n    }\n\n    NearestNeighbor.NearestHit[] hits = NearestNeighbor.nearest(latitude, longitude, readers, liveDocs, docBases, n);\n\n    // Convert to TopFieldDocs:\n    ScoreDoc[] scoreDocs = new ScoreDoc[hits.length];\n    for(int i=0;i<hits.length;i++) {\n      NearestNeighbor.NearestHit hit = hits[i];\n      scoreDocs[i] = new FieldDoc(hit.docID, 0.0f, new Object[] {Double.valueOf(hit.distanceMeters)});\n    }\n    return new TopFieldDocs(totalHits, scoreDocs, null, 0.0f);\n  }\n\n","sourceOld":"  /**\n   * Finds the {@code n} nearest indexed points to the provided point, according to Haversine distance.\n   * <p>\n   * This is functionally equivalent to running {@link MatchAllDocsQuery} with a {@link #newDistanceSort},\n   * but is far more efficient since it takes advantage of properties the indexed BKD tree.  Currently this\n   * only works with {@link Lucene60PointsFormat} (used by the default codec).  Multi-valued fields are\n   * currently not de-duplicated, so if a document had multiple instances of the specified field that\n   * make it into the top n, that document will appear more than once.\n   * <p>\n   * Documents are ordered by ascending distance from the location. The value returned in {@link FieldDoc} for\n   * the hits contains a Double instance with the distance in meters.\n   * \n   * @param searcher IndexSearcher to find nearest points from.\n   * @param field field name. must not be null.\n   * @param latitude latitude at the center: must be within standard +/-90 coordinate bounds.\n   * @param longitude longitude at the center: must be within standard +/-180 coordinate bounds.\n   * @param n the number of nearest neighbors to retrieve.\n   * @return TopFieldDocs containing documents ordered by distance, where the field value for each {@link FieldDoc} is the distance in meters\n   * @throws IllegalArgumentException if the underlying PointValues is not a {@code Lucene60PointsReader} (this is a current limitation), or\n   *         if {@code field} or {@code searcher} is null, or if {@code latitude}, {@code longitude} or {@code n} are out-of-bounds\n   * @throws IOException if an IOException occurs while finding the points.\n   */\n  // TODO: what about multi-valued documents? what happens?\n  public static TopFieldDocs nearest(IndexSearcher searcher, String field, double latitude, double longitude, int n) throws IOException {\n    GeoUtils.checkLatitude(latitude);\n    GeoUtils.checkLongitude(longitude);\n    if (n < 1) {\n      throw new IllegalArgumentException(\"n must be at least 1; got \" + n);\n    }\n    if (field == null) {\n      throw new IllegalArgumentException(\"field must not be null\");\n    }\n    if (searcher == null) {\n      throw new IllegalArgumentException(\"searcher must not be null\");\n    }\n    List<BKDReader> readers = new ArrayList<>();\n    List<Integer> docBases = new ArrayList<>();\n    List<Bits> liveDocs = new ArrayList<>();\n    int totalHits = 0;\n    for(LeafReaderContext leaf : searcher.getIndexReader().leaves()) {\n      PointValues points = leaf.reader().getPointValues();\n      if (points != null) {\n        if (points instanceof Lucene60PointsReader == false) {\n          throw new IllegalArgumentException(\"can only run on Lucene60PointsReader points implementation, but got \" + points);\n        }\n        totalHits += points.getDocCount(field);\n        BKDReader reader = ((Lucene60PointsReader) points).getBKDReader(field);\n        if (reader != null) {\n          readers.add(reader);\n          docBases.add(leaf.docBase);\n          liveDocs.add(leaf.reader().getLiveDocs());\n        }\n      }\n    }\n\n    NearestNeighbor.NearestHit[] hits = NearestNeighbor.nearest(latitude, longitude, readers, liveDocs, docBases, n);\n\n    // Convert to TopFieldDocs:\n    ScoreDoc[] scoreDocs = new ScoreDoc[hits.length];\n    for(int i=0;i<hits.length;i++) {\n      NearestNeighbor.NearestHit hit = hits[i];\n      scoreDocs[i] = new FieldDoc(hit.docID, 0.0f, new Object[] {Double.valueOf(hit.distanceMeters)});\n    }\n    return new TopFieldDocs(totalHits, scoreDocs, null, 0.0f);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f7f901826e47f75f810d7aae24b0455d21ea1fe2","date":1461678892,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint#nearest(IndexSearcher,String,double,double,int).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint#nearest(IndexSearcher,String,double,double,int).mjava","sourceNew":"  /**\n   * Finds the {@code n} nearest indexed points to the provided point, according to Haversine distance.\n   * <p>\n   * This is functionally equivalent to running {@link MatchAllDocsQuery} with a {@link LatLonDocValuesField#newDistanceSort},\n   * but is far more efficient since it takes advantage of properties the indexed BKD tree.  Currently this\n   * only works with {@link Lucene60PointsFormat} (used by the default codec).  Multi-valued fields are\n   * currently not de-duplicated, so if a document had multiple instances of the specified field that\n   * make it into the top n, that document will appear more than once.\n   * <p>\n   * Documents are ordered by ascending distance from the location. The value returned in {@link FieldDoc} for\n   * the hits contains a Double instance with the distance in meters.\n   * \n   * @param searcher IndexSearcher to find nearest points from.\n   * @param field field name. must not be null.\n   * @param latitude latitude at the center: must be within standard +/-90 coordinate bounds.\n   * @param longitude longitude at the center: must be within standard +/-180 coordinate bounds.\n   * @param n the number of nearest neighbors to retrieve.\n   * @return TopFieldDocs containing documents ordered by distance, where the field value for each {@link FieldDoc} is the distance in meters\n   * @throws IllegalArgumentException if the underlying PointValues is not a {@code Lucene60PointsReader} (this is a current limitation), or\n   *         if {@code field} or {@code searcher} is null, or if {@code latitude}, {@code longitude} or {@code n} are out-of-bounds\n   * @throws IOException if an IOException occurs while finding the points.\n   */\n  // TODO: what about multi-valued documents? what happens?\n  public static TopFieldDocs nearest(IndexSearcher searcher, String field, double latitude, double longitude, int n) throws IOException {\n    GeoUtils.checkLatitude(latitude);\n    GeoUtils.checkLongitude(longitude);\n    if (n < 1) {\n      throw new IllegalArgumentException(\"n must be at least 1; got \" + n);\n    }\n    if (field == null) {\n      throw new IllegalArgumentException(\"field must not be null\");\n    }\n    if (searcher == null) {\n      throw new IllegalArgumentException(\"searcher must not be null\");\n    }\n    List<BKDReader> readers = new ArrayList<>();\n    List<Integer> docBases = new ArrayList<>();\n    List<Bits> liveDocs = new ArrayList<>();\n    int totalHits = 0;\n    for(LeafReaderContext leaf : searcher.getIndexReader().leaves()) {\n      PointValues points = leaf.reader().getPointValues();\n      if (points != null) {\n        if (points instanceof Lucene60PointsReader == false) {\n          throw new IllegalArgumentException(\"can only run on Lucene60PointsReader points implementation, but got \" + points);\n        }\n        totalHits += points.getDocCount(field);\n        BKDReader reader = ((Lucene60PointsReader) points).getBKDReader(field);\n        if (reader != null) {\n          readers.add(reader);\n          docBases.add(leaf.docBase);\n          liveDocs.add(leaf.reader().getLiveDocs());\n        }\n      }\n    }\n\n    NearestNeighbor.NearestHit[] hits = NearestNeighbor.nearest(latitude, longitude, readers, liveDocs, docBases, n);\n\n    // Convert to TopFieldDocs:\n    ScoreDoc[] scoreDocs = new ScoreDoc[hits.length];\n    for(int i=0;i<hits.length;i++) {\n      NearestNeighbor.NearestHit hit = hits[i];\n      scoreDocs[i] = new FieldDoc(hit.docID, 0.0f, new Object[] {Double.valueOf(hit.distanceMeters)});\n    }\n    return new TopFieldDocs(totalHits, scoreDocs, null, 0.0f);\n  }\n\n","sourceOld":"  /**\n   * Finds the {@code n} nearest indexed points to the provided point, according to Haversine distance.\n   * <p>\n   * This is functionally equivalent to running {@link MatchAllDocsQuery} with a {@link #newDistanceSort},\n   * but is far more efficient since it takes advantage of properties the indexed BKD tree.  Currently this\n   * only works with {@link Lucene60PointsFormat} (used by the default codec).  Multi-valued fields are\n   * currently not de-duplicated, so if a document had multiple instances of the specified field that\n   * make it into the top n, that document will appear more than once.\n   * <p>\n   * Documents are ordered by ascending distance from the location. The value returned in {@link FieldDoc} for\n   * the hits contains a Double instance with the distance in meters.\n   * \n   * @param searcher IndexSearcher to find nearest points from.\n   * @param field field name. must not be null.\n   * @param latitude latitude at the center: must be within standard +/-90 coordinate bounds.\n   * @param longitude longitude at the center: must be within standard +/-180 coordinate bounds.\n   * @param n the number of nearest neighbors to retrieve.\n   * @return TopFieldDocs containing documents ordered by distance, where the field value for each {@link FieldDoc} is the distance in meters\n   * @throws IllegalArgumentException if the underlying PointValues is not a {@code Lucene60PointsReader} (this is a current limitation), or\n   *         if {@code field} or {@code searcher} is null, or if {@code latitude}, {@code longitude} or {@code n} are out-of-bounds\n   * @throws IOException if an IOException occurs while finding the points.\n   */\n  // TODO: what about multi-valued documents? what happens?\n  public static TopFieldDocs nearest(IndexSearcher searcher, String field, double latitude, double longitude, int n) throws IOException {\n    GeoUtils.checkLatitude(latitude);\n    GeoUtils.checkLongitude(longitude);\n    if (n < 1) {\n      throw new IllegalArgumentException(\"n must be at least 1; got \" + n);\n    }\n    if (field == null) {\n      throw new IllegalArgumentException(\"field must not be null\");\n    }\n    if (searcher == null) {\n      throw new IllegalArgumentException(\"searcher must not be null\");\n    }\n    List<BKDReader> readers = new ArrayList<>();\n    List<Integer> docBases = new ArrayList<>();\n    List<Bits> liveDocs = new ArrayList<>();\n    int totalHits = 0;\n    for(LeafReaderContext leaf : searcher.getIndexReader().leaves()) {\n      PointValues points = leaf.reader().getPointValues();\n      if (points != null) {\n        if (points instanceof Lucene60PointsReader == false) {\n          throw new IllegalArgumentException(\"can only run on Lucene60PointsReader points implementation, but got \" + points);\n        }\n        totalHits += points.getDocCount(field);\n        BKDReader reader = ((Lucene60PointsReader) points).getBKDReader(field);\n        if (reader != null) {\n          readers.add(reader);\n          docBases.add(leaf.docBase);\n          liveDocs.add(leaf.reader().getLiveDocs());\n        }\n      }\n    }\n\n    NearestNeighbor.NearestHit[] hits = NearestNeighbor.nearest(latitude, longitude, readers, liveDocs, docBases, n);\n\n    // Convert to TopFieldDocs:\n    ScoreDoc[] scoreDocs = new ScoreDoc[hits.length];\n    for(int i=0;i<hits.length;i++) {\n      NearestNeighbor.NearestHit hit = hits[i];\n      scoreDocs[i] = new FieldDoc(hit.docID, 0.0f, new Object[] {Double.valueOf(hit.distanceMeters)});\n    }\n    return new TopFieldDocs(totalHits, scoreDocs, null, 0.0f);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"367f57e2ee85b7f7e28cfe73370a22cf67624f65","date":1476778467,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint#nearest(IndexSearcher,String,double,double,int).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint#nearest(IndexSearcher,String,double,double,int).mjava","sourceNew":"  /**\n   * Finds the {@code n} nearest indexed points to the provided point, according to Haversine distance.\n   * <p>\n   * This is functionally equivalent to running {@link MatchAllDocsQuery} with a {@link LatLonDocValuesField#newDistanceSort},\n   * but is far more efficient since it takes advantage of properties the indexed BKD tree.  Currently this\n   * only works with {@link Lucene60PointsFormat} (used by the default codec).  Multi-valued fields are\n   * currently not de-duplicated, so if a document had multiple instances of the specified field that\n   * make it into the top n, that document will appear more than once.\n   * <p>\n   * Documents are ordered by ascending distance from the location. The value returned in {@link FieldDoc} for\n   * the hits contains a Double instance with the distance in meters.\n   * \n   * @param searcher IndexSearcher to find nearest points from.\n   * @param field field name. must not be null.\n   * @param latitude latitude at the center: must be within standard +/-90 coordinate bounds.\n   * @param longitude longitude at the center: must be within standard +/-180 coordinate bounds.\n   * @param n the number of nearest neighbors to retrieve.\n   * @return TopFieldDocs containing documents ordered by distance, where the field value for each {@link FieldDoc} is the distance in meters\n   * @throws IllegalArgumentException if the underlying PointValues is not a {@code Lucene60PointsReader} (this is a current limitation), or\n   *         if {@code field} or {@code searcher} is null, or if {@code latitude}, {@code longitude} or {@code n} are out-of-bounds\n   * @throws IOException if an IOException occurs while finding the points.\n   */\n  // TODO: what about multi-valued documents? what happens?\n  public static TopFieldDocs nearest(IndexSearcher searcher, String field, double latitude, double longitude, int n) throws IOException {\n    GeoUtils.checkLatitude(latitude);\n    GeoUtils.checkLongitude(longitude);\n    if (n < 1) {\n      throw new IllegalArgumentException(\"n must be at least 1; got \" + n);\n    }\n    if (field == null) {\n      throw new IllegalArgumentException(\"field must not be null\");\n    }\n    if (searcher == null) {\n      throw new IllegalArgumentException(\"searcher must not be null\");\n    }\n    List<BKDReader> readers = new ArrayList<>();\n    List<Integer> docBases = new ArrayList<>();\n    List<Bits> liveDocs = new ArrayList<>();\n    int totalHits = 0;\n    for(LeafReaderContext leaf : searcher.getIndexReader().leaves()) {\n      PointValues points = leaf.reader().getPointValues(field);\n      if (points != null) {\n        if (points instanceof BKDReader == false) {\n          throw new IllegalArgumentException(\"can only run on Lucene60PointsReader points implementation, but got \" + points);\n        }\n        totalHits += points.getDocCount();\n        BKDReader reader = (BKDReader) points;\n        if (reader != null) {\n          readers.add(reader);\n          docBases.add(leaf.docBase);\n          liveDocs.add(leaf.reader().getLiveDocs());\n        }\n      }\n    }\n\n    NearestNeighbor.NearestHit[] hits = NearestNeighbor.nearest(latitude, longitude, readers, liveDocs, docBases, n);\n\n    // Convert to TopFieldDocs:\n    ScoreDoc[] scoreDocs = new ScoreDoc[hits.length];\n    for(int i=0;i<hits.length;i++) {\n      NearestNeighbor.NearestHit hit = hits[i];\n      scoreDocs[i] = new FieldDoc(hit.docID, 0.0f, new Object[] {Double.valueOf(hit.distanceMeters)});\n    }\n    return new TopFieldDocs(totalHits, scoreDocs, null, 0.0f);\n  }\n\n","sourceOld":"  /**\n   * Finds the {@code n} nearest indexed points to the provided point, according to Haversine distance.\n   * <p>\n   * This is functionally equivalent to running {@link MatchAllDocsQuery} with a {@link LatLonDocValuesField#newDistanceSort},\n   * but is far more efficient since it takes advantage of properties the indexed BKD tree.  Currently this\n   * only works with {@link Lucene60PointsFormat} (used by the default codec).  Multi-valued fields are\n   * currently not de-duplicated, so if a document had multiple instances of the specified field that\n   * make it into the top n, that document will appear more than once.\n   * <p>\n   * Documents are ordered by ascending distance from the location. The value returned in {@link FieldDoc} for\n   * the hits contains a Double instance with the distance in meters.\n   * \n   * @param searcher IndexSearcher to find nearest points from.\n   * @param field field name. must not be null.\n   * @param latitude latitude at the center: must be within standard +/-90 coordinate bounds.\n   * @param longitude longitude at the center: must be within standard +/-180 coordinate bounds.\n   * @param n the number of nearest neighbors to retrieve.\n   * @return TopFieldDocs containing documents ordered by distance, where the field value for each {@link FieldDoc} is the distance in meters\n   * @throws IllegalArgumentException if the underlying PointValues is not a {@code Lucene60PointsReader} (this is a current limitation), or\n   *         if {@code field} or {@code searcher} is null, or if {@code latitude}, {@code longitude} or {@code n} are out-of-bounds\n   * @throws IOException if an IOException occurs while finding the points.\n   */\n  // TODO: what about multi-valued documents? what happens?\n  public static TopFieldDocs nearest(IndexSearcher searcher, String field, double latitude, double longitude, int n) throws IOException {\n    GeoUtils.checkLatitude(latitude);\n    GeoUtils.checkLongitude(longitude);\n    if (n < 1) {\n      throw new IllegalArgumentException(\"n must be at least 1; got \" + n);\n    }\n    if (field == null) {\n      throw new IllegalArgumentException(\"field must not be null\");\n    }\n    if (searcher == null) {\n      throw new IllegalArgumentException(\"searcher must not be null\");\n    }\n    List<BKDReader> readers = new ArrayList<>();\n    List<Integer> docBases = new ArrayList<>();\n    List<Bits> liveDocs = new ArrayList<>();\n    int totalHits = 0;\n    for(LeafReaderContext leaf : searcher.getIndexReader().leaves()) {\n      PointValues points = leaf.reader().getPointValues();\n      if (points != null) {\n        if (points instanceof Lucene60PointsReader == false) {\n          throw new IllegalArgumentException(\"can only run on Lucene60PointsReader points implementation, but got \" + points);\n        }\n        totalHits += points.getDocCount(field);\n        BKDReader reader = ((Lucene60PointsReader) points).getBKDReader(field);\n        if (reader != null) {\n          readers.add(reader);\n          docBases.add(leaf.docBase);\n          liveDocs.add(leaf.reader().getLiveDocs());\n        }\n      }\n    }\n\n    NearestNeighbor.NearestHit[] hits = NearestNeighbor.nearest(latitude, longitude, readers, liveDocs, docBases, n);\n\n    // Convert to TopFieldDocs:\n    ScoreDoc[] scoreDocs = new ScoreDoc[hits.length];\n    for(int i=0;i<hits.length;i++) {\n      NearestNeighbor.NearestHit hit = hits[i];\n      scoreDocs[i] = new FieldDoc(hit.docID, 0.0f, new Object[] {Double.valueOf(hit.distanceMeters)});\n    }\n    return new TopFieldDocs(totalHits, scoreDocs, null, 0.0f);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint#nearest(IndexSearcher,String,double,double,int).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint#nearest(IndexSearcher,String,double,double,int).mjava","sourceNew":"  /**\n   * Finds the {@code n} nearest indexed points to the provided point, according to Haversine distance.\n   * <p>\n   * This is functionally equivalent to running {@link MatchAllDocsQuery} with a {@link LatLonDocValuesField#newDistanceSort},\n   * but is far more efficient since it takes advantage of properties the indexed BKD tree.  Currently this\n   * only works with {@link Lucene60PointsFormat} (used by the default codec).  Multi-valued fields are\n   * currently not de-duplicated, so if a document had multiple instances of the specified field that\n   * make it into the top n, that document will appear more than once.\n   * <p>\n   * Documents are ordered by ascending distance from the location. The value returned in {@link FieldDoc} for\n   * the hits contains a Double instance with the distance in meters.\n   * \n   * @param searcher IndexSearcher to find nearest points from.\n   * @param field field name. must not be null.\n   * @param latitude latitude at the center: must be within standard +/-90 coordinate bounds.\n   * @param longitude longitude at the center: must be within standard +/-180 coordinate bounds.\n   * @param n the number of nearest neighbors to retrieve.\n   * @return TopFieldDocs containing documents ordered by distance, where the field value for each {@link FieldDoc} is the distance in meters\n   * @throws IllegalArgumentException if the underlying PointValues is not a {@code Lucene60PointsReader} (this is a current limitation), or\n   *         if {@code field} or {@code searcher} is null, or if {@code latitude}, {@code longitude} or {@code n} are out-of-bounds\n   * @throws IOException if an IOException occurs while finding the points.\n   */\n  // TODO: what about multi-valued documents? what happens?\n  public static TopFieldDocs nearest(IndexSearcher searcher, String field, double latitude, double longitude, int n) throws IOException {\n    GeoUtils.checkLatitude(latitude);\n    GeoUtils.checkLongitude(longitude);\n    if (n < 1) {\n      throw new IllegalArgumentException(\"n must be at least 1; got \" + n);\n    }\n    if (field == null) {\n      throw new IllegalArgumentException(\"field must not be null\");\n    }\n    if (searcher == null) {\n      throw new IllegalArgumentException(\"searcher must not be null\");\n    }\n    List<BKDReader> readers = new ArrayList<>();\n    List<Integer> docBases = new ArrayList<>();\n    List<Bits> liveDocs = new ArrayList<>();\n    int totalHits = 0;\n    for(LeafReaderContext leaf : searcher.getIndexReader().leaves()) {\n      PointValues points = leaf.reader().getPointValues(field);\n      if (points != null) {\n        if (points instanceof BKDReader == false) {\n          throw new IllegalArgumentException(\"can only run on Lucene60PointsReader points implementation, but got \" + points);\n        }\n        totalHits += points.getDocCount();\n        BKDReader reader = (BKDReader) points;\n        if (reader != null) {\n          readers.add(reader);\n          docBases.add(leaf.docBase);\n          liveDocs.add(leaf.reader().getLiveDocs());\n        }\n      }\n    }\n\n    NearestNeighbor.NearestHit[] hits = NearestNeighbor.nearest(latitude, longitude, readers, liveDocs, docBases, n);\n\n    // Convert to TopFieldDocs:\n    ScoreDoc[] scoreDocs = new ScoreDoc[hits.length];\n    for(int i=0;i<hits.length;i++) {\n      NearestNeighbor.NearestHit hit = hits[i];\n      scoreDocs[i] = new FieldDoc(hit.docID, 0.0f, new Object[] {Double.valueOf(hit.distanceMeters)});\n    }\n    return new TopFieldDocs(totalHits, scoreDocs, null, 0.0f);\n  }\n\n","sourceOld":"  /**\n   * Finds the {@code n} nearest indexed points to the provided point, according to Haversine distance.\n   * <p>\n   * This is functionally equivalent to running {@link MatchAllDocsQuery} with a {@link LatLonDocValuesField#newDistanceSort},\n   * but is far more efficient since it takes advantage of properties the indexed BKD tree.  Currently this\n   * only works with {@link Lucene60PointsFormat} (used by the default codec).  Multi-valued fields are\n   * currently not de-duplicated, so if a document had multiple instances of the specified field that\n   * make it into the top n, that document will appear more than once.\n   * <p>\n   * Documents are ordered by ascending distance from the location. The value returned in {@link FieldDoc} for\n   * the hits contains a Double instance with the distance in meters.\n   * \n   * @param searcher IndexSearcher to find nearest points from.\n   * @param field field name. must not be null.\n   * @param latitude latitude at the center: must be within standard +/-90 coordinate bounds.\n   * @param longitude longitude at the center: must be within standard +/-180 coordinate bounds.\n   * @param n the number of nearest neighbors to retrieve.\n   * @return TopFieldDocs containing documents ordered by distance, where the field value for each {@link FieldDoc} is the distance in meters\n   * @throws IllegalArgumentException if the underlying PointValues is not a {@code Lucene60PointsReader} (this is a current limitation), or\n   *         if {@code field} or {@code searcher} is null, or if {@code latitude}, {@code longitude} or {@code n} are out-of-bounds\n   * @throws IOException if an IOException occurs while finding the points.\n   */\n  // TODO: what about multi-valued documents? what happens?\n  public static TopFieldDocs nearest(IndexSearcher searcher, String field, double latitude, double longitude, int n) throws IOException {\n    GeoUtils.checkLatitude(latitude);\n    GeoUtils.checkLongitude(longitude);\n    if (n < 1) {\n      throw new IllegalArgumentException(\"n must be at least 1; got \" + n);\n    }\n    if (field == null) {\n      throw new IllegalArgumentException(\"field must not be null\");\n    }\n    if (searcher == null) {\n      throw new IllegalArgumentException(\"searcher must not be null\");\n    }\n    List<BKDReader> readers = new ArrayList<>();\n    List<Integer> docBases = new ArrayList<>();\n    List<Bits> liveDocs = new ArrayList<>();\n    int totalHits = 0;\n    for(LeafReaderContext leaf : searcher.getIndexReader().leaves()) {\n      PointValues points = leaf.reader().getPointValues();\n      if (points != null) {\n        if (points instanceof Lucene60PointsReader == false) {\n          throw new IllegalArgumentException(\"can only run on Lucene60PointsReader points implementation, but got \" + points);\n        }\n        totalHits += points.getDocCount(field);\n        BKDReader reader = ((Lucene60PointsReader) points).getBKDReader(field);\n        if (reader != null) {\n          readers.add(reader);\n          docBases.add(leaf.docBase);\n          liveDocs.add(leaf.reader().getLiveDocs());\n        }\n      }\n    }\n\n    NearestNeighbor.NearestHit[] hits = NearestNeighbor.nearest(latitude, longitude, readers, liveDocs, docBases, n);\n\n    // Convert to TopFieldDocs:\n    ScoreDoc[] scoreDocs = new ScoreDoc[hits.length];\n    for(int i=0;i<hits.length;i++) {\n      NearestNeighbor.NearestHit hit = hits[i];\n      scoreDocs[i] = new FieldDoc(hit.docID, 0.0f, new Object[] {Double.valueOf(hit.distanceMeters)});\n    }\n    return new TopFieldDocs(totalHits, scoreDocs, null, 0.0f);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"81fff83bdb893c1471efd78f6a9a3ce4f98120b9","date":1531895937,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint#nearest(IndexSearcher,String,double,double,int).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint#nearest(IndexSearcher,String,double,double,int).mjava","sourceNew":"  /**\n   * Finds the {@code n} nearest indexed points to the provided point, according to Haversine distance.\n   * <p>\n   * This is functionally equivalent to running {@link MatchAllDocsQuery} with a {@link LatLonDocValuesField#newDistanceSort},\n   * but is far more efficient since it takes advantage of properties the indexed BKD tree.  Currently this\n   * only works with {@link Lucene60PointsFormat} (used by the default codec).  Multi-valued fields are\n   * currently not de-duplicated, so if a document had multiple instances of the specified field that\n   * make it into the top n, that document will appear more than once.\n   * <p>\n   * Documents are ordered by ascending distance from the location. The value returned in {@link FieldDoc} for\n   * the hits contains a Double instance with the distance in meters.\n   * \n   * @param searcher IndexSearcher to find nearest points from.\n   * @param field field name. must not be null.\n   * @param latitude latitude at the center: must be within standard +/-90 coordinate bounds.\n   * @param longitude longitude at the center: must be within standard +/-180 coordinate bounds.\n   * @param n the number of nearest neighbors to retrieve.\n   * @return TopFieldDocs containing documents ordered by distance, where the field value for each {@link FieldDoc} is the distance in meters\n   * @throws IllegalArgumentException if the underlying PointValues is not a {@code Lucene60PointsReader} (this is a current limitation), or\n   *         if {@code field} or {@code searcher} is null, or if {@code latitude}, {@code longitude} or {@code n} are out-of-bounds\n   * @throws IOException if an IOException occurs while finding the points.\n   */\n  // TODO: what about multi-valued documents? what happens?\n  public static TopFieldDocs nearest(IndexSearcher searcher, String field, double latitude, double longitude, int n) throws IOException {\n    GeoUtils.checkLatitude(latitude);\n    GeoUtils.checkLongitude(longitude);\n    if (n < 1) {\n      throw new IllegalArgumentException(\"n must be at least 1; got \" + n);\n    }\n    if (field == null) {\n      throw new IllegalArgumentException(\"field must not be null\");\n    }\n    if (searcher == null) {\n      throw new IllegalArgumentException(\"searcher must not be null\");\n    }\n    List<BKDReader> readers = new ArrayList<>();\n    List<Integer> docBases = new ArrayList<>();\n    List<Bits> liveDocs = new ArrayList<>();\n    int totalHits = 0;\n    for(LeafReaderContext leaf : searcher.getIndexReader().leaves()) {\n      PointValues points = leaf.reader().getPointValues(field);\n      if (points != null) {\n        if (points instanceof BKDReader == false) {\n          throw new IllegalArgumentException(\"can only run on Lucene60PointsReader points implementation, but got \" + points);\n        }\n        totalHits += points.getDocCount();\n        BKDReader reader = (BKDReader) points;\n        if (reader != null) {\n          readers.add(reader);\n          docBases.add(leaf.docBase);\n          liveDocs.add(leaf.reader().getLiveDocs());\n        }\n      }\n    }\n\n    NearestNeighbor.NearestHit[] hits = NearestNeighbor.nearest(latitude, longitude, readers, liveDocs, docBases, n);\n\n    // Convert to TopFieldDocs:\n    ScoreDoc[] scoreDocs = new ScoreDoc[hits.length];\n    for(int i=0;i<hits.length;i++) {\n      NearestNeighbor.NearestHit hit = hits[i];\n      scoreDocs[i] = new FieldDoc(hit.docID, 0.0f, new Object[] {Double.valueOf(hit.distanceMeters)});\n    }\n    return new TopFieldDocs(totalHits, scoreDocs, null);\n  }\n\n","sourceOld":"  /**\n   * Finds the {@code n} nearest indexed points to the provided point, according to Haversine distance.\n   * <p>\n   * This is functionally equivalent to running {@link MatchAllDocsQuery} with a {@link LatLonDocValuesField#newDistanceSort},\n   * but is far more efficient since it takes advantage of properties the indexed BKD tree.  Currently this\n   * only works with {@link Lucene60PointsFormat} (used by the default codec).  Multi-valued fields are\n   * currently not de-duplicated, so if a document had multiple instances of the specified field that\n   * make it into the top n, that document will appear more than once.\n   * <p>\n   * Documents are ordered by ascending distance from the location. The value returned in {@link FieldDoc} for\n   * the hits contains a Double instance with the distance in meters.\n   * \n   * @param searcher IndexSearcher to find nearest points from.\n   * @param field field name. must not be null.\n   * @param latitude latitude at the center: must be within standard +/-90 coordinate bounds.\n   * @param longitude longitude at the center: must be within standard +/-180 coordinate bounds.\n   * @param n the number of nearest neighbors to retrieve.\n   * @return TopFieldDocs containing documents ordered by distance, where the field value for each {@link FieldDoc} is the distance in meters\n   * @throws IllegalArgumentException if the underlying PointValues is not a {@code Lucene60PointsReader} (this is a current limitation), or\n   *         if {@code field} or {@code searcher} is null, or if {@code latitude}, {@code longitude} or {@code n} are out-of-bounds\n   * @throws IOException if an IOException occurs while finding the points.\n   */\n  // TODO: what about multi-valued documents? what happens?\n  public static TopFieldDocs nearest(IndexSearcher searcher, String field, double latitude, double longitude, int n) throws IOException {\n    GeoUtils.checkLatitude(latitude);\n    GeoUtils.checkLongitude(longitude);\n    if (n < 1) {\n      throw new IllegalArgumentException(\"n must be at least 1; got \" + n);\n    }\n    if (field == null) {\n      throw new IllegalArgumentException(\"field must not be null\");\n    }\n    if (searcher == null) {\n      throw new IllegalArgumentException(\"searcher must not be null\");\n    }\n    List<BKDReader> readers = new ArrayList<>();\n    List<Integer> docBases = new ArrayList<>();\n    List<Bits> liveDocs = new ArrayList<>();\n    int totalHits = 0;\n    for(LeafReaderContext leaf : searcher.getIndexReader().leaves()) {\n      PointValues points = leaf.reader().getPointValues(field);\n      if (points != null) {\n        if (points instanceof BKDReader == false) {\n          throw new IllegalArgumentException(\"can only run on Lucene60PointsReader points implementation, but got \" + points);\n        }\n        totalHits += points.getDocCount();\n        BKDReader reader = (BKDReader) points;\n        if (reader != null) {\n          readers.add(reader);\n          docBases.add(leaf.docBase);\n          liveDocs.add(leaf.reader().getLiveDocs());\n        }\n      }\n    }\n\n    NearestNeighbor.NearestHit[] hits = NearestNeighbor.nearest(latitude, longitude, readers, liveDocs, docBases, n);\n\n    // Convert to TopFieldDocs:\n    ScoreDoc[] scoreDocs = new ScoreDoc[hits.length];\n    for(int i=0;i<hits.length;i++) {\n      NearestNeighbor.NearestHit hit = hits[i];\n      scoreDocs[i] = new FieldDoc(hit.docID, 0.0f, new Object[] {Double.valueOf(hit.distanceMeters)});\n    }\n    return new TopFieldDocs(totalHits, scoreDocs, null, 0.0f);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint#nearest(IndexSearcher,String,double,double,int).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint#nearest(IndexSearcher,String,double,double,int).mjava","sourceNew":"  /**\n   * Finds the {@code n} nearest indexed points to the provided point, according to Haversine distance.\n   * <p>\n   * This is functionally equivalent to running {@link MatchAllDocsQuery} with a {@link LatLonDocValuesField#newDistanceSort},\n   * but is far more efficient since it takes advantage of properties the indexed BKD tree.  Currently this\n   * only works with {@link Lucene60PointsFormat} (used by the default codec).  Multi-valued fields are\n   * currently not de-duplicated, so if a document had multiple instances of the specified field that\n   * make it into the top n, that document will appear more than once.\n   * <p>\n   * Documents are ordered by ascending distance from the location. The value returned in {@link FieldDoc} for\n   * the hits contains a Double instance with the distance in meters.\n   * \n   * @param searcher IndexSearcher to find nearest points from.\n   * @param field field name. must not be null.\n   * @param latitude latitude at the center: must be within standard +/-90 coordinate bounds.\n   * @param longitude longitude at the center: must be within standard +/-180 coordinate bounds.\n   * @param n the number of nearest neighbors to retrieve.\n   * @return TopFieldDocs containing documents ordered by distance, where the field value for each {@link FieldDoc} is the distance in meters\n   * @throws IllegalArgumentException if the underlying PointValues is not a {@code Lucene60PointsReader} (this is a current limitation), or\n   *         if {@code field} or {@code searcher} is null, or if {@code latitude}, {@code longitude} or {@code n} are out-of-bounds\n   * @throws IOException if an IOException occurs while finding the points.\n   */\n  // TODO: what about multi-valued documents? what happens?\n  public static TopFieldDocs nearest(IndexSearcher searcher, String field, double latitude, double longitude, int n) throws IOException {\n    GeoUtils.checkLatitude(latitude);\n    GeoUtils.checkLongitude(longitude);\n    if (n < 1) {\n      throw new IllegalArgumentException(\"n must be at least 1; got \" + n);\n    }\n    if (field == null) {\n      throw new IllegalArgumentException(\"field must not be null\");\n    }\n    if (searcher == null) {\n      throw new IllegalArgumentException(\"searcher must not be null\");\n    }\n    List<BKDReader> readers = new ArrayList<>();\n    List<Integer> docBases = new ArrayList<>();\n    List<Bits> liveDocs = new ArrayList<>();\n    int totalHits = 0;\n    for(LeafReaderContext leaf : searcher.getIndexReader().leaves()) {\n      PointValues points = leaf.reader().getPointValues(field);\n      if (points != null) {\n        if (points instanceof BKDReader == false) {\n          throw new IllegalArgumentException(\"can only run on Lucene60PointsReader points implementation, but got \" + points);\n        }\n        totalHits += points.getDocCount();\n        BKDReader reader = (BKDReader) points;\n        if (reader != null) {\n          readers.add(reader);\n          docBases.add(leaf.docBase);\n          liveDocs.add(leaf.reader().getLiveDocs());\n        }\n      }\n    }\n\n    NearestNeighbor.NearestHit[] hits = NearestNeighbor.nearest(latitude, longitude, readers, liveDocs, docBases, n);\n\n    // Convert to TopFieldDocs:\n    ScoreDoc[] scoreDocs = new ScoreDoc[hits.length];\n    for(int i=0;i<hits.length;i++) {\n      NearestNeighbor.NearestHit hit = hits[i];\n      scoreDocs[i] = new FieldDoc(hit.docID, 0.0f, new Object[] {Double.valueOf(hit.distanceMeters)});\n    }\n    return new TopFieldDocs(totalHits, scoreDocs, null);\n  }\n\n","sourceOld":"  /**\n   * Finds the {@code n} nearest indexed points to the provided point, according to Haversine distance.\n   * <p>\n   * This is functionally equivalent to running {@link MatchAllDocsQuery} with a {@link LatLonDocValuesField#newDistanceSort},\n   * but is far more efficient since it takes advantage of properties the indexed BKD tree.  Currently this\n   * only works with {@link Lucene60PointsFormat} (used by the default codec).  Multi-valued fields are\n   * currently not de-duplicated, so if a document had multiple instances of the specified field that\n   * make it into the top n, that document will appear more than once.\n   * <p>\n   * Documents are ordered by ascending distance from the location. The value returned in {@link FieldDoc} for\n   * the hits contains a Double instance with the distance in meters.\n   * \n   * @param searcher IndexSearcher to find nearest points from.\n   * @param field field name. must not be null.\n   * @param latitude latitude at the center: must be within standard +/-90 coordinate bounds.\n   * @param longitude longitude at the center: must be within standard +/-180 coordinate bounds.\n   * @param n the number of nearest neighbors to retrieve.\n   * @return TopFieldDocs containing documents ordered by distance, where the field value for each {@link FieldDoc} is the distance in meters\n   * @throws IllegalArgumentException if the underlying PointValues is not a {@code Lucene60PointsReader} (this is a current limitation), or\n   *         if {@code field} or {@code searcher} is null, or if {@code latitude}, {@code longitude} or {@code n} are out-of-bounds\n   * @throws IOException if an IOException occurs while finding the points.\n   */\n  // TODO: what about multi-valued documents? what happens?\n  public static TopFieldDocs nearest(IndexSearcher searcher, String field, double latitude, double longitude, int n) throws IOException {\n    GeoUtils.checkLatitude(latitude);\n    GeoUtils.checkLongitude(longitude);\n    if (n < 1) {\n      throw new IllegalArgumentException(\"n must be at least 1; got \" + n);\n    }\n    if (field == null) {\n      throw new IllegalArgumentException(\"field must not be null\");\n    }\n    if (searcher == null) {\n      throw new IllegalArgumentException(\"searcher must not be null\");\n    }\n    List<BKDReader> readers = new ArrayList<>();\n    List<Integer> docBases = new ArrayList<>();\n    List<Bits> liveDocs = new ArrayList<>();\n    int totalHits = 0;\n    for(LeafReaderContext leaf : searcher.getIndexReader().leaves()) {\n      PointValues points = leaf.reader().getPointValues(field);\n      if (points != null) {\n        if (points instanceof BKDReader == false) {\n          throw new IllegalArgumentException(\"can only run on Lucene60PointsReader points implementation, but got \" + points);\n        }\n        totalHits += points.getDocCount();\n        BKDReader reader = (BKDReader) points;\n        if (reader != null) {\n          readers.add(reader);\n          docBases.add(leaf.docBase);\n          liveDocs.add(leaf.reader().getLiveDocs());\n        }\n      }\n    }\n\n    NearestNeighbor.NearestHit[] hits = NearestNeighbor.nearest(latitude, longitude, readers, liveDocs, docBases, n);\n\n    // Convert to TopFieldDocs:\n    ScoreDoc[] scoreDocs = new ScoreDoc[hits.length];\n    for(int i=0;i<hits.length;i++) {\n      NearestNeighbor.NearestHit hit = hits[i];\n      scoreDocs[i] = new FieldDoc(hit.docID, 0.0f, new Object[] {Double.valueOf(hit.distanceMeters)});\n    }\n    return new TopFieldDocs(totalHits, scoreDocs, null, 0.0f);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"88b0212386fe531136816706dc37dc49b9dbf7dc","date":1532560226,"type":5,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/search/LatLonPointPrototypeQueries#nearest(IndexSearcher,String,double,double,int).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint#nearest(IndexSearcher,String,double,double,int).mjava","sourceNew":"  /**\n   * Finds the {@code n} nearest indexed points to the provided point, according to Haversine distance.\n   * <p>\n   * This is functionally equivalent to running {@link MatchAllDocsQuery} with a {@link LatLonDocValuesField#newDistanceSort},\n   * but is far more efficient since it takes advantage of properties the indexed BKD tree.  Currently this\n   * only works with {@link Lucene60PointsFormat} (used by the default codec).  Multi-valued fields are\n   * currently not de-duplicated, so if a document had multiple instances of the specified field that\n   * make it into the top n, that document will appear more than once.\n   * <p>\n   * Documents are ordered by ascending distance from the location. The value returned in {@link FieldDoc} for\n   * the hits contains a Double instance with the distance in meters.\n   *\n   * @param searcher IndexSearcher to find nearest points from.\n   * @param field field name. must not be null.\n   * @param latitude latitude at the center: must be within standard +/-90 coordinate bounds.\n   * @param longitude longitude at the center: must be within standard +/-180 coordinate bounds.\n   * @param n the number of nearest neighbors to retrieve.\n   * @return TopFieldDocs containing documents ordered by distance, where the field value for each {@link FieldDoc} is the distance in meters\n   * @throws IllegalArgumentException if the underlying PointValues is not a {@code Lucene60PointsReader} (this is a current limitation), or\n   *         if {@code field} or {@code searcher} is null, or if {@code latitude}, {@code longitude} or {@code n} are out-of-bounds\n   * @throws IOException if an IOException occurs while finding the points.\n   */\n  // TODO: what about multi-valued documents? what happens?\n  public static TopFieldDocs nearest(IndexSearcher searcher, String field, double latitude, double longitude, int n) throws IOException {\n    GeoUtils.checkLatitude(latitude);\n    GeoUtils.checkLongitude(longitude);\n    if (n < 1) {\n      throw new IllegalArgumentException(\"n must be at least 1; got \" + n);\n    }\n    if (field == null) {\n      throw new IllegalArgumentException(\"field must not be null\");\n    }\n    if (searcher == null) {\n      throw new IllegalArgumentException(\"searcher must not be null\");\n    }\n    List<BKDReader> readers = new ArrayList<>();\n    List<Integer> docBases = new ArrayList<>();\n    List<Bits> liveDocs = new ArrayList<>();\n    int totalHits = 0;\n    for(LeafReaderContext leaf : searcher.getIndexReader().leaves()) {\n      PointValues points = leaf.reader().getPointValues(field);\n      if (points != null) {\n        if (points instanceof BKDReader == false) {\n          throw new IllegalArgumentException(\"can only run on Lucene60PointsReader points implementation, but got \" + points);\n        }\n        totalHits += points.getDocCount();\n        BKDReader reader = (BKDReader) points;\n        if (reader != null) {\n          readers.add(reader);\n          docBases.add(leaf.docBase);\n          liveDocs.add(leaf.reader().getLiveDocs());\n        }\n      }\n    }\n\n    NearestNeighbor.NearestHit[] hits = NearestNeighbor.nearest(latitude, longitude, readers, liveDocs, docBases, n);\n\n    // Convert to TopFieldDocs:\n    ScoreDoc[] scoreDocs = new ScoreDoc[hits.length];\n    for(int i=0;i<hits.length;i++) {\n      NearestNeighbor.NearestHit hit = hits[i];\n      scoreDocs[i] = new FieldDoc(hit.docID, 0.0f, new Object[] {Double.valueOf(hit.distanceMeters)});\n    }\n    return new TopFieldDocs(totalHits, scoreDocs, null);\n  }\n\n","sourceOld":"  /**\n   * Finds the {@code n} nearest indexed points to the provided point, according to Haversine distance.\n   * <p>\n   * This is functionally equivalent to running {@link MatchAllDocsQuery} with a {@link LatLonDocValuesField#newDistanceSort},\n   * but is far more efficient since it takes advantage of properties the indexed BKD tree.  Currently this\n   * only works with {@link Lucene60PointsFormat} (used by the default codec).  Multi-valued fields are\n   * currently not de-duplicated, so if a document had multiple instances of the specified field that\n   * make it into the top n, that document will appear more than once.\n   * <p>\n   * Documents are ordered by ascending distance from the location. The value returned in {@link FieldDoc} for\n   * the hits contains a Double instance with the distance in meters.\n   * \n   * @param searcher IndexSearcher to find nearest points from.\n   * @param field field name. must not be null.\n   * @param latitude latitude at the center: must be within standard +/-90 coordinate bounds.\n   * @param longitude longitude at the center: must be within standard +/-180 coordinate bounds.\n   * @param n the number of nearest neighbors to retrieve.\n   * @return TopFieldDocs containing documents ordered by distance, where the field value for each {@link FieldDoc} is the distance in meters\n   * @throws IllegalArgumentException if the underlying PointValues is not a {@code Lucene60PointsReader} (this is a current limitation), or\n   *         if {@code field} or {@code searcher} is null, or if {@code latitude}, {@code longitude} or {@code n} are out-of-bounds\n   * @throws IOException if an IOException occurs while finding the points.\n   */\n  // TODO: what about multi-valued documents? what happens?\n  public static TopFieldDocs nearest(IndexSearcher searcher, String field, double latitude, double longitude, int n) throws IOException {\n    GeoUtils.checkLatitude(latitude);\n    GeoUtils.checkLongitude(longitude);\n    if (n < 1) {\n      throw new IllegalArgumentException(\"n must be at least 1; got \" + n);\n    }\n    if (field == null) {\n      throw new IllegalArgumentException(\"field must not be null\");\n    }\n    if (searcher == null) {\n      throw new IllegalArgumentException(\"searcher must not be null\");\n    }\n    List<BKDReader> readers = new ArrayList<>();\n    List<Integer> docBases = new ArrayList<>();\n    List<Bits> liveDocs = new ArrayList<>();\n    int totalHits = 0;\n    for(LeafReaderContext leaf : searcher.getIndexReader().leaves()) {\n      PointValues points = leaf.reader().getPointValues(field);\n      if (points != null) {\n        if (points instanceof BKDReader == false) {\n          throw new IllegalArgumentException(\"can only run on Lucene60PointsReader points implementation, but got \" + points);\n        }\n        totalHits += points.getDocCount();\n        BKDReader reader = (BKDReader) points;\n        if (reader != null) {\n          readers.add(reader);\n          docBases.add(leaf.docBase);\n          liveDocs.add(leaf.reader().getLiveDocs());\n        }\n      }\n    }\n\n    NearestNeighbor.NearestHit[] hits = NearestNeighbor.nearest(latitude, longitude, readers, liveDocs, docBases, n);\n\n    // Convert to TopFieldDocs:\n    ScoreDoc[] scoreDocs = new ScoreDoc[hits.length];\n    for(int i=0;i<hits.length;i++) {\n      NearestNeighbor.NearestHit hit = hits[i];\n      scoreDocs[i] = new FieldDoc(hit.docID, 0.0f, new Object[] {Double.valueOf(hit.distanceMeters)});\n    }\n    return new TopFieldDocs(totalHits, scoreDocs, null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b01431682e11036a1a7d757a3fa7c1f903fb2c45":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d925740d44a439905255b03982e9c8cf281c01a4":["20525bc1c12e6c61555b30ae60d9c1d2d005024f"],"f7f901826e47f75f810d7aae24b0455d21ea1fe2":["73457c9372b4f2f962ca916788a5fe9e1f644a9f","cc75470f235495b4ac71f43bba9b503023f7f2d0"],"367f57e2ee85b7f7e28cfe73370a22cf67624f65":["f7f901826e47f75f810d7aae24b0455d21ea1fe2"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["f7f901826e47f75f810d7aae24b0455d21ea1fe2","367f57e2ee85b7f7e28cfe73370a22cf67624f65"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["367f57e2ee85b7f7e28cfe73370a22cf67624f65","81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"88b0212386fe531136816706dc37dc49b9dbf7dc":["81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"81fff83bdb893c1471efd78f6a9a3ce4f98120b9":["367f57e2ee85b7f7e28cfe73370a22cf67624f65"],"73457c9372b4f2f962ca916788a5fe9e1f644a9f":["b01431682e11036a1a7d757a3fa7c1f903fb2c45","d925740d44a439905255b03982e9c8cf281c01a4"],"cc75470f235495b4ac71f43bba9b503023f7f2d0":["73457c9372b4f2f962ca916788a5fe9e1f644a9f"],"20525bc1c12e6c61555b30ae60d9c1d2d005024f":["b01431682e11036a1a7d757a3fa7c1f903fb2c45"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["88b0212386fe531136816706dc37dc49b9dbf7dc"]},"commit2Childs":{"b01431682e11036a1a7d757a3fa7c1f903fb2c45":["73457c9372b4f2f962ca916788a5fe9e1f644a9f","20525bc1c12e6c61555b30ae60d9c1d2d005024f"],"d925740d44a439905255b03982e9c8cf281c01a4":["73457c9372b4f2f962ca916788a5fe9e1f644a9f"],"f7f901826e47f75f810d7aae24b0455d21ea1fe2":["367f57e2ee85b7f7e28cfe73370a22cf67624f65","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"367f57e2ee85b7f7e28cfe73370a22cf67624f65":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b01431682e11036a1a7d757a3fa7c1f903fb2c45"],"88b0212386fe531136816706dc37dc49b9dbf7dc":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"81fff83bdb893c1471efd78f6a9a3ce4f98120b9":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","88b0212386fe531136816706dc37dc49b9dbf7dc"],"73457c9372b4f2f962ca916788a5fe9e1f644a9f":["f7f901826e47f75f810d7aae24b0455d21ea1fe2","cc75470f235495b4ac71f43bba9b503023f7f2d0"],"cc75470f235495b4ac71f43bba9b503023f7f2d0":["f7f901826e47f75f810d7aae24b0455d21ea1fe2"],"20525bc1c12e6c61555b30ae60d9c1d2d005024f":["d925740d44a439905255b03982e9c8cf281c01a4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}