{"path":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCustomCollectionsAPI().mjava","commits":[{"id":"1eeda7e62e149f90eee8895af874c74efa7d4852","date":1375293182,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCustomCollectionsAPI().mjava","pathOld":"/dev/null","sourceNew":"  private void testCustomCollectionsAPI() throws Exception {\n    String COLL_PREFIX = \"new_implicit_coll_\";\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or\n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n\n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = random().nextInt(6) + 1;\n\n    for (int i = 0; i < cnt; i++) {\n      int numShards = 4;\n      int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = ((((numShards+1) * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(COLL_PREFIX + i);\n        }\n\n        Map<String, Object> props = OverseerCollectionProcessor.asMap(\n            ROUTER, ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c,d\");\n\n        createCollection(collectionInfos, COLL_PREFIX + i,props,client);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n\n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n\n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(COLL_PREFIX + j, zkStateReader, false);\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    DocCollection coll = clusterState.getCollection(COLL_PREFIX + 0);\n    assertEquals(\"implicit\", coll.getStr(ROUTER));\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n\n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    log.info(\"Collections created : \"+collectionNameList );\n\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n\n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", _ROUTE_,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(\"shard.keys\",\"b\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(\"shard.keys\",\"a\")).getResults().getNumFound());\n\n    collectionClient.deleteByQuery(\"*:*\");\n    collectionClient.commit(true,true);\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(_ROUTE_, \"c\");\n    up.setParam(\"commit\",\"true\");\n\n    up.add(getDoc(id, 9, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\"));\n    up.add(getDoc(id, 10, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\"));\n    up.add(getDoc(id, 11, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\"));\n\n    collectionClient.request(up);\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(\"shard.keys\",\"a\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(\"shard.keys\",\"c\")).getResults().getNumFound());\n\n    //Testing CREATESHARD\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATESHARD.toString());\n    params.set(\"collection\", coll.getName());\n    params.set(\"shard\", \"z\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", getBaseUrl((HttpSolrServer) clients.get(0))).request(request);\n    waitForCollection(zkStateReader,coll.getName(),5);\n    collectionClient.add(getDoc(id, 66, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"x\"));\n    collectionClient.commit();\n    assertEquals(1, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"x\")).getResults().getNumFound());\n\n\n    int numShards = 4;\n    int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n    int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n        .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n    CloudSolrServer client = null;\n    String shard_fld = \"shard_s\";\n    try {\n      client = createCloudClient(null);\n      Map<String, Object> props = OverseerCollectionProcessor.asMap(\n          ROUTER, ImplicitDocRouter.NAME,\n          REPLICATION_FACTOR, replicationFactor,\n          MAX_SHARDS_PER_NODE, maxShardsPerNode,\n          SHARDS_PROP,\"a,b,c,d\",\n          DocRouter.ROUTE_FIELD, shard_fld);\n\n      collectionName = COLL_PREFIX + \"withShardField\";\n      createCollection(collectionInfos, collectionName,props,client);\n    } finally {\n      if (client != null) client.shutdown();\n    }\n\n    List<Integer> list = collectionInfos.get(collectionName);\n    checkForCollection(collectionName, list, null);\n\n\n    url = getUrlFromZk(collectionName);\n\n    collectionClient = new HttpSolrServer(url);\n\n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n\n\n\n\n    collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", shard_fld,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(\"shard.keys\",\"b\")).getResults().getNumFound());\n    //TODO debug the following case\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(\"shard.keys\", \"a\")).getResults().getNumFound());\n\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["4c7856260bc28f285ae7bfefa99b28db4dca6daf","6784d0cc613dc1ee97030eaaa5e0754edc22d164"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"da3894312f2635a8faf0bd4f81e047cb3805e557","date":1375952794,"type":5,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest#testCustomCollectionsAPI().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest#testCustomCollectionsAPI().mjava","sourceNew":"  private void testCustomCollectionsAPI() throws Exception {\n    String COLL_PREFIX = \"implicitcoll\";\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or\n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n\n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n\n    int cnt = random().nextInt(6) + 1;\n\n    for (int i = 0; i < cnt; i++) {\n      int numShards = 3;\n      int maxShardsPerNode = ((((numShards+1) * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(COLL_PREFIX + i);\n        }\n\n        Map<String, Object> props = OverseerCollectionProcessor.asMap(\n            ROUTER, ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c\");\n\n        createCollection(collectionInfos, COLL_PREFIX + i,props,client);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n\n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n\n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(COLL_PREFIX + j, zkStateReader, false);\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    DocCollection coll = clusterState.getCollection(COLL_PREFIX + 0);\n    assertEquals(\"implicit\", coll.getStr(ROUTER));\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n\n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    log.info(\"Collections created : \"+collectionNameList );\n\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n\n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", _ROUTE_,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(\"shard.keys\",\"b\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(\"shard.keys\",\"a\")).getResults().getNumFound());\n\n    collectionClient.deleteByQuery(\"*:*\");\n    collectionClient.commit(true,true);\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(_ROUTE_, \"c\");\n    up.setParam(\"commit\",\"true\");\n\n    up.add(getDoc(id, 9, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\"));\n    up.add(getDoc(id, 10, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\"));\n    up.add(getDoc(id, 11, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\"));\n\n    collectionClient.request(up);\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(\"shard.keys\",\"a\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(\"shard.keys\",\"c\")).getResults().getNumFound());\n\n    //Testing CREATESHARD\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATESHARD.toString());\n    params.set(\"collection\", collectionName);\n    params.set(\"shard\", \"x\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", getBaseUrl((HttpSolrServer) clients.get(0))).request(request);\n    waitForCollection(zkStateReader,collectionName,4);\n    //wait for all the replicas to become active\n    int attempts = 0;\n    while(true){\n      if(attempts>30 ) fail(\"Not enough active replicas in the shard 'x'\");\n      attempts++;\n      int activeReplicaCount = 0;\n      for (Replica x : zkStateReader.getClusterState().getCollection(collectionName).getSlice(\"x\").getReplicas()) {\n        if(\"active\".equals(x.getStr(\"state\"))) activeReplicaCount++;\n      }\n      Thread.sleep(500);\n      if(activeReplicaCount >= replicationFactor) break;\n    }\n    log.info(zkStateReader.getClusterState().toString());\n\n    collectionClient.add(getDoc(id, 66, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"x\"));\n    collectionClient.commit();\n    assertEquals(1, collectionClient.query(new SolrQuery(\"*:*\").setParam(\"shard.keys\",\"x\")).getResults().getNumFound());\n\n\n    int numShards = 4;\n    replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n    int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n        .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n    CloudSolrServer client = null;\n    String shard_fld = \"shard_s\";\n    try {\n      client = createCloudClient(null);\n      Map<String, Object> props = OverseerCollectionProcessor.asMap(\n          ROUTER, ImplicitDocRouter.NAME,\n          REPLICATION_FACTOR, replicationFactor,\n          MAX_SHARDS_PER_NODE, maxShardsPerNode,\n          SHARDS_PROP,\"a,b,c,d\",\n          DocRouter.ROUTE_FIELD, shard_fld);\n\n      collectionName = COLL_PREFIX + \"withShardField\";\n      createCollection(collectionInfos, collectionName,props,client);\n    } finally {\n      if (client != null) client.shutdown();\n    }\n\n    List<Integer> list = collectionInfos.get(collectionName);\n    checkForCollection(collectionName, list, null);\n\n\n    url = getUrlFromZk(collectionName);\n\n    collectionClient = new HttpSolrServer(url);\n\n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n\n\n\n\n    collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", shard_fld,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(\"shard.keys\",\"b\")).getResults().getNumFound());\n    //TODO debug the following case\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(\"shard.keys\", \"a\")).getResults().getNumFound());\n\n\n  }\n\n","sourceOld":"  private void testCustomCollectionsAPI() throws Exception {\n    String COLL_PREFIX = \"new_implicit_coll_\";\n\n    // TODO: fragile - because we dont pass collection.confName, it will only\n    // find a default if a conf set with a name matching the collection name is found, or\n    // if there is only one conf set. That and the fact that other tests run first in this\n    // env make this pretty fragile\n\n    // create new collections rapid fire\n    Map<String,List<Integer>> collectionInfos = new HashMap<String,List<Integer>>();\n    int cnt = random().nextInt(6) + 1;\n\n    for (int i = 0; i < cnt; i++) {\n      int numShards = 4;\n      int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n      int maxShardsPerNode = ((((numShards+1) * replicationFactor) / getCommonCloudSolrServer()\n          .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n      CloudSolrServer client = null;\n      try {\n        if (i == 0) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you havnt set default-collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection\n          client = createCloudClient(null);\n        } else if (i == 1) {\n          // Test if we can create a collection through CloudSolrServer where\n          // you have set default-collection to a non-existing collection\n          // This is nice because you want to be able to create you first\n          // collection using CloudSolrServer, and in such case there is\n          // nothing reasonable to set as default-collection, but you might want\n          // to use the same CloudSolrServer throughout the entire\n          // lifetime of your client-application, so it is nice to be able to\n          // set a default-collection on this CloudSolrServer once and for all\n          // and use this CloudSolrServer to create the collection\n          client = createCloudClient(COLL_PREFIX + i);\n        }\n\n        Map<String, Object> props = OverseerCollectionProcessor.asMap(\n            ROUTER, ImplicitDocRouter.NAME,\n            REPLICATION_FACTOR, replicationFactor,\n            MAX_SHARDS_PER_NODE, maxShardsPerNode,\n            SHARDS_PROP,\"a,b,c,d\");\n\n        createCollection(collectionInfos, COLL_PREFIX + i,props,client);\n      } finally {\n        if (client != null) client.shutdown();\n      }\n    }\n\n    Set<Entry<String,List<Integer>>> collectionInfosEntrySet = collectionInfos.entrySet();\n    for (Entry<String,List<Integer>> entry : collectionInfosEntrySet) {\n      String collection = entry.getKey();\n      List<Integer> list = entry.getValue();\n      checkForCollection(collection, list, null);\n\n      String url = getUrlFromZk(collection);\n\n      HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n      // poll for a second - it can take a moment before we are ready to serve\n      waitForNon403or404or503(collectionClient);\n    }\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    for (int j = 0; j < cnt; j++) {\n      waitForRecoveriesToFinish(COLL_PREFIX + j, zkStateReader, false);\n    }\n\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    DocCollection coll = clusterState.getCollection(COLL_PREFIX + 0);\n    assertEquals(\"implicit\", coll.getStr(ROUTER));\n    assertNotNull(coll.getStr(REPLICATION_FACTOR));\n    assertNotNull(coll.getStr(MAX_SHARDS_PER_NODE));\n\n    List<String> collectionNameList = new ArrayList<String>();\n    collectionNameList.addAll(collectionInfos.keySet());\n    log.info(\"Collections created : \"+collectionNameList );\n\n    String collectionName = collectionNameList.get(random().nextInt(collectionNameList.size()));\n\n    String url = getUrlFromZk(collectionName);\n\n    HttpSolrServer collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", _ROUTE_,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", _ROUTE_,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(\"shard.keys\",\"b\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(\"shard.keys\",\"a\")).getResults().getNumFound());\n\n    collectionClient.deleteByQuery(\"*:*\");\n    collectionClient.commit(true,true);\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(_ROUTE_, \"c\");\n    up.setParam(\"commit\",\"true\");\n\n    up.add(getDoc(id, 9, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\"));\n    up.add(getDoc(id, 10, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\"));\n    up.add(getDoc(id, 11, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\"));\n\n    collectionClient.request(up);\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(\"shard.keys\",\"a\")).getResults().getNumFound());\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(\"shard.keys\",\"c\")).getResults().getNumFound());\n\n    //Testing CREATESHARD\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.CREATESHARD.toString());\n    params.set(\"collection\", coll.getName());\n    params.set(\"shard\", \"z\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    createNewSolrServer(\"\", getBaseUrl((HttpSolrServer) clients.get(0))).request(request);\n    waitForCollection(zkStateReader,coll.getName(),5);\n    collectionClient.add(getDoc(id, 66, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", _ROUTE_,\"x\"));\n    collectionClient.commit();\n    assertEquals(1, collectionClient.query(new SolrQuery(\"*:*\").setParam(_ROUTE_,\"x\")).getResults().getNumFound());\n\n\n    int numShards = 4;\n    int replicationFactor = _TestUtil.nextInt(random(), 0, 3) + 2;\n    int maxShardsPerNode = (((numShards * replicationFactor) / getCommonCloudSolrServer()\n        .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;\n\n\n    CloudSolrServer client = null;\n    String shard_fld = \"shard_s\";\n    try {\n      client = createCloudClient(null);\n      Map<String, Object> props = OverseerCollectionProcessor.asMap(\n          ROUTER, ImplicitDocRouter.NAME,\n          REPLICATION_FACTOR, replicationFactor,\n          MAX_SHARDS_PER_NODE, maxShardsPerNode,\n          SHARDS_PROP,\"a,b,c,d\",\n          DocRouter.ROUTE_FIELD, shard_fld);\n\n      collectionName = COLL_PREFIX + \"withShardField\";\n      createCollection(collectionInfos, collectionName,props,client);\n    } finally {\n      if (client != null) client.shutdown();\n    }\n\n    List<Integer> list = collectionInfos.get(collectionName);\n    checkForCollection(collectionName, list, null);\n\n\n    url = getUrlFromZk(collectionName);\n\n    collectionClient = new HttpSolrServer(url);\n\n    // poll for a second - it can take a moment before we are ready to serve\n    waitForNon403or404or503(collectionClient);\n\n\n\n\n    collectionClient = new HttpSolrServer(url);\n\n\n    // lets try and use the solrj client to index a couple documents\n\n    collectionClient.add(getDoc(id, 6, i1, -600, tlong, 600, t1,\n        \"humpty dumpy sat on a wall\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 7, i1, -600, tlong, 600, t1,\n        \"humpty dumpy3 sat on a walls\", shard_fld,\"a\"));\n\n    collectionClient.add(getDoc(id, 8, i1, -600, tlong, 600, t1,\n        \"humpty dumpy2 sat on a walled\", shard_fld,\"a\"));\n\n    collectionClient.commit();\n\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertEquals(0, collectionClient.query(new SolrQuery(\"*:*\").setParam(\"shard.keys\",\"b\")).getResults().getNumFound());\n    //TODO debug the following case\n    assertEquals(3, collectionClient.query(new SolrQuery(\"*:*\").setParam(\"shard.keys\", \"a\")).getResults().getNumFound());\n\n\n  }\n\n","bugFix":null,"bugIntro":["6784d0cc613dc1ee97030eaaa5e0754edc22d164"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"da3894312f2635a8faf0bd4f81e047cb3805e557":["1eeda7e62e149f90eee8895af874c74efa7d4852"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1eeda7e62e149f90eee8895af874c74efa7d4852":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["da3894312f2635a8faf0bd4f81e047cb3805e557"]},"commit2Childs":{"da3894312f2635a8faf0bd4f81e047cb3805e557":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1eeda7e62e149f90eee8895af874c74efa7d4852"],"1eeda7e62e149f90eee8895af874c74efa7d4852":["da3894312f2635a8faf0bd4f81e047cb3805e557"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}