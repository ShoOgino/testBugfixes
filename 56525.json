{"path":"lucene/src/java/org/apache/lucene/search/payloads/PayloadTermQuery.PayloadTermWeight#explain(AtomicReaderContext,int).mjava","commits":[{"id":"0f3cee3d20b0c786e6fca20539454262e29edcab","date":1310101685,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/payloads/PayloadTermQuery.PayloadTermWeight#explain(AtomicReaderContext,int).mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public Explanation explain(AtomicReaderContext context, int doc) throws IOException {\n      PayloadTermSpanScorer scorer = (PayloadTermSpanScorer) scorer(context, ScorerContext.def());\n      if (scorer != null) {\n        int newDoc = scorer.advance(doc);\n        if (newDoc == doc) {\n          float freq = scorer.freq();\n          SloppyDocScorer docScorer = similarity.sloppyDocScorer(stats, query.getField(), context);\n          Explanation expl = new Explanation();\n          expl.setDescription(\"weight(\"+getQuery()+\" in \"+doc+\") [\" + similarity.getClass().getSimpleName() + \"], result of:\");\n          Explanation scoreExplanation = docScorer.explain(doc, new Explanation(freq, \"phraseFreq=\" + freq));\n          expl.addDetail(scoreExplanation);\n          expl.setValue(scoreExplanation.getValue());\n          // now the payloads part\n          // QUESTION: Is there a way to avoid this skipTo call? We need to know\n          // whether to load the payload or not\n          // GSI: I suppose we could toString the payload, but I don't think that\n          // would be a good idea\n          Explanation payloadExpl = new Explanation(scorer.getPayloadScore(), \"scorePayload(...)\");\n          payloadExpl.setValue(scorer.getPayloadScore());\n          // combined\n          ComplexExplanation result = new ComplexExplanation();\n          result.addDetail(expl);\n          result.addDetail(payloadExpl);\n          result.setValue(expl.getValue() * payloadExpl.getValue());\n          result.setDescription(\"btq, product of:\");\n          result.setMatch(expl.getValue() == 0 ? Boolean.FALSE : Boolean.TRUE); // LUCENE-1303\n          return result;\n        }\n      }\n      \n      return new ComplexExplanation(false, 0.0f, \"no matching term\");\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["c921c1e37d028185ebb98e95b9be889914dd9655"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f0b9507caf22f292ac0e5e59f62db4275adf4511","date":1310107283,"type":0,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/payloads/PayloadTermQuery.PayloadTermWeight#explain(AtomicReaderContext,int).mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public Explanation explain(AtomicReaderContext context, int doc) throws IOException {\n      PayloadTermSpanScorer scorer = (PayloadTermSpanScorer) scorer(context, ScorerContext.def());\n      if (scorer != null) {\n        int newDoc = scorer.advance(doc);\n        if (newDoc == doc) {\n          float freq = scorer.freq();\n          SloppyDocScorer docScorer = similarity.sloppyDocScorer(stats, query.getField(), context);\n          Explanation expl = new Explanation();\n          expl.setDescription(\"weight(\"+getQuery()+\" in \"+doc+\") [\" + similarity.getClass().getSimpleName() + \"], result of:\");\n          Explanation scoreExplanation = docScorer.explain(doc, new Explanation(freq, \"phraseFreq=\" + freq));\n          expl.addDetail(scoreExplanation);\n          expl.setValue(scoreExplanation.getValue());\n          // now the payloads part\n          // QUESTION: Is there a way to avoid this skipTo call? We need to know\n          // whether to load the payload or not\n          // GSI: I suppose we could toString the payload, but I don't think that\n          // would be a good idea\n          Explanation payloadExpl = new Explanation(scorer.getPayloadScore(), \"scorePayload(...)\");\n          payloadExpl.setValue(scorer.getPayloadScore());\n          // combined\n          ComplexExplanation result = new ComplexExplanation();\n          result.addDetail(expl);\n          result.addDetail(payloadExpl);\n          result.setValue(expl.getValue() * payloadExpl.getValue());\n          result.setDescription(\"btq, product of:\");\n          result.setMatch(expl.getValue() == 0 ? Boolean.FALSE : Boolean.TRUE); // LUCENE-1303\n          return result;\n        }\n      }\n      \n      return new ComplexExplanation(false, 0.0f, \"no matching term\");\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1291e4568eb7d9463d751627596ef14baf4c1603","date":1310112572,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/payloads/PayloadTermQuery.PayloadTermWeight#explain(AtomicReaderContext,int).mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public Explanation explain(AtomicReaderContext context, int doc) throws IOException {\n      PayloadTermSpanScorer scorer = (PayloadTermSpanScorer) scorer(context, ScorerContext.def());\n      if (scorer != null) {\n        int newDoc = scorer.advance(doc);\n        if (newDoc == doc) {\n          float freq = scorer.freq();\n          SloppyDocScorer docScorer = similarity.sloppyDocScorer(stats, query.getField(), context);\n          Explanation expl = new Explanation();\n          expl.setDescription(\"weight(\"+getQuery()+\" in \"+doc+\") [\" + similarity.getClass().getSimpleName() + \"], result of:\");\n          Explanation scoreExplanation = docScorer.explain(doc, new Explanation(freq, \"phraseFreq=\" + freq));\n          expl.addDetail(scoreExplanation);\n          expl.setValue(scoreExplanation.getValue());\n          // now the payloads part\n          // QUESTION: Is there a way to avoid this skipTo call? We need to know\n          // whether to load the payload or not\n          // GSI: I suppose we could toString the payload, but I don't think that\n          // would be a good idea\n          Explanation payloadExpl = new Explanation(scorer.getPayloadScore(), \"scorePayload(...)\");\n          payloadExpl.setValue(scorer.getPayloadScore());\n          // combined\n          ComplexExplanation result = new ComplexExplanation();\n          result.addDetail(expl);\n          result.addDetail(payloadExpl);\n          result.setValue(expl.getValue() * payloadExpl.getValue());\n          result.setDescription(\"btq, product of:\");\n          result.setMatch(expl.getValue() == 0 ? Boolean.FALSE : Boolean.TRUE); // LUCENE-1303\n          return result;\n        }\n      }\n      \n      return new ComplexExplanation(false, 0.0f, \"no matching term\");\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c921c1e37d028185ebb98e95b9be889914dd9655","date":1315485231,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/payloads/PayloadTermQuery.PayloadTermWeight#explain(AtomicReaderContext,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/payloads/PayloadTermQuery.PayloadTermWeight#explain(AtomicReaderContext,int).mjava","sourceNew":"    @Override\n    public Explanation explain(AtomicReaderContext context, int doc) throws IOException {\n      PayloadTermSpanScorer scorer = (PayloadTermSpanScorer) scorer(context, ScorerContext.def());\n      if (scorer != null) {\n        int newDoc = scorer.advance(doc);\n        if (newDoc == doc) {\n          float freq = scorer.freq();\n          SloppyDocScorer docScorer = similarity.sloppyDocScorer(stats, query.getField(), context);\n          Explanation expl = new Explanation();\n          expl.setDescription(\"weight(\"+getQuery()+\" in \"+doc+\") [\" + similarity.getClass().getSimpleName() + \"], result of:\");\n          Explanation scoreExplanation = docScorer.explain(doc, new Explanation(freq, \"phraseFreq=\" + freq));\n          expl.addDetail(scoreExplanation);\n          expl.setValue(scoreExplanation.getValue());\n          // now the payloads part\n          // QUESTION: Is there a way to avoid this skipTo call? We need to know\n          // whether to load the payload or not\n          // GSI: I suppose we could toString the payload, but I don't think that\n          // would be a good idea\n          Explanation payloadExpl = new Explanation(scorer.getPayloadScore(), \"scorePayload(...)\");\n          payloadExpl.setValue(scorer.getPayloadScore());\n          // combined\n          ComplexExplanation result = new ComplexExplanation();\n          if (includeSpanScore) {\n            result.addDetail(expl);\n            result.addDetail(payloadExpl);\n            result.setValue(expl.getValue() * payloadExpl.getValue());\n            result.setDescription(\"btq, product of:\");\n          } else {\n            result.addDetail(payloadExpl);\n            result.setValue(payloadExpl.getValue());\n            result.setDescription(\"btq(includeSpanScore=false), result of:\");\n          }\n          result.setMatch(true); // LUCENE-1303\n          return result;\n        }\n      }\n      \n      return new ComplexExplanation(false, 0.0f, \"no matching term\");\n    }\n\n","sourceOld":"    @Override\n    public Explanation explain(AtomicReaderContext context, int doc) throws IOException {\n      PayloadTermSpanScorer scorer = (PayloadTermSpanScorer) scorer(context, ScorerContext.def());\n      if (scorer != null) {\n        int newDoc = scorer.advance(doc);\n        if (newDoc == doc) {\n          float freq = scorer.freq();\n          SloppyDocScorer docScorer = similarity.sloppyDocScorer(stats, query.getField(), context);\n          Explanation expl = new Explanation();\n          expl.setDescription(\"weight(\"+getQuery()+\" in \"+doc+\") [\" + similarity.getClass().getSimpleName() + \"], result of:\");\n          Explanation scoreExplanation = docScorer.explain(doc, new Explanation(freq, \"phraseFreq=\" + freq));\n          expl.addDetail(scoreExplanation);\n          expl.setValue(scoreExplanation.getValue());\n          // now the payloads part\n          // QUESTION: Is there a way to avoid this skipTo call? We need to know\n          // whether to load the payload or not\n          // GSI: I suppose we could toString the payload, but I don't think that\n          // would be a good idea\n          Explanation payloadExpl = new Explanation(scorer.getPayloadScore(), \"scorePayload(...)\");\n          payloadExpl.setValue(scorer.getPayloadScore());\n          // combined\n          ComplexExplanation result = new ComplexExplanation();\n          result.addDetail(expl);\n          result.addDetail(payloadExpl);\n          result.setValue(expl.getValue() * payloadExpl.getValue());\n          result.setDescription(\"btq, product of:\");\n          result.setMatch(expl.getValue() == 0 ? Boolean.FALSE : Boolean.TRUE); // LUCENE-1303\n          return result;\n        }\n      }\n      \n      return new ComplexExplanation(false, 0.0f, \"no matching term\");\n    }\n\n","bugFix":["0f3cee3d20b0c786e6fca20539454262e29edcab"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3fc1f3f78b299e125f7e60f43b5d457392bea23f","date":1317431015,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/payloads/PayloadTermQuery.PayloadTermWeight#explain(AtomicReaderContext,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/payloads/PayloadTermQuery.PayloadTermWeight#explain(AtomicReaderContext,int).mjava","sourceNew":"    @Override\n    public Explanation explain(AtomicReaderContext context, int doc) throws IOException {\n      PayloadTermSpanScorer scorer = (PayloadTermSpanScorer) scorer(context, true, false, context.reader.getLiveDocs());\n      if (scorer != null) {\n        int newDoc = scorer.advance(doc);\n        if (newDoc == doc) {\n          float freq = scorer.freq();\n          SloppyDocScorer docScorer = similarity.sloppyDocScorer(stats, query.getField(), context);\n          Explanation expl = new Explanation();\n          expl.setDescription(\"weight(\"+getQuery()+\" in \"+doc+\") [\" + similarity.getClass().getSimpleName() + \"], result of:\");\n          Explanation scoreExplanation = docScorer.explain(doc, new Explanation(freq, \"phraseFreq=\" + freq));\n          expl.addDetail(scoreExplanation);\n          expl.setValue(scoreExplanation.getValue());\n          // now the payloads part\n          // QUESTION: Is there a way to avoid this skipTo call? We need to know\n          // whether to load the payload or not\n          // GSI: I suppose we could toString the payload, but I don't think that\n          // would be a good idea\n          Explanation payloadExpl = new Explanation(scorer.getPayloadScore(), \"scorePayload(...)\");\n          payloadExpl.setValue(scorer.getPayloadScore());\n          // combined\n          ComplexExplanation result = new ComplexExplanation();\n          if (includeSpanScore) {\n            result.addDetail(expl);\n            result.addDetail(payloadExpl);\n            result.setValue(expl.getValue() * payloadExpl.getValue());\n            result.setDescription(\"btq, product of:\");\n          } else {\n            result.addDetail(payloadExpl);\n            result.setValue(payloadExpl.getValue());\n            result.setDescription(\"btq(includeSpanScore=false), result of:\");\n          }\n          result.setMatch(true); // LUCENE-1303\n          return result;\n        }\n      }\n      \n      return new ComplexExplanation(false, 0.0f, \"no matching term\");\n    }\n\n","sourceOld":"    @Override\n    public Explanation explain(AtomicReaderContext context, int doc) throws IOException {\n      PayloadTermSpanScorer scorer = (PayloadTermSpanScorer) scorer(context, ScorerContext.def());\n      if (scorer != null) {\n        int newDoc = scorer.advance(doc);\n        if (newDoc == doc) {\n          float freq = scorer.freq();\n          SloppyDocScorer docScorer = similarity.sloppyDocScorer(stats, query.getField(), context);\n          Explanation expl = new Explanation();\n          expl.setDescription(\"weight(\"+getQuery()+\" in \"+doc+\") [\" + similarity.getClass().getSimpleName() + \"], result of:\");\n          Explanation scoreExplanation = docScorer.explain(doc, new Explanation(freq, \"phraseFreq=\" + freq));\n          expl.addDetail(scoreExplanation);\n          expl.setValue(scoreExplanation.getValue());\n          // now the payloads part\n          // QUESTION: Is there a way to avoid this skipTo call? We need to know\n          // whether to load the payload or not\n          // GSI: I suppose we could toString the payload, but I don't think that\n          // would be a good idea\n          Explanation payloadExpl = new Explanation(scorer.getPayloadScore(), \"scorePayload(...)\");\n          payloadExpl.setValue(scorer.getPayloadScore());\n          // combined\n          ComplexExplanation result = new ComplexExplanation();\n          if (includeSpanScore) {\n            result.addDetail(expl);\n            result.addDetail(payloadExpl);\n            result.setValue(expl.getValue() * payloadExpl.getValue());\n            result.setDescription(\"btq, product of:\");\n          } else {\n            result.addDetail(payloadExpl);\n            result.setValue(payloadExpl.getValue());\n            result.setDescription(\"btq(includeSpanScore=false), result of:\");\n          }\n          result.setMatch(true); // LUCENE-1303\n          return result;\n        }\n      }\n      \n      return new ComplexExplanation(false, 0.0f, \"no matching term\");\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6fff8f4b218bd0626afcdce82027bafeb84a50a4","date":1327229950,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/payloads/PayloadTermQuery.PayloadTermWeight#explain(AtomicReaderContext,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/payloads/PayloadTermQuery.PayloadTermWeight#explain(AtomicReaderContext,int).mjava","sourceNew":"    @Override\n    public Explanation explain(AtomicReaderContext context, int doc) throws IOException {\n      PayloadTermSpanScorer scorer = (PayloadTermSpanScorer) scorer(context, true, false, context.reader().getLiveDocs());\n      if (scorer != null) {\n        int newDoc = scorer.advance(doc);\n        if (newDoc == doc) {\n          float freq = scorer.freq();\n          SloppyDocScorer docScorer = similarity.sloppyDocScorer(stats, query.getField(), context);\n          Explanation expl = new Explanation();\n          expl.setDescription(\"weight(\"+getQuery()+\" in \"+doc+\") [\" + similarity.getClass().getSimpleName() + \"], result of:\");\n          Explanation scoreExplanation = docScorer.explain(doc, new Explanation(freq, \"phraseFreq=\" + freq));\n          expl.addDetail(scoreExplanation);\n          expl.setValue(scoreExplanation.getValue());\n          // now the payloads part\n          // QUESTION: Is there a way to avoid this skipTo call? We need to know\n          // whether to load the payload or not\n          // GSI: I suppose we could toString the payload, but I don't think that\n          // would be a good idea\n          Explanation payloadExpl = new Explanation(scorer.getPayloadScore(), \"scorePayload(...)\");\n          payloadExpl.setValue(scorer.getPayloadScore());\n          // combined\n          ComplexExplanation result = new ComplexExplanation();\n          if (includeSpanScore) {\n            result.addDetail(expl);\n            result.addDetail(payloadExpl);\n            result.setValue(expl.getValue() * payloadExpl.getValue());\n            result.setDescription(\"btq, product of:\");\n          } else {\n            result.addDetail(payloadExpl);\n            result.setValue(payloadExpl.getValue());\n            result.setDescription(\"btq(includeSpanScore=false), result of:\");\n          }\n          result.setMatch(true); // LUCENE-1303\n          return result;\n        }\n      }\n      \n      return new ComplexExplanation(false, 0.0f, \"no matching term\");\n    }\n\n","sourceOld":"    @Override\n    public Explanation explain(AtomicReaderContext context, int doc) throws IOException {\n      PayloadTermSpanScorer scorer = (PayloadTermSpanScorer) scorer(context, true, false, context.reader.getLiveDocs());\n      if (scorer != null) {\n        int newDoc = scorer.advance(doc);\n        if (newDoc == doc) {\n          float freq = scorer.freq();\n          SloppyDocScorer docScorer = similarity.sloppyDocScorer(stats, query.getField(), context);\n          Explanation expl = new Explanation();\n          expl.setDescription(\"weight(\"+getQuery()+\" in \"+doc+\") [\" + similarity.getClass().getSimpleName() + \"], result of:\");\n          Explanation scoreExplanation = docScorer.explain(doc, new Explanation(freq, \"phraseFreq=\" + freq));\n          expl.addDetail(scoreExplanation);\n          expl.setValue(scoreExplanation.getValue());\n          // now the payloads part\n          // QUESTION: Is there a way to avoid this skipTo call? We need to know\n          // whether to load the payload or not\n          // GSI: I suppose we could toString the payload, but I don't think that\n          // would be a good idea\n          Explanation payloadExpl = new Explanation(scorer.getPayloadScore(), \"scorePayload(...)\");\n          payloadExpl.setValue(scorer.getPayloadScore());\n          // combined\n          ComplexExplanation result = new ComplexExplanation();\n          if (includeSpanScore) {\n            result.addDetail(expl);\n            result.addDetail(payloadExpl);\n            result.setValue(expl.getValue() * payloadExpl.getValue());\n            result.setDescription(\"btq, product of:\");\n          } else {\n            result.addDetail(payloadExpl);\n            result.setValue(payloadExpl.getValue());\n            result.setDescription(\"btq(includeSpanScore=false), result of:\");\n          }\n          result.setMatch(true); // LUCENE-1303\n          return result;\n        }\n      }\n      \n      return new ComplexExplanation(false, 0.0f, \"no matching term\");\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5cab9a86bd67202d20b6adc463008c8e982b070a","date":1327966443,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/payloads/PayloadTermQuery.PayloadTermWeight#explain(AtomicReaderContext,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/payloads/PayloadTermQuery.PayloadTermWeight#explain(AtomicReaderContext,int).mjava","sourceNew":"    @Override\n    public Explanation explain(AtomicReaderContext context, int doc) throws IOException {\n      PayloadTermSpanScorer scorer = (PayloadTermSpanScorer) scorer(context, true, false, context.reader().getLiveDocs());\n      if (scorer != null) {\n        int newDoc = scorer.advance(doc);\n        if (newDoc == doc) {\n          float freq = scorer.freq();\n          SloppyDocScorer docScorer = similarity.sloppyDocScorer(stats, query.getField(), context);\n          Explanation expl = new Explanation();\n          expl.setDescription(\"weight(\"+getQuery()+\" in \"+doc+\") [\" + similarity.getClass().getSimpleName() + \"], result of:\");\n          Explanation scoreExplanation = docScorer.explain(doc, new Explanation(freq, \"phraseFreq=\" + freq));\n          expl.addDetail(scoreExplanation);\n          expl.setValue(scoreExplanation.getValue());\n          // now the payloads part\n          // QUESTION: Is there a way to avoid this skipTo call? We need to know\n          // whether to load the payload or not\n          // GSI: I suppose we could toString the payload, but I don't think that\n          // would be a good idea\n          Explanation payloadExpl = new Explanation(scorer.getPayloadScore(), \"scorePayload(...)\");\n          payloadExpl.setValue(scorer.getPayloadScore());\n          // combined\n          ComplexExplanation result = new ComplexExplanation();\n          if (includeSpanScore) {\n            result.addDetail(expl);\n            result.addDetail(payloadExpl);\n            result.setValue(expl.getValue() * payloadExpl.getValue());\n            result.setDescription(\"btq, product of:\");\n          } else {\n            result.addDetail(payloadExpl);\n            result.setValue(payloadExpl.getValue());\n            result.setDescription(\"btq(includeSpanScore=false), result of:\");\n          }\n          result.setMatch(true); // LUCENE-1303\n          return result;\n        }\n      }\n      \n      return new ComplexExplanation(false, 0.0f, \"no matching term\");\n    }\n\n","sourceOld":"    @Override\n    public Explanation explain(AtomicReaderContext context, int doc) throws IOException {\n      PayloadTermSpanScorer scorer = (PayloadTermSpanScorer) scorer(context, true, false, context.reader.getLiveDocs());\n      if (scorer != null) {\n        int newDoc = scorer.advance(doc);\n        if (newDoc == doc) {\n          float freq = scorer.freq();\n          SloppyDocScorer docScorer = similarity.sloppyDocScorer(stats, query.getField(), context);\n          Explanation expl = new Explanation();\n          expl.setDescription(\"weight(\"+getQuery()+\" in \"+doc+\") [\" + similarity.getClass().getSimpleName() + \"], result of:\");\n          Explanation scoreExplanation = docScorer.explain(doc, new Explanation(freq, \"phraseFreq=\" + freq));\n          expl.addDetail(scoreExplanation);\n          expl.setValue(scoreExplanation.getValue());\n          // now the payloads part\n          // QUESTION: Is there a way to avoid this skipTo call? We need to know\n          // whether to load the payload or not\n          // GSI: I suppose we could toString the payload, but I don't think that\n          // would be a good idea\n          Explanation payloadExpl = new Explanation(scorer.getPayloadScore(), \"scorePayload(...)\");\n          payloadExpl.setValue(scorer.getPayloadScore());\n          // combined\n          ComplexExplanation result = new ComplexExplanation();\n          if (includeSpanScore) {\n            result.addDetail(expl);\n            result.addDetail(payloadExpl);\n            result.setValue(expl.getValue() * payloadExpl.getValue());\n            result.setDescription(\"btq, product of:\");\n          } else {\n            result.addDetail(payloadExpl);\n            result.setValue(payloadExpl.getValue());\n            result.setDescription(\"btq(includeSpanScore=false), result of:\");\n          }\n          result.setMatch(true); // LUCENE-1303\n          return result;\n        }\n      }\n      \n      return new ComplexExplanation(false, 0.0f, \"no matching term\");\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"660345363f16c7d4c38aa11a35bf59aa99466cf1","date":1328227279,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/payloads/PayloadTermQuery.PayloadTermWeight#explain(AtomicReaderContext,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/payloads/PayloadTermQuery.PayloadTermWeight#explain(AtomicReaderContext,int).mjava","sourceNew":"    @Override\n    public Explanation explain(AtomicReaderContext context, int doc) throws IOException {\n      PayloadTermSpanScorer scorer = (PayloadTermSpanScorer) scorer(context, true, false, context.reader().getLiveDocs());\n      if (scorer != null) {\n        int newDoc = scorer.advance(doc);\n        if (newDoc == doc) {\n          float freq = scorer.freq();\n          SloppySimScorer docScorer = similarity.sloppySimScorer(stats, context);\n          Explanation expl = new Explanation();\n          expl.setDescription(\"weight(\"+getQuery()+\" in \"+doc+\") [\" + similarity.getClass().getSimpleName() + \"], result of:\");\n          Explanation scoreExplanation = docScorer.explain(doc, new Explanation(freq, \"phraseFreq=\" + freq));\n          expl.addDetail(scoreExplanation);\n          expl.setValue(scoreExplanation.getValue());\n          // now the payloads part\n          // QUESTION: Is there a way to avoid this skipTo call? We need to know\n          // whether to load the payload or not\n          // GSI: I suppose we could toString the payload, but I don't think that\n          // would be a good idea\n          Explanation payloadExpl = new Explanation(scorer.getPayloadScore(), \"scorePayload(...)\");\n          payloadExpl.setValue(scorer.getPayloadScore());\n          // combined\n          ComplexExplanation result = new ComplexExplanation();\n          if (includeSpanScore) {\n            result.addDetail(expl);\n            result.addDetail(payloadExpl);\n            result.setValue(expl.getValue() * payloadExpl.getValue());\n            result.setDescription(\"btq, product of:\");\n          } else {\n            result.addDetail(payloadExpl);\n            result.setValue(payloadExpl.getValue());\n            result.setDescription(\"btq(includeSpanScore=false), result of:\");\n          }\n          result.setMatch(true); // LUCENE-1303\n          return result;\n        }\n      }\n      \n      return new ComplexExplanation(false, 0.0f, \"no matching term\");\n    }\n\n","sourceOld":"    @Override\n    public Explanation explain(AtomicReaderContext context, int doc) throws IOException {\n      PayloadTermSpanScorer scorer = (PayloadTermSpanScorer) scorer(context, true, false, context.reader().getLiveDocs());\n      if (scorer != null) {\n        int newDoc = scorer.advance(doc);\n        if (newDoc == doc) {\n          float freq = scorer.freq();\n          SloppyDocScorer docScorer = similarity.sloppyDocScorer(stats, query.getField(), context);\n          Explanation expl = new Explanation();\n          expl.setDescription(\"weight(\"+getQuery()+\" in \"+doc+\") [\" + similarity.getClass().getSimpleName() + \"], result of:\");\n          Explanation scoreExplanation = docScorer.explain(doc, new Explanation(freq, \"phraseFreq=\" + freq));\n          expl.addDetail(scoreExplanation);\n          expl.setValue(scoreExplanation.getValue());\n          // now the payloads part\n          // QUESTION: Is there a way to avoid this skipTo call? We need to know\n          // whether to load the payload or not\n          // GSI: I suppose we could toString the payload, but I don't think that\n          // would be a good idea\n          Explanation payloadExpl = new Explanation(scorer.getPayloadScore(), \"scorePayload(...)\");\n          payloadExpl.setValue(scorer.getPayloadScore());\n          // combined\n          ComplexExplanation result = new ComplexExplanation();\n          if (includeSpanScore) {\n            result.addDetail(expl);\n            result.addDetail(payloadExpl);\n            result.setValue(expl.getValue() * payloadExpl.getValue());\n            result.setDescription(\"btq, product of:\");\n          } else {\n            result.addDetail(payloadExpl);\n            result.setValue(payloadExpl.getValue());\n            result.setDescription(\"btq(includeSpanScore=false), result of:\");\n          }\n          result.setMatch(true); // LUCENE-1303\n          return result;\n        }\n      }\n      \n      return new ComplexExplanation(false, 0.0f, \"no matching term\");\n    }\n\n","bugFix":null,"bugIntro":["b799defcfda6d303cbb180917bf1e749089adf42"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/payloads/PayloadTermQuery.PayloadTermWeight#explain(AtomicReaderContext,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/payloads/PayloadTermQuery.PayloadTermWeight#explain(AtomicReaderContext,int).mjava","sourceNew":"    @Override\n    public Explanation explain(AtomicReaderContext context, int doc) throws IOException {\n      PayloadTermSpanScorer scorer = (PayloadTermSpanScorer) scorer(context, true, false, context.reader().getLiveDocs());\n      if (scorer != null) {\n        int newDoc = scorer.advance(doc);\n        if (newDoc == doc) {\n          float freq = scorer.freq();\n          SloppySimScorer docScorer = similarity.sloppySimScorer(stats, context);\n          Explanation expl = new Explanation();\n          expl.setDescription(\"weight(\"+getQuery()+\" in \"+doc+\") [\" + similarity.getClass().getSimpleName() + \"], result of:\");\n          Explanation scoreExplanation = docScorer.explain(doc, new Explanation(freq, \"phraseFreq=\" + freq));\n          expl.addDetail(scoreExplanation);\n          expl.setValue(scoreExplanation.getValue());\n          // now the payloads part\n          // QUESTION: Is there a way to avoid this skipTo call? We need to know\n          // whether to load the payload or not\n          // GSI: I suppose we could toString the payload, but I don't think that\n          // would be a good idea\n          Explanation payloadExpl = new Explanation(scorer.getPayloadScore(), \"scorePayload(...)\");\n          payloadExpl.setValue(scorer.getPayloadScore());\n          // combined\n          ComplexExplanation result = new ComplexExplanation();\n          if (includeSpanScore) {\n            result.addDetail(expl);\n            result.addDetail(payloadExpl);\n            result.setValue(expl.getValue() * payloadExpl.getValue());\n            result.setDescription(\"btq, product of:\");\n          } else {\n            result.addDetail(payloadExpl);\n            result.setValue(payloadExpl.getValue());\n            result.setDescription(\"btq(includeSpanScore=false), result of:\");\n          }\n          result.setMatch(true); // LUCENE-1303\n          return result;\n        }\n      }\n      \n      return new ComplexExplanation(false, 0.0f, \"no matching term\");\n    }\n\n","sourceOld":"    @Override\n    public Explanation explain(AtomicReaderContext context, int doc) throws IOException {\n      PayloadTermSpanScorer scorer = (PayloadTermSpanScorer) scorer(context, true, false, context.reader().getLiveDocs());\n      if (scorer != null) {\n        int newDoc = scorer.advance(doc);\n        if (newDoc == doc) {\n          float freq = scorer.freq();\n          SloppySimScorer docScorer = similarity.sloppySimScorer(stats, context);\n          Explanation expl = new Explanation();\n          expl.setDescription(\"weight(\"+getQuery()+\" in \"+doc+\") [\" + similarity.getClass().getSimpleName() + \"], result of:\");\n          Explanation scoreExplanation = docScorer.explain(doc, new Explanation(freq, \"phraseFreq=\" + freq));\n          expl.addDetail(scoreExplanation);\n          expl.setValue(scoreExplanation.getValue());\n          // now the payloads part\n          // QUESTION: Is there a way to avoid this skipTo call? We need to know\n          // whether to load the payload or not\n          // GSI: I suppose we could toString the payload, but I don't think that\n          // would be a good idea\n          Explanation payloadExpl = new Explanation(scorer.getPayloadScore(), \"scorePayload(...)\");\n          payloadExpl.setValue(scorer.getPayloadScore());\n          // combined\n          ComplexExplanation result = new ComplexExplanation();\n          if (includeSpanScore) {\n            result.addDetail(expl);\n            result.addDetail(payloadExpl);\n            result.setValue(expl.getValue() * payloadExpl.getValue());\n            result.setDescription(\"btq, product of:\");\n          } else {\n            result.addDetail(payloadExpl);\n            result.setValue(payloadExpl.getValue());\n            result.setDescription(\"btq(includeSpanScore=false), result of:\");\n          }\n          result.setMatch(true); // LUCENE-1303\n          return result;\n        }\n      }\n      \n      return new ComplexExplanation(false, 0.0f, \"no matching term\");\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"1291e4568eb7d9463d751627596ef14baf4c1603":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","0f3cee3d20b0c786e6fca20539454262e29edcab"],"660345363f16c7d4c38aa11a35bf59aa99466cf1":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"0f3cee3d20b0c786e6fca20539454262e29edcab":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f0b9507caf22f292ac0e5e59f62db4275adf4511":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","0f3cee3d20b0c786e6fca20539454262e29edcab"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["660345363f16c7d4c38aa11a35bf59aa99466cf1"],"3fc1f3f78b299e125f7e60f43b5d457392bea23f":["c921c1e37d028185ebb98e95b9be889914dd9655"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6fff8f4b218bd0626afcdce82027bafeb84a50a4":["3fc1f3f78b299e125f7e60f43b5d457392bea23f"],"c921c1e37d028185ebb98e95b9be889914dd9655":["0f3cee3d20b0c786e6fca20539454262e29edcab"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["3fc1f3f78b299e125f7e60f43b5d457392bea23f","6fff8f4b218bd0626afcdce82027bafeb84a50a4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"1291e4568eb7d9463d751627596ef14baf4c1603":[],"0f3cee3d20b0c786e6fca20539454262e29edcab":["1291e4568eb7d9463d751627596ef14baf4c1603","f0b9507caf22f292ac0e5e59f62db4275adf4511","c921c1e37d028185ebb98e95b9be889914dd9655"],"660345363f16c7d4c38aa11a35bf59aa99466cf1":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"f0b9507caf22f292ac0e5e59f62db4275adf4511":[],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3fc1f3f78b299e125f7e60f43b5d457392bea23f":["6fff8f4b218bd0626afcdce82027bafeb84a50a4","5cab9a86bd67202d20b6adc463008c8e982b070a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1291e4568eb7d9463d751627596ef14baf4c1603","0f3cee3d20b0c786e6fca20539454262e29edcab","f0b9507caf22f292ac0e5e59f62db4275adf4511"],"6fff8f4b218bd0626afcdce82027bafeb84a50a4":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"c921c1e37d028185ebb98e95b9be889914dd9655":["3fc1f3f78b299e125f7e60f43b5d457392bea23f"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["660345363f16c7d4c38aa11a35bf59aa99466cf1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["1291e4568eb7d9463d751627596ef14baf4c1603","f0b9507caf22f292ac0e5e59f62db4275adf4511","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}