{"path":"solr/core/src/java/org/apache/solr/handler/admin/RebalanceLeaders#insurePreferredIsLeader(NamedList[Object],Slice,Map[String,String]).mjava","commits":[{"id":"9ebd3a557326ef3eab85b73a8cff781f7d801248","date":1431620752,"type":1,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/RebalanceLeaders#insurePreferredIsLeader(NamedList[Object],Slice,Map[String,String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#insurePreferredIsLeader(SolrQueryRequest,NamedList[Object],Slice,Map[String,String]).mjava","sourceNew":"  private void insurePreferredIsLeader(NamedList<Object> results,\n                                       Slice slice, Map<String, String> currentRequests) throws KeeperException, InterruptedException {\n    final String inactivePreferreds = \"inactivePreferreds\";\n    final String alreadyLeaders = \"alreadyLeaders\";\n    String collectionName = req.getParams().get(COLLECTION_PROP);\n\n    for (Replica replica : slice.getReplicas()) {\n      // Tell the replica to become the leader if we're the preferred leader AND active AND not the leader already\n      if (replica.getBool(SliceMutator.PREFERRED_LEADER_PROP, false) == false) {\n        continue;\n      }\n      // OK, we are the preferred leader, are we the actual leader?\n      if (replica.getBool(LEADER_PROP, false)) {\n        //We're a preferred leader, but we're _also_ the leader, don't need to do anything.\n        NamedList<Object> noops = (NamedList<Object>) results.get(alreadyLeaders);\n        if (noops == null) {\n          noops = new NamedList<>();\n          results.add(alreadyLeaders, noops);\n        }\n        NamedList<Object> res = new NamedList<>();\n        res.add(\"status\", \"success\");\n        res.add(\"msg\", \"Already leader\");\n        res.add(\"shard\", slice.getName());\n        res.add(\"nodeName\", replica.getNodeName());\n        noops.add(replica.getName(), res);\n        return; // already the leader, do nothing.\n      }\n\n      // We're the preferred leader, but someone else is leader. Only become leader if we're active.\n      if (replica.getState() != Replica.State.ACTIVE) {\n        NamedList<Object> inactives = (NamedList<Object>) results.get(inactivePreferreds);\n        if (inactives == null) {\n          inactives = new NamedList<>();\n          results.add(inactivePreferreds, inactives);\n        }\n        NamedList<Object> res = new NamedList<>();\n        res.add(\"status\", \"skipped\");\n        res.add(\"msg\", \"Node is a referredLeader, but it's inactive. Skipping\");\n        res.add(\"shard\", slice.getName());\n        res.add(\"nodeName\", replica.getNodeName());\n        inactives.add(replica.getName(), res);\n        return; // Don't try to become the leader if we're not active!\n      }\n\n      // Replica is the preferred leader but not the actual leader, do something about that.\n      // \"Something\" is\n      // 1> if the preferred leader isn't first in line, tell it to re-queue itself.\n      // 2> tell the actual leader to re-queue itself.\n\n      ZkStateReader zkStateReader = coreContainer.getZkController().getZkStateReader();\n\n      List<String> electionNodes = OverseerCollectionProcessor.getSortedElectionNodes(zkStateReader.getZkClient(),\n          ZkStateReader.getShardLeadersElectPath(collectionName, slice.getName()));\n\n      if (electionNodes.size() < 2) { // if there's only one node in the queue, should already be leader and we shouldn't be here anyway.\n        CollectionsHandler.log.warn(\"Rebalancing leaders and slice \" + slice.getName() + \" has less than two elements in the leader \" +\n            \"election queue, but replica \" + replica.getName() + \" doesn't think it's the leader. Do nothing\");\n        return;\n      }\n\n      // Ok, the sorting for election nodes is a bit strange. If the sequence numbers are the same, then the whole\n      // string is used, but that sorts nodes with the same sequence number by their session IDs from ZK.\n      // While this is determinate, it's not quite what we need, so re-queue nodes that aren't us and are\n      // watching the leader node..\n\n      String firstWatcher = electionNodes.get(1);\n\n      if (LeaderElector.getNodeName(firstWatcher).equals(replica.getName()) == false) {\n        makeReplicaFirstWatcher(collectionName, slice, replica);\n      }\n\n      String coreName = slice.getReplica(LeaderElector.getNodeName(electionNodes.get(0))).getStr(CORE_NAME_PROP);\n      rejoinElection(collectionName, slice, electionNodes.get(0), coreName, false);\n      waitForNodeChange(collectionName, slice, electionNodes.get(0));\n\n\n      return; // Done with this slice, skip the rest of the replicas.\n    }\n  }\n\n","sourceOld":"  private void insurePreferredIsLeader(SolrQueryRequest req, NamedList<Object> results,\n                                              Slice slice, Map<String, String> currentRequests) throws KeeperException, InterruptedException {\n    final String inactivePreferreds = \"inactivePreferreds\";\n    final String alreadyLeaders = \"alreadyLeaders\";\n    String collectionName = req.getParams().get(COLLECTION_PROP);\n\n    for (Replica replica : slice.getReplicas()) {\n      // Tell the replica to become the leader if we're the preferred leader AND active AND not the leader already\n      if (replica.getBool(SliceMutator.PREFERRED_LEADER_PROP, false) == false) {\n        continue;\n      }\n      // OK, we are the preferred leader, are we the actual leader?\n      if (replica.getBool(LEADER_PROP, false)) {\n        //We're a preferred leader, but we're _also_ the leader, don't need to do anything.\n        NamedList<Object> noops = (NamedList<Object>) results.get(alreadyLeaders);\n        if (noops == null) {\n          noops = new NamedList<>();\n          results.add(alreadyLeaders, noops);\n        }\n        NamedList<Object> res = new NamedList<>();\n        res.add(\"status\", \"success\");\n        res.add(\"msg\", \"Already leader\");\n        res.add(\"shard\", slice.getName());\n        res.add(\"nodeName\", replica.getNodeName());\n        noops.add(replica.getName(), res);\n        return; // already the leader, do nothing.\n      }\n\n      // We're the preferred leader, but someone else is leader. Only become leader if we're active.\n      if (replica.getState() != Replica.State.ACTIVE) {\n        NamedList<Object> inactives = (NamedList<Object>) results.get(inactivePreferreds);\n        if (inactives == null) {\n          inactives = new NamedList<>();\n          results.add(inactivePreferreds, inactives);\n        }\n        NamedList<Object> res = new NamedList<>();\n        res.add(\"status\", \"skipped\");\n        res.add(\"msg\", \"Node is a referredLeader, but it's inactive. Skipping\");\n        res.add(\"shard\", slice.getName());\n        res.add(\"nodeName\", replica.getNodeName());\n        inactives.add(replica.getName(), res);\n        return; // Don't try to become the leader if we're not active!\n      }\n\n      // Replica is the preferred leader but not the actual leader, do something about that.\n      // \"Something\" is\n      // 1> if the preferred leader isn't first in line, tell it to re-queue itself.\n      // 2> tell the actual leader to re-queue itself.\n\n      ZkStateReader zkStateReader = coreContainer.getZkController().getZkStateReader();\n\n      List<String> electionNodes = OverseerCollectionProcessor.getSortedElectionNodes(zkStateReader.getZkClient(),\n          ZkStateReader.getShardLeadersElectPath(collectionName, slice.getName()));\n\n      if (electionNodes.size() < 2) { // if there's only one node in the queue, should already be leader and we shouldn't be here anyway.\n        log.warn(\"Rebalancing leaders and slice \" + slice.getName() + \" has less than two elements in the leader \" +\n            \"election queue, but replica \" + replica.getName() + \" doesn't think it's the leader. Do nothing\");\n        return;\n      }\n\n      // Ok, the sorting for election nodes is a bit strange. If the sequence numbers are the same, then the whole\n      // string is used, but that sorts nodes with the same sequence number by their session IDs from ZK.\n      // While this is determinate, it's not quite what we need, so re-queue nodes that aren't us and are\n      // watching the leader node..\n\n      String firstWatcher = electionNodes.get(1);\n\n      if (LeaderElector.getNodeName(firstWatcher).equals(replica.getName()) == false) {\n        makeReplicaFirstWatcher(collectionName, slice, replica);\n      }\n\n      String coreName = slice.getReplica(LeaderElector.getNodeName(electionNodes.get(0))).getStr(CORE_NAME_PROP);\n      rejoinElection(collectionName, slice, electionNodes.get(0), coreName, false);\n      waitForNodeChange(collectionName, slice, electionNodes.get(0));\n\n\n      return; // Done with this slice, skip the rest of the replicas.\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac","date":1438841252,"type":3,"author":"Gregory Chanan","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/RebalanceLeaders#insurePreferredIsLeader(NamedList[Object],Slice,Map[String,String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/RebalanceLeaders#insurePreferredIsLeader(NamedList[Object],Slice,Map[String,String]).mjava","sourceNew":"  private void insurePreferredIsLeader(NamedList<Object> results,\n                                       Slice slice, Map<String, String> currentRequests) throws KeeperException, InterruptedException {\n    final String inactivePreferreds = \"inactivePreferreds\";\n    final String alreadyLeaders = \"alreadyLeaders\";\n    String collectionName = req.getParams().get(COLLECTION_PROP);\n\n    for (Replica replica : slice.getReplicas()) {\n      // Tell the replica to become the leader if we're the preferred leader AND active AND not the leader already\n      if (replica.getBool(SliceMutator.PREFERRED_LEADER_PROP, false) == false) {\n        continue;\n      }\n      // OK, we are the preferred leader, are we the actual leader?\n      if (replica.getBool(LEADER_PROP, false)) {\n        //We're a preferred leader, but we're _also_ the leader, don't need to do anything.\n        NamedList<Object> noops = (NamedList<Object>) results.get(alreadyLeaders);\n        if (noops == null) {\n          noops = new NamedList<>();\n          results.add(alreadyLeaders, noops);\n        }\n        NamedList<Object> res = new NamedList<>();\n        res.add(\"status\", \"success\");\n        res.add(\"msg\", \"Already leader\");\n        res.add(\"shard\", slice.getName());\n        res.add(\"nodeName\", replica.getNodeName());\n        noops.add(replica.getName(), res);\n        return; // already the leader, do nothing.\n      }\n\n      // We're the preferred leader, but someone else is leader. Only become leader if we're active.\n      if (replica.getState() != Replica.State.ACTIVE) {\n        NamedList<Object> inactives = (NamedList<Object>) results.get(inactivePreferreds);\n        if (inactives == null) {\n          inactives = new NamedList<>();\n          results.add(inactivePreferreds, inactives);\n        }\n        NamedList<Object> res = new NamedList<>();\n        res.add(\"status\", \"skipped\");\n        res.add(\"msg\", \"Node is a referredLeader, but it's inactive. Skipping\");\n        res.add(\"shard\", slice.getName());\n        res.add(\"nodeName\", replica.getNodeName());\n        inactives.add(replica.getName(), res);\n        return; // Don't try to become the leader if we're not active!\n      }\n\n      // Replica is the preferred leader but not the actual leader, do something about that.\n      // \"Something\" is\n      // 1> if the preferred leader isn't first in line, tell it to re-queue itself.\n      // 2> tell the actual leader to re-queue itself.\n\n      ZkStateReader zkStateReader = coreContainer.getZkController().getZkStateReader();\n\n      List<String> electionNodes = OverseerProcessor.getSortedElectionNodes(zkStateReader.getZkClient(),\n          ZkStateReader.getShardLeadersElectPath(collectionName, slice.getName()));\n\n      if (electionNodes.size() < 2) { // if there's only one node in the queue, should already be leader and we shouldn't be here anyway.\n        CollectionsHandler.log.warn(\"Rebalancing leaders and slice \" + slice.getName() + \" has less than two elements in the leader \" +\n            \"election queue, but replica \" + replica.getName() + \" doesn't think it's the leader. Do nothing\");\n        return;\n      }\n\n      // Ok, the sorting for election nodes is a bit strange. If the sequence numbers are the same, then the whole\n      // string is used, but that sorts nodes with the same sequence number by their session IDs from ZK.\n      // While this is determinate, it's not quite what we need, so re-queue nodes that aren't us and are\n      // watching the leader node..\n\n      String firstWatcher = electionNodes.get(1);\n\n      if (LeaderElector.getNodeName(firstWatcher).equals(replica.getName()) == false) {\n        makeReplicaFirstWatcher(collectionName, slice, replica);\n      }\n\n      String coreName = slice.getReplica(LeaderElector.getNodeName(electionNodes.get(0))).getStr(CORE_NAME_PROP);\n      rejoinElection(collectionName, slice, electionNodes.get(0), coreName, false);\n      waitForNodeChange(collectionName, slice, electionNodes.get(0));\n\n\n      return; // Done with this slice, skip the rest of the replicas.\n    }\n  }\n\n","sourceOld":"  private void insurePreferredIsLeader(NamedList<Object> results,\n                                       Slice slice, Map<String, String> currentRequests) throws KeeperException, InterruptedException {\n    final String inactivePreferreds = \"inactivePreferreds\";\n    final String alreadyLeaders = \"alreadyLeaders\";\n    String collectionName = req.getParams().get(COLLECTION_PROP);\n\n    for (Replica replica : slice.getReplicas()) {\n      // Tell the replica to become the leader if we're the preferred leader AND active AND not the leader already\n      if (replica.getBool(SliceMutator.PREFERRED_LEADER_PROP, false) == false) {\n        continue;\n      }\n      // OK, we are the preferred leader, are we the actual leader?\n      if (replica.getBool(LEADER_PROP, false)) {\n        //We're a preferred leader, but we're _also_ the leader, don't need to do anything.\n        NamedList<Object> noops = (NamedList<Object>) results.get(alreadyLeaders);\n        if (noops == null) {\n          noops = new NamedList<>();\n          results.add(alreadyLeaders, noops);\n        }\n        NamedList<Object> res = new NamedList<>();\n        res.add(\"status\", \"success\");\n        res.add(\"msg\", \"Already leader\");\n        res.add(\"shard\", slice.getName());\n        res.add(\"nodeName\", replica.getNodeName());\n        noops.add(replica.getName(), res);\n        return; // already the leader, do nothing.\n      }\n\n      // We're the preferred leader, but someone else is leader. Only become leader if we're active.\n      if (replica.getState() != Replica.State.ACTIVE) {\n        NamedList<Object> inactives = (NamedList<Object>) results.get(inactivePreferreds);\n        if (inactives == null) {\n          inactives = new NamedList<>();\n          results.add(inactivePreferreds, inactives);\n        }\n        NamedList<Object> res = new NamedList<>();\n        res.add(\"status\", \"skipped\");\n        res.add(\"msg\", \"Node is a referredLeader, but it's inactive. Skipping\");\n        res.add(\"shard\", slice.getName());\n        res.add(\"nodeName\", replica.getNodeName());\n        inactives.add(replica.getName(), res);\n        return; // Don't try to become the leader if we're not active!\n      }\n\n      // Replica is the preferred leader but not the actual leader, do something about that.\n      // \"Something\" is\n      // 1> if the preferred leader isn't first in line, tell it to re-queue itself.\n      // 2> tell the actual leader to re-queue itself.\n\n      ZkStateReader zkStateReader = coreContainer.getZkController().getZkStateReader();\n\n      List<String> electionNodes = OverseerCollectionProcessor.getSortedElectionNodes(zkStateReader.getZkClient(),\n          ZkStateReader.getShardLeadersElectPath(collectionName, slice.getName()));\n\n      if (electionNodes.size() < 2) { // if there's only one node in the queue, should already be leader and we shouldn't be here anyway.\n        CollectionsHandler.log.warn(\"Rebalancing leaders and slice \" + slice.getName() + \" has less than two elements in the leader \" +\n            \"election queue, but replica \" + replica.getName() + \" doesn't think it's the leader. Do nothing\");\n        return;\n      }\n\n      // Ok, the sorting for election nodes is a bit strange. If the sequence numbers are the same, then the whole\n      // string is used, but that sorts nodes with the same sequence number by their session IDs from ZK.\n      // While this is determinate, it's not quite what we need, so re-queue nodes that aren't us and are\n      // watching the leader node..\n\n      String firstWatcher = electionNodes.get(1);\n\n      if (LeaderElector.getNodeName(firstWatcher).equals(replica.getName()) == false) {\n        makeReplicaFirstWatcher(collectionName, slice, replica);\n      }\n\n      String coreName = slice.getReplica(LeaderElector.getNodeName(electionNodes.get(0))).getStr(CORE_NAME_PROP);\n      rejoinElection(collectionName, slice, electionNodes.get(0), coreName, false);\n      waitForNodeChange(collectionName, slice, electionNodes.get(0));\n\n\n      return; // Done with this slice, skip the rest of the replicas.\n    }\n  }\n\n","bugFix":["4e6b620c271c84c0f14919eec7b90083b292ee51"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2209af2c265d2258ec4b29c8cc78622d36994a15","date":1440641916,"type":3,"author":"Gregory Chanan","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/RebalanceLeaders#insurePreferredIsLeader(NamedList[Object],Slice,Map[String,String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/RebalanceLeaders#insurePreferredIsLeader(NamedList[Object],Slice,Map[String,String]).mjava","sourceNew":"  private void insurePreferredIsLeader(NamedList<Object> results,\n                                       Slice slice, Map<String, String> currentRequests) throws KeeperException, InterruptedException {\n    final String inactivePreferreds = \"inactivePreferreds\";\n    final String alreadyLeaders = \"alreadyLeaders\";\n    String collectionName = req.getParams().get(COLLECTION_PROP);\n\n    for (Replica replica : slice.getReplicas()) {\n      // Tell the replica to become the leader if we're the preferred leader AND active AND not the leader already\n      if (replica.getBool(SliceMutator.PREFERRED_LEADER_PROP, false) == false) {\n        continue;\n      }\n      // OK, we are the preferred leader, are we the actual leader?\n      if (replica.getBool(LEADER_PROP, false)) {\n        //We're a preferred leader, but we're _also_ the leader, don't need to do anything.\n        NamedList<Object> noops = (NamedList<Object>) results.get(alreadyLeaders);\n        if (noops == null) {\n          noops = new NamedList<>();\n          results.add(alreadyLeaders, noops);\n        }\n        NamedList<Object> res = new NamedList<>();\n        res.add(\"status\", \"success\");\n        res.add(\"msg\", \"Already leader\");\n        res.add(\"shard\", slice.getName());\n        res.add(\"nodeName\", replica.getNodeName());\n        noops.add(replica.getName(), res);\n        return; // already the leader, do nothing.\n      }\n\n      // We're the preferred leader, but someone else is leader. Only become leader if we're active.\n      if (replica.getState() != Replica.State.ACTIVE) {\n        NamedList<Object> inactives = (NamedList<Object>) results.get(inactivePreferreds);\n        if (inactives == null) {\n          inactives = new NamedList<>();\n          results.add(inactivePreferreds, inactives);\n        }\n        NamedList<Object> res = new NamedList<>();\n        res.add(\"status\", \"skipped\");\n        res.add(\"msg\", \"Node is a referredLeader, but it's inactive. Skipping\");\n        res.add(\"shard\", slice.getName());\n        res.add(\"nodeName\", replica.getNodeName());\n        inactives.add(replica.getName(), res);\n        return; // Don't try to become the leader if we're not active!\n      }\n\n      // Replica is the preferred leader but not the actual leader, do something about that.\n      // \"Something\" is\n      // 1> if the preferred leader isn't first in line, tell it to re-queue itself.\n      // 2> tell the actual leader to re-queue itself.\n\n      ZkStateReader zkStateReader = coreContainer.getZkController().getZkStateReader();\n\n      List<String> electionNodes = OverseerTaskProcessor.getSortedElectionNodes(zkStateReader.getZkClient(),\n          ZkStateReader.getShardLeadersElectPath(collectionName, slice.getName()));\n\n      if (electionNodes.size() < 2) { // if there's only one node in the queue, should already be leader and we shouldn't be here anyway.\n        CollectionsHandler.log.warn(\"Rebalancing leaders and slice \" + slice.getName() + \" has less than two elements in the leader \" +\n            \"election queue, but replica \" + replica.getName() + \" doesn't think it's the leader. Do nothing\");\n        return;\n      }\n\n      // Ok, the sorting for election nodes is a bit strange. If the sequence numbers are the same, then the whole\n      // string is used, but that sorts nodes with the same sequence number by their session IDs from ZK.\n      // While this is determinate, it's not quite what we need, so re-queue nodes that aren't us and are\n      // watching the leader node..\n\n      String firstWatcher = electionNodes.get(1);\n\n      if (LeaderElector.getNodeName(firstWatcher).equals(replica.getName()) == false) {\n        makeReplicaFirstWatcher(collectionName, slice, replica);\n      }\n\n      String coreName = slice.getReplica(LeaderElector.getNodeName(electionNodes.get(0))).getStr(CORE_NAME_PROP);\n      rejoinElection(collectionName, slice, electionNodes.get(0), coreName, false);\n      waitForNodeChange(collectionName, slice, electionNodes.get(0));\n\n\n      return; // Done with this slice, skip the rest of the replicas.\n    }\n  }\n\n","sourceOld":"  private void insurePreferredIsLeader(NamedList<Object> results,\n                                       Slice slice, Map<String, String> currentRequests) throws KeeperException, InterruptedException {\n    final String inactivePreferreds = \"inactivePreferreds\";\n    final String alreadyLeaders = \"alreadyLeaders\";\n    String collectionName = req.getParams().get(COLLECTION_PROP);\n\n    for (Replica replica : slice.getReplicas()) {\n      // Tell the replica to become the leader if we're the preferred leader AND active AND not the leader already\n      if (replica.getBool(SliceMutator.PREFERRED_LEADER_PROP, false) == false) {\n        continue;\n      }\n      // OK, we are the preferred leader, are we the actual leader?\n      if (replica.getBool(LEADER_PROP, false)) {\n        //We're a preferred leader, but we're _also_ the leader, don't need to do anything.\n        NamedList<Object> noops = (NamedList<Object>) results.get(alreadyLeaders);\n        if (noops == null) {\n          noops = new NamedList<>();\n          results.add(alreadyLeaders, noops);\n        }\n        NamedList<Object> res = new NamedList<>();\n        res.add(\"status\", \"success\");\n        res.add(\"msg\", \"Already leader\");\n        res.add(\"shard\", slice.getName());\n        res.add(\"nodeName\", replica.getNodeName());\n        noops.add(replica.getName(), res);\n        return; // already the leader, do nothing.\n      }\n\n      // We're the preferred leader, but someone else is leader. Only become leader if we're active.\n      if (replica.getState() != Replica.State.ACTIVE) {\n        NamedList<Object> inactives = (NamedList<Object>) results.get(inactivePreferreds);\n        if (inactives == null) {\n          inactives = new NamedList<>();\n          results.add(inactivePreferreds, inactives);\n        }\n        NamedList<Object> res = new NamedList<>();\n        res.add(\"status\", \"skipped\");\n        res.add(\"msg\", \"Node is a referredLeader, but it's inactive. Skipping\");\n        res.add(\"shard\", slice.getName());\n        res.add(\"nodeName\", replica.getNodeName());\n        inactives.add(replica.getName(), res);\n        return; // Don't try to become the leader if we're not active!\n      }\n\n      // Replica is the preferred leader but not the actual leader, do something about that.\n      // \"Something\" is\n      // 1> if the preferred leader isn't first in line, tell it to re-queue itself.\n      // 2> tell the actual leader to re-queue itself.\n\n      ZkStateReader zkStateReader = coreContainer.getZkController().getZkStateReader();\n\n      List<String> electionNodes = OverseerProcessor.getSortedElectionNodes(zkStateReader.getZkClient(),\n          ZkStateReader.getShardLeadersElectPath(collectionName, slice.getName()));\n\n      if (electionNodes.size() < 2) { // if there's only one node in the queue, should already be leader and we shouldn't be here anyway.\n        CollectionsHandler.log.warn(\"Rebalancing leaders and slice \" + slice.getName() + \" has less than two elements in the leader \" +\n            \"election queue, but replica \" + replica.getName() + \" doesn't think it's the leader. Do nothing\");\n        return;\n      }\n\n      // Ok, the sorting for election nodes is a bit strange. If the sequence numbers are the same, then the whole\n      // string is used, but that sorts nodes with the same sequence number by their session IDs from ZK.\n      // While this is determinate, it's not quite what we need, so re-queue nodes that aren't us and are\n      // watching the leader node..\n\n      String firstWatcher = electionNodes.get(1);\n\n      if (LeaderElector.getNodeName(firstWatcher).equals(replica.getName()) == false) {\n        makeReplicaFirstWatcher(collectionName, slice, replica);\n      }\n\n      String coreName = slice.getReplica(LeaderElector.getNodeName(electionNodes.get(0))).getStr(CORE_NAME_PROP);\n      rejoinElection(collectionName, slice, electionNodes.get(0), coreName, false);\n      waitForNodeChange(collectionName, slice, electionNodes.get(0));\n\n\n      return; // Done with this slice, skip the rest of the replicas.\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6b18ef9cd3f6ff4f7733e6d43eebec259e0e9064","date":1441124018,"type":5,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/RebalanceLeaders#ensurePreferredIsLeader(NamedList[Object],Slice,Map[String,String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/RebalanceLeaders#insurePreferredIsLeader(NamedList[Object],Slice,Map[String,String]).mjava","sourceNew":"  private void ensurePreferredIsLeader(NamedList<Object> results,\n                                       Slice slice, Map<String, String> currentRequests) throws KeeperException, InterruptedException {\n    final String inactivePreferreds = \"inactivePreferreds\";\n    final String alreadyLeaders = \"alreadyLeaders\";\n    String collectionName = req.getParams().get(COLLECTION_PROP);\n\n    for (Replica replica : slice.getReplicas()) {\n      // Tell the replica to become the leader if we're the preferred leader AND active AND not the leader already\n      if (replica.getBool(SliceMutator.PREFERRED_LEADER_PROP, false) == false) {\n        continue;\n      }\n      // OK, we are the preferred leader, are we the actual leader?\n      if (replica.getBool(LEADER_PROP, false)) {\n        //We're a preferred leader, but we're _also_ the leader, don't need to do anything.\n        NamedList<Object> noops = (NamedList<Object>) results.get(alreadyLeaders);\n        if (noops == null) {\n          noops = new NamedList<>();\n          results.add(alreadyLeaders, noops);\n        }\n        NamedList<Object> res = new NamedList<>();\n        res.add(\"status\", \"success\");\n        res.add(\"msg\", \"Already leader\");\n        res.add(\"shard\", slice.getName());\n        res.add(\"nodeName\", replica.getNodeName());\n        noops.add(replica.getName(), res);\n        return; // already the leader, do nothing.\n      }\n\n      // We're the preferred leader, but someone else is leader. Only become leader if we're active.\n      if (replica.getState() != Replica.State.ACTIVE) {\n        NamedList<Object> inactives = (NamedList<Object>) results.get(inactivePreferreds);\n        if (inactives == null) {\n          inactives = new NamedList<>();\n          results.add(inactivePreferreds, inactives);\n        }\n        NamedList<Object> res = new NamedList<>();\n        res.add(\"status\", \"skipped\");\n        res.add(\"msg\", \"Node is a referredLeader, but it's inactive. Skipping\");\n        res.add(\"shard\", slice.getName());\n        res.add(\"nodeName\", replica.getNodeName());\n        inactives.add(replica.getName(), res);\n        return; // Don't try to become the leader if we're not active!\n      }\n\n      // Replica is the preferred leader but not the actual leader, do something about that.\n      // \"Something\" is\n      // 1> if the preferred leader isn't first in line, tell it to re-queue itself.\n      // 2> tell the actual leader to re-queue itself.\n\n      ZkStateReader zkStateReader = coreContainer.getZkController().getZkStateReader();\n\n      List<String> electionNodes = OverseerTaskProcessor.getSortedElectionNodes(zkStateReader.getZkClient(),\n          ZkStateReader.getShardLeadersElectPath(collectionName, slice.getName()));\n\n      if (electionNodes.size() < 2) { // if there's only one node in the queue, should already be leader and we shouldn't be here anyway.\n        log.info(\"Rebalancing leaders and slice \" + slice.getName() + \" has less than two elements in the leader \" +\n            \"election queue, but replica \" + replica.getName() + \" doesn't think it's the leader.\");\n        return;\n      }\n\n      // Ok, the sorting for election nodes is a bit strange. If the sequence numbers are the same, then the whole\n      // string is used, but that sorts nodes with the same sequence number by their session IDs from ZK.\n      // While this is determinate, it's not quite what we need, so re-queue nodes that aren't us and are\n      // watching the leader node..\n\n      String firstWatcher = electionNodes.get(1);\n\n      if (LeaderElector.getNodeName(firstWatcher).equals(replica.getName()) == false) {\n        makeReplicaFirstWatcher(collectionName, slice, replica);\n      }\n\n      String coreName = slice.getReplica(LeaderElector.getNodeName(electionNodes.get(0))).getStr(CORE_NAME_PROP);\n      rejoinElection(collectionName, slice, electionNodes.get(0), coreName, false);\n      waitForNodeChange(collectionName, slice, electionNodes.get(0));\n\n\n      return; // Done with this slice, skip the rest of the replicas.\n    }\n  }\n\n","sourceOld":"  private void insurePreferredIsLeader(NamedList<Object> results,\n                                       Slice slice, Map<String, String> currentRequests) throws KeeperException, InterruptedException {\n    final String inactivePreferreds = \"inactivePreferreds\";\n    final String alreadyLeaders = \"alreadyLeaders\";\n    String collectionName = req.getParams().get(COLLECTION_PROP);\n\n    for (Replica replica : slice.getReplicas()) {\n      // Tell the replica to become the leader if we're the preferred leader AND active AND not the leader already\n      if (replica.getBool(SliceMutator.PREFERRED_LEADER_PROP, false) == false) {\n        continue;\n      }\n      // OK, we are the preferred leader, are we the actual leader?\n      if (replica.getBool(LEADER_PROP, false)) {\n        //We're a preferred leader, but we're _also_ the leader, don't need to do anything.\n        NamedList<Object> noops = (NamedList<Object>) results.get(alreadyLeaders);\n        if (noops == null) {\n          noops = new NamedList<>();\n          results.add(alreadyLeaders, noops);\n        }\n        NamedList<Object> res = new NamedList<>();\n        res.add(\"status\", \"success\");\n        res.add(\"msg\", \"Already leader\");\n        res.add(\"shard\", slice.getName());\n        res.add(\"nodeName\", replica.getNodeName());\n        noops.add(replica.getName(), res);\n        return; // already the leader, do nothing.\n      }\n\n      // We're the preferred leader, but someone else is leader. Only become leader if we're active.\n      if (replica.getState() != Replica.State.ACTIVE) {\n        NamedList<Object> inactives = (NamedList<Object>) results.get(inactivePreferreds);\n        if (inactives == null) {\n          inactives = new NamedList<>();\n          results.add(inactivePreferreds, inactives);\n        }\n        NamedList<Object> res = new NamedList<>();\n        res.add(\"status\", \"skipped\");\n        res.add(\"msg\", \"Node is a referredLeader, but it's inactive. Skipping\");\n        res.add(\"shard\", slice.getName());\n        res.add(\"nodeName\", replica.getNodeName());\n        inactives.add(replica.getName(), res);\n        return; // Don't try to become the leader if we're not active!\n      }\n\n      // Replica is the preferred leader but not the actual leader, do something about that.\n      // \"Something\" is\n      // 1> if the preferred leader isn't first in line, tell it to re-queue itself.\n      // 2> tell the actual leader to re-queue itself.\n\n      ZkStateReader zkStateReader = coreContainer.getZkController().getZkStateReader();\n\n      List<String> electionNodes = OverseerTaskProcessor.getSortedElectionNodes(zkStateReader.getZkClient(),\n          ZkStateReader.getShardLeadersElectPath(collectionName, slice.getName()));\n\n      if (electionNodes.size() < 2) { // if there's only one node in the queue, should already be leader and we shouldn't be here anyway.\n        CollectionsHandler.log.warn(\"Rebalancing leaders and slice \" + slice.getName() + \" has less than two elements in the leader \" +\n            \"election queue, but replica \" + replica.getName() + \" doesn't think it's the leader. Do nothing\");\n        return;\n      }\n\n      // Ok, the sorting for election nodes is a bit strange. If the sequence numbers are the same, then the whole\n      // string is used, but that sorts nodes with the same sequence number by their session IDs from ZK.\n      // While this is determinate, it's not quite what we need, so re-queue nodes that aren't us and are\n      // watching the leader node..\n\n      String firstWatcher = electionNodes.get(1);\n\n      if (LeaderElector.getNodeName(firstWatcher).equals(replica.getName()) == false) {\n        makeReplicaFirstWatcher(collectionName, slice, replica);\n      }\n\n      String coreName = slice.getReplica(LeaderElector.getNodeName(electionNodes.get(0))).getStr(CORE_NAME_PROP);\n      rejoinElection(collectionName, slice, electionNodes.get(0), coreName, false);\n      waitForNodeChange(collectionName, slice, electionNodes.get(0));\n\n\n      return; // Done with this slice, skip the rest of the replicas.\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac":["9ebd3a557326ef3eab85b73a8cff781f7d801248"],"2209af2c265d2258ec4b29c8cc78622d36994a15":["e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9ebd3a557326ef3eab85b73a8cff781f7d801248":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"6b18ef9cd3f6ff4f7733e6d43eebec259e0e9064":["2209af2c265d2258ec4b29c8cc78622d36994a15"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6b18ef9cd3f6ff4f7733e6d43eebec259e0e9064"]},"commit2Childs":{"e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac":["2209af2c265d2258ec4b29c8cc78622d36994a15"],"2209af2c265d2258ec4b29c8cc78622d36994a15":["6b18ef9cd3f6ff4f7733e6d43eebec259e0e9064"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9ebd3a557326ef3eab85b73a8cff781f7d801248"],"9ebd3a557326ef3eab85b73a8cff781f7d801248":["e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac"],"6b18ef9cd3f6ff4f7733e6d43eebec259e0e9064":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}