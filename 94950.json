{"path":"src/java/org/apache/lucene/util/Arrays#mergeSort(String[],String[],int,int).mjava","commits":[{"id":"91109046a59c58ee0ee5d0d2767b08d1f30d6702","date":1000830588,"type":0,"author":"Jason van Zyl","isMerge":false,"pathNew":"src/java/org/apache/lucene/util/Arrays#mergeSort(String[],String[],int,int).mjava","pathOld":"/dev/null","sourceNew":"    private static void mergeSort(String src[], String dest[],\n                                  int low, int high) {\n\tint length = high - low;\n\n\t// Insertion sort on smallest arrays\n\tif (length < 7) {\n\t    for (int i=low; i<high; i++)\n\t\tfor (int j=i; j>low && (dest[j-1]).compareTo(dest[j])>0; j--)\n\t\t    swap(dest, j, j-1);\n\t    return;\n\t}\n\n        // Recursively sort halves of dest into src\n        int mid = (low + high)/2;\n        mergeSort(dest, src, low, mid);\n        mergeSort(dest, src, mid, high);\n\n        // If list is already sorted, just copy from src to dest.  This is an\n        // optimization that results in faster sorts for nearly ordered lists.\n        if ((src[mid-1]).compareTo(src[mid]) <= 0) {\n           System.arraycopy(src, low, dest, low, length);\n           return;\n        }\n\n        // Merge sorted halves (now in src) into dest\n        for(int i = low, p = low, q = mid; i < high; i++) {\n            if (q>=high || p<mid && (src[p]).compareTo(src[q])<=0)\n                dest[i] = src[p++];\n            else\n                dest[i] = src[q++];\n        }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"51507f02c43eb5af1a493ce4c8e071bb20350b9a","date":1072630976,"type":4,"author":"Erik Hatcher","isMerge":false,"pathNew":"/dev/null","pathOld":"src/java/org/apache/lucene/util/Arrays#mergeSort(String[],String[],int,int).mjava","sourceNew":null,"sourceOld":"    private static void mergeSort(String src[], String dest[],\n                                  int low, int high) {\n\tint length = high - low;\n\n\t// Insertion sort on smallest arrays\n\tif (length < 7) {\n\t    for (int i=low; i<high; i++)\n\t\tfor (int j=i; j>low && (dest[j-1]).compareTo(dest[j])>0; j--)\n\t\t    swap(dest, j, j-1);\n\t    return;\n\t}\n\n        // Recursively sort halves of dest into src\n        int mid = (low + high)/2;\n        mergeSort(dest, src, low, mid);\n        mergeSort(dest, src, mid, high);\n\n        // If list is already sorted, just copy from src to dest.  This is an\n        // optimization that results in faster sorts for nearly ordered lists.\n        if ((src[mid-1]).compareTo(src[mid]) <= 0) {\n           System.arraycopy(src, low, dest, low, length);\n           return;\n        }\n\n        // Merge sorted halves (now in src) into dest\n        for(int i = low, p = low, q = mid; i < high; i++) {\n            if (q>=high || p<mid && (src[p]).compareTo(src[q])<=0)\n                dest[i] = src[p++];\n            else\n                dest[i] = src[q++];\n        }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"91109046a59c58ee0ee5d0d2767b08d1f30d6702":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"51507f02c43eb5af1a493ce4c8e071bb20350b9a":["91109046a59c58ee0ee5d0d2767b08d1f30d6702"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["51507f02c43eb5af1a493ce4c8e071bb20350b9a"]},"commit2Childs":{"91109046a59c58ee0ee5d0d2767b08d1f30d6702":["51507f02c43eb5af1a493ce4c8e071bb20350b9a"],"51507f02c43eb5af1a493ce4c8e071bb20350b9a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["91109046a59c58ee0ee5d0d2767b08d1f30d6702"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}