{"path":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","sourceNew":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(random, MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false).setMergePolicy(newLogMergePolicy()));\n\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n\n    dir.failOn(failure.reset());\n\n    FieldType custom1 = new FieldType();\n    custom1.setStored(true);\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newField(\"id\", keywords[i], StringField.TYPE_STORED));\n      doc.add(newField(\"country\", unindexed[i], custom1));\n      doc.add(newField(\"contents\", unstored[i], TextField.TYPE_UNSTORED));\n      doc.add(newField(\"city\", text[i], TextField.TYPE_STORED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now full merge\");\n    }\n\n    modifier.forceMerge(1);\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","sourceOld":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(random, MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false).setMergePolicy(newLogMergePolicy()));\n\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n\n    dir.failOn(failure.reset());\n\n    FieldType custom1 = new FieldType();\n    custom1.setStored(true);\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newField(\"id\", keywords[i], StringField.TYPE_STORED));\n      doc.add(newField(\"country\", unindexed[i], custom1));\n      doc.add(newField(\"contents\", unstored[i], TextField.TYPE_UNSTORED));\n      doc.add(newField(\"city\", text[i], TextField.TYPE_STORED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now full merge\");\n    }\n\n    modifier.forceMerge(1);\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","sourceNew":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false).setMergePolicy(newLogMergePolicy()));\n\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n\n    dir.failOn(failure.reset());\n\n    FieldType custom1 = new FieldType();\n    custom1.setStored(true);\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newField(\"id\", keywords[i], StringField.TYPE_STORED));\n      doc.add(newField(\"country\", unindexed[i], custom1));\n      doc.add(newField(\"contents\", unstored[i], TextField.TYPE_UNSTORED));\n      doc.add(newField(\"city\", text[i], TextField.TYPE_STORED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now full merge\");\n    }\n\n    modifier.forceMerge(1);\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","sourceOld":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(random, MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false).setMergePolicy(newLogMergePolicy()));\n\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n\n    dir.failOn(failure.reset());\n\n    FieldType custom1 = new FieldType();\n    custom1.setStored(true);\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newField(\"id\", keywords[i], StringField.TYPE_STORED));\n      doc.add(newField(\"country\", unindexed[i], custom1));\n      doc.add(newField(\"contents\", unstored[i], TextField.TYPE_UNSTORED));\n      doc.add(newField(\"city\", text[i], TextField.TYPE_STORED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now full merge\");\n    }\n\n    modifier.forceMerge(1);\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"04f07771a2a7dd3a395700665ed839c3dae2def2","date":1339350139,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","sourceNew":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false).setMergePolicy(newLogMergePolicy()));\n\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n\n    dir.failOn(failure.reset());\n\n    FieldType custom1 = new FieldType();\n    custom1.setStored(true);\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", keywords[i], Field.Store.YES));\n      doc.add(newField(\"country\", unindexed[i], custom1));\n      doc.add(newTextField(\"contents\", unstored[i], Field.Store.NO));\n      doc.add(newTextField(\"city\", text[i], Field.Store.YES));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now full merge\");\n    }\n\n    modifier.forceMerge(1);\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","sourceOld":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false).setMergePolicy(newLogMergePolicy()));\n\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n\n    dir.failOn(failure.reset());\n\n    FieldType custom1 = new FieldType();\n    custom1.setStored(true);\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newField(\"id\", keywords[i], StringField.TYPE_STORED));\n      doc.add(newField(\"country\", unindexed[i], custom1));\n      doc.add(newField(\"contents\", unstored[i], TextField.TYPE_UNSTORED));\n      doc.add(newField(\"city\", text[i], TextField.TYPE_STORED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now full merge\");\n    }\n\n    modifier.forceMerge(1);\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","bugFix":["1509f151d7692d84fae414b2b799ac06ba60fcb4"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d19974432be9aed28ee7dca73bdf01d139e763a9","date":1342822166,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","sourceNew":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newMockDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false).setMergePolicy(newLogMergePolicy()));\n\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n\n    dir.failOn(failure.reset());\n\n    FieldType custom1 = new FieldType();\n    custom1.setStored(true);\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", keywords[i], Field.Store.YES));\n      doc.add(newField(\"country\", unindexed[i], custom1));\n      doc.add(newTextField(\"contents\", unstored[i], Field.Store.NO));\n      doc.add(newTextField(\"city\", text[i], Field.Store.YES));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now full merge\");\n    }\n\n    modifier.forceMerge(1);\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","sourceOld":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false).setMergePolicy(newLogMergePolicy()));\n\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n\n    dir.failOn(failure.reset());\n\n    FieldType custom1 = new FieldType();\n    custom1.setStored(true);\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", keywords[i], Field.Store.YES));\n      doc.add(newField(\"country\", unindexed[i], custom1));\n      doc.add(newTextField(\"contents\", unstored[i], Field.Store.NO));\n      doc.add(newTextField(\"city\", text[i], Field.Store.YES));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now full merge\");\n    }\n\n    modifier.forceMerge(1);\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","bugFix":["1f653cfcf159baeaafe5d01682a911e95bba4012"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","date":1343059585,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","sourceNew":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newMockDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false).setMergePolicy(newLogMergePolicy()));\n\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n\n    dir.failOn(failure.reset());\n\n    FieldType custom1 = new FieldType();\n    custom1.setStored(true);\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", keywords[i], Field.Store.YES));\n      doc.add(newField(\"country\", unindexed[i], custom1));\n      doc.add(newTextField(\"contents\", unstored[i], Field.Store.NO));\n      doc.add(newTextField(\"city\", text[i], Field.Store.YES));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now full merge\");\n    }\n\n    modifier.forceMerge(1);\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","sourceOld":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false).setMergePolicy(newLogMergePolicy()));\n\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n\n    dir.failOn(failure.reset());\n\n    FieldType custom1 = new FieldType();\n    custom1.setStored(true);\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", keywords[i], Field.Store.YES));\n      doc.add(newField(\"country\", unindexed[i], custom1));\n      doc.add(newTextField(\"contents\", unstored[i], Field.Store.NO));\n      doc.add(newTextField(\"city\", text[i], Field.Store.YES));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now full merge\");\n    }\n\n    modifier.forceMerge(1);\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","sourceNew":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newMockDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false).setMergePolicy(newLogMergePolicy()));\n\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n\n    dir.failOn(failure.reset());\n\n    FieldType custom1 = new FieldType();\n    custom1.setStored(true);\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", keywords[i], Field.Store.YES));\n      doc.add(newField(\"country\", unindexed[i], custom1));\n      doc.add(newTextField(\"contents\", unstored[i], Field.Store.NO));\n      doc.add(newTextField(\"city\", text[i], Field.Store.YES));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now full merge\");\n    }\n\n    modifier.forceMerge(1);\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","sourceOld":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false).setMergePolicy(newLogMergePolicy()));\n\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n\n    dir.failOn(failure.reset());\n\n    FieldType custom1 = new FieldType();\n    custom1.setStored(true);\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", keywords[i], Field.Store.YES));\n      doc.add(newField(\"country\", unindexed[i], custom1));\n      doc.add(newTextField(\"contents\", unstored[i], Field.Store.NO));\n      doc.add(newTextField(\"city\", text[i], Field.Store.YES));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now full merge\");\n    }\n\n    modifier.forceMerge(1);\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"088a7ef694fd43d5d9a4d200c4005865f773d1e7","date":1371136274,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","sourceNew":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newMockDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false).setMergePolicy(newLogMergePolicy()));\n\n    MergePolicy lmp = modifier.getConfig().getMergePolicy();\n    lmp.setNoCFSRatio(1.0);\n\n    dir.failOn(failure.reset());\n\n    FieldType custom1 = new FieldType();\n    custom1.setStored(true);\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", keywords[i], Field.Store.YES));\n      doc.add(newField(\"country\", unindexed[i], custom1));\n      doc.add(newTextField(\"contents\", unstored[i], Field.Store.NO));\n      doc.add(newTextField(\"city\", text[i], Field.Store.YES));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now full merge\");\n    }\n\n    modifier.forceMerge(1);\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","sourceOld":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newMockDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false).setMergePolicy(newLogMergePolicy()));\n\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n\n    dir.failOn(failure.reset());\n\n    FieldType custom1 = new FieldType();\n    custom1.setStored(true);\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", keywords[i], Field.Store.YES));\n      doc.add(newField(\"country\", unindexed[i], custom1));\n      doc.add(newTextField(\"contents\", unstored[i], Field.Store.NO));\n      doc.add(newTextField(\"city\", text[i], Field.Store.YES));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now full merge\");\n    }\n\n    modifier.forceMerge(1);\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0","date":1383367127,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","sourceNew":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletesAndUpdates\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletesAndUpdates\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newMockDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false).setMergePolicy(newLogMergePolicy()));\n\n    MergePolicy lmp = modifier.getConfig().getMergePolicy();\n    lmp.setNoCFSRatio(1.0);\n\n    dir.failOn(failure.reset());\n\n    FieldType custom1 = new FieldType();\n    custom1.setStored(true);\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", keywords[i], Field.Store.YES));\n      doc.add(newField(\"country\", unindexed[i], custom1));\n      doc.add(newTextField(\"contents\", unstored[i], Field.Store.NO));\n      doc.add(newTextField(\"city\", text[i], Field.Store.YES));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now full merge\");\n    }\n\n    modifier.forceMerge(1);\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","sourceOld":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newMockDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false).setMergePolicy(newLogMergePolicy()));\n\n    MergePolicy lmp = modifier.getConfig().getMergePolicy();\n    lmp.setNoCFSRatio(1.0);\n\n    dir.failOn(failure.reset());\n\n    FieldType custom1 = new FieldType();\n    custom1.setStored(true);\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", keywords[i], Field.Store.YES));\n      doc.add(newField(\"country\", unindexed[i], custom1));\n      doc.add(newTextField(\"contents\", unstored[i], Field.Store.NO));\n      doc.add(newTextField(\"city\", text[i], Field.Store.YES));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now full merge\");\n    }\n\n    modifier.forceMerge(1);\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cd4e13d997cf4fb810398a20a299c2c5a9f6b796","date":1395594336,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","sourceNew":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletesAndUpdates\".equals(trace[i].getMethodName()) ||\n                  \"slowFileExists\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletesAndUpdates\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newMockDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false).setMergePolicy(newLogMergePolicy()));\n\n    MergePolicy lmp = modifier.getConfig().getMergePolicy();\n    lmp.setNoCFSRatio(1.0);\n\n    dir.failOn(failure.reset());\n\n    FieldType custom1 = new FieldType();\n    custom1.setStored(true);\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", keywords[i], Field.Store.YES));\n      doc.add(newField(\"country\", unindexed[i], custom1));\n      doc.add(newTextField(\"contents\", unstored[i], Field.Store.NO));\n      doc.add(newTextField(\"city\", text[i], Field.Store.YES));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now full merge\");\n    }\n\n    modifier.forceMerge(1);\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","sourceOld":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletesAndUpdates\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletesAndUpdates\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newMockDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false).setMergePolicy(newLogMergePolicy()));\n\n    MergePolicy lmp = modifier.getConfig().getMergePolicy();\n    lmp.setNoCFSRatio(1.0);\n\n    dir.failOn(failure.reset());\n\n    FieldType custom1 = new FieldType();\n    custom1.setStored(true);\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", keywords[i], Field.Store.YES));\n      doc.add(newField(\"country\", unindexed[i], custom1));\n      doc.add(newTextField(\"contents\", unstored[i], Field.Store.NO));\n      doc.add(newTextField(\"city\", text[i], Field.Store.YES));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now full merge\");\n    }\n\n    modifier.forceMerge(1);\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ae14298f4eec6d5faee6a149f88ba57d14a6f21a","date":1396971290,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","sourceNew":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletesAndUpdates\".equals(trace[i].getMethodName()) ||\n                  \"slowFileExists\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletesAndUpdates\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newMockDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false).setMergePolicy(newLogMergePolicy()));\n\n    MergePolicy lmp = modifier.getConfig().getMergePolicy();\n    lmp.setNoCFSRatio(1.0);\n\n    dir.failOn(failure.reset());\n\n    FieldType custom1 = new FieldType();\n    custom1.setStored(true);\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", keywords[i], Field.Store.YES));\n      doc.add(newField(\"country\", unindexed[i], custom1));\n      doc.add(newTextField(\"contents\", unstored[i], Field.Store.NO));\n      doc.add(newTextField(\"city\", text[i], Field.Store.YES));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now full merge\");\n    }\n\n    modifier.forceMerge(1);\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.shutdown();\n    dir.close();\n  }\n\n","sourceOld":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletesAndUpdates\".equals(trace[i].getMethodName()) ||\n                  \"slowFileExists\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletesAndUpdates\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newMockDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false).setMergePolicy(newLogMergePolicy()));\n\n    MergePolicy lmp = modifier.getConfig().getMergePolicy();\n    lmp.setNoCFSRatio(1.0);\n\n    dir.failOn(failure.reset());\n\n    FieldType custom1 = new FieldType();\n    custom1.setStored(true);\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", keywords[i], Field.Store.YES));\n      doc.add(newField(\"country\", unindexed[i], custom1));\n      doc.add(newTextField(\"contents\", unstored[i], Field.Store.NO));\n      doc.add(newTextField(\"city\", text[i], Field.Store.YES));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now full merge\");\n    }\n\n    modifier.forceMerge(1);\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e","date":1406737224,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","sourceNew":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletesAndUpdates\".equals(trace[i].getMethodName()) ||\n                  \"slowFileExists\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletesAndUpdates\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newMockDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false))\n                                                  .setMaxBufferedDeleteTerms(2)\n                                                  .setReaderPooling(false)\n                                                  .setMergePolicy(newLogMergePolicy()));\n\n    MergePolicy lmp = modifier.getConfig().getMergePolicy();\n    lmp.setNoCFSRatio(1.0);\n\n    dir.failOn(failure.reset());\n\n    FieldType custom1 = new FieldType();\n    custom1.setStored(true);\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", keywords[i], Field.Store.YES));\n      doc.add(newField(\"country\", unindexed[i], custom1));\n      doc.add(newTextField(\"contents\", unstored[i], Field.Store.NO));\n      doc.add(newTextField(\"city\", text[i], Field.Store.YES));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now full merge\");\n    }\n\n    modifier.forceMerge(1);\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.shutdown();\n    dir.close();\n  }\n\n","sourceOld":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletesAndUpdates\".equals(trace[i].getMethodName()) ||\n                  \"slowFileExists\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletesAndUpdates\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newMockDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false).setMergePolicy(newLogMergePolicy()));\n\n    MergePolicy lmp = modifier.getConfig().getMergePolicy();\n    lmp.setNoCFSRatio(1.0);\n\n    dir.failOn(failure.reset());\n\n    FieldType custom1 = new FieldType();\n    custom1.setStored(true);\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", keywords[i], Field.Store.YES));\n      doc.add(newField(\"country\", unindexed[i], custom1));\n      doc.add(newTextField(\"contents\", unstored[i], Field.Store.NO));\n      doc.add(newTextField(\"city\", text[i], Field.Store.YES));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now full merge\");\n    }\n\n    modifier.forceMerge(1);\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.shutdown();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d0ef034a4f10871667ae75181537775ddcf8ade4","date":1407610475,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","sourceNew":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletesAndUpdates\".equals(trace[i].getMethodName()) ||\n                  \"slowFileExists\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletesAndUpdates\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newMockDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false))\n                                                  .setMaxBufferedDeleteTerms(2)\n                                                  .setReaderPooling(false)\n                                                  .setMergePolicy(newLogMergePolicy()));\n\n    MergePolicy lmp = modifier.getConfig().getMergePolicy();\n    lmp.setNoCFSRatio(1.0);\n\n    dir.failOn(failure.reset());\n\n    FieldType custom1 = new FieldType();\n    custom1.setStored(true);\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", keywords[i], Field.Store.YES));\n      doc.add(newField(\"country\", unindexed[i], custom1));\n      doc.add(newTextField(\"contents\", unstored[i], Field.Store.NO));\n      doc.add(newTextField(\"city\", text[i], Field.Store.YES));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now full merge\");\n    }\n\n    modifier.forceMerge(1);\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","sourceOld":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletesAndUpdates\".equals(trace[i].getMethodName()) ||\n                  \"slowFileExists\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletesAndUpdates\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newMockDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false))\n                                                  .setMaxBufferedDeleteTerms(2)\n                                                  .setReaderPooling(false)\n                                                  .setMergePolicy(newLogMergePolicy()));\n\n    MergePolicy lmp = modifier.getConfig().getMergePolicy();\n    lmp.setNoCFSRatio(1.0);\n\n    dir.failOn(failure.reset());\n\n    FieldType custom1 = new FieldType();\n    custom1.setStored(true);\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", keywords[i], Field.Store.YES));\n      doc.add(newField(\"country\", unindexed[i], custom1));\n      doc.add(newTextField(\"contents\", unstored[i], Field.Store.NO));\n      doc.add(newTextField(\"city\", text[i], Field.Store.YES));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now full merge\");\n    }\n\n    modifier.forceMerge(1);\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.shutdown();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"98d2deb8c96c79ebef084a1f8e5a1a6c08608f13","date":1409346855,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","sourceNew":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletesAndUpdates\".equals(trace[i].getMethodName()) ||\n                  \"slowFileExists\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new RuntimeException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletesAndUpdates\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newMockDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false))\n                                                  .setMaxBufferedDeleteTerms(2)\n                                                  .setReaderPooling(false)\n                                                  .setMergePolicy(newLogMergePolicy()));\n\n    MergePolicy lmp = modifier.getConfig().getMergePolicy();\n    lmp.setNoCFSRatio(1.0);\n\n    dir.failOn(failure.reset());\n\n    FieldType custom1 = new FieldType();\n    custom1.setStored(true);\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", keywords[i], Field.Store.YES));\n      doc.add(newField(\"country\", unindexed[i], custom1));\n      doc.add(newTextField(\"contents\", unstored[i], Field.Store.NO));\n      doc.add(newTextField(\"city\", text[i], Field.Store.YES));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now full merge\");\n    }\n\n    modifier.forceMerge(1);\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (RuntimeException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","sourceOld":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletesAndUpdates\".equals(trace[i].getMethodName()) ||\n                  \"slowFileExists\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletesAndUpdates\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newMockDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false))\n                                                  .setMaxBufferedDeleteTerms(2)\n                                                  .setReaderPooling(false)\n                                                  .setMergePolicy(newLogMergePolicy()));\n\n    MergePolicy lmp = modifier.getConfig().getMergePolicy();\n    lmp.setNoCFSRatio(1.0);\n\n    dir.failOn(failure.reset());\n\n    FieldType custom1 = new FieldType();\n    custom1.setStored(true);\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", keywords[i], Field.Store.YES));\n      doc.add(newField(\"country\", unindexed[i], custom1));\n      doc.add(newTextField(\"contents\", unstored[i], Field.Store.NO));\n      doc.add(newTextField(\"city\", text[i], Field.Store.YES));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now full merge\");\n    }\n\n    modifier.forceMerge(1);\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":["05fe562aa248790944d43cdd478f512572835ba0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7e4c214a1f904dde76f5611b56d4081533055b3b","date":1421938451,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","sourceNew":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletesAndUpdates\".equals(trace[i].getMethodName()) ||\n                  \"slowFileExists\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new RuntimeException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletesAndUpdates\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newMockDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false))\n                                                  .setMaxBufferedDeleteTerms(2)\n                                                  .setReaderPooling(false)\n                                                  .setMergePolicy(newLogMergePolicy()));\n\n    MergePolicy lmp = modifier.getConfig().getMergePolicy();\n    lmp.setNoCFSRatio(1.0);\n\n    dir.failOn(failure.reset());\n\n    FieldType custom1 = new FieldType();\n    custom1.setStored(true);\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", keywords[i], Field.Store.YES));\n      doc.add(newField(\"country\", unindexed[i], custom1));\n      doc.add(newTextField(\"contents\", unstored[i], Field.Store.NO));\n      doc.add(newTextField(\"city\", text[i], Field.Store.YES));\n      modifier.addDocument(doc);\n    }\n    // flush\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now full merge\");\n    }\n\n    modifier.forceMerge(1);\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (RuntimeException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","sourceOld":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletesAndUpdates\".equals(trace[i].getMethodName()) ||\n                  \"slowFileExists\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new RuntimeException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletesAndUpdates\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newMockDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false))\n                                                  .setMaxBufferedDeleteTerms(2)\n                                                  .setReaderPooling(false)\n                                                  .setMergePolicy(newLogMergePolicy()));\n\n    MergePolicy lmp = modifier.getConfig().getMergePolicy();\n    lmp.setNoCFSRatio(1.0);\n\n    dir.failOn(failure.reset());\n\n    FieldType custom1 = new FieldType();\n    custom1.setStored(true);\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", keywords[i], Field.Store.YES));\n      doc.add(newField(\"country\", unindexed[i], custom1));\n      doc.add(newTextField(\"contents\", unstored[i], Field.Store.NO));\n      doc.add(newTextField(\"city\", text[i], Field.Store.YES));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now full merge\");\n    }\n\n    modifier.forceMerge(1);\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (RuntimeException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","bugFix":["87c966e9308847938a7c905c2e46a56d8df788b8"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d9e22bdf0692bfa61e342b04a6ac7078670c1e16","date":1436866730,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","sourceNew":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletesAndUpdates\".equals(trace[i].getMethodName()) ||\n                  \"slowFileExists\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new RuntimeException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletesAndUpdates\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newMockDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false))\n                                                  .setMaxBufferedDeleteTerms(2)\n                                                  .setReaderPooling(false)\n                                                  .setMergePolicy(newLogMergePolicy()));\n\n    MergePolicy lmp = modifier.getConfig().getMergePolicy();\n    lmp.setNoCFSRatio(1.0);\n\n    dir.failOn(failure.reset());\n\n    FieldType custom1 = new FieldType();\n    custom1.setStored(true);\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", keywords[i], Field.Store.YES));\n      doc.add(newField(\"country\", unindexed[i], custom1));\n      doc.add(newTextField(\"contents\", unstored[i], Field.Store.NO));\n      doc.add(newTextField(\"city\", text[i], Field.Store.YES));\n      modifier.addDocument(doc);\n    }\n    // flush\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now full merge\");\n    }\n\n    modifier.forceMerge(1);\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (RuntimeException ioe) {\n      // expected\n      if (VERBOSE) {\n        System.out.println(\"TEST: hit exc:\");\n        ioe.printStackTrace(System.out);\n      }\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    boolean writerClosed;\n    try {\n      modifier.commit();\n      writerClosed = false;\n    } catch (IllegalStateException ise) {\n      // The above exc struck during merge, and closed the writer\n      writerClosed = true;\n    }\n\n    if (writerClosed == false) {\n      hitCount = getHitCount(dir, term);\n\n      // Make sure the delete was successfully flushed:\n      assertEquals(0, hitCount);\n\n      modifier.close();\n    }\n    dir.close();\n  }\n\n","sourceOld":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletesAndUpdates\".equals(trace[i].getMethodName()) ||\n                  \"slowFileExists\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new RuntimeException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletesAndUpdates\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newMockDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false))\n                                                  .setMaxBufferedDeleteTerms(2)\n                                                  .setReaderPooling(false)\n                                                  .setMergePolicy(newLogMergePolicy()));\n\n    MergePolicy lmp = modifier.getConfig().getMergePolicy();\n    lmp.setNoCFSRatio(1.0);\n\n    dir.failOn(failure.reset());\n\n    FieldType custom1 = new FieldType();\n    custom1.setStored(true);\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", keywords[i], Field.Store.YES));\n      doc.add(newField(\"country\", unindexed[i], custom1));\n      doc.add(newTextField(\"contents\", unstored[i], Field.Store.NO));\n      doc.add(newTextField(\"city\", text[i], Field.Store.YES));\n      modifier.addDocument(doc);\n    }\n    // flush\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now full merge\");\n    }\n\n    modifier.forceMerge(1);\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (RuntimeException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":["05fe562aa248790944d43cdd478f512572835ba0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"05fe562aa248790944d43cdd478f512572835ba0","date":1455901667,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","sourceNew":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletesAndUpdates\".equals(trace[i].getMethodName()) ||\n                  \"slowFileExists\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new RuntimeException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletesAndUpdates\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newMockDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false))\n                                                  .setMaxBufferedDeleteTerms(2)\n                                                  .setReaderPooling(false)\n                                                  .setMergePolicy(newLogMergePolicy()));\n\n    MergePolicy lmp = modifier.getConfig().getMergePolicy();\n    lmp.setNoCFSRatio(1.0);\n\n    dir.failOn(failure.reset());\n\n    FieldType custom1 = new FieldType();\n    custom1.setStored(true);\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", keywords[i], Field.Store.YES));\n      doc.add(newField(\"country\", unindexed[i], custom1));\n      doc.add(newTextField(\"contents\", unstored[i], Field.Store.NO));\n      doc.add(newTextField(\"city\", text[i], Field.Store.YES));\n      modifier.addDocument(doc);\n    }\n    // flush\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now full merge\");\n    }\n\n    modifier.forceMerge(1);\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit for failure\");\n    }\n    RuntimeException expected = expectThrows(RuntimeException.class, () -> {\n      modifier.commit();\n    });\n    if (VERBOSE) {\n      System.out.println(\"TEST: hit exc:\");\n      expected.printStackTrace(System.out);\n    }\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    boolean writerClosed;\n    try {\n      modifier.commit();\n      writerClosed = false;\n    } catch (IllegalStateException ise) {\n      // The above exc struck during merge, and closed the writer\n      writerClosed = true;\n    }\n\n    if (writerClosed == false) {\n      hitCount = getHitCount(dir, term);\n\n      // Make sure the delete was successfully flushed:\n      assertEquals(0, hitCount);\n\n      modifier.close();\n    }\n    dir.close();\n  }\n\n","sourceOld":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletesAndUpdates\".equals(trace[i].getMethodName()) ||\n                  \"slowFileExists\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new RuntimeException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletesAndUpdates\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newMockDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false))\n                                                  .setMaxBufferedDeleteTerms(2)\n                                                  .setReaderPooling(false)\n                                                  .setMergePolicy(newLogMergePolicy()));\n\n    MergePolicy lmp = modifier.getConfig().getMergePolicy();\n    lmp.setNoCFSRatio(1.0);\n\n    dir.failOn(failure.reset());\n\n    FieldType custom1 = new FieldType();\n    custom1.setStored(true);\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", keywords[i], Field.Store.YES));\n      doc.add(newField(\"country\", unindexed[i], custom1));\n      doc.add(newTextField(\"contents\", unstored[i], Field.Store.NO));\n      doc.add(newTextField(\"city\", text[i], Field.Store.YES));\n      modifier.addDocument(doc);\n    }\n    // flush\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now full merge\");\n    }\n\n    modifier.forceMerge(1);\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (RuntimeException ioe) {\n      // expected\n      if (VERBOSE) {\n        System.out.println(\"TEST: hit exc:\");\n        ioe.printStackTrace(System.out);\n      }\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    boolean writerClosed;\n    try {\n      modifier.commit();\n      writerClosed = false;\n    } catch (IllegalStateException ise) {\n      // The above exc struck during merge, and closed the writer\n      writerClosed = true;\n    }\n\n    if (writerClosed == false) {\n      hitCount = getHitCount(dir, term);\n\n      // Make sure the delete was successfully flushed:\n      assertEquals(0, hitCount);\n\n      modifier.close();\n    }\n    dir.close();\n  }\n\n","bugFix":["d9e22bdf0692bfa61e342b04a6ac7078670c1e16","f3c3298e3b8617605888ca94ac7fd2d168bd098d","98d2deb8c96c79ebef084a1f8e5a1a6c08608f13","163fe85a71d778fd2b7747f65ca27b54829e2e57","87c966e9308847938a7c905c2e46a56d8df788b8"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6","date":1498031702,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","sourceNew":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletesAndUpdates\".equals(trace[i].getMethodName()) ||\n                  \"slowFileExists\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new RuntimeException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletesAndUpdates\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newMockDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false))\n                                                  .setMaxBufferedDeleteTerms(2)\n                                                  .setReaderPooling(false)\n                                                  .setMergePolicy(newLogMergePolicy()));\n\n    MergePolicy lmp = modifier.getConfig().getMergePolicy();\n    lmp.setNoCFSRatio(1.0);\n\n    dir.failOn(failure.reset());\n\n    FieldType custom1 = new FieldType();\n    custom1.setStored(true);\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", keywords[i], Field.Store.YES));\n      doc.add(newField(\"country\", unindexed[i], custom1));\n      doc.add(newTextField(\"contents\", unstored[i], Field.Store.NO));\n      doc.add(newTextField(\"city\", text[i], Field.Store.YES));\n      modifier.addDocument(doc);\n    }\n    // flush\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now full merge\");\n    }\n\n    modifier.forceMerge(1);\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    long hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit for failure\");\n    }\n    RuntimeException expected = expectThrows(RuntimeException.class, () -> {\n      modifier.commit();\n    });\n    if (VERBOSE) {\n      System.out.println(\"TEST: hit exc:\");\n      expected.printStackTrace(System.out);\n    }\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    boolean writerClosed;\n    try {\n      modifier.commit();\n      writerClosed = false;\n    } catch (IllegalStateException ise) {\n      // The above exc struck during merge, and closed the writer\n      writerClosed = true;\n    }\n\n    if (writerClosed == false) {\n      hitCount = getHitCount(dir, term);\n\n      // Make sure the delete was successfully flushed:\n      assertEquals(0, hitCount);\n\n      modifier.close();\n    }\n    dir.close();\n  }\n\n","sourceOld":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletesAndUpdates\".equals(trace[i].getMethodName()) ||\n                  \"slowFileExists\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new RuntimeException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletesAndUpdates\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newMockDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false))\n                                                  .setMaxBufferedDeleteTerms(2)\n                                                  .setReaderPooling(false)\n                                                  .setMergePolicy(newLogMergePolicy()));\n\n    MergePolicy lmp = modifier.getConfig().getMergePolicy();\n    lmp.setNoCFSRatio(1.0);\n\n    dir.failOn(failure.reset());\n\n    FieldType custom1 = new FieldType();\n    custom1.setStored(true);\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", keywords[i], Field.Store.YES));\n      doc.add(newField(\"country\", unindexed[i], custom1));\n      doc.add(newTextField(\"contents\", unstored[i], Field.Store.NO));\n      doc.add(newTextField(\"city\", text[i], Field.Store.YES));\n      modifier.addDocument(doc);\n    }\n    // flush\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now full merge\");\n    }\n\n    modifier.forceMerge(1);\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit for failure\");\n    }\n    RuntimeException expected = expectThrows(RuntimeException.class, () -> {\n      modifier.commit();\n    });\n    if (VERBOSE) {\n      System.out.println(\"TEST: hit exc:\");\n      expected.printStackTrace(System.out);\n    }\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    boolean writerClosed;\n    try {\n      modifier.commit();\n      writerClosed = false;\n    } catch (IllegalStateException ise) {\n      // The above exc struck during merge, and closed the writer\n      writerClosed = true;\n    }\n\n    if (writerClosed == false) {\n      hitCount = getHitCount(dir, term);\n\n      // Make sure the delete was successfully flushed:\n      assertEquals(0, hitCount);\n\n      modifier.close();\n    }\n    dir.close();\n  }\n\n","bugFix":["87c966e9308847938a7c905c2e46a56d8df788b8"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4363cd33f6eff7fb4753574a441e2d18c1022a4","date":1498067235,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","sourceNew":"  @Ignore\n  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (VERBOSE) {\n            System.out.println(\"FAIL EVAL:\");\n          }\n          new Throwable().printStackTrace(System.out);\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletesAndUpdates\".equals(trace[i].getMethodName()) ||\n                  \"slowFileExists\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new RuntimeException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletesAndUpdates\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newMockDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false))\n                                                  .setReaderPooling(false)\n                                                  .setMergePolicy(newLogMergePolicy()));\n\n    MergePolicy lmp = modifier.getConfig().getMergePolicy();\n    lmp.setNoCFSRatio(1.0);\n\n    dir.failOn(failure.reset());\n\n    FieldType custom1 = new FieldType();\n    custom1.setStored(true);\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", keywords[i], Field.Store.YES));\n      doc.add(newField(\"country\", unindexed[i], custom1));\n      doc.add(newTextField(\"contents\", unstored[i], Field.Store.NO));\n      doc.add(newTextField(\"city\", text[i], Field.Store.YES));\n      modifier.addDocument(doc);\n    }\n    // flush\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now full merge\");\n    }\n\n    modifier.forceMerge(1);\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    long hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit for failure\");\n    }\n    RuntimeException expected = expectThrows(RuntimeException.class, () -> {\n      modifier.commit();\n    });\n    if (VERBOSE) {\n      System.out.println(\"TEST: hit exc:\");\n      expected.printStackTrace(System.out);\n    }\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    boolean writerClosed;\n    try {\n      modifier.commit();\n      writerClosed = false;\n    } catch (IllegalStateException ise) {\n      // The above exc struck during merge, and closed the writer\n      writerClosed = true;\n    }\n\n    if (writerClosed == false) {\n      hitCount = getHitCount(dir, term);\n\n      // Make sure the delete was successfully flushed:\n      assertEquals(0, hitCount);\n\n      modifier.close();\n    }\n    dir.close();\n  }\n\n","sourceOld":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletesAndUpdates\".equals(trace[i].getMethodName()) ||\n                  \"slowFileExists\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new RuntimeException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletesAndUpdates\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newMockDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false))\n                                                  .setMaxBufferedDeleteTerms(2)\n                                                  .setReaderPooling(false)\n                                                  .setMergePolicy(newLogMergePolicy()));\n\n    MergePolicy lmp = modifier.getConfig().getMergePolicy();\n    lmp.setNoCFSRatio(1.0);\n\n    dir.failOn(failure.reset());\n\n    FieldType custom1 = new FieldType();\n    custom1.setStored(true);\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", keywords[i], Field.Store.YES));\n      doc.add(newField(\"country\", unindexed[i], custom1));\n      doc.add(newTextField(\"contents\", unstored[i], Field.Store.NO));\n      doc.add(newTextField(\"city\", text[i], Field.Store.YES));\n      modifier.addDocument(doc);\n    }\n    // flush\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now full merge\");\n    }\n\n    modifier.forceMerge(1);\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    long hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit for failure\");\n    }\n    RuntimeException expected = expectThrows(RuntimeException.class, () -> {\n      modifier.commit();\n    });\n    if (VERBOSE) {\n      System.out.println(\"TEST: hit exc:\");\n      expected.printStackTrace(System.out);\n    }\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    boolean writerClosed;\n    try {\n      modifier.commit();\n      writerClosed = false;\n    } catch (IllegalStateException ise) {\n      // The above exc struck during merge, and closed the writer\n      writerClosed = true;\n    }\n\n    if (writerClosed == false) {\n      hitCount = getHitCount(dir, term);\n\n      // Make sure the delete was successfully flushed:\n      assertEquals(0, hitCount);\n\n      modifier.close();\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","sourceNew":"  @Ignore\n  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (VERBOSE) {\n            System.out.println(\"FAIL EVAL:\");\n          }\n          new Throwable().printStackTrace(System.out);\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletesAndUpdates\".equals(trace[i].getMethodName()) ||\n                  \"slowFileExists\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new RuntimeException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletesAndUpdates\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newMockDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false))\n                                                  .setReaderPooling(false)\n                                                  .setMergePolicy(newLogMergePolicy()));\n\n    MergePolicy lmp = modifier.getConfig().getMergePolicy();\n    lmp.setNoCFSRatio(1.0);\n\n    dir.failOn(failure.reset());\n\n    FieldType custom1 = new FieldType();\n    custom1.setStored(true);\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", keywords[i], Field.Store.YES));\n      doc.add(newField(\"country\", unindexed[i], custom1));\n      doc.add(newTextField(\"contents\", unstored[i], Field.Store.NO));\n      doc.add(newTextField(\"city\", text[i], Field.Store.YES));\n      modifier.addDocument(doc);\n    }\n    // flush\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now full merge\");\n    }\n\n    modifier.forceMerge(1);\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    long hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit for failure\");\n    }\n    RuntimeException expected = expectThrows(RuntimeException.class, () -> {\n      modifier.commit();\n    });\n    if (VERBOSE) {\n      System.out.println(\"TEST: hit exc:\");\n      expected.printStackTrace(System.out);\n    }\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    boolean writerClosed;\n    try {\n      modifier.commit();\n      writerClosed = false;\n    } catch (IllegalStateException ise) {\n      // The above exc struck during merge, and closed the writer\n      writerClosed = true;\n    }\n\n    if (writerClosed == false) {\n      hitCount = getHitCount(dir, term);\n\n      // Make sure the delete was successfully flushed:\n      assertEquals(0, hitCount);\n\n      modifier.close();\n    }\n    dir.close();\n  }\n\n","sourceOld":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletesAndUpdates\".equals(trace[i].getMethodName()) ||\n                  \"slowFileExists\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new RuntimeException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletesAndUpdates\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newMockDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false))\n                                                  .setMaxBufferedDeleteTerms(2)\n                                                  .setReaderPooling(false)\n                                                  .setMergePolicy(newLogMergePolicy()));\n\n    MergePolicy lmp = modifier.getConfig().getMergePolicy();\n    lmp.setNoCFSRatio(1.0);\n\n    dir.failOn(failure.reset());\n\n    FieldType custom1 = new FieldType();\n    custom1.setStored(true);\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", keywords[i], Field.Store.YES));\n      doc.add(newField(\"country\", unindexed[i], custom1));\n      doc.add(newTextField(\"contents\", unstored[i], Field.Store.NO));\n      doc.add(newTextField(\"city\", text[i], Field.Store.YES));\n      modifier.addDocument(doc);\n    }\n    // flush\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now full merge\");\n    }\n\n    modifier.forceMerge(1);\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit for failure\");\n    }\n    RuntimeException expected = expectThrows(RuntimeException.class, () -> {\n      modifier.commit();\n    });\n    if (VERBOSE) {\n      System.out.println(\"TEST: hit exc:\");\n      expected.printStackTrace(System.out);\n    }\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    boolean writerClosed;\n    try {\n      modifier.commit();\n      writerClosed = false;\n    } catch (IllegalStateException ise) {\n      // The above exc struck during merge, and closed the writer\n      writerClosed = true;\n    }\n\n    if (writerClosed == false) {\n      hitCount = getHitCount(dir, term);\n\n      // Make sure the delete was successfully flushed:\n      assertEquals(0, hitCount);\n\n      modifier.close();\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","sourceNew":"  @Ignore\n  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (VERBOSE) {\n            System.out.println(\"FAIL EVAL:\");\n          }\n          new Throwable().printStackTrace(System.out);\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletesAndUpdates\".equals(trace[i].getMethodName()) ||\n                  \"slowFileExists\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new RuntimeException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletesAndUpdates\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newMockDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false))\n                                                  .setReaderPooling(false)\n                                                  .setMergePolicy(newLogMergePolicy()));\n\n    MergePolicy lmp = modifier.getConfig().getMergePolicy();\n    lmp.setNoCFSRatio(1.0);\n\n    dir.failOn(failure.reset());\n\n    FieldType custom1 = new FieldType();\n    custom1.setStored(true);\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", keywords[i], Field.Store.YES));\n      doc.add(newField(\"country\", unindexed[i], custom1));\n      doc.add(newTextField(\"contents\", unstored[i], Field.Store.NO));\n      doc.add(newTextField(\"city\", text[i], Field.Store.YES));\n      modifier.addDocument(doc);\n    }\n    // flush\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now full merge\");\n    }\n\n    modifier.forceMerge(1);\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    long hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit for failure\");\n    }\n    RuntimeException expected = expectThrows(RuntimeException.class, () -> {\n      modifier.commit();\n    });\n    if (VERBOSE) {\n      System.out.println(\"TEST: hit exc:\");\n      expected.printStackTrace(System.out);\n    }\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    boolean writerClosed;\n    try {\n      modifier.commit();\n      writerClosed = false;\n    } catch (IllegalStateException ise) {\n      // The above exc struck during merge, and closed the writer\n      writerClosed = true;\n    }\n\n    if (writerClosed == false) {\n      hitCount = getHitCount(dir, term);\n\n      // Make sure the delete was successfully flushed:\n      assertEquals(0, hitCount);\n\n      modifier.close();\n    }\n    dir.close();\n  }\n\n","sourceOld":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletesAndUpdates\".equals(trace[i].getMethodName()) ||\n                  \"slowFileExists\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new RuntimeException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletesAndUpdates\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newMockDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false))\n                                                  .setMaxBufferedDeleteTerms(2)\n                                                  .setReaderPooling(false)\n                                                  .setMergePolicy(newLogMergePolicy()));\n\n    MergePolicy lmp = modifier.getConfig().getMergePolicy();\n    lmp.setNoCFSRatio(1.0);\n\n    dir.failOn(failure.reset());\n\n    FieldType custom1 = new FieldType();\n    custom1.setStored(true);\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", keywords[i], Field.Store.YES));\n      doc.add(newField(\"country\", unindexed[i], custom1));\n      doc.add(newTextField(\"contents\", unstored[i], Field.Store.NO));\n      doc.add(newTextField(\"city\", text[i], Field.Store.YES));\n      modifier.addDocument(doc);\n    }\n    // flush\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now full merge\");\n    }\n\n    modifier.forceMerge(1);\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit for failure\");\n    }\n    RuntimeException expected = expectThrows(RuntimeException.class, () -> {\n      modifier.commit();\n    });\n    if (VERBOSE) {\n      System.out.println(\"TEST: hit exc:\");\n      expected.printStackTrace(System.out);\n    }\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    boolean writerClosed;\n    try {\n      modifier.commit();\n      writerClosed = false;\n    } catch (IllegalStateException ise) {\n      // The above exc struck during merge, and closed the writer\n      writerClosed = true;\n    }\n\n    if (writerClosed == false) {\n      hitCount = getHitCount(dir, term);\n\n      // Make sure the delete was successfully flushed:\n      assertEquals(0, hitCount);\n\n      modifier.close();\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2916966cc9815e973c01452a0d76c98c5e0d0926","date":1577444040,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","sourceNew":"  @Ignore\n  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (VERBOSE) {\n            System.out.println(\"FAIL EVAL:\");\n          }\n          new Throwable().printStackTrace(System.out);\n          if (sawMaybe && !failed) {\n            boolean seen = callStackContainsAnyOf(\"applyDeletesAndUpdates\", \"slowFileExists\");\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new RuntimeException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            if (callStackContainsAnyOf(\"applyDeletesAndUpdates\")) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                new Throwable().printStackTrace(System.out);\n              }\n              sawMaybe = true;\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newMockDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false))\n                                                  .setReaderPooling(false)\n                                                  .setMergePolicy(newLogMergePolicy()));\n\n    MergePolicy lmp = modifier.getConfig().getMergePolicy();\n    lmp.setNoCFSRatio(1.0);\n\n    dir.failOn(failure.reset());\n\n    FieldType custom1 = new FieldType();\n    custom1.setStored(true);\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", keywords[i], Field.Store.YES));\n      doc.add(newField(\"country\", unindexed[i], custom1));\n      doc.add(newTextField(\"contents\", unstored[i], Field.Store.NO));\n      doc.add(newTextField(\"city\", text[i], Field.Store.YES));\n      modifier.addDocument(doc);\n    }\n    // flush\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now full merge\");\n    }\n\n    modifier.forceMerge(1);\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    long hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit for failure\");\n    }\n    RuntimeException expected = expectThrows(RuntimeException.class, () -> {\n      modifier.commit();\n    });\n    if (VERBOSE) {\n      System.out.println(\"TEST: hit exc:\");\n      expected.printStackTrace(System.out);\n    }\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    boolean writerClosed;\n    try {\n      modifier.commit();\n      writerClosed = false;\n    } catch (IllegalStateException ise) {\n      // The above exc struck during merge, and closed the writer\n      writerClosed = true;\n    }\n\n    if (writerClosed == false) {\n      hitCount = getHitCount(dir, term);\n\n      // Make sure the delete was successfully flushed:\n      assertEquals(0, hitCount);\n\n      modifier.close();\n    }\n    dir.close();\n  }\n\n","sourceOld":"  @Ignore\n  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (VERBOSE) {\n            System.out.println(\"FAIL EVAL:\");\n          }\n          new Throwable().printStackTrace(System.out);\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletesAndUpdates\".equals(trace[i].getMethodName()) ||\n                  \"slowFileExists\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new RuntimeException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletesAndUpdates\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newMockDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false))\n                                                  .setReaderPooling(false)\n                                                  .setMergePolicy(newLogMergePolicy()));\n\n    MergePolicy lmp = modifier.getConfig().getMergePolicy();\n    lmp.setNoCFSRatio(1.0);\n\n    dir.failOn(failure.reset());\n\n    FieldType custom1 = new FieldType();\n    custom1.setStored(true);\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", keywords[i], Field.Store.YES));\n      doc.add(newField(\"country\", unindexed[i], custom1));\n      doc.add(newTextField(\"contents\", unstored[i], Field.Store.NO));\n      doc.add(newTextField(\"city\", text[i], Field.Store.YES));\n      modifier.addDocument(doc);\n    }\n    // flush\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now full merge\");\n    }\n\n    modifier.forceMerge(1);\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    long hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit for failure\");\n    }\n    RuntimeException expected = expectThrows(RuntimeException.class, () -> {\n      modifier.commit();\n    });\n    if (VERBOSE) {\n      System.out.println(\"TEST: hit exc:\");\n      expected.printStackTrace(System.out);\n    }\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    boolean writerClosed;\n    try {\n      modifier.commit();\n      writerClosed = false;\n    } catch (IllegalStateException ise) {\n      // The above exc struck during merge, and closed the writer\n      writerClosed = true;\n    }\n\n    if (writerClosed == false) {\n      hitCount = getHitCount(dir, term);\n\n      // Make sure the delete was successfully flushed:\n      assertEquals(0, hitCount);\n\n      modifier.close();\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"94ec73c5617c177b1d81ddfe04bbff1d08fccecc","date":1577456244,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","sourceNew":"  @Ignore\n  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (VERBOSE) {\n            System.out.println(\"FAIL EVAL:\");\n          }\n          new Throwable().printStackTrace(System.out);\n          if (sawMaybe && !failed) {\n            boolean seen = callStackContainsAnyOf(\"applyDeletesAndUpdates\", \"slowFileExists\");\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new RuntimeException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            if (callStackContainsAnyOf(\"applyDeletesAndUpdates\")) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                new Throwable().printStackTrace(System.out);\n              }\n              sawMaybe = true;\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newMockDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false))\n                                                  .setReaderPooling(false)\n                                                  .setMergePolicy(newLogMergePolicy()));\n\n    MergePolicy lmp = modifier.getConfig().getMergePolicy();\n    lmp.setNoCFSRatio(1.0);\n\n    dir.failOn(failure.reset());\n\n    FieldType custom1 = new FieldType();\n    custom1.setStored(true);\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", keywords[i], Field.Store.YES));\n      doc.add(newField(\"country\", unindexed[i], custom1));\n      doc.add(newTextField(\"contents\", unstored[i], Field.Store.NO));\n      doc.add(newTextField(\"city\", text[i], Field.Store.YES));\n      modifier.addDocument(doc);\n    }\n    // flush\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now full merge\");\n    }\n\n    modifier.forceMerge(1);\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    long hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit for failure\");\n    }\n    RuntimeException expected = expectThrows(RuntimeException.class, () -> {\n      modifier.commit();\n    });\n    if (VERBOSE) {\n      System.out.println(\"TEST: hit exc:\");\n      expected.printStackTrace(System.out);\n    }\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    boolean writerClosed;\n    try {\n      modifier.commit();\n      writerClosed = false;\n    } catch (IllegalStateException ise) {\n      // The above exc struck during merge, and closed the writer\n      writerClosed = true;\n    }\n\n    if (writerClosed == false) {\n      hitCount = getHitCount(dir, term);\n\n      // Make sure the delete was successfully flushed:\n      assertEquals(0, hitCount);\n\n      modifier.close();\n    }\n    dir.close();\n  }\n\n","sourceOld":"  @Ignore\n  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (VERBOSE) {\n            System.out.println(\"FAIL EVAL:\");\n          }\n          new Throwable().printStackTrace(System.out);\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletesAndUpdates\".equals(trace[i].getMethodName()) ||\n                  \"slowFileExists\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new RuntimeException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletesAndUpdates\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newMockDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false))\n                                                  .setReaderPooling(false)\n                                                  .setMergePolicy(newLogMergePolicy()));\n\n    MergePolicy lmp = modifier.getConfig().getMergePolicy();\n    lmp.setNoCFSRatio(1.0);\n\n    dir.failOn(failure.reset());\n\n    FieldType custom1 = new FieldType();\n    custom1.setStored(true);\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", keywords[i], Field.Store.YES));\n      doc.add(newField(\"country\", unindexed[i], custom1));\n      doc.add(newTextField(\"contents\", unstored[i], Field.Store.NO));\n      doc.add(newTextField(\"city\", text[i], Field.Store.YES));\n      modifier.addDocument(doc);\n    }\n    // flush\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now full merge\");\n    }\n\n    modifier.forceMerge(1);\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    long hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit for failure\");\n    }\n    RuntimeException expected = expectThrows(RuntimeException.class, () -> {\n      modifier.commit();\n    });\n    if (VERBOSE) {\n      System.out.println(\"TEST: hit exc:\");\n      expected.printStackTrace(System.out);\n    }\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    boolean writerClosed;\n    try {\n      modifier.commit();\n      writerClosed = false;\n    } catch (IllegalStateException ise) {\n      // The above exc struck during merge, and closed the writer\n      writerClosed = true;\n    }\n\n    if (writerClosed == false) {\n      hitCount = getHitCount(dir, term);\n\n      // Make sure the delete was successfully flushed:\n      assertEquals(0, hitCount);\n\n      modifier.close();\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0":["088a7ef694fd43d5d9a4d200c4005865f773d1e7"],"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"cd4e13d997cf4fb810398a20a299c2c5a9f6b796":["73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6"],"f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6":["05fe562aa248790944d43cdd478f512572835ba0"],"05fe562aa248790944d43cdd478f512572835ba0":["d9e22bdf0692bfa61e342b04a6ac7078670c1e16"],"98d2deb8c96c79ebef084a1f8e5a1a6c08608f13":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"2916966cc9815e973c01452a0d76c98c5e0d0926":["28288370235ed02234a64753cdbf0c6ec096304a"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["05fe562aa248790944d43cdd478f512572835ba0","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"28288370235ed02234a64753cdbf0c6ec096304a":["05fe562aa248790944d43cdd478f512572835ba0","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"04f07771a2a7dd3a395700665ed839c3dae2def2":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"d9e22bdf0692bfa61e342b04a6ac7078670c1e16":["7e4c214a1f904dde76f5611b56d4081533055b3b"],"088a7ef694fd43d5d9a4d200c4005865f773d1e7":["d19974432be9aed28ee7dca73bdf01d139e763a9"],"aba371508186796cc6151d8223a5b4e16d02e26e":["04f07771a2a7dd3a395700665ed839c3dae2def2","d19974432be9aed28ee7dca73bdf01d139e763a9"],"d19974432be9aed28ee7dca73bdf01d139e763a9":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d0ef034a4f10871667ae75181537775ddcf8ade4":["54a6bea0b991120a99ad0e2f72ae853fd5ecae0e"],"7e4c214a1f904dde76f5611b56d4081533055b3b":["98d2deb8c96c79ebef084a1f8e5a1a6c08608f13"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["cd4e13d997cf4fb810398a20a299c2c5a9f6b796"],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":["04f07771a2a7dd3a395700665ed839c3dae2def2","d19974432be9aed28ee7dca73bdf01d139e763a9"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"94ec73c5617c177b1d81ddfe04bbff1d08fccecc":["28288370235ed02234a64753cdbf0c6ec096304a","2916966cc9815e973c01452a0d76c98c5e0d0926"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2916966cc9815e973c01452a0d76c98c5e0d0926"]},"commit2Childs":{"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0":["cd4e13d997cf4fb810398a20a299c2c5a9f6b796"],"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"cd4e13d997cf4fb810398a20a299c2c5a9f6b796":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6":["f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"05fe562aa248790944d43cdd478f512572835ba0":["f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"98d2deb8c96c79ebef084a1f8e5a1a6c08608f13":["7e4c214a1f904dde76f5611b56d4081533055b3b"],"2916966cc9815e973c01452a0d76c98c5e0d0926":["94ec73c5617c177b1d81ddfe04bbff1d08fccecc","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":[],"28288370235ed02234a64753cdbf0c6ec096304a":["2916966cc9815e973c01452a0d76c98c5e0d0926","94ec73c5617c177b1d81ddfe04bbff1d08fccecc"],"04f07771a2a7dd3a395700665ed839c3dae2def2":["aba371508186796cc6151d8223a5b4e16d02e26e","d19974432be9aed28ee7dca73bdf01d139e763a9","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7"],"d9e22bdf0692bfa61e342b04a6ac7078670c1e16":["05fe562aa248790944d43cdd478f512572835ba0"],"088a7ef694fd43d5d9a4d200c4005865f773d1e7":["73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0"],"aba371508186796cc6151d8223a5b4e16d02e26e":[],"d19974432be9aed28ee7dca73bdf01d139e763a9":["088a7ef694fd43d5d9a4d200c4005865f773d1e7","aba371508186796cc6151d8223a5b4e16d02e26e","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["98d2deb8c96c79ebef084a1f8e5a1a6c08608f13"],"7e4c214a1f904dde76f5611b56d4081533055b3b":["d9e22bdf0692bfa61e342b04a6ac7078670c1e16"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["54a6bea0b991120a99ad0e2f72ae853fd5ecae0e"],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":[],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"94ec73c5617c177b1d81ddfe04bbff1d08fccecc":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","aba371508186796cc6151d8223a5b4e16d02e26e","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","94ec73c5617c177b1d81ddfe04bbff1d08fccecc","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}