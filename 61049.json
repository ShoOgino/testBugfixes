{"path":"lucene/src/java/org/apache/lucene/search/MultiTermQuery.TopTermsBooleanQueryRewrite#rewrite(IndexReader,MultiTermQuery).mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/MultiTermQuery.TopTermsBooleanQueryRewrite#rewrite(IndexReader,MultiTermQuery).mjava","pathOld":"src/java/org/apache/lucene/search/MultiTermQuery.TopTermsBooleanQueryRewrite#rewrite(IndexReader,MultiTermQuery).mjava","sourceNew":"    @Override\n    public Query rewrite(IndexReader reader, MultiTermQuery query) throws IOException {\n      final int maxSize = Math.min(size, BooleanQuery.getMaxClauseCount());\n      final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n      collectTerms(reader, query, new TermCollector() {\n        public boolean collect(Term t, float boost) {\n          // ignore uncompetetive hits\n          if (stQueue.size() >= maxSize && boost <= stQueue.peek().boost)\n            return true;\n          // add new entry in PQ\n          st.term = t;\n          st.boost = boost;\n          stQueue.offer(st);\n          // possibly drop entries from queue\n          st = (stQueue.size() > maxSize) ? stQueue.poll() : new ScoreTerm();\n          return true;\n        }\n        \n        // reusable instance\n        private ScoreTerm st = new ScoreTerm();\n      });\n      \n      final BooleanQuery bq = new BooleanQuery(true);\n      for (final ScoreTerm st : stQueue) {\n        Query tq = getQuery(st.term);    // found a match\n        tq.setBoost(query.getBoost() * st.boost); // set the boost\n        bq.add(tq, BooleanClause.Occur.SHOULD);   // add to query\n      }\n      query.incTotalNumberOfTerms(bq.clauses().size());\n      return bq;\n    }\n\n","sourceOld":"    @Override\n    public Query rewrite(IndexReader reader, MultiTermQuery query) throws IOException {\n      final int maxSize = Math.min(size, BooleanQuery.getMaxClauseCount());\n      final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n      collectTerms(reader, query, new TermCollector() {\n        public boolean collect(Term t, float boost) {\n          // ignore uncompetetive hits\n          if (stQueue.size() >= maxSize && boost <= stQueue.peek().boost)\n            return true;\n          // add new entry in PQ\n          st.term = t;\n          st.boost = boost;\n          stQueue.offer(st);\n          // possibly drop entries from queue\n          st = (stQueue.size() > maxSize) ? stQueue.poll() : new ScoreTerm();\n          return true;\n        }\n        \n        // reusable instance\n        private ScoreTerm st = new ScoreTerm();\n      });\n      \n      final BooleanQuery bq = new BooleanQuery(true);\n      for (final ScoreTerm st : stQueue) {\n        Query tq = getQuery(st.term);    // found a match\n        tq.setBoost(query.getBoost() * st.boost); // set the boost\n        bq.add(tq, BooleanClause.Occur.SHOULD);   // add to query\n      }\n      query.incTotalNumberOfTerms(bq.clauses().size());\n      return bq;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"955c32f886db6f6356c9fcdea6b1f1cb4effda24","date":1270581567,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/MultiTermQuery.TopTermsBooleanQueryRewrite#rewrite(IndexReader,MultiTermQuery).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/MultiTermQuery.TopTermsBooleanQueryRewrite#rewrite(IndexReader,MultiTermQuery).mjava","sourceNew":"    @Override\n    public Query rewrite(IndexReader reader, MultiTermQuery query) throws IOException {\n      final int maxSize = Math.min(size, BooleanQuery.getMaxClauseCount());\n      final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n      collectTerms(reader, query, new TermCollector() {\n        public boolean collect(Term t, float boost) {\n          // ignore uncompetetive hits\n          if (stQueue.size() >= maxSize && boost <= stQueue.peek().boost)\n            return true;\n          // add new entry in PQ\n          st.term = t;\n          st.boost = boost;\n          stQueue.offer(st);\n          // possibly drop entries from queue\n          st = (stQueue.size() > maxSize) ? stQueue.poll() : new ScoreTerm();\n          setMaxNonCompetitiveBoost((stQueue.size() >= maxSize) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n          return true;\n        }\n        \n        // reusable instance\n        private ScoreTerm st = new ScoreTerm();\n      });\n      \n      final BooleanQuery bq = new BooleanQuery(true);\n      for (final ScoreTerm st : stQueue) {\n        Query tq = getQuery(st.term);    // found a match\n        tq.setBoost(query.getBoost() * st.boost); // set the boost\n        bq.add(tq, BooleanClause.Occur.SHOULD);   // add to query\n      }\n      query.incTotalNumberOfTerms(bq.clauses().size());\n      return bq;\n    }\n\n","sourceOld":"    @Override\n    public Query rewrite(IndexReader reader, MultiTermQuery query) throws IOException {\n      final int maxSize = Math.min(size, BooleanQuery.getMaxClauseCount());\n      final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n      collectTerms(reader, query, new TermCollector() {\n        public boolean collect(Term t, float boost) {\n          // ignore uncompetetive hits\n          if (stQueue.size() >= maxSize && boost <= stQueue.peek().boost)\n            return true;\n          // add new entry in PQ\n          st.term = t;\n          st.boost = boost;\n          stQueue.offer(st);\n          // possibly drop entries from queue\n          st = (stQueue.size() > maxSize) ? stQueue.poll() : new ScoreTerm();\n          return true;\n        }\n        \n        // reusable instance\n        private ScoreTerm st = new ScoreTerm();\n      });\n      \n      final BooleanQuery bq = new BooleanQuery(true);\n      for (final ScoreTerm st : stQueue) {\n        Query tq = getQuery(st.term);    // found a match\n        tq.setBoost(query.getBoost() * st.boost); // set the boost\n        bq.add(tq, BooleanClause.Occur.SHOULD);   // add to query\n      }\n      query.incTotalNumberOfTerms(bq.clauses().size());\n      return bq;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4f29ba80b723649f5feb7e37afe1a558dd2c1304","date":1278318805,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/MultiTermQuery.TopTermsBooleanQueryRewrite#rewrite(IndexReader,MultiTermQuery).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/MultiTermQuery.TopTermsBooleanQueryRewrite#rewrite(IndexReader,MultiTermQuery).mjava","sourceNew":"    @Override\n    public Query rewrite(final IndexReader reader, final MultiTermQuery query) throws IOException {\n      final int maxSize = Math.min(size, BooleanQuery.getMaxClauseCount());\n      final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n      collectTerms(reader, query, new TermCollector() {\n        public boolean collect(BytesRef bytes, float boost) {\n          // ignore uncompetetive hits\n          if (stQueue.size() >= maxSize && boost <= stQueue.peek().boost)\n            return true;\n          // add new entry in PQ, we must clone the term, else it may get overwritten!\n          st.bytes.copy(bytes);\n          st.boost = boost;\n          stQueue.offer(st);\n          // possibly drop entries from queue\n          st = (stQueue.size() > maxSize) ? stQueue.poll() : new ScoreTerm();\n          setMaxNonCompetitiveBoost((stQueue.size() >= maxSize) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n          return true;\n        }\n        \n        // reusable instance\n        private ScoreTerm st = new ScoreTerm();\n      });\n      \n      final Term placeholderTerm = new Term(query.field);\n      final BooleanQuery bq = new BooleanQuery(true);\n      for (final ScoreTerm st : stQueue) {\n        // add new query, we must clone the term, else it may get overwritten!\n        Query tq = getQuery(placeholderTerm.createTerm(st.bytes));\n        tq.setBoost(query.getBoost() * st.boost); // set the boost\n        bq.add(tq, BooleanClause.Occur.SHOULD);   // add to query\n      }\n      query.incTotalNumberOfTerms(bq.clauses().size());\n      return bq;\n    }\n\n","sourceOld":"    @Override\n    public Query rewrite(IndexReader reader, MultiTermQuery query) throws IOException {\n      final int maxSize = Math.min(size, BooleanQuery.getMaxClauseCount());\n      final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n      collectTerms(reader, query, new TermCollector() {\n        public boolean collect(Term t, float boost) {\n          // ignore uncompetetive hits\n          if (stQueue.size() >= maxSize && boost <= stQueue.peek().boost)\n            return true;\n          // add new entry in PQ\n          st.term = t;\n          st.boost = boost;\n          stQueue.offer(st);\n          // possibly drop entries from queue\n          st = (stQueue.size() > maxSize) ? stQueue.poll() : new ScoreTerm();\n          setMaxNonCompetitiveBoost((stQueue.size() >= maxSize) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n          return true;\n        }\n        \n        // reusable instance\n        private ScoreTerm st = new ScoreTerm();\n      });\n      \n      final BooleanQuery bq = new BooleanQuery(true);\n      for (final ScoreTerm st : stQueue) {\n        Query tq = getQuery(st.term);    // found a match\n        tq.setBoost(query.getBoost() * st.boost); // set the boost\n        bq.add(tq, BooleanClause.Occur.SHOULD);   // add to query\n      }\n      query.incTotalNumberOfTerms(bq.clauses().size());\n      return bq;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5f4e87790277826a2aea119328600dfb07761f32","date":1279827275,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/MultiTermQuery.TopTermsBooleanQueryRewrite#rewrite(IndexReader,MultiTermQuery).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/MultiTermQuery.TopTermsBooleanQueryRewrite#rewrite(IndexReader,MultiTermQuery).mjava","sourceNew":"    @Override\n    public Query rewrite(final IndexReader reader, final MultiTermQuery query) throws IOException {\n      final int maxSize = Math.min(size, BooleanQuery.getMaxClauseCount());\n      final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n      collectTerms(reader, query, new TermCollector() {\n        public boolean collect(BytesRef bytes, float boost) {\n          // ignore uncompetetive hits\n          if (stQueue.size() >= maxSize && boost <= stQueue.peek().boost)\n            return true;\n          // add new entry in PQ, we must clone the term, else it may get overwritten!\n          st.bytes.copy(bytes);\n          st.boost = boost;\n          stQueue.offer(st);\n          // possibly drop entries from queue\n          st = (stQueue.size() > maxSize) ? stQueue.poll() : new ScoreTerm();\n          setMaxNonCompetitiveBoost((stQueue.size() >= maxSize) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n          return true;\n        }\n        \n        // reusable instance\n        private ScoreTerm st = new ScoreTerm();\n      });\n      \n      final Term placeholderTerm = new Term(query.field);\n      final BooleanQuery bq = new BooleanQuery(true);\n      for (final ScoreTerm st : stQueue) {\n        // add new query, we must clone the term, else it may get overwritten!\n        Query tq = getQuery(placeholderTerm.createTerm(st.bytes));\n        tq.setBoost(query.getBoost() * st.boost); // set the boost\n        bq.add(tq, BooleanClause.Occur.SHOULD);   // add to query\n      }\n      query.incTotalNumberOfTerms(bq.clauses().size());\n      return bq;\n    }\n\n","sourceOld":"    @Override\n    public Query rewrite(IndexReader reader, MultiTermQuery query) throws IOException {\n      final int maxSize = Math.min(size, BooleanQuery.getMaxClauseCount());\n      final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n      collectTerms(reader, query, new TermCollector() {\n        public boolean collect(Term t, float boost) {\n          // ignore uncompetetive hits\n          if (stQueue.size() >= maxSize && boost <= stQueue.peek().boost)\n            return true;\n          // add new entry in PQ\n          st.term = t;\n          st.boost = boost;\n          stQueue.offer(st);\n          // possibly drop entries from queue\n          st = (stQueue.size() > maxSize) ? stQueue.poll() : new ScoreTerm();\n          setMaxNonCompetitiveBoost((stQueue.size() >= maxSize) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n          return true;\n        }\n        \n        // reusable instance\n        private ScoreTerm st = new ScoreTerm();\n      });\n      \n      final BooleanQuery bq = new BooleanQuery(true);\n      for (final ScoreTerm st : stQueue) {\n        Query tq = getQuery(st.term);    // found a match\n        tq.setBoost(query.getBoost() * st.boost); // set the boost\n        bq.add(tq, BooleanClause.Occur.SHOULD);   // add to query\n      }\n      query.incTotalNumberOfTerms(bq.clauses().size());\n      return bq;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"825bcb488bc228d1fb6a19c1f441a2181f7d766d","date":1285691504,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/MultiTermQuery.TopTermsBooleanQueryRewrite#rewrite(IndexReader,MultiTermQuery).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/MultiTermQuery.TopTermsBooleanQueryRewrite#rewrite(IndexReader,MultiTermQuery).mjava","sourceNew":"    @Override\n    public Query rewrite(final IndexReader reader, final MultiTermQuery query) throws IOException {\n      final int maxSize = Math.min(size, BooleanQuery.getMaxClauseCount());\n      final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n      collectTerms(reader, query, new TermCollector() {\n        @Override\n        public boolean collect(TermsEnum termsEnum, BytesRef bytes, float boost) {\n          // ignore uncompetetive hits\n          if (stQueue.size() >= maxSize && boost <= stQueue.peek().boost)\n            return true;\n          // add new entry in PQ, we must clone the term, else it may get overwritten!\n          st.bytes.copy(bytes);\n          st.boost = boost;\n          st.docFreq = termsEnum.docFreq();\n          stQueue.offer(st);\n          // possibly drop entries from queue\n          st = (stQueue.size() > maxSize) ? stQueue.poll() : new ScoreTerm();\n          setMaxNonCompetitiveBoost((stQueue.size() >= maxSize) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n          return true;\n        }\n        \n        // reusable instance\n        private ScoreTerm st = new ScoreTerm();\n      });\n      \n      final Term placeholderTerm = new Term(query.field);\n      final BooleanQuery bq = new BooleanQuery(true);\n      for (final ScoreTerm st : stQueue) {\n        // add new query, we must clone the term, else it may get overwritten!\n        Query tq = getQuery(placeholderTerm.createTerm(st.bytes), st.docFreq);\n        tq.setBoost(query.getBoost() * st.boost); // set the boost\n        bq.add(tq, BooleanClause.Occur.SHOULD);   // add to query\n      }\n      query.incTotalNumberOfTerms(bq.clauses().size());\n      return bq;\n    }\n\n","sourceOld":"    @Override\n    public Query rewrite(final IndexReader reader, final MultiTermQuery query) throws IOException {\n      final int maxSize = Math.min(size, BooleanQuery.getMaxClauseCount());\n      final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n      collectTerms(reader, query, new TermCollector() {\n        public boolean collect(BytesRef bytes, float boost) {\n          // ignore uncompetetive hits\n          if (stQueue.size() >= maxSize && boost <= stQueue.peek().boost)\n            return true;\n          // add new entry in PQ, we must clone the term, else it may get overwritten!\n          st.bytes.copy(bytes);\n          st.boost = boost;\n          stQueue.offer(st);\n          // possibly drop entries from queue\n          st = (stQueue.size() > maxSize) ? stQueue.poll() : new ScoreTerm();\n          setMaxNonCompetitiveBoost((stQueue.size() >= maxSize) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n          return true;\n        }\n        \n        // reusable instance\n        private ScoreTerm st = new ScoreTerm();\n      });\n      \n      final Term placeholderTerm = new Term(query.field);\n      final BooleanQuery bq = new BooleanQuery(true);\n      for (final ScoreTerm st : stQueue) {\n        // add new query, we must clone the term, else it may get overwritten!\n        Query tq = getQuery(placeholderTerm.createTerm(st.bytes));\n        tq.setBoost(query.getBoost() * st.boost); // set the boost\n        bq.add(tq, BooleanClause.Occur.SHOULD);   // add to query\n      }\n      query.incTotalNumberOfTerms(bq.clauses().size());\n      return bq;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"33a8b1f99104f4144f210f5d068411c297cd7163","date":1287152748,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/MultiTermQuery.TopTermsBooleanQueryRewrite#rewrite(IndexReader,MultiTermQuery).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/MultiTermQuery.TopTermsBooleanQueryRewrite#rewrite(IndexReader,MultiTermQuery).mjava","sourceNew":"    @Override\n    public Query rewrite(final IndexReader reader, final MultiTermQuery query) throws IOException {\n      final int maxSize = Math.min(size, BooleanQuery.getMaxClauseCount());\n      final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n      collectTerms(reader, query, new TermCollector() {\n        private final MaxNonCompetitiveBoostAttribute maxBoostAtt =\n          attributes.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n        \n        private final Map<BytesRef,ScoreTerm> visitedTerms = new HashMap<BytesRef,ScoreTerm>();\n        \n        private TermsEnum termsEnum;\n        private Comparator<BytesRef> termComp;\n        private BoostAttribute boostAtt;        \n        private ScoreTerm st;\n        \n        @Override\n        public void setNextEnum(TermsEnum termsEnum) throws IOException {\n          this.termsEnum = termsEnum;\n          this.termComp = termsEnum.getComparator();\n          // lazy init the initial ScoreTerm because comparator is not known on ctor:\n          if (st == null)\n            st = new ScoreTerm(this.termComp);\n          boostAtt = termsEnum.attributes().addAttribute(BoostAttribute.class);\n        }\n      \n        @Override\n        public boolean collect(BytesRef bytes) {\n          final float boost = boostAtt.getBoost();\n          // ignore uncompetetive hits\n          if (stQueue.size() == maxSize) {\n            final ScoreTerm t = stQueue.peek();\n            if (boost < t.boost)\n              return true;\n            if (boost == t.boost && termComp.compare(bytes, t.bytes) > 0)\n              return true;\n          }\n          ScoreTerm t = visitedTerms.get(bytes);\n          if (t != null) {\n            // if the term is already in the PQ, only update docFreq of term in PQ\n            t.docFreq += termsEnum.docFreq();\n            assert t.boost == boost : \"boost should be equal in all segment TermsEnums\";\n          } else {\n            // add new entry in PQ, we must clone the term, else it may get overwritten!\n            st.bytes.copy(bytes);\n            st.boost = boost;\n            st.docFreq = termsEnum.docFreq();\n            visitedTerms.put(st.bytes, st);\n            stQueue.offer(st);\n            // possibly drop entries from queue\n            if (stQueue.size() > maxSize) {\n              st = stQueue.poll();\n              visitedTerms.remove(st.bytes);\n            } else {\n              st = new ScoreTerm(termComp);\n            }\n            assert stQueue.size() <= maxSize : \"the PQ size must be limited to maxSize\";\n            // set maxBoostAtt with values to help FuzzyTermsEnum to optimize\n            if (stQueue.size() == maxSize) {\n              t = stQueue.peek();\n              maxBoostAtt.setMaxNonCompetitiveBoost(t.boost);\n              maxBoostAtt.setCompetitiveTerm(t.bytes);\n            }\n          }\n          return true;\n        }\n      });\n      \n      final Term placeholderTerm = new Term(query.field);\n      final BooleanQuery bq = new BooleanQuery(true);\n      final ScoreTerm[] scoreTerms = stQueue.toArray(new ScoreTerm[stQueue.size()]);\n      Arrays.sort(scoreTerms, new Comparator<ScoreTerm>() {\n        public int compare(ScoreTerm st1, ScoreTerm st2) {\n          assert st1.termComp == st2.termComp :\n            \"term comparator should not change between segments\";\n          return st1.termComp.compare(st1.bytes, st2.bytes);\n        }\n      });\n      for (final ScoreTerm st : scoreTerms) {\n        final Term term = placeholderTerm.createTerm(st.bytes);\n        assert reader.docFreq(term) == st.docFreq;\n        Query tq = getQuery(term, st.docFreq);\n        tq.setBoost(query.getBoost() * st.boost); // set the boost\n        bq.add(tq, BooleanClause.Occur.SHOULD);   // add to query\n      }\n      query.incTotalNumberOfTerms(scoreTerms.length);\n      return bq;\n    }\n\n","sourceOld":"    @Override\n    public Query rewrite(final IndexReader reader, final MultiTermQuery query) throws IOException {\n      final int maxSize = Math.min(size, BooleanQuery.getMaxClauseCount());\n      final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n      collectTerms(reader, query, new TermCollector() {\n        @Override\n        public boolean collect(TermsEnum termsEnum, BytesRef bytes, float boost) {\n          // ignore uncompetetive hits\n          if (stQueue.size() >= maxSize && boost <= stQueue.peek().boost)\n            return true;\n          // add new entry in PQ, we must clone the term, else it may get overwritten!\n          st.bytes.copy(bytes);\n          st.boost = boost;\n          st.docFreq = termsEnum.docFreq();\n          stQueue.offer(st);\n          // possibly drop entries from queue\n          st = (stQueue.size() > maxSize) ? stQueue.poll() : new ScoreTerm();\n          setMaxNonCompetitiveBoost((stQueue.size() >= maxSize) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n          return true;\n        }\n        \n        // reusable instance\n        private ScoreTerm st = new ScoreTerm();\n      });\n      \n      final Term placeholderTerm = new Term(query.field);\n      final BooleanQuery bq = new BooleanQuery(true);\n      for (final ScoreTerm st : stQueue) {\n        // add new query, we must clone the term, else it may get overwritten!\n        Query tq = getQuery(placeholderTerm.createTerm(st.bytes), st.docFreq);\n        tq.setBoost(query.getBoost() * st.boost); // set the boost\n        bq.add(tq, BooleanClause.Occur.SHOULD);   // add to query\n      }\n      query.incTotalNumberOfTerms(bq.clauses().size());\n      return bq;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4ecea1664e8617d82eca3b8055a3c37cb4da8511","date":1287578668,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/MultiTermQuery.TopTermsBooleanQueryRewrite#rewrite(IndexReader,MultiTermQuery).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/MultiTermQuery.TopTermsBooleanQueryRewrite#rewrite(IndexReader,MultiTermQuery).mjava","sourceNew":"    @Override\n    public Query rewrite(final IndexReader reader, final MultiTermQuery query) throws IOException {\n      final int maxSize = Math.min(size, BooleanQuery.getMaxClauseCount());\n      final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n      collectTerms(reader, query, new TermCollector() {\n        private final MaxNonCompetitiveBoostAttribute maxBoostAtt =\n          attributes.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n        \n        private final Map<BytesRef,ScoreTerm> visitedTerms = new HashMap<BytesRef,ScoreTerm>();\n        \n        private TermsEnum termsEnum;\n        private Comparator<BytesRef> termComp;\n        private BoostAttribute boostAtt;        \n        private ScoreTerm st;\n        \n        @Override\n        public void setNextEnum(TermsEnum termsEnum) throws IOException {\n          this.termsEnum = termsEnum;\n          this.termComp = termsEnum.getComparator();\n          // lazy init the initial ScoreTerm because comparator is not known on ctor:\n          if (st == null)\n            st = new ScoreTerm(this.termComp);\n          boostAtt = termsEnum.attributes().addAttribute(BoostAttribute.class);\n        }\n      \n        @Override\n        public boolean collect(BytesRef bytes) {\n          final float boost = boostAtt.getBoost();\n          // ignore uncompetetive hits\n          if (stQueue.size() == maxSize) {\n            final ScoreTerm t = stQueue.peek();\n            if (boost < t.boost)\n              return true;\n            if (boost == t.boost && termComp.compare(bytes, t.bytes) > 0)\n              return true;\n          }\n          ScoreTerm t = visitedTerms.get(bytes);\n          if (t != null) {\n            // if the term is already in the PQ, only update docFreq of term in PQ\n            t.docFreq += termsEnum.docFreq();\n            assert t.boost == boost : \"boost should be equal in all segment TermsEnums\";\n          } else {\n            // add new entry in PQ, we must clone the term, else it may get overwritten!\n            st.bytes.copy(bytes);\n            st.boost = boost;\n            st.docFreq = termsEnum.docFreq();\n            visitedTerms.put(st.bytes, st);\n            stQueue.offer(st);\n            // possibly drop entries from queue\n            if (stQueue.size() > maxSize) {\n              st = stQueue.poll();\n              visitedTerms.remove(st.bytes);\n            } else {\n              st = new ScoreTerm(termComp);\n            }\n            assert stQueue.size() <= maxSize : \"the PQ size must be limited to maxSize\";\n            // set maxBoostAtt with values to help FuzzyTermsEnum to optimize\n            if (stQueue.size() == maxSize) {\n              t = stQueue.peek();\n              maxBoostAtt.setMaxNonCompetitiveBoost(t.boost);\n              maxBoostAtt.setCompetitiveTerm(t.bytes);\n            }\n          }\n          return true;\n        }\n      });\n      \n      final Term placeholderTerm = new Term(query.field);\n      final BooleanQuery bq = new BooleanQuery(true);\n      final ScoreTerm[] scoreTerms = stQueue.toArray(new ScoreTerm[stQueue.size()]);\n      Arrays.sort(scoreTerms, new Comparator<ScoreTerm>() {\n        public int compare(ScoreTerm st1, ScoreTerm st2) {\n          assert st1.termComp == st2.termComp :\n            \"term comparator should not change between segments\";\n          return st1.termComp.compare(st1.bytes, st2.bytes);\n        }\n      });\n      for (final ScoreTerm st : scoreTerms) {\n        final Term term = placeholderTerm.createTerm(st.bytes);\n        assert reader.docFreq(term) == st.docFreq;\n        Query tq = getQuery(term, st.docFreq);\n        tq.setBoost(query.getBoost() * st.boost); // set the boost\n        bq.add(tq, BooleanClause.Occur.SHOULD);   // add to query\n      }\n      query.incTotalNumberOfTerms(scoreTerms.length);\n      return bq;\n    }\n\n","sourceOld":"    @Override\n    public Query rewrite(final IndexReader reader, final MultiTermQuery query) throws IOException {\n      final int maxSize = Math.min(size, BooleanQuery.getMaxClauseCount());\n      final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n      collectTerms(reader, query, new TermCollector() {\n        @Override\n        public boolean collect(TermsEnum termsEnum, BytesRef bytes, float boost) {\n          // ignore uncompetetive hits\n          if (stQueue.size() >= maxSize && boost <= stQueue.peek().boost)\n            return true;\n          // add new entry in PQ, we must clone the term, else it may get overwritten!\n          st.bytes.copy(bytes);\n          st.boost = boost;\n          st.docFreq = termsEnum.docFreq();\n          stQueue.offer(st);\n          // possibly drop entries from queue\n          st = (stQueue.size() > maxSize) ? stQueue.poll() : new ScoreTerm();\n          setMaxNonCompetitiveBoost((stQueue.size() >= maxSize) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n          return true;\n        }\n        \n        // reusable instance\n        private ScoreTerm st = new ScoreTerm();\n      });\n      \n      final Term placeholderTerm = new Term(query.field);\n      final BooleanQuery bq = new BooleanQuery(true);\n      for (final ScoreTerm st : stQueue) {\n        // add new query, we must clone the term, else it may get overwritten!\n        Query tq = getQuery(placeholderTerm.createTerm(st.bytes), st.docFreq);\n        tq.setBoost(query.getBoost() * st.boost); // set the boost\n        bq.add(tq, BooleanClause.Occur.SHOULD);   // add to query\n      }\n      query.incTotalNumberOfTerms(bq.clauses().size());\n      return bq;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae7aa98ce0c64f3b2b81087d14ff9ae992b4903b","date":1288192616,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/MultiTermQuery.TopTermsBooleanQueryRewrite#rewrite(IndexReader,MultiTermQuery).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/MultiTermQuery.TopTermsBooleanQueryRewrite#rewrite(IndexReader,MultiTermQuery).mjava","sourceNew":"    @Override\n    public Query rewrite(final IndexReader reader, final MultiTermQuery query) throws IOException {\n      final int maxSize = Math.min(size, BooleanQuery.getMaxClauseCount());\n      final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n      collectTerms(reader, query, new TermCollector() {\n        private final MaxNonCompetitiveBoostAttribute maxBoostAtt =\n          attributes.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n        \n        private final Map<BytesRef,ScoreTerm> visitedTerms = new HashMap<BytesRef,ScoreTerm>();\n        \n        private TermsEnum termsEnum;\n        private Comparator<BytesRef> termComp;\n        private BoostAttribute boostAtt;        \n        private ScoreTerm st;\n        \n        @Override\n        public void setNextEnum(TermsEnum termsEnum) throws IOException {\n          this.termsEnum = termsEnum;\n          this.termComp = termsEnum.getComparator();\n          // lazy init the initial ScoreTerm because comparator is not known on ctor:\n          if (st == null)\n            st = new ScoreTerm(this.termComp);\n          boostAtt = termsEnum.attributes().addAttribute(BoostAttribute.class);\n        }\n      \n        @Override\n        public boolean collect(BytesRef bytes) {\n          final float boost = boostAtt.getBoost();\n          // ignore uncompetetive hits\n          if (stQueue.size() == maxSize) {\n            final ScoreTerm t = stQueue.peek();\n            if (boost < t.boost)\n              return true;\n            if (boost == t.boost && termComp.compare(bytes, t.bytes) > 0)\n              return true;\n          }\n          ScoreTerm t = visitedTerms.get(bytes);\n          if (t != null) {\n            // if the term is already in the PQ, only update docFreq of term in PQ\n            t.docFreq += termsEnum.docFreq();\n            assert t.boost == boost : \"boost should be equal in all segment TermsEnums\";\n          } else {\n            // add new entry in PQ, we must clone the term, else it may get overwritten!\n            st.bytes.copy(bytes);\n            st.boost = boost;\n            st.docFreq = termsEnum.docFreq();\n            visitedTerms.put(st.bytes, st);\n            stQueue.offer(st);\n            // possibly drop entries from queue\n            if (stQueue.size() > maxSize) {\n              st = stQueue.poll();\n              visitedTerms.remove(st.bytes);\n            } else {\n              st = new ScoreTerm(termComp);\n            }\n            assert stQueue.size() <= maxSize : \"the PQ size must be limited to maxSize\";\n            // set maxBoostAtt with values to help FuzzyTermsEnum to optimize\n            if (stQueue.size() == maxSize) {\n              t = stQueue.peek();\n              maxBoostAtt.setMaxNonCompetitiveBoost(t.boost);\n              maxBoostAtt.setCompetitiveTerm(t.bytes);\n            }\n          }\n          return true;\n        }\n      });\n      \n      final Term placeholderTerm = new Term(query.field);\n      final BooleanQuery bq = new BooleanQuery(true);\n      final ScoreTerm[] scoreTerms = stQueue.toArray(new ScoreTerm[stQueue.size()]);\n      ArrayUtil.quickSort(scoreTerms, scoreTermSortByTermComp);\n      for (final ScoreTerm st : scoreTerms) {\n        final Term term = placeholderTerm.createTerm(st.bytes);\n        assert reader.docFreq(term) == st.docFreq;\n        Query tq = getQuery(term, st.docFreq);\n        tq.setBoost(query.getBoost() * st.boost); // set the boost\n        bq.add(tq, BooleanClause.Occur.SHOULD);   // add to query\n      }\n      query.incTotalNumberOfTerms(scoreTerms.length);\n      return bq;\n    }\n\n","sourceOld":"    @Override\n    public Query rewrite(final IndexReader reader, final MultiTermQuery query) throws IOException {\n      final int maxSize = Math.min(size, BooleanQuery.getMaxClauseCount());\n      final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n      collectTerms(reader, query, new TermCollector() {\n        private final MaxNonCompetitiveBoostAttribute maxBoostAtt =\n          attributes.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n        \n        private final Map<BytesRef,ScoreTerm> visitedTerms = new HashMap<BytesRef,ScoreTerm>();\n        \n        private TermsEnum termsEnum;\n        private Comparator<BytesRef> termComp;\n        private BoostAttribute boostAtt;        \n        private ScoreTerm st;\n        \n        @Override\n        public void setNextEnum(TermsEnum termsEnum) throws IOException {\n          this.termsEnum = termsEnum;\n          this.termComp = termsEnum.getComparator();\n          // lazy init the initial ScoreTerm because comparator is not known on ctor:\n          if (st == null)\n            st = new ScoreTerm(this.termComp);\n          boostAtt = termsEnum.attributes().addAttribute(BoostAttribute.class);\n        }\n      \n        @Override\n        public boolean collect(BytesRef bytes) {\n          final float boost = boostAtt.getBoost();\n          // ignore uncompetetive hits\n          if (stQueue.size() == maxSize) {\n            final ScoreTerm t = stQueue.peek();\n            if (boost < t.boost)\n              return true;\n            if (boost == t.boost && termComp.compare(bytes, t.bytes) > 0)\n              return true;\n          }\n          ScoreTerm t = visitedTerms.get(bytes);\n          if (t != null) {\n            // if the term is already in the PQ, only update docFreq of term in PQ\n            t.docFreq += termsEnum.docFreq();\n            assert t.boost == boost : \"boost should be equal in all segment TermsEnums\";\n          } else {\n            // add new entry in PQ, we must clone the term, else it may get overwritten!\n            st.bytes.copy(bytes);\n            st.boost = boost;\n            st.docFreq = termsEnum.docFreq();\n            visitedTerms.put(st.bytes, st);\n            stQueue.offer(st);\n            // possibly drop entries from queue\n            if (stQueue.size() > maxSize) {\n              st = stQueue.poll();\n              visitedTerms.remove(st.bytes);\n            } else {\n              st = new ScoreTerm(termComp);\n            }\n            assert stQueue.size() <= maxSize : \"the PQ size must be limited to maxSize\";\n            // set maxBoostAtt with values to help FuzzyTermsEnum to optimize\n            if (stQueue.size() == maxSize) {\n              t = stQueue.peek();\n              maxBoostAtt.setMaxNonCompetitiveBoost(t.boost);\n              maxBoostAtt.setCompetitiveTerm(t.bytes);\n            }\n          }\n          return true;\n        }\n      });\n      \n      final Term placeholderTerm = new Term(query.field);\n      final BooleanQuery bq = new BooleanQuery(true);\n      final ScoreTerm[] scoreTerms = stQueue.toArray(new ScoreTerm[stQueue.size()]);\n      Arrays.sort(scoreTerms, new Comparator<ScoreTerm>() {\n        public int compare(ScoreTerm st1, ScoreTerm st2) {\n          assert st1.termComp == st2.termComp :\n            \"term comparator should not change between segments\";\n          return st1.termComp.compare(st1.bytes, st2.bytes);\n        }\n      });\n      for (final ScoreTerm st : scoreTerms) {\n        final Term term = placeholderTerm.createTerm(st.bytes);\n        assert reader.docFreq(term) == st.docFreq;\n        Query tq = getQuery(term, st.docFreq);\n        tq.setBoost(query.getBoost() * st.boost); // set the boost\n        bq.add(tq, BooleanClause.Occur.SHOULD);   // add to query\n      }\n      query.incTotalNumberOfTerms(scoreTerms.length);\n      return bq;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ca0ffea399542e8aac8ed7608f34f8ec4cb8904d","date":1288424244,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/MultiTermQuery.TopTermsBooleanQueryRewrite#rewrite(IndexReader,MultiTermQuery).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/MultiTermQuery.TopTermsBooleanQueryRewrite#rewrite(IndexReader,MultiTermQuery).mjava","sourceNew":"    @Override\n    public Query rewrite(final IndexReader reader, final MultiTermQuery query) throws IOException {\n      final int maxSize = Math.min(size, BooleanQuery.getMaxClauseCount());\n      final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n      collectTerms(reader, query, new TermCollector() {\n        private final MaxNonCompetitiveBoostAttribute maxBoostAtt =\n          attributes.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n        \n        private final Map<BytesRef,ScoreTerm> visitedTerms = new HashMap<BytesRef,ScoreTerm>();\n        \n        private TermsEnum termsEnum;\n        private Comparator<BytesRef> termComp;\n        private BoostAttribute boostAtt;        \n        private ScoreTerm st;\n        \n        @Override\n        public void setNextEnum(TermsEnum termsEnum) throws IOException {\n          this.termsEnum = termsEnum;\n          this.termComp = termsEnum.getComparator();\n          // lazy init the initial ScoreTerm because comparator is not known on ctor:\n          if (st == null)\n            st = new ScoreTerm(this.termComp);\n          boostAtt = termsEnum.attributes().addAttribute(BoostAttribute.class);\n        }\n      \n        @Override\n        public boolean collect(BytesRef bytes) {\n          final float boost = boostAtt.getBoost();\n          // ignore uncompetetive hits\n          if (stQueue.size() == maxSize) {\n            final ScoreTerm t = stQueue.peek();\n            if (boost < t.boost)\n              return true;\n            if (boost == t.boost && termComp.compare(bytes, t.bytes) > 0)\n              return true;\n          }\n          ScoreTerm t = visitedTerms.get(bytes);\n          if (t != null) {\n            // if the term is already in the PQ, only update docFreq of term in PQ\n            t.docFreq += termsEnum.docFreq();\n            assert t.boost == boost : \"boost should be equal in all segment TermsEnums\";\n          } else {\n            // add new entry in PQ, we must clone the term, else it may get overwritten!\n            st.bytes.copy(bytes);\n            st.boost = boost;\n            st.docFreq = termsEnum.docFreq();\n            visitedTerms.put(st.bytes, st);\n            stQueue.offer(st);\n            // possibly drop entries from queue\n            if (stQueue.size() > maxSize) {\n              st = stQueue.poll();\n              visitedTerms.remove(st.bytes);\n            } else {\n              st = new ScoreTerm(termComp);\n            }\n            assert stQueue.size() <= maxSize : \"the PQ size must be limited to maxSize\";\n            // set maxBoostAtt with values to help FuzzyTermsEnum to optimize\n            if (stQueue.size() == maxSize) {\n              t = stQueue.peek();\n              maxBoostAtt.setMaxNonCompetitiveBoost(t.boost);\n              maxBoostAtt.setCompetitiveTerm(t.bytes);\n            }\n          }\n          return true;\n        }\n      });\n      \n      final Term placeholderTerm = new Term(query.field);\n      final BooleanQuery bq = new BooleanQuery(true);\n      final ScoreTerm[] scoreTerms = stQueue.toArray(new ScoreTerm[stQueue.size()]);\n      ArrayUtil.quickSort(scoreTerms, scoreTermSortByTermComp);\n      for (final ScoreTerm st : scoreTerms) {\n        final Term term = placeholderTerm.createTerm(st.bytes);\n        assert reader.docFreq(term) == st.docFreq;\n        Query tq = getQuery(term, st.docFreq);\n        tq.setBoost(query.getBoost() * st.boost); // set the boost\n        bq.add(tq, BooleanClause.Occur.SHOULD);   // add to query\n      }\n      query.incTotalNumberOfTerms(scoreTerms.length);\n      return bq;\n    }\n\n","sourceOld":"    @Override\n    public Query rewrite(final IndexReader reader, final MultiTermQuery query) throws IOException {\n      final int maxSize = Math.min(size, BooleanQuery.getMaxClauseCount());\n      final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n      collectTerms(reader, query, new TermCollector() {\n        private final MaxNonCompetitiveBoostAttribute maxBoostAtt =\n          attributes.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n        \n        private final Map<BytesRef,ScoreTerm> visitedTerms = new HashMap<BytesRef,ScoreTerm>();\n        \n        private TermsEnum termsEnum;\n        private Comparator<BytesRef> termComp;\n        private BoostAttribute boostAtt;        \n        private ScoreTerm st;\n        \n        @Override\n        public void setNextEnum(TermsEnum termsEnum) throws IOException {\n          this.termsEnum = termsEnum;\n          this.termComp = termsEnum.getComparator();\n          // lazy init the initial ScoreTerm because comparator is not known on ctor:\n          if (st == null)\n            st = new ScoreTerm(this.termComp);\n          boostAtt = termsEnum.attributes().addAttribute(BoostAttribute.class);\n        }\n      \n        @Override\n        public boolean collect(BytesRef bytes) {\n          final float boost = boostAtt.getBoost();\n          // ignore uncompetetive hits\n          if (stQueue.size() == maxSize) {\n            final ScoreTerm t = stQueue.peek();\n            if (boost < t.boost)\n              return true;\n            if (boost == t.boost && termComp.compare(bytes, t.bytes) > 0)\n              return true;\n          }\n          ScoreTerm t = visitedTerms.get(bytes);\n          if (t != null) {\n            // if the term is already in the PQ, only update docFreq of term in PQ\n            t.docFreq += termsEnum.docFreq();\n            assert t.boost == boost : \"boost should be equal in all segment TermsEnums\";\n          } else {\n            // add new entry in PQ, we must clone the term, else it may get overwritten!\n            st.bytes.copy(bytes);\n            st.boost = boost;\n            st.docFreq = termsEnum.docFreq();\n            visitedTerms.put(st.bytes, st);\n            stQueue.offer(st);\n            // possibly drop entries from queue\n            if (stQueue.size() > maxSize) {\n              st = stQueue.poll();\n              visitedTerms.remove(st.bytes);\n            } else {\n              st = new ScoreTerm(termComp);\n            }\n            assert stQueue.size() <= maxSize : \"the PQ size must be limited to maxSize\";\n            // set maxBoostAtt with values to help FuzzyTermsEnum to optimize\n            if (stQueue.size() == maxSize) {\n              t = stQueue.peek();\n              maxBoostAtt.setMaxNonCompetitiveBoost(t.boost);\n              maxBoostAtt.setCompetitiveTerm(t.bytes);\n            }\n          }\n          return true;\n        }\n      });\n      \n      final Term placeholderTerm = new Term(query.field);\n      final BooleanQuery bq = new BooleanQuery(true);\n      final ScoreTerm[] scoreTerms = stQueue.toArray(new ScoreTerm[stQueue.size()]);\n      Arrays.sort(scoreTerms, new Comparator<ScoreTerm>() {\n        public int compare(ScoreTerm st1, ScoreTerm st2) {\n          assert st1.termComp == st2.termComp :\n            \"term comparator should not change between segments\";\n          return st1.termComp.compare(st1.bytes, st2.bytes);\n        }\n      });\n      for (final ScoreTerm st : scoreTerms) {\n        final Term term = placeholderTerm.createTerm(st.bytes);\n        assert reader.docFreq(term) == st.docFreq;\n        Query tq = getQuery(term, st.docFreq);\n        tq.setBoost(query.getBoost() * st.boost); // set the boost\n        bq.add(tq, BooleanClause.Occur.SHOULD);   // add to query\n      }\n      query.incTotalNumberOfTerms(scoreTerms.length);\n      return bq;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"744486748bc5bee772100e49230e5bca39bac99a","date":1289776426,"type":4,"author":"Uwe Schindler","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/search/MultiTermQuery.TopTermsBooleanQueryRewrite#rewrite(IndexReader,MultiTermQuery).mjava","sourceNew":null,"sourceOld":"    @Override\n    public Query rewrite(final IndexReader reader, final MultiTermQuery query) throws IOException {\n      final int maxSize = Math.min(size, BooleanQuery.getMaxClauseCount());\n      final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n      collectTerms(reader, query, new TermCollector() {\n        private final MaxNonCompetitiveBoostAttribute maxBoostAtt =\n          attributes.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n        \n        private final Map<BytesRef,ScoreTerm> visitedTerms = new HashMap<BytesRef,ScoreTerm>();\n        \n        private TermsEnum termsEnum;\n        private Comparator<BytesRef> termComp;\n        private BoostAttribute boostAtt;        \n        private ScoreTerm st;\n        \n        @Override\n        public void setNextEnum(TermsEnum termsEnum) throws IOException {\n          this.termsEnum = termsEnum;\n          this.termComp = termsEnum.getComparator();\n          // lazy init the initial ScoreTerm because comparator is not known on ctor:\n          if (st == null)\n            st = new ScoreTerm(this.termComp);\n          boostAtt = termsEnum.attributes().addAttribute(BoostAttribute.class);\n        }\n      \n        @Override\n        public boolean collect(BytesRef bytes) {\n          final float boost = boostAtt.getBoost();\n          // ignore uncompetetive hits\n          if (stQueue.size() == maxSize) {\n            final ScoreTerm t = stQueue.peek();\n            if (boost < t.boost)\n              return true;\n            if (boost == t.boost && termComp.compare(bytes, t.bytes) > 0)\n              return true;\n          }\n          ScoreTerm t = visitedTerms.get(bytes);\n          if (t != null) {\n            // if the term is already in the PQ, only update docFreq of term in PQ\n            t.docFreq += termsEnum.docFreq();\n            assert t.boost == boost : \"boost should be equal in all segment TermsEnums\";\n          } else {\n            // add new entry in PQ, we must clone the term, else it may get overwritten!\n            st.bytes.copy(bytes);\n            st.boost = boost;\n            st.docFreq = termsEnum.docFreq();\n            visitedTerms.put(st.bytes, st);\n            stQueue.offer(st);\n            // possibly drop entries from queue\n            if (stQueue.size() > maxSize) {\n              st = stQueue.poll();\n              visitedTerms.remove(st.bytes);\n            } else {\n              st = new ScoreTerm(termComp);\n            }\n            assert stQueue.size() <= maxSize : \"the PQ size must be limited to maxSize\";\n            // set maxBoostAtt with values to help FuzzyTermsEnum to optimize\n            if (stQueue.size() == maxSize) {\n              t = stQueue.peek();\n              maxBoostAtt.setMaxNonCompetitiveBoost(t.boost);\n              maxBoostAtt.setCompetitiveTerm(t.bytes);\n            }\n          }\n          return true;\n        }\n      });\n      \n      final Term placeholderTerm = new Term(query.field);\n      final BooleanQuery bq = new BooleanQuery(true);\n      final ScoreTerm[] scoreTerms = stQueue.toArray(new ScoreTerm[stQueue.size()]);\n      ArrayUtil.quickSort(scoreTerms, scoreTermSortByTermComp);\n      for (final ScoreTerm st : scoreTerms) {\n        final Term term = placeholderTerm.createTerm(st.bytes);\n        assert reader.docFreq(term) == st.docFreq;\n        Query tq = getQuery(term, st.docFreq);\n        tq.setBoost(query.getBoost() * st.boost); // set the boost\n        bq.add(tq, BooleanClause.Occur.SHOULD);   // add to query\n      }\n      query.incTotalNumberOfTerms(scoreTerms.length);\n      return bq;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9ab1f5591dc05f1f2b5407d809c9699f75554a32","date":1290008586,"type":4,"author":"Simon Willnauer","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/search/MultiTermQuery.TopTermsBooleanQueryRewrite#rewrite(IndexReader,MultiTermQuery).mjava","sourceNew":null,"sourceOld":"    @Override\n    public Query rewrite(final IndexReader reader, final MultiTermQuery query) throws IOException {\n      final int maxSize = Math.min(size, BooleanQuery.getMaxClauseCount());\n      final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n      collectTerms(reader, query, new TermCollector() {\n        private final MaxNonCompetitiveBoostAttribute maxBoostAtt =\n          attributes.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n        \n        private final Map<BytesRef,ScoreTerm> visitedTerms = new HashMap<BytesRef,ScoreTerm>();\n        \n        private TermsEnum termsEnum;\n        private Comparator<BytesRef> termComp;\n        private BoostAttribute boostAtt;        \n        private ScoreTerm st;\n        \n        @Override\n        public void setNextEnum(TermsEnum termsEnum) throws IOException {\n          this.termsEnum = termsEnum;\n          this.termComp = termsEnum.getComparator();\n          // lazy init the initial ScoreTerm because comparator is not known on ctor:\n          if (st == null)\n            st = new ScoreTerm(this.termComp);\n          boostAtt = termsEnum.attributes().addAttribute(BoostAttribute.class);\n        }\n      \n        @Override\n        public boolean collect(BytesRef bytes) {\n          final float boost = boostAtt.getBoost();\n          // ignore uncompetetive hits\n          if (stQueue.size() == maxSize) {\n            final ScoreTerm t = stQueue.peek();\n            if (boost < t.boost)\n              return true;\n            if (boost == t.boost && termComp.compare(bytes, t.bytes) > 0)\n              return true;\n          }\n          ScoreTerm t = visitedTerms.get(bytes);\n          if (t != null) {\n            // if the term is already in the PQ, only update docFreq of term in PQ\n            t.docFreq += termsEnum.docFreq();\n            assert t.boost == boost : \"boost should be equal in all segment TermsEnums\";\n          } else {\n            // add new entry in PQ, we must clone the term, else it may get overwritten!\n            st.bytes.copy(bytes);\n            st.boost = boost;\n            st.docFreq = termsEnum.docFreq();\n            visitedTerms.put(st.bytes, st);\n            stQueue.offer(st);\n            // possibly drop entries from queue\n            if (stQueue.size() > maxSize) {\n              st = stQueue.poll();\n              visitedTerms.remove(st.bytes);\n            } else {\n              st = new ScoreTerm(termComp);\n            }\n            assert stQueue.size() <= maxSize : \"the PQ size must be limited to maxSize\";\n            // set maxBoostAtt with values to help FuzzyTermsEnum to optimize\n            if (stQueue.size() == maxSize) {\n              t = stQueue.peek();\n              maxBoostAtt.setMaxNonCompetitiveBoost(t.boost);\n              maxBoostAtt.setCompetitiveTerm(t.bytes);\n            }\n          }\n          return true;\n        }\n      });\n      \n      final Term placeholderTerm = new Term(query.field);\n      final BooleanQuery bq = new BooleanQuery(true);\n      final ScoreTerm[] scoreTerms = stQueue.toArray(new ScoreTerm[stQueue.size()]);\n      ArrayUtil.quickSort(scoreTerms, scoreTermSortByTermComp);\n      for (final ScoreTerm st : scoreTerms) {\n        final Term term = placeholderTerm.createTerm(st.bytes);\n        assert reader.docFreq(term) == st.docFreq;\n        Query tq = getQuery(term, st.docFreq);\n        tq.setBoost(query.getBoost() * st.boost); // set the boost\n        bq.add(tq, BooleanClause.Occur.SHOULD);   // add to query\n      }\n      query.incTotalNumberOfTerms(scoreTerms.length);\n      return bq;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":4,"author":"Michael Busch","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/search/MultiTermQuery.TopTermsBooleanQueryRewrite#rewrite(IndexReader,MultiTermQuery).mjava","sourceNew":null,"sourceOld":"    @Override\n    public Query rewrite(final IndexReader reader, final MultiTermQuery query) throws IOException {\n      final int maxSize = Math.min(size, BooleanQuery.getMaxClauseCount());\n      final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n      collectTerms(reader, query, new TermCollector() {\n        public boolean collect(BytesRef bytes, float boost) {\n          // ignore uncompetetive hits\n          if (stQueue.size() >= maxSize && boost <= stQueue.peek().boost)\n            return true;\n          // add new entry in PQ, we must clone the term, else it may get overwritten!\n          st.bytes.copy(bytes);\n          st.boost = boost;\n          stQueue.offer(st);\n          // possibly drop entries from queue\n          st = (stQueue.size() > maxSize) ? stQueue.poll() : new ScoreTerm();\n          setMaxNonCompetitiveBoost((stQueue.size() >= maxSize) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n          return true;\n        }\n        \n        // reusable instance\n        private ScoreTerm st = new ScoreTerm();\n      });\n      \n      final Term placeholderTerm = new Term(query.field);\n      final BooleanQuery bq = new BooleanQuery(true);\n      for (final ScoreTerm st : stQueue) {\n        // add new query, we must clone the term, else it may get overwritten!\n        Query tq = getQuery(placeholderTerm.createTerm(st.bytes));\n        tq.setBoost(query.getBoost() * st.boost); // set the boost\n        bq.add(tq, BooleanClause.Occur.SHOULD);   // add to query\n      }\n      query.incTotalNumberOfTerms(bq.clauses().size());\n      return bq;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"4f29ba80b723649f5feb7e37afe1a558dd2c1304":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"9ab1f5591dc05f1f2b5407d809c9699f75554a32":["ca0ffea399542e8aac8ed7608f34f8ec4cb8904d","744486748bc5bee772100e49230e5bca39bac99a"],"825bcb488bc228d1fb6a19c1f441a2181f7d766d":["4f29ba80b723649f5feb7e37afe1a558dd2c1304"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"5f4e87790277826a2aea119328600dfb07761f32":["955c32f886db6f6356c9fcdea6b1f1cb4effda24","4f29ba80b723649f5feb7e37afe1a558dd2c1304"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["5f4e87790277826a2aea119328600dfb07761f32","744486748bc5bee772100e49230e5bca39bac99a"],"33a8b1f99104f4144f210f5d068411c297cd7163":["825bcb488bc228d1fb6a19c1f441a2181f7d766d"],"ae7aa98ce0c64f3b2b81087d14ff9ae992b4903b":["33a8b1f99104f4144f210f5d068411c297cd7163"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4ecea1664e8617d82eca3b8055a3c37cb4da8511":["825bcb488bc228d1fb6a19c1f441a2181f7d766d","33a8b1f99104f4144f210f5d068411c297cd7163"],"ca0ffea399542e8aac8ed7608f34f8ec4cb8904d":["4ecea1664e8617d82eca3b8055a3c37cb4da8511","ae7aa98ce0c64f3b2b81087d14ff9ae992b4903b"],"744486748bc5bee772100e49230e5bca39bac99a":["ae7aa98ce0c64f3b2b81087d14ff9ae992b4903b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["744486748bc5bee772100e49230e5bca39bac99a"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"4f29ba80b723649f5feb7e37afe1a558dd2c1304":["825bcb488bc228d1fb6a19c1f441a2181f7d766d","5f4e87790277826a2aea119328600dfb07761f32"],"9ab1f5591dc05f1f2b5407d809c9699f75554a32":[],"825bcb488bc228d1fb6a19c1f441a2181f7d766d":["33a8b1f99104f4144f210f5d068411c297cd7163","4ecea1664e8617d82eca3b8055a3c37cb4da8511"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["4f29ba80b723649f5feb7e37afe1a558dd2c1304","5f4e87790277826a2aea119328600dfb07761f32"],"5f4e87790277826a2aea119328600dfb07761f32":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":[],"33a8b1f99104f4144f210f5d068411c297cd7163":["ae7aa98ce0c64f3b2b81087d14ff9ae992b4903b","4ecea1664e8617d82eca3b8055a3c37cb4da8511"],"ae7aa98ce0c64f3b2b81087d14ff9ae992b4903b":["ca0ffea399542e8aac8ed7608f34f8ec4cb8904d","744486748bc5bee772100e49230e5bca39bac99a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"ca0ffea399542e8aac8ed7608f34f8ec4cb8904d":["9ab1f5591dc05f1f2b5407d809c9699f75554a32"],"4ecea1664e8617d82eca3b8055a3c37cb4da8511":["ca0ffea399542e8aac8ed7608f34f8ec4cb8904d"],"744486748bc5bee772100e49230e5bca39bac99a":["9ab1f5591dc05f1f2b5407d809c9699f75554a32","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9ab1f5591dc05f1f2b5407d809c9699f75554a32","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}