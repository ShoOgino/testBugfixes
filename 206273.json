{"path":"lucene/core/src/java/org/apache/lucene/search/BlockMaxConjunctionScorer#approximation().mjava","commits":[{"id":"edc1c8fc0262c6b5526c8e0e23f9b72ddcff6aac","date":1558431344,"type":0,"author":"jimczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BlockMaxConjunctionScorer#approximation().mjava","pathOld":"/dev/null","sourceNew":"  private DocIdSetIterator approximation() {\n    final DocIdSetIterator lead = approximations[0];\n\n    return new DocIdSetIterator() {\n\n      float maxScore;\n      int upTo = -1;\n\n      @Override\n      public int docID() {\n        return lead.docID();\n      }\n\n      @Override\n      public long cost() {\n        return lead.cost();\n      }\n\n      private void moveToNextBlock(int target) throws IOException {\n        upTo = advanceShallow(target);\n        maxScore = getMaxScore(upTo);\n      }\n\n      private int advanceTarget(int target) throws IOException {\n        if (target > upTo) {\n          moveToNextBlock(target);\n        }\n\n        while (true) {\n          assert upTo >= target;\n\n          if (maxScore >= minScore) {\n            return target;\n          }\n\n          if (upTo == NO_MORE_DOCS) {\n            return NO_MORE_DOCS;\n          }\n\n          target = upTo + 1;\n\n          moveToNextBlock(target);\n        }\n      }\n\n      @Override\n      public int nextDoc() throws IOException {\n        return advance(docID() + 1);\n      }\n\n      @Override\n      public int advance(int target) throws IOException {\n        return doNext(lead.advance(advanceTarget(target)));\n      }\n\n      private int doNext(int doc) throws IOException {\n        advanceHead: for(;;) {\n          assert doc == lead.docID();\n\n          if (doc == NO_MORE_DOCS) {\n            return NO_MORE_DOCS;\n          }\n\n          if (doc > upTo) {\n            // This check is useful when scorers return information about blocks\n            // that do not actually have any matches. Otherwise `doc` will always\n            // be in the current block already since it is always the result of\n            // lead.advance(advanceTarget(some_doc_id))\n            final int nextTarget = advanceTarget(doc);\n            if (nextTarget != doc) {\n              doc = lead.advance(nextTarget);\n              continue;\n            }\n          }\n\n          assert doc <= upTo;\n\n          // then find agreement with other iterators\n          for (int i = 1; i < approximations.length; ++i) {\n            final DocIdSetIterator other = approximations[i];\n            // other.doc may already be equal to doc if we \"continued advanceHead\"\n            // on the previous iteration and the advance on the lead scorer exactly matched.\n            if (other.docID() < doc) {\n              final int next = other.advance(doc);\n\n              if (next > doc) {\n                // iterator beyond the current doc - advance lead and continue to the new highest doc.\n                doc = lead.advance(advanceTarget(next));\n                continue advanceHead;\n              }\n            }\n\n            assert other.docID() == doc;\n          }\n\n          // success - all iterators are on the same doc and the score is competitive\n          return doc;\n        }\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"edc1c8fc0262c6b5526c8e0e23f9b72ddcff6aac":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["edc1c8fc0262c6b5526c8e0e23f9b72ddcff6aac"]},"commit2Childs":{"edc1c8fc0262c6b5526c8e0e23f9b72ddcff6aac":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["edc1c8fc0262c6b5526c8e0e23f9b72ddcff6aac"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}