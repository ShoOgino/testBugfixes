{"path":"lucene/queries/src/java/org/apache/lucene/queries/TermsQuery#TermsQuery(Collection[Term]).mjava","commits":[{"id":"01fc0eec0e4dd3fdd2977bb8d7d2997a4c8075cb","date":1453797574,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/queries/src/java/org/apache/lucene/queries/TermsQuery#TermsQuery(Collection[Term]).mjava","pathOld":"lucene/queries/src/java/org/apache/lucene/queries/TermsQuery#TermsQuery(List[Term]).mjava","sourceNew":"  /**\n   * Creates a new {@link TermsQuery} from the given collection. It\n   * can contain duplicate terms and multiple fields.\n   */\n  public TermsQuery(Collection<Term> terms) {\n    Term[] sortedTerms = terms.toArray(new Term[terms.size()]);\n    // already sorted if we are a SortedSet with natural order\n    boolean sorted = terms instanceof SortedSet && ((SortedSet<Term>)terms).comparator() == null;\n    if (!sorted) {\n      ArrayUtil.timSort(sortedTerms);\n    }\n    PrefixCodedTerms.Builder builder = new PrefixCodedTerms.Builder();\n    Term previous = null;\n    for (Term term : sortedTerms) {\n      if (term.equals(previous) == false) {\n        builder.add(term);\n      }\n      previous = term;\n    }\n    termData = builder.finish();\n    termDataHashCode = termData.hashCode();\n  }\n\n","sourceOld":"  /**\n   * Creates a new {@link TermsQuery} from the given list. The list\n   * can contain duplicate terms and multiple fields.\n   */\n  public TermsQuery(final List<Term> terms) {\n    Term[] sortedTerms = terms.toArray(new Term[terms.size()]);\n    ArrayUtil.timSort(sortedTerms);\n    PrefixCodedTerms.Builder builder = new PrefixCodedTerms.Builder();\n    Term previous = null;\n    for (Term term : sortedTerms) {\n      if (term.equals(previous) == false) {\n        builder.add(term);\n      }\n      previous = term;\n    }\n    termData = builder.finish();\n    termDataHashCode = termData.hashCode();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ac88193d9fe80e165a43bb0555c43afa83da8330","date":1453823827,"type":1,"author":"jbernste","isMerge":true,"pathNew":"lucene/queries/src/java/org/apache/lucene/queries/TermsQuery#TermsQuery(Collection[Term]).mjava","pathOld":"lucene/queries/src/java/org/apache/lucene/queries/TermsQuery#TermsQuery(List[Term]).mjava","sourceNew":"  /**\n   * Creates a new {@link TermsQuery} from the given collection. It\n   * can contain duplicate terms and multiple fields.\n   */\n  public TermsQuery(Collection<Term> terms) {\n    Term[] sortedTerms = terms.toArray(new Term[terms.size()]);\n    // already sorted if we are a SortedSet with natural order\n    boolean sorted = terms instanceof SortedSet && ((SortedSet<Term>)terms).comparator() == null;\n    if (!sorted) {\n      ArrayUtil.timSort(sortedTerms);\n    }\n    PrefixCodedTerms.Builder builder = new PrefixCodedTerms.Builder();\n    Term previous = null;\n    for (Term term : sortedTerms) {\n      if (term.equals(previous) == false) {\n        builder.add(term);\n      }\n      previous = term;\n    }\n    termData = builder.finish();\n    termDataHashCode = termData.hashCode();\n  }\n\n","sourceOld":"  /**\n   * Creates a new {@link TermsQuery} from the given list. The list\n   * can contain duplicate terms and multiple fields.\n   */\n  public TermsQuery(final List<Term> terms) {\n    Term[] sortedTerms = terms.toArray(new Term[terms.size()]);\n    ArrayUtil.timSort(sortedTerms);\n    PrefixCodedTerms.Builder builder = new PrefixCodedTerms.Builder();\n    Term previous = null;\n    for (Term term : sortedTerms) {\n      if (term.equals(previous) == false) {\n        builder.add(term);\n      }\n      previous = term;\n    }\n    termData = builder.finish();\n    termDataHashCode = termData.hashCode();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e6acbaae7af722f17204ceccf0f7db5753eccf3","date":1454775255,"type":1,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/queries/src/java/org/apache/lucene/queries/TermsQuery#TermsQuery(Collection[Term]).mjava","pathOld":"lucene/queries/src/java/org/apache/lucene/queries/TermsQuery#TermsQuery(List[Term]).mjava","sourceNew":"  /**\n   * Creates a new {@link TermsQuery} from the given collection. It\n   * can contain duplicate terms and multiple fields.\n   */\n  public TermsQuery(Collection<Term> terms) {\n    Term[] sortedTerms = terms.toArray(new Term[terms.size()]);\n    // already sorted if we are a SortedSet with natural order\n    boolean sorted = terms instanceof SortedSet && ((SortedSet<Term>)terms).comparator() == null;\n    if (!sorted) {\n      ArrayUtil.timSort(sortedTerms);\n    }\n    PrefixCodedTerms.Builder builder = new PrefixCodedTerms.Builder();\n    Term previous = null;\n    for (Term term : sortedTerms) {\n      if (term.equals(previous) == false) {\n        builder.add(term);\n      }\n      previous = term;\n    }\n    termData = builder.finish();\n    termDataHashCode = termData.hashCode();\n  }\n\n","sourceOld":"  /**\n   * Creates a new {@link TermsQuery} from the given list. The list\n   * can contain duplicate terms and multiple fields.\n   */\n  public TermsQuery(final List<Term> terms) {\n    Term[] sortedTerms = terms.toArray(new Term[terms.size()]);\n    ArrayUtil.timSort(sortedTerms);\n    PrefixCodedTerms.Builder builder = new PrefixCodedTerms.Builder();\n    Term previous = null;\n    for (Term term : sortedTerms) {\n      if (term.equals(previous) == false) {\n        builder.add(term);\n      }\n      previous = term;\n    }\n    termData = builder.finish();\n    termDataHashCode = termData.hashCode();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9ee4c03e3ee986704eeeb45c571d001905a6430","date":1462194267,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/queries/src/java/org/apache/lucene/queries/TermsQuery#TermsQuery(Collection[Term]).mjava","pathOld":"lucene/queries/src/java/org/apache/lucene/queries/TermsQuery#TermsQuery(Collection[Term]).mjava","sourceNew":"  /**\n   * Creates a new {@link TermsQuery} from the given collection. It\n   * can contain duplicate terms and multiple fields.\n   */\n  public TermsQuery(Collection<Term> terms) {\n    Term[] sortedTerms = terms.toArray(new Term[terms.size()]);\n    // already sorted if we are a SortedSet with natural order\n    boolean sorted = terms instanceof SortedSet && ((SortedSet<Term>)terms).comparator() == null;\n    if (!sorted) {\n      ArrayUtil.timSort(sortedTerms);\n    }\n    PrefixCodedTerms.Builder builder = new PrefixCodedTerms.Builder();\n    Set<String> fields = new HashSet<>();\n    Term previous = null;\n    for (Term term : sortedTerms) {\n      if (term.equals(previous) == false) {\n        fields.add(term.field());\n        builder.add(term);\n      }\n      previous = term;\n    }\n    this.fields = Collections.unmodifiableSet(fields);\n    termData = builder.finish();\n    termDataHashCode = termData.hashCode();\n  }\n\n","sourceOld":"  /**\n   * Creates a new {@link TermsQuery} from the given collection. It\n   * can contain duplicate terms and multiple fields.\n   */\n  public TermsQuery(Collection<Term> terms) {\n    Term[] sortedTerms = terms.toArray(new Term[terms.size()]);\n    // already sorted if we are a SortedSet with natural order\n    boolean sorted = terms instanceof SortedSet && ((SortedSet<Term>)terms).comparator() == null;\n    if (!sorted) {\n      ArrayUtil.timSort(sortedTerms);\n    }\n    PrefixCodedTerms.Builder builder = new PrefixCodedTerms.Builder();\n    Term previous = null;\n    for (Term term : sortedTerms) {\n      if (term.equals(previous) == false) {\n        builder.add(term);\n      }\n      previous = term;\n    }\n    termData = builder.finish();\n    termDataHashCode = termData.hashCode();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"30540ec27130887a9372c159e8fe971200f37727","date":1462223109,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/queries/src/java/org/apache/lucene/queries/TermsQuery#TermsQuery(Collection[Term]).mjava","pathOld":"lucene/queries/src/java/org/apache/lucene/queries/TermsQuery#TermsQuery(Collection[Term]).mjava","sourceNew":"  /**\n   * Creates a new {@link TermsQuery} from the given collection. It\n   * can contain duplicate terms and multiple fields.\n   */\n  public TermsQuery(Collection<Term> terms) {\n    Term[] sortedTerms = terms.toArray(new Term[terms.size()]);\n    // already sorted if we are a SortedSet with natural order\n    boolean sorted = terms instanceof SortedSet && ((SortedSet<Term>)terms).comparator() == null;\n    if (!sorted) {\n      ArrayUtil.timSort(sortedTerms);\n    }\n    PrefixCodedTerms.Builder builder = new PrefixCodedTerms.Builder();\n    Set<String> fields = new HashSet<>();\n    Term previous = null;\n    for (Term term : sortedTerms) {\n      if (term.equals(previous) == false) {\n        fields.add(term.field());\n        builder.add(term);\n      }\n      previous = term;\n    }\n    this.fields = Collections.unmodifiableSet(fields);\n    termData = builder.finish();\n    termDataHashCode = termData.hashCode();\n  }\n\n","sourceOld":"  /**\n   * Creates a new {@link TermsQuery} from the given collection. It\n   * can contain duplicate terms and multiple fields.\n   */\n  public TermsQuery(Collection<Term> terms) {\n    Term[] sortedTerms = terms.toArray(new Term[terms.size()]);\n    // already sorted if we are a SortedSet with natural order\n    boolean sorted = terms instanceof SortedSet && ((SortedSet<Term>)terms).comparator() == null;\n    if (!sorted) {\n      ArrayUtil.timSort(sortedTerms);\n    }\n    PrefixCodedTerms.Builder builder = new PrefixCodedTerms.Builder();\n    Term previous = null;\n    for (Term term : sortedTerms) {\n      if (term.equals(previous) == false) {\n        builder.add(term);\n      }\n      previous = term;\n    }\n    termData = builder.finish();\n    termDataHashCode = termData.hashCode();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dc891462bf24e8b4c8d0bdc862942e75015540c7","date":1462342542,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/queries/src/java/org/apache/lucene/queries/TermsQuery#TermsQuery(Collection[Term]).mjava","pathOld":"lucene/queries/src/java/org/apache/lucene/queries/TermsQuery#TermsQuery(Collection[Term]).mjava","sourceNew":"  /**\n   * Creates a new {@link TermsQuery} from the given collection. It\n   * can contain duplicate terms and multiple fields.\n   */\n  public TermsQuery(Collection<Term> terms) {\n    Term[] sortedTerms = terms.toArray(new Term[terms.size()]);\n    // already sorted if we are a SortedSet with natural order\n    boolean sorted = terms instanceof SortedSet && ((SortedSet<Term>)terms).comparator() == null;\n    if (!sorted) {\n      ArrayUtil.timSort(sortedTerms);\n    }\n    PrefixCodedTerms.Builder builder = new PrefixCodedTerms.Builder();\n    Set<String> fields = new HashSet<>();\n    Term previous = null;\n    for (Term term : sortedTerms) {\n      if (term.equals(previous) == false) {\n        fields.add(term.field());\n        builder.add(term);\n      }\n      previous = term;\n    }\n    singleField = fields.size() == 1;\n    termData = builder.finish();\n    termDataHashCode = termData.hashCode();\n  }\n\n","sourceOld":"  /**\n   * Creates a new {@link TermsQuery} from the given collection. It\n   * can contain duplicate terms and multiple fields.\n   */\n  public TermsQuery(Collection<Term> terms) {\n    Term[] sortedTerms = terms.toArray(new Term[terms.size()]);\n    // already sorted if we are a SortedSet with natural order\n    boolean sorted = terms instanceof SortedSet && ((SortedSet<Term>)terms).comparator() == null;\n    if (!sorted) {\n      ArrayUtil.timSort(sortedTerms);\n    }\n    PrefixCodedTerms.Builder builder = new PrefixCodedTerms.Builder();\n    Set<String> fields = new HashSet<>();\n    Term previous = null;\n    for (Term term : sortedTerms) {\n      if (term.equals(previous) == false) {\n        fields.add(term.field());\n        builder.add(term);\n      }\n      previous = term;\n    }\n    this.fields = Collections.unmodifiableSet(fields);\n    termData = builder.finish();\n    termDataHashCode = termData.hashCode();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55b50463286869f584cf849d1587a0fcd54d1dfa","date":1462378517,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/queries/src/java/org/apache/lucene/queries/TermsQuery#TermsQuery(Collection[Term]).mjava","pathOld":"lucene/queries/src/java/org/apache/lucene/queries/TermsQuery#TermsQuery(Collection[Term]).mjava","sourceNew":"  /**\n   * Creates a new {@link TermsQuery} from the given collection. It\n   * can contain duplicate terms and multiple fields.\n   */\n  public TermsQuery(Collection<Term> terms) {\n    Term[] sortedTerms = terms.toArray(new Term[terms.size()]);\n    // already sorted if we are a SortedSet with natural order\n    boolean sorted = terms instanceof SortedSet && ((SortedSet<Term>)terms).comparator() == null;\n    if (!sorted) {\n      ArrayUtil.timSort(sortedTerms);\n    }\n    PrefixCodedTerms.Builder builder = new PrefixCodedTerms.Builder();\n    Set<String> fields = new HashSet<>();\n    Term previous = null;\n    for (Term term : sortedTerms) {\n      if (term.equals(previous) == false) {\n        fields.add(term.field());\n        builder.add(term);\n      }\n      previous = term;\n    }\n    singleField = fields.size() == 1;\n    termData = builder.finish();\n    termDataHashCode = termData.hashCode();\n  }\n\n","sourceOld":"  /**\n   * Creates a new {@link TermsQuery} from the given collection. It\n   * can contain duplicate terms and multiple fields.\n   */\n  public TermsQuery(Collection<Term> terms) {\n    Term[] sortedTerms = terms.toArray(new Term[terms.size()]);\n    // already sorted if we are a SortedSet with natural order\n    boolean sorted = terms instanceof SortedSet && ((SortedSet<Term>)terms).comparator() == null;\n    if (!sorted) {\n      ArrayUtil.timSort(sortedTerms);\n    }\n    PrefixCodedTerms.Builder builder = new PrefixCodedTerms.Builder();\n    Term previous = null;\n    for (Term term : sortedTerms) {\n      if (term.equals(previous) == false) {\n        builder.add(term);\n      }\n      previous = term;\n    }\n    termData = builder.finish();\n    termDataHashCode = termData.hashCode();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"73450c0955930295d34703e7ddbfc6973b7a121a","date":1462431925,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/queries/src/java/org/apache/lucene/queries/TermsQuery#TermsQuery(Collection[Term]).mjava","pathOld":"lucene/queries/src/java/org/apache/lucene/queries/TermsQuery#TermsQuery(Collection[Term]).mjava","sourceNew":"  /**\n   * Creates a new {@link TermsQuery} from the given collection. It\n   * can contain duplicate terms and multiple fields.\n   */\n  public TermsQuery(Collection<Term> terms) {\n    Term[] sortedTerms = terms.toArray(new Term[terms.size()]);\n    // already sorted if we are a SortedSet with natural order\n    boolean sorted = terms instanceof SortedSet && ((SortedSet<Term>)terms).comparator() == null;\n    if (!sorted) {\n      ArrayUtil.timSort(sortedTerms);\n    }\n    PrefixCodedTerms.Builder builder = new PrefixCodedTerms.Builder();\n    Set<String> fields = new HashSet<>();\n    Term previous = null;\n    for (Term term : sortedTerms) {\n      if (term.equals(previous) == false) {\n        fields.add(term.field());\n        builder.add(term);\n      }\n      previous = term;\n    }\n    singleField = fields.size() == 1;\n    termData = builder.finish();\n    termDataHashCode = termData.hashCode();\n  }\n\n","sourceOld":"  /**\n   * Creates a new {@link TermsQuery} from the given collection. It\n   * can contain duplicate terms and multiple fields.\n   */\n  public TermsQuery(Collection<Term> terms) {\n    Term[] sortedTerms = terms.toArray(new Term[terms.size()]);\n    // already sorted if we are a SortedSet with natural order\n    boolean sorted = terms instanceof SortedSet && ((SortedSet<Term>)terms).comparator() == null;\n    if (!sorted) {\n      ArrayUtil.timSort(sortedTerms);\n    }\n    PrefixCodedTerms.Builder builder = new PrefixCodedTerms.Builder();\n    Set<String> fields = new HashSet<>();\n    Term previous = null;\n    for (Term term : sortedTerms) {\n      if (term.equals(previous) == false) {\n        fields.add(term.field());\n        builder.add(term);\n      }\n      previous = term;\n    }\n    this.fields = Collections.unmodifiableSet(fields);\n    termData = builder.finish();\n    termDataHashCode = termData.hashCode();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8d73510b39df24d6b65de48e56f8dccb136b9d01","date":1483971905,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/queries/src/java/org/apache/lucene/queries/TermsQuery#TermsQuery(Collection[Term]).mjava","pathOld":"lucene/queries/src/java/org/apache/lucene/queries/TermsQuery#TermsQuery(Collection[Term]).mjava","sourceNew":"  /**\n   * Creates a new {@link TermsQuery} from the given collection. It\n   * can contain duplicate terms and multiple fields.\n   */\n  public TermsQuery(Collection<Term> terms) {\n    super(terms);\n  }\n\n","sourceOld":"  /**\n   * Creates a new {@link TermsQuery} from the given collection. It\n   * can contain duplicate terms and multiple fields.\n   */\n  public TermsQuery(Collection<Term> terms) {\n    Term[] sortedTerms = terms.toArray(new Term[terms.size()]);\n    // already sorted if we are a SortedSet with natural order\n    boolean sorted = terms instanceof SortedSet && ((SortedSet<Term>)terms).comparator() == null;\n    if (!sorted) {\n      ArrayUtil.timSort(sortedTerms);\n    }\n    PrefixCodedTerms.Builder builder = new PrefixCodedTerms.Builder();\n    Set<String> fields = new HashSet<>();\n    Term previous = null;\n    for (Term term : sortedTerms) {\n      if (term.equals(previous) == false) {\n        fields.add(term.field());\n        builder.add(term);\n      }\n      previous = term;\n    }\n    singleField = fields.size() == 1;\n    termData = builder.finish();\n    termDataHashCode = termData.hashCode();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f255a4bca4db0ebee5a45ecced67a799531ad6a0","date":1483975987,"type":4,"author":"Alan Woodward","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/queries/src/java/org/apache/lucene/queries/TermsQuery#TermsQuery(Collection[Term]).mjava","sourceNew":null,"sourceOld":"  /**\n   * Creates a new {@link TermsQuery} from the given collection. It\n   * can contain duplicate terms and multiple fields.\n   */\n  public TermsQuery(Collection<Term> terms) {\n    super(terms);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","date":1484239864,"type":5,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TermInSetQuery#TermInSetQuery(Collection[Term]).mjava","pathOld":"lucene/queries/src/java/org/apache/lucene/queries/TermsQuery#TermsQuery(Collection[Term]).mjava","sourceNew":"  /**\n   * Creates a new {@link TermInSetQuery} from the given collection. It\n   * can contain duplicate terms and multiple fields.\n   */\n  public TermInSetQuery(Collection<Term> terms) {\n    Term[] sortedTerms = terms.toArray(new Term[terms.size()]);\n    // already sorted if we are a SortedSet with natural order\n    boolean sorted = terms instanceof SortedSet && ((SortedSet<Term>)terms).comparator() == null;\n    if (!sorted) {\n      ArrayUtil.timSort(sortedTerms);\n    }\n    PrefixCodedTerms.Builder builder = new PrefixCodedTerms.Builder();\n    Set<String> fields = new HashSet<>();\n    Term previous = null;\n    for (Term term : sortedTerms) {\n      if (term.equals(previous) == false) {\n        fields.add(term.field());\n        builder.add(term);\n      }\n      previous = term;\n    }\n    singleField = fields.size() == 1;\n    termData = builder.finish();\n    termDataHashCode = termData.hashCode();\n  }\n\n","sourceOld":"  /**\n   * Creates a new {@link TermsQuery} from the given collection. It\n   * can contain duplicate terms and multiple fields.\n   */\n  public TermsQuery(Collection<Term> terms) {\n    Term[] sortedTerms = terms.toArray(new Term[terms.size()]);\n    // already sorted if we are a SortedSet with natural order\n    boolean sorted = terms instanceof SortedSet && ((SortedSet<Term>)terms).comparator() == null;\n    if (!sorted) {\n      ArrayUtil.timSort(sortedTerms);\n    }\n    PrefixCodedTerms.Builder builder = new PrefixCodedTerms.Builder();\n    Set<String> fields = new HashSet<>();\n    Term previous = null;\n    for (Term term : sortedTerms) {\n      if (term.equals(previous) == false) {\n        fields.add(term.field());\n        builder.add(term);\n      }\n      previous = term;\n    }\n    singleField = fields.size() == 1;\n    termData = builder.finish();\n    termDataHashCode = termData.hashCode();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ac88193d9fe80e165a43bb0555c43afa83da8330":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","01fc0eec0e4dd3fdd2977bb8d7d2997a4c8075cb"],"73450c0955930295d34703e7ddbfc6973b7a121a":["30540ec27130887a9372c159e8fe971200f37727","dc891462bf24e8b4c8d0bdc862942e75015540c7"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ac88193d9fe80e165a43bb0555c43afa83da8330"],"30540ec27130887a9372c159e8fe971200f37727":["ac88193d9fe80e165a43bb0555c43afa83da8330","c9ee4c03e3ee986704eeeb45c571d001905a6430"],"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7":["55b50463286869f584cf849d1587a0fcd54d1dfa","f255a4bca4db0ebee5a45ecced67a799531ad6a0"],"55b50463286869f584cf849d1587a0fcd54d1dfa":["ac88193d9fe80e165a43bb0555c43afa83da8330","dc891462bf24e8b4c8d0bdc862942e75015540c7"],"dc891462bf24e8b4c8d0bdc862942e75015540c7":["30540ec27130887a9372c159e8fe971200f37727"],"c9ee4c03e3ee986704eeeb45c571d001905a6430":["ac88193d9fe80e165a43bb0555c43afa83da8330"],"01fc0eec0e4dd3fdd2977bb8d7d2997a4c8075cb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8d73510b39df24d6b65de48e56f8dccb136b9d01":["73450c0955930295d34703e7ddbfc6973b7a121a"],"f255a4bca4db0ebee5a45ecced67a799531ad6a0":["8d73510b39df24d6b65de48e56f8dccb136b9d01"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f255a4bca4db0ebee5a45ecced67a799531ad6a0"]},"commit2Childs":{"ac88193d9fe80e165a43bb0555c43afa83da8330":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","30540ec27130887a9372c159e8fe971200f37727","55b50463286869f584cf849d1587a0fcd54d1dfa","c9ee4c03e3ee986704eeeb45c571d001905a6430"],"73450c0955930295d34703e7ddbfc6973b7a121a":["8d73510b39df24d6b65de48e56f8dccb136b9d01"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":[],"30540ec27130887a9372c159e8fe971200f37727":["73450c0955930295d34703e7ddbfc6973b7a121a","dc891462bf24e8b4c8d0bdc862942e75015540c7"],"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7":[],"55b50463286869f584cf849d1587a0fcd54d1dfa":["09ab8ee44ca898536770d0106a7c0ee4be4f0eb7"],"dc891462bf24e8b4c8d0bdc862942e75015540c7":["73450c0955930295d34703e7ddbfc6973b7a121a","55b50463286869f584cf849d1587a0fcd54d1dfa"],"c9ee4c03e3ee986704eeeb45c571d001905a6430":["30540ec27130887a9372c159e8fe971200f37727"],"01fc0eec0e4dd3fdd2977bb8d7d2997a4c8075cb":["ac88193d9fe80e165a43bb0555c43afa83da8330"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ac88193d9fe80e165a43bb0555c43afa83da8330","1e6acbaae7af722f17204ceccf0f7db5753eccf3","01fc0eec0e4dd3fdd2977bb8d7d2997a4c8075cb"],"8d73510b39df24d6b65de48e56f8dccb136b9d01":["f255a4bca4db0ebee5a45ecced67a799531ad6a0"],"f255a4bca4db0ebee5a45ecced67a799531ad6a0":["09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}