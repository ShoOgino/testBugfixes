{"path":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,int,int,boolean).mjava","commits":[{"id":"163fe85a71d778fd2b7747f65ca27b54829e2e57","date":1279898785,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,int,int,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,int,int).mjava","sourceNew":"  // If unicodeSortOrder is true, we do the surrogates dance\n  // so that the terms are sorted by unicode sort order.\n  // This should be true when segments are used for \"normal\"\n  // searching; it's only false during testing, to create a\n  // pre-flex index, using the preflexrw codec under\n  // src/test.\n  public PreFlexFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, int readBufferSize, int indexDivisor, boolean unicodeSortOrder)\n    throws IOException {\n\n    si = info;\n    this.unicodeSortOrder = unicodeSortOrder;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n\n    TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, readBufferSize, indexDivisor);    \n    if (indexDivisor == -1) {\n      tisNoIndex = r;\n    } else {\n      tisNoIndex = null;\n      tis = r;\n    }\n    this.readBufferSize = readBufferSize;\n    this.fieldInfos = fieldInfos;\n\n    // make sure that all index files have been read or are kept open\n    // so that if an index update removes them we'll still have them\n    freqStream = dir.openInput(info.name + \".frq\", readBufferSize);\n    boolean anyProx = false;\n    final int numFields = fieldInfos.size();\n    for(int i=0;i<numFields;i++) {\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(i);\n      if (fieldInfo.isIndexed) {\n        fields.put(fieldInfo.name, fieldInfo);\n        if (!fieldInfo.omitTermFreqAndPositions) {\n          anyProx = true;\n        }\n      }\n    }\n\n    if (anyProx) {\n      proxStream = dir.openInput(info.name + \".prx\", readBufferSize);\n    } else {\n      proxStream = null;\n    }\n\n    this.dir = dir;\n  }\n\n","sourceOld":"  PreFlexFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, int readBufferSize, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n\n    TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, readBufferSize, indexDivisor);    \n    if (indexDivisor == -1) {\n      tisNoIndex = r;\n    } else {\n      tisNoIndex = null;\n      tis = r;\n    }\n    this.readBufferSize = readBufferSize;\n    this.fieldInfos = fieldInfos;\n\n    // make sure that all index files have been read or are kept open\n    // so that if an index update removes them we'll still have them\n    freqStream = dir.openInput(info.name + \".frq\", readBufferSize);\n    boolean anyProx = false;\n    final int numFields = fieldInfos.size();\n    for(int i=0;i<numFields;i++) {\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(i);\n      if (fieldInfo.isIndexed) {\n        fields.put(fieldInfo.name, fieldInfo);\n        if (!fieldInfo.omitTermFreqAndPositions) {\n          anyProx = true;\n        }\n      }\n    }\n\n    if (anyProx) {\n      proxStream = dir.openInput(info.name + \".prx\", readBufferSize);\n    } else {\n      proxStream = null;\n    }\n\n    this.dir = dir;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"399a364d374f2132b6d9ff9fd7f997a9f2ef734f","date":1279978822,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields#PreFlexFields(Directory,FieldInfos,SegmentInfo,int,int,boolean).mjava","sourceNew":"  public PreFlexFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, int readBufferSize, int indexDivisor)\n    throws IOException {\n\n    si = info;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n\n    TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, readBufferSize, indexDivisor);    \n    if (indexDivisor == -1) {\n      tisNoIndex = r;\n    } else {\n      tisNoIndex = null;\n      tis = r;\n    }\n    this.readBufferSize = readBufferSize;\n    this.fieldInfos = fieldInfos;\n\n    // make sure that all index files have been read or are kept open\n    // so that if an index update removes them we'll still have them\n    freqStream = dir.openInput(info.name + \".frq\", readBufferSize);\n    boolean anyProx = false;\n    final int numFields = fieldInfos.size();\n    for(int i=0;i<numFields;i++) {\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(i);\n      if (fieldInfo.isIndexed) {\n        fields.put(fieldInfo.name, fieldInfo);\n        if (!fieldInfo.omitTermFreqAndPositions) {\n          anyProx = true;\n        }\n      }\n    }\n\n    if (anyProx) {\n      proxStream = dir.openInput(info.name + \".prx\", readBufferSize);\n    } else {\n      proxStream = null;\n    }\n\n    this.dir = dir;\n  }\n\n","sourceOld":"  // If unicodeSortOrder is true, we do the surrogates dance\n  // so that the terms are sorted by unicode sort order.\n  // This should be true when segments are used for \"normal\"\n  // searching; it's only false during testing, to create a\n  // pre-flex index, using the preflexrw codec under\n  // src/test.\n  public PreFlexFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, int readBufferSize, int indexDivisor, boolean unicodeSortOrder)\n    throws IOException {\n\n    si = info;\n    this.unicodeSortOrder = unicodeSortOrder;\n\n    // NOTE: we must always load terms index, even for\n    // \"sequential\" scan during merging, because what is\n    // sequential to merger may not be to TermInfosReader\n    // since we do the surrogates dance:\n    if (indexDivisor < 0) {\n      indexDivisor = -indexDivisor;\n    }\n\n    TermInfosReader r = new TermInfosReader(dir, info.name, fieldInfos, readBufferSize, indexDivisor);    \n    if (indexDivisor == -1) {\n      tisNoIndex = r;\n    } else {\n      tisNoIndex = null;\n      tis = r;\n    }\n    this.readBufferSize = readBufferSize;\n    this.fieldInfos = fieldInfos;\n\n    // make sure that all index files have been read or are kept open\n    // so that if an index update removes them we'll still have them\n    freqStream = dir.openInput(info.name + \".frq\", readBufferSize);\n    boolean anyProx = false;\n    final int numFields = fieldInfos.size();\n    for(int i=0;i<numFields;i++) {\n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(i);\n      if (fieldInfo.isIndexed) {\n        fields.put(fieldInfo.name, fieldInfo);\n        if (!fieldInfo.omitTermFreqAndPositions) {\n          anyProx = true;\n        }\n      }\n    }\n\n    if (anyProx) {\n      proxStream = dir.openInput(info.name + \".prx\", readBufferSize);\n    } else {\n      proxStream = null;\n    }\n\n    this.dir = dir;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"163fe85a71d778fd2b7747f65ca27b54829e2e57":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"399a364d374f2132b6d9ff9fd7f997a9f2ef734f":["163fe85a71d778fd2b7747f65ca27b54829e2e57"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"163fe85a71d778fd2b7747f65ca27b54829e2e57":["399a364d374f2132b6d9ff9fd7f997a9f2ef734f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["163fe85a71d778fd2b7747f65ca27b54829e2e57","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"399a364d374f2132b6d9ff9fd7f997a9f2ef734f":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["399a364d374f2132b6d9ff9fd7f997a9f2ef734f","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}