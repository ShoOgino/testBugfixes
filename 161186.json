{"path":"solr/core/src/test/org/apache/solr/search/TestRecovery#testBuffering().mjava","commits":[{"id":"2c007e7c4cf8c55bc2a5884e315123afaaeec87f","date":1327520966,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestRecovery#testBuffering().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testBuffering() throws Exception {\n\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = new Runnable() {\n      @Override\n      public void run() {\n        try {\n          assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n        } catch (Exception e) {\n          throw new RuntimeException(e);\n        }\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = new Runnable() {\n      @Override\n      public void run() {\n        logReplayFinish.release();\n      }\n    };\n\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n\n    try {\n      clearIndex();\n      assertU(commit());\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n      Future<UpdateLog.RecoveryInfo> rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture == null);\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"1\", \"_version_\",\"1010\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n      updateJ(jsonAdd(sdoc(\"id\",\"11\", \"_version_\",\"1015\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n      updateJ(jsonDelQ(\"id:1 id:11 id:2 id:3\"), params(SEEN_LEADER,SEEN_LEADER_VAL, \"_version_\",\"-1017\"));\n      updateJ(jsonAdd(sdoc(\"id\",\"2\", \"_version_\",\"1020\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n      updateJ(jsonAdd(sdoc(\"id\",\"3\", \"_version_\",\"1030\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n      deleteAndGetVersion(\"1\", params(SEEN_LEADER,SEEN_LEADER_VAL, \"_version_\",\"-2010\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      assertU(commit());\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      // updates should be buffered, so we should not see any results yet.\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==0\"\n      );\n\n      // real-time get should also not show anything (this could change in the future,\n      // but it's currently used for validating version numbers too, so it would\n      // be bad for updates to be visible if we're just buffering.\n      assertJQ(req(\"qt\",\"/get\", \"id\",\"3\")\n          ,\"=={'doc':null}\"\n      );\n\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      logReplay.release(1000);\n\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==2\"\n      );\n\n      // move back to recovering\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Long ver = getVer(req(\"qt\",\"/get\", \"id\",\"3\"));\n      assertEquals(1030L, ver.longValue());\n\n      // add a reordered doc that shouldn't overwrite one in the index\n      updateJ(jsonAdd(sdoc(\"id\",\"3\", \"_version_\",\"3\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n\n      // reorder two buffered updates\n      updateJ(jsonAdd(sdoc(\"id\",\"4\", \"_version_\",\"1040\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n      deleteAndGetVersion(\"4\", params(SEEN_LEADER,SEEN_LEADER_VAL, \"_version_\",\"-940\"));   // this update should not take affect\n      updateJ(jsonAdd(sdoc(\"id\",\"6\", \"_version_\",\"1060\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n      updateJ(jsonAdd(sdoc(\"id\",\"5\", \"_version_\",\"1050\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n      updateJ(jsonAdd(sdoc(\"id\",\"8\", \"_version_\",\"1080\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n\n      // test that delete by query is at least buffered along with everything else so it will delete the\n      // currently buffered id:8 (even if it doesn't currently support versioning)\n      updateJ(\"{\\\"delete\\\": { \\\"query\\\":\\\"id:2 OR id:8\\\" }}\", params(SEEN_LEADER,SEEN_LEADER_VAL, \"_version_\",\"-3000\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"13\")\n          ,\"=={'versions':[-3000,1080,1050,1060,-940,1040,3,-2010,1030,1020,-1017,1015,1010]}\"  // the \"3\" appears because versions aren't checked while buffering\n      );\n\n      logReplay.drainPermits();\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      // apply a single update\n      logReplay.release(1);\n\n      // now add another update\n      updateJ(jsonAdd(sdoc(\"id\",\"7\", \"_version_\",\"1070\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n\n      // a reordered update that should be dropped\n      deleteAndGetVersion(\"5\", params(SEEN_LEADER,SEEN_LEADER_VAL, \"_version_\",\"-950\"));\n\n      deleteAndGetVersion(\"6\", params(SEEN_LEADER,SEEN_LEADER_VAL, \"_version_\",\"-2060\"));\n\n      logReplay.release(1000);\n      UpdateLog.RecoveryInfo recInfo = rinfoFuture.get();\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"id asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n                           + \"{'id':'3','_version_':1030}\"\n                           + \",{'id':'4','_version_':1040}\"\n                           + \",{'id':'5','_version_':1050}\"\n                           + \",{'id':'7','_version_':1070}\"\n                           +\"]\"\n      );\n\n      assertEquals(1, recInfo.deleteByQuery);\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestRecovery#testBuffering().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testBuffering() throws Exception {\n\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = new Runnable() {\n      @Override\n      public void run() {\n        try {\n          assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n        } catch (Exception e) {\n          throw new RuntimeException(e);\n        }\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = new Runnable() {\n      @Override\n      public void run() {\n        logReplayFinish.release();\n      }\n    };\n\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n\n    try {\n      clearIndex();\n      assertU(commit());\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n      Future<UpdateLog.RecoveryInfo> rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture == null);\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"1\", \"_version_\",\"1010\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n      updateJ(jsonAdd(sdoc(\"id\",\"11\", \"_version_\",\"1015\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n      updateJ(jsonDelQ(\"id:1 id:11 id:2 id:3\"), params(SEEN_LEADER,SEEN_LEADER_VAL, \"_version_\",\"-1017\"));\n      updateJ(jsonAdd(sdoc(\"id\",\"2\", \"_version_\",\"1020\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n      updateJ(jsonAdd(sdoc(\"id\",\"3\", \"_version_\",\"1030\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n      deleteAndGetVersion(\"1\", params(SEEN_LEADER,SEEN_LEADER_VAL, \"_version_\",\"-2010\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      assertU(commit());\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      // updates should be buffered, so we should not see any results yet.\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==0\"\n      );\n\n      // real-time get should also not show anything (this could change in the future,\n      // but it's currently used for validating version numbers too, so it would\n      // be bad for updates to be visible if we're just buffering.\n      assertJQ(req(\"qt\",\"/get\", \"id\",\"3\")\n          ,\"=={'doc':null}\"\n      );\n\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      logReplay.release(1000);\n\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==2\"\n      );\n\n      // move back to recovering\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Long ver = getVer(req(\"qt\",\"/get\", \"id\",\"3\"));\n      assertEquals(1030L, ver.longValue());\n\n      // add a reordered doc that shouldn't overwrite one in the index\n      updateJ(jsonAdd(sdoc(\"id\",\"3\", \"_version_\",\"3\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n\n      // reorder two buffered updates\n      updateJ(jsonAdd(sdoc(\"id\",\"4\", \"_version_\",\"1040\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n      deleteAndGetVersion(\"4\", params(SEEN_LEADER,SEEN_LEADER_VAL, \"_version_\",\"-940\"));   // this update should not take affect\n      updateJ(jsonAdd(sdoc(\"id\",\"6\", \"_version_\",\"1060\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n      updateJ(jsonAdd(sdoc(\"id\",\"5\", \"_version_\",\"1050\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n      updateJ(jsonAdd(sdoc(\"id\",\"8\", \"_version_\",\"1080\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n\n      // test that delete by query is at least buffered along with everything else so it will delete the\n      // currently buffered id:8 (even if it doesn't currently support versioning)\n      updateJ(\"{\\\"delete\\\": { \\\"query\\\":\\\"id:2 OR id:8\\\" }}\", params(SEEN_LEADER,SEEN_LEADER_VAL, \"_version_\",\"-3000\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"13\")\n          ,\"=={'versions':[-3000,1080,1050,1060,-940,1040,3,-2010,1030,1020,-1017,1015,1010]}\"  // the \"3\" appears because versions aren't checked while buffering\n      );\n\n      logReplay.drainPermits();\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      // apply a single update\n      logReplay.release(1);\n\n      // now add another update\n      updateJ(jsonAdd(sdoc(\"id\",\"7\", \"_version_\",\"1070\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n\n      // a reordered update that should be dropped\n      deleteAndGetVersion(\"5\", params(SEEN_LEADER,SEEN_LEADER_VAL, \"_version_\",\"-950\"));\n\n      deleteAndGetVersion(\"6\", params(SEEN_LEADER,SEEN_LEADER_VAL, \"_version_\",\"-2060\"));\n\n      logReplay.release(1000);\n      UpdateLog.RecoveryInfo recInfo = rinfoFuture.get();\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"id asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n                           + \"{'id':'3','_version_':1030}\"\n                           + \",{'id':'4','_version_':1040}\"\n                           + \",{'id':'5','_version_':1050}\"\n                           + \",{'id':'7','_version_':1070}\"\n                           +\"]\"\n      );\n\n      assertEquals(1, recInfo.deleteByQuery);\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d22ac6a4146774c1bc8400160fc0b6150294e92","date":1327528604,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestRecovery#testBuffering().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testBuffering() throws Exception {\n\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = new Runnable() {\n      @Override\n      public void run() {\n        try {\n          assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n        } catch (Exception e) {\n          throw new RuntimeException(e);\n        }\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = new Runnable() {\n      @Override\n      public void run() {\n        logReplayFinish.release();\n      }\n    };\n\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n\n    try {\n      clearIndex();\n      assertU(commit());\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n      Future<UpdateLog.RecoveryInfo> rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture == null);\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"1\", \"_version_\",\"1010\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n      updateJ(jsonAdd(sdoc(\"id\",\"11\", \"_version_\",\"1015\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n      updateJ(jsonDelQ(\"id:1 id:11 id:2 id:3\"), params(SEEN_LEADER,SEEN_LEADER_VAL, \"_version_\",\"-1017\"));\n      updateJ(jsonAdd(sdoc(\"id\",\"2\", \"_version_\",\"1020\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n      updateJ(jsonAdd(sdoc(\"id\",\"3\", \"_version_\",\"1030\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n      deleteAndGetVersion(\"1\", params(SEEN_LEADER,SEEN_LEADER_VAL, \"_version_\",\"-2010\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      assertU(commit());\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      // updates should be buffered, so we should not see any results yet.\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==0\"\n      );\n\n      // real-time get should also not show anything (this could change in the future,\n      // but it's currently used for validating version numbers too, so it would\n      // be bad for updates to be visible if we're just buffering.\n      assertJQ(req(\"qt\",\"/get\", \"id\",\"3\")\n          ,\"=={'doc':null}\"\n      );\n\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      logReplay.release(1000);\n\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==2\"\n      );\n\n      // move back to recovering\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Long ver = getVer(req(\"qt\",\"/get\", \"id\",\"3\"));\n      assertEquals(1030L, ver.longValue());\n\n      // add a reordered doc that shouldn't overwrite one in the index\n      updateJ(jsonAdd(sdoc(\"id\",\"3\", \"_version_\",\"3\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n\n      // reorder two buffered updates\n      updateJ(jsonAdd(sdoc(\"id\",\"4\", \"_version_\",\"1040\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n      deleteAndGetVersion(\"4\", params(SEEN_LEADER,SEEN_LEADER_VAL, \"_version_\",\"-940\"));   // this update should not take affect\n      updateJ(jsonAdd(sdoc(\"id\",\"6\", \"_version_\",\"1060\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n      updateJ(jsonAdd(sdoc(\"id\",\"5\", \"_version_\",\"1050\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n      updateJ(jsonAdd(sdoc(\"id\",\"8\", \"_version_\",\"1080\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n\n      // test that delete by query is at least buffered along with everything else so it will delete the\n      // currently buffered id:8 (even if it doesn't currently support versioning)\n      updateJ(\"{\\\"delete\\\": { \\\"query\\\":\\\"id:2 OR id:8\\\" }}\", params(SEEN_LEADER,SEEN_LEADER_VAL, \"_version_\",\"-3000\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"13\")\n          ,\"=={'versions':[-3000,1080,1050,1060,-940,1040,3,-2010,1030,1020,-1017,1015,1010]}\"  // the \"3\" appears because versions aren't checked while buffering\n      );\n\n      logReplay.drainPermits();\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      // apply a single update\n      logReplay.release(1);\n\n      // now add another update\n      updateJ(jsonAdd(sdoc(\"id\",\"7\", \"_version_\",\"1070\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n\n      // a reordered update that should be dropped\n      deleteAndGetVersion(\"5\", params(SEEN_LEADER,SEEN_LEADER_VAL, \"_version_\",\"-950\"));\n\n      deleteAndGetVersion(\"6\", params(SEEN_LEADER,SEEN_LEADER_VAL, \"_version_\",\"-2060\"));\n\n      logReplay.release(1000);\n      UpdateLog.RecoveryInfo recInfo = rinfoFuture.get();\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"id asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n                           + \"{'id':'3','_version_':1030}\"\n                           + \",{'id':'4','_version_':1040}\"\n                           + \",{'id':'5','_version_':1050}\"\n                           + \",{'id':'7','_version_':1070}\"\n                           +\"]\"\n      );\n\n      assertEquals(1, recInfo.deleteByQuery);\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"01e98f8ae83ed9c1151cd99b37a7371fd6754ac2","date":1329660825,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestRecovery#testBuffering().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestRecovery#testBuffering().mjava","sourceNew":"  @Test\n  public void testBuffering() throws Exception {\n\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = new Runnable() {\n      @Override\n      public void run() {\n        try {\n          assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n        } catch (Exception e) {\n          throw new RuntimeException(e);\n        }\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = new Runnable() {\n      @Override\n      public void run() {\n        logReplayFinish.release();\n      }\n    };\n\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n\n    try {\n      clearIndex();\n      assertU(commit());\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n      Future<UpdateLog.RecoveryInfo> rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture == null);\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"B1\", \"_version_\",\"1010\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n      updateJ(jsonAdd(sdoc(\"id\",\"B11\", \"_version_\",\"1015\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n      updateJ(jsonDelQ(\"id:B1 id:B11 id:B2 id:B3\"), params(SEEN_LEADER,SEEN_LEADER_VAL, \"_version_\",\"-1017\"));\n      updateJ(jsonAdd(sdoc(\"id\",\"B2\", \"_version_\",\"1020\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"1030\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n      deleteAndGetVersion(\"B1\", params(SEEN_LEADER,SEEN_LEADER_VAL, \"_version_\",\"-2010\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      assertU(commit());\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      // updates should be buffered, so we should not see any results yet.\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==0\"\n      );\n\n      // real-time get should also not show anything (this could change in the future,\n      // but it's currently used for validating version numbers too, so it would\n      // be bad for updates to be visible if we're just buffering.\n      assertJQ(req(\"qt\",\"/get\", \"id\",\"B3\")\n          ,\"=={'doc':null}\"\n      );\n\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      logReplay.release(1000);\n\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==2\"\n      );\n\n      // move back to recovering\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Long ver = getVer(req(\"qt\",\"/get\", \"id\",\"B3\"));\n      assertEquals(1030L, ver.longValue());\n\n      // add a reordered doc that shouldn't overwrite one in the index\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"3\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n\n      // reorder two buffered updates\n      updateJ(jsonAdd(sdoc(\"id\",\"B4\", \"_version_\",\"1040\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n      deleteAndGetVersion(\"B4\", params(SEEN_LEADER,SEEN_LEADER_VAL, \"_version_\",\"-940\"));   // this update should not take affect\n      updateJ(jsonAdd(sdoc(\"id\",\"B6\", \"_version_\",\"1060\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n      updateJ(jsonAdd(sdoc(\"id\",\"B5\", \"_version_\",\"1050\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n      updateJ(jsonAdd(sdoc(\"id\",\"B8\", \"_version_\",\"1080\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n\n      // test that delete by query is at least buffered along with everything else so it will delete the\n      // currently buffered id:8 (even if it doesn't currently support versioning)\n      updateJ(\"{\\\"delete\\\": { \\\"query\\\":\\\"id:B2 OR id:B8\\\" }}\", params(SEEN_LEADER,SEEN_LEADER_VAL, \"_version_\",\"-3000\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"13\")\n          ,\"=={'versions':[-3000,1080,1050,1060,-940,1040,3,-2010,1030,1020,-1017,1015,1010]}\"  // the \"3\" appears because versions aren't checked while buffering\n      );\n\n      logReplay.drainPermits();\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      // apply a single update\n      logReplay.release(1);\n\n      // now add another update\n      updateJ(jsonAdd(sdoc(\"id\",\"B7\", \"_version_\",\"1070\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n\n      // a reordered update that should be dropped\n      deleteAndGetVersion(\"B5\", params(SEEN_LEADER,SEEN_LEADER_VAL, \"_version_\",\"-950\"));\n\n      deleteAndGetVersion(\"B6\", params(SEEN_LEADER,SEEN_LEADER_VAL, \"_version_\",\"-2060\"));\n\n      logReplay.release(1000);\n      UpdateLog.RecoveryInfo recInfo = rinfoFuture.get();\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"id asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n                           + \"{'id':'B3','_version_':1030}\"\n                           + \",{'id':'B4','_version_':1040}\"\n                           + \",{'id':'B5','_version_':1050}\"\n                           + \",{'id':'B7','_version_':1070}\"\n                           +\"]\"\n      );\n\n      assertEquals(1, recInfo.deleteByQuery);\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testBuffering() throws Exception {\n\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = new Runnable() {\n      @Override\n      public void run() {\n        try {\n          assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n        } catch (Exception e) {\n          throw new RuntimeException(e);\n        }\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = new Runnable() {\n      @Override\n      public void run() {\n        logReplayFinish.release();\n      }\n    };\n\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n\n    try {\n      clearIndex();\n      assertU(commit());\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n      Future<UpdateLog.RecoveryInfo> rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture == null);\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"1\", \"_version_\",\"1010\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n      updateJ(jsonAdd(sdoc(\"id\",\"11\", \"_version_\",\"1015\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n      updateJ(jsonDelQ(\"id:1 id:11 id:2 id:3\"), params(SEEN_LEADER,SEEN_LEADER_VAL, \"_version_\",\"-1017\"));\n      updateJ(jsonAdd(sdoc(\"id\",\"2\", \"_version_\",\"1020\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n      updateJ(jsonAdd(sdoc(\"id\",\"3\", \"_version_\",\"1030\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n      deleteAndGetVersion(\"1\", params(SEEN_LEADER,SEEN_LEADER_VAL, \"_version_\",\"-2010\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      assertU(commit());\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      // updates should be buffered, so we should not see any results yet.\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==0\"\n      );\n\n      // real-time get should also not show anything (this could change in the future,\n      // but it's currently used for validating version numbers too, so it would\n      // be bad for updates to be visible if we're just buffering.\n      assertJQ(req(\"qt\",\"/get\", \"id\",\"3\")\n          ,\"=={'doc':null}\"\n      );\n\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      logReplay.release(1000);\n\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==2\"\n      );\n\n      // move back to recovering\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Long ver = getVer(req(\"qt\",\"/get\", \"id\",\"3\"));\n      assertEquals(1030L, ver.longValue());\n\n      // add a reordered doc that shouldn't overwrite one in the index\n      updateJ(jsonAdd(sdoc(\"id\",\"3\", \"_version_\",\"3\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n\n      // reorder two buffered updates\n      updateJ(jsonAdd(sdoc(\"id\",\"4\", \"_version_\",\"1040\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n      deleteAndGetVersion(\"4\", params(SEEN_LEADER,SEEN_LEADER_VAL, \"_version_\",\"-940\"));   // this update should not take affect\n      updateJ(jsonAdd(sdoc(\"id\",\"6\", \"_version_\",\"1060\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n      updateJ(jsonAdd(sdoc(\"id\",\"5\", \"_version_\",\"1050\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n      updateJ(jsonAdd(sdoc(\"id\",\"8\", \"_version_\",\"1080\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n\n      // test that delete by query is at least buffered along with everything else so it will delete the\n      // currently buffered id:8 (even if it doesn't currently support versioning)\n      updateJ(\"{\\\"delete\\\": { \\\"query\\\":\\\"id:2 OR id:8\\\" }}\", params(SEEN_LEADER,SEEN_LEADER_VAL, \"_version_\",\"-3000\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"13\")\n          ,\"=={'versions':[-3000,1080,1050,1060,-940,1040,3,-2010,1030,1020,-1017,1015,1010]}\"  // the \"3\" appears because versions aren't checked while buffering\n      );\n\n      logReplay.drainPermits();\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      // apply a single update\n      logReplay.release(1);\n\n      // now add another update\n      updateJ(jsonAdd(sdoc(\"id\",\"7\", \"_version_\",\"1070\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n\n      // a reordered update that should be dropped\n      deleteAndGetVersion(\"5\", params(SEEN_LEADER,SEEN_LEADER_VAL, \"_version_\",\"-950\"));\n\n      deleteAndGetVersion(\"6\", params(SEEN_LEADER,SEEN_LEADER_VAL, \"_version_\",\"-2060\"));\n\n      logReplay.release(1000);\n      UpdateLog.RecoveryInfo recInfo = rinfoFuture.get();\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"id asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n                           + \"{'id':'3','_version_':1030}\"\n                           + \",{'id':'4','_version_':1040}\"\n                           + \",{'id':'5','_version_':1050}\"\n                           + \",{'id':'7','_version_':1070}\"\n                           +\"]\"\n      );\n\n      assertEquals(1, recInfo.deleteByQuery);\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e2fe35ac47f8f51356d6c1724455d18f31c94fae","date":1337966698,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestRecovery#testBuffering().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestRecovery#testBuffering().mjava","sourceNew":"  @Test\n  public void testBuffering() throws Exception {\n\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = new Runnable() {\n      @Override\n      public void run() {\n        try {\n          assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n        } catch (Exception e) {\n          throw new RuntimeException(e);\n        }\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = new Runnable() {\n      @Override\n      public void run() {\n        logReplayFinish.release();\n      }\n    };\n\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n\n    try {\n      clearIndex();\n      assertU(commit());\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n      Future<UpdateLog.RecoveryInfo> rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture == null);\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"B1\", \"_version_\",\"1010\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B11\", \"_version_\",\"1015\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonDelQ(\"id:B1 id:B11 id:B2 id:B3\"), params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-1017\"));\n      updateJ(jsonAdd(sdoc(\"id\",\"B2\", \"_version_\",\"1020\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"1030\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B1\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2010\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      assertU(commit());\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      // updates should be buffered, so we should not see any results yet.\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==0\"\n      );\n\n      // real-time get should also not show anything (this could change in the future,\n      // but it's currently used for validating version numbers too, so it would\n      // be bad for updates to be visible if we're just buffering.\n      assertJQ(req(\"qt\",\"/get\", \"id\",\"B3\")\n          ,\"=={'doc':null}\"\n      );\n\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      logReplay.release(1000);\n\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==2\"\n      );\n\n      // move back to recovering\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Long ver = getVer(req(\"qt\",\"/get\", \"id\",\"B3\"));\n      assertEquals(1030L, ver.longValue());\n\n      // add a reordered doc that shouldn't overwrite one in the index\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"3\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // reorder two buffered updates\n      updateJ(jsonAdd(sdoc(\"id\",\"B4\", \"_version_\",\"1040\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B4\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-940\"));   // this update should not take affect\n      updateJ(jsonAdd(sdoc(\"id\",\"B6\", \"_version_\",\"1060\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B5\", \"_version_\",\"1050\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B8\", \"_version_\",\"1080\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // test that delete by query is at least buffered along with everything else so it will delete the\n      // currently buffered id:8 (even if it doesn't currently support versioning)\n      updateJ(\"{\\\"delete\\\": { \\\"query\\\":\\\"id:B2 OR id:B8\\\" }}\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-3000\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"13\")\n          ,\"=={'versions':[-3000,1080,1050,1060,-940,1040,3,-2010,1030,1020,-1017,1015,1010]}\"  // the \"3\" appears because versions aren't checked while buffering\n      );\n\n      logReplay.drainPermits();\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      // apply a single update\n      logReplay.release(1);\n\n      // now add another update\n      updateJ(jsonAdd(sdoc(\"id\",\"B7\", \"_version_\",\"1070\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // a reordered update that should be dropped\n      deleteAndGetVersion(\"B5\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-950\"));\n\n      deleteAndGetVersion(\"B6\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2060\"));\n\n      logReplay.release(1000);\n      UpdateLog.RecoveryInfo recInfo = rinfoFuture.get();\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"id asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n                           + \"{'id':'B3','_version_':1030}\"\n                           + \",{'id':'B4','_version_':1040}\"\n                           + \",{'id':'B5','_version_':1050}\"\n                           + \",{'id':'B7','_version_':1070}\"\n                           +\"]\"\n      );\n\n      assertEquals(1, recInfo.deleteByQuery);\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testBuffering() throws Exception {\n\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = new Runnable() {\n      @Override\n      public void run() {\n        try {\n          assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n        } catch (Exception e) {\n          throw new RuntimeException(e);\n        }\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = new Runnable() {\n      @Override\n      public void run() {\n        logReplayFinish.release();\n      }\n    };\n\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n\n    try {\n      clearIndex();\n      assertU(commit());\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n      Future<UpdateLog.RecoveryInfo> rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture == null);\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"B1\", \"_version_\",\"1010\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n      updateJ(jsonAdd(sdoc(\"id\",\"B11\", \"_version_\",\"1015\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n      updateJ(jsonDelQ(\"id:B1 id:B11 id:B2 id:B3\"), params(SEEN_LEADER,SEEN_LEADER_VAL, \"_version_\",\"-1017\"));\n      updateJ(jsonAdd(sdoc(\"id\",\"B2\", \"_version_\",\"1020\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"1030\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n      deleteAndGetVersion(\"B1\", params(SEEN_LEADER,SEEN_LEADER_VAL, \"_version_\",\"-2010\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      assertU(commit());\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      // updates should be buffered, so we should not see any results yet.\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==0\"\n      );\n\n      // real-time get should also not show anything (this could change in the future,\n      // but it's currently used for validating version numbers too, so it would\n      // be bad for updates to be visible if we're just buffering.\n      assertJQ(req(\"qt\",\"/get\", \"id\",\"B3\")\n          ,\"=={'doc':null}\"\n      );\n\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      logReplay.release(1000);\n\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==2\"\n      );\n\n      // move back to recovering\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Long ver = getVer(req(\"qt\",\"/get\", \"id\",\"B3\"));\n      assertEquals(1030L, ver.longValue());\n\n      // add a reordered doc that shouldn't overwrite one in the index\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"3\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n\n      // reorder two buffered updates\n      updateJ(jsonAdd(sdoc(\"id\",\"B4\", \"_version_\",\"1040\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n      deleteAndGetVersion(\"B4\", params(SEEN_LEADER,SEEN_LEADER_VAL, \"_version_\",\"-940\"));   // this update should not take affect\n      updateJ(jsonAdd(sdoc(\"id\",\"B6\", \"_version_\",\"1060\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n      updateJ(jsonAdd(sdoc(\"id\",\"B5\", \"_version_\",\"1050\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n      updateJ(jsonAdd(sdoc(\"id\",\"B8\", \"_version_\",\"1080\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n\n      // test that delete by query is at least buffered along with everything else so it will delete the\n      // currently buffered id:8 (even if it doesn't currently support versioning)\n      updateJ(\"{\\\"delete\\\": { \\\"query\\\":\\\"id:B2 OR id:B8\\\" }}\", params(SEEN_LEADER,SEEN_LEADER_VAL, \"_version_\",\"-3000\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"13\")\n          ,\"=={'versions':[-3000,1080,1050,1060,-940,1040,3,-2010,1030,1020,-1017,1015,1010]}\"  // the \"3\" appears because versions aren't checked while buffering\n      );\n\n      logReplay.drainPermits();\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      // apply a single update\n      logReplay.release(1);\n\n      // now add another update\n      updateJ(jsonAdd(sdoc(\"id\",\"B7\", \"_version_\",\"1070\")), params(SEEN_LEADER,SEEN_LEADER_VAL));\n\n      // a reordered update that should be dropped\n      deleteAndGetVersion(\"B5\", params(SEEN_LEADER,SEEN_LEADER_VAL, \"_version_\",\"-950\"));\n\n      deleteAndGetVersion(\"B6\", params(SEEN_LEADER,SEEN_LEADER_VAL, \"_version_\",\"-2060\"));\n\n      logReplay.release(1000);\n      UpdateLog.RecoveryInfo recInfo = rinfoFuture.get();\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"id asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n                           + \"{'id':'B3','_version_':1030}\"\n                           + \",{'id':'B4','_version_':1040}\"\n                           + \",{'id':'B5','_version_':1050}\"\n                           + \",{'id':'B7','_version_':1070}\"\n                           +\"]\"\n      );\n\n      assertEquals(1, recInfo.deleteByQuery);\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a0c04b71951333291abc7f317109a6a5957bd28","date":1457097827,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestRecovery#testBuffering().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestRecovery#testBuffering().mjava","sourceNew":"  @Test\n  public void testBuffering() throws Exception {\n\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = new Runnable() {\n      @Override\n      public void run() {\n        logReplayFinish.release();\n      }\n    };\n\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n\n    try {\n      clearIndex();\n      assertU(commit());\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n      Future<UpdateLog.RecoveryInfo> rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture == null);\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"B1\", \"_version_\",\"1010\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B11\", \"_version_\",\"1015\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonDelQ(\"id:B1 id:B11 id:B2 id:B3\"), params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-1017\"));\n      updateJ(jsonAdd(sdoc(\"id\",\"B2\", \"_version_\",\"1020\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"1030\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B1\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2010\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      assertU(commit());\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      // updates should be buffered, so we should not see any results yet.\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==0\"\n      );\n\n      // real-time get should also not show anything (this could change in the future,\n      // but it's currently used for validating version numbers too, so it would\n      // be bad for updates to be visible if we're just buffering.\n      assertJQ(req(\"qt\",\"/get\", \"id\",\"B3\")\n          ,\"=={'doc':null}\"\n      );\n\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      logReplay.release(1000);\n\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==2\"\n      );\n\n      // move back to recovering\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Long ver = getVer(req(\"qt\",\"/get\", \"id\",\"B3\"));\n      assertEquals(1030L, ver.longValue());\n\n      // add a reordered doc that shouldn't overwrite one in the index\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"3\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // reorder two buffered updates\n      updateJ(jsonAdd(sdoc(\"id\",\"B4\", \"_version_\",\"1040\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B4\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-940\"));   // this update should not take affect\n      updateJ(jsonAdd(sdoc(\"id\",\"B6\", \"_version_\",\"1060\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B5\", \"_version_\",\"1050\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B8\", \"_version_\",\"1080\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // test that delete by query is at least buffered along with everything else so it will delete the\n      // currently buffered id:8 (even if it doesn't currently support versioning)\n      updateJ(\"{\\\"delete\\\": { \\\"query\\\":\\\"id:B2 OR id:B8\\\" }}\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-3000\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"13\")\n          ,\"=={'versions':[-3000,1080,1050,1060,-940,1040,3,-2010,1030,1020,-1017,1015,1010]}\"  // the \"3\" appears because versions aren't checked while buffering\n      );\n\n      logReplay.drainPermits();\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      // apply a single update\n      logReplay.release(1);\n\n      // now add another update\n      updateJ(jsonAdd(sdoc(\"id\",\"B7\", \"_version_\",\"1070\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // a reordered update that should be dropped\n      deleteAndGetVersion(\"B5\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-950\"));\n\n      deleteAndGetVersion(\"B6\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2060\"));\n\n      logReplay.release(1000);\n      UpdateLog.RecoveryInfo recInfo = rinfoFuture.get();\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"id asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n                           + \"{'id':'B3','_version_':1030}\"\n                           + \",{'id':'B4','_version_':1040}\"\n                           + \",{'id':'B5','_version_':1050}\"\n                           + \",{'id':'B7','_version_':1070}\"\n                           +\"]\"\n      );\n\n      assertEquals(1, recInfo.deleteByQuery);\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testBuffering() throws Exception {\n\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = new Runnable() {\n      @Override\n      public void run() {\n        try {\n          assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n        } catch (Exception e) {\n          throw new RuntimeException(e);\n        }\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = new Runnable() {\n      @Override\n      public void run() {\n        logReplayFinish.release();\n      }\n    };\n\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n\n    try {\n      clearIndex();\n      assertU(commit());\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n      Future<UpdateLog.RecoveryInfo> rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture == null);\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"B1\", \"_version_\",\"1010\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B11\", \"_version_\",\"1015\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonDelQ(\"id:B1 id:B11 id:B2 id:B3\"), params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-1017\"));\n      updateJ(jsonAdd(sdoc(\"id\",\"B2\", \"_version_\",\"1020\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"1030\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B1\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2010\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      assertU(commit());\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      // updates should be buffered, so we should not see any results yet.\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==0\"\n      );\n\n      // real-time get should also not show anything (this could change in the future,\n      // but it's currently used for validating version numbers too, so it would\n      // be bad for updates to be visible if we're just buffering.\n      assertJQ(req(\"qt\",\"/get\", \"id\",\"B3\")\n          ,\"=={'doc':null}\"\n      );\n\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      logReplay.release(1000);\n\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==2\"\n      );\n\n      // move back to recovering\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Long ver = getVer(req(\"qt\",\"/get\", \"id\",\"B3\"));\n      assertEquals(1030L, ver.longValue());\n\n      // add a reordered doc that shouldn't overwrite one in the index\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"3\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // reorder two buffered updates\n      updateJ(jsonAdd(sdoc(\"id\",\"B4\", \"_version_\",\"1040\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B4\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-940\"));   // this update should not take affect\n      updateJ(jsonAdd(sdoc(\"id\",\"B6\", \"_version_\",\"1060\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B5\", \"_version_\",\"1050\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B8\", \"_version_\",\"1080\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // test that delete by query is at least buffered along with everything else so it will delete the\n      // currently buffered id:8 (even if it doesn't currently support versioning)\n      updateJ(\"{\\\"delete\\\": { \\\"query\\\":\\\"id:B2 OR id:B8\\\" }}\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-3000\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"13\")\n          ,\"=={'versions':[-3000,1080,1050,1060,-940,1040,3,-2010,1030,1020,-1017,1015,1010]}\"  // the \"3\" appears because versions aren't checked while buffering\n      );\n\n      logReplay.drainPermits();\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      // apply a single update\n      logReplay.release(1);\n\n      // now add another update\n      updateJ(jsonAdd(sdoc(\"id\",\"B7\", \"_version_\",\"1070\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // a reordered update that should be dropped\n      deleteAndGetVersion(\"B5\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-950\"));\n\n      deleteAndGetVersion(\"B6\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2060\"));\n\n      logReplay.release(1000);\n      UpdateLog.RecoveryInfo recInfo = rinfoFuture.get();\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"id asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n                           + \"{'id':'B3','_version_':1030}\"\n                           + \",{'id':'B4','_version_':1040}\"\n                           + \",{'id':'B5','_version_':1050}\"\n                           + \",{'id':'B7','_version_':1070}\"\n                           +\"]\"\n      );\n\n      assertEquals(1, recInfo.deleteByQuery);\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"043df2e9a841864922c32756a44c939ed768cb89","date":1459876536,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestRecovery#testBuffering().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestRecovery#testBuffering().mjava","sourceNew":"  @Test\n  public void testBuffering() throws Exception {\n\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = logReplayFinish::release;\n\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n\n    try {\n      clearIndex();\n      assertU(commit());\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n      Future<UpdateLog.RecoveryInfo> rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture == null);\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"B1\", \"_version_\",\"1010\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B11\", \"_version_\",\"1015\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonDelQ(\"id:B1 id:B11 id:B2 id:B3\"), params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-1017\"));\n      updateJ(jsonAdd(sdoc(\"id\",\"B2\", \"_version_\",\"1020\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"1030\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B1\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2010\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      assertU(commit());\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      // updates should be buffered, so we should not see any results yet.\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==0\"\n      );\n\n      // real-time get should also not show anything (this could change in the future,\n      // but it's currently used for validating version numbers too, so it would\n      // be bad for updates to be visible if we're just buffering.\n      assertJQ(req(\"qt\",\"/get\", \"id\",\"B3\")\n          ,\"=={'doc':null}\"\n      );\n\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      logReplay.release(1000);\n\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==2\"\n      );\n\n      // move back to recovering\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Long ver = getVer(req(\"qt\",\"/get\", \"id\",\"B3\"));\n      assertEquals(1030L, ver.longValue());\n\n      // add a reordered doc that shouldn't overwrite one in the index\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"3\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // reorder two buffered updates\n      updateJ(jsonAdd(sdoc(\"id\",\"B4\", \"_version_\",\"1040\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B4\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-940\"));   // this update should not take affect\n      updateJ(jsonAdd(sdoc(\"id\",\"B6\", \"_version_\",\"1060\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B5\", \"_version_\",\"1050\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B8\", \"_version_\",\"1080\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // test that delete by query is at least buffered along with everything else so it will delete the\n      // currently buffered id:8 (even if it doesn't currently support versioning)\n      updateJ(\"{\\\"delete\\\": { \\\"query\\\":\\\"id:B2 OR id:B8\\\" }}\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-3000\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"13\")\n          ,\"=={'versions':[-3000,1080,1050,1060,-940,1040,3,-2010,1030,1020,-1017,1015,1010]}\"  // the \"3\" appears because versions aren't checked while buffering\n      );\n\n      logReplay.drainPermits();\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      // apply a single update\n      logReplay.release(1);\n\n      // now add another update\n      updateJ(jsonAdd(sdoc(\"id\",\"B7\", \"_version_\",\"1070\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // a reordered update that should be dropped\n      deleteAndGetVersion(\"B5\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-950\"));\n\n      deleteAndGetVersion(\"B6\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2060\"));\n\n      logReplay.release(1000);\n      UpdateLog.RecoveryInfo recInfo = rinfoFuture.get();\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"id asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n                           + \"{'id':'B3','_version_':1030}\"\n                           + \",{'id':'B4','_version_':1040}\"\n                           + \",{'id':'B5','_version_':1050}\"\n                           + \",{'id':'B7','_version_':1070}\"\n                           +\"]\"\n      );\n\n      assertEquals(1, recInfo.deleteByQuery);\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testBuffering() throws Exception {\n\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = new Runnable() {\n      @Override\n      public void run() {\n        logReplayFinish.release();\n      }\n    };\n\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n\n    try {\n      clearIndex();\n      assertU(commit());\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n      Future<UpdateLog.RecoveryInfo> rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture == null);\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"B1\", \"_version_\",\"1010\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B11\", \"_version_\",\"1015\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonDelQ(\"id:B1 id:B11 id:B2 id:B3\"), params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-1017\"));\n      updateJ(jsonAdd(sdoc(\"id\",\"B2\", \"_version_\",\"1020\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"1030\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B1\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2010\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      assertU(commit());\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      // updates should be buffered, so we should not see any results yet.\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==0\"\n      );\n\n      // real-time get should also not show anything (this could change in the future,\n      // but it's currently used for validating version numbers too, so it would\n      // be bad for updates to be visible if we're just buffering.\n      assertJQ(req(\"qt\",\"/get\", \"id\",\"B3\")\n          ,\"=={'doc':null}\"\n      );\n\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      logReplay.release(1000);\n\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==2\"\n      );\n\n      // move back to recovering\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Long ver = getVer(req(\"qt\",\"/get\", \"id\",\"B3\"));\n      assertEquals(1030L, ver.longValue());\n\n      // add a reordered doc that shouldn't overwrite one in the index\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"3\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // reorder two buffered updates\n      updateJ(jsonAdd(sdoc(\"id\",\"B4\", \"_version_\",\"1040\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B4\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-940\"));   // this update should not take affect\n      updateJ(jsonAdd(sdoc(\"id\",\"B6\", \"_version_\",\"1060\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B5\", \"_version_\",\"1050\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B8\", \"_version_\",\"1080\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // test that delete by query is at least buffered along with everything else so it will delete the\n      // currently buffered id:8 (even if it doesn't currently support versioning)\n      updateJ(\"{\\\"delete\\\": { \\\"query\\\":\\\"id:B2 OR id:B8\\\" }}\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-3000\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"13\")\n          ,\"=={'versions':[-3000,1080,1050,1060,-940,1040,3,-2010,1030,1020,-1017,1015,1010]}\"  // the \"3\" appears because versions aren't checked while buffering\n      );\n\n      logReplay.drainPermits();\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      // apply a single update\n      logReplay.release(1);\n\n      // now add another update\n      updateJ(jsonAdd(sdoc(\"id\",\"B7\", \"_version_\",\"1070\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // a reordered update that should be dropped\n      deleteAndGetVersion(\"B5\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-950\"));\n\n      deleteAndGetVersion(\"B6\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2060\"));\n\n      logReplay.release(1000);\n      UpdateLog.RecoveryInfo recInfo = rinfoFuture.get();\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"id asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n                           + \"{'id':'B3','_version_':1030}\"\n                           + \",{'id':'B4','_version_':1040}\"\n                           + \",{'id':'B5','_version_':1050}\"\n                           + \",{'id':'B7','_version_':1070}\"\n                           +\"]\"\n      );\n\n      assertEquals(1, recInfo.deleteByQuery);\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b6284684320a9808c41a5e43de958b2da22f89bd","date":1459977490,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestRecovery#testBuffering().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestRecovery#testBuffering().mjava","sourceNew":"  @Test\n  public void testBuffering() throws Exception {\n\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = logReplayFinish::release;\n\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n\n    try {\n      clearIndex();\n      assertU(commit());\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n      Future<UpdateLog.RecoveryInfo> rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture == null);\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"B1\", \"_version_\",\"1010\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B11\", \"_version_\",\"1015\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonDelQ(\"id:B1 id:B11 id:B2 id:B3\"), params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-1017\"));\n      updateJ(jsonAdd(sdoc(\"id\",\"B2\", \"_version_\",\"1020\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"1030\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B1\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2010\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      assertU(commit());\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      // updates should be buffered, so we should not see any results yet.\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==0\"\n      );\n\n      // real-time get should also not show anything (this could change in the future,\n      // but it's currently used for validating version numbers too, so it would\n      // be bad for updates to be visible if we're just buffering.\n      assertJQ(req(\"qt\",\"/get\", \"id\",\"B3\")\n          ,\"=={'doc':null}\"\n      );\n\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      logReplay.release(1000);\n\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==2\"\n      );\n\n      // move back to recovering\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Long ver = getVer(req(\"qt\",\"/get\", \"id\",\"B3\"));\n      assertEquals(1030L, ver.longValue());\n\n      // add a reordered doc that shouldn't overwrite one in the index\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"3\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // reorder two buffered updates\n      updateJ(jsonAdd(sdoc(\"id\",\"B4\", \"_version_\",\"1040\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B4\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-940\"));   // this update should not take affect\n      updateJ(jsonAdd(sdoc(\"id\",\"B6\", \"_version_\",\"1060\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B5\", \"_version_\",\"1050\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B8\", \"_version_\",\"1080\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // test that delete by query is at least buffered along with everything else so it will delete the\n      // currently buffered id:8 (even if it doesn't currently support versioning)\n      updateJ(\"{\\\"delete\\\": { \\\"query\\\":\\\"id:B2 OR id:B8\\\" }}\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-3000\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"13\")\n          ,\"=={'versions':[-3000,1080,1050,1060,-940,1040,3,-2010,1030,1020,-1017,1015,1010]}\"  // the \"3\" appears because versions aren't checked while buffering\n      );\n\n      logReplay.drainPermits();\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      // apply a single update\n      logReplay.release(1);\n\n      // now add another update\n      updateJ(jsonAdd(sdoc(\"id\",\"B7\", \"_version_\",\"1070\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // a reordered update that should be dropped\n      deleteAndGetVersion(\"B5\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-950\"));\n\n      deleteAndGetVersion(\"B6\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2060\"));\n\n      logReplay.release(1000);\n      UpdateLog.RecoveryInfo recInfo = rinfoFuture.get();\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"id asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n                           + \"{'id':'B3','_version_':1030}\"\n                           + \",{'id':'B4','_version_':1040}\"\n                           + \",{'id':'B5','_version_':1050}\"\n                           + \",{'id':'B7','_version_':1070}\"\n                           +\"]\"\n      );\n\n      assertEquals(1, recInfo.deleteByQuery);\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testBuffering() throws Exception {\n\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = new Runnable() {\n      @Override\n      public void run() {\n        logReplayFinish.release();\n      }\n    };\n\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n\n    try {\n      clearIndex();\n      assertU(commit());\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n      Future<UpdateLog.RecoveryInfo> rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture == null);\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"B1\", \"_version_\",\"1010\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B11\", \"_version_\",\"1015\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonDelQ(\"id:B1 id:B11 id:B2 id:B3\"), params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-1017\"));\n      updateJ(jsonAdd(sdoc(\"id\",\"B2\", \"_version_\",\"1020\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"1030\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B1\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2010\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      assertU(commit());\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      // updates should be buffered, so we should not see any results yet.\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==0\"\n      );\n\n      // real-time get should also not show anything (this could change in the future,\n      // but it's currently used for validating version numbers too, so it would\n      // be bad for updates to be visible if we're just buffering.\n      assertJQ(req(\"qt\",\"/get\", \"id\",\"B3\")\n          ,\"=={'doc':null}\"\n      );\n\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      logReplay.release(1000);\n\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==2\"\n      );\n\n      // move back to recovering\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Long ver = getVer(req(\"qt\",\"/get\", \"id\",\"B3\"));\n      assertEquals(1030L, ver.longValue());\n\n      // add a reordered doc that shouldn't overwrite one in the index\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"3\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // reorder two buffered updates\n      updateJ(jsonAdd(sdoc(\"id\",\"B4\", \"_version_\",\"1040\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B4\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-940\"));   // this update should not take affect\n      updateJ(jsonAdd(sdoc(\"id\",\"B6\", \"_version_\",\"1060\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B5\", \"_version_\",\"1050\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B8\", \"_version_\",\"1080\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // test that delete by query is at least buffered along with everything else so it will delete the\n      // currently buffered id:8 (even if it doesn't currently support versioning)\n      updateJ(\"{\\\"delete\\\": { \\\"query\\\":\\\"id:B2 OR id:B8\\\" }}\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-3000\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"13\")\n          ,\"=={'versions':[-3000,1080,1050,1060,-940,1040,3,-2010,1030,1020,-1017,1015,1010]}\"  // the \"3\" appears because versions aren't checked while buffering\n      );\n\n      logReplay.drainPermits();\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      // apply a single update\n      logReplay.release(1);\n\n      // now add another update\n      updateJ(jsonAdd(sdoc(\"id\",\"B7\", \"_version_\",\"1070\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // a reordered update that should be dropped\n      deleteAndGetVersion(\"B5\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-950\"));\n\n      deleteAndGetVersion(\"B6\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2060\"));\n\n      logReplay.release(1000);\n      UpdateLog.RecoveryInfo recInfo = rinfoFuture.get();\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"id asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n                           + \"{'id':'B3','_version_':1030}\"\n                           + \",{'id':'B4','_version_':1040}\"\n                           + \",{'id':'B5','_version_':1050}\"\n                           + \",{'id':'B7','_version_':1070}\"\n                           +\"]\"\n      );\n\n      assertEquals(1, recInfo.deleteByQuery);\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"268f09ed3a9a9b77003b15a5ae30386dc4e3721f","date":1483992000,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestRecovery#testBuffering().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestRecovery#testBuffering().mjava","sourceNew":"  @Test\n  public void testBuffering() throws Exception {\n\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = logReplayFinish::release;\n\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n\n    try {\n      clearIndex();\n      assertU(commit());\n\n      Map<String, Metric> metrics = getMetrics();\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Future<UpdateLog.RecoveryInfo> rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture == null);\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n      Gauge<Integer> state = (Gauge<Integer>)metrics.get(\"TLOG.state\");\n      assertEquals(UpdateLog.State.BUFFERING.ordinal(), state.getValue().intValue());\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"B1\", \"_version_\",\"1010\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B11\", \"_version_\",\"1015\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonDelQ(\"id:B1 id:B11 id:B2 id:B3\"), params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-1017\"));\n      updateJ(jsonAdd(sdoc(\"id\",\"B2\", \"_version_\",\"1020\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"1030\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B1\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2010\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      assertU(commit());\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      // updates should be buffered, so we should not see any results yet.\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==0\"\n      );\n\n      // real-time get should also not show anything (this could change in the future,\n      // but it's currently used for validating version numbers too, so it would\n      // be bad for updates to be visible if we're just buffering.\n      assertJQ(req(\"qt\",\"/get\", \"id\",\"B3\")\n          ,\"=={'doc':null}\"\n      );\n\n      Gauge<Integer> bufferedOps = (Gauge<Integer>)metrics.get(\"TLOG.buffered.ops\");\n      assertEquals(6, bufferedOps.getValue().intValue());\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      logReplay.release(1000);\n\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      Meter applyingBuffered = (Meter)metrics.get(\"TLOG.applying_buffered.ops\");\n      assertEquals(6L, applyingBuffered.getCount());\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==2\"\n      );\n\n      // move back to recovering\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Long ver = getVer(req(\"qt\",\"/get\", \"id\",\"B3\"));\n      assertEquals(1030L, ver.longValue());\n\n      // add a reordered doc that shouldn't overwrite one in the index\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"3\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // reorder two buffered updates\n      updateJ(jsonAdd(sdoc(\"id\",\"B4\", \"_version_\",\"1040\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B4\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-940\"));   // this update should not take affect\n      updateJ(jsonAdd(sdoc(\"id\",\"B6\", \"_version_\",\"1060\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B5\", \"_version_\",\"1050\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B8\", \"_version_\",\"1080\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // test that delete by query is at least buffered along with everything else so it will delete the\n      // currently buffered id:8 (even if it doesn't currently support versioning)\n      updateJ(\"{\\\"delete\\\": { \\\"query\\\":\\\"id:B2 OR id:B8\\\" }}\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-3000\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"13\")\n          ,\"=={'versions':[-3000,1080,1050,1060,-940,1040,3,-2010,1030,1020,-1017,1015,1010]}\"  // the \"3\" appears because versions aren't checked while buffering\n      );\n\n      logReplay.drainPermits();\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      // apply a single update\n      logReplay.release(1);\n\n      // now add another update\n      updateJ(jsonAdd(sdoc(\"id\",\"B7\", \"_version_\",\"1070\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // a reordered update that should be dropped\n      deleteAndGetVersion(\"B5\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-950\"));\n\n      deleteAndGetVersion(\"B6\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2060\"));\n\n      logReplay.release(1000);\n      UpdateLog.RecoveryInfo recInfo = rinfoFuture.get();\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"id asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n                           + \"{'id':'B3','_version_':1030}\"\n                           + \",{'id':'B4','_version_':1040}\"\n                           + \",{'id':'B5','_version_':1050}\"\n                           + \",{'id':'B7','_version_':1070}\"\n                           +\"]\"\n      );\n\n      assertEquals(1, recInfo.deleteByQuery);\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n\n      assertEquals(0, bufferedOps.getValue().intValue());\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testBuffering() throws Exception {\n\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = logReplayFinish::release;\n\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n\n    try {\n      clearIndex();\n      assertU(commit());\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n      Future<UpdateLog.RecoveryInfo> rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture == null);\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"B1\", \"_version_\",\"1010\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B11\", \"_version_\",\"1015\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonDelQ(\"id:B1 id:B11 id:B2 id:B3\"), params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-1017\"));\n      updateJ(jsonAdd(sdoc(\"id\",\"B2\", \"_version_\",\"1020\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"1030\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B1\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2010\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      assertU(commit());\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      // updates should be buffered, so we should not see any results yet.\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==0\"\n      );\n\n      // real-time get should also not show anything (this could change in the future,\n      // but it's currently used for validating version numbers too, so it would\n      // be bad for updates to be visible if we're just buffering.\n      assertJQ(req(\"qt\",\"/get\", \"id\",\"B3\")\n          ,\"=={'doc':null}\"\n      );\n\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      logReplay.release(1000);\n\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==2\"\n      );\n\n      // move back to recovering\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Long ver = getVer(req(\"qt\",\"/get\", \"id\",\"B3\"));\n      assertEquals(1030L, ver.longValue());\n\n      // add a reordered doc that shouldn't overwrite one in the index\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"3\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // reorder two buffered updates\n      updateJ(jsonAdd(sdoc(\"id\",\"B4\", \"_version_\",\"1040\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B4\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-940\"));   // this update should not take affect\n      updateJ(jsonAdd(sdoc(\"id\",\"B6\", \"_version_\",\"1060\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B5\", \"_version_\",\"1050\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B8\", \"_version_\",\"1080\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // test that delete by query is at least buffered along with everything else so it will delete the\n      // currently buffered id:8 (even if it doesn't currently support versioning)\n      updateJ(\"{\\\"delete\\\": { \\\"query\\\":\\\"id:B2 OR id:B8\\\" }}\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-3000\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"13\")\n          ,\"=={'versions':[-3000,1080,1050,1060,-940,1040,3,-2010,1030,1020,-1017,1015,1010]}\"  // the \"3\" appears because versions aren't checked while buffering\n      );\n\n      logReplay.drainPermits();\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      // apply a single update\n      logReplay.release(1);\n\n      // now add another update\n      updateJ(jsonAdd(sdoc(\"id\",\"B7\", \"_version_\",\"1070\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // a reordered update that should be dropped\n      deleteAndGetVersion(\"B5\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-950\"));\n\n      deleteAndGetVersion(\"B6\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2060\"));\n\n      logReplay.release(1000);\n      UpdateLog.RecoveryInfo recInfo = rinfoFuture.get();\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"id asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n                           + \"{'id':'B3','_version_':1030}\"\n                           + \",{'id':'B4','_version_':1040}\"\n                           + \",{'id':'B5','_version_':1050}\"\n                           + \",{'id':'B7','_version_':1070}\"\n                           +\"]\"\n      );\n\n      assertEquals(1, recInfo.deleteByQuery);\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":["0642d05afc07bfe3de944300b21fdbf1e17d3baf"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0642d05afc07bfe3de944300b21fdbf1e17d3baf","date":1484045056,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestRecovery#testBuffering().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestRecovery#testBuffering().mjava","sourceNew":"  @Test\n  public void testBuffering() throws Exception {\n\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = logReplayFinish::release;\n\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n\n    try {\n      clearIndex();\n      assertU(commit());\n\n      Map<String, Metric> metrics = getMetrics();\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Future<UpdateLog.RecoveryInfo> rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture == null);\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n      Gauge<Integer> state = (Gauge<Integer>)metrics.get(\"TLOG.state\");\n      assertEquals(UpdateLog.State.BUFFERING.ordinal(), state.getValue().intValue());\n      Gauge<Integer> bufferedOps = (Gauge<Integer>)metrics.get(\"TLOG.buffered.ops\");\n      int initialOps = bufferedOps.getValue();\n      Meter applyingBuffered = (Meter)metrics.get(\"TLOG.applying_buffered.ops\");\n      long initialApplyingOps = applyingBuffered.getCount();\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"B1\", \"_version_\",\"1010\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B11\", \"_version_\",\"1015\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonDelQ(\"id:B1 id:B11 id:B2 id:B3\"), params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-1017\"));\n      updateJ(jsonAdd(sdoc(\"id\",\"B2\", \"_version_\",\"1020\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"1030\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B1\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2010\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      assertU(commit());\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      // updates should be buffered, so we should not see any results yet.\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==0\"\n      );\n\n      // real-time get should also not show anything (this could change in the future,\n      // but it's currently used for validating version numbers too, so it would\n      // be bad for updates to be visible if we're just buffering.\n      assertJQ(req(\"qt\",\"/get\", \"id\",\"B3\")\n          ,\"=={'doc':null}\"\n      );\n\n      assertEquals(6, bufferedOps.getValue().intValue() - initialOps);\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      logReplay.release(1000);\n\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      assertEquals(6L, applyingBuffered.getCount() - initialApplyingOps);\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==2\"\n      );\n\n      // move back to recovering\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Long ver = getVer(req(\"qt\",\"/get\", \"id\",\"B3\"));\n      assertEquals(1030L, ver.longValue());\n\n      // add a reordered doc that shouldn't overwrite one in the index\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"3\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // reorder two buffered updates\n      updateJ(jsonAdd(sdoc(\"id\",\"B4\", \"_version_\",\"1040\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B4\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-940\"));   // this update should not take affect\n      updateJ(jsonAdd(sdoc(\"id\",\"B6\", \"_version_\",\"1060\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B5\", \"_version_\",\"1050\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B8\", \"_version_\",\"1080\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // test that delete by query is at least buffered along with everything else so it will delete the\n      // currently buffered id:8 (even if it doesn't currently support versioning)\n      updateJ(\"{\\\"delete\\\": { \\\"query\\\":\\\"id:B2 OR id:B8\\\" }}\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-3000\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"13\")\n          ,\"=={'versions':[-3000,1080,1050,1060,-940,1040,3,-2010,1030,1020,-1017,1015,1010]}\"  // the \"3\" appears because versions aren't checked while buffering\n      );\n\n      logReplay.drainPermits();\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      // apply a single update\n      logReplay.release(1);\n\n      // now add another update\n      updateJ(jsonAdd(sdoc(\"id\",\"B7\", \"_version_\",\"1070\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // a reordered update that should be dropped\n      deleteAndGetVersion(\"B5\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-950\"));\n\n      deleteAndGetVersion(\"B6\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2060\"));\n\n      logReplay.release(1000);\n      UpdateLog.RecoveryInfo recInfo = rinfoFuture.get();\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"id asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n                           + \"{'id':'B3','_version_':1030}\"\n                           + \",{'id':'B4','_version_':1040}\"\n                           + \",{'id':'B5','_version_':1050}\"\n                           + \",{'id':'B7','_version_':1070}\"\n                           +\"]\"\n      );\n\n      assertEquals(1, recInfo.deleteByQuery);\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n\n      assertEquals(0, bufferedOps.getValue().intValue());\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testBuffering() throws Exception {\n\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = logReplayFinish::release;\n\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n\n    try {\n      clearIndex();\n      assertU(commit());\n\n      Map<String, Metric> metrics = getMetrics();\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Future<UpdateLog.RecoveryInfo> rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture == null);\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n      Gauge<Integer> state = (Gauge<Integer>)metrics.get(\"TLOG.state\");\n      assertEquals(UpdateLog.State.BUFFERING.ordinal(), state.getValue().intValue());\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"B1\", \"_version_\",\"1010\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B11\", \"_version_\",\"1015\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonDelQ(\"id:B1 id:B11 id:B2 id:B3\"), params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-1017\"));\n      updateJ(jsonAdd(sdoc(\"id\",\"B2\", \"_version_\",\"1020\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"1030\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B1\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2010\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      assertU(commit());\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      // updates should be buffered, so we should not see any results yet.\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==0\"\n      );\n\n      // real-time get should also not show anything (this could change in the future,\n      // but it's currently used for validating version numbers too, so it would\n      // be bad for updates to be visible if we're just buffering.\n      assertJQ(req(\"qt\",\"/get\", \"id\",\"B3\")\n          ,\"=={'doc':null}\"\n      );\n\n      Gauge<Integer> bufferedOps = (Gauge<Integer>)metrics.get(\"TLOG.buffered.ops\");\n      assertEquals(6, bufferedOps.getValue().intValue());\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      logReplay.release(1000);\n\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      Meter applyingBuffered = (Meter)metrics.get(\"TLOG.applying_buffered.ops\");\n      assertEquals(6L, applyingBuffered.getCount());\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==2\"\n      );\n\n      // move back to recovering\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Long ver = getVer(req(\"qt\",\"/get\", \"id\",\"B3\"));\n      assertEquals(1030L, ver.longValue());\n\n      // add a reordered doc that shouldn't overwrite one in the index\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"3\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // reorder two buffered updates\n      updateJ(jsonAdd(sdoc(\"id\",\"B4\", \"_version_\",\"1040\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B4\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-940\"));   // this update should not take affect\n      updateJ(jsonAdd(sdoc(\"id\",\"B6\", \"_version_\",\"1060\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B5\", \"_version_\",\"1050\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B8\", \"_version_\",\"1080\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // test that delete by query is at least buffered along with everything else so it will delete the\n      // currently buffered id:8 (even if it doesn't currently support versioning)\n      updateJ(\"{\\\"delete\\\": { \\\"query\\\":\\\"id:B2 OR id:B8\\\" }}\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-3000\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"13\")\n          ,\"=={'versions':[-3000,1080,1050,1060,-940,1040,3,-2010,1030,1020,-1017,1015,1010]}\"  // the \"3\" appears because versions aren't checked while buffering\n      );\n\n      logReplay.drainPermits();\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      // apply a single update\n      logReplay.release(1);\n\n      // now add another update\n      updateJ(jsonAdd(sdoc(\"id\",\"B7\", \"_version_\",\"1070\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // a reordered update that should be dropped\n      deleteAndGetVersion(\"B5\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-950\"));\n\n      deleteAndGetVersion(\"B6\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2060\"));\n\n      logReplay.release(1000);\n      UpdateLog.RecoveryInfo recInfo = rinfoFuture.get();\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"id asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n                           + \"{'id':'B3','_version_':1030}\"\n                           + \",{'id':'B4','_version_':1040}\"\n                           + \",{'id':'B5','_version_':1050}\"\n                           + \",{'id':'B7','_version_':1070}\"\n                           +\"]\"\n      );\n\n      assertEquals(1, recInfo.deleteByQuery);\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n\n      assertEquals(0, bufferedOps.getValue().intValue());\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n\n  }\n\n","bugFix":["268f09ed3a9a9b77003b15a5ae30386dc4e3721f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9b10b88c8af8835e23b0d566418ef8397a7bb8ed","date":1484223252,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestRecovery#testBuffering().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestRecovery#testBuffering().mjava","sourceNew":"  @Test\n  public void testBuffering() throws Exception {\n\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = logReplayFinish::release;\n\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n\n    try {\n      clearIndex();\n      assertU(commit());\n\n      Map<String, Metric> metrics = getMetrics();\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Future<UpdateLog.RecoveryInfo> rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture == null);\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n      Gauge<Integer> state = (Gauge<Integer>)metrics.get(\"TLOG.state\");\n      assertEquals(UpdateLog.State.BUFFERING.ordinal(), state.getValue().intValue());\n      Gauge<Integer> bufferedOps = (Gauge<Integer>)metrics.get(\"TLOG.buffered.ops\");\n      int initialOps = bufferedOps.getValue();\n      Meter applyingBuffered = (Meter)metrics.get(\"TLOG.applyingBuffered.ops\");\n      long initialApplyingOps = applyingBuffered.getCount();\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"B1\", \"_version_\",\"1010\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B11\", \"_version_\",\"1015\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonDelQ(\"id:B1 id:B11 id:B2 id:B3\"), params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-1017\"));\n      updateJ(jsonAdd(sdoc(\"id\",\"B2\", \"_version_\",\"1020\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"1030\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B1\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2010\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      assertU(commit());\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      // updates should be buffered, so we should not see any results yet.\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==0\"\n      );\n\n      // real-time get should also not show anything (this could change in the future,\n      // but it's currently used for validating version numbers too, so it would\n      // be bad for updates to be visible if we're just buffering.\n      assertJQ(req(\"qt\",\"/get\", \"id\",\"B3\")\n          ,\"=={'doc':null}\"\n      );\n\n      assertEquals(6, bufferedOps.getValue().intValue() - initialOps);\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      logReplay.release(1000);\n\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      assertEquals(6L, applyingBuffered.getCount() - initialApplyingOps);\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==2\"\n      );\n\n      // move back to recovering\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Long ver = getVer(req(\"qt\",\"/get\", \"id\",\"B3\"));\n      assertEquals(1030L, ver.longValue());\n\n      // add a reordered doc that shouldn't overwrite one in the index\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"3\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // reorder two buffered updates\n      updateJ(jsonAdd(sdoc(\"id\",\"B4\", \"_version_\",\"1040\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B4\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-940\"));   // this update should not take affect\n      updateJ(jsonAdd(sdoc(\"id\",\"B6\", \"_version_\",\"1060\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B5\", \"_version_\",\"1050\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B8\", \"_version_\",\"1080\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // test that delete by query is at least buffered along with everything else so it will delete the\n      // currently buffered id:8 (even if it doesn't currently support versioning)\n      updateJ(\"{\\\"delete\\\": { \\\"query\\\":\\\"id:B2 OR id:B8\\\" }}\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-3000\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"13\")\n          ,\"=={'versions':[-3000,1080,1050,1060,-940,1040,3,-2010,1030,1020,-1017,1015,1010]}\"  // the \"3\" appears because versions aren't checked while buffering\n      );\n\n      logReplay.drainPermits();\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      // apply a single update\n      logReplay.release(1);\n\n      // now add another update\n      updateJ(jsonAdd(sdoc(\"id\",\"B7\", \"_version_\",\"1070\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // a reordered update that should be dropped\n      deleteAndGetVersion(\"B5\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-950\"));\n\n      deleteAndGetVersion(\"B6\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2060\"));\n\n      logReplay.release(1000);\n      UpdateLog.RecoveryInfo recInfo = rinfoFuture.get();\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"id asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n                           + \"{'id':'B3','_version_':1030}\"\n                           + \",{'id':'B4','_version_':1040}\"\n                           + \",{'id':'B5','_version_':1050}\"\n                           + \",{'id':'B7','_version_':1070}\"\n                           +\"]\"\n      );\n\n      assertEquals(1, recInfo.deleteByQuery);\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n\n      assertEquals(0, bufferedOps.getValue().intValue());\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testBuffering() throws Exception {\n\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = logReplayFinish::release;\n\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n\n    try {\n      clearIndex();\n      assertU(commit());\n\n      Map<String, Metric> metrics = getMetrics();\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Future<UpdateLog.RecoveryInfo> rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture == null);\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n      Gauge<Integer> state = (Gauge<Integer>)metrics.get(\"TLOG.state\");\n      assertEquals(UpdateLog.State.BUFFERING.ordinal(), state.getValue().intValue());\n      Gauge<Integer> bufferedOps = (Gauge<Integer>)metrics.get(\"TLOG.buffered.ops\");\n      int initialOps = bufferedOps.getValue();\n      Meter applyingBuffered = (Meter)metrics.get(\"TLOG.applying_buffered.ops\");\n      long initialApplyingOps = applyingBuffered.getCount();\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"B1\", \"_version_\",\"1010\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B11\", \"_version_\",\"1015\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonDelQ(\"id:B1 id:B11 id:B2 id:B3\"), params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-1017\"));\n      updateJ(jsonAdd(sdoc(\"id\",\"B2\", \"_version_\",\"1020\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"1030\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B1\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2010\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      assertU(commit());\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      // updates should be buffered, so we should not see any results yet.\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==0\"\n      );\n\n      // real-time get should also not show anything (this could change in the future,\n      // but it's currently used for validating version numbers too, so it would\n      // be bad for updates to be visible if we're just buffering.\n      assertJQ(req(\"qt\",\"/get\", \"id\",\"B3\")\n          ,\"=={'doc':null}\"\n      );\n\n      assertEquals(6, bufferedOps.getValue().intValue() - initialOps);\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      logReplay.release(1000);\n\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      assertEquals(6L, applyingBuffered.getCount() - initialApplyingOps);\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==2\"\n      );\n\n      // move back to recovering\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Long ver = getVer(req(\"qt\",\"/get\", \"id\",\"B3\"));\n      assertEquals(1030L, ver.longValue());\n\n      // add a reordered doc that shouldn't overwrite one in the index\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"3\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // reorder two buffered updates\n      updateJ(jsonAdd(sdoc(\"id\",\"B4\", \"_version_\",\"1040\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B4\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-940\"));   // this update should not take affect\n      updateJ(jsonAdd(sdoc(\"id\",\"B6\", \"_version_\",\"1060\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B5\", \"_version_\",\"1050\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B8\", \"_version_\",\"1080\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // test that delete by query is at least buffered along with everything else so it will delete the\n      // currently buffered id:8 (even if it doesn't currently support versioning)\n      updateJ(\"{\\\"delete\\\": { \\\"query\\\":\\\"id:B2 OR id:B8\\\" }}\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-3000\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"13\")\n          ,\"=={'versions':[-3000,1080,1050,1060,-940,1040,3,-2010,1030,1020,-1017,1015,1010]}\"  // the \"3\" appears because versions aren't checked while buffering\n      );\n\n      logReplay.drainPermits();\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      // apply a single update\n      logReplay.release(1);\n\n      // now add another update\n      updateJ(jsonAdd(sdoc(\"id\",\"B7\", \"_version_\",\"1070\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // a reordered update that should be dropped\n      deleteAndGetVersion(\"B5\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-950\"));\n\n      deleteAndGetVersion(\"B6\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2060\"));\n\n      logReplay.release(1000);\n      UpdateLog.RecoveryInfo recInfo = rinfoFuture.get();\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"id asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n                           + \"{'id':'B3','_version_':1030}\"\n                           + \",{'id':'B4','_version_':1040}\"\n                           + \",{'id':'B5','_version_':1050}\"\n                           + \",{'id':'B7','_version_':1070}\"\n                           +\"]\"\n      );\n\n      assertEquals(1, recInfo.deleteByQuery);\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n\n      assertEquals(0, bufferedOps.getValue().intValue());\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","date":1484239864,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestRecovery#testBuffering().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestRecovery#testBuffering().mjava","sourceNew":"  @Test\n  public void testBuffering() throws Exception {\n\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = logReplayFinish::release;\n\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n\n    try {\n      clearIndex();\n      assertU(commit());\n\n      Map<String, Metric> metrics = getMetrics();\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Future<UpdateLog.RecoveryInfo> rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture == null);\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n      Gauge<Integer> state = (Gauge<Integer>)metrics.get(\"TLOG.state\");\n      assertEquals(UpdateLog.State.BUFFERING.ordinal(), state.getValue().intValue());\n      Gauge<Integer> bufferedOps = (Gauge<Integer>)metrics.get(\"TLOG.buffered.ops\");\n      int initialOps = bufferedOps.getValue();\n      Meter applyingBuffered = (Meter)metrics.get(\"TLOG.applyingBuffered.ops\");\n      long initialApplyingOps = applyingBuffered.getCount();\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"B1\", \"_version_\",\"1010\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B11\", \"_version_\",\"1015\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonDelQ(\"id:B1 id:B11 id:B2 id:B3\"), params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-1017\"));\n      updateJ(jsonAdd(sdoc(\"id\",\"B2\", \"_version_\",\"1020\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"1030\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B1\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2010\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      assertU(commit());\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      // updates should be buffered, so we should not see any results yet.\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==0\"\n      );\n\n      // real-time get should also not show anything (this could change in the future,\n      // but it's currently used for validating version numbers too, so it would\n      // be bad for updates to be visible if we're just buffering.\n      assertJQ(req(\"qt\",\"/get\", \"id\",\"B3\")\n          ,\"=={'doc':null}\"\n      );\n\n      assertEquals(6, bufferedOps.getValue().intValue() - initialOps);\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      logReplay.release(1000);\n\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      assertEquals(6L, applyingBuffered.getCount() - initialApplyingOps);\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==2\"\n      );\n\n      // move back to recovering\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Long ver = getVer(req(\"qt\",\"/get\", \"id\",\"B3\"));\n      assertEquals(1030L, ver.longValue());\n\n      // add a reordered doc that shouldn't overwrite one in the index\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"3\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // reorder two buffered updates\n      updateJ(jsonAdd(sdoc(\"id\",\"B4\", \"_version_\",\"1040\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B4\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-940\"));   // this update should not take affect\n      updateJ(jsonAdd(sdoc(\"id\",\"B6\", \"_version_\",\"1060\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B5\", \"_version_\",\"1050\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B8\", \"_version_\",\"1080\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // test that delete by query is at least buffered along with everything else so it will delete the\n      // currently buffered id:8 (even if it doesn't currently support versioning)\n      updateJ(\"{\\\"delete\\\": { \\\"query\\\":\\\"id:B2 OR id:B8\\\" }}\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-3000\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"13\")\n          ,\"=={'versions':[-3000,1080,1050,1060,-940,1040,3,-2010,1030,1020,-1017,1015,1010]}\"  // the \"3\" appears because versions aren't checked while buffering\n      );\n\n      logReplay.drainPermits();\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      // apply a single update\n      logReplay.release(1);\n\n      // now add another update\n      updateJ(jsonAdd(sdoc(\"id\",\"B7\", \"_version_\",\"1070\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // a reordered update that should be dropped\n      deleteAndGetVersion(\"B5\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-950\"));\n\n      deleteAndGetVersion(\"B6\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2060\"));\n\n      logReplay.release(1000);\n      UpdateLog.RecoveryInfo recInfo = rinfoFuture.get();\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"id asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n                           + \"{'id':'B3','_version_':1030}\"\n                           + \",{'id':'B4','_version_':1040}\"\n                           + \",{'id':'B5','_version_':1050}\"\n                           + \",{'id':'B7','_version_':1070}\"\n                           +\"]\"\n      );\n\n      assertEquals(1, recInfo.deleteByQuery);\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n\n      assertEquals(0, bufferedOps.getValue().intValue());\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testBuffering() throws Exception {\n\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = logReplayFinish::release;\n\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n\n    try {\n      clearIndex();\n      assertU(commit());\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n      Future<UpdateLog.RecoveryInfo> rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture == null);\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"B1\", \"_version_\",\"1010\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B11\", \"_version_\",\"1015\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonDelQ(\"id:B1 id:B11 id:B2 id:B3\"), params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-1017\"));\n      updateJ(jsonAdd(sdoc(\"id\",\"B2\", \"_version_\",\"1020\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"1030\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B1\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2010\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      assertU(commit());\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      // updates should be buffered, so we should not see any results yet.\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==0\"\n      );\n\n      // real-time get should also not show anything (this could change in the future,\n      // but it's currently used for validating version numbers too, so it would\n      // be bad for updates to be visible if we're just buffering.\n      assertJQ(req(\"qt\",\"/get\", \"id\",\"B3\")\n          ,\"=={'doc':null}\"\n      );\n\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      logReplay.release(1000);\n\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==2\"\n      );\n\n      // move back to recovering\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Long ver = getVer(req(\"qt\",\"/get\", \"id\",\"B3\"));\n      assertEquals(1030L, ver.longValue());\n\n      // add a reordered doc that shouldn't overwrite one in the index\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"3\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // reorder two buffered updates\n      updateJ(jsonAdd(sdoc(\"id\",\"B4\", \"_version_\",\"1040\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B4\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-940\"));   // this update should not take affect\n      updateJ(jsonAdd(sdoc(\"id\",\"B6\", \"_version_\",\"1060\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B5\", \"_version_\",\"1050\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B8\", \"_version_\",\"1080\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // test that delete by query is at least buffered along with everything else so it will delete the\n      // currently buffered id:8 (even if it doesn't currently support versioning)\n      updateJ(\"{\\\"delete\\\": { \\\"query\\\":\\\"id:B2 OR id:B8\\\" }}\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-3000\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"13\")\n          ,\"=={'versions':[-3000,1080,1050,1060,-940,1040,3,-2010,1030,1020,-1017,1015,1010]}\"  // the \"3\" appears because versions aren't checked while buffering\n      );\n\n      logReplay.drainPermits();\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      // apply a single update\n      logReplay.release(1);\n\n      // now add another update\n      updateJ(jsonAdd(sdoc(\"id\",\"B7\", \"_version_\",\"1070\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // a reordered update that should be dropped\n      deleteAndGetVersion(\"B5\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-950\"));\n\n      deleteAndGetVersion(\"B6\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2060\"));\n\n      logReplay.release(1000);\n      UpdateLog.RecoveryInfo recInfo = rinfoFuture.get();\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"id asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n                           + \"{'id':'B3','_version_':1030}\"\n                           + \",{'id':'B4','_version_':1040}\"\n                           + \",{'id':'B5','_version_':1050}\"\n                           + \",{'id':'B7','_version_':1070}\"\n                           +\"]\"\n      );\n\n      assertEquals(1, recInfo.deleteByQuery);\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9efcb86f82b536ffcefcc27adbfa39b603342af1","date":1492147023,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestRecovery#testBuffering().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestRecovery#testBuffering().mjava","sourceNew":"  @Test\n  public void testBuffering() throws Exception {\n\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = logReplayFinish::release;\n\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n\n    try {\n      clearIndex();\n      assertU(commit());\n\n      Map<String, Metric> metrics = getMetrics();\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Future<UpdateLog.RecoveryInfo> rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture == null);\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n      Gauge<Integer> state = (Gauge<Integer>)metrics.get(\"TLOG.state\");\n      assertEquals(UpdateLog.State.BUFFERING.ordinal(), state.getValue().intValue());\n      Gauge<Integer> bufferedOps = (Gauge<Integer>)metrics.get(\"TLOG.buffered.ops\");\n      int initialOps = bufferedOps.getValue();\n      Meter applyingBuffered = (Meter)metrics.get(\"TLOG.applyingBuffered.ops\");\n      long initialApplyingOps = applyingBuffered.getCount();\n      \n      String v3 = getNextVersion();\n      String v940_del = \"-\" + getNextVersion();\n      String v950_del = \"-\" + getNextVersion();\n      String v1010 = getNextVersion();\n      String v1015 = getNextVersion();\n      String v1017_del = \"-\" + getNextVersion();\n      String v1020 = getNextVersion();\n      String v1030 = getNextVersion();\n      String v1040 = getNextVersion();\n      String v1050 = getNextVersion();\n      String v1060 = getNextVersion();\n      String v1070 = getNextVersion();\n      String v1080 = getNextVersion();\n      String v2010_del = \"-\" + getNextVersion();\n      String v2060_del = \"-\" + getNextVersion();\n      String v3000_del = \"-\" + getNextVersion();\n\n      String versionListFirstCheck = String.join(\",\", v2010_del, v1030, v1020, v1017_del, v1015, v1010);\n      String versionListSecondCheck = String.join(\",\", v3000_del, v1080, v1050, v1060, v940_del, v1040 ,v3, v2010_del, v1030, v1020, v1017_del, v1015, v1010);\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"B1\", \"_version_\",v1010)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B11\", \"_version_\",v1015)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonDelQ(\"id:B1 id:B11 id:B2 id:B3\"), params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",v1017_del));\n      updateJ(jsonAdd(sdoc(\"id\",\"B2\", \"_version_\",v1020)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",v1030)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B1\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",v2010_del));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[\"+versionListFirstCheck+\"]}\"\n      );\n\n      assertU(commit());\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[\"+versionListFirstCheck+\"]}\"\n      );\n\n      // updates should be buffered, so we should not see any results yet.\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==0\"\n      );\n\n      // real-time get should also not show anything (this could change in the future,\n      // but it's currently used for validating version numbers too, so it would\n      // be bad for updates to be visible if we're just buffering.\n      assertJQ(req(\"qt\",\"/get\", \"id\",\"B3\")\n          ,\"=={'doc':null}\"\n      );\n\n      assertEquals(6, bufferedOps.getValue().intValue() - initialOps);\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      logReplay.release(1000);\n\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      assertEquals(6L, applyingBuffered.getCount() - initialApplyingOps);\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[\"+versionListFirstCheck+\"]}\"\n      );\n\n\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==2\"\n      );\n\n      // move back to recovering\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Long ver = getVer(req(\"qt\",\"/get\", \"id\",\"B3\"));\n      assertEquals(Long.valueOf(v1030), ver);\n\n      // add a reordered doc that shouldn't overwrite one in the index\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",v3)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // reorder two buffered updates\n      updateJ(jsonAdd(sdoc(\"id\",\"B4\", \"_version_\",v1040)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B4\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",v940_del));   // this update should not take affect\n      updateJ(jsonAdd(sdoc(\"id\",\"B6\", \"_version_\",v1060)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B5\", \"_version_\",v1050)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B8\", \"_version_\",v1080)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // test that delete by query is at least buffered along with everything else so it will delete the\n      // currently buffered id:8 (even if it doesn't currently support versioning)\n      updateJ(\"{\\\"delete\\\": { \\\"query\\\":\\\"id:B2 OR id:B8\\\" }}\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",v3000_del));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"13\")\n          ,\"=={'versions':[\" + versionListSecondCheck + \"]}\"  // the \"3\" appears because versions aren't checked while buffering\n      );\n\n      logReplay.drainPermits();\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      // apply a single update\n      logReplay.release(1);\n\n      // now add another update\n      updateJ(jsonAdd(sdoc(\"id\",\"B7\", \"_version_\",v1070)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // a reordered update that should be dropped\n      deleteAndGetVersion(\"B5\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",v950_del));\n\n      deleteAndGetVersion(\"B6\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",v2060_del));\n\n      logReplay.release(1000);\n      UpdateLog.RecoveryInfo recInfo = rinfoFuture.get();\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"id asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n                           + \"{'id':'B3','_version_':\"+v1030+\"}\"\n                           + \",{'id':'B4','_version_':\"+v1040+\"}\"\n                           + \",{'id':'B5','_version_':\"+v1050+\"}\"\n                           + \",{'id':'B7','_version_':\"+v1070+\"}\"\n                           +\"]\"\n      );\n\n      assertEquals(1, recInfo.deleteByQuery);\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n\n      assertEquals(0, bufferedOps.getValue().intValue());\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testBuffering() throws Exception {\n\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = logReplayFinish::release;\n\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n\n    try {\n      clearIndex();\n      assertU(commit());\n\n      Map<String, Metric> metrics = getMetrics();\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Future<UpdateLog.RecoveryInfo> rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture == null);\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n      Gauge<Integer> state = (Gauge<Integer>)metrics.get(\"TLOG.state\");\n      assertEquals(UpdateLog.State.BUFFERING.ordinal(), state.getValue().intValue());\n      Gauge<Integer> bufferedOps = (Gauge<Integer>)metrics.get(\"TLOG.buffered.ops\");\n      int initialOps = bufferedOps.getValue();\n      Meter applyingBuffered = (Meter)metrics.get(\"TLOG.applyingBuffered.ops\");\n      long initialApplyingOps = applyingBuffered.getCount();\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"B1\", \"_version_\",\"1010\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B11\", \"_version_\",\"1015\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonDelQ(\"id:B1 id:B11 id:B2 id:B3\"), params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-1017\"));\n      updateJ(jsonAdd(sdoc(\"id\",\"B2\", \"_version_\",\"1020\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"1030\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B1\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2010\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      assertU(commit());\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      // updates should be buffered, so we should not see any results yet.\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==0\"\n      );\n\n      // real-time get should also not show anything (this could change in the future,\n      // but it's currently used for validating version numbers too, so it would\n      // be bad for updates to be visible if we're just buffering.\n      assertJQ(req(\"qt\",\"/get\", \"id\",\"B3\")\n          ,\"=={'doc':null}\"\n      );\n\n      assertEquals(6, bufferedOps.getValue().intValue() - initialOps);\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      logReplay.release(1000);\n\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      assertEquals(6L, applyingBuffered.getCount() - initialApplyingOps);\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==2\"\n      );\n\n      // move back to recovering\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Long ver = getVer(req(\"qt\",\"/get\", \"id\",\"B3\"));\n      assertEquals(1030L, ver.longValue());\n\n      // add a reordered doc that shouldn't overwrite one in the index\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"3\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // reorder two buffered updates\n      updateJ(jsonAdd(sdoc(\"id\",\"B4\", \"_version_\",\"1040\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B4\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-940\"));   // this update should not take affect\n      updateJ(jsonAdd(sdoc(\"id\",\"B6\", \"_version_\",\"1060\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B5\", \"_version_\",\"1050\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B8\", \"_version_\",\"1080\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // test that delete by query is at least buffered along with everything else so it will delete the\n      // currently buffered id:8 (even if it doesn't currently support versioning)\n      updateJ(\"{\\\"delete\\\": { \\\"query\\\":\\\"id:B2 OR id:B8\\\" }}\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-3000\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"13\")\n          ,\"=={'versions':[-3000,1080,1050,1060,-940,1040,3,-2010,1030,1020,-1017,1015,1010]}\"  // the \"3\" appears because versions aren't checked while buffering\n      );\n\n      logReplay.drainPermits();\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      // apply a single update\n      logReplay.release(1);\n\n      // now add another update\n      updateJ(jsonAdd(sdoc(\"id\",\"B7\", \"_version_\",\"1070\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // a reordered update that should be dropped\n      deleteAndGetVersion(\"B5\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-950\"));\n\n      deleteAndGetVersion(\"B6\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2060\"));\n\n      logReplay.release(1000);\n      UpdateLog.RecoveryInfo recInfo = rinfoFuture.get();\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"id asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n                           + \"{'id':'B3','_version_':1030}\"\n                           + \",{'id':'B4','_version_':1040}\"\n                           + \",{'id':'B5','_version_':1050}\"\n                           + \",{'id':'B7','_version_':1070}\"\n                           +\"]\"\n      );\n\n      assertEquals(1, recInfo.deleteByQuery);\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n\n      assertEquals(0, bufferedOps.getValue().intValue());\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestRecovery#testBuffering().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestRecovery#testBuffering().mjava","sourceNew":"  @Test\n  public void testBuffering() throws Exception {\n\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = logReplayFinish::release;\n\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n\n    try {\n      clearIndex();\n      assertU(commit());\n\n      Map<String, Metric> metrics = getMetrics();\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Future<UpdateLog.RecoveryInfo> rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture == null);\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n      Gauge<Integer> state = (Gauge<Integer>)metrics.get(\"TLOG.state\");\n      assertEquals(UpdateLog.State.BUFFERING.ordinal(), state.getValue().intValue());\n      Gauge<Integer> bufferedOps = (Gauge<Integer>)metrics.get(\"TLOG.buffered.ops\");\n      int initialOps = bufferedOps.getValue();\n      Meter applyingBuffered = (Meter)metrics.get(\"TLOG.applyingBuffered.ops\");\n      long initialApplyingOps = applyingBuffered.getCount();\n      \n      String v3 = getNextVersion();\n      String v940_del = \"-\" + getNextVersion();\n      String v950_del = \"-\" + getNextVersion();\n      String v1010 = getNextVersion();\n      String v1015 = getNextVersion();\n      String v1017_del = \"-\" + getNextVersion();\n      String v1020 = getNextVersion();\n      String v1030 = getNextVersion();\n      String v1040 = getNextVersion();\n      String v1050 = getNextVersion();\n      String v1060 = getNextVersion();\n      String v1070 = getNextVersion();\n      String v1080 = getNextVersion();\n      String v2010_del = \"-\" + getNextVersion();\n      String v2060_del = \"-\" + getNextVersion();\n      String v3000_del = \"-\" + getNextVersion();\n\n      String versionListFirstCheck = String.join(\",\", v2010_del, v1030, v1020, v1017_del, v1015, v1010);\n      String versionListSecondCheck = String.join(\",\", v3000_del, v1080, v1050, v1060, v940_del, v1040 ,v3, v2010_del, v1030, v1020, v1017_del, v1015, v1010);\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"B1\", \"_version_\",v1010)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B11\", \"_version_\",v1015)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonDelQ(\"id:B1 id:B11 id:B2 id:B3\"), params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",v1017_del));\n      updateJ(jsonAdd(sdoc(\"id\",\"B2\", \"_version_\",v1020)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",v1030)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B1\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",v2010_del));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[\"+versionListFirstCheck+\"]}\"\n      );\n\n      assertU(commit());\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[\"+versionListFirstCheck+\"]}\"\n      );\n\n      // updates should be buffered, so we should not see any results yet.\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==0\"\n      );\n\n      // real-time get should also not show anything (this could change in the future,\n      // but it's currently used for validating version numbers too, so it would\n      // be bad for updates to be visible if we're just buffering.\n      assertJQ(req(\"qt\",\"/get\", \"id\",\"B3\")\n          ,\"=={'doc':null}\"\n      );\n\n      assertEquals(6, bufferedOps.getValue().intValue() - initialOps);\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      logReplay.release(1000);\n\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      assertEquals(6L, applyingBuffered.getCount() - initialApplyingOps);\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[\"+versionListFirstCheck+\"]}\"\n      );\n\n\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==2\"\n      );\n\n      // move back to recovering\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Long ver = getVer(req(\"qt\",\"/get\", \"id\",\"B3\"));\n      assertEquals(Long.valueOf(v1030), ver);\n\n      // add a reordered doc that shouldn't overwrite one in the index\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",v3)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // reorder two buffered updates\n      updateJ(jsonAdd(sdoc(\"id\",\"B4\", \"_version_\",v1040)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B4\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",v940_del));   // this update should not take affect\n      updateJ(jsonAdd(sdoc(\"id\",\"B6\", \"_version_\",v1060)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B5\", \"_version_\",v1050)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B8\", \"_version_\",v1080)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // test that delete by query is at least buffered along with everything else so it will delete the\n      // currently buffered id:8 (even if it doesn't currently support versioning)\n      updateJ(\"{\\\"delete\\\": { \\\"query\\\":\\\"id:B2 OR id:B8\\\" }}\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",v3000_del));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"13\")\n          ,\"=={'versions':[\" + versionListSecondCheck + \"]}\"  // the \"3\" appears because versions aren't checked while buffering\n      );\n\n      logReplay.drainPermits();\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      // apply a single update\n      logReplay.release(1);\n\n      // now add another update\n      updateJ(jsonAdd(sdoc(\"id\",\"B7\", \"_version_\",v1070)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // a reordered update that should be dropped\n      deleteAndGetVersion(\"B5\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",v950_del));\n\n      deleteAndGetVersion(\"B6\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",v2060_del));\n\n      logReplay.release(1000);\n      UpdateLog.RecoveryInfo recInfo = rinfoFuture.get();\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"id asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n                           + \"{'id':'B3','_version_':\"+v1030+\"}\"\n                           + \",{'id':'B4','_version_':\"+v1040+\"}\"\n                           + \",{'id':'B5','_version_':\"+v1050+\"}\"\n                           + \",{'id':'B7','_version_':\"+v1070+\"}\"\n                           +\"]\"\n      );\n\n      assertEquals(1, recInfo.deleteByQuery);\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n\n      assertEquals(0, bufferedOps.getValue().intValue());\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testBuffering() throws Exception {\n\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = logReplayFinish::release;\n\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n\n    try {\n      clearIndex();\n      assertU(commit());\n\n      Map<String, Metric> metrics = getMetrics();\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Future<UpdateLog.RecoveryInfo> rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture == null);\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n      Gauge<Integer> state = (Gauge<Integer>)metrics.get(\"TLOG.state\");\n      assertEquals(UpdateLog.State.BUFFERING.ordinal(), state.getValue().intValue());\n      Gauge<Integer> bufferedOps = (Gauge<Integer>)metrics.get(\"TLOG.buffered.ops\");\n      int initialOps = bufferedOps.getValue();\n      Meter applyingBuffered = (Meter)metrics.get(\"TLOG.applyingBuffered.ops\");\n      long initialApplyingOps = applyingBuffered.getCount();\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"B1\", \"_version_\",\"1010\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B11\", \"_version_\",\"1015\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonDelQ(\"id:B1 id:B11 id:B2 id:B3\"), params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-1017\"));\n      updateJ(jsonAdd(sdoc(\"id\",\"B2\", \"_version_\",\"1020\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"1030\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B1\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2010\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      assertU(commit());\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      // updates should be buffered, so we should not see any results yet.\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==0\"\n      );\n\n      // real-time get should also not show anything (this could change in the future,\n      // but it's currently used for validating version numbers too, so it would\n      // be bad for updates to be visible if we're just buffering.\n      assertJQ(req(\"qt\",\"/get\", \"id\",\"B3\")\n          ,\"=={'doc':null}\"\n      );\n\n      assertEquals(6, bufferedOps.getValue().intValue() - initialOps);\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      logReplay.release(1000);\n\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      assertEquals(6L, applyingBuffered.getCount() - initialApplyingOps);\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==2\"\n      );\n\n      // move back to recovering\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Long ver = getVer(req(\"qt\",\"/get\", \"id\",\"B3\"));\n      assertEquals(1030L, ver.longValue());\n\n      // add a reordered doc that shouldn't overwrite one in the index\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"3\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // reorder two buffered updates\n      updateJ(jsonAdd(sdoc(\"id\",\"B4\", \"_version_\",\"1040\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B4\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-940\"));   // this update should not take affect\n      updateJ(jsonAdd(sdoc(\"id\",\"B6\", \"_version_\",\"1060\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B5\", \"_version_\",\"1050\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B8\", \"_version_\",\"1080\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // test that delete by query is at least buffered along with everything else so it will delete the\n      // currently buffered id:8 (even if it doesn't currently support versioning)\n      updateJ(\"{\\\"delete\\\": { \\\"query\\\":\\\"id:B2 OR id:B8\\\" }}\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-3000\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"13\")\n          ,\"=={'versions':[-3000,1080,1050,1060,-940,1040,3,-2010,1030,1020,-1017,1015,1010]}\"  // the \"3\" appears because versions aren't checked while buffering\n      );\n\n      logReplay.drainPermits();\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      // apply a single update\n      logReplay.release(1);\n\n      // now add another update\n      updateJ(jsonAdd(sdoc(\"id\",\"B7\", \"_version_\",\"1070\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // a reordered update that should be dropped\n      deleteAndGetVersion(\"B5\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-950\"));\n\n      deleteAndGetVersion(\"B6\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2060\"));\n\n      logReplay.release(1000);\n      UpdateLog.RecoveryInfo recInfo = rinfoFuture.get();\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"id asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n                           + \"{'id':'B3','_version_':1030}\"\n                           + \",{'id':'B4','_version_':1040}\"\n                           + \",{'id':'B5','_version_':1050}\"\n                           + \",{'id':'B7','_version_':1070}\"\n                           +\"]\"\n      );\n\n      assertEquals(1, recInfo.deleteByQuery);\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n\n      assertEquals(0, bufferedOps.getValue().intValue());\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b6a0ad05ae2af8aa028b1a6099a8222fad0bc8c1","date":1579200426,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestRecovery#testBuffering().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestRecovery#testBuffering().mjava","sourceNew":"  @Test\n  public void testBuffering() throws Exception {\n\n    TestInjection.skipIndexWriterCommitOnClose = true;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = logReplayFinish::release;\n\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n\n    try {\n      clearIndex();\n      assertU(commit());\n\n      Map<String, Metric> metrics = getMetrics();\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Future<UpdateLog.RecoveryInfo> rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture == null);\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n      Gauge<Integer> state = (Gauge<Integer>)metrics.get(\"TLOG.state\");\n      assertEquals(UpdateLog.State.BUFFERING.ordinal(), state.getValue().intValue());\n      Gauge<Integer> bufferedOps = (Gauge<Integer>)metrics.get(\"TLOG.buffered.ops\");\n      int initialOps = bufferedOps.getValue();\n      Meter applyingBuffered = (Meter)metrics.get(\"TLOG.applyingBuffered.ops\");\n      long initialApplyingOps = applyingBuffered.getCount();\n      \n      String v3 = getNextVersion();\n      String v940_del = \"-\" + getNextVersion();\n      String v950_del = \"-\" + getNextVersion();\n      String v1010 = getNextVersion();\n      String v1015 = getNextVersion();\n      String v1017_del = \"-\" + getNextVersion();\n      String v1020 = getNextVersion();\n      String v1030 = getNextVersion();\n      String v1040 = getNextVersion();\n      String v1050 = getNextVersion();\n      String v1060 = getNextVersion();\n      String v1070 = getNextVersion();\n      String v1080 = getNextVersion();\n      String v2010_del = \"-\" + getNextVersion();\n      String v2060_del = \"-\" + getNextVersion();\n      String v3000_del = \"-\" + getNextVersion();\n\n      String versionListFirstCheck = String.join(\",\", v2010_del, v1030, v1020, v1017_del, v1015, v1010);\n      String versionListSecondCheck = String.join(\",\", v3000_del, v1080, v1050, v1060, v940_del, v1040 ,v3, v2010_del, v1030, v1020, v1017_del, v1015, v1010);\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"B1\", \"_version_\",v1010)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B11\", \"_version_\",v1015)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonDelQ(\"id:B1 id:B11 id:B2 id:B3\"), params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",v1017_del));\n      updateJ(jsonAdd(sdoc(\"id\",\"B2\", \"_version_\",v1020)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",v1030)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B1\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",v2010_del));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[\"+versionListFirstCheck+\"]}\"\n      );\n\n      assertU(commit());\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[\"+versionListFirstCheck+\"]}\"\n      );\n\n      // updates should be buffered, so we should not see any results yet.\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==0\"\n      );\n\n      // real-time get should also not show anything (this could change in the future,\n      // but it's currently used for validating version numbers too, so it would\n      // be bad for updates to be visible if we're just buffering.\n      assertJQ(req(\"qt\",\"/get\", \"id\",\"B3\")\n          ,\"=={'doc':null}\"\n      );\n\n      assertEquals(6, bufferedOps.getValue().intValue() - initialOps);\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      logReplay.release(1000);\n\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      assertEquals(6L, applyingBuffered.getCount() - initialApplyingOps);\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[\"+versionListFirstCheck+\"]}\"\n      );\n\n\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==2\"\n      );\n\n      // move back to recovering\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Long ver = getVer(req(\"qt\",\"/get\", \"id\",\"B3\"));\n      assertEquals(Long.valueOf(v1030), ver);\n\n      // add a reordered doc that shouldn't overwrite one in the index\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",v3)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // reorder two buffered updates\n      updateJ(jsonAdd(sdoc(\"id\",\"B4\", \"_version_\",v1040)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B4\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",v940_del));   // this update should not take affect\n      updateJ(jsonAdd(sdoc(\"id\",\"B6\", \"_version_\",v1060)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B5\", \"_version_\",v1050)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B8\", \"_version_\",v1080)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // test that delete by query is at least buffered along with everything else so it will delete the\n      // currently buffered id:8 (even if it doesn't currently support versioning)\n      updateJ(\"{\\\"delete\\\": { \\\"query\\\":\\\"id:B2 OR id:B8\\\" }}\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",v3000_del));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"13\")\n          ,\"=={'versions':[\" + versionListSecondCheck + \"]}\"  // the \"3\" appears because versions aren't checked while buffering\n      );\n\n      logReplay.drainPermits();\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      // apply a single update\n      logReplay.release(1);\n\n      // now add another update\n      updateJ(jsonAdd(sdoc(\"id\",\"B7\", \"_version_\",v1070)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // a reordered update that should be dropped\n      deleteAndGetVersion(\"B5\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",v950_del));\n\n      deleteAndGetVersion(\"B6\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",v2060_del));\n\n      logReplay.release(1000);\n      UpdateLog.RecoveryInfo recInfo = rinfoFuture.get();\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"id asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n                           + \"{'id':'B3','_version_':\"+v1030+\"}\"\n                           + \",{'id':'B4','_version_':\"+v1040+\"}\"\n                           + \",{'id':'B5','_version_':\"+v1050+\"}\"\n                           + \",{'id':'B7','_version_':\"+v1070+\"}\"\n                           +\"]\"\n      );\n\n      assertEquals(1, recInfo.deleteByQuery);\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n\n      assertEquals(0, bufferedOps.getValue().intValue());\n    } finally {\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testBuffering() throws Exception {\n\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = logReplayFinish::release;\n\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n\n    try {\n      clearIndex();\n      assertU(commit());\n\n      Map<String, Metric> metrics = getMetrics();\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Future<UpdateLog.RecoveryInfo> rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture == null);\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n      Gauge<Integer> state = (Gauge<Integer>)metrics.get(\"TLOG.state\");\n      assertEquals(UpdateLog.State.BUFFERING.ordinal(), state.getValue().intValue());\n      Gauge<Integer> bufferedOps = (Gauge<Integer>)metrics.get(\"TLOG.buffered.ops\");\n      int initialOps = bufferedOps.getValue();\n      Meter applyingBuffered = (Meter)metrics.get(\"TLOG.applyingBuffered.ops\");\n      long initialApplyingOps = applyingBuffered.getCount();\n      \n      String v3 = getNextVersion();\n      String v940_del = \"-\" + getNextVersion();\n      String v950_del = \"-\" + getNextVersion();\n      String v1010 = getNextVersion();\n      String v1015 = getNextVersion();\n      String v1017_del = \"-\" + getNextVersion();\n      String v1020 = getNextVersion();\n      String v1030 = getNextVersion();\n      String v1040 = getNextVersion();\n      String v1050 = getNextVersion();\n      String v1060 = getNextVersion();\n      String v1070 = getNextVersion();\n      String v1080 = getNextVersion();\n      String v2010_del = \"-\" + getNextVersion();\n      String v2060_del = \"-\" + getNextVersion();\n      String v3000_del = \"-\" + getNextVersion();\n\n      String versionListFirstCheck = String.join(\",\", v2010_del, v1030, v1020, v1017_del, v1015, v1010);\n      String versionListSecondCheck = String.join(\",\", v3000_del, v1080, v1050, v1060, v940_del, v1040 ,v3, v2010_del, v1030, v1020, v1017_del, v1015, v1010);\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"B1\", \"_version_\",v1010)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B11\", \"_version_\",v1015)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonDelQ(\"id:B1 id:B11 id:B2 id:B3\"), params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",v1017_del));\n      updateJ(jsonAdd(sdoc(\"id\",\"B2\", \"_version_\",v1020)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",v1030)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B1\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",v2010_del));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[\"+versionListFirstCheck+\"]}\"\n      );\n\n      assertU(commit());\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[\"+versionListFirstCheck+\"]}\"\n      );\n\n      // updates should be buffered, so we should not see any results yet.\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==0\"\n      );\n\n      // real-time get should also not show anything (this could change in the future,\n      // but it's currently used for validating version numbers too, so it would\n      // be bad for updates to be visible if we're just buffering.\n      assertJQ(req(\"qt\",\"/get\", \"id\",\"B3\")\n          ,\"=={'doc':null}\"\n      );\n\n      assertEquals(6, bufferedOps.getValue().intValue() - initialOps);\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      logReplay.release(1000);\n\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      assertEquals(6L, applyingBuffered.getCount() - initialApplyingOps);\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[\"+versionListFirstCheck+\"]}\"\n      );\n\n\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==2\"\n      );\n\n      // move back to recovering\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Long ver = getVer(req(\"qt\",\"/get\", \"id\",\"B3\"));\n      assertEquals(Long.valueOf(v1030), ver);\n\n      // add a reordered doc that shouldn't overwrite one in the index\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",v3)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // reorder two buffered updates\n      updateJ(jsonAdd(sdoc(\"id\",\"B4\", \"_version_\",v1040)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B4\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",v940_del));   // this update should not take affect\n      updateJ(jsonAdd(sdoc(\"id\",\"B6\", \"_version_\",v1060)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B5\", \"_version_\",v1050)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B8\", \"_version_\",v1080)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // test that delete by query is at least buffered along with everything else so it will delete the\n      // currently buffered id:8 (even if it doesn't currently support versioning)\n      updateJ(\"{\\\"delete\\\": { \\\"query\\\":\\\"id:B2 OR id:B8\\\" }}\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",v3000_del));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"13\")\n          ,\"=={'versions':[\" + versionListSecondCheck + \"]}\"  // the \"3\" appears because versions aren't checked while buffering\n      );\n\n      logReplay.drainPermits();\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      // apply a single update\n      logReplay.release(1);\n\n      // now add another update\n      updateJ(jsonAdd(sdoc(\"id\",\"B7\", \"_version_\",v1070)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // a reordered update that should be dropped\n      deleteAndGetVersion(\"B5\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",v950_del));\n\n      deleteAndGetVersion(\"B6\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",v2060_del));\n\n      logReplay.release(1000);\n      UpdateLog.RecoveryInfo recInfo = rinfoFuture.get();\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"id asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n                           + \"{'id':'B3','_version_':\"+v1030+\"}\"\n                           + \",{'id':'B4','_version_':\"+v1040+\"}\"\n                           + \",{'id':'B5','_version_':\"+v1050+\"}\"\n                           + \",{'id':'B7','_version_':\"+v1070+\"}\"\n                           +\"]\"\n      );\n\n      assertEquals(1, recInfo.deleteByQuery);\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n\n      assertEquals(0, bufferedOps.getValue().intValue());\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e98520789adb1d5ad05afb4956eca0944a929688","date":1592430701,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestRecovery#testBuffering().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestRecovery#testBuffering().mjava","sourceNew":"  @Test\n  public void testBuffering() throws Exception {\n\n    TestInjection.skipIndexWriterCommitOnClose = true;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = logReplayFinish::release;\n\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n\n    try {\n      clearIndex();\n      assertU(commit());\n\n      Map<String, Metric> metrics = getMetrics();\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Future<UpdateLog.RecoveryInfo> rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture == null);\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n      @SuppressWarnings({\"unchecked\"})\n      Gauge<Integer> state = (Gauge<Integer>)metrics.get(\"TLOG.state\");\n      assertEquals(UpdateLog.State.BUFFERING.ordinal(), state.getValue().intValue());\n      @SuppressWarnings({\"unchecked\"})\n      Gauge<Integer> bufferedOps = (Gauge<Integer>)metrics.get(\"TLOG.buffered.ops\");\n      int initialOps = bufferedOps.getValue();\n      Meter applyingBuffered = (Meter)metrics.get(\"TLOG.applyingBuffered.ops\");\n      long initialApplyingOps = applyingBuffered.getCount();\n      \n      String v3 = getNextVersion();\n      String v940_del = \"-\" + getNextVersion();\n      String v950_del = \"-\" + getNextVersion();\n      String v1010 = getNextVersion();\n      String v1015 = getNextVersion();\n      String v1017_del = \"-\" + getNextVersion();\n      String v1020 = getNextVersion();\n      String v1030 = getNextVersion();\n      String v1040 = getNextVersion();\n      String v1050 = getNextVersion();\n      String v1060 = getNextVersion();\n      String v1070 = getNextVersion();\n      String v1080 = getNextVersion();\n      String v2010_del = \"-\" + getNextVersion();\n      String v2060_del = \"-\" + getNextVersion();\n      String v3000_del = \"-\" + getNextVersion();\n\n      String versionListFirstCheck = String.join(\",\", v2010_del, v1030, v1020, v1017_del, v1015, v1010);\n      String versionListSecondCheck = String.join(\",\", v3000_del, v1080, v1050, v1060, v940_del, v1040 ,v3, v2010_del, v1030, v1020, v1017_del, v1015, v1010);\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"B1\", \"_version_\",v1010)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B11\", \"_version_\",v1015)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonDelQ(\"id:B1 id:B11 id:B2 id:B3\"), params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",v1017_del));\n      updateJ(jsonAdd(sdoc(\"id\",\"B2\", \"_version_\",v1020)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",v1030)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B1\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",v2010_del));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[\"+versionListFirstCheck+\"]}\"\n      );\n\n      assertU(commit());\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[\"+versionListFirstCheck+\"]}\"\n      );\n\n      // updates should be buffered, so we should not see any results yet.\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==0\"\n      );\n\n      // real-time get should also not show anything (this could change in the future,\n      // but it's currently used for validating version numbers too, so it would\n      // be bad for updates to be visible if we're just buffering.\n      assertJQ(req(\"qt\",\"/get\", \"id\",\"B3\")\n          ,\"=={'doc':null}\"\n      );\n\n      assertEquals(6, bufferedOps.getValue().intValue() - initialOps);\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      logReplay.release(1000);\n\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      assertEquals(6L, applyingBuffered.getCount() - initialApplyingOps);\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[\"+versionListFirstCheck+\"]}\"\n      );\n\n\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==2\"\n      );\n\n      // move back to recovering\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Long ver = getVer(req(\"qt\",\"/get\", \"id\",\"B3\"));\n      assertEquals(Long.valueOf(v1030), ver);\n\n      // add a reordered doc that shouldn't overwrite one in the index\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",v3)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // reorder two buffered updates\n      updateJ(jsonAdd(sdoc(\"id\",\"B4\", \"_version_\",v1040)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B4\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",v940_del));   // this update should not take affect\n      updateJ(jsonAdd(sdoc(\"id\",\"B6\", \"_version_\",v1060)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B5\", \"_version_\",v1050)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B8\", \"_version_\",v1080)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // test that delete by query is at least buffered along with everything else so it will delete the\n      // currently buffered id:8 (even if it doesn't currently support versioning)\n      updateJ(\"{\\\"delete\\\": { \\\"query\\\":\\\"id:B2 OR id:B8\\\" }}\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",v3000_del));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"13\")\n          ,\"=={'versions':[\" + versionListSecondCheck + \"]}\"  // the \"3\" appears because versions aren't checked while buffering\n      );\n\n      logReplay.drainPermits();\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      // apply a single update\n      logReplay.release(1);\n\n      // now add another update\n      updateJ(jsonAdd(sdoc(\"id\",\"B7\", \"_version_\",v1070)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // a reordered update that should be dropped\n      deleteAndGetVersion(\"B5\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",v950_del));\n\n      deleteAndGetVersion(\"B6\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",v2060_del));\n\n      logReplay.release(1000);\n      UpdateLog.RecoveryInfo recInfo = rinfoFuture.get();\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"id asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n                           + \"{'id':'B3','_version_':\"+v1030+\"}\"\n                           + \",{'id':'B4','_version_':\"+v1040+\"}\"\n                           + \",{'id':'B5','_version_':\"+v1050+\"}\"\n                           + \",{'id':'B7','_version_':\"+v1070+\"}\"\n                           +\"]\"\n      );\n\n      assertEquals(1, recInfo.deleteByQuery);\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n\n      assertEquals(0, bufferedOps.getValue().intValue());\n    } finally {\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testBuffering() throws Exception {\n\n    TestInjection.skipIndexWriterCommitOnClose = true;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = logReplayFinish::release;\n\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n\n    try {\n      clearIndex();\n      assertU(commit());\n\n      Map<String, Metric> metrics = getMetrics();\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Future<UpdateLog.RecoveryInfo> rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture == null);\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n      Gauge<Integer> state = (Gauge<Integer>)metrics.get(\"TLOG.state\");\n      assertEquals(UpdateLog.State.BUFFERING.ordinal(), state.getValue().intValue());\n      Gauge<Integer> bufferedOps = (Gauge<Integer>)metrics.get(\"TLOG.buffered.ops\");\n      int initialOps = bufferedOps.getValue();\n      Meter applyingBuffered = (Meter)metrics.get(\"TLOG.applyingBuffered.ops\");\n      long initialApplyingOps = applyingBuffered.getCount();\n      \n      String v3 = getNextVersion();\n      String v940_del = \"-\" + getNextVersion();\n      String v950_del = \"-\" + getNextVersion();\n      String v1010 = getNextVersion();\n      String v1015 = getNextVersion();\n      String v1017_del = \"-\" + getNextVersion();\n      String v1020 = getNextVersion();\n      String v1030 = getNextVersion();\n      String v1040 = getNextVersion();\n      String v1050 = getNextVersion();\n      String v1060 = getNextVersion();\n      String v1070 = getNextVersion();\n      String v1080 = getNextVersion();\n      String v2010_del = \"-\" + getNextVersion();\n      String v2060_del = \"-\" + getNextVersion();\n      String v3000_del = \"-\" + getNextVersion();\n\n      String versionListFirstCheck = String.join(\",\", v2010_del, v1030, v1020, v1017_del, v1015, v1010);\n      String versionListSecondCheck = String.join(\",\", v3000_del, v1080, v1050, v1060, v940_del, v1040 ,v3, v2010_del, v1030, v1020, v1017_del, v1015, v1010);\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"B1\", \"_version_\",v1010)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B11\", \"_version_\",v1015)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonDelQ(\"id:B1 id:B11 id:B2 id:B3\"), params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",v1017_del));\n      updateJ(jsonAdd(sdoc(\"id\",\"B2\", \"_version_\",v1020)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",v1030)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B1\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",v2010_del));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[\"+versionListFirstCheck+\"]}\"\n      );\n\n      assertU(commit());\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[\"+versionListFirstCheck+\"]}\"\n      );\n\n      // updates should be buffered, so we should not see any results yet.\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==0\"\n      );\n\n      // real-time get should also not show anything (this could change in the future,\n      // but it's currently used for validating version numbers too, so it would\n      // be bad for updates to be visible if we're just buffering.\n      assertJQ(req(\"qt\",\"/get\", \"id\",\"B3\")\n          ,\"=={'doc':null}\"\n      );\n\n      assertEquals(6, bufferedOps.getValue().intValue() - initialOps);\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      logReplay.release(1000);\n\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      assertEquals(6L, applyingBuffered.getCount() - initialApplyingOps);\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[\"+versionListFirstCheck+\"]}\"\n      );\n\n\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==2\"\n      );\n\n      // move back to recovering\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Long ver = getVer(req(\"qt\",\"/get\", \"id\",\"B3\"));\n      assertEquals(Long.valueOf(v1030), ver);\n\n      // add a reordered doc that shouldn't overwrite one in the index\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",v3)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // reorder two buffered updates\n      updateJ(jsonAdd(sdoc(\"id\",\"B4\", \"_version_\",v1040)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B4\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",v940_del));   // this update should not take affect\n      updateJ(jsonAdd(sdoc(\"id\",\"B6\", \"_version_\",v1060)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B5\", \"_version_\",v1050)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B8\", \"_version_\",v1080)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // test that delete by query is at least buffered along with everything else so it will delete the\n      // currently buffered id:8 (even if it doesn't currently support versioning)\n      updateJ(\"{\\\"delete\\\": { \\\"query\\\":\\\"id:B2 OR id:B8\\\" }}\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",v3000_del));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"13\")\n          ,\"=={'versions':[\" + versionListSecondCheck + \"]}\"  // the \"3\" appears because versions aren't checked while buffering\n      );\n\n      logReplay.drainPermits();\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      // apply a single update\n      logReplay.release(1);\n\n      // now add another update\n      updateJ(jsonAdd(sdoc(\"id\",\"B7\", \"_version_\",v1070)), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // a reordered update that should be dropped\n      deleteAndGetVersion(\"B5\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",v950_del));\n\n      deleteAndGetVersion(\"B6\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",v2060_del));\n\n      logReplay.release(1000);\n      UpdateLog.RecoveryInfo recInfo = rinfoFuture.get();\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"id asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n                           + \"{'id':'B3','_version_':\"+v1030+\"}\"\n                           + \",{'id':'B4','_version_':\"+v1040+\"}\"\n                           + \",{'id':'B5','_version_':\"+v1050+\"}\"\n                           + \",{'id':'B7','_version_':\"+v1070+\"}\"\n                           +\"]\"\n      );\n\n      assertEquals(1, recInfo.deleteByQuery);\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n\n      assertEquals(0, bufferedOps.getValue().intValue());\n    } finally {\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["9b10b88c8af8835e23b0d566418ef8397a7bb8ed"],"043df2e9a841864922c32756a44c939ed768cb89":["3a0c04b71951333291abc7f317109a6a5957bd28"],"9b10b88c8af8835e23b0d566418ef8397a7bb8ed":["0642d05afc07bfe3de944300b21fdbf1e17d3baf"],"268f09ed3a9a9b77003b15a5ae30386dc4e3721f":["b6284684320a9808c41a5e43de958b2da22f89bd"],"0642d05afc07bfe3de944300b21fdbf1e17d3baf":["268f09ed3a9a9b77003b15a5ae30386dc4e3721f"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7":["b6284684320a9808c41a5e43de958b2da22f89bd","9b10b88c8af8835e23b0d566418ef8397a7bb8ed"],"b6a0ad05ae2af8aa028b1a6099a8222fad0bc8c1":["9efcb86f82b536ffcefcc27adbfa39b603342af1"],"3a0c04b71951333291abc7f317109a6a5957bd28":["e2fe35ac47f8f51356d6c1724455d18f31c94fae"],"e98520789adb1d5ad05afb4956eca0944a929688":["b6a0ad05ae2af8aa028b1a6099a8222fad0bc8c1"],"9efcb86f82b536ffcefcc27adbfa39b603342af1":["9b10b88c8af8835e23b0d566418ef8397a7bb8ed"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"b6284684320a9808c41a5e43de958b2da22f89bd":["3a0c04b71951333291abc7f317109a6a5957bd28","043df2e9a841864922c32756a44c939ed768cb89"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"01e98f8ae83ed9c1151cd99b37a7371fd6754ac2":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e98520789adb1d5ad05afb4956eca0944a929688"],"e2fe35ac47f8f51356d6c1724455d18f31c94fae":["01e98f8ae83ed9c1151cd99b37a7371fd6754ac2"]},"commit2Childs":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":[],"043df2e9a841864922c32756a44c939ed768cb89":["b6284684320a9808c41a5e43de958b2da22f89bd"],"9b10b88c8af8835e23b0d566418ef8397a7bb8ed":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","9efcb86f82b536ffcefcc27adbfa39b603342af1"],"268f09ed3a9a9b77003b15a5ae30386dc4e3721f":["0642d05afc07bfe3de944300b21fdbf1e17d3baf"],"0642d05afc07bfe3de944300b21fdbf1e17d3baf":["9b10b88c8af8835e23b0d566418ef8397a7bb8ed"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":[],"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7":[],"b6a0ad05ae2af8aa028b1a6099a8222fad0bc8c1":["e98520789adb1d5ad05afb4956eca0944a929688"],"3a0c04b71951333291abc7f317109a6a5957bd28":["043df2e9a841864922c32756a44c939ed768cb89","b6284684320a9808c41a5e43de958b2da22f89bd"],"e98520789adb1d5ad05afb4956eca0944a929688":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9efcb86f82b536ffcefcc27adbfa39b603342af1":["b6a0ad05ae2af8aa028b1a6099a8222fad0bc8c1"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":[],"b6284684320a9808c41a5e43de958b2da22f89bd":["268f09ed3a9a9b77003b15a5ae30386dc4e3721f","09ab8ee44ca898536770d0106a7c0ee4be4f0eb7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","0d22ac6a4146774c1bc8400160fc0b6150294e92","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","0d22ac6a4146774c1bc8400160fc0b6150294e92","01e98f8ae83ed9c1151cd99b37a7371fd6754ac2"],"01e98f8ae83ed9c1151cd99b37a7371fd6754ac2":["e2fe35ac47f8f51356d6c1724455d18f31c94fae"],"e2fe35ac47f8f51356d6c1724455d18f31c94fae":["3a0c04b71951333291abc7f317109a6a5957bd28"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","0d22ac6a4146774c1bc8400160fc0b6150294e92","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}