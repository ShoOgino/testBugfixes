{"path":"lucene/core/src/java/org/apache/lucene/index/PersistentSnapshotDeletionPolicy#loadPriorSnapshots().mjava","commits":[{"id":"dce99db8590cdd065839ae4e6b228b66eeee8f38","date":1367579599,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/PersistentSnapshotDeletionPolicy#loadPriorSnapshots().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Reads the snapshots information from the given {@link Directory}. This\n   * method can be used if the snapshots information is needed, however you\n   * cannot instantiate the deletion policy (because e.g., some other process\n   * keeps a lock on the snapshots directory).\n   */\n  private synchronized void loadPriorSnapshots() throws IOException {\n    long genLoaded = -1;\n    IOException ioe = null;\n    List<String> snapshotFiles = new ArrayList<String>();\n    for(String file : dir.listAll()) {\n      if (file.startsWith(SNAPSHOTS_PREFIX)) {\n        long gen = Long.parseLong(file.substring(SNAPSHOTS_PREFIX.length()));\n        if (genLoaded == -1 || gen > genLoaded) {\n          snapshotFiles.add(file);\n          Map<Long,Integer> m = new HashMap<Long,Integer>();    \n          IndexInput in = dir.openInput(file, IOContext.DEFAULT);\n          try {\n            CodecUtil.checkHeader(in, CODEC_NAME, VERSION_START, VERSION_START);\n            int count = in.readVInt();\n            for(int i=0;i<count;i++) {\n              long commitGen = in.readVLong();\n              int refCount = in.readVInt();\n              m.put(commitGen, refCount);\n            }\n          } catch (IOException ioe2) {\n            // Save first exception & throw in the end\n            if (ioe == null) {\n              ioe = ioe2;\n            }\n          } finally {\n            in.close();\n          }\n\n          genLoaded = gen;\n          refCounts.clear();\n          refCounts.putAll(m);\n        }\n      }\n    }\n\n    if (genLoaded == -1) {\n      // Nothing was loaded...\n      if (ioe != null) {\n        // ... not for lack of trying:\n        throw ioe;\n      }\n    } else { \n      if (snapshotFiles.size() > 1) {\n        // Remove any broken / old snapshot files:\n        String curFileName = SNAPSHOTS_PREFIX + genLoaded;\n        for(String file : snapshotFiles) {\n          if (!curFileName.equals(file)) {\n            dir.deleteFile(file);\n          }\n        }\n      }\n      nextWriteGen = 1+genLoaded;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/PersistentSnapshotDeletionPolicy#loadPriorSnapshots().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/PersistentSnapshotDeletionPolicy#loadPriorSnapshots().mjava","sourceNew":"  /**\n   * Reads the snapshots information from the given {@link Directory}. This\n   * method can be used if the snapshots information is needed, however you\n   * cannot instantiate the deletion policy (because e.g., some other process\n   * keeps a lock on the snapshots directory).\n   */\n  private synchronized void loadPriorSnapshots() throws IOException {\n    long genLoaded = -1;\n    IOException ioe = null;\n    List<String> snapshotFiles = new ArrayList<>();\n    for(String file : dir.listAll()) {\n      if (file.startsWith(SNAPSHOTS_PREFIX)) {\n        long gen = Long.parseLong(file.substring(SNAPSHOTS_PREFIX.length()));\n        if (genLoaded == -1 || gen > genLoaded) {\n          snapshotFiles.add(file);\n          Map<Long,Integer> m = new HashMap<>();\n          IndexInput in = dir.openInput(file, IOContext.DEFAULT);\n          try {\n            CodecUtil.checkHeader(in, CODEC_NAME, VERSION_START, VERSION_START);\n            int count = in.readVInt();\n            for(int i=0;i<count;i++) {\n              long commitGen = in.readVLong();\n              int refCount = in.readVInt();\n              m.put(commitGen, refCount);\n            }\n          } catch (IOException ioe2) {\n            // Save first exception & throw in the end\n            if (ioe == null) {\n              ioe = ioe2;\n            }\n          } finally {\n            in.close();\n          }\n\n          genLoaded = gen;\n          refCounts.clear();\n          refCounts.putAll(m);\n        }\n      }\n    }\n\n    if (genLoaded == -1) {\n      // Nothing was loaded...\n      if (ioe != null) {\n        // ... not for lack of trying:\n        throw ioe;\n      }\n    } else { \n      if (snapshotFiles.size() > 1) {\n        // Remove any broken / old snapshot files:\n        String curFileName = SNAPSHOTS_PREFIX + genLoaded;\n        for(String file : snapshotFiles) {\n          if (!curFileName.equals(file)) {\n            dir.deleteFile(file);\n          }\n        }\n      }\n      nextWriteGen = 1+genLoaded;\n    }\n  }\n\n","sourceOld":"  /**\n   * Reads the snapshots information from the given {@link Directory}. This\n   * method can be used if the snapshots information is needed, however you\n   * cannot instantiate the deletion policy (because e.g., some other process\n   * keeps a lock on the snapshots directory).\n   */\n  private synchronized void loadPriorSnapshots() throws IOException {\n    long genLoaded = -1;\n    IOException ioe = null;\n    List<String> snapshotFiles = new ArrayList<String>();\n    for(String file : dir.listAll()) {\n      if (file.startsWith(SNAPSHOTS_PREFIX)) {\n        long gen = Long.parseLong(file.substring(SNAPSHOTS_PREFIX.length()));\n        if (genLoaded == -1 || gen > genLoaded) {\n          snapshotFiles.add(file);\n          Map<Long,Integer> m = new HashMap<Long,Integer>();    \n          IndexInput in = dir.openInput(file, IOContext.DEFAULT);\n          try {\n            CodecUtil.checkHeader(in, CODEC_NAME, VERSION_START, VERSION_START);\n            int count = in.readVInt();\n            for(int i=0;i<count;i++) {\n              long commitGen = in.readVLong();\n              int refCount = in.readVInt();\n              m.put(commitGen, refCount);\n            }\n          } catch (IOException ioe2) {\n            // Save first exception & throw in the end\n            if (ioe == null) {\n              ioe = ioe2;\n            }\n          } finally {\n            in.close();\n          }\n\n          genLoaded = gen;\n          refCounts.clear();\n          refCounts.putAll(m);\n        }\n      }\n    }\n\n    if (genLoaded == -1) {\n      // Nothing was loaded...\n      if (ioe != null) {\n        // ... not for lack of trying:\n        throw ioe;\n      }\n    } else { \n      if (snapshotFiles.size() > 1) {\n        // Remove any broken / old snapshot files:\n        String curFileName = SNAPSHOTS_PREFIX + genLoaded;\n        for(String file : snapshotFiles) {\n          if (!curFileName.equals(file)) {\n            dir.deleteFile(file);\n          }\n        }\n      }\n      nextWriteGen = 1+genLoaded;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"98d2deb8c96c79ebef084a1f8e5a1a6c08608f13","date":1409346855,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/PersistentSnapshotDeletionPolicy#loadPriorSnapshots().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/PersistentSnapshotDeletionPolicy#loadPriorSnapshots().mjava","sourceNew":"  /**\n   * Reads the snapshots information from the given {@link Directory}. This\n   * method can be used if the snapshots information is needed, however you\n   * cannot instantiate the deletion policy (because e.g., some other process\n   * keeps a lock on the snapshots directory).\n   */\n  private synchronized void loadPriorSnapshots() throws IOException {\n    long genLoaded = -1;\n    IOException ioe = null;\n    List<String> snapshotFiles = new ArrayList<>();\n    for(String file : dir.listAll()) {\n      if (file.startsWith(SNAPSHOTS_PREFIX)) {\n        long gen = Long.parseLong(file.substring(SNAPSHOTS_PREFIX.length()));\n        if (genLoaded == -1 || gen > genLoaded) {\n          snapshotFiles.add(file);\n          Map<Long,Integer> m = new HashMap<>();\n          IndexInput in = dir.openInput(file, IOContext.DEFAULT);\n          try {\n            CodecUtil.checkHeader(in, CODEC_NAME, VERSION_START, VERSION_START);\n            int count = in.readVInt();\n            for(int i=0;i<count;i++) {\n              long commitGen = in.readVLong();\n              int refCount = in.readVInt();\n              m.put(commitGen, refCount);\n            }\n          } catch (IOException ioe2) {\n            // Save first exception & throw in the end\n            if (ioe == null) {\n              ioe = ioe2;\n            }\n          } finally {\n            in.close();\n          }\n\n          genLoaded = gen;\n          refCounts.clear();\n          refCounts.putAll(m);\n        }\n      }\n    }\n\n    if (genLoaded == -1) {\n      // Nothing was loaded...\n      if (ioe != null) {\n        // ... not for lack of trying:\n        throw ioe;\n      }\n    } else { \n      if (snapshotFiles.size() > 1) {\n        // Remove any broken / old snapshot files:\n        String curFileName = SNAPSHOTS_PREFIX + genLoaded;\n        for(String file : snapshotFiles) {\n          if (!curFileName.equals(file)) {\n            IOUtils.deleteFilesIgnoringExceptions(dir, file);\n          }\n        }\n      }\n      nextWriteGen = 1+genLoaded;\n    }\n  }\n\n","sourceOld":"  /**\n   * Reads the snapshots information from the given {@link Directory}. This\n   * method can be used if the snapshots information is needed, however you\n   * cannot instantiate the deletion policy (because e.g., some other process\n   * keeps a lock on the snapshots directory).\n   */\n  private synchronized void loadPriorSnapshots() throws IOException {\n    long genLoaded = -1;\n    IOException ioe = null;\n    List<String> snapshotFiles = new ArrayList<>();\n    for(String file : dir.listAll()) {\n      if (file.startsWith(SNAPSHOTS_PREFIX)) {\n        long gen = Long.parseLong(file.substring(SNAPSHOTS_PREFIX.length()));\n        if (genLoaded == -1 || gen > genLoaded) {\n          snapshotFiles.add(file);\n          Map<Long,Integer> m = new HashMap<>();\n          IndexInput in = dir.openInput(file, IOContext.DEFAULT);\n          try {\n            CodecUtil.checkHeader(in, CODEC_NAME, VERSION_START, VERSION_START);\n            int count = in.readVInt();\n            for(int i=0;i<count;i++) {\n              long commitGen = in.readVLong();\n              int refCount = in.readVInt();\n              m.put(commitGen, refCount);\n            }\n          } catch (IOException ioe2) {\n            // Save first exception & throw in the end\n            if (ioe == null) {\n              ioe = ioe2;\n            }\n          } finally {\n            in.close();\n          }\n\n          genLoaded = gen;\n          refCounts.clear();\n          refCounts.putAll(m);\n        }\n      }\n    }\n\n    if (genLoaded == -1) {\n      // Nothing was loaded...\n      if (ioe != null) {\n        // ... not for lack of trying:\n        throw ioe;\n      }\n    } else { \n      if (snapshotFiles.size() > 1) {\n        // Remove any broken / old snapshot files:\n        String curFileName = SNAPSHOTS_PREFIX + genLoaded;\n        for(String file : snapshotFiles) {\n          if (!curFileName.equals(file)) {\n            dir.deleteFile(file);\n          }\n        }\n      }\n      nextWriteGen = 1+genLoaded;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["dce99db8590cdd065839ae4e6b228b66eeee8f38"],"dce99db8590cdd065839ae4e6b228b66eeee8f38":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"98d2deb8c96c79ebef084a1f8e5a1a6c08608f13":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["98d2deb8c96c79ebef084a1f8e5a1a6c08608f13"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["98d2deb8c96c79ebef084a1f8e5a1a6c08608f13"],"dce99db8590cdd065839ae4e6b228b66eeee8f38":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["dce99db8590cdd065839ae4e6b228b66eeee8f38"],"98d2deb8c96c79ebef084a1f8e5a1a6c08608f13":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}