{"path":"solr/core/src/test/org/apache/solr/cloud/TestQueryingOnDownCollection#testQueryToDownCollectionShouldFailFast().mjava","commits":[{"id":"3ce90eebc5ea0ea353b865b3db6dbe0c51fc1710","date":1571130800,"type":0,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestQueryingOnDownCollection#testQueryToDownCollectionShouldFailFast().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  /**\n   * Assert that requests to \"down collection\", i.e. a collection which has all replicas in down state\n   * (but are hosted on nodes that are live), fail fast and throw meaningful exceptions\n   */\n  public void testQueryToDownCollectionShouldFailFast() throws Exception {\n\n    CollectionAdminRequest.createCollection(COLLECTION_NAME, \"conf\", 2, 1)\n        .setBasicAuthCredentials(USERNAME, PASSWORD)\n        .process(cluster.getSolrClient());\n\n    // Add some dummy documents\n    UpdateRequest update = (UpdateRequest) new UpdateRequest().setBasicAuthCredentials(USERNAME, PASSWORD);\n    for (int i = 0; i < 100; i++) {\n      update.add(\"id\", Integer.toString(i));\n    }\n    update.commit(cluster.getSolrClient(), COLLECTION_NAME);\n\n    // Bring down replicas but keep nodes up. This could've been done by some combinations of collections API operations;\n    // however, to make it faster, altering cluster state directly! ;-)\n    downAllReplicas();\n\n    // assert all replicas are in down state\n    List<Replica> replicas = getCollectionState(COLLECTION_NAME).getReplicas();\n    for (Replica replica: replicas){\n      assertEquals(replica.getState(), Replica.State.DOWN);\n    }\n\n    // assert all nodes as active\n    assertEquals(3, cluster.getSolrClient().getClusterStateProvider().getLiveNodes().size());\n\n    SolrClient client = cluster.getJettySolrRunner(0).newClient();\n\n    SolrRequest req = new QueryRequest(new SolrQuery(\"*:*\").setRows(0)).setBasicAuthCredentials(USERNAME, PASSWORD);\n\n    // Without the SOLR-13793 fix, this causes requests to \"down collection\" to pile up (until the nodes run out \n    // of serviceable threads and they crash, even for other collections hosted on the nodes).\n    SolrException error = expectThrows(SolrException.class,\n        \"Request should fail after trying all replica nodes once\",\n        () -> client.request(req, COLLECTION_NAME)\n    );\n\n    client.close();\n\n    assertEquals(error.code(), SolrException.ErrorCode.INVALID_STATE.code);\n    assertTrue(error.getMessage().contains(\"No active replicas found for collection: \" + COLLECTION_NAME));\n\n    // run same set of tests on v2 client which uses V2HttpCall\n    Http2SolrClient v2Client = new Http2SolrClient.Builder(cluster.getJettySolrRunner(0).getBaseUrl().toString())\n        .build();\n    PreemptiveBasicAuthClientBuilderFactory factory = new PreemptiveBasicAuthClientBuilderFactory();\n    factory.setup(v2Client);\n\n    error = expectThrows(SolrException.class,\n        \"Request should fail after trying all replica nodes once\",\n        () -> v2Client.request(req, COLLECTION_NAME)\n    );\n\n    v2Client.close();\n\n    assertEquals(error.code(), SolrException.ErrorCode.INVALID_STATE.code);\n    assertTrue(error.getMessage().contains(\"No active replicas found for collection: \" + COLLECTION_NAME));\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9f3232e979baf87b2cf422ce98adfabf402f8b3","date":1571179053,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestQueryingOnDownCollection#testQueryToDownCollectionShouldFailFast().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestQueryingOnDownCollection#testQueryToDownCollectionShouldFailFast().mjava","sourceNew":"  @Test\n  /**\n   * Assert that requests to \"down collection\", i.e. a collection which has all replicas in down state\n   * (but are hosted on nodes that are live), fail fast and throw meaningful exceptions\n   */\n  public void testQueryToDownCollectionShouldFailFast() throws Exception {\n\n    CollectionAdminRequest.createCollection(COLLECTION_NAME, \"conf\", 2, 1)\n        .setBasicAuthCredentials(USERNAME, PASSWORD)\n        .process(cluster.getSolrClient());\n\n    // Add some dummy documents\n    UpdateRequest update = (UpdateRequest) new UpdateRequest().setBasicAuthCredentials(USERNAME, PASSWORD);\n    for (int i = 0; i < 100; i++) {\n      update.add(\"id\", Integer.toString(i));\n    }\n    update.commit(cluster.getSolrClient(), COLLECTION_NAME);\n\n    // Bring down replicas but keep nodes up. This could've been done by some combinations of collections API operations;\n    // however, to make it faster, altering cluster state directly! ;-)\n    downAllReplicas();\n\n    // assert all replicas are in down state\n    List<Replica> replicas = getCollectionState(COLLECTION_NAME).getReplicas();\n    for (Replica replica: replicas){\n      assertEquals(replica.getState(), Replica.State.DOWN);\n    }\n\n    // assert all nodes as active\n    assertEquals(3, cluster.getSolrClient().getClusterStateProvider().getLiveNodes().size());\n\n    SolrClient client = cluster.getJettySolrRunner(0).newClient();\n\n    SolrRequest req = new QueryRequest(new SolrQuery(\"*:*\").setRows(0)).setBasicAuthCredentials(USERNAME, PASSWORD);\n\n    // Without the SOLR-13793 fix, this causes requests to \"down collection\" to pile up (until the nodes run out \n    // of serviceable threads and they crash, even for other collections hosted on the nodes).\n    SolrException error = expectThrows(SolrException.class,\n        \"Request should fail after trying all replica nodes once\",\n        () -> client.request(req, COLLECTION_NAME)\n    );\n\n    client.close();\n\n    assertEquals(error.code(), SolrException.ErrorCode.INVALID_STATE.code);\n    assertTrue(error.getMessage().contains(\"No active replicas found for collection: \" + COLLECTION_NAME));\n\n    // run same set of tests on v2 client which uses V2HttpCall\n    Http2SolrClient v2Client = new Http2SolrClient.Builder(cluster.getJettySolrRunner(0).getBaseUrl().toString())\n        .build();\n\n    error = expectThrows(SolrException.class,\n        \"Request should fail after trying all replica nodes once\",\n        () -> v2Client.request(req, COLLECTION_NAME)\n    );\n\n    v2Client.close();\n\n    assertEquals(error.code(), SolrException.ErrorCode.INVALID_STATE.code);\n    assertTrue(error.getMessage().contains(\"No active replicas found for collection: \" + COLLECTION_NAME));\n  }\n\n","sourceOld":"  @Test\n  /**\n   * Assert that requests to \"down collection\", i.e. a collection which has all replicas in down state\n   * (but are hosted on nodes that are live), fail fast and throw meaningful exceptions\n   */\n  public void testQueryToDownCollectionShouldFailFast() throws Exception {\n\n    CollectionAdminRequest.createCollection(COLLECTION_NAME, \"conf\", 2, 1)\n        .setBasicAuthCredentials(USERNAME, PASSWORD)\n        .process(cluster.getSolrClient());\n\n    // Add some dummy documents\n    UpdateRequest update = (UpdateRequest) new UpdateRequest().setBasicAuthCredentials(USERNAME, PASSWORD);\n    for (int i = 0; i < 100; i++) {\n      update.add(\"id\", Integer.toString(i));\n    }\n    update.commit(cluster.getSolrClient(), COLLECTION_NAME);\n\n    // Bring down replicas but keep nodes up. This could've been done by some combinations of collections API operations;\n    // however, to make it faster, altering cluster state directly! ;-)\n    downAllReplicas();\n\n    // assert all replicas are in down state\n    List<Replica> replicas = getCollectionState(COLLECTION_NAME).getReplicas();\n    for (Replica replica: replicas){\n      assertEquals(replica.getState(), Replica.State.DOWN);\n    }\n\n    // assert all nodes as active\n    assertEquals(3, cluster.getSolrClient().getClusterStateProvider().getLiveNodes().size());\n\n    SolrClient client = cluster.getJettySolrRunner(0).newClient();\n\n    SolrRequest req = new QueryRequest(new SolrQuery(\"*:*\").setRows(0)).setBasicAuthCredentials(USERNAME, PASSWORD);\n\n    // Without the SOLR-13793 fix, this causes requests to \"down collection\" to pile up (until the nodes run out \n    // of serviceable threads and they crash, even for other collections hosted on the nodes).\n    SolrException error = expectThrows(SolrException.class,\n        \"Request should fail after trying all replica nodes once\",\n        () -> client.request(req, COLLECTION_NAME)\n    );\n\n    client.close();\n\n    assertEquals(error.code(), SolrException.ErrorCode.INVALID_STATE.code);\n    assertTrue(error.getMessage().contains(\"No active replicas found for collection: \" + COLLECTION_NAME));\n\n    // run same set of tests on v2 client which uses V2HttpCall\n    Http2SolrClient v2Client = new Http2SolrClient.Builder(cluster.getJettySolrRunner(0).getBaseUrl().toString())\n        .build();\n    PreemptiveBasicAuthClientBuilderFactory factory = new PreemptiveBasicAuthClientBuilderFactory();\n    factory.setup(v2Client);\n\n    error = expectThrows(SolrException.class,\n        \"Request should fail after trying all replica nodes once\",\n        () -> v2Client.request(req, COLLECTION_NAME)\n    );\n\n    v2Client.close();\n\n    assertEquals(error.code(), SolrException.ErrorCode.INVALID_STATE.code);\n    assertTrue(error.getMessage().contains(\"No active replicas found for collection: \" + COLLECTION_NAME));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":0,"author":"jimczi","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestQueryingOnDownCollection#testQueryToDownCollectionShouldFailFast().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  /**\n   * Assert that requests to \"down collection\", i.e. a collection which has all replicas in down state\n   * (but are hosted on nodes that are live), fail fast and throw meaningful exceptions\n   */\n  public void testQueryToDownCollectionShouldFailFast() throws Exception {\n\n    CollectionAdminRequest.createCollection(COLLECTION_NAME, \"conf\", 2, 1)\n        .setBasicAuthCredentials(USERNAME, PASSWORD)\n        .process(cluster.getSolrClient());\n\n    // Add some dummy documents\n    UpdateRequest update = (UpdateRequest) new UpdateRequest().setBasicAuthCredentials(USERNAME, PASSWORD);\n    for (int i = 0; i < 100; i++) {\n      update.add(\"id\", Integer.toString(i));\n    }\n    update.commit(cluster.getSolrClient(), COLLECTION_NAME);\n\n    // Bring down replicas but keep nodes up. This could've been done by some combinations of collections API operations;\n    // however, to make it faster, altering cluster state directly! ;-)\n    downAllReplicas();\n\n    // assert all replicas are in down state\n    List<Replica> replicas = getCollectionState(COLLECTION_NAME).getReplicas();\n    for (Replica replica: replicas){\n      assertEquals(replica.getState(), Replica.State.DOWN);\n    }\n\n    // assert all nodes as active\n    assertEquals(3, cluster.getSolrClient().getClusterStateProvider().getLiveNodes().size());\n\n    SolrClient client = cluster.getJettySolrRunner(0).newClient();\n\n    SolrRequest req = new QueryRequest(new SolrQuery(\"*:*\").setRows(0)).setBasicAuthCredentials(USERNAME, PASSWORD);\n\n    // Without the SOLR-13793 fix, this causes requests to \"down collection\" to pile up (until the nodes run out \n    // of serviceable threads and they crash, even for other collections hosted on the nodes).\n    SolrException error = expectThrows(SolrException.class,\n        \"Request should fail after trying all replica nodes once\",\n        () -> client.request(req, COLLECTION_NAME)\n    );\n\n    client.close();\n\n    assertEquals(error.code(), SolrException.ErrorCode.INVALID_STATE.code);\n    assertTrue(error.getMessage().contains(\"No active replicas found for collection: \" + COLLECTION_NAME));\n\n    // run same set of tests on v2 client which uses V2HttpCall\n    Http2SolrClient v2Client = new Http2SolrClient.Builder(cluster.getJettySolrRunner(0).getBaseUrl().toString())\n        .build();\n\n    error = expectThrows(SolrException.class,\n        \"Request should fail after trying all replica nodes once\",\n        () -> v2Client.request(req, COLLECTION_NAME)\n    );\n\n    v2Client.close();\n\n    assertEquals(error.code(), SolrException.ErrorCode.INVALID_STATE.code);\n    assertTrue(error.getMessage().contains(\"No active replicas found for collection: \" + COLLECTION_NAME));\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e98520789adb1d5ad05afb4956eca0944a929688","date":1592430701,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestQueryingOnDownCollection#testQueryToDownCollectionShouldFailFast().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestQueryingOnDownCollection#testQueryToDownCollectionShouldFailFast().mjava","sourceNew":"  @Test\n  /**\n   * Assert that requests to \"down collection\", i.e. a collection which has all replicas in down state\n   * (but are hosted on nodes that are live), fail fast and throw meaningful exceptions\n   */\n  public void testQueryToDownCollectionShouldFailFast() throws Exception {\n\n    CollectionAdminRequest.createCollection(COLLECTION_NAME, \"conf\", 2, 1)\n        .setBasicAuthCredentials(USERNAME, PASSWORD)\n        .process(cluster.getSolrClient());\n\n    // Add some dummy documents\n    UpdateRequest update = (UpdateRequest) new UpdateRequest().setBasicAuthCredentials(USERNAME, PASSWORD);\n    for (int i = 0; i < 100; i++) {\n      update.add(\"id\", Integer.toString(i));\n    }\n    update.commit(cluster.getSolrClient(), COLLECTION_NAME);\n\n    // Bring down replicas but keep nodes up. This could've been done by some combinations of collections API operations;\n    // however, to make it faster, altering cluster state directly! ;-)\n    downAllReplicas();\n\n    // assert all replicas are in down state\n    List<Replica> replicas = getCollectionState(COLLECTION_NAME).getReplicas();\n    for (Replica replica: replicas){\n      assertEquals(replica.getState(), Replica.State.DOWN);\n    }\n\n    // assert all nodes as active\n    assertEquals(3, cluster.getSolrClient().getClusterStateProvider().getLiveNodes().size());\n\n    SolrClient client = cluster.getJettySolrRunner(0).newClient();\n\n    @SuppressWarnings({\"rawtypes\"})\n    SolrRequest req = new QueryRequest(new SolrQuery(\"*:*\").setRows(0)).setBasicAuthCredentials(USERNAME, PASSWORD);\n\n    // Without the SOLR-13793 fix, this causes requests to \"down collection\" to pile up (until the nodes run out \n    // of serviceable threads and they crash, even for other collections hosted on the nodes).\n    SolrException error = expectThrows(SolrException.class,\n        \"Request should fail after trying all replica nodes once\",\n        () -> client.request(req, COLLECTION_NAME)\n    );\n\n    client.close();\n\n    assertEquals(error.code(), SolrException.ErrorCode.INVALID_STATE.code);\n    assertTrue(error.getMessage().contains(\"No active replicas found for collection: \" + COLLECTION_NAME));\n\n    // run same set of tests on v2 client which uses V2HttpCall\n    Http2SolrClient v2Client = new Http2SolrClient.Builder(cluster.getJettySolrRunner(0).getBaseUrl().toString())\n        .build();\n\n    error = expectThrows(SolrException.class,\n        \"Request should fail after trying all replica nodes once\",\n        () -> v2Client.request(req, COLLECTION_NAME)\n    );\n\n    v2Client.close();\n\n    assertEquals(error.code(), SolrException.ErrorCode.INVALID_STATE.code);\n    assertTrue(error.getMessage().contains(\"No active replicas found for collection: \" + COLLECTION_NAME));\n  }\n\n","sourceOld":"  @Test\n  /**\n   * Assert that requests to \"down collection\", i.e. a collection which has all replicas in down state\n   * (but are hosted on nodes that are live), fail fast and throw meaningful exceptions\n   */\n  public void testQueryToDownCollectionShouldFailFast() throws Exception {\n\n    CollectionAdminRequest.createCollection(COLLECTION_NAME, \"conf\", 2, 1)\n        .setBasicAuthCredentials(USERNAME, PASSWORD)\n        .process(cluster.getSolrClient());\n\n    // Add some dummy documents\n    UpdateRequest update = (UpdateRequest) new UpdateRequest().setBasicAuthCredentials(USERNAME, PASSWORD);\n    for (int i = 0; i < 100; i++) {\n      update.add(\"id\", Integer.toString(i));\n    }\n    update.commit(cluster.getSolrClient(), COLLECTION_NAME);\n\n    // Bring down replicas but keep nodes up. This could've been done by some combinations of collections API operations;\n    // however, to make it faster, altering cluster state directly! ;-)\n    downAllReplicas();\n\n    // assert all replicas are in down state\n    List<Replica> replicas = getCollectionState(COLLECTION_NAME).getReplicas();\n    for (Replica replica: replicas){\n      assertEquals(replica.getState(), Replica.State.DOWN);\n    }\n\n    // assert all nodes as active\n    assertEquals(3, cluster.getSolrClient().getClusterStateProvider().getLiveNodes().size());\n\n    SolrClient client = cluster.getJettySolrRunner(0).newClient();\n\n    SolrRequest req = new QueryRequest(new SolrQuery(\"*:*\").setRows(0)).setBasicAuthCredentials(USERNAME, PASSWORD);\n\n    // Without the SOLR-13793 fix, this causes requests to \"down collection\" to pile up (until the nodes run out \n    // of serviceable threads and they crash, even for other collections hosted on the nodes).\n    SolrException error = expectThrows(SolrException.class,\n        \"Request should fail after trying all replica nodes once\",\n        () -> client.request(req, COLLECTION_NAME)\n    );\n\n    client.close();\n\n    assertEquals(error.code(), SolrException.ErrorCode.INVALID_STATE.code);\n    assertTrue(error.getMessage().contains(\"No active replicas found for collection: \" + COLLECTION_NAME));\n\n    // run same set of tests on v2 client which uses V2HttpCall\n    Http2SolrClient v2Client = new Http2SolrClient.Builder(cluster.getJettySolrRunner(0).getBaseUrl().toString())\n        .build();\n\n    error = expectThrows(SolrException.class,\n        \"Request should fail after trying all replica nodes once\",\n        () -> v2Client.request(req, COLLECTION_NAME)\n    );\n\n    v2Client.close();\n\n    assertEquals(error.code(), SolrException.ErrorCode.INVALID_STATE.code);\n    assertTrue(error.getMessage().contains(\"No active replicas found for collection: \" + COLLECTION_NAME));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3ce90eebc5ea0ea353b865b3db6dbe0c51fc1710":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e98520789adb1d5ad05afb4956eca0944a929688"],"e98520789adb1d5ad05afb4956eca0944a929688":["c9f3232e979baf87b2cf422ce98adfabf402f8b3"],"c9f3232e979baf87b2cf422ce98adfabf402f8b3":["3ce90eebc5ea0ea353b865b3db6dbe0c51fc1710"],"b0b597c65628ca9e73913a07e81691f8229bae35":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c9f3232e979baf87b2cf422ce98adfabf402f8b3"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3ce90eebc5ea0ea353b865b3db6dbe0c51fc1710","b0b597c65628ca9e73913a07e81691f8229bae35"],"3ce90eebc5ea0ea353b865b3db6dbe0c51fc1710":["c9f3232e979baf87b2cf422ce98adfabf402f8b3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"e98520789adb1d5ad05afb4956eca0944a929688":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c9f3232e979baf87b2cf422ce98adfabf402f8b3":["e98520789adb1d5ad05afb4956eca0944a929688","b0b597c65628ca9e73913a07e81691f8229bae35"],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}