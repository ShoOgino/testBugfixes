{"path":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    try {\n      newestSearcher = getNewestSearcher(false);\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = new File(getIndexDir()).getCanonicalFile();\n      File newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      \n      if (newestSearcher != null && solrConfig.reopenReaders\n          && indexDirFile.equals(newIndexDirFile)) {\n        \n        if (updateHandlerReopens) {\n          \n          tmp = getUpdateHandler().reopenSearcher(newestSearcher.get());\n          \n        } else {\n          \n          IndexReader currentReader = newestSearcher.get().getIndexReader();\n          IndexReader newReader;\n          \n          newReader = currentReader.reopen();\n          \n          if (newReader == currentReader) {\n            currentReader.incRef();\n          }\n          \n          tmp = new SolrIndexSearcher(this, schema, \"main\", newReader, true, true);\n        }\n\n      } else {\n        IndexReader reader = getIndexReaderFactory().newReader(getDirectoryFactory().open(newIndexDir), true);\n        tmp = new SolrIndexSearcher(this, schema, \"main\", reader, true, true);\n      }\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n    \n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher, currSearcher);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    try {\n      newestSearcher = getNewestSearcher(false);\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = new File(getIndexDir()).getCanonicalFile();\n      File newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      \n      if (newestSearcher != null && solrConfig.reopenReaders\n          && indexDirFile.equals(newIndexDirFile)) {\n        \n        if (updateHandlerReopens) {\n          \n          tmp = getUpdateHandler().reopenSearcher(newestSearcher.get());\n          \n        } else {\n          \n          IndexReader currentReader = newestSearcher.get().getIndexReader();\n          IndexReader newReader;\n          \n          newReader = currentReader.reopen();\n          \n          if (newReader == currentReader) {\n            currentReader.incRef();\n          }\n          \n          tmp = new SolrIndexSearcher(this, schema, \"main\", newReader, true, true);\n        }\n\n      } else {\n        IndexReader reader = getIndexReaderFactory().newReader(getDirectoryFactory().open(newIndexDir), true);\n        tmp = new SolrIndexSearcher(this, schema, \"main\", reader, true, true);\n      }\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n    \n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher, currSearcher);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    try {\n      newestSearcher = getNewestSearcher(false);\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = new File(getIndexDir()).getCanonicalFile();\n      File newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      \n      if (newestSearcher != null && solrConfig.reopenReaders\n          && indexDirFile.equals(newIndexDirFile)) {\n        \n        if (updateHandlerReopens) {\n          \n          tmp = getUpdateHandler().reopenSearcher(newestSearcher.get());\n          \n        } else {\n          \n          IndexReader currentReader = newestSearcher.get().getIndexReader();\n          IndexReader newReader;\n          \n          newReader = currentReader.reopen();\n          \n          if (newReader == currentReader) {\n            currentReader.incRef();\n          }\n          \n          tmp = new SolrIndexSearcher(this, schema, \"main\", newReader, true, true);\n        }\n\n      } else {\n        IndexReader reader = getIndexReaderFactory().newReader(getDirectoryFactory().open(newIndexDir), true);\n        tmp = new SolrIndexSearcher(this, schema, \"main\", reader, true, true);\n      }\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n    \n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher, currSearcher);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    try {\n      newestSearcher = getNewestSearcher(false);\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = new File(getIndexDir()).getCanonicalFile();\n      File newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      \n      if (newestSearcher != null && solrConfig.reopenReaders\n          && indexDirFile.equals(newIndexDirFile)) {\n        \n        if (updateHandlerReopens) {\n          \n          tmp = getUpdateHandler().reopenSearcher(newestSearcher.get());\n          \n        } else {\n          \n          IndexReader currentReader = newestSearcher.get().getIndexReader();\n          IndexReader newReader;\n          \n          newReader = currentReader.reopen();\n          \n          if (newReader == currentReader) {\n            currentReader.incRef();\n          }\n          \n          tmp = new SolrIndexSearcher(this, schema, \"main\", newReader, true, true);\n        }\n\n      } else {\n        IndexReader reader = getIndexReaderFactory().newReader(getDirectoryFactory().open(newIndexDir), true);\n        tmp = new SolrIndexSearcher(this, schema, \"main\", reader, true, true);\n      }\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n    \n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher, currSearcher);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    try {\n      newestSearcher = getNewestSearcher(false);\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = new File(getIndexDir()).getCanonicalFile();\n      File newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      \n      if (newestSearcher != null && solrConfig.reopenReaders\n          && indexDirFile.equals(newIndexDirFile)) {\n        \n        if (updateHandlerReopens) {\n          \n          tmp = getUpdateHandler().reopenSearcher(newestSearcher.get());\n          \n        } else {\n          \n          IndexReader currentReader = newestSearcher.get().getIndexReader();\n          IndexReader newReader;\n          \n          newReader = currentReader.reopen();\n          \n          if (newReader == currentReader) {\n            currentReader.incRef();\n          }\n          \n          tmp = new SolrIndexSearcher(this, schema, \"main\", newReader, true, true);\n        }\n\n      } else {\n        IndexReader reader = getIndexReaderFactory().newReader(getDirectoryFactory().open(newIndexDir), true);\n        tmp = new SolrIndexSearcher(this, schema, \"main\", reader, true, true);\n      }\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n    \n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher, currSearcher);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    try {\n      newestSearcher = getNewestSearcher(false);\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = new File(getIndexDir()).getCanonicalFile();\n      File newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      \n      if (newestSearcher != null && solrConfig.reopenReaders\n          && indexDirFile.equals(newIndexDirFile)) {\n        \n        if (updateHandlerReopens) {\n          \n          tmp = getUpdateHandler().reopenSearcher(newestSearcher.get());\n          \n        } else {\n          \n          IndexReader currentReader = newestSearcher.get().getIndexReader();\n          IndexReader newReader;\n          \n          newReader = currentReader.reopen();\n          \n          if (newReader == currentReader) {\n            currentReader.incRef();\n          }\n          \n          tmp = new SolrIndexSearcher(this, schema, \"main\", newReader, true, true);\n        }\n\n      } else {\n        IndexReader reader = getIndexReaderFactory().newReader(getDirectoryFactory().open(newIndexDir), true);\n        tmp = new SolrIndexSearcher(this, schema, \"main\", reader, true, true);\n      }\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n    \n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher, currSearcher);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e22ffe8cc51a892ae103df018822d7873e901c2a","date":1313696790,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    try {\n      newestSearcher = getNewestSearcher(false);\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = new File(getIndexDir()).getCanonicalFile();\n      File newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      \n      if (newestSearcher != null && solrConfig.reopenReaders\n          && indexDirFile.equals(newIndexDirFile)) {\n        \n        if (updateHandlerReopens) {\n          \n          tmp = getUpdateHandler().reopenSearcher(newestSearcher.get());\n          \n        } else {\n          \n          IndexReader currentReader = newestSearcher.get().getIndexReader();\n          IndexReader newReader;\n          \n          newReader = currentReader.reopen();\n          \n          if (newReader == currentReader) {\n            currentReader.incRef();\n          }\n          \n          tmp = new SolrIndexSearcher(this, schema, \"main\", newReader, true, true, true, directoryFactory);\n        }\n\n      } else {\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().mainIndexConfig, \"main\", true, true, directoryFactory);\n      }\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n    \n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher, currSearcher);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    try {\n      newestSearcher = getNewestSearcher(false);\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = new File(getIndexDir()).getCanonicalFile();\n      File newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      \n      if (newestSearcher != null && solrConfig.reopenReaders\n          && indexDirFile.equals(newIndexDirFile)) {\n        \n        if (updateHandlerReopens) {\n          \n          tmp = getUpdateHandler().reopenSearcher(newestSearcher.get());\n          \n        } else {\n          \n          IndexReader currentReader = newestSearcher.get().getIndexReader();\n          IndexReader newReader;\n          \n          newReader = currentReader.reopen();\n          \n          if (newReader == currentReader) {\n            currentReader.incRef();\n          }\n          \n          tmp = new SolrIndexSearcher(this, schema, \"main\", newReader, true, true);\n        }\n\n      } else {\n        IndexReader reader = getIndexReaderFactory().newReader(getDirectoryFactory().open(newIndexDir), true);\n        tmp = new SolrIndexSearcher(this, schema, \"main\", reader, true, true);\n      }\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n    \n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher, currSearcher);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","bugFix":["7a71a0b2d4be2299a163f60626729852d81a8e02"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1ba7ea4168f8418335f06510cdcb5be262f35c73","date":1316998082,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    try {\n      newestSearcher = getNewestSearcher(false);\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = new File(getIndexDir()).getCanonicalFile();\n      File newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      \n      if (newestSearcher != null && solrConfig.reopenReaders\n          && indexDirFile.equals(newIndexDirFile)) {\n        \n        if (updateHandlerReopens) {\n          \n          tmp = getUpdateHandler().reopenSearcher(newestSearcher.get());\n          \n        } else {\n          \n          IndexReader currentReader = newestSearcher.get().getIndexReader();\n          IndexReader newReader;\n          \n          newReader = currentReader.reopen();\n          \n          if (newReader == currentReader) {\n            currentReader.incRef();\n          }\n          \n          tmp = new SolrIndexSearcher(this, schema, \"main\", newReader, true, true, true, directoryFactory);\n        }\n\n      } else {\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().mainIndexConfig, \"main\", true, true, directoryFactory);\n      }\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n    \n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher, currSearcher);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        // signal that we no longer need to decrement\n                        // the count *before* registering the searcher since\n                        // registerSearcher will decrement even if it errors.\n                        decrementOnDeckCount[0]=false;\n                        registerSearcher(newSearchHolder);\n                      } catch (Throwable e) {\n                        SolrException.logOnce(log,null,e);\n                      } finally {\n                        // we are all done with the old searcher we used\n                        // for warming...\n                        if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                      }\n                      return null;\n                    }\n                  }\n          );\n        } catch(Exception e) {\n          // if submit fails, newSearchHolder does not get decref'd\n          if (newSearchHolder != null) newSearchHolder.decref();\n          throw e;\n        }\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    try {\n      newestSearcher = getNewestSearcher(false);\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = new File(getIndexDir()).getCanonicalFile();\n      File newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      \n      if (newestSearcher != null && solrConfig.reopenReaders\n          && indexDirFile.equals(newIndexDirFile)) {\n        \n        if (updateHandlerReopens) {\n          \n          tmp = getUpdateHandler().reopenSearcher(newestSearcher.get());\n          \n        } else {\n          \n          IndexReader currentReader = newestSearcher.get().getIndexReader();\n          IndexReader newReader;\n          \n          newReader = currentReader.reopen();\n          \n          if (newReader == currentReader) {\n            currentReader.incRef();\n          }\n          \n          tmp = new SolrIndexSearcher(this, schema, \"main\", newReader, true, true, true, directoryFactory);\n        }\n\n      } else {\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().mainIndexConfig, \"main\", true, true, directoryFactory);\n      }\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n    \n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher, currSearcher);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"eebf3ab509404167976d51dd135e5d95c74996a5","date":1317003203,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    try {\n      newestSearcher = getNewestSearcher(false);\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = new File(getIndexDir()).getCanonicalFile();\n      File newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      \n      if (newestSearcher != null && solrConfig.reopenReaders\n          && indexDirFile.equals(newIndexDirFile)) {\n        \n        if (updateHandlerReopens) {\n          \n          tmp = getUpdateHandler().reopenSearcher(newestSearcher.get());\n          \n        } else {\n          \n          IndexReader currentReader = newestSearcher.get().getIndexReader();\n          IndexReader newReader;\n          \n          newReader = currentReader.reopen();\n          \n          if (newReader == currentReader) {\n            currentReader.incRef();\n          }\n          \n          tmp = new SolrIndexSearcher(this, schema, \"main\", newReader, true, true, true, directoryFactory);\n        }\n\n      } else {\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().mainIndexConfig, \"main\", true, true, directoryFactory);\n      }\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n    \n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher, currSearcher);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        // signal that we no longer need to decrement\n                        // the count *before* registering the searcher since\n                        // registerSearcher will decrement even if it errors.\n                        decrementOnDeckCount[0]=false;\n                        registerSearcher(newSearchHolder);\n                      } catch (Throwable e) {\n                        SolrException.logOnce(log,null,e);\n                      } finally {\n                        // we are all done with the old searcher we used\n                        // for warming...\n                        if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                      }\n                      return null;\n                    }\n                  }\n          );\n        } catch(Exception e) {\n          // if submit fails, newSearchHolder does not get decref'd\n          if (returnSearcher && newSearchHolder != null) newSearchHolder.decref();\n          throw e;\n        }\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    try {\n      newestSearcher = getNewestSearcher(false);\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = new File(getIndexDir()).getCanonicalFile();\n      File newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      \n      if (newestSearcher != null && solrConfig.reopenReaders\n          && indexDirFile.equals(newIndexDirFile)) {\n        \n        if (updateHandlerReopens) {\n          \n          tmp = getUpdateHandler().reopenSearcher(newestSearcher.get());\n          \n        } else {\n          \n          IndexReader currentReader = newestSearcher.get().getIndexReader();\n          IndexReader newReader;\n          \n          newReader = currentReader.reopen();\n          \n          if (newReader == currentReader) {\n            currentReader.incRef();\n          }\n          \n          tmp = new SolrIndexSearcher(this, schema, \"main\", newReader, true, true, true, directoryFactory);\n        }\n\n      } else {\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().mainIndexConfig, \"main\", true, true, directoryFactory);\n      }\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n    \n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher, currSearcher);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        // signal that we no longer need to decrement\n                        // the count *before* registering the searcher since\n                        // registerSearcher will decrement even if it errors.\n                        decrementOnDeckCount[0]=false;\n                        registerSearcher(newSearchHolder);\n                      } catch (Throwable e) {\n                        SolrException.logOnce(log,null,e);\n                      } finally {\n                        // we are all done with the old searcher we used\n                        // for warming...\n                        if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                      }\n                      return null;\n                    }\n                  }\n          );\n        } catch(Exception e) {\n          // if submit fails, newSearchHolder does not get decref'd\n          if (newSearchHolder != null) newSearchHolder.decref();\n          throw e;\n        }\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","bugFix":null,"bugIntro":["7a0b8b7d237d61dcead2d98e45b3479941a41db8"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7a0b8b7d237d61dcead2d98e45b3479941a41db8","date":1317007735,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    try {\n      newestSearcher = getNewestSearcher(false);\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = new File(getIndexDir()).getCanonicalFile();\n      File newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      \n      if (newestSearcher != null && solrConfig.reopenReaders\n          && indexDirFile.equals(newIndexDirFile)) {\n        \n        if (updateHandlerReopens) {\n          \n          tmp = getUpdateHandler().reopenSearcher(newestSearcher.get());\n          \n        } else {\n          \n          IndexReader currentReader = newestSearcher.get().getIndexReader();\n          IndexReader newReader;\n          \n          newReader = currentReader.reopen();\n          \n          if (newReader == currentReader) {\n            currentReader.incRef();\n          }\n          \n          tmp = new SolrIndexSearcher(this, schema, \"main\", newReader, true, true, true, directoryFactory);\n        }\n\n      } else {\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().mainIndexConfig, \"main\", true, true, directoryFactory);\n      }\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n    \n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        newSearcher.warm(currSearcher);\n                      } catch (Throwable e) {\n                        SolrException.logOnce(log,null,e);\n                      }\n                      return null;\n                    }\n                  }\n          );\n        } catch(Exception e) {\n          // if submit fails, newSearchHolder does not get decref'd\n          if (newSearchHolder != null) {\n            newSearchHolder.decref();\n            if (returnSearcher) {\n              newSearchHolder.decref();\n            }\n          }\n          throw e;\n        }\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        for (SolrEventListener listener : firstSearcherListeners) {\n                          listener.newSearcher(newSearcher,null);\n                        }\n                      } catch (Throwable e) {\n                        SolrException.logOnce(log,null,e);\n                      }\n                      return null;\n                    }\n                  }\n          );\n        } catch(Exception e) {\n          // if submit fails, newSearchHolder does not get decref'd\n          if (newSearchHolder != null) {\n            newSearchHolder.decref();\n            if (returnSearcher) {\n              newSearchHolder.decref();\n            }\n          }\n          throw e;\n        }\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        for (SolrEventListener listener : newSearcherListeners) {\n                          listener.newSearcher(newSearcher, currSearcher);\n                        }\n                      } catch (Throwable e) {\n                        SolrException.logOnce(log,null,e);\n                      }\n                      return null;\n                    }\n                  }\n          );\n      } catch(Exception e) {\n        // if submit fails, newSearchHolder does not get decref'd\n        if (newSearchHolder != null) {\n          newSearchHolder.decref();\n          if (returnSearcher) {\n            newSearchHolder.decref();\n          }\n        }\n        throw e;\n      }\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        // signal that we no longer need to decrement\n                        // the count *before* registering the searcher since\n                        // registerSearcher will decrement even if it errors.\n                        decrementOnDeckCount[0]=false;\n                        registerSearcher(newSearchHolder);\n                      } catch (Throwable e) {\n                        SolrException.logOnce(log,null,e);\n                      } finally {\n                        // we are all done with the old searcher we used\n                        // for warming...\n                        if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                      }\n                      return null;\n                    }\n                  }\n          );\n        } catch(Exception e) {\n          // if submit fails, newSearchHolder does not get decref'd\n          if (newSearchHolder != null) {\n            newSearchHolder.decref();\n            if (returnSearcher) {\n              newSearchHolder.decref();\n            }\n          }\n          throw e;\n        }\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    try {\n      newestSearcher = getNewestSearcher(false);\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = new File(getIndexDir()).getCanonicalFile();\n      File newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      \n      if (newestSearcher != null && solrConfig.reopenReaders\n          && indexDirFile.equals(newIndexDirFile)) {\n        \n        if (updateHandlerReopens) {\n          \n          tmp = getUpdateHandler().reopenSearcher(newestSearcher.get());\n          \n        } else {\n          \n          IndexReader currentReader = newestSearcher.get().getIndexReader();\n          IndexReader newReader;\n          \n          newReader = currentReader.reopen();\n          \n          if (newReader == currentReader) {\n            currentReader.incRef();\n          }\n          \n          tmp = new SolrIndexSearcher(this, schema, \"main\", newReader, true, true, true, directoryFactory);\n        }\n\n      } else {\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().mainIndexConfig, \"main\", true, true, directoryFactory);\n      }\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n    \n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher, currSearcher);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        // signal that we no longer need to decrement\n                        // the count *before* registering the searcher since\n                        // registerSearcher will decrement even if it errors.\n                        decrementOnDeckCount[0]=false;\n                        registerSearcher(newSearchHolder);\n                      } catch (Throwable e) {\n                        SolrException.logOnce(log,null,e);\n                      } finally {\n                        // we are all done with the old searcher we used\n                        // for warming...\n                        if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                      }\n                      return null;\n                    }\n                  }\n          );\n        } catch(Exception e) {\n          // if submit fails, newSearchHolder does not get decref'd\n          if (returnSearcher && newSearchHolder != null) newSearchHolder.decref();\n          throw e;\n        }\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","bugFix":["7a71a0b2d4be2299a163f60626729852d81a8e02","eebf3ab509404167976d51dd135e5d95c74996a5"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8a8259c922a83abc544609227a60d48e5ee93e7e","date":1317679620,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    try {\n      newestSearcher = getNewestSearcher(false);\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = new File(getIndexDir()).getCanonicalFile();\n      File newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      \n      if (newestSearcher != null && solrConfig.reopenReaders\n          && indexDirFile.equals(newIndexDirFile)) {\n        \n        if (updateHandlerReopens) {\n          \n          tmp = getUpdateHandler().reopenSearcher(newestSearcher.get());\n          \n        } else {\n          \n          IndexReader currentReader = newestSearcher.get().getIndexReader();\n          IndexReader newReader;\n          \n          newReader = IndexReader.openIfChanged(currentReader);\n          \n          if (newReader == null) {\n            currentReader.incRef();\n            newReader = currentReader;\n          }\n          \n          tmp = new SolrIndexSearcher(this, schema, \"main\", newReader, true, true, true, directoryFactory);\n        }\n\n      } else {\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().mainIndexConfig, \"main\", true, true, directoryFactory);\n      }\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n    \n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        newSearcher.warm(currSearcher);\n                      } catch (Throwable e) {\n                        SolrException.logOnce(log,null,e);\n                      }\n                      return null;\n                    }\n                  }\n          );\n        } catch(Exception e) {\n          // if submit fails, newSearchHolder does not get decref'd\n          if (newSearchHolder != null) {\n            newSearchHolder.decref();\n            if (returnSearcher) {\n              newSearchHolder.decref();\n            }\n          }\n          throw e;\n        }\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        for (SolrEventListener listener : firstSearcherListeners) {\n                          listener.newSearcher(newSearcher,null);\n                        }\n                      } catch (Throwable e) {\n                        SolrException.logOnce(log,null,e);\n                      }\n                      return null;\n                    }\n                  }\n          );\n        } catch(Exception e) {\n          // if submit fails, newSearchHolder does not get decref'd\n          if (newSearchHolder != null) {\n            newSearchHolder.decref();\n            if (returnSearcher) {\n              newSearchHolder.decref();\n            }\n          }\n          throw e;\n        }\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        for (SolrEventListener listener : newSearcherListeners) {\n                          listener.newSearcher(newSearcher, currSearcher);\n                        }\n                      } catch (Throwable e) {\n                        SolrException.logOnce(log,null,e);\n                      }\n                      return null;\n                    }\n                  }\n          );\n      } catch(Exception e) {\n        // if submit fails, newSearchHolder does not get decref'd\n        if (newSearchHolder != null) {\n          newSearchHolder.decref();\n          if (returnSearcher) {\n            newSearchHolder.decref();\n          }\n        }\n        throw e;\n      }\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        // signal that we no longer need to decrement\n                        // the count *before* registering the searcher since\n                        // registerSearcher will decrement even if it errors.\n                        decrementOnDeckCount[0]=false;\n                        registerSearcher(newSearchHolder);\n                      } catch (Throwable e) {\n                        SolrException.logOnce(log,null,e);\n                      } finally {\n                        // we are all done with the old searcher we used\n                        // for warming...\n                        if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                      }\n                      return null;\n                    }\n                  }\n          );\n        } catch(Exception e) {\n          // if submit fails, newSearchHolder does not get decref'd\n          if (newSearchHolder != null) {\n            newSearchHolder.decref();\n            if (returnSearcher) {\n              newSearchHolder.decref();\n            }\n          }\n          throw e;\n        }\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    try {\n      newestSearcher = getNewestSearcher(false);\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = new File(getIndexDir()).getCanonicalFile();\n      File newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      \n      if (newestSearcher != null && solrConfig.reopenReaders\n          && indexDirFile.equals(newIndexDirFile)) {\n        \n        if (updateHandlerReopens) {\n          \n          tmp = getUpdateHandler().reopenSearcher(newestSearcher.get());\n          \n        } else {\n          \n          IndexReader currentReader = newestSearcher.get().getIndexReader();\n          IndexReader newReader;\n          \n          newReader = currentReader.reopen();\n          \n          if (newReader == currentReader) {\n            currentReader.incRef();\n          }\n          \n          tmp = new SolrIndexSearcher(this, schema, \"main\", newReader, true, true, true, directoryFactory);\n        }\n\n      } else {\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().mainIndexConfig, \"main\", true, true, directoryFactory);\n      }\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n    \n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        newSearcher.warm(currSearcher);\n                      } catch (Throwable e) {\n                        SolrException.logOnce(log,null,e);\n                      }\n                      return null;\n                    }\n                  }\n          );\n        } catch(Exception e) {\n          // if submit fails, newSearchHolder does not get decref'd\n          if (newSearchHolder != null) {\n            newSearchHolder.decref();\n            if (returnSearcher) {\n              newSearchHolder.decref();\n            }\n          }\n          throw e;\n        }\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        for (SolrEventListener listener : firstSearcherListeners) {\n                          listener.newSearcher(newSearcher,null);\n                        }\n                      } catch (Throwable e) {\n                        SolrException.logOnce(log,null,e);\n                      }\n                      return null;\n                    }\n                  }\n          );\n        } catch(Exception e) {\n          // if submit fails, newSearchHolder does not get decref'd\n          if (newSearchHolder != null) {\n            newSearchHolder.decref();\n            if (returnSearcher) {\n              newSearchHolder.decref();\n            }\n          }\n          throw e;\n        }\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        for (SolrEventListener listener : newSearcherListeners) {\n                          listener.newSearcher(newSearcher, currSearcher);\n                        }\n                      } catch (Throwable e) {\n                        SolrException.logOnce(log,null,e);\n                      }\n                      return null;\n                    }\n                  }\n          );\n      } catch(Exception e) {\n        // if submit fails, newSearchHolder does not get decref'd\n        if (newSearchHolder != null) {\n          newSearchHolder.decref();\n          if (returnSearcher) {\n            newSearchHolder.decref();\n          }\n        }\n        throw e;\n      }\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        // signal that we no longer need to decrement\n                        // the count *before* registering the searcher since\n                        // registerSearcher will decrement even if it errors.\n                        decrementOnDeckCount[0]=false;\n                        registerSearcher(newSearchHolder);\n                      } catch (Throwable e) {\n                        SolrException.logOnce(log,null,e);\n                      } finally {\n                        // we are all done with the old searcher we used\n                        // for warming...\n                        if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                      }\n                      return null;\n                    }\n                  }\n          );\n        } catch(Exception e) {\n          // if submit fails, newSearchHolder does not get decref'd\n          if (newSearchHolder != null) {\n            newSearchHolder.decref();\n            if (returnSearcher) {\n              newSearchHolder.decref();\n            }\n          }\n          throw e;\n        }\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7a3554ff15950ad0e3bcbb4e4e2ddb45b0b0f27e","date":1320267737,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    try {\n      newestSearcher = getNewestSearcher(false);\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = new File(getIndexDir()).getCanonicalFile();\n      File newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      \n      if (newestSearcher != null && solrConfig.reopenReaders\n          && indexDirFile.equals(newIndexDirFile)) {\n\n        if (updateHandlerReopens) {\n          \n          tmp = getUpdateHandler().reopenSearcher(newestSearcher.get());\n        } else {\n          \n          IndexReader currentReader = newestSearcher.get().getIndexReader();\n          IndexReader newReader;\n          \n          // verbose(\"start reopen without writer, reader=\", currentReader);\n          newReader = IndexReader.openIfChanged(currentReader);\n          // verbose(\"reopen result\", newReader);\n\n\n          if (newReader == null) {\n            currentReader.incRef();\n            newReader = currentReader;\n          }\n          \n          tmp = new SolrIndexSearcher(this, schema, \"main\", newReader, true, true, true, directoryFactory);\n        }\n\n\n      } else {\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().mainIndexConfig, \"main\", true, true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n      }\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n    \n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n        // verbose(\"added searcher \",newSearchHolder.get(),\" to _searchers\");\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        newSearcher.warm(currSearcher);\n                      } catch (Throwable e) {\n                        SolrException.logOnce(log,null,e);\n                      }\n                      return null;\n                    }\n                  }\n          );\n        } catch(Exception e) {\n          // if submit fails, newSearchHolder does not get decref'd\n          if (newSearchHolder != null) {\n            newSearchHolder.decref();\n            if (returnSearcher) {\n              newSearchHolder.decref();\n            }\n          }\n          throw e;\n        }\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        for (SolrEventListener listener : firstSearcherListeners) {\n                          listener.newSearcher(newSearcher,null);\n                        }\n                      } catch (Throwable e) {\n                        SolrException.logOnce(log,null,e);\n                      }\n                      return null;\n                    }\n                  }\n          );\n        } catch(Exception e) {\n          // if submit fails, newSearchHolder does not get decref'd\n          if (newSearchHolder != null) {\n            newSearchHolder.decref();\n            if (returnSearcher) {\n              newSearchHolder.decref();\n            }\n          }\n          throw e;\n        }\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        for (SolrEventListener listener : newSearcherListeners) {\n                          listener.newSearcher(newSearcher, currSearcher);\n                        }\n                      } catch (Throwable e) {\n                        SolrException.logOnce(log,null,e);\n                      }\n                      return null;\n                    }\n                  }\n          );\n      } catch(Exception e) {\n        // if submit fails, newSearchHolder does not get decref'd\n        if (newSearchHolder != null) {\n          newSearchHolder.decref();\n          if (returnSearcher) {\n            newSearchHolder.decref();\n          }\n        }\n        throw e;\n      }\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        // signal that we no longer need to decrement\n                        // the count *before* registering the searcher since\n                        // registerSearcher will decrement even if it errors.\n                        decrementOnDeckCount[0]=false;\n                        registerSearcher(newSearchHolder);\n                      } catch (Throwable e) {\n                        SolrException.logOnce(log,null,e);\n                      } finally {\n                        // we are all done with the old searcher we used\n                        // for warming...\n                        if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                      }\n                      return null;\n                    }\n                  }\n          );\n        } catch(Exception e) {\n          // if submit fails, newSearchHolder does not get decref'd\n          if (newSearchHolder != null) {\n            newSearchHolder.decref();\n            if (returnSearcher) {\n              newSearchHolder.decref();\n            }\n          }\n          throw e;\n        }\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    try {\n      newestSearcher = getNewestSearcher(false);\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = new File(getIndexDir()).getCanonicalFile();\n      File newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      \n      if (newestSearcher != null && solrConfig.reopenReaders\n          && indexDirFile.equals(newIndexDirFile)) {\n        \n        if (updateHandlerReopens) {\n          \n          tmp = getUpdateHandler().reopenSearcher(newestSearcher.get());\n          \n        } else {\n          \n          IndexReader currentReader = newestSearcher.get().getIndexReader();\n          IndexReader newReader;\n          \n          newReader = IndexReader.openIfChanged(currentReader);\n          \n          if (newReader == null) {\n            currentReader.incRef();\n            newReader = currentReader;\n          }\n          \n          tmp = new SolrIndexSearcher(this, schema, \"main\", newReader, true, true, true, directoryFactory);\n        }\n\n      } else {\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().mainIndexConfig, \"main\", true, true, directoryFactory);\n      }\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n    \n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        newSearcher.warm(currSearcher);\n                      } catch (Throwable e) {\n                        SolrException.logOnce(log,null,e);\n                      }\n                      return null;\n                    }\n                  }\n          );\n        } catch(Exception e) {\n          // if submit fails, newSearchHolder does not get decref'd\n          if (newSearchHolder != null) {\n            newSearchHolder.decref();\n            if (returnSearcher) {\n              newSearchHolder.decref();\n            }\n          }\n          throw e;\n        }\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        for (SolrEventListener listener : firstSearcherListeners) {\n                          listener.newSearcher(newSearcher,null);\n                        }\n                      } catch (Throwable e) {\n                        SolrException.logOnce(log,null,e);\n                      }\n                      return null;\n                    }\n                  }\n          );\n        } catch(Exception e) {\n          // if submit fails, newSearchHolder does not get decref'd\n          if (newSearchHolder != null) {\n            newSearchHolder.decref();\n            if (returnSearcher) {\n              newSearchHolder.decref();\n            }\n          }\n          throw e;\n        }\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        for (SolrEventListener listener : newSearcherListeners) {\n                          listener.newSearcher(newSearcher, currSearcher);\n                        }\n                      } catch (Throwable e) {\n                        SolrException.logOnce(log,null,e);\n                      }\n                      return null;\n                    }\n                  }\n          );\n      } catch(Exception e) {\n        // if submit fails, newSearchHolder does not get decref'd\n        if (newSearchHolder != null) {\n          newSearchHolder.decref();\n          if (returnSearcher) {\n            newSearchHolder.decref();\n          }\n        }\n        throw e;\n      }\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        // signal that we no longer need to decrement\n                        // the count *before* registering the searcher since\n                        // registerSearcher will decrement even if it errors.\n                        decrementOnDeckCount[0]=false;\n                        registerSearcher(newSearchHolder);\n                      } catch (Throwable e) {\n                        SolrException.logOnce(log,null,e);\n                      } finally {\n                        // we are all done with the old searcher we used\n                        // for warming...\n                        if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                      }\n                      return null;\n                    }\n                  }\n          );\n        } catch(Exception e) {\n          // if submit fails, newSearchHolder does not get decref'd\n          if (newSearchHolder != null) {\n            newSearchHolder.decref();\n            if (returnSearcher) {\n              newSearchHolder.decref();\n            }\n          }\n          throw e;\n        }\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"77cc5d33c4ecf450c71edad489df69de68a73a11","date":1323189401,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    try {\n      newestSearcher = getNewestSearcher(false);\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = new File(getIndexDir()).getCanonicalFile();\n      File newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      \n      if (newestSearcher != null && solrConfig.reopenReaders\n          && indexDirFile.equals(newIndexDirFile)) {\n\n        if (updateHandlerReopens) {\n          \n          tmp = getUpdateHandler().reopenSearcher(newestSearcher.get());\n        } else {\n          \n          IndexReader currentReader = newestSearcher.get().getIndexReader();\n          IndexReader newReader;\n          \n          // verbose(\"start reopen without writer, reader=\", currentReader);\n          newReader = IndexReader.openIfChanged(currentReader);\n          // verbose(\"reopen result\", newReader);\n\n\n          if (newReader == null) {\n            currentReader.incRef();\n            newReader = currentReader;\n          }\n          \n          tmp = new SolrIndexSearcher(this, schema, \"main\", newReader, true, true, true, directoryFactory);\n        }\n\n\n      } else {\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().mainIndexConfig, \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n      }\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n    \n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n        // verbose(\"added searcher \",newSearchHolder.get(),\" to _searchers\");\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        newSearcher.warm(currSearcher);\n                      } catch (Throwable e) {\n                        SolrException.logOnce(log,null,e);\n                      }\n                      return null;\n                    }\n                  }\n          );\n        } catch(Exception e) {\n          // if submit fails, newSearchHolder does not get decref'd\n          if (newSearchHolder != null) {\n            newSearchHolder.decref();\n            if (returnSearcher) {\n              newSearchHolder.decref();\n            }\n          }\n          throw e;\n        }\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        for (SolrEventListener listener : firstSearcherListeners) {\n                          listener.newSearcher(newSearcher,null);\n                        }\n                      } catch (Throwable e) {\n                        SolrException.logOnce(log,null,e);\n                      }\n                      return null;\n                    }\n                  }\n          );\n        } catch(Exception e) {\n          // if submit fails, newSearchHolder does not get decref'd\n          if (newSearchHolder != null) {\n            newSearchHolder.decref();\n            if (returnSearcher) {\n              newSearchHolder.decref();\n            }\n          }\n          throw e;\n        }\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        for (SolrEventListener listener : newSearcherListeners) {\n                          listener.newSearcher(newSearcher, currSearcher);\n                        }\n                      } catch (Throwable e) {\n                        SolrException.logOnce(log,null,e);\n                      }\n                      return null;\n                    }\n                  }\n          );\n      } catch(Exception e) {\n        // if submit fails, newSearchHolder does not get decref'd\n        if (newSearchHolder != null) {\n          newSearchHolder.decref();\n          if (returnSearcher) {\n            newSearchHolder.decref();\n          }\n        }\n        throw e;\n      }\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        // signal that we no longer need to decrement\n                        // the count *before* registering the searcher since\n                        // registerSearcher will decrement even if it errors.\n                        decrementOnDeckCount[0]=false;\n                        registerSearcher(newSearchHolder);\n                      } catch (Throwable e) {\n                        SolrException.logOnce(log,null,e);\n                      } finally {\n                        // we are all done with the old searcher we used\n                        // for warming...\n                        if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                      }\n                      return null;\n                    }\n                  }\n          );\n        } catch(Exception e) {\n          // if submit fails, newSearchHolder does not get decref'd\n          if (newSearchHolder != null) {\n            newSearchHolder.decref();\n            if (returnSearcher) {\n              newSearchHolder.decref();\n            }\n          }\n          throw e;\n        }\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    try {\n      newestSearcher = getNewestSearcher(false);\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = new File(getIndexDir()).getCanonicalFile();\n      File newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      \n      if (newestSearcher != null && solrConfig.reopenReaders\n          && indexDirFile.equals(newIndexDirFile)) {\n\n        if (updateHandlerReopens) {\n          \n          tmp = getUpdateHandler().reopenSearcher(newestSearcher.get());\n        } else {\n          \n          IndexReader currentReader = newestSearcher.get().getIndexReader();\n          IndexReader newReader;\n          \n          // verbose(\"start reopen without writer, reader=\", currentReader);\n          newReader = IndexReader.openIfChanged(currentReader);\n          // verbose(\"reopen result\", newReader);\n\n\n          if (newReader == null) {\n            currentReader.incRef();\n            newReader = currentReader;\n          }\n          \n          tmp = new SolrIndexSearcher(this, schema, \"main\", newReader, true, true, true, directoryFactory);\n        }\n\n\n      } else {\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().mainIndexConfig, \"main\", true, true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n      }\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n    \n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n        // verbose(\"added searcher \",newSearchHolder.get(),\" to _searchers\");\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        newSearcher.warm(currSearcher);\n                      } catch (Throwable e) {\n                        SolrException.logOnce(log,null,e);\n                      }\n                      return null;\n                    }\n                  }\n          );\n        } catch(Exception e) {\n          // if submit fails, newSearchHolder does not get decref'd\n          if (newSearchHolder != null) {\n            newSearchHolder.decref();\n            if (returnSearcher) {\n              newSearchHolder.decref();\n            }\n          }\n          throw e;\n        }\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        for (SolrEventListener listener : firstSearcherListeners) {\n                          listener.newSearcher(newSearcher,null);\n                        }\n                      } catch (Throwable e) {\n                        SolrException.logOnce(log,null,e);\n                      }\n                      return null;\n                    }\n                  }\n          );\n        } catch(Exception e) {\n          // if submit fails, newSearchHolder does not get decref'd\n          if (newSearchHolder != null) {\n            newSearchHolder.decref();\n            if (returnSearcher) {\n              newSearchHolder.decref();\n            }\n          }\n          throw e;\n        }\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        for (SolrEventListener listener : newSearcherListeners) {\n                          listener.newSearcher(newSearcher, currSearcher);\n                        }\n                      } catch (Throwable e) {\n                        SolrException.logOnce(log,null,e);\n                      }\n                      return null;\n                    }\n                  }\n          );\n      } catch(Exception e) {\n        // if submit fails, newSearchHolder does not get decref'd\n        if (newSearchHolder != null) {\n          newSearchHolder.decref();\n          if (returnSearcher) {\n            newSearchHolder.decref();\n          }\n        }\n        throw e;\n      }\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        // signal that we no longer need to decrement\n                        // the count *before* registering the searcher since\n                        // registerSearcher will decrement even if it errors.\n                        decrementOnDeckCount[0]=false;\n                        registerSearcher(newSearchHolder);\n                      } catch (Throwable e) {\n                        SolrException.logOnce(log,null,e);\n                      } finally {\n                        // we are all done with the old searcher we used\n                        // for warming...\n                        if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                      }\n                      return null;\n                    }\n                  }\n          );\n        } catch(Exception e) {\n          // if submit fails, newSearchHolder does not get decref'd\n          if (newSearchHolder != null) {\n            newSearchHolder.decref();\n            if (returnSearcher) {\n              newSearchHolder.decref();\n            }\n          }\n          throw e;\n        }\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3615ce4a1f785ae1b779244de52c6a7d99227e60","date":1323422019,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    try {\n      newestSearcher = getNewestSearcher(false);\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = new File(getIndexDir()).getCanonicalFile();\n      File newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      \n      if (newestSearcher != null && solrConfig.reopenReaders\n          && indexDirFile.equals(newIndexDirFile)) {\n\n        if (updateHandlerReopens) {\n          \n          tmp = getUpdateHandler().reopenSearcher(newestSearcher.get());\n        } else {\n          \n          IndexReader currentReader = newestSearcher.get().getIndexReader();\n          IndexReader newReader;\n          \n          // verbose(\"start reopen without writer, reader=\", currentReader);\n          newReader = IndexReader.openIfChanged(currentReader);\n          // verbose(\"reopen result\", newReader);\n\n\n          if (newReader == null) {\n            currentReader.incRef();\n            newReader = currentReader;\n          }\n          \n          tmp = new SolrIndexSearcher(this, schema, \"main\", newReader, true, true, true, directoryFactory);\n        }\n\n\n      } else {\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().mainIndexConfig, \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n      }\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n    \n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n        // verbose(\"added searcher \",newSearchHolder.get(),\" to _searchers\");\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        newSearcher.warm(currSearcher);\n                      } catch (Throwable e) {\n                        SolrException.logOnce(log,null,e);\n                      }\n                      return null;\n                    }\n                  }\n          );\n        } catch(Exception e) {\n          // if submit fails, newSearchHolder does not get decref'd\n          if (newSearchHolder != null) {\n            newSearchHolder.decref();\n            if (returnSearcher) {\n              newSearchHolder.decref();\n            }\n          }\n          throw e;\n        }\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        for (SolrEventListener listener : firstSearcherListeners) {\n                          listener.newSearcher(newSearcher,null);\n                        }\n                      } catch (Throwable e) {\n                        SolrException.logOnce(log,null,e);\n                      }\n                      return null;\n                    }\n                  }\n          );\n        } catch(Exception e) {\n          // if submit fails, newSearchHolder does not get decref'd\n          if (newSearchHolder != null) {\n            newSearchHolder.decref();\n            if (returnSearcher) {\n              newSearchHolder.decref();\n            }\n          }\n          throw e;\n        }\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        for (SolrEventListener listener : newSearcherListeners) {\n                          listener.newSearcher(newSearcher, currSearcher);\n                        }\n                      } catch (Throwable e) {\n                        SolrException.logOnce(log,null,e);\n                      }\n                      return null;\n                    }\n                  }\n          );\n      } catch(Exception e) {\n        // if submit fails, newSearchHolder does not get decref'd\n        if (newSearchHolder != null) {\n          newSearchHolder.decref();\n          if (returnSearcher) {\n            newSearchHolder.decref();\n          }\n        }\n        throw e;\n      }\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        // signal that we no longer need to decrement\n                        // the count *before* registering the searcher since\n                        // registerSearcher will decrement even if it errors.\n                        decrementOnDeckCount[0]=false;\n                        registerSearcher(newSearchHolder);\n                      } catch (Throwable e) {\n                        SolrException.logOnce(log,null,e);\n                      } finally {\n                        // we are all done with the old searcher we used\n                        // for warming...\n                        if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                      }\n                      return null;\n                    }\n                  }\n          );\n        } catch(Exception e) {\n          // if submit fails, newSearchHolder does not get decref'd\n          if (newSearchHolder != null) {\n            newSearchHolder.decref();\n            if (returnSearcher) {\n              newSearchHolder.decref();\n            }\n          }\n          throw e;\n        }\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    try {\n      newestSearcher = getNewestSearcher(false);\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = new File(getIndexDir()).getCanonicalFile();\n      File newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      \n      if (newestSearcher != null && solrConfig.reopenReaders\n          && indexDirFile.equals(newIndexDirFile)) {\n\n        if (updateHandlerReopens) {\n          \n          tmp = getUpdateHandler().reopenSearcher(newestSearcher.get());\n        } else {\n          \n          IndexReader currentReader = newestSearcher.get().getIndexReader();\n          IndexReader newReader;\n          \n          // verbose(\"start reopen without writer, reader=\", currentReader);\n          newReader = IndexReader.openIfChanged(currentReader);\n          // verbose(\"reopen result\", newReader);\n\n\n          if (newReader == null) {\n            currentReader.incRef();\n            newReader = currentReader;\n          }\n          \n          tmp = new SolrIndexSearcher(this, schema, \"main\", newReader, true, true, true, directoryFactory);\n        }\n\n\n      } else {\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().mainIndexConfig, \"main\", true, true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n      }\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n    \n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n        // verbose(\"added searcher \",newSearchHolder.get(),\" to _searchers\");\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        newSearcher.warm(currSearcher);\n                      } catch (Throwable e) {\n                        SolrException.logOnce(log,null,e);\n                      }\n                      return null;\n                    }\n                  }\n          );\n        } catch(Exception e) {\n          // if submit fails, newSearchHolder does not get decref'd\n          if (newSearchHolder != null) {\n            newSearchHolder.decref();\n            if (returnSearcher) {\n              newSearchHolder.decref();\n            }\n          }\n          throw e;\n        }\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        for (SolrEventListener listener : firstSearcherListeners) {\n                          listener.newSearcher(newSearcher,null);\n                        }\n                      } catch (Throwable e) {\n                        SolrException.logOnce(log,null,e);\n                      }\n                      return null;\n                    }\n                  }\n          );\n        } catch(Exception e) {\n          // if submit fails, newSearchHolder does not get decref'd\n          if (newSearchHolder != null) {\n            newSearchHolder.decref();\n            if (returnSearcher) {\n              newSearchHolder.decref();\n            }\n          }\n          throw e;\n        }\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        for (SolrEventListener listener : newSearcherListeners) {\n                          listener.newSearcher(newSearcher, currSearcher);\n                        }\n                      } catch (Throwable e) {\n                        SolrException.logOnce(log,null,e);\n                      }\n                      return null;\n                    }\n                  }\n          );\n      } catch(Exception e) {\n        // if submit fails, newSearchHolder does not get decref'd\n        if (newSearchHolder != null) {\n          newSearchHolder.decref();\n          if (returnSearcher) {\n            newSearchHolder.decref();\n          }\n        }\n        throw e;\n      }\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        // signal that we no longer need to decrement\n                        // the count *before* registering the searcher since\n                        // registerSearcher will decrement even if it errors.\n                        decrementOnDeckCount[0]=false;\n                        registerSearcher(newSearchHolder);\n                      } catch (Throwable e) {\n                        SolrException.logOnce(log,null,e);\n                      } finally {\n                        // we are all done with the old searcher we used\n                        // for warming...\n                        if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                      }\n                      return null;\n                    }\n                  }\n          );\n        } catch(Exception e) {\n          // if submit fails, newSearchHolder does not get decref'd\n          if (newSearchHolder != null) {\n            newSearchHolder.decref();\n            if (returnSearcher) {\n              newSearchHolder.decref();\n            }\n          }\n          throw e;\n        }\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00","date":1323437438,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    try {\n      newestSearcher = getNewestSearcher(false);\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = new File(getIndexDir()).getCanonicalFile();\n      File newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      \n      if (newestSearcher != null && solrConfig.reopenReaders\n          && indexDirFile.equals(newIndexDirFile)) {\n\n        if (updateHandlerReopens) {\n          \n          tmp = getUpdateHandler().reopenSearcher(newestSearcher.get());\n        } else {\n          \n          IndexReader currentReader = newestSearcher.get().getIndexReader();\n          IndexReader newReader;\n          \n          // verbose(\"start reopen without writer, reader=\", currentReader);\n          newReader = IndexReader.openIfChanged(currentReader);\n          // verbose(\"reopen result\", newReader);\n\n\n          if (newReader == null) {\n            currentReader.incRef();\n            newReader = currentReader;\n          }\n          \n          tmp = new SolrIndexSearcher(this, schema, \"main\", newReader, true, true, true, directoryFactory);\n        }\n\n\n      } else {\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().mainIndexConfig, \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n      }\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n    \n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n        // verbose(\"added searcher \",newSearchHolder.get(),\" to _searchers\");\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        newSearcher.warm(currSearcher);\n                      } catch (Throwable e) {\n                        SolrException.logOnce(log,null,e);\n                      }\n                      return null;\n                    }\n                  }\n          );\n        } catch(Exception e) {\n          // if submit fails, newSearchHolder does not get decref'd\n          if (newSearchHolder != null) {\n            newSearchHolder.decref();\n            if (returnSearcher) {\n              newSearchHolder.decref();\n            }\n          }\n          throw e;\n        }\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        for (SolrEventListener listener : firstSearcherListeners) {\n                          listener.newSearcher(newSearcher,null);\n                        }\n                      } catch (Throwable e) {\n                        SolrException.logOnce(log,null,e);\n                      }\n                      return null;\n                    }\n                  }\n          );\n        } catch(Exception e) {\n          // if submit fails, newSearchHolder does not get decref'd\n          if (newSearchHolder != null) {\n            newSearchHolder.decref();\n            if (returnSearcher) {\n              newSearchHolder.decref();\n            }\n          }\n          throw e;\n        }\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        for (SolrEventListener listener : newSearcherListeners) {\n                          listener.newSearcher(newSearcher, currSearcher);\n                        }\n                      } catch (Throwable e) {\n                        SolrException.logOnce(log,null,e);\n                      }\n                      return null;\n                    }\n                  }\n          );\n      } catch(Exception e) {\n        // if submit fails, newSearchHolder does not get decref'd\n        if (newSearchHolder != null) {\n          newSearchHolder.decref();\n          if (returnSearcher) {\n            newSearchHolder.decref();\n          }\n        }\n        throw e;\n      }\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        // signal that we no longer need to decrement\n                        // the count *before* registering the searcher since\n                        // registerSearcher will decrement even if it errors.\n                        decrementOnDeckCount[0]=false;\n                        registerSearcher(newSearchHolder);\n                      } catch (Throwable e) {\n                        SolrException.logOnce(log,null,e);\n                      } finally {\n                        // we are all done with the old searcher we used\n                        // for warming...\n                        if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                      }\n                      return null;\n                    }\n                  }\n          );\n        } catch(Exception e) {\n          // if submit fails, newSearchHolder does not get decref'd\n          if (newSearchHolder != null) {\n            newSearchHolder.decref();\n            if (returnSearcher) {\n              newSearchHolder.decref();\n            }\n          }\n          throw e;\n        }\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    try {\n      newestSearcher = getNewestSearcher(false);\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = new File(getIndexDir()).getCanonicalFile();\n      File newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      \n      if (newestSearcher != null && solrConfig.reopenReaders\n          && indexDirFile.equals(newIndexDirFile)) {\n\n        if (updateHandlerReopens) {\n          \n          tmp = getUpdateHandler().reopenSearcher(newestSearcher.get());\n        } else {\n          \n          IndexReader currentReader = newestSearcher.get().getIndexReader();\n          IndexReader newReader;\n          \n          // verbose(\"start reopen without writer, reader=\", currentReader);\n          newReader = IndexReader.openIfChanged(currentReader);\n          // verbose(\"reopen result\", newReader);\n\n\n          if (newReader == null) {\n            currentReader.incRef();\n            newReader = currentReader;\n          }\n          \n          tmp = new SolrIndexSearcher(this, schema, \"main\", newReader, true, true, true, directoryFactory);\n        }\n\n\n      } else {\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().mainIndexConfig, \"main\", true, true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n      }\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n    \n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n        // verbose(\"added searcher \",newSearchHolder.get(),\" to _searchers\");\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        newSearcher.warm(currSearcher);\n                      } catch (Throwable e) {\n                        SolrException.logOnce(log,null,e);\n                      }\n                      return null;\n                    }\n                  }\n          );\n        } catch(Exception e) {\n          // if submit fails, newSearchHolder does not get decref'd\n          if (newSearchHolder != null) {\n            newSearchHolder.decref();\n            if (returnSearcher) {\n              newSearchHolder.decref();\n            }\n          }\n          throw e;\n        }\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        for (SolrEventListener listener : firstSearcherListeners) {\n                          listener.newSearcher(newSearcher,null);\n                        }\n                      } catch (Throwable e) {\n                        SolrException.logOnce(log,null,e);\n                      }\n                      return null;\n                    }\n                  }\n          );\n        } catch(Exception e) {\n          // if submit fails, newSearchHolder does not get decref'd\n          if (newSearchHolder != null) {\n            newSearchHolder.decref();\n            if (returnSearcher) {\n              newSearchHolder.decref();\n            }\n          }\n          throw e;\n        }\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        for (SolrEventListener listener : newSearcherListeners) {\n                          listener.newSearcher(newSearcher, currSearcher);\n                        }\n                      } catch (Throwable e) {\n                        SolrException.logOnce(log,null,e);\n                      }\n                      return null;\n                    }\n                  }\n          );\n      } catch(Exception e) {\n        // if submit fails, newSearchHolder does not get decref'd\n        if (newSearchHolder != null) {\n          newSearchHolder.decref();\n          if (returnSearcher) {\n            newSearchHolder.decref();\n          }\n        }\n        throw e;\n      }\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        // signal that we no longer need to decrement\n                        // the count *before* registering the searcher since\n                        // registerSearcher will decrement even if it errors.\n                        decrementOnDeckCount[0]=false;\n                        registerSearcher(newSearchHolder);\n                      } catch (Throwable e) {\n                        SolrException.logOnce(log,null,e);\n                      } finally {\n                        // we are all done with the old searcher we used\n                        // for warming...\n                        if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                      }\n                      return null;\n                    }\n                  }\n          );\n        } catch(Exception e) {\n          // if submit fails, newSearchHolder does not get decref'd\n          if (newSearchHolder != null) {\n            newSearchHolder.decref();\n            if (returnSearcher) {\n              newSearchHolder.decref();\n            }\n          }\n          throw e;\n        }\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b1605dda5afabdc06fd136fa0dd14ad326e3001","date":1326751633,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    try {\n      newestSearcher = getNewestSearcher(false);\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = new File(getIndexDir()).getCanonicalFile();\n      File newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      \n      if (newestSearcher != null && solrConfig.reopenReaders\n          && indexDirFile.equals(newIndexDirFile)) {\n\n        if (updateHandlerReopens) {\n          \n          tmp = getUpdateHandler().reopenSearcher(newestSearcher.get());\n        } else {\n          \n          IndexReader currentReader = newestSearcher.get().getIndexReader();\n          IndexReader newReader;\n          \n          // verbose(\"start reopen without writer, reader=\", currentReader);\n          newReader = IndexReader.openIfChanged(currentReader);\n          // verbose(\"reopen result\", newReader);\n\n\n          if (newReader == null) {\n            currentReader.incRef();\n            newReader = currentReader;\n          }\n          \n          tmp = new SolrIndexSearcher(this, schema, \"main\", newReader, true, true, true, directoryFactory);\n        }\n\n\n      } else {\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().mainIndexConfig, \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n      }\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n    \n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n        // verbose(\"added searcher \",newSearchHolder.get(),\" to _searchers\");\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        newSearcher.warm(currSearcher);\n                      } catch (Throwable e) {\n                        SolrException.log(log, null, e);\n                      }\n                      return null;\n                    }\n                  }\n          );\n        } catch(Exception e) {\n          // if submit fails, newSearchHolder does not get decref'd\n          if (newSearchHolder != null) {\n            newSearchHolder.decref();\n            if (returnSearcher) {\n              newSearchHolder.decref();\n            }\n          }\n          throw e;\n        }\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        for (SolrEventListener listener : firstSearcherListeners) {\n                          listener.newSearcher(newSearcher,null);\n                        }\n                      } catch (Throwable e) {\n                        SolrException.log(log, null, e);\n                      }\n                      return null;\n                    }\n                  }\n          );\n        } catch(Exception e) {\n          // if submit fails, newSearchHolder does not get decref'd\n          if (newSearchHolder != null) {\n            newSearchHolder.decref();\n            if (returnSearcher) {\n              newSearchHolder.decref();\n            }\n          }\n          throw e;\n        }\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        for (SolrEventListener listener : newSearcherListeners) {\n                          listener.newSearcher(newSearcher, currSearcher);\n                        }\n                      } catch (Throwable e) {\n                        SolrException.log(log, null, e);\n                      }\n                      return null;\n                    }\n                  }\n          );\n      } catch(Exception e) {\n        // if submit fails, newSearchHolder does not get decref'd\n        if (newSearchHolder != null) {\n          newSearchHolder.decref();\n          if (returnSearcher) {\n            newSearchHolder.decref();\n          }\n        }\n        throw e;\n      }\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        // signal that we no longer need to decrement\n                        // the count *before* registering the searcher since\n                        // registerSearcher will decrement even if it errors.\n                        decrementOnDeckCount[0]=false;\n                        registerSearcher(newSearchHolder);\n                      } catch (Throwable e) {\n                        SolrException.log(log, null, e);\n                      } finally {\n                        // we are all done with the old searcher we used\n                        // for warming...\n                        if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                      }\n                      return null;\n                    }\n                  }\n          );\n        } catch(Exception e) {\n          // if submit fails, newSearchHolder does not get decref'd\n          if (newSearchHolder != null) {\n            newSearchHolder.decref();\n            if (returnSearcher) {\n              newSearchHolder.decref();\n            }\n          }\n          throw e;\n        }\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.log(log, null, e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    try {\n      newestSearcher = getNewestSearcher(false);\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = new File(getIndexDir()).getCanonicalFile();\n      File newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      \n      if (newestSearcher != null && solrConfig.reopenReaders\n          && indexDirFile.equals(newIndexDirFile)) {\n\n        if (updateHandlerReopens) {\n          \n          tmp = getUpdateHandler().reopenSearcher(newestSearcher.get());\n        } else {\n          \n          IndexReader currentReader = newestSearcher.get().getIndexReader();\n          IndexReader newReader;\n          \n          // verbose(\"start reopen without writer, reader=\", currentReader);\n          newReader = IndexReader.openIfChanged(currentReader);\n          // verbose(\"reopen result\", newReader);\n\n\n          if (newReader == null) {\n            currentReader.incRef();\n            newReader = currentReader;\n          }\n          \n          tmp = new SolrIndexSearcher(this, schema, \"main\", newReader, true, true, true, directoryFactory);\n        }\n\n\n      } else {\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().mainIndexConfig, \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n      }\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n    \n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n        // verbose(\"added searcher \",newSearchHolder.get(),\" to _searchers\");\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        newSearcher.warm(currSearcher);\n                      } catch (Throwable e) {\n                        SolrException.logOnce(log,null,e);\n                      }\n                      return null;\n                    }\n                  }\n          );\n        } catch(Exception e) {\n          // if submit fails, newSearchHolder does not get decref'd\n          if (newSearchHolder != null) {\n            newSearchHolder.decref();\n            if (returnSearcher) {\n              newSearchHolder.decref();\n            }\n          }\n          throw e;\n        }\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        for (SolrEventListener listener : firstSearcherListeners) {\n                          listener.newSearcher(newSearcher,null);\n                        }\n                      } catch (Throwable e) {\n                        SolrException.logOnce(log,null,e);\n                      }\n                      return null;\n                    }\n                  }\n          );\n        } catch(Exception e) {\n          // if submit fails, newSearchHolder does not get decref'd\n          if (newSearchHolder != null) {\n            newSearchHolder.decref();\n            if (returnSearcher) {\n              newSearchHolder.decref();\n            }\n          }\n          throw e;\n        }\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        for (SolrEventListener listener : newSearcherListeners) {\n                          listener.newSearcher(newSearcher, currSearcher);\n                        }\n                      } catch (Throwable e) {\n                        SolrException.logOnce(log,null,e);\n                      }\n                      return null;\n                    }\n                  }\n          );\n      } catch(Exception e) {\n        // if submit fails, newSearchHolder does not get decref'd\n        if (newSearchHolder != null) {\n          newSearchHolder.decref();\n          if (returnSearcher) {\n            newSearchHolder.decref();\n          }\n        }\n        throw e;\n      }\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        // signal that we no longer need to decrement\n                        // the count *before* registering the searcher since\n                        // registerSearcher will decrement even if it errors.\n                        decrementOnDeckCount[0]=false;\n                        registerSearcher(newSearchHolder);\n                      } catch (Throwable e) {\n                        SolrException.logOnce(log,null,e);\n                      } finally {\n                        // we are all done with the old searcher we used\n                        // for warming...\n                        if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                      }\n                      return null;\n                    }\n                  }\n          );\n        } catch(Exception e) {\n          // if submit fails, newSearchHolder does not get decref'd\n          if (newSearchHolder != null) {\n            newSearchHolder.decref();\n            if (returnSearcher) {\n              newSearchHolder.decref();\n            }\n          }\n          throw e;\n        }\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2c007e7c4cf8c55bc2a5884e315123afaaeec87f","date":1327520966,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n       // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n       // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              public Object call() throws Exception {\n                try {\n                  newSearcher.warm(currSearcher);\n                } catch (Throwable e) {\n                  SolrException.log(log,e);\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              public Object call() throws Exception {\n                try {\n                  for (SolrEventListener listener : firstSearcherListeners) {\n                    listener.newSearcher(newSearcher,null);\n                  }\n                } catch (Throwable e) {\n                  SolrException.log(log,null,e);\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              public Object call() throws Exception {\n                try {\n                  for (SolrEventListener listener : newSearcherListeners) {\n                    listener.newSearcher(newSearcher, currSearcher);\n                  }\n                } catch (Throwable e) {\n                  SolrException.log(log,null,e);\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              public Object call() throws Exception {\n                try {\n                  // registerSearcher will decrement onDeckSearchers and\n                  // do a notify, even if it fails.\n                  registerSearcher(newSearchHolder);\n                } catch (Throwable e) {\n                  SolrException.log(log, e);\n                } finally {\n                  // we are all done with the old searcher we used\n                  // for warming...\n                  if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof SolrException) throw (SolrException)e;\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      if (!success) {\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n            onDeckSearchers=0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    try {\n      newestSearcher = getNewestSearcher(false);\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = new File(getIndexDir()).getCanonicalFile();\n      File newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      \n      if (newestSearcher != null && solrConfig.reopenReaders\n          && indexDirFile.equals(newIndexDirFile)) {\n\n        if (updateHandlerReopens) {\n          \n          tmp = getUpdateHandler().reopenSearcher(newestSearcher.get());\n        } else {\n          \n          IndexReader currentReader = newestSearcher.get().getIndexReader();\n          IndexReader newReader;\n          \n          // verbose(\"start reopen without writer, reader=\", currentReader);\n          newReader = IndexReader.openIfChanged(currentReader);\n          // verbose(\"reopen result\", newReader);\n\n\n          if (newReader == null) {\n            currentReader.incRef();\n            newReader = currentReader;\n          }\n          \n          tmp = new SolrIndexSearcher(this, schema, \"main\", newReader, true, true, true, directoryFactory);\n        }\n\n\n      } else {\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().mainIndexConfig, \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n      }\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n    \n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n        // verbose(\"added searcher \",newSearchHolder.get(),\" to _searchers\");\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        newSearcher.warm(currSearcher);\n                      } catch (Throwable e) {\n                        SolrException.log(log, null, e);\n                      }\n                      return null;\n                    }\n                  }\n          );\n        } catch(Exception e) {\n          // if submit fails, newSearchHolder does not get decref'd\n          if (newSearchHolder != null) {\n            newSearchHolder.decref();\n            if (returnSearcher) {\n              newSearchHolder.decref();\n            }\n          }\n          throw e;\n        }\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        for (SolrEventListener listener : firstSearcherListeners) {\n                          listener.newSearcher(newSearcher,null);\n                        }\n                      } catch (Throwable e) {\n                        SolrException.log(log, null, e);\n                      }\n                      return null;\n                    }\n                  }\n          );\n        } catch(Exception e) {\n          // if submit fails, newSearchHolder does not get decref'd\n          if (newSearchHolder != null) {\n            newSearchHolder.decref();\n            if (returnSearcher) {\n              newSearchHolder.decref();\n            }\n          }\n          throw e;\n        }\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        for (SolrEventListener listener : newSearcherListeners) {\n                          listener.newSearcher(newSearcher, currSearcher);\n                        }\n                      } catch (Throwable e) {\n                        SolrException.log(log, null, e);\n                      }\n                      return null;\n                    }\n                  }\n          );\n      } catch(Exception e) {\n        // if submit fails, newSearchHolder does not get decref'd\n        if (newSearchHolder != null) {\n          newSearchHolder.decref();\n          if (returnSearcher) {\n            newSearchHolder.decref();\n          }\n        }\n        throw e;\n      }\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        // signal that we no longer need to decrement\n                        // the count *before* registering the searcher since\n                        // registerSearcher will decrement even if it errors.\n                        decrementOnDeckCount[0]=false;\n                        registerSearcher(newSearchHolder);\n                      } catch (Throwable e) {\n                        SolrException.log(log, null, e);\n                      } finally {\n                        // we are all done with the old searcher we used\n                        // for warming...\n                        if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                      }\n                      return null;\n                    }\n                  }\n          );\n        } catch(Exception e) {\n          // if submit fails, newSearchHolder does not get decref'd\n          if (newSearchHolder != null) {\n            newSearchHolder.decref();\n            if (returnSearcher) {\n              newSearchHolder.decref();\n            }\n          }\n          throw e;\n        }\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.log(log, null, e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","bugFix":null,"bugIntro":["96e0d4494fe54b31c7f0151f3a632124ab806351","bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n       // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n       // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              public Object call() throws Exception {\n                try {\n                  newSearcher.warm(currSearcher);\n                } catch (Throwable e) {\n                  SolrException.log(log,e);\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              public Object call() throws Exception {\n                try {\n                  for (SolrEventListener listener : firstSearcherListeners) {\n                    listener.newSearcher(newSearcher,null);\n                  }\n                } catch (Throwable e) {\n                  SolrException.log(log,null,e);\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              public Object call() throws Exception {\n                try {\n                  for (SolrEventListener listener : newSearcherListeners) {\n                    listener.newSearcher(newSearcher, currSearcher);\n                  }\n                } catch (Throwable e) {\n                  SolrException.log(log,null,e);\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              public Object call() throws Exception {\n                try {\n                  // registerSearcher will decrement onDeckSearchers and\n                  // do a notify, even if it fails.\n                  registerSearcher(newSearchHolder);\n                } catch (Throwable e) {\n                  SolrException.log(log, e);\n                } finally {\n                  // we are all done with the old searcher we used\n                  // for warming...\n                  if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof SolrException) throw (SolrException)e;\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      if (!success) {\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n            onDeckSearchers=0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    try {\n      newestSearcher = getNewestSearcher(false);\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = new File(getIndexDir()).getCanonicalFile();\n      File newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      \n      if (newestSearcher != null && solrConfig.reopenReaders\n          && indexDirFile.equals(newIndexDirFile)) {\n\n        if (updateHandlerReopens) {\n          \n          tmp = getUpdateHandler().reopenSearcher(newestSearcher.get());\n        } else {\n          \n          IndexReader currentReader = newestSearcher.get().getIndexReader();\n          IndexReader newReader;\n          \n          // verbose(\"start reopen without writer, reader=\", currentReader);\n          newReader = IndexReader.openIfChanged(currentReader);\n          // verbose(\"reopen result\", newReader);\n\n\n          if (newReader == null) {\n            currentReader.incRef();\n            newReader = currentReader;\n          }\n          \n          tmp = new SolrIndexSearcher(this, schema, \"main\", newReader, true, true, true, directoryFactory);\n        }\n\n\n      } else {\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().mainIndexConfig, \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n      }\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n    \n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n        // verbose(\"added searcher \",newSearchHolder.get(),\" to _searchers\");\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        newSearcher.warm(currSearcher);\n                      } catch (Throwable e) {\n                        SolrException.log(log, null, e);\n                      }\n                      return null;\n                    }\n                  }\n          );\n        } catch(Exception e) {\n          // if submit fails, newSearchHolder does not get decref'd\n          if (newSearchHolder != null) {\n            newSearchHolder.decref();\n            if (returnSearcher) {\n              newSearchHolder.decref();\n            }\n          }\n          throw e;\n        }\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        for (SolrEventListener listener : firstSearcherListeners) {\n                          listener.newSearcher(newSearcher,null);\n                        }\n                      } catch (Throwable e) {\n                        SolrException.log(log, null, e);\n                      }\n                      return null;\n                    }\n                  }\n          );\n        } catch(Exception e) {\n          // if submit fails, newSearchHolder does not get decref'd\n          if (newSearchHolder != null) {\n            newSearchHolder.decref();\n            if (returnSearcher) {\n              newSearchHolder.decref();\n            }\n          }\n          throw e;\n        }\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        for (SolrEventListener listener : newSearcherListeners) {\n                          listener.newSearcher(newSearcher, currSearcher);\n                        }\n                      } catch (Throwable e) {\n                        SolrException.log(log, null, e);\n                      }\n                      return null;\n                    }\n                  }\n          );\n      } catch(Exception e) {\n        // if submit fails, newSearchHolder does not get decref'd\n        if (newSearchHolder != null) {\n          newSearchHolder.decref();\n          if (returnSearcher) {\n            newSearchHolder.decref();\n          }\n        }\n        throw e;\n      }\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        // signal that we no longer need to decrement\n                        // the count *before* registering the searcher since\n                        // registerSearcher will decrement even if it errors.\n                        decrementOnDeckCount[0]=false;\n                        registerSearcher(newSearchHolder);\n                      } catch (Throwable e) {\n                        SolrException.log(log, null, e);\n                      } finally {\n                        // we are all done with the old searcher we used\n                        // for warming...\n                        if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                      }\n                      return null;\n                    }\n                  }\n          );\n        } catch(Exception e) {\n          // if submit fails, newSearchHolder does not get decref'd\n          if (newSearchHolder != null) {\n            newSearchHolder.decref();\n            if (returnSearcher) {\n              newSearchHolder.decref();\n            }\n          }\n          throw e;\n        }\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.log(log, null, e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d22ac6a4146774c1bc8400160fc0b6150294e92","date":1327528604,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n       // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n       // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              public Object call() throws Exception {\n                try {\n                  newSearcher.warm(currSearcher);\n                } catch (Throwable e) {\n                  SolrException.log(log,e);\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              public Object call() throws Exception {\n                try {\n                  for (SolrEventListener listener : firstSearcherListeners) {\n                    listener.newSearcher(newSearcher,null);\n                  }\n                } catch (Throwable e) {\n                  SolrException.log(log,null,e);\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              public Object call() throws Exception {\n                try {\n                  for (SolrEventListener listener : newSearcherListeners) {\n                    listener.newSearcher(newSearcher, currSearcher);\n                  }\n                } catch (Throwable e) {\n                  SolrException.log(log,null,e);\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              public Object call() throws Exception {\n                try {\n                  // registerSearcher will decrement onDeckSearchers and\n                  // do a notify, even if it fails.\n                  registerSearcher(newSearchHolder);\n                } catch (Throwable e) {\n                  SolrException.log(log, e);\n                } finally {\n                  // we are all done with the old searcher we used\n                  // for warming...\n                  if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof SolrException) throw (SolrException)e;\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      if (!success) {\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n            onDeckSearchers=0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    try {\n      newestSearcher = getNewestSearcher(false);\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = new File(getIndexDir()).getCanonicalFile();\n      File newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      \n      if (newestSearcher != null && solrConfig.reopenReaders\n          && indexDirFile.equals(newIndexDirFile)) {\n\n        if (updateHandlerReopens) {\n          \n          tmp = getUpdateHandler().reopenSearcher(newestSearcher.get());\n        } else {\n          \n          IndexReader currentReader = newestSearcher.get().getIndexReader();\n          IndexReader newReader;\n          \n          // verbose(\"start reopen without writer, reader=\", currentReader);\n          newReader = IndexReader.openIfChanged(currentReader);\n          // verbose(\"reopen result\", newReader);\n\n\n          if (newReader == null) {\n            currentReader.incRef();\n            newReader = currentReader;\n          }\n          \n          tmp = new SolrIndexSearcher(this, schema, \"main\", newReader, true, true, true, directoryFactory);\n        }\n\n\n      } else {\n        // verbose(\"non-reopen START:\");\n        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().mainIndexConfig, \"main\", true, directoryFactory);\n        // verbose(\"non-reopen DONE: searcher=\",tmp);\n      }\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n    \n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n        // verbose(\"added searcher \",newSearchHolder.get(),\" to _searchers\");\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        newSearcher.warm(currSearcher);\n                      } catch (Throwable e) {\n                        SolrException.log(log, null, e);\n                      }\n                      return null;\n                    }\n                  }\n          );\n        } catch(Exception e) {\n          // if submit fails, newSearchHolder does not get decref'd\n          if (newSearchHolder != null) {\n            newSearchHolder.decref();\n            if (returnSearcher) {\n              newSearchHolder.decref();\n            }\n          }\n          throw e;\n        }\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        for (SolrEventListener listener : firstSearcherListeners) {\n                          listener.newSearcher(newSearcher,null);\n                        }\n                      } catch (Throwable e) {\n                        SolrException.log(log, null, e);\n                      }\n                      return null;\n                    }\n                  }\n          );\n        } catch(Exception e) {\n          // if submit fails, newSearchHolder does not get decref'd\n          if (newSearchHolder != null) {\n            newSearchHolder.decref();\n            if (returnSearcher) {\n              newSearchHolder.decref();\n            }\n          }\n          throw e;\n        }\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        for (SolrEventListener listener : newSearcherListeners) {\n                          listener.newSearcher(newSearcher, currSearcher);\n                        }\n                      } catch (Throwable e) {\n                        SolrException.log(log, null, e);\n                      }\n                      return null;\n                    }\n                  }\n          );\n      } catch(Exception e) {\n        // if submit fails, newSearchHolder does not get decref'd\n        if (newSearchHolder != null) {\n          newSearchHolder.decref();\n          if (returnSearcher) {\n            newSearchHolder.decref();\n          }\n        }\n        throw e;\n      }\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        try {\n          future = searcherExecutor.submit(\n                  new Callable() {\n                    public Object call() throws Exception {\n                      try {\n                        // signal that we no longer need to decrement\n                        // the count *before* registering the searcher since\n                        // registerSearcher will decrement even if it errors.\n                        decrementOnDeckCount[0]=false;\n                        registerSearcher(newSearchHolder);\n                      } catch (Throwable e) {\n                        SolrException.log(log, null, e);\n                      } finally {\n                        // we are all done with the old searcher we used\n                        // for warming...\n                        if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                      }\n                      return null;\n                    }\n                  }\n          );\n        } catch(Exception e) {\n          // if submit fails, newSearchHolder does not get decref'd\n          if (newSearchHolder != null) {\n            newSearchHolder.decref();\n            if (returnSearcher) {\n              newSearchHolder.decref();\n            }\n          }\n          throw e;\n        }\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.log(log, null, e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"da31fa73cb487fbb3136c9165470193515358b0b","date":1335818643,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg);\n      } else if (onDeckSearchers > 1) {\n        log.warn(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n       // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n       // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              public Object call() throws Exception {\n                try {\n                  newSearcher.warm(currSearcher);\n                } catch (Throwable e) {\n                  SolrException.log(log,e);\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              public Object call() throws Exception {\n                try {\n                  for (SolrEventListener listener : firstSearcherListeners) {\n                    listener.newSearcher(newSearcher,null);\n                  }\n                } catch (Throwable e) {\n                  SolrException.log(log,null,e);\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              public Object call() throws Exception {\n                try {\n                  for (SolrEventListener listener : newSearcherListeners) {\n                    listener.newSearcher(newSearcher, currSearcher);\n                  }\n                } catch (Throwable e) {\n                  SolrException.log(log,null,e);\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              public Object call() throws Exception {\n                try {\n                  // registerSearcher will decrement onDeckSearchers and\n                  // do a notify, even if it fails.\n                  registerSearcher(newSearchHolder);\n                } catch (Throwable e) {\n                  SolrException.log(log, e);\n                } finally {\n                  // we are all done with the old searcher we used\n                  // for warming...\n                  if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof SolrException) throw (SolrException)e;\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      if (!success) {\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n            onDeckSearchers=0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n       // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n       // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              public Object call() throws Exception {\n                try {\n                  newSearcher.warm(currSearcher);\n                } catch (Throwable e) {\n                  SolrException.log(log,e);\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              public Object call() throws Exception {\n                try {\n                  for (SolrEventListener listener : firstSearcherListeners) {\n                    listener.newSearcher(newSearcher,null);\n                  }\n                } catch (Throwable e) {\n                  SolrException.log(log,null,e);\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              public Object call() throws Exception {\n                try {\n                  for (SolrEventListener listener : newSearcherListeners) {\n                    listener.newSearcher(newSearcher, currSearcher);\n                  }\n                } catch (Throwable e) {\n                  SolrException.log(log,null,e);\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              public Object call() throws Exception {\n                try {\n                  // registerSearcher will decrement onDeckSearchers and\n                  // do a notify, even if it fails.\n                  registerSearcher(newSearchHolder);\n                } catch (Throwable e) {\n                  SolrException.log(log, e);\n                } finally {\n                  // we are all done with the old searcher we used\n                  // for warming...\n                  if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof SolrException) throw (SolrException)e;\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      if (!success) {\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n            onDeckSearchers=0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4d3e8520fd031bab31fd0e4d480e55958bc45efe","date":1340901565,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg);\n      } else if (onDeckSearchers > 1) {\n        log.warn(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n       // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n       // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              public Object call() throws Exception {\n                try {\n                  newSearcher.warm(currSearcher);\n                } catch (Throwable e) {\n                  SolrException.log(log,e);\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              public Object call() throws Exception {\n                try {\n                  for (SolrEventListener listener : firstSearcherListeners) {\n                    listener.newSearcher(newSearcher,null);\n                  }\n                } catch (Throwable e) {\n                  SolrException.log(log,null,e);\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              public Object call() throws Exception {\n                try {\n                  for (SolrEventListener listener : newSearcherListeners) {\n                    listener.newSearcher(newSearcher, currSearcher);\n                  }\n                } catch (Throwable e) {\n                  SolrException.log(log,null,e);\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              public Object call() throws Exception {\n                try {\n                  // registerSearcher will decrement onDeckSearchers and\n                  // do a notify, even if it fails.\n                  registerSearcher(newSearchHolder);\n                } catch (Throwable e) {\n                  SolrException.log(log, e);\n                } finally {\n                  // we are all done with the old searcher we used\n                  // for warming...\n                  if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof SolrException) throw (SolrException)e;\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      if (!success) {\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n            onDeckSearchers=0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg);\n      } else if (onDeckSearchers > 1) {\n        log.warn(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n       // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n       // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              public Object call() throws Exception {\n                try {\n                  newSearcher.warm(currSearcher);\n                } catch (Throwable e) {\n                  SolrException.log(log,e);\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              public Object call() throws Exception {\n                try {\n                  for (SolrEventListener listener : firstSearcherListeners) {\n                    listener.newSearcher(newSearcher,null);\n                  }\n                } catch (Throwable e) {\n                  SolrException.log(log,null,e);\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              public Object call() throws Exception {\n                try {\n                  for (SolrEventListener listener : newSearcherListeners) {\n                    listener.newSearcher(newSearcher, currSearcher);\n                  }\n                } catch (Throwable e) {\n                  SolrException.log(log,null,e);\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              public Object call() throws Exception {\n                try {\n                  // registerSearcher will decrement onDeckSearchers and\n                  // do a notify, even if it fails.\n                  registerSearcher(newSearchHolder);\n                } catch (Throwable e) {\n                  SolrException.log(log, e);\n                } finally {\n                  // we are all done with the old searcher we used\n                  // for warming...\n                  if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof SolrException) throw (SolrException)e;\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      if (!success) {\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n            onDeckSearchers=0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","bugFix":["7a71a0b2d4be2299a163f60626729852d81a8e02"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg);\n      } else if (onDeckSearchers > 1) {\n        log.warn(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n       // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n       // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              public Object call() throws Exception {\n                try {\n                  newSearcher.warm(currSearcher);\n                } catch (Throwable e) {\n                  SolrException.log(log,e);\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              public Object call() throws Exception {\n                try {\n                  for (SolrEventListener listener : firstSearcherListeners) {\n                    listener.newSearcher(newSearcher,null);\n                  }\n                } catch (Throwable e) {\n                  SolrException.log(log,null,e);\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              public Object call() throws Exception {\n                try {\n                  for (SolrEventListener listener : newSearcherListeners) {\n                    listener.newSearcher(newSearcher, currSearcher);\n                  }\n                } catch (Throwable e) {\n                  SolrException.log(log,null,e);\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              public Object call() throws Exception {\n                try {\n                  // registerSearcher will decrement onDeckSearchers and\n                  // do a notify, even if it fails.\n                  registerSearcher(newSearchHolder);\n                } catch (Throwable e) {\n                  SolrException.log(log, e);\n                } finally {\n                  // we are all done with the old searcher we used\n                  // for warming...\n                  if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof SolrException) throw (SolrException)e;\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      if (!success) {\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n            onDeckSearchers=0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg);\n      } else if (onDeckSearchers > 1) {\n        log.warn(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n       // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n       // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              public Object call() throws Exception {\n                try {\n                  newSearcher.warm(currSearcher);\n                } catch (Throwable e) {\n                  SolrException.log(log,e);\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              public Object call() throws Exception {\n                try {\n                  for (SolrEventListener listener : firstSearcherListeners) {\n                    listener.newSearcher(newSearcher,null);\n                  }\n                } catch (Throwable e) {\n                  SolrException.log(log,null,e);\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              public Object call() throws Exception {\n                try {\n                  for (SolrEventListener listener : newSearcherListeners) {\n                    listener.newSearcher(newSearcher, currSearcher);\n                  }\n                } catch (Throwable e) {\n                  SolrException.log(log,null,e);\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              public Object call() throws Exception {\n                try {\n                  // registerSearcher will decrement onDeckSearchers and\n                  // do a notify, even if it fails.\n                  registerSearcher(newSearchHolder);\n                } catch (Throwable e) {\n                  SolrException.log(log, e);\n                } finally {\n                  // we are all done with the old searcher we used\n                  // for warming...\n                  if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof SolrException) throw (SolrException)e;\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      if (!success) {\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n            onDeckSearchers=0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7530de27b87b961b51f01bd1299b7004d46e8823","date":1355236261,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg);\n      } else if (onDeckSearchers > 1) {\n        log.warn(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n       // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n       // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              @Override\n              public Object call() throws Exception {\n                try {\n                  newSearcher.warm(currSearcher);\n                } catch (Throwable e) {\n                  SolrException.log(log,e);\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              @Override\n              public Object call() throws Exception {\n                try {\n                  for (SolrEventListener listener : firstSearcherListeners) {\n                    listener.newSearcher(newSearcher,null);\n                  }\n                } catch (Throwable e) {\n                  SolrException.log(log,null,e);\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              @Override\n              public Object call() throws Exception {\n                try {\n                  for (SolrEventListener listener : newSearcherListeners) {\n                    listener.newSearcher(newSearcher, currSearcher);\n                  }\n                } catch (Throwable e) {\n                  SolrException.log(log,null,e);\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              @Override\n              public Object call() throws Exception {\n                try {\n                  // registerSearcher will decrement onDeckSearchers and\n                  // do a notify, even if it fails.\n                  registerSearcher(newSearchHolder);\n                } catch (Throwable e) {\n                  SolrException.log(log, e);\n                } finally {\n                  // we are all done with the old searcher we used\n                  // for warming...\n                  if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof SolrException) throw (SolrException)e;\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      if (!success) {\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n            onDeckSearchers=0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg);\n      } else if (onDeckSearchers > 1) {\n        log.warn(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n       // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n       // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              public Object call() throws Exception {\n                try {\n                  newSearcher.warm(currSearcher);\n                } catch (Throwable e) {\n                  SolrException.log(log,e);\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              public Object call() throws Exception {\n                try {\n                  for (SolrEventListener listener : firstSearcherListeners) {\n                    listener.newSearcher(newSearcher,null);\n                  }\n                } catch (Throwable e) {\n                  SolrException.log(log,null,e);\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              public Object call() throws Exception {\n                try {\n                  for (SolrEventListener listener : newSearcherListeners) {\n                    listener.newSearcher(newSearcher, currSearcher);\n                  }\n                } catch (Throwable e) {\n                  SolrException.log(log,null,e);\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              public Object call() throws Exception {\n                try {\n                  // registerSearcher will decrement onDeckSearchers and\n                  // do a notify, even if it fails.\n                  registerSearcher(newSearchHolder);\n                } catch (Throwable e) {\n                  SolrException.log(log, e);\n                } finally {\n                  // we are all done with the old searcher we used\n                  // for warming...\n                  if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof SolrException) throw (SolrException)e;\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      if (!success) {\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n            onDeckSearchers=0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg);\n      } else if (onDeckSearchers > 1) {\n        log.warn(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n       // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n       // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              @Override\n              public Object call() throws Exception {\n                try {\n                  newSearcher.warm(currSearcher);\n                } catch (Throwable e) {\n                  SolrException.log(log,e);\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              @Override\n              public Object call() throws Exception {\n                try {\n                  for (SolrEventListener listener : firstSearcherListeners) {\n                    listener.newSearcher(newSearcher,null);\n                  }\n                } catch (Throwable e) {\n                  SolrException.log(log,null,e);\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              @Override\n              public Object call() throws Exception {\n                try {\n                  for (SolrEventListener listener : newSearcherListeners) {\n                    listener.newSearcher(newSearcher, currSearcher);\n                  }\n                } catch (Throwable e) {\n                  SolrException.log(log,null,e);\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              @Override\n              public Object call() throws Exception {\n                try {\n                  // registerSearcher will decrement onDeckSearchers and\n                  // do a notify, even if it fails.\n                  registerSearcher(newSearchHolder);\n                } catch (Throwable e) {\n                  SolrException.log(log, e);\n                } finally {\n                  // we are all done with the old searcher we used\n                  // for warming...\n                  if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof SolrException) throw (SolrException)e;\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      if (!success) {\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n            onDeckSearchers=0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg);\n      } else if (onDeckSearchers > 1) {\n        log.warn(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n       // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n       // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              public Object call() throws Exception {\n                try {\n                  newSearcher.warm(currSearcher);\n                } catch (Throwable e) {\n                  SolrException.log(log,e);\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              public Object call() throws Exception {\n                try {\n                  for (SolrEventListener listener : firstSearcherListeners) {\n                    listener.newSearcher(newSearcher,null);\n                  }\n                } catch (Throwable e) {\n                  SolrException.log(log,null,e);\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              public Object call() throws Exception {\n                try {\n                  for (SolrEventListener listener : newSearcherListeners) {\n                    listener.newSearcher(newSearcher, currSearcher);\n                  }\n                } catch (Throwable e) {\n                  SolrException.log(log,null,e);\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              public Object call() throws Exception {\n                try {\n                  // registerSearcher will decrement onDeckSearchers and\n                  // do a notify, even if it fails.\n                  registerSearcher(newSearchHolder);\n                } catch (Throwable e) {\n                  SolrException.log(log, e);\n                } finally {\n                  // we are all done with the old searcher we used\n                  // for warming...\n                  if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof SolrException) throw (SolrException)e;\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      if (!success) {\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n            onDeckSearchers=0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2","date":1389633998,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg);\n      } else if (onDeckSearchers > 1) {\n        log.warn(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n       // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n       // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              @Override\n              public Object call() throws Exception {\n                try {\n                  newSearcher.warm(currSearcher);\n                } catch (Throwable e) {\n                  SolrException.log(log,e);\n                  if (e instanceof Error) {\n                    throw (Error) e;\n                  }\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              @Override\n              public Object call() throws Exception {\n                try {\n                  for (SolrEventListener listener : firstSearcherListeners) {\n                    listener.newSearcher(newSearcher,null);\n                  }\n                } catch (Throwable e) {\n                  SolrException.log(log,null,e);\n                  if (e instanceof Error) {\n                    throw (Error) e;\n                  }\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              @Override\n              public Object call() throws Exception {\n                try {\n                  for (SolrEventListener listener : newSearcherListeners) {\n                    listener.newSearcher(newSearcher, currSearcher);\n                  }\n                } catch (Throwable e) {\n                  SolrException.log(log,null,e);\n                  if (e instanceof Error) {\n                    throw (Error) e;\n                  }\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              @Override\n              public Object call() throws Exception {\n                try {\n                  // registerSearcher will decrement onDeckSearchers and\n                  // do a notify, even if it fails.\n                  registerSearcher(newSearchHolder);\n                } catch (Throwable e) {\n                  SolrException.log(log, e);\n                  if (e instanceof Error) {\n                    throw (Error) e;\n                  }\n                } finally {\n                  // we are all done with the old searcher we used\n                  // for warming...\n                  if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof SolrException) throw (SolrException)e;\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      if (!success) {\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n            onDeckSearchers=0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg);\n      } else if (onDeckSearchers > 1) {\n        log.warn(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n       // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n       // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              @Override\n              public Object call() throws Exception {\n                try {\n                  newSearcher.warm(currSearcher);\n                } catch (Throwable e) {\n                  SolrException.log(log,e);\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              @Override\n              public Object call() throws Exception {\n                try {\n                  for (SolrEventListener listener : firstSearcherListeners) {\n                    listener.newSearcher(newSearcher,null);\n                  }\n                } catch (Throwable e) {\n                  SolrException.log(log,null,e);\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              @Override\n              public Object call() throws Exception {\n                try {\n                  for (SolrEventListener listener : newSearcherListeners) {\n                    listener.newSearcher(newSearcher, currSearcher);\n                  }\n                } catch (Throwable e) {\n                  SolrException.log(log,null,e);\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              @Override\n              public Object call() throws Exception {\n                try {\n                  // registerSearcher will decrement onDeckSearchers and\n                  // do a notify, even if it fails.\n                  registerSearcher(newSearchHolder);\n                } catch (Throwable e) {\n                  SolrException.log(log, e);\n                } finally {\n                  // we are all done with the old searcher we used\n                  // for warming...\n                  if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof SolrException) throw (SolrException)e;\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      if (!success) {\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n            onDeckSearchers=0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"beea4d4bbebcfb6689ed31936553c5e98bce2871","date":1393882670,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg);\n      } else if (onDeckSearchers > 1) {\n        log.warn(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n       // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n       // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      Future future=null;\n\n      // if the underlying seracher has not changed, no warming is needed\n      if (newSearcher != currSearcher) {\n        \n        // warm the new searcher based on the current searcher.\n        // should this go before the other event handlers or after?\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(new Callable() {\n            @Override\n            public Object call() throws Exception {\n              try {\n                newSearcher.warm(currSearcher);\n              } catch (Throwable e) {\n                SolrException.log(log, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              }\n              return null;\n            }\n          });\n        }\n        \n        if (currSearcher == null && firstSearcherListeners.size() > 0) {\n          future = searcherExecutor.submit(new Callable() {\n            @Override\n            public Object call() throws Exception {\n              try {\n                for (SolrEventListener listener : firstSearcherListeners) {\n                  listener.newSearcher(newSearcher, null);\n                }\n              } catch (Throwable e) {\n                SolrException.log(log, null, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              }\n              return null;\n            }\n          });\n        }\n        \n        if (currSearcher != null && newSearcherListeners.size() > 0) {\n          future = searcherExecutor.submit(new Callable() {\n            @Override\n            public Object call() throws Exception {\n              try {\n                for (SolrEventListener listener : newSearcherListeners) {\n                  listener.newSearcher(newSearcher, currSearcher);\n                }\n              } catch (Throwable e) {\n                SolrException.log(log, null, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              }\n              return null;\n            }\n          });\n        }\n        \n      }\n\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              @Override\n              public Object call() throws Exception {\n                try {\n                  // registerSearcher will decrement onDeckSearchers and\n                  // do a notify, even if it fails.\n                  registerSearcher(newSearchHolder);\n                } catch (Throwable e) {\n                  SolrException.log(log, e);\n                  if (e instanceof Error) {\n                    throw (Error) e;\n                  }\n                } finally {\n                  // we are all done with the old searcher we used\n                  // for warming...\n                  if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof SolrException) throw (SolrException)e;\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      if (!success) {\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n            onDeckSearchers=0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg);\n      } else if (onDeckSearchers > 1) {\n        log.warn(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n       // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n       // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              @Override\n              public Object call() throws Exception {\n                try {\n                  newSearcher.warm(currSearcher);\n                } catch (Throwable e) {\n                  SolrException.log(log,e);\n                  if (e instanceof Error) {\n                    throw (Error) e;\n                  }\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              @Override\n              public Object call() throws Exception {\n                try {\n                  for (SolrEventListener listener : firstSearcherListeners) {\n                    listener.newSearcher(newSearcher,null);\n                  }\n                } catch (Throwable e) {\n                  SolrException.log(log,null,e);\n                  if (e instanceof Error) {\n                    throw (Error) e;\n                  }\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              @Override\n              public Object call() throws Exception {\n                try {\n                  for (SolrEventListener listener : newSearcherListeners) {\n                    listener.newSearcher(newSearcher, currSearcher);\n                  }\n                } catch (Throwable e) {\n                  SolrException.log(log,null,e);\n                  if (e instanceof Error) {\n                    throw (Error) e;\n                  }\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              @Override\n              public Object call() throws Exception {\n                try {\n                  // registerSearcher will decrement onDeckSearchers and\n                  // do a notify, even if it fails.\n                  registerSearcher(newSearchHolder);\n                } catch (Throwable e) {\n                  SolrException.log(log, e);\n                  if (e instanceof Error) {\n                    throw (Error) e;\n                  }\n                } finally {\n                  // we are all done with the old searcher we used\n                  // for warming...\n                  if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof SolrException) throw (SolrException)e;\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      if (!success) {\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n            onDeckSearchers=0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9d951133e62b079e1dde80890d60bf451997355b","date":1418945070,"type":3,"author":"Tomas Eduardo Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg);\n      } else if (onDeckSearchers > 1) {\n        log.warn(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n       // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n       // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      Future future=null;\n\n      // if the underlying seracher has not changed, no warming is needed\n      if (newSearcher != currSearcher) {\n        \n        // warm the new searcher based on the current searcher.\n        // should this go before the other event handlers or after?\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(new Callable() {\n            @Override\n            public Object call() throws Exception {\n              try {\n                newSearcher.warm(currSearcher);\n              } catch (Throwable e) {\n                SolrException.log(log, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              }\n              return null;\n            }\n          });\n        }\n        \n        if (currSearcher == null) {\n          future = searcherExecutor.submit(new Callable() {\n            @Override\n            public Object call() throws Exception {\n              try {\n                for (SolrEventListener listener : firstSearcherListeners) {\n                  listener.newSearcher(newSearcher, null);\n                }\n              } catch (Throwable e) {\n                SolrException.log(log, null, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              }\n              return null;\n            }\n          });\n        }\n        \n        if (currSearcher != null) {\n          future = searcherExecutor.submit(new Callable() {\n            @Override\n            public Object call() throws Exception {\n              try {\n                for (SolrEventListener listener : newSearcherListeners) {\n                  listener.newSearcher(newSearcher, currSearcher);\n                }\n              } catch (Throwable e) {\n                SolrException.log(log, null, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              }\n              return null;\n            }\n          });\n        }\n        \n      }\n\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              @Override\n              public Object call() throws Exception {\n                try {\n                  // registerSearcher will decrement onDeckSearchers and\n                  // do a notify, even if it fails.\n                  registerSearcher(newSearchHolder);\n                } catch (Throwable e) {\n                  SolrException.log(log, e);\n                  if (e instanceof Error) {\n                    throw (Error) e;\n                  }\n                } finally {\n                  // we are all done with the old searcher we used\n                  // for warming...\n                  if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof SolrException) throw (SolrException)e;\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      if (!success) {\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n            onDeckSearchers=0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg);\n      } else if (onDeckSearchers > 1) {\n        log.warn(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n       // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n       // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      Future future=null;\n\n      // if the underlying seracher has not changed, no warming is needed\n      if (newSearcher != currSearcher) {\n        \n        // warm the new searcher based on the current searcher.\n        // should this go before the other event handlers or after?\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(new Callable() {\n            @Override\n            public Object call() throws Exception {\n              try {\n                newSearcher.warm(currSearcher);\n              } catch (Throwable e) {\n                SolrException.log(log, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              }\n              return null;\n            }\n          });\n        }\n        \n        if (currSearcher == null && firstSearcherListeners.size() > 0) {\n          future = searcherExecutor.submit(new Callable() {\n            @Override\n            public Object call() throws Exception {\n              try {\n                for (SolrEventListener listener : firstSearcherListeners) {\n                  listener.newSearcher(newSearcher, null);\n                }\n              } catch (Throwable e) {\n                SolrException.log(log, null, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              }\n              return null;\n            }\n          });\n        }\n        \n        if (currSearcher != null && newSearcherListeners.size() > 0) {\n          future = searcherExecutor.submit(new Callable() {\n            @Override\n            public Object call() throws Exception {\n              try {\n                for (SolrEventListener listener : newSearcherListeners) {\n                  listener.newSearcher(newSearcher, currSearcher);\n                }\n              } catch (Throwable e) {\n                SolrException.log(log, null, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              }\n              return null;\n            }\n          });\n        }\n        \n      }\n\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              @Override\n              public Object call() throws Exception {\n                try {\n                  // registerSearcher will decrement onDeckSearchers and\n                  // do a notify, even if it fails.\n                  registerSearcher(newSearchHolder);\n                } catch (Throwable e) {\n                  SolrException.log(log, e);\n                  if (e instanceof Error) {\n                    throw (Error) e;\n                  }\n                } finally {\n                  // we are all done with the old searcher we used\n                  // for warming...\n                  if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof SolrException) throw (SolrException)e;\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      if (!success) {\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n            onDeckSearchers=0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9aea0485ecacb6734c17da2d02569816c23a69c1","date":1425707735,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg);\n      } else if (onDeckSearchers > 1) {\n        log.warn(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n       // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n       // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      Future future=null;\n\n      // if the underlying seracher has not changed, no warming is needed\n      if (newSearcher != currSearcher) {\n\n        // warm the new searcher based on the current searcher.\n        // should this go before the other event handlers or after?\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(new Callable() {\n            @Override\n            public Object call() throws Exception {\n              try {\n                newSearcher.warm(currSearcher);\n              } catch (Throwable e) {\n                SolrException.log(log, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              }\n              return null;\n            }\n          });\n        }\n\n        if (currSearcher == null) {\n          future = searcherExecutor.submit(new Callable() {\n            @Override\n            public Object call() throws Exception {\n              try {\n                for (SolrEventListener listener : firstSearcherListeners) {\n                  listener.newSearcher(newSearcher, null);\n                }\n              } catch (Throwable e) {\n                SolrException.log(log, null, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              }\n              return null;\n            }\n          });\n        }\n\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(new Callable() {\n            @Override\n            public Object call() throws Exception {\n              try {\n                for (SolrEventListener listener : newSearcherListeners) {\n                  listener.newSearcher(newSearcher, currSearcher);\n                }\n              } catch (Throwable e) {\n                SolrException.log(log, null, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              }\n              return null;\n            }\n          });\n        }\n\n      }\n\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              @Override\n              public Object call() throws Exception {\n                try {\n                  // registerSearcher will decrement onDeckSearchers and\n                  // do a notify, even if it fails.\n                  registerSearcher(newSearchHolder);\n                } catch (Throwable e) {\n                  SolrException.log(log, e);\n                  if (e instanceof Error) {\n                    throw (Error) e;\n                  }\n                } finally {\n                  // we are all done with the old searcher we used\n                  // for warming...\n                  if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof SolrException) throw (SolrException)e;\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      if (!success) {\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n            onDeckSearchers=0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg);\n      } else if (onDeckSearchers > 1) {\n        log.warn(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n       // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n       // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      Future future=null;\n\n      // if the underlying seracher has not changed, no warming is needed\n      if (newSearcher != currSearcher) {\n        \n        // warm the new searcher based on the current searcher.\n        // should this go before the other event handlers or after?\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(new Callable() {\n            @Override\n            public Object call() throws Exception {\n              try {\n                newSearcher.warm(currSearcher);\n              } catch (Throwable e) {\n                SolrException.log(log, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              }\n              return null;\n            }\n          });\n        }\n        \n        if (currSearcher == null) {\n          future = searcherExecutor.submit(new Callable() {\n            @Override\n            public Object call() throws Exception {\n              try {\n                for (SolrEventListener listener : firstSearcherListeners) {\n                  listener.newSearcher(newSearcher, null);\n                }\n              } catch (Throwable e) {\n                SolrException.log(log, null, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              }\n              return null;\n            }\n          });\n        }\n        \n        if (currSearcher != null) {\n          future = searcherExecutor.submit(new Callable() {\n            @Override\n            public Object call() throws Exception {\n              try {\n                for (SolrEventListener listener : newSearcherListeners) {\n                  listener.newSearcher(newSearcher, currSearcher);\n                }\n              } catch (Throwable e) {\n                SolrException.log(log, null, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              }\n              return null;\n            }\n          });\n        }\n        \n      }\n\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              @Override\n              public Object call() throws Exception {\n                try {\n                  // registerSearcher will decrement onDeckSearchers and\n                  // do a notify, even if it fails.\n                  registerSearcher(newSearchHolder);\n                } catch (Throwable e) {\n                  SolrException.log(log, e);\n                  if (e instanceof Error) {\n                    throw (Error) e;\n                  }\n                } finally {\n                  // we are all done with the old searcher we used\n                  // for warming...\n                  if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof SolrException) throw (SolrException)e;\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      if (!success) {\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n            onDeckSearchers=0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg);\n      } else if (onDeckSearchers > 1) {\n        log.warn(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n       // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n       // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      Future future=null;\n\n      // if the underlying seracher has not changed, no warming is needed\n      if (newSearcher != currSearcher) {\n\n        // warm the new searcher based on the current searcher.\n        // should this go before the other event handlers or after?\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(new Callable() {\n            @Override\n            public Object call() throws Exception {\n              try {\n                newSearcher.warm(currSearcher);\n              } catch (Throwable e) {\n                SolrException.log(log, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              }\n              return null;\n            }\n          });\n        }\n\n        if (currSearcher == null) {\n          future = searcherExecutor.submit(new Callable() {\n            @Override\n            public Object call() throws Exception {\n              try {\n                for (SolrEventListener listener : firstSearcherListeners) {\n                  listener.newSearcher(newSearcher, null);\n                }\n              } catch (Throwable e) {\n                SolrException.log(log, null, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              }\n              return null;\n            }\n          });\n        }\n\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(new Callable() {\n            @Override\n            public Object call() throws Exception {\n              try {\n                for (SolrEventListener listener : newSearcherListeners) {\n                  listener.newSearcher(newSearcher, currSearcher);\n                }\n              } catch (Throwable e) {\n                SolrException.log(log, null, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              }\n              return null;\n            }\n          });\n        }\n\n      }\n\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              @Override\n              public Object call() throws Exception {\n                try {\n                  // registerSearcher will decrement onDeckSearchers and\n                  // do a notify, even if it fails.\n                  registerSearcher(newSearchHolder);\n                } catch (Throwable e) {\n                  SolrException.log(log, e);\n                  if (e instanceof Error) {\n                    throw (Error) e;\n                  }\n                } finally {\n                  // we are all done with the old searcher we used\n                  // for warming...\n                  if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof SolrException) throw (SolrException)e;\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      if (!success) {\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n            onDeckSearchers=0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg);\n      } else if (onDeckSearchers > 1) {\n        log.warn(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n       // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n       // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      Future future=null;\n\n      // if the underlying seracher has not changed, no warming is needed\n      if (newSearcher != currSearcher) {\n        \n        // warm the new searcher based on the current searcher.\n        // should this go before the other event handlers or after?\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(new Callable() {\n            @Override\n            public Object call() throws Exception {\n              try {\n                newSearcher.warm(currSearcher);\n              } catch (Throwable e) {\n                SolrException.log(log, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              }\n              return null;\n            }\n          });\n        }\n        \n        if (currSearcher == null) {\n          future = searcherExecutor.submit(new Callable() {\n            @Override\n            public Object call() throws Exception {\n              try {\n                for (SolrEventListener listener : firstSearcherListeners) {\n                  listener.newSearcher(newSearcher, null);\n                }\n              } catch (Throwable e) {\n                SolrException.log(log, null, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              }\n              return null;\n            }\n          });\n        }\n        \n        if (currSearcher != null) {\n          future = searcherExecutor.submit(new Callable() {\n            @Override\n            public Object call() throws Exception {\n              try {\n                for (SolrEventListener listener : newSearcherListeners) {\n                  listener.newSearcher(newSearcher, currSearcher);\n                }\n              } catch (Throwable e) {\n                SolrException.log(log, null, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              }\n              return null;\n            }\n          });\n        }\n        \n      }\n\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              @Override\n              public Object call() throws Exception {\n                try {\n                  // registerSearcher will decrement onDeckSearchers and\n                  // do a notify, even if it fails.\n                  registerSearcher(newSearchHolder);\n                } catch (Throwable e) {\n                  SolrException.log(log, e);\n                  if (e instanceof Error) {\n                    throw (Error) e;\n                  }\n                } finally {\n                  // we are all done with the old searcher we used\n                  // for warming...\n                  if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof SolrException) throw (SolrException)e;\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      if (!success) {\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n            onDeckSearchers=0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"773a737806859660d4756f710adc0ad53e05f9d5","date":1432140757,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg);\n      } else if (onDeckSearchers > 1) {\n        log.warn(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n       // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n       // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      Future future=null;\n\n      // if the underlying seracher has not changed, no warming is needed\n      if (newSearcher != currSearcher) {\n\n        // warm the new searcher based on the current searcher.\n        // should this go before the other event handlers or after?\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(new Callable() {\n            @Override\n            public Object call() throws Exception {\n              try {\n                newSearcher.warm(currSearcher);\n              } catch (Throwable e) {\n                SolrException.log(log, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              }\n              return null;\n            }\n          });\n        }\n\n        if (currSearcher == null) {\n          if (updateHandler != null && updateHandler.getUpdateLog() != null) {\n            updateHandler.getUpdateLog().onFirstSearcher(newSearcher);\n          }\n\n          future = searcherExecutor.submit(new Callable() {\n            @Override\n            public Object call() throws Exception {\n              try {\n                for (SolrEventListener listener : firstSearcherListeners) {\n                  listener.newSearcher(newSearcher, null);\n                }\n              } catch (Throwable e) {\n                SolrException.log(log, null, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              }\n              return null;\n            }\n          });\n        }\n\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(new Callable() {\n            @Override\n            public Object call() throws Exception {\n              try {\n                for (SolrEventListener listener : newSearcherListeners) {\n                  listener.newSearcher(newSearcher, currSearcher);\n                }\n              } catch (Throwable e) {\n                SolrException.log(log, null, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              }\n              return null;\n            }\n          });\n        }\n\n      }\n\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              @Override\n              public Object call() throws Exception {\n                try {\n                  // registerSearcher will decrement onDeckSearchers and\n                  // do a notify, even if it fails.\n                  registerSearcher(newSearchHolder);\n                } catch (Throwable e) {\n                  SolrException.log(log, e);\n                  if (e instanceof Error) {\n                    throw (Error) e;\n                  }\n                } finally {\n                  // we are all done with the old searcher we used\n                  // for warming...\n                  if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof SolrException) throw (SolrException)e;\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      if (!success) {\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n            onDeckSearchers=0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg);\n      } else if (onDeckSearchers > 1) {\n        log.warn(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n       // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n       // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      Future future=null;\n\n      // if the underlying seracher has not changed, no warming is needed\n      if (newSearcher != currSearcher) {\n\n        // warm the new searcher based on the current searcher.\n        // should this go before the other event handlers or after?\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(new Callable() {\n            @Override\n            public Object call() throws Exception {\n              try {\n                newSearcher.warm(currSearcher);\n              } catch (Throwable e) {\n                SolrException.log(log, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              }\n              return null;\n            }\n          });\n        }\n\n        if (currSearcher == null) {\n          future = searcherExecutor.submit(new Callable() {\n            @Override\n            public Object call() throws Exception {\n              try {\n                for (SolrEventListener listener : firstSearcherListeners) {\n                  listener.newSearcher(newSearcher, null);\n                }\n              } catch (Throwable e) {\n                SolrException.log(log, null, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              }\n              return null;\n            }\n          });\n        }\n\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(new Callable() {\n            @Override\n            public Object call() throws Exception {\n              try {\n                for (SolrEventListener listener : newSearcherListeners) {\n                  listener.newSearcher(newSearcher, currSearcher);\n                }\n              } catch (Throwable e) {\n                SolrException.log(log, null, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              }\n              return null;\n            }\n          });\n        }\n\n      }\n\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              @Override\n              public Object call() throws Exception {\n                try {\n                  // registerSearcher will decrement onDeckSearchers and\n                  // do a notify, even if it fails.\n                  registerSearcher(newSearchHolder);\n                } catch (Throwable e) {\n                  SolrException.log(log, e);\n                  if (e instanceof Error) {\n                    throw (Error) e;\n                  }\n                } finally {\n                  // we are all done with the old searcher we used\n                  // for warming...\n                  if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof SolrException) throw (SolrException)e;\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      if (!success) {\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n            onDeckSearchers=0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9220b7d1848f68bc299608612f8e0139c4036fcf","date":1432485783,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg);\n      } else if (onDeckSearchers > 1) {\n        log.warn(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n       // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n       // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      Future future=null;\n\n      // if the underlying seracher has not changed, no warming is needed\n      if (newSearcher != currSearcher) {\n\n        // warm the new searcher based on the current searcher.\n        // should this go before the other event handlers or after?\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(new Callable() {\n            @Override\n            public Object call() throws Exception {\n              try {\n                newSearcher.warm(currSearcher);\n              } catch (Throwable e) {\n                SolrException.log(log, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              }\n              return null;\n            }\n          });\n        }\n\n        if (currSearcher == null) {\n          future = searcherExecutor.submit(new Callable() {\n            @Override\n            public Object call() throws Exception {\n              try {\n                for (SolrEventListener listener : firstSearcherListeners) {\n                  listener.newSearcher(newSearcher, null);\n                }\n              } catch (Throwable e) {\n                SolrException.log(log, null, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              }\n              return null;\n            }\n          });\n        }\n\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(new Callable() {\n            @Override\n            public Object call() throws Exception {\n              try {\n                for (SolrEventListener listener : newSearcherListeners) {\n                  listener.newSearcher(newSearcher, currSearcher);\n                }\n              } catch (Throwable e) {\n                SolrException.log(log, null, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              }\n              return null;\n            }\n          });\n        }\n\n      }\n\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              @Override\n              public Object call() throws Exception {\n                try {\n                  // registerSearcher will decrement onDeckSearchers and\n                  // do a notify, even if it fails.\n                  registerSearcher(newSearchHolder);\n                } catch (Throwable e) {\n                  SolrException.log(log, e);\n                  if (e instanceof Error) {\n                    throw (Error) e;\n                  }\n                } finally {\n                  // we are all done with the old searcher we used\n                  // for warming...\n                  if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof SolrException) throw (SolrException)e;\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      if (!success) {\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n            onDeckSearchers=0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg);\n      } else if (onDeckSearchers > 1) {\n        log.warn(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n       // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n       // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      Future future=null;\n\n      // if the underlying seracher has not changed, no warming is needed\n      if (newSearcher != currSearcher) {\n\n        // warm the new searcher based on the current searcher.\n        // should this go before the other event handlers or after?\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(new Callable() {\n            @Override\n            public Object call() throws Exception {\n              try {\n                newSearcher.warm(currSearcher);\n              } catch (Throwable e) {\n                SolrException.log(log, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              }\n              return null;\n            }\n          });\n        }\n\n        if (currSearcher == null) {\n          if (updateHandler != null && updateHandler.getUpdateLog() != null) {\n            updateHandler.getUpdateLog().onFirstSearcher(newSearcher);\n          }\n\n          future = searcherExecutor.submit(new Callable() {\n            @Override\n            public Object call() throws Exception {\n              try {\n                for (SolrEventListener listener : firstSearcherListeners) {\n                  listener.newSearcher(newSearcher, null);\n                }\n              } catch (Throwable e) {\n                SolrException.log(log, null, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              }\n              return null;\n            }\n          });\n        }\n\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(new Callable() {\n            @Override\n            public Object call() throws Exception {\n              try {\n                for (SolrEventListener listener : newSearcherListeners) {\n                  listener.newSearcher(newSearcher, currSearcher);\n                }\n              } catch (Throwable e) {\n                SolrException.log(log, null, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              }\n              return null;\n            }\n          });\n        }\n\n      }\n\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              @Override\n              public Object call() throws Exception {\n                try {\n                  // registerSearcher will decrement onDeckSearchers and\n                  // do a notify, even if it fails.\n                  registerSearcher(newSearchHolder);\n                } catch (Throwable e) {\n                  SolrException.log(log, e);\n                  if (e instanceof Error) {\n                    throw (Error) e;\n                  }\n                } finally {\n                  // we are all done with the old searcher we used\n                  // for warming...\n                  if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof SolrException) throw (SolrException)e;\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      if (!success) {\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n            onDeckSearchers=0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"043df2e9a841864922c32756a44c939ed768cb89","date":1459876536,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg);\n      } else if (onDeckSearchers > 1) {\n        log.warn(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n       // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n       // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      Future future=null;\n\n      // if the underlying seracher has not changed, no warming is needed\n      if (newSearcher != currSearcher) {\n\n        // warm the new searcher based on the current searcher.\n        // should this go before the other event handlers or after?\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              newSearcher.warm(currSearcher);\n            } catch (Throwable e) {\n              SolrException.log(log, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher == null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : firstSearcherListeners) {\n                listener.newSearcher(newSearcher, null);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : newSearcherListeners) {\n                listener.newSearcher(newSearcher, currSearcher);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n      }\n\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              @Override\n              public Object call() throws Exception {\n                try {\n                  // registerSearcher will decrement onDeckSearchers and\n                  // do a notify, even if it fails.\n                  registerSearcher(newSearchHolder);\n                } catch (Throwable e) {\n                  SolrException.log(log, e);\n                  if (e instanceof Error) {\n                    throw (Error) e;\n                  }\n                } finally {\n                  // we are all done with the old searcher we used\n                  // for warming...\n                  if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof SolrException) throw (SolrException)e;\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      if (!success) {\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n            onDeckSearchers=0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg);\n      } else if (onDeckSearchers > 1) {\n        log.warn(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n       // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n       // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      Future future=null;\n\n      // if the underlying seracher has not changed, no warming is needed\n      if (newSearcher != currSearcher) {\n\n        // warm the new searcher based on the current searcher.\n        // should this go before the other event handlers or after?\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(new Callable() {\n            @Override\n            public Object call() throws Exception {\n              try {\n                newSearcher.warm(currSearcher);\n              } catch (Throwable e) {\n                SolrException.log(log, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              }\n              return null;\n            }\n          });\n        }\n\n        if (currSearcher == null) {\n          future = searcherExecutor.submit(new Callable() {\n            @Override\n            public Object call() throws Exception {\n              try {\n                for (SolrEventListener listener : firstSearcherListeners) {\n                  listener.newSearcher(newSearcher, null);\n                }\n              } catch (Throwable e) {\n                SolrException.log(log, null, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              }\n              return null;\n            }\n          });\n        }\n\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(new Callable() {\n            @Override\n            public Object call() throws Exception {\n              try {\n                for (SolrEventListener listener : newSearcherListeners) {\n                  listener.newSearcher(newSearcher, currSearcher);\n                }\n              } catch (Throwable e) {\n                SolrException.log(log, null, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              }\n              return null;\n            }\n          });\n        }\n\n      }\n\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              @Override\n              public Object call() throws Exception {\n                try {\n                  // registerSearcher will decrement onDeckSearchers and\n                  // do a notify, even if it fails.\n                  registerSearcher(newSearchHolder);\n                } catch (Throwable e) {\n                  SolrException.log(log, e);\n                  if (e instanceof Error) {\n                    throw (Error) e;\n                  }\n                } finally {\n                  // we are all done with the old searcher we used\n                  // for warming...\n                  if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof SolrException) throw (SolrException)e;\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      if (!success) {\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n            onDeckSearchers=0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b6284684320a9808c41a5e43de958b2da22f89bd","date":1459977490,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg);\n      } else if (onDeckSearchers > 1) {\n        log.warn(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n       // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n       // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      Future future=null;\n\n      // if the underlying seracher has not changed, no warming is needed\n      if (newSearcher != currSearcher) {\n\n        // warm the new searcher based on the current searcher.\n        // should this go before the other event handlers or after?\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              newSearcher.warm(currSearcher);\n            } catch (Throwable e) {\n              SolrException.log(log, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher == null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : firstSearcherListeners) {\n                listener.newSearcher(newSearcher, null);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : newSearcherListeners) {\n                listener.newSearcher(newSearcher, currSearcher);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n      }\n\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              @Override\n              public Object call() throws Exception {\n                try {\n                  // registerSearcher will decrement onDeckSearchers and\n                  // do a notify, even if it fails.\n                  registerSearcher(newSearchHolder);\n                } catch (Throwable e) {\n                  SolrException.log(log, e);\n                  if (e instanceof Error) {\n                    throw (Error) e;\n                  }\n                } finally {\n                  // we are all done with the old searcher we used\n                  // for warming...\n                  if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof SolrException) throw (SolrException)e;\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      if (!success) {\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n            onDeckSearchers=0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg);\n      } else if (onDeckSearchers > 1) {\n        log.warn(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n       // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n       // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      Future future=null;\n\n      // if the underlying seracher has not changed, no warming is needed\n      if (newSearcher != currSearcher) {\n\n        // warm the new searcher based on the current searcher.\n        // should this go before the other event handlers or after?\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(new Callable() {\n            @Override\n            public Object call() throws Exception {\n              try {\n                newSearcher.warm(currSearcher);\n              } catch (Throwable e) {\n                SolrException.log(log, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              }\n              return null;\n            }\n          });\n        }\n\n        if (currSearcher == null) {\n          future = searcherExecutor.submit(new Callable() {\n            @Override\n            public Object call() throws Exception {\n              try {\n                for (SolrEventListener listener : firstSearcherListeners) {\n                  listener.newSearcher(newSearcher, null);\n                }\n              } catch (Throwable e) {\n                SolrException.log(log, null, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              }\n              return null;\n            }\n          });\n        }\n\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(new Callable() {\n            @Override\n            public Object call() throws Exception {\n              try {\n                for (SolrEventListener listener : newSearcherListeners) {\n                  listener.newSearcher(newSearcher, currSearcher);\n                }\n              } catch (Throwable e) {\n                SolrException.log(log, null, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              }\n              return null;\n            }\n          });\n        }\n\n      }\n\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              @Override\n              public Object call() throws Exception {\n                try {\n                  // registerSearcher will decrement onDeckSearchers and\n                  // do a notify, even if it fails.\n                  registerSearcher(newSearchHolder);\n                } catch (Throwable e) {\n                  SolrException.log(log, e);\n                  if (e instanceof Error) {\n                    throw (Error) e;\n                  }\n                } finally {\n                  // we are all done with the old searcher we used\n                  // for warming...\n                  if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof SolrException) throw (SolrException)e;\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      if (!success) {\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n            onDeckSearchers=0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a360f5e61c6281e4b1e4daa253ed716a6b2cd491","date":1460727202,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg);\n      } else if (onDeckSearchers > 1) {\n        log.warn(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n       // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n       // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      Future future=null;\n\n      // if the underlying seracher has not changed, no warming is needed\n      if (newSearcher != currSearcher) {\n\n        // warm the new searcher based on the current searcher.\n        // should this go before the other event handlers or after?\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              newSearcher.warm(currSearcher);\n            } catch (Throwable e) {\n              SolrException.log(log, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher == null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : firstSearcherListeners) {\n                listener.newSearcher(newSearcher, null);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : newSearcherListeners) {\n                listener.newSearcher(newSearcher, currSearcher);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n      }\n\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            () -> {\n              try {\n                // registerSearcher will decrement onDeckSearchers and\n                // do a notify, even if it fails.\n                registerSearcher(newSearchHolder);\n              } catch (Throwable e) {\n                SolrException.log(log, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              } finally {\n                // we are all done with the old searcher we used\n                // for warming...\n                if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n              }\n              return null;\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof SolrException) throw (SolrException)e;\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      if (!success) {\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n            onDeckSearchers=0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg);\n      } else if (onDeckSearchers > 1) {\n        log.warn(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n       // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n       // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      Future future=null;\n\n      // if the underlying seracher has not changed, no warming is needed\n      if (newSearcher != currSearcher) {\n\n        // warm the new searcher based on the current searcher.\n        // should this go before the other event handlers or after?\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              newSearcher.warm(currSearcher);\n            } catch (Throwable e) {\n              SolrException.log(log, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher == null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : firstSearcherListeners) {\n                listener.newSearcher(newSearcher, null);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : newSearcherListeners) {\n                listener.newSearcher(newSearcher, currSearcher);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n      }\n\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              @Override\n              public Object call() throws Exception {\n                try {\n                  // registerSearcher will decrement onDeckSearchers and\n                  // do a notify, even if it fails.\n                  registerSearcher(newSearchHolder);\n                } catch (Throwable e) {\n                  SolrException.log(log, e);\n                  if (e instanceof Error) {\n                    throw (Error) e;\n                  }\n                } finally {\n                  // we are all done with the old searcher we used\n                  // for warming...\n                  if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof SolrException) throw (SolrException)e;\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      if (!success) {\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n            onDeckSearchers=0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"73457c9372b4f2f962ca916788a5fe9e1f644a9f","date":1460794059,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg);\n      } else if (onDeckSearchers > 1) {\n        log.warn(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n       // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n       // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      Future future=null;\n\n      // if the underlying seracher has not changed, no warming is needed\n      if (newSearcher != currSearcher) {\n\n        // warm the new searcher based on the current searcher.\n        // should this go before the other event handlers or after?\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              newSearcher.warm(currSearcher);\n            } catch (Throwable e) {\n              SolrException.log(log, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher == null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : firstSearcherListeners) {\n                listener.newSearcher(newSearcher, null);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : newSearcherListeners) {\n                listener.newSearcher(newSearcher, currSearcher);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n      }\n\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            () -> {\n              try {\n                // registerSearcher will decrement onDeckSearchers and\n                // do a notify, even if it fails.\n                registerSearcher(newSearchHolder);\n              } catch (Throwable e) {\n                SolrException.log(log, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              } finally {\n                // we are all done with the old searcher we used\n                // for warming...\n                if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n              }\n              return null;\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof SolrException) throw (SolrException)e;\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      if (!success) {\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n            onDeckSearchers=0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg);\n      } else if (onDeckSearchers > 1) {\n        log.warn(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n       // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n       // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      Future future=null;\n\n      // if the underlying seracher has not changed, no warming is needed\n      if (newSearcher != currSearcher) {\n\n        // warm the new searcher based on the current searcher.\n        // should this go before the other event handlers or after?\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              newSearcher.warm(currSearcher);\n            } catch (Throwable e) {\n              SolrException.log(log, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher == null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : firstSearcherListeners) {\n                listener.newSearcher(newSearcher, null);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : newSearcherListeners) {\n                listener.newSearcher(newSearcher, currSearcher);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n      }\n\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            new Callable() {\n              @Override\n              public Object call() throws Exception {\n                try {\n                  // registerSearcher will decrement onDeckSearchers and\n                  // do a notify, even if it fails.\n                  registerSearcher(newSearchHolder);\n                } catch (Throwable e) {\n                  SolrException.log(log, e);\n                  if (e instanceof Error) {\n                    throw (Error) e;\n                  }\n                } finally {\n                  // we are all done with the old searcher we used\n                  // for warming...\n                  if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                }\n                return null;\n              }\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof SolrException) throw (SolrException)e;\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      if (!success) {\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n            onDeckSearchers=0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6554f36a4636755009195a7840518bf6b4f03d6c","date":1481906808,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      for(;;) { // this loop is so w can retry in the event that we exceed maxWarmingSearchers\n        // see if we can return the current searcher\n        if (_searcher != null && !forceNew) {\n          if (returnSearcher) {\n            _searcher.incref();\n            return _searcher;\n          } else {\n            return null;\n          }\n        }\n\n        // check to see if we can wait for someone else's searcher to be set\n        if (onDeckSearchers > 0 && !forceNew && _searcher == null) {\n          try {\n            searcherLock.wait();\n          } catch (InterruptedException e) {\n            log.info(SolrException.toStr(e));\n          }\n        }\n\n        // check again: see if we can return right now\n        if (_searcher != null && !forceNew) {\n          if (returnSearcher) {\n            _searcher.incref();\n            return _searcher;\n          } else {\n            return null;\n          }\n        }\n\n        // At this point, we know we need to open a new searcher...\n        // first: increment count to signal other threads that we are\n        //        opening a new searcher.\n        onDeckSearchers++;\n        if (onDeckSearchers < 1) {\n          // should never happen... just a sanity check\n          log.error(logid + \"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n          onDeckSearchers = 1;  // reset\n        } else if (onDeckSearchers > maxWarmingSearchers) {\n          onDeckSearchers--;\n          try {\n            searcherLock.wait();\n          } catch (InterruptedException e) {\n            log.info(SolrException.toStr(e));\n          }\n          continue;  // go back to the top of the loop and retry\n        } else if (onDeckSearchers > 1) {\n          log.warn(logid + \"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n        }\n\n        break; // I can now exit the loop and proceed to open a searcher\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n       // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n       // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      Future future=null;\n\n      // if the underlying seracher has not changed, no warming is needed\n      if (newSearcher != currSearcher) {\n\n        // warm the new searcher based on the current searcher.\n        // should this go before the other event handlers or after?\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              newSearcher.warm(currSearcher);\n            } catch (Throwable e) {\n              SolrException.log(log, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher == null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : firstSearcherListeners) {\n                listener.newSearcher(newSearcher, null);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : newSearcherListeners) {\n                listener.newSearcher(newSearcher, currSearcher);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n      }\n\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            () -> {\n              try {\n                // registerSearcher will decrement onDeckSearchers and\n                // do a notify, even if it fails.\n                registerSearcher(newSearchHolder);\n              } catch (Throwable e) {\n                SolrException.log(log, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              } finally {\n                // we are all done with the old searcher we used\n                // for warming...\n                if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n              }\n              return null;\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof SolrException) throw (SolrException)e;\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      if (!success) {\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n            onDeckSearchers=0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg);\n      } else if (onDeckSearchers > 1) {\n        log.warn(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n       // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n       // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      Future future=null;\n\n      // if the underlying seracher has not changed, no warming is needed\n      if (newSearcher != currSearcher) {\n\n        // warm the new searcher based on the current searcher.\n        // should this go before the other event handlers or after?\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              newSearcher.warm(currSearcher);\n            } catch (Throwable e) {\n              SolrException.log(log, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher == null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : firstSearcherListeners) {\n                listener.newSearcher(newSearcher, null);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : newSearcherListeners) {\n                listener.newSearcher(newSearcher, currSearcher);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n      }\n\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            () -> {\n              try {\n                // registerSearcher will decrement onDeckSearchers and\n                // do a notify, even if it fails.\n                registerSearcher(newSearchHolder);\n              } catch (Throwable e) {\n                SolrException.log(log, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              } finally {\n                // we are all done with the old searcher we used\n                // for warming...\n                if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n              }\n              return null;\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof SolrException) throw (SolrException)e;\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      if (!success) {\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n            onDeckSearchers=0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c6ba9c6a7bb3418fae644fe4b821c94cf739338a","date":1482164091,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      for(;;) { // this loop is so w can retry in the event that we exceed maxWarmingSearchers\n        // see if we can return the current searcher\n        if (_searcher != null && !forceNew) {\n          if (returnSearcher) {\n            _searcher.incref();\n            return _searcher;\n          } else {\n            return null;\n          }\n        }\n\n        // check to see if we can wait for someone else's searcher to be set\n        if (onDeckSearchers > 0 && !forceNew && _searcher == null) {\n          try {\n            searcherLock.wait();\n          } catch (InterruptedException e) {\n            log.info(SolrException.toStr(e));\n          }\n        }\n\n        // check again: see if we can return right now\n        if (_searcher != null && !forceNew) {\n          if (returnSearcher) {\n            _searcher.incref();\n            return _searcher;\n          } else {\n            return null;\n          }\n        }\n\n        // At this point, we know we need to open a new searcher...\n        // first: increment count to signal other threads that we are\n        //        opening a new searcher.\n        onDeckSearchers++;\n        if (onDeckSearchers < 1) {\n          // should never happen... just a sanity check\n          log.error(logid + \"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n          onDeckSearchers = 1;  // reset\n        } else if (onDeckSearchers > maxWarmingSearchers) {\n          onDeckSearchers--;\n          try {\n            searcherLock.wait();\n          } catch (InterruptedException e) {\n            log.info(SolrException.toStr(e));\n          }\n          continue;  // go back to the top of the loop and retry\n        } else if (onDeckSearchers > 1) {\n          log.warn(logid + \"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n        }\n\n        break; // I can now exit the loop and proceed to open a searcher\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n       // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n       // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      Future future=null;\n\n      // if the underlying searcher has not changed, no warming is needed\n      if (newSearcher != currSearcher) {\n\n        // warm the new searcher based on the current searcher.\n        // should this go before the other event handlers or after?\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              newSearcher.warm(currSearcher);\n            } catch (Throwable e) {\n              SolrException.log(log, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher == null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : firstSearcherListeners) {\n                listener.newSearcher(newSearcher, null);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : newSearcherListeners) {\n                listener.newSearcher(newSearcher, currSearcher);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n      }\n\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            () -> {\n              try {\n                // registerSearcher will decrement onDeckSearchers and\n                // do a notify, even if it fails.\n                registerSearcher(newSearchHolder);\n              } catch (Throwable e) {\n                SolrException.log(log, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              } finally {\n                // we are all done with the old searcher we used\n                // for warming...\n                if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n              }\n              return null;\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof SolrException) throw (SolrException)e;\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      if (!success) {\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n            onDeckSearchers=0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      for(;;) { // this loop is so w can retry in the event that we exceed maxWarmingSearchers\n        // see if we can return the current searcher\n        if (_searcher != null && !forceNew) {\n          if (returnSearcher) {\n            _searcher.incref();\n            return _searcher;\n          } else {\n            return null;\n          }\n        }\n\n        // check to see if we can wait for someone else's searcher to be set\n        if (onDeckSearchers > 0 && !forceNew && _searcher == null) {\n          try {\n            searcherLock.wait();\n          } catch (InterruptedException e) {\n            log.info(SolrException.toStr(e));\n          }\n        }\n\n        // check again: see if we can return right now\n        if (_searcher != null && !forceNew) {\n          if (returnSearcher) {\n            _searcher.incref();\n            return _searcher;\n          } else {\n            return null;\n          }\n        }\n\n        // At this point, we know we need to open a new searcher...\n        // first: increment count to signal other threads that we are\n        //        opening a new searcher.\n        onDeckSearchers++;\n        if (onDeckSearchers < 1) {\n          // should never happen... just a sanity check\n          log.error(logid + \"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n          onDeckSearchers = 1;  // reset\n        } else if (onDeckSearchers > maxWarmingSearchers) {\n          onDeckSearchers--;\n          try {\n            searcherLock.wait();\n          } catch (InterruptedException e) {\n            log.info(SolrException.toStr(e));\n          }\n          continue;  // go back to the top of the loop and retry\n        } else if (onDeckSearchers > 1) {\n          log.warn(logid + \"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n        }\n\n        break; // I can now exit the loop and proceed to open a searcher\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n       // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n       // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      Future future=null;\n\n      // if the underlying seracher has not changed, no warming is needed\n      if (newSearcher != currSearcher) {\n\n        // warm the new searcher based on the current searcher.\n        // should this go before the other event handlers or after?\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              newSearcher.warm(currSearcher);\n            } catch (Throwable e) {\n              SolrException.log(log, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher == null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : firstSearcherListeners) {\n                listener.newSearcher(newSearcher, null);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : newSearcherListeners) {\n                listener.newSearcher(newSearcher, currSearcher);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n      }\n\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            () -> {\n              try {\n                // registerSearcher will decrement onDeckSearchers and\n                // do a notify, even if it fails.\n                registerSearcher(newSearchHolder);\n              } catch (Throwable e) {\n                SolrException.log(log, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              } finally {\n                // we are all done with the old searcher we used\n                // for warming...\n                if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n              }\n              return null;\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof SolrException) throw (SolrException)e;\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      if (!success) {\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n            onDeckSearchers=0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0265144286422ad99682a00904cc2536b79c8535","date":1482222684,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      for(;;) { // this loop is so w can retry in the event that we exceed maxWarmingSearchers\n        // see if we can return the current searcher\n        if (_searcher != null && !forceNew) {\n          if (returnSearcher) {\n            _searcher.incref();\n            return _searcher;\n          } else {\n            return null;\n          }\n        }\n\n        // check to see if we can wait for someone else's searcher to be set\n        if (onDeckSearchers > 0 && !forceNew && _searcher == null) {\n          try {\n            searcherLock.wait();\n          } catch (InterruptedException e) {\n            log.info(SolrException.toStr(e));\n          }\n        }\n\n        // check again: see if we can return right now\n        if (_searcher != null && !forceNew) {\n          if (returnSearcher) {\n            _searcher.incref();\n            return _searcher;\n          } else {\n            return null;\n          }\n        }\n\n        // At this point, we know we need to open a new searcher...\n        // first: increment count to signal other threads that we are\n        //        opening a new searcher.\n        onDeckSearchers++;\n        newSearcherCounter.inc();\n        if (onDeckSearchers < 1) {\n          // should never happen... just a sanity check\n          log.error(logid + \"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n          onDeckSearchers = 1;  // reset\n        } else if (onDeckSearchers > maxWarmingSearchers) {\n          onDeckSearchers--;\n          newSearcherMaxReachedCounter.inc();\n          try {\n            searcherLock.wait();\n          } catch (InterruptedException e) {\n            log.info(SolrException.toStr(e));\n          }\n          continue;  // go back to the top of the loop and retry\n        } else if (onDeckSearchers > 1) {\n          log.warn(logid + \"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n        }\n\n        break; // I can now exit the loop and proceed to open a searcher\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    Timer.Context timerContext = newSearcherTimer.time();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n       // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n       // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      Future future=null;\n\n      // if the underlying searcher has not changed, no warming is needed\n      if (newSearcher != currSearcher) {\n\n        // warm the new searcher based on the current searcher.\n        // should this go before the other event handlers or after?\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            Timer.Context warmupContext = newSearcherWarmupTimer.time();\n            try {\n              newSearcher.warm(currSearcher);\n            } catch (Throwable e) {\n              SolrException.log(log, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            } finally {\n              warmupContext.close();\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher == null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : firstSearcherListeners) {\n                listener.newSearcher(newSearcher, null);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : newSearcherListeners) {\n                listener.newSearcher(newSearcher, currSearcher);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n      }\n\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            () -> {\n              try {\n                // registerSearcher will decrement onDeckSearchers and\n                // do a notify, even if it fails.\n                registerSearcher(newSearchHolder);\n              } catch (Throwable e) {\n                SolrException.log(log, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              } finally {\n                // we are all done with the old searcher we used\n                // for warming...\n                if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n              }\n              return null;\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof SolrException) throw (SolrException)e;\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      timerContext.close();\n\n      if (!success) {\n        newSearcherOtherErrorsCounter.inc();;\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n            onDeckSearchers=0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      for(;;) { // this loop is so w can retry in the event that we exceed maxWarmingSearchers\n        // see if we can return the current searcher\n        if (_searcher != null && !forceNew) {\n          if (returnSearcher) {\n            _searcher.incref();\n            return _searcher;\n          } else {\n            return null;\n          }\n        }\n\n        // check to see if we can wait for someone else's searcher to be set\n        if (onDeckSearchers > 0 && !forceNew && _searcher == null) {\n          try {\n            searcherLock.wait();\n          } catch (InterruptedException e) {\n            log.info(SolrException.toStr(e));\n          }\n        }\n\n        // check again: see if we can return right now\n        if (_searcher != null && !forceNew) {\n          if (returnSearcher) {\n            _searcher.incref();\n            return _searcher;\n          } else {\n            return null;\n          }\n        }\n\n        // At this point, we know we need to open a new searcher...\n        // first: increment count to signal other threads that we are\n        //        opening a new searcher.\n        onDeckSearchers++;\n        if (onDeckSearchers < 1) {\n          // should never happen... just a sanity check\n          log.error(logid + \"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n          onDeckSearchers = 1;  // reset\n        } else if (onDeckSearchers > maxWarmingSearchers) {\n          onDeckSearchers--;\n          try {\n            searcherLock.wait();\n          } catch (InterruptedException e) {\n            log.info(SolrException.toStr(e));\n          }\n          continue;  // go back to the top of the loop and retry\n        } else if (onDeckSearchers > 1) {\n          log.warn(logid + \"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n        }\n\n        break; // I can now exit the loop and proceed to open a searcher\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n       // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n       // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      Future future=null;\n\n      // if the underlying searcher has not changed, no warming is needed\n      if (newSearcher != currSearcher) {\n\n        // warm the new searcher based on the current searcher.\n        // should this go before the other event handlers or after?\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              newSearcher.warm(currSearcher);\n            } catch (Throwable e) {\n              SolrException.log(log, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher == null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : firstSearcherListeners) {\n                listener.newSearcher(newSearcher, null);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : newSearcherListeners) {\n                listener.newSearcher(newSearcher, currSearcher);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n      }\n\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            () -> {\n              try {\n                // registerSearcher will decrement onDeckSearchers and\n                // do a notify, even if it fails.\n                registerSearcher(newSearchHolder);\n              } catch (Throwable e) {\n                SolrException.log(log, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              } finally {\n                // we are all done with the old searcher we used\n                // for warming...\n                if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n              }\n              return null;\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof SolrException) throw (SolrException)e;\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      if (!success) {\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n            onDeckSearchers=0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf","date":1482251961,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      for(;;) { // this loop is so w can retry in the event that we exceed maxWarmingSearchers\n        // see if we can return the current searcher\n        if (_searcher != null && !forceNew) {\n          if (returnSearcher) {\n            _searcher.incref();\n            return _searcher;\n          } else {\n            return null;\n          }\n        }\n\n        // check to see if we can wait for someone else's searcher to be set\n        if (onDeckSearchers > 0 && !forceNew && _searcher == null) {\n          try {\n            searcherLock.wait();\n          } catch (InterruptedException e) {\n            log.info(SolrException.toStr(e));\n          }\n        }\n\n        // check again: see if we can return right now\n        if (_searcher != null && !forceNew) {\n          if (returnSearcher) {\n            _searcher.incref();\n            return _searcher;\n          } else {\n            return null;\n          }\n        }\n\n        // At this point, we know we need to open a new searcher...\n        // first: increment count to signal other threads that we are\n        //        opening a new searcher.\n        onDeckSearchers++;\n        newSearcherCounter.inc();\n        if (onDeckSearchers < 1) {\n          // should never happen... just a sanity check\n          log.error(logid + \"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n          onDeckSearchers = 1;  // reset\n        } else if (onDeckSearchers > maxWarmingSearchers) {\n          onDeckSearchers--;\n          newSearcherMaxReachedCounter.inc();\n          try {\n            searcherLock.wait();\n          } catch (InterruptedException e) {\n            log.info(SolrException.toStr(e));\n          }\n          continue;  // go back to the top of the loop and retry\n        } else if (onDeckSearchers > 1) {\n          log.warn(logid + \"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n        }\n\n        break; // I can now exit the loop and proceed to open a searcher\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    Timer.Context timerContext = newSearcherTimer.time();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n       // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n       // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      Future future=null;\n\n      // if the underlying searcher has not changed, no warming is needed\n      if (newSearcher != currSearcher) {\n\n        // warm the new searcher based on the current searcher.\n        // should this go before the other event handlers or after?\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            Timer.Context warmupContext = newSearcherWarmupTimer.time();\n            try {\n              newSearcher.warm(currSearcher);\n            } catch (Throwable e) {\n              SolrException.log(log, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            } finally {\n              warmupContext.close();\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher == null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : firstSearcherListeners) {\n                listener.newSearcher(newSearcher, null);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : newSearcherListeners) {\n                listener.newSearcher(newSearcher, currSearcher);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n      }\n\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            () -> {\n              try {\n                // registerSearcher will decrement onDeckSearchers and\n                // do a notify, even if it fails.\n                registerSearcher(newSearchHolder);\n              } catch (Throwable e) {\n                SolrException.log(log, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              } finally {\n                // we are all done with the old searcher we used\n                // for warming...\n                if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n              }\n              return null;\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof SolrException) throw (SolrException)e;\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      timerContext.close();\n\n      if (!success) {\n        newSearcherOtherErrorsCounter.inc();;\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n            onDeckSearchers=0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg);\n      } else if (onDeckSearchers > 1) {\n        log.warn(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n       // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n       // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      Future future=null;\n\n      // if the underlying seracher has not changed, no warming is needed\n      if (newSearcher != currSearcher) {\n\n        // warm the new searcher based on the current searcher.\n        // should this go before the other event handlers or after?\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              newSearcher.warm(currSearcher);\n            } catch (Throwable e) {\n              SolrException.log(log, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher == null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : firstSearcherListeners) {\n                listener.newSearcher(newSearcher, null);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : newSearcherListeners) {\n                listener.newSearcher(newSearcher, currSearcher);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n      }\n\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            () -> {\n              try {\n                // registerSearcher will decrement onDeckSearchers and\n                // do a notify, even if it fails.\n                registerSearcher(newSearchHolder);\n              } catch (Throwable e) {\n                SolrException.log(log, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              } finally {\n                // we are all done with the old searcher we used\n                // for warming...\n                if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n              }\n              return null;\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof SolrException) throw (SolrException)e;\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      if (!success) {\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n            onDeckSearchers=0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"96e0d4494fe54b31c7f0151f3a632124ab806351","date":1512410218,"type":3,"author":"Erick","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      for(;;) { // this loop is so w can retry in the event that we exceed maxWarmingSearchers\n        // see if we can return the current searcher\n        if (_searcher != null && !forceNew) {\n          if (returnSearcher) {\n            _searcher.incref();\n            return _searcher;\n          } else {\n            return null;\n          }\n        }\n\n        // check to see if we can wait for someone else's searcher to be set\n        if (onDeckSearchers > 0 && !forceNew && _searcher == null) {\n          try {\n            searcherLock.wait();\n          } catch (InterruptedException e) {\n            log.info(SolrException.toStr(e));\n          }\n        }\n\n        // check again: see if we can return right now\n        if (_searcher != null && !forceNew) {\n          if (returnSearcher) {\n            _searcher.incref();\n            return _searcher;\n          } else {\n            return null;\n          }\n        }\n\n        // At this point, we know we need to open a new searcher...\n        // first: increment count to signal other threads that we are\n        //        opening a new searcher.\n        onDeckSearchers++;\n        newSearcherCounter.inc();\n        if (onDeckSearchers < 1) {\n          // should never happen... just a sanity check\n          log.error(logid + \"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n          onDeckSearchers = 1;  // reset\n        } else if (onDeckSearchers > maxWarmingSearchers) {\n          onDeckSearchers--;\n          newSearcherMaxReachedCounter.inc();\n          try {\n            searcherLock.wait();\n          } catch (InterruptedException e) {\n            log.info(SolrException.toStr(e));\n          }\n          continue;  // go back to the top of the loop and retry\n        } else if (onDeckSearchers > 1) {\n          log.warn(logid + \"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n        }\n\n        break; // I can now exit the loop and proceed to open a searcher\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    Timer.Context timerContext = newSearcherTimer.time();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n       // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n       // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      Future future=null;\n\n      // if the underlying searcher has not changed, no warming is needed\n      if (newSearcher != currSearcher) {\n\n        // warm the new searcher based on the current searcher.\n        // should this go before the other event handlers or after?\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            Timer.Context warmupContext = newSearcherWarmupTimer.time();\n            try {\n              newSearcher.warm(currSearcher);\n            } catch (Throwable e) {\n              SolrException.log(log, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            } finally {\n              warmupContext.close();\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher == null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : firstSearcherListeners) {\n                listener.newSearcher(newSearcher, null);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : newSearcherListeners) {\n                listener.newSearcher(newSearcher, currSearcher);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n      }\n\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            () -> {\n              try {\n                // registerSearcher will decrement onDeckSearchers and\n                // do a notify, even if it fails.\n                registerSearcher(newSearchHolder);\n              } catch (Throwable e) {\n                SolrException.log(log, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              } finally {\n                // we are all done with the old searcher we used\n                // for warming...\n                if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n              }\n              return null;\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof SolrException) throw (SolrException)e;\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      timerContext.close();\n\n      if (!success) {\n        newSearcherOtherErrorsCounter.inc();;\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n            onDeckSearchers=0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      for(;;) { // this loop is so w can retry in the event that we exceed maxWarmingSearchers\n        // see if we can return the current searcher\n        if (_searcher != null && !forceNew) {\n          if (returnSearcher) {\n            _searcher.incref();\n            return _searcher;\n          } else {\n            return null;\n          }\n        }\n\n        // check to see if we can wait for someone else's searcher to be set\n        if (onDeckSearchers > 0 && !forceNew && _searcher == null) {\n          try {\n            searcherLock.wait();\n          } catch (InterruptedException e) {\n            log.info(SolrException.toStr(e));\n          }\n        }\n\n        // check again: see if we can return right now\n        if (_searcher != null && !forceNew) {\n          if (returnSearcher) {\n            _searcher.incref();\n            return _searcher;\n          } else {\n            return null;\n          }\n        }\n\n        // At this point, we know we need to open a new searcher...\n        // first: increment count to signal other threads that we are\n        //        opening a new searcher.\n        onDeckSearchers++;\n        newSearcherCounter.inc();\n        if (onDeckSearchers < 1) {\n          // should never happen... just a sanity check\n          log.error(logid + \"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n          onDeckSearchers = 1;  // reset\n        } else if (onDeckSearchers > maxWarmingSearchers) {\n          onDeckSearchers--;\n          newSearcherMaxReachedCounter.inc();\n          try {\n            searcherLock.wait();\n          } catch (InterruptedException e) {\n            log.info(SolrException.toStr(e));\n          }\n          continue;  // go back to the top of the loop and retry\n        } else if (onDeckSearchers > 1) {\n          log.warn(logid + \"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n        }\n\n        break; // I can now exit the loop and proceed to open a searcher\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    Timer.Context timerContext = newSearcherTimer.time();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n       // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n       // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      Future future=null;\n\n      // if the underlying searcher has not changed, no warming is needed\n      if (newSearcher != currSearcher) {\n\n        // warm the new searcher based on the current searcher.\n        // should this go before the other event handlers or after?\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            Timer.Context warmupContext = newSearcherWarmupTimer.time();\n            try {\n              newSearcher.warm(currSearcher);\n            } catch (Throwable e) {\n              SolrException.log(log, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            } finally {\n              warmupContext.close();\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher == null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : firstSearcherListeners) {\n                listener.newSearcher(newSearcher, null);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : newSearcherListeners) {\n                listener.newSearcher(newSearcher, currSearcher);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n      }\n\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            () -> {\n              try {\n                // registerSearcher will decrement onDeckSearchers and\n                // do a notify, even if it fails.\n                registerSearcher(newSearchHolder);\n              } catch (Throwable e) {\n                SolrException.log(log, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              } finally {\n                // we are all done with the old searcher we used\n                // for warming...\n                if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n              }\n              return null;\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof SolrException) throw (SolrException)e;\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      timerContext.close();\n\n      if (!success) {\n        newSearcherOtherErrorsCounter.inc();;\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n            onDeckSearchers=0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","bugFix":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"24792720c893049d53a1807bd0ae9b64d1cd7be5","date":1527536585,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      for(;;) { // this loop is so w can retry in the event that we exceed maxWarmingSearchers\n        // see if we can return the current searcher\n        if (_searcher != null && !forceNew) {\n          if (returnSearcher) {\n            _searcher.incref();\n            return _searcher;\n          } else {\n            return null;\n          }\n        }\n\n        // check to see if we can wait for someone else's searcher to be set\n        if (onDeckSearchers > 0 && !forceNew && _searcher == null) {\n          try {\n            searcherLock.wait();\n          } catch (InterruptedException e) {\n            log.info(SolrException.toStr(e));\n          }\n        }\n\n        // check again: see if we can return right now\n        if (_searcher != null && !forceNew) {\n          if (returnSearcher) {\n            _searcher.incref();\n            return _searcher;\n          } else {\n            return null;\n          }\n        }\n\n        // At this point, we know we need to open a new searcher...\n        // first: increment count to signal other threads that we are\n        //        opening a new searcher.\n        onDeckSearchers++;\n        newSearcherCounter.inc();\n        if (onDeckSearchers < 1) {\n          // should never happen... just a sanity check\n          log.error(\"{}ERROR!!! onDeckSearchers is {}\", logid, onDeckSearchers);\n          onDeckSearchers = 1;  // reset\n        } else if (onDeckSearchers > maxWarmingSearchers) {\n          onDeckSearchers--;\n          newSearcherMaxReachedCounter.inc();\n          try {\n            searcherLock.wait();\n          } catch (InterruptedException e) {\n            log.info(SolrException.toStr(e));\n          }\n          continue;  // go back to the top of the loop and retry\n        } else if (onDeckSearchers > 1) {\n          log.warn(\"{}PERFORMANCE WARNING: Overlapping onDeckSearchers={}\", logid, onDeckSearchers);\n        }\n\n        break; // I can now exit the loop and proceed to open a searcher\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    Timer.Context timerContext = newSearcherTimer.time();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n       // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n       // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      Future future=null;\n\n      // if the underlying searcher has not changed, no warming is needed\n      if (newSearcher != currSearcher) {\n\n        // warm the new searcher based on the current searcher.\n        // should this go before the other event handlers or after?\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            Timer.Context warmupContext = newSearcherWarmupTimer.time();\n            try {\n              newSearcher.warm(currSearcher);\n            } catch (Throwable e) {\n              SolrException.log(log, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            } finally {\n              warmupContext.close();\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher == null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : firstSearcherListeners) {\n                listener.newSearcher(newSearcher, null);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : newSearcherListeners) {\n                listener.newSearcher(newSearcher, currSearcher);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n      }\n\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            () -> {\n              try {\n                // registerSearcher will decrement onDeckSearchers and\n                // do a notify, even if it fails.\n                registerSearcher(newSearchHolder);\n              } catch (Throwable e) {\n                SolrException.log(log, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              } finally {\n                // we are all done with the old searcher we used\n                // for warming...\n                if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n              }\n              return null;\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof SolrException) throw (SolrException)e;\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      timerContext.close();\n\n      if (!success) {\n        newSearcherOtherErrorsCounter.inc();;\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(\"{}ERROR!!! onDeckSearchers after decrement={}\", logid, onDeckSearchers);\n            onDeckSearchers=0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      for(;;) { // this loop is so w can retry in the event that we exceed maxWarmingSearchers\n        // see if we can return the current searcher\n        if (_searcher != null && !forceNew) {\n          if (returnSearcher) {\n            _searcher.incref();\n            return _searcher;\n          } else {\n            return null;\n          }\n        }\n\n        // check to see if we can wait for someone else's searcher to be set\n        if (onDeckSearchers > 0 && !forceNew && _searcher == null) {\n          try {\n            searcherLock.wait();\n          } catch (InterruptedException e) {\n            log.info(SolrException.toStr(e));\n          }\n        }\n\n        // check again: see if we can return right now\n        if (_searcher != null && !forceNew) {\n          if (returnSearcher) {\n            _searcher.incref();\n            return _searcher;\n          } else {\n            return null;\n          }\n        }\n\n        // At this point, we know we need to open a new searcher...\n        // first: increment count to signal other threads that we are\n        //        opening a new searcher.\n        onDeckSearchers++;\n        newSearcherCounter.inc();\n        if (onDeckSearchers < 1) {\n          // should never happen... just a sanity check\n          log.error(logid + \"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n          onDeckSearchers = 1;  // reset\n        } else if (onDeckSearchers > maxWarmingSearchers) {\n          onDeckSearchers--;\n          newSearcherMaxReachedCounter.inc();\n          try {\n            searcherLock.wait();\n          } catch (InterruptedException e) {\n            log.info(SolrException.toStr(e));\n          }\n          continue;  // go back to the top of the loop and retry\n        } else if (onDeckSearchers > 1) {\n          log.warn(logid + \"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n        }\n\n        break; // I can now exit the loop and proceed to open a searcher\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    Timer.Context timerContext = newSearcherTimer.time();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n       // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n       // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      Future future=null;\n\n      // if the underlying searcher has not changed, no warming is needed\n      if (newSearcher != currSearcher) {\n\n        // warm the new searcher based on the current searcher.\n        // should this go before the other event handlers or after?\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            Timer.Context warmupContext = newSearcherWarmupTimer.time();\n            try {\n              newSearcher.warm(currSearcher);\n            } catch (Throwable e) {\n              SolrException.log(log, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            } finally {\n              warmupContext.close();\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher == null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : firstSearcherListeners) {\n                listener.newSearcher(newSearcher, null);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : newSearcherListeners) {\n                listener.newSearcher(newSearcher, currSearcher);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n      }\n\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            () -> {\n              try {\n                // registerSearcher will decrement onDeckSearchers and\n                // do a notify, even if it fails.\n                registerSearcher(newSearchHolder);\n              } catch (Throwable e) {\n                SolrException.log(log, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              } finally {\n                // we are all done with the old searcher we used\n                // for warming...\n                if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n              }\n              return null;\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof SolrException) throw (SolrException)e;\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      timerContext.close();\n\n      if (!success) {\n        newSearcherOtherErrorsCounter.inc();;\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n            onDeckSearchers=0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      for(;;) { // this loop is so w can retry in the event that we exceed maxWarmingSearchers\n        // see if we can return the current searcher\n        if (_searcher != null && !forceNew) {\n          if (returnSearcher) {\n            _searcher.incref();\n            return _searcher;\n          } else {\n            return null;\n          }\n        }\n\n        // check to see if we can wait for someone else's searcher to be set\n        if (onDeckSearchers > 0 && !forceNew && _searcher == null) {\n          try {\n            searcherLock.wait();\n          } catch (InterruptedException e) {\n            log.info(SolrException.toStr(e));\n          }\n        }\n\n        // check again: see if we can return right now\n        if (_searcher != null && !forceNew) {\n          if (returnSearcher) {\n            _searcher.incref();\n            return _searcher;\n          } else {\n            return null;\n          }\n        }\n\n        // At this point, we know we need to open a new searcher...\n        // first: increment count to signal other threads that we are\n        //        opening a new searcher.\n        onDeckSearchers++;\n        newSearcherCounter.inc();\n        if (onDeckSearchers < 1) {\n          // should never happen... just a sanity check\n          log.error(\"{}ERROR!!! onDeckSearchers is {}\", logid, onDeckSearchers);\n          onDeckSearchers = 1;  // reset\n        } else if (onDeckSearchers > maxWarmingSearchers) {\n          onDeckSearchers--;\n          newSearcherMaxReachedCounter.inc();\n          try {\n            searcherLock.wait();\n          } catch (InterruptedException e) {\n            log.info(SolrException.toStr(e));\n          }\n          continue;  // go back to the top of the loop and retry\n        } else if (onDeckSearchers > 1) {\n          log.warn(\"{}PERFORMANCE WARNING: Overlapping onDeckSearchers={}\", logid, onDeckSearchers);\n        }\n\n        break; // I can now exit the loop and proceed to open a searcher\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    Timer.Context timerContext = newSearcherTimer.time();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n       // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n       // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      Future future=null;\n\n      // if the underlying searcher has not changed, no warming is needed\n      if (newSearcher != currSearcher) {\n\n        // warm the new searcher based on the current searcher.\n        // should this go before the other event handlers or after?\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            Timer.Context warmupContext = newSearcherWarmupTimer.time();\n            try {\n              newSearcher.warm(currSearcher);\n            } catch (Throwable e) {\n              SolrException.log(log, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            } finally {\n              warmupContext.close();\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher == null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : firstSearcherListeners) {\n                listener.newSearcher(newSearcher, null);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : newSearcherListeners) {\n                listener.newSearcher(newSearcher, currSearcher);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n      }\n\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            () -> {\n              try {\n                // registerSearcher will decrement onDeckSearchers and\n                // do a notify, even if it fails.\n                registerSearcher(newSearchHolder);\n              } catch (Throwable e) {\n                SolrException.log(log, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              } finally {\n                // we are all done with the old searcher we used\n                // for warming...\n                if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n              }\n              return null;\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof RuntimeException) throw (RuntimeException)e;\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      timerContext.close();\n\n      if (!success) {\n        newSearcherOtherErrorsCounter.inc();;\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(\"{}ERROR!!! onDeckSearchers after decrement={}\", logid, onDeckSearchers);\n            onDeckSearchers=0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      for(;;) { // this loop is so w can retry in the event that we exceed maxWarmingSearchers\n        // see if we can return the current searcher\n        if (_searcher != null && !forceNew) {\n          if (returnSearcher) {\n            _searcher.incref();\n            return _searcher;\n          } else {\n            return null;\n          }\n        }\n\n        // check to see if we can wait for someone else's searcher to be set\n        if (onDeckSearchers > 0 && !forceNew && _searcher == null) {\n          try {\n            searcherLock.wait();\n          } catch (InterruptedException e) {\n            log.info(SolrException.toStr(e));\n          }\n        }\n\n        // check again: see if we can return right now\n        if (_searcher != null && !forceNew) {\n          if (returnSearcher) {\n            _searcher.incref();\n            return _searcher;\n          } else {\n            return null;\n          }\n        }\n\n        // At this point, we know we need to open a new searcher...\n        // first: increment count to signal other threads that we are\n        //        opening a new searcher.\n        onDeckSearchers++;\n        newSearcherCounter.inc();\n        if (onDeckSearchers < 1) {\n          // should never happen... just a sanity check\n          log.error(\"{}ERROR!!! onDeckSearchers is {}\", logid, onDeckSearchers);\n          onDeckSearchers = 1;  // reset\n        } else if (onDeckSearchers > maxWarmingSearchers) {\n          onDeckSearchers--;\n          newSearcherMaxReachedCounter.inc();\n          try {\n            searcherLock.wait();\n          } catch (InterruptedException e) {\n            log.info(SolrException.toStr(e));\n          }\n          continue;  // go back to the top of the loop and retry\n        } else if (onDeckSearchers > 1) {\n          log.warn(\"{}PERFORMANCE WARNING: Overlapping onDeckSearchers={}\", logid, onDeckSearchers);\n        }\n\n        break; // I can now exit the loop and proceed to open a searcher\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    Timer.Context timerContext = newSearcherTimer.time();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n       // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n       // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      Future future=null;\n\n      // if the underlying searcher has not changed, no warming is needed\n      if (newSearcher != currSearcher) {\n\n        // warm the new searcher based on the current searcher.\n        // should this go before the other event handlers or after?\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            Timer.Context warmupContext = newSearcherWarmupTimer.time();\n            try {\n              newSearcher.warm(currSearcher);\n            } catch (Throwable e) {\n              SolrException.log(log, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            } finally {\n              warmupContext.close();\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher == null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : firstSearcherListeners) {\n                listener.newSearcher(newSearcher, null);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : newSearcherListeners) {\n                listener.newSearcher(newSearcher, currSearcher);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n      }\n\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            () -> {\n              try {\n                // registerSearcher will decrement onDeckSearchers and\n                // do a notify, even if it fails.\n                registerSearcher(newSearchHolder);\n              } catch (Throwable e) {\n                SolrException.log(log, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              } finally {\n                // we are all done with the old searcher we used\n                // for warming...\n                if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n              }\n              return null;\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof SolrException) throw (SolrException)e;\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      timerContext.close();\n\n      if (!success) {\n        newSearcherOtherErrorsCounter.inc();;\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(\"{}ERROR!!! onDeckSearchers after decrement={}\", logid, onDeckSearchers);\n            onDeckSearchers=0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","bugFix":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2668c99990e4c94a78bac005aa682b7c5986d23a","date":1561446137,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   * A new searcher will be opened and registered regardless of whether there is already\n   * a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   * <li>If a searcher is already registered, that searcher will be returned</li>\n   * <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   * <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   *\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      for (; ; ) { // this loop is so w can retry in the event that we exceed maxWarmingSearchers\n        // see if we can return the current searcher\n        if (_searcher != null && !forceNew) {\n          if (returnSearcher) {\n            _searcher.incref();\n            return _searcher;\n          } else {\n            return null;\n          }\n        }\n\n        // check to see if we can wait for someone else's searcher to be set\n        if (onDeckSearchers > 0 && !forceNew && _searcher == null) {\n          try {\n            searcherLock.wait();\n          } catch (InterruptedException e) {\n            log.info(SolrException.toStr(e));\n          }\n        }\n\n        // check again: see if we can return right now\n        if (_searcher != null && !forceNew) {\n          if (returnSearcher) {\n            _searcher.incref();\n            return _searcher;\n          } else {\n            return null;\n          }\n        }\n\n        // At this point, we know we need to open a new searcher...\n        // first: increment count to signal other threads that we are\n        //        opening a new searcher.\n        onDeckSearchers++;\n        newSearcherCounter.inc();\n        if (onDeckSearchers < 1) {\n          // should never happen... just a sanity check\n          log.error(\"{}ERROR!!! onDeckSearchers is {}\", logid, onDeckSearchers);\n          onDeckSearchers = 1;  // reset\n        } else if (onDeckSearchers > maxWarmingSearchers) {\n          onDeckSearchers--;\n          newSearcherMaxReachedCounter.inc();\n          try {\n            searcherLock.wait();\n          } catch (InterruptedException e) {\n            log.info(SolrException.toStr(e));\n          }\n          continue;  // go back to the top of the loop and retry\n        } else if (onDeckSearchers > 1) {\n          log.warn(\"{}PERFORMANCE WARNING: Overlapping onDeckSearchers={}\", logid, onDeckSearchers);\n        }\n\n        break; // I can now exit the loop and proceed to open a searcher\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount = new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    Timer.Context timerContext = newSearcherTimer.time();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n      // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n      // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0] = false;\n            alreadyRegistered = true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder = _searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder == null ? null : currSearcherHolder.get();\n\n      Future future = null;\n\n      // if the underlying searcher has not changed, no warming is needed\n      if (newSearcher != currSearcher) {\n\n        // warm the new searcher based on the current searcher.\n        // should this go before the other event handlers or after?\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            Timer.Context warmupContext = newSearcherWarmupTimer.time();\n            try {\n              newSearcher.warm(currSearcher);\n            } catch (Throwable e) {\n              SolrException.log(log, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            } finally {\n              warmupContext.close();\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher == null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : firstSearcherListeners) {\n                listener.newSearcher(newSearcher, null);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : newSearcherListeners) {\n                listener.newSearcher(newSearcher, currSearcher);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n      }\n\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            () -> {\n              try {\n                // registerSearcher will decrement onDeckSearchers and\n                // do a notify, even if it fails.\n                registerSearcher(newSearchHolder);\n              } catch (Throwable e) {\n                SolrException.log(log, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              } finally {\n                // we are all done with the old searcher we used\n                // for warming...\n                if (currSearcherHolderF != null) currSearcherHolderF.decref();\n              }\n              return null;\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof RuntimeException) throw (RuntimeException) e;\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      timerContext.close();\n\n      if (!success) {\n        newSearcherOtherErrorsCounter.inc();\n        ;\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(\"{}ERROR!!! onDeckSearchers after decrement={}\", logid, onDeckSearchers);\n            onDeckSearchers = 0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      for(;;) { // this loop is so w can retry in the event that we exceed maxWarmingSearchers\n        // see if we can return the current searcher\n        if (_searcher != null && !forceNew) {\n          if (returnSearcher) {\n            _searcher.incref();\n            return _searcher;\n          } else {\n            return null;\n          }\n        }\n\n        // check to see if we can wait for someone else's searcher to be set\n        if (onDeckSearchers > 0 && !forceNew && _searcher == null) {\n          try {\n            searcherLock.wait();\n          } catch (InterruptedException e) {\n            log.info(SolrException.toStr(e));\n          }\n        }\n\n        // check again: see if we can return right now\n        if (_searcher != null && !forceNew) {\n          if (returnSearcher) {\n            _searcher.incref();\n            return _searcher;\n          } else {\n            return null;\n          }\n        }\n\n        // At this point, we know we need to open a new searcher...\n        // first: increment count to signal other threads that we are\n        //        opening a new searcher.\n        onDeckSearchers++;\n        newSearcherCounter.inc();\n        if (onDeckSearchers < 1) {\n          // should never happen... just a sanity check\n          log.error(\"{}ERROR!!! onDeckSearchers is {}\", logid, onDeckSearchers);\n          onDeckSearchers = 1;  // reset\n        } else if (onDeckSearchers > maxWarmingSearchers) {\n          onDeckSearchers--;\n          newSearcherMaxReachedCounter.inc();\n          try {\n            searcherLock.wait();\n          } catch (InterruptedException e) {\n            log.info(SolrException.toStr(e));\n          }\n          continue;  // go back to the top of the loop and retry\n        } else if (onDeckSearchers > 1) {\n          log.warn(\"{}PERFORMANCE WARNING: Overlapping onDeckSearchers={}\", logid, onDeckSearchers);\n        }\n\n        break; // I can now exit the loop and proceed to open a searcher\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    Timer.Context timerContext = newSearcherTimer.time();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n       // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n       // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      Future future=null;\n\n      // if the underlying searcher has not changed, no warming is needed\n      if (newSearcher != currSearcher) {\n\n        // warm the new searcher based on the current searcher.\n        // should this go before the other event handlers or after?\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            Timer.Context warmupContext = newSearcherWarmupTimer.time();\n            try {\n              newSearcher.warm(currSearcher);\n            } catch (Throwable e) {\n              SolrException.log(log, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            } finally {\n              warmupContext.close();\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher == null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : firstSearcherListeners) {\n                listener.newSearcher(newSearcher, null);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : newSearcherListeners) {\n                listener.newSearcher(newSearcher, currSearcher);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n      }\n\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            () -> {\n              try {\n                // registerSearcher will decrement onDeckSearchers and\n                // do a notify, even if it fails.\n                registerSearcher(newSearchHolder);\n              } catch (Throwable e) {\n                SolrException.log(log, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              } finally {\n                // we are all done with the old searcher we used\n                // for warming...\n                if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n              }\n              return null;\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof RuntimeException) throw (RuntimeException)e;\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      timerContext.close();\n\n      if (!success) {\n        newSearcherOtherErrorsCounter.inc();;\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(\"{}ERROR!!! onDeckSearchers after decrement={}\", logid, onDeckSearchers);\n            onDeckSearchers=0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6e360143e9d6f677ecfe06b0c5204ee70bdb2a3c","date":1566455239,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   * A new searcher will be opened and registered regardless of whether there is already\n   * a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   * <li>If a searcher is already registered, that searcher will be returned</li>\n   * <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   * <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   *\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      for (; ; ) { // this loop is so w can retry in the event that we exceed maxWarmingSearchers\n        // see if we can return the current searcher\n        if (_searcher != null && !forceNew) {\n          if (returnSearcher) {\n            _searcher.incref();\n            return _searcher;\n          } else {\n            return null;\n          }\n        }\n\n        // check to see if we can wait for someone else's searcher to be set\n        if (onDeckSearchers > 0 && !forceNew && _searcher == null) {\n          try {\n            searcherLock.wait();\n          } catch (InterruptedException e) {\n            log.info(SolrException.toStr(e));\n          }\n        }\n\n        // check again: see if we can return right now\n        if (_searcher != null && !forceNew) {\n          if (returnSearcher) {\n            _searcher.incref();\n            return _searcher;\n          } else {\n            return null;\n          }\n        }\n\n        // At this point, we know we need to open a new searcher...\n        // first: increment count to signal other threads that we are\n        //        opening a new searcher.\n        onDeckSearchers++;\n        newSearcherCounter.inc();\n        if (onDeckSearchers < 1) {\n          // should never happen... just a sanity check\n          log.error(\"{}ERROR!!! onDeckSearchers is {}\", logid, onDeckSearchers);\n          onDeckSearchers = 1;  // reset\n        } else if (onDeckSearchers > maxWarmingSearchers) {\n          onDeckSearchers--;\n          newSearcherMaxReachedCounter.inc();\n          try {\n            searcherLock.wait();\n          } catch (InterruptedException e) {\n            log.info(SolrException.toStr(e));\n          }\n          continue;  // go back to the top of the loop and retry\n        } else if (onDeckSearchers > 1) {\n          log.warn(\"{}PERFORMANCE WARNING: Overlapping onDeckSearchers={}\", logid, onDeckSearchers);\n        }\n\n        break; // I can now exit the loop and proceed to open a searcher\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount = new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    Timer.Context timerContext = newSearcherTimer.time();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n      // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n      // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0] = false;\n            alreadyRegistered = true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder = _searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder == null ? null : currSearcherHolder.get();\n\n      Future future = null;\n\n      // if the underlying searcher has not changed, no warming is needed\n      if (newSearcher != currSearcher) {\n\n        // warm the new searcher based on the current searcher.\n        // should this go before the other event handlers or after?\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            Timer.Context warmupContext = newSearcherWarmupTimer.time();\n            try {\n              newSearcher.warm(currSearcher);\n            } catch (Throwable e) {\n              SolrException.log(log, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            } finally {\n              warmupContext.close();\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher == null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : firstSearcherListeners) {\n                listener.newSearcher(newSearcher, null);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : newSearcherListeners) {\n                listener.newSearcher(newSearcher, currSearcher);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n      }\n\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            () -> {\n              try {\n                // registerSearcher will decrement onDeckSearchers and\n                // do a notify, even if it fails.\n                registerSearcher(newSearchHolder);\n              } catch (Throwable e) {\n                SolrException.log(log, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              } finally {\n                // we are all done with the old searcher we used\n                // for warming...\n                if (currSearcherHolderF != null) currSearcherHolderF.decref();\n              }\n              return null;\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof RuntimeException) throw (RuntimeException) e;\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      timerContext.close();\n\n      if (!success) {\n        newSearcherOtherErrorsCounter.inc();\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(\"{}ERROR!!! onDeckSearchers after decrement={}\", logid, onDeckSearchers);\n            onDeckSearchers = 0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   * A new searcher will be opened and registered regardless of whether there is already\n   * a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   * <li>If a searcher is already registered, that searcher will be returned</li>\n   * <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   * <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   *\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      for (; ; ) { // this loop is so w can retry in the event that we exceed maxWarmingSearchers\n        // see if we can return the current searcher\n        if (_searcher != null && !forceNew) {\n          if (returnSearcher) {\n            _searcher.incref();\n            return _searcher;\n          } else {\n            return null;\n          }\n        }\n\n        // check to see if we can wait for someone else's searcher to be set\n        if (onDeckSearchers > 0 && !forceNew && _searcher == null) {\n          try {\n            searcherLock.wait();\n          } catch (InterruptedException e) {\n            log.info(SolrException.toStr(e));\n          }\n        }\n\n        // check again: see if we can return right now\n        if (_searcher != null && !forceNew) {\n          if (returnSearcher) {\n            _searcher.incref();\n            return _searcher;\n          } else {\n            return null;\n          }\n        }\n\n        // At this point, we know we need to open a new searcher...\n        // first: increment count to signal other threads that we are\n        //        opening a new searcher.\n        onDeckSearchers++;\n        newSearcherCounter.inc();\n        if (onDeckSearchers < 1) {\n          // should never happen... just a sanity check\n          log.error(\"{}ERROR!!! onDeckSearchers is {}\", logid, onDeckSearchers);\n          onDeckSearchers = 1;  // reset\n        } else if (onDeckSearchers > maxWarmingSearchers) {\n          onDeckSearchers--;\n          newSearcherMaxReachedCounter.inc();\n          try {\n            searcherLock.wait();\n          } catch (InterruptedException e) {\n            log.info(SolrException.toStr(e));\n          }\n          continue;  // go back to the top of the loop and retry\n        } else if (onDeckSearchers > 1) {\n          log.warn(\"{}PERFORMANCE WARNING: Overlapping onDeckSearchers={}\", logid, onDeckSearchers);\n        }\n\n        break; // I can now exit the loop and proceed to open a searcher\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount = new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    Timer.Context timerContext = newSearcherTimer.time();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n      // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n      // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0] = false;\n            alreadyRegistered = true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder = _searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder == null ? null : currSearcherHolder.get();\n\n      Future future = null;\n\n      // if the underlying searcher has not changed, no warming is needed\n      if (newSearcher != currSearcher) {\n\n        // warm the new searcher based on the current searcher.\n        // should this go before the other event handlers or after?\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            Timer.Context warmupContext = newSearcherWarmupTimer.time();\n            try {\n              newSearcher.warm(currSearcher);\n            } catch (Throwable e) {\n              SolrException.log(log, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            } finally {\n              warmupContext.close();\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher == null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : firstSearcherListeners) {\n                listener.newSearcher(newSearcher, null);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : newSearcherListeners) {\n                listener.newSearcher(newSearcher, currSearcher);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n      }\n\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            () -> {\n              try {\n                // registerSearcher will decrement onDeckSearchers and\n                // do a notify, even if it fails.\n                registerSearcher(newSearchHolder);\n              } catch (Throwable e) {\n                SolrException.log(log, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              } finally {\n                // we are all done with the old searcher we used\n                // for warming...\n                if (currSearcherHolderF != null) currSearcherHolderF.decref();\n              }\n              return null;\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof RuntimeException) throw (RuntimeException) e;\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      timerContext.close();\n\n      if (!success) {\n        newSearcherOtherErrorsCounter.inc();\n        ;\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(\"{}ERROR!!! onDeckSearchers after decrement={}\", logid, onDeckSearchers);\n            onDeckSearchers = 0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c44cc06c26e456fe9c215072b79fce30babe3975","date":1570365040,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   * A new searcher will be opened and registered regardless of whether there is already\n   * a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   * <li>If a searcher is already registered, that searcher will be returned</li>\n   * <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   * <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   *\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      for (; ; ) { // this loop is so w can retry in the event that we exceed maxWarmingSearchers\n        // see if we can return the current searcher\n        if (_searcher != null && !forceNew) {\n          if (returnSearcher) {\n            _searcher.incref();\n            return _searcher;\n          } else {\n            return null;\n          }\n        }\n\n        // check to see if we can wait for someone else's searcher to be set\n        if (onDeckSearchers > 0 && !forceNew && _searcher == null) {\n          try {\n            searcherLock.wait();\n          } catch (InterruptedException e) {\n            log.info(SolrException.toStr(e));\n          }\n        }\n\n        // check again: see if we can return right now\n        if (_searcher != null && !forceNew) {\n          if (returnSearcher) {\n            _searcher.incref();\n            return _searcher;\n          } else {\n            return null;\n          }\n        }\n\n        // At this point, we know we need to open a new searcher...\n        // first: increment count to signal other threads that we are\n        //        opening a new searcher.\n        onDeckSearchers++;\n        newSearcherCounter.inc();\n        if (onDeckSearchers < 1) {\n          // should never happen... just a sanity check\n          log.error(\"{}ERROR!!! onDeckSearchers is {}\", logid, onDeckSearchers);\n          onDeckSearchers = 1;  // reset\n        } else if (onDeckSearchers > maxWarmingSearchers) {\n          onDeckSearchers--;\n          newSearcherMaxReachedCounter.inc();\n          try {\n            searcherLock.wait();\n          } catch (InterruptedException e) {\n            log.info(SolrException.toStr(e));\n          }\n          continue;  // go back to the top of the loop and retry\n        } else if (onDeckSearchers > 1) {\n          log.warn(\"{}PERFORMANCE WARNING: Overlapping onDeckSearchers={}\", logid, onDeckSearchers);\n        }\n\n        break; // I can now exit the loop and proceed to open a searcher\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount = new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    Timer.Context timerContext = newSearcherTimer.time();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n      // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n      // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0] = false;\n            alreadyRegistered = true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder = _searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder == null ? null : currSearcherHolder.get();\n\n      Future future = null;\n\n      // if the underlying searcher has not changed, no warming is needed\n      if (newSearcher != currSearcher) {\n\n        // warm the new searcher based on the current searcher.\n        // should this go before the other event handlers or after?\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            Timer.Context warmupContext = newSearcherWarmupTimer.time();\n            try {\n              newSearcher.warm(currSearcher);\n            } catch (Throwable e) {\n              SolrException.log(log, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            } finally {\n              warmupContext.close();\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher == null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : firstSearcherListeners) {\n                listener.newSearcher(newSearcher, null);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : newSearcherListeners) {\n                listener.newSearcher(newSearcher, currSearcher);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n      }\n\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            () -> {\n              try {\n                // registerSearcher will decrement onDeckSearchers and\n                // do a notify, even if it fails.\n                registerSearcher(newSearchHolder);\n              } catch (Throwable e) {\n                SolrException.log(log, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              } finally {\n                // we are all done with the old searcher we used\n                // for warming...\n                if (currSearcherHolderF != null) currSearcherHolderF.decref();\n              }\n              return null;\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof RuntimeException) throw (RuntimeException) e;\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      timerContext.close();\n\n      if (!success) {\n        newSearcherOtherErrorsCounter.inc();\n        ;\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(\"{}ERROR!!! onDeckSearchers after decrement={}\", logid, onDeckSearchers);\n            onDeckSearchers = 0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   * A new searcher will be opened and registered regardless of whether there is already\n   * a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   * <li>If a searcher is already registered, that searcher will be returned</li>\n   * <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   * <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   *\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      for (; ; ) { // this loop is so w can retry in the event that we exceed maxWarmingSearchers\n        // see if we can return the current searcher\n        if (_searcher != null && !forceNew) {\n          if (returnSearcher) {\n            _searcher.incref();\n            return _searcher;\n          } else {\n            return null;\n          }\n        }\n\n        // check to see if we can wait for someone else's searcher to be set\n        if (onDeckSearchers > 0 && !forceNew && _searcher == null) {\n          try {\n            searcherLock.wait();\n          } catch (InterruptedException e) {\n            log.info(SolrException.toStr(e));\n          }\n        }\n\n        // check again: see if we can return right now\n        if (_searcher != null && !forceNew) {\n          if (returnSearcher) {\n            _searcher.incref();\n            return _searcher;\n          } else {\n            return null;\n          }\n        }\n\n        // At this point, we know we need to open a new searcher...\n        // first: increment count to signal other threads that we are\n        //        opening a new searcher.\n        onDeckSearchers++;\n        newSearcherCounter.inc();\n        if (onDeckSearchers < 1) {\n          // should never happen... just a sanity check\n          log.error(\"{}ERROR!!! onDeckSearchers is {}\", logid, onDeckSearchers);\n          onDeckSearchers = 1;  // reset\n        } else if (onDeckSearchers > maxWarmingSearchers) {\n          onDeckSearchers--;\n          newSearcherMaxReachedCounter.inc();\n          try {\n            searcherLock.wait();\n          } catch (InterruptedException e) {\n            log.info(SolrException.toStr(e));\n          }\n          continue;  // go back to the top of the loop and retry\n        } else if (onDeckSearchers > 1) {\n          log.warn(\"{}PERFORMANCE WARNING: Overlapping onDeckSearchers={}\", logid, onDeckSearchers);\n        }\n\n        break; // I can now exit the loop and proceed to open a searcher\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount = new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    Timer.Context timerContext = newSearcherTimer.time();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n      // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n      // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0] = false;\n            alreadyRegistered = true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder = _searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder == null ? null : currSearcherHolder.get();\n\n      Future future = null;\n\n      // if the underlying searcher has not changed, no warming is needed\n      if (newSearcher != currSearcher) {\n\n        // warm the new searcher based on the current searcher.\n        // should this go before the other event handlers or after?\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            Timer.Context warmupContext = newSearcherWarmupTimer.time();\n            try {\n              newSearcher.warm(currSearcher);\n            } catch (Throwable e) {\n              SolrException.log(log, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            } finally {\n              warmupContext.close();\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher == null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : firstSearcherListeners) {\n                listener.newSearcher(newSearcher, null);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : newSearcherListeners) {\n                listener.newSearcher(newSearcher, currSearcher);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n      }\n\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            () -> {\n              try {\n                // registerSearcher will decrement onDeckSearchers and\n                // do a notify, even if it fails.\n                registerSearcher(newSearchHolder);\n              } catch (Throwable e) {\n                SolrException.log(log, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              } finally {\n                // we are all done with the old searcher we used\n                // for warming...\n                if (currSearcherHolderF != null) currSearcherHolderF.decref();\n              }\n              return null;\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof RuntimeException) throw (RuntimeException) e;\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      timerContext.close();\n\n      if (!success) {\n        newSearcherOtherErrorsCounter.inc();\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(\"{}ERROR!!! onDeckSearchers after decrement={}\", logid, onDeckSearchers);\n            onDeckSearchers = 0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":3,"author":"jimczi","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   * A new searcher will be opened and registered regardless of whether there is already\n   * a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   * <li>If a searcher is already registered, that searcher will be returned</li>\n   * <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   * <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   *\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      for (; ; ) { // this loop is so w can retry in the event that we exceed maxWarmingSearchers\n        // see if we can return the current searcher\n        if (_searcher != null && !forceNew) {\n          if (returnSearcher) {\n            _searcher.incref();\n            return _searcher;\n          } else {\n            return null;\n          }\n        }\n\n        // check to see if we can wait for someone else's searcher to be set\n        if (onDeckSearchers > 0 && !forceNew && _searcher == null) {\n          try {\n            searcherLock.wait();\n          } catch (InterruptedException e) {\n            log.info(SolrException.toStr(e));\n          }\n        }\n\n        // check again: see if we can return right now\n        if (_searcher != null && !forceNew) {\n          if (returnSearcher) {\n            _searcher.incref();\n            return _searcher;\n          } else {\n            return null;\n          }\n        }\n\n        // At this point, we know we need to open a new searcher...\n        // first: increment count to signal other threads that we are\n        //        opening a new searcher.\n        onDeckSearchers++;\n        newSearcherCounter.inc();\n        if (onDeckSearchers < 1) {\n          // should never happen... just a sanity check\n          log.error(\"{}ERROR!!! onDeckSearchers is {}\", logid, onDeckSearchers);\n          onDeckSearchers = 1;  // reset\n        } else if (onDeckSearchers > maxWarmingSearchers) {\n          onDeckSearchers--;\n          newSearcherMaxReachedCounter.inc();\n          try {\n            searcherLock.wait();\n          } catch (InterruptedException e) {\n            log.info(SolrException.toStr(e));\n          }\n          continue;  // go back to the top of the loop and retry\n        } else if (onDeckSearchers > 1) {\n          log.warn(\"{}PERFORMANCE WARNING: Overlapping onDeckSearchers={}\", logid, onDeckSearchers);\n        }\n\n        break; // I can now exit the loop and proceed to open a searcher\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount = new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    Timer.Context timerContext = newSearcherTimer.time();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n      // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n      // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0] = false;\n            alreadyRegistered = true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder = _searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder == null ? null : currSearcherHolder.get();\n\n      Future future = null;\n\n      // if the underlying searcher has not changed, no warming is needed\n      if (newSearcher != currSearcher) {\n\n        // warm the new searcher based on the current searcher.\n        // should this go before the other event handlers or after?\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            Timer.Context warmupContext = newSearcherWarmupTimer.time();\n            try {\n              newSearcher.warm(currSearcher);\n            } catch (Throwable e) {\n              SolrException.log(log, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            } finally {\n              warmupContext.close();\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher == null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : firstSearcherListeners) {\n                listener.newSearcher(newSearcher, null);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : newSearcherListeners) {\n                listener.newSearcher(newSearcher, currSearcher);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n      }\n\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            () -> {\n              try {\n                // registerSearcher will decrement onDeckSearchers and\n                // do a notify, even if it fails.\n                registerSearcher(newSearchHolder);\n              } catch (Throwable e) {\n                SolrException.log(log, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              } finally {\n                // we are all done with the old searcher we used\n                // for warming...\n                if (currSearcherHolderF != null) currSearcherHolderF.decref();\n              }\n              return null;\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof RuntimeException) throw (RuntimeException) e;\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      timerContext.close();\n\n      if (!success) {\n        newSearcherOtherErrorsCounter.inc();\n        ;\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(\"{}ERROR!!! onDeckSearchers after decrement={}\", logid, onDeckSearchers);\n            onDeckSearchers = 0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   * A new searcher will be opened and registered regardless of whether there is already\n   * a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   * <li>If a searcher is already registered, that searcher will be returned</li>\n   * <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   * <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   *\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      for (; ; ) { // this loop is so w can retry in the event that we exceed maxWarmingSearchers\n        // see if we can return the current searcher\n        if (_searcher != null && !forceNew) {\n          if (returnSearcher) {\n            _searcher.incref();\n            return _searcher;\n          } else {\n            return null;\n          }\n        }\n\n        // check to see if we can wait for someone else's searcher to be set\n        if (onDeckSearchers > 0 && !forceNew && _searcher == null) {\n          try {\n            searcherLock.wait();\n          } catch (InterruptedException e) {\n            log.info(SolrException.toStr(e));\n          }\n        }\n\n        // check again: see if we can return right now\n        if (_searcher != null && !forceNew) {\n          if (returnSearcher) {\n            _searcher.incref();\n            return _searcher;\n          } else {\n            return null;\n          }\n        }\n\n        // At this point, we know we need to open a new searcher...\n        // first: increment count to signal other threads that we are\n        //        opening a new searcher.\n        onDeckSearchers++;\n        newSearcherCounter.inc();\n        if (onDeckSearchers < 1) {\n          // should never happen... just a sanity check\n          log.error(\"{}ERROR!!! onDeckSearchers is {}\", logid, onDeckSearchers);\n          onDeckSearchers = 1;  // reset\n        } else if (onDeckSearchers > maxWarmingSearchers) {\n          onDeckSearchers--;\n          newSearcherMaxReachedCounter.inc();\n          try {\n            searcherLock.wait();\n          } catch (InterruptedException e) {\n            log.info(SolrException.toStr(e));\n          }\n          continue;  // go back to the top of the loop and retry\n        } else if (onDeckSearchers > 1) {\n          log.warn(\"{}PERFORMANCE WARNING: Overlapping onDeckSearchers={}\", logid, onDeckSearchers);\n        }\n\n        break; // I can now exit the loop and proceed to open a searcher\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount = new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    Timer.Context timerContext = newSearcherTimer.time();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n      // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n      // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0] = false;\n            alreadyRegistered = true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder = _searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder == null ? null : currSearcherHolder.get();\n\n      Future future = null;\n\n      // if the underlying searcher has not changed, no warming is needed\n      if (newSearcher != currSearcher) {\n\n        // warm the new searcher based on the current searcher.\n        // should this go before the other event handlers or after?\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            Timer.Context warmupContext = newSearcherWarmupTimer.time();\n            try {\n              newSearcher.warm(currSearcher);\n            } catch (Throwable e) {\n              SolrException.log(log, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            } finally {\n              warmupContext.close();\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher == null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : firstSearcherListeners) {\n                listener.newSearcher(newSearcher, null);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : newSearcherListeners) {\n                listener.newSearcher(newSearcher, currSearcher);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n      }\n\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            () -> {\n              try {\n                // registerSearcher will decrement onDeckSearchers and\n                // do a notify, even if it fails.\n                registerSearcher(newSearchHolder);\n              } catch (Throwable e) {\n                SolrException.log(log, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              } finally {\n                // we are all done with the old searcher we used\n                // for warming...\n                if (currSearcherHolderF != null) currSearcherHolderF.decref();\n              }\n              return null;\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof RuntimeException) throw (RuntimeException) e;\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      timerContext.close();\n\n      if (!success) {\n        newSearcherOtherErrorsCounter.inc();\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(\"{}ERROR!!! onDeckSearchers after decrement={}\", logid, onDeckSearchers);\n            onDeckSearchers = 0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9e3751ad4cc85eb979419cf5469dfba266eae56a","date":1581046252,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <code>forceNew==true</code> then\n   * A new searcher will be opened and registered regardless of whether there is already\n   * a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <code>forceNew==false</code> then:<ul>\n   * <li>If a searcher is already registered, that searcher will be returned</li>\n   * <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   * <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <code>returnSearcher==true</code> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <code>waitSearcher!=null</code> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <code>null</code> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   *\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      for (; ; ) { // this loop is so w can retry in the event that we exceed maxWarmingSearchers\n        // see if we can return the current searcher\n        if (_searcher != null && !forceNew) {\n          if (returnSearcher) {\n            _searcher.incref();\n            return _searcher;\n          } else {\n            return null;\n          }\n        }\n\n        // check to see if we can wait for someone else's searcher to be set\n        if (onDeckSearchers > 0 && !forceNew && _searcher == null) {\n          try {\n            searcherLock.wait();\n          } catch (InterruptedException e) {\n            log.info(SolrException.toStr(e));\n          }\n        }\n\n        // check again: see if we can return right now\n        if (_searcher != null && !forceNew) {\n          if (returnSearcher) {\n            _searcher.incref();\n            return _searcher;\n          } else {\n            return null;\n          }\n        }\n\n        // At this point, we know we need to open a new searcher...\n        // first: increment count to signal other threads that we are\n        //        opening a new searcher.\n        onDeckSearchers++;\n        newSearcherCounter.inc();\n        if (onDeckSearchers < 1) {\n          // should never happen... just a sanity check\n          log.error(\"{}ERROR!!! onDeckSearchers is {}\", logid, onDeckSearchers);\n          onDeckSearchers = 1;  // reset\n        } else if (onDeckSearchers > maxWarmingSearchers) {\n          onDeckSearchers--;\n          newSearcherMaxReachedCounter.inc();\n          try {\n            searcherLock.wait();\n          } catch (InterruptedException e) {\n            log.info(SolrException.toStr(e));\n          }\n          continue;  // go back to the top of the loop and retry\n        } else if (onDeckSearchers > 1) {\n          log.warn(\"{}PERFORMANCE WARNING: Overlapping onDeckSearchers={}\", logid, onDeckSearchers);\n        }\n\n        break; // I can now exit the loop and proceed to open a searcher\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount = new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    Timer.Context timerContext = newSearcherTimer.time();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n      // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n      // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0] = false;\n            alreadyRegistered = true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder = _searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder == null ? null : currSearcherHolder.get();\n\n      Future future = null;\n\n      // if the underlying searcher has not changed, no warming is needed\n      if (newSearcher != currSearcher) {\n\n        // warm the new searcher based on the current searcher.\n        // should this go before the other event handlers or after?\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            Timer.Context warmupContext = newSearcherWarmupTimer.time();\n            try {\n              newSearcher.warm(currSearcher);\n            } catch (Throwable e) {\n              SolrException.log(log, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            } finally {\n              warmupContext.close();\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher == null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : firstSearcherListeners) {\n                listener.newSearcher(newSearcher, null);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : newSearcherListeners) {\n                listener.newSearcher(newSearcher, currSearcher);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n      }\n\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            () -> {\n              try {\n                // registerSearcher will decrement onDeckSearchers and\n                // do a notify, even if it fails.\n                registerSearcher(newSearchHolder);\n              } catch (Throwable e) {\n                SolrException.log(log, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              } finally {\n                // we are all done with the old searcher we used\n                // for warming...\n                if (currSearcherHolderF != null) currSearcherHolderF.decref();\n              }\n              return null;\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof RuntimeException) throw (RuntimeException) e;\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      timerContext.close();\n\n      if (!success) {\n        newSearcherOtherErrorsCounter.inc();\n        ;\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(\"{}ERROR!!! onDeckSearchers after decrement={}\", logid, onDeckSearchers);\n            onDeckSearchers = 0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   * A new searcher will be opened and registered regardless of whether there is already\n   * a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   * <li>If a searcher is already registered, that searcher will be returned</li>\n   * <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   * <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   *\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      for (; ; ) { // this loop is so w can retry in the event that we exceed maxWarmingSearchers\n        // see if we can return the current searcher\n        if (_searcher != null && !forceNew) {\n          if (returnSearcher) {\n            _searcher.incref();\n            return _searcher;\n          } else {\n            return null;\n          }\n        }\n\n        // check to see if we can wait for someone else's searcher to be set\n        if (onDeckSearchers > 0 && !forceNew && _searcher == null) {\n          try {\n            searcherLock.wait();\n          } catch (InterruptedException e) {\n            log.info(SolrException.toStr(e));\n          }\n        }\n\n        // check again: see if we can return right now\n        if (_searcher != null && !forceNew) {\n          if (returnSearcher) {\n            _searcher.incref();\n            return _searcher;\n          } else {\n            return null;\n          }\n        }\n\n        // At this point, we know we need to open a new searcher...\n        // first: increment count to signal other threads that we are\n        //        opening a new searcher.\n        onDeckSearchers++;\n        newSearcherCounter.inc();\n        if (onDeckSearchers < 1) {\n          // should never happen... just a sanity check\n          log.error(\"{}ERROR!!! onDeckSearchers is {}\", logid, onDeckSearchers);\n          onDeckSearchers = 1;  // reset\n        } else if (onDeckSearchers > maxWarmingSearchers) {\n          onDeckSearchers--;\n          newSearcherMaxReachedCounter.inc();\n          try {\n            searcherLock.wait();\n          } catch (InterruptedException e) {\n            log.info(SolrException.toStr(e));\n          }\n          continue;  // go back to the top of the loop and retry\n        } else if (onDeckSearchers > 1) {\n          log.warn(\"{}PERFORMANCE WARNING: Overlapping onDeckSearchers={}\", logid, onDeckSearchers);\n        }\n\n        break; // I can now exit the loop and proceed to open a searcher\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount = new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    Timer.Context timerContext = newSearcherTimer.time();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n      // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n      // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0] = false;\n            alreadyRegistered = true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder = _searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder == null ? null : currSearcherHolder.get();\n\n      Future future = null;\n\n      // if the underlying searcher has not changed, no warming is needed\n      if (newSearcher != currSearcher) {\n\n        // warm the new searcher based on the current searcher.\n        // should this go before the other event handlers or after?\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            Timer.Context warmupContext = newSearcherWarmupTimer.time();\n            try {\n              newSearcher.warm(currSearcher);\n            } catch (Throwable e) {\n              SolrException.log(log, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            } finally {\n              warmupContext.close();\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher == null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : firstSearcherListeners) {\n                listener.newSearcher(newSearcher, null);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : newSearcherListeners) {\n                listener.newSearcher(newSearcher, currSearcher);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n      }\n\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            () -> {\n              try {\n                // registerSearcher will decrement onDeckSearchers and\n                // do a notify, even if it fails.\n                registerSearcher(newSearchHolder);\n              } catch (Throwable e) {\n                SolrException.log(log, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              } finally {\n                // we are all done with the old searcher we used\n                // for warming...\n                if (currSearcherHolderF != null) currSearcherHolderF.decref();\n              }\n              return null;\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof RuntimeException) throw (RuntimeException) e;\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      timerContext.close();\n\n      if (!success) {\n        newSearcherOtherErrorsCounter.inc();\n        ;\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(\"{}ERROR!!! onDeckSearchers after decrement={}\", logid, onDeckSearchers);\n            onDeckSearchers = 0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"140be51d03394488536f4aacedace29f9b318347","date":1587170432,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <code>forceNew==true</code> then\n   * A new searcher will be opened and registered regardless of whether there is already\n   * a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <code>forceNew==false</code> then:<ul>\n   * <li>If a searcher is already registered, that searcher will be returned</li>\n   * <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   * <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <code>returnSearcher==true</code> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <code>waitSearcher!=null</code> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <code>null</code> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   *\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      for (; ; ) { // this loop is so w can retry in the event that we exceed maxWarmingSearchers\n        // see if we can return the current searcher\n        if (_searcher != null && !forceNew) {\n          if (returnSearcher) {\n            _searcher.incref();\n            return _searcher;\n          } else {\n            return null;\n          }\n        }\n\n        // check to see if we can wait for someone else's searcher to be set\n        if (onDeckSearchers > 0 && !forceNew && _searcher == null) {\n          try {\n            searcherLock.wait();\n          } catch (InterruptedException e) {\n            if (log.isInfoEnabled()) {\n              log.info(SolrException.toStr(e));\n            }\n          }\n        }\n\n        // check again: see if we can return right now\n        if (_searcher != null && !forceNew) {\n          if (returnSearcher) {\n            _searcher.incref();\n            return _searcher;\n          } else {\n            return null;\n          }\n        }\n\n        // At this point, we know we need to open a new searcher...\n        // first: increment count to signal other threads that we are\n        //        opening a new searcher.\n        onDeckSearchers++;\n        newSearcherCounter.inc();\n        if (onDeckSearchers < 1) {\n          // should never happen... just a sanity check\n          log.error(\"{}ERROR!!! onDeckSearchers is {}\", logid, onDeckSearchers);\n          onDeckSearchers = 1;  // reset\n        } else if (onDeckSearchers > maxWarmingSearchers) {\n          onDeckSearchers--;\n          newSearcherMaxReachedCounter.inc();\n          try {\n            searcherLock.wait();\n          } catch (InterruptedException e) {\n            if (log.isInfoEnabled()) {\n              log.info(SolrException.toStr(e));\n            }\n          }\n          continue;  // go back to the top of the loop and retry\n        } else if (onDeckSearchers > 1) {\n          log.warn(\"{}PERFORMANCE WARNING: Overlapping onDeckSearchers={}\", logid, onDeckSearchers);\n        }\n\n        break; // I can now exit the loop and proceed to open a searcher\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount = new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    Timer.Context timerContext = newSearcherTimer.time();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n      // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n      // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0] = false;\n            alreadyRegistered = true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder = _searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder == null ? null : currSearcherHolder.get();\n\n      Future future = null;\n\n      // if the underlying searcher has not changed, no warming is needed\n      if (newSearcher != currSearcher) {\n\n        // warm the new searcher based on the current searcher.\n        // should this go before the other event handlers or after?\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            Timer.Context warmupContext = newSearcherWarmupTimer.time();\n            try {\n              newSearcher.warm(currSearcher);\n            } catch (Throwable e) {\n              SolrException.log(log, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            } finally {\n              warmupContext.close();\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher == null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : firstSearcherListeners) {\n                listener.newSearcher(newSearcher, null);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : newSearcherListeners) {\n                listener.newSearcher(newSearcher, currSearcher);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n      }\n\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            () -> {\n              try {\n                // registerSearcher will decrement onDeckSearchers and\n                // do a notify, even if it fails.\n                registerSearcher(newSearchHolder);\n              } catch (Throwable e) {\n                SolrException.log(log, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              } finally {\n                // we are all done with the old searcher we used\n                // for warming...\n                if (currSearcherHolderF != null) currSearcherHolderF.decref();\n              }\n              return null;\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof RuntimeException) throw (RuntimeException) e;\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      timerContext.close();\n\n      if (!success) {\n        newSearcherOtherErrorsCounter.inc();\n        ;\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(\"{}ERROR!!! onDeckSearchers after decrement={}\", logid, onDeckSearchers);\n            onDeckSearchers = 0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <code>forceNew==true</code> then\n   * A new searcher will be opened and registered regardless of whether there is already\n   * a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <code>forceNew==false</code> then:<ul>\n   * <li>If a searcher is already registered, that searcher will be returned</li>\n   * <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   * <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <code>returnSearcher==true</code> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <code>waitSearcher!=null</code> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <code>null</code> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   *\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      for (; ; ) { // this loop is so w can retry in the event that we exceed maxWarmingSearchers\n        // see if we can return the current searcher\n        if (_searcher != null && !forceNew) {\n          if (returnSearcher) {\n            _searcher.incref();\n            return _searcher;\n          } else {\n            return null;\n          }\n        }\n\n        // check to see if we can wait for someone else's searcher to be set\n        if (onDeckSearchers > 0 && !forceNew && _searcher == null) {\n          try {\n            searcherLock.wait();\n          } catch (InterruptedException e) {\n            log.info(SolrException.toStr(e));\n          }\n        }\n\n        // check again: see if we can return right now\n        if (_searcher != null && !forceNew) {\n          if (returnSearcher) {\n            _searcher.incref();\n            return _searcher;\n          } else {\n            return null;\n          }\n        }\n\n        // At this point, we know we need to open a new searcher...\n        // first: increment count to signal other threads that we are\n        //        opening a new searcher.\n        onDeckSearchers++;\n        newSearcherCounter.inc();\n        if (onDeckSearchers < 1) {\n          // should never happen... just a sanity check\n          log.error(\"{}ERROR!!! onDeckSearchers is {}\", logid, onDeckSearchers);\n          onDeckSearchers = 1;  // reset\n        } else if (onDeckSearchers > maxWarmingSearchers) {\n          onDeckSearchers--;\n          newSearcherMaxReachedCounter.inc();\n          try {\n            searcherLock.wait();\n          } catch (InterruptedException e) {\n            log.info(SolrException.toStr(e));\n          }\n          continue;  // go back to the top of the loop and retry\n        } else if (onDeckSearchers > 1) {\n          log.warn(\"{}PERFORMANCE WARNING: Overlapping onDeckSearchers={}\", logid, onDeckSearchers);\n        }\n\n        break; // I can now exit the loop and proceed to open a searcher\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount = new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    Timer.Context timerContext = newSearcherTimer.time();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n      // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n      // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0] = false;\n            alreadyRegistered = true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder = _searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder == null ? null : currSearcherHolder.get();\n\n      Future future = null;\n\n      // if the underlying searcher has not changed, no warming is needed\n      if (newSearcher != currSearcher) {\n\n        // warm the new searcher based on the current searcher.\n        // should this go before the other event handlers or after?\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            Timer.Context warmupContext = newSearcherWarmupTimer.time();\n            try {\n              newSearcher.warm(currSearcher);\n            } catch (Throwable e) {\n              SolrException.log(log, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            } finally {\n              warmupContext.close();\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher == null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : firstSearcherListeners) {\n                listener.newSearcher(newSearcher, null);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : newSearcherListeners) {\n                listener.newSearcher(newSearcher, currSearcher);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n      }\n\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            () -> {\n              try {\n                // registerSearcher will decrement onDeckSearchers and\n                // do a notify, even if it fails.\n                registerSearcher(newSearchHolder);\n              } catch (Throwable e) {\n                SolrException.log(log, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              } finally {\n                // we are all done with the old searcher we used\n                // for warming...\n                if (currSearcherHolderF != null) currSearcherHolderF.decref();\n              }\n              return null;\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof RuntimeException) throw (RuntimeException) e;\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      timerContext.close();\n\n      if (!success) {\n        newSearcherOtherErrorsCounter.inc();\n        ;\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(\"{}ERROR!!! onDeckSearchers after decrement={}\", logid, onDeckSearchers);\n            onDeckSearchers = 0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"75237075d8425856bf4bbf52a6be4f9162b8187d","date":1591103291,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <code>forceNew==true</code> then\n   * A new searcher will be opened and registered regardless of whether there is already\n   * a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <code>forceNew==false</code> then:<ul>\n   * <li>If a searcher is already registered, that searcher will be returned</li>\n   * <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   * <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <code>returnSearcher==true</code> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <code>waitSearcher!=null</code> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <code>null</code> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   *\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, @SuppressWarnings({\"rawtypes\"})final Future[] waitSearcher, boolean updateHandlerReopens) {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      for (; ; ) { // this loop is so w can retry in the event that we exceed maxWarmingSearchers\n        // see if we can return the current searcher\n        if (_searcher != null && !forceNew) {\n          if (returnSearcher) {\n            _searcher.incref();\n            return _searcher;\n          } else {\n            return null;\n          }\n        }\n\n        // check to see if we can wait for someone else's searcher to be set\n        if (onDeckSearchers > 0 && !forceNew && _searcher == null) {\n          try {\n            searcherLock.wait();\n          } catch (InterruptedException e) {\n            if (log.isInfoEnabled()) {\n              log.info(SolrException.toStr(e));\n            }\n          }\n        }\n\n        // check again: see if we can return right now\n        if (_searcher != null && !forceNew) {\n          if (returnSearcher) {\n            _searcher.incref();\n            return _searcher;\n          } else {\n            return null;\n          }\n        }\n\n        // At this point, we know we need to open a new searcher...\n        // first: increment count to signal other threads that we are\n        //        opening a new searcher.\n        onDeckSearchers++;\n        newSearcherCounter.inc();\n        if (onDeckSearchers < 1) {\n          // should never happen... just a sanity check\n          log.error(\"{}ERROR!!! onDeckSearchers is {}\", logid, onDeckSearchers);\n          onDeckSearchers = 1;  // reset\n        } else if (onDeckSearchers > maxWarmingSearchers) {\n          onDeckSearchers--;\n          newSearcherMaxReachedCounter.inc();\n          try {\n            searcherLock.wait();\n          } catch (InterruptedException e) {\n            if (log.isInfoEnabled()) {\n              log.info(SolrException.toStr(e));\n            }\n          }\n          continue;  // go back to the top of the loop and retry\n        } else if (onDeckSearchers > 1) {\n          log.warn(\"{}PERFORMANCE WARNING: Overlapping onDeckSearchers={}\", logid, onDeckSearchers);\n        }\n\n        break; // I can now exit the loop and proceed to open a searcher\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount = new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    Timer.Context timerContext = newSearcherTimer.time();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n      // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n      // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0] = false;\n            alreadyRegistered = true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder = _searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder == null ? null : currSearcherHolder.get();\n\n      @SuppressWarnings({\"rawtypes\"})\n      Future future = null;\n\n      // if the underlying searcher has not changed, no warming is needed\n      if (newSearcher != currSearcher) {\n\n        // warm the new searcher based on the current searcher.\n        // should this go before the other event handlers or after?\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            Timer.Context warmupContext = newSearcherWarmupTimer.time();\n            try {\n              newSearcher.warm(currSearcher);\n            } catch (Throwable e) {\n              SolrException.log(log, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            } finally {\n              warmupContext.close();\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher == null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : firstSearcherListeners) {\n                listener.newSearcher(newSearcher, null);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : newSearcherListeners) {\n                listener.newSearcher(newSearcher, currSearcher);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n      }\n\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            () -> {\n              try {\n                // registerSearcher will decrement onDeckSearchers and\n                // do a notify, even if it fails.\n                registerSearcher(newSearchHolder);\n              } catch (Throwable e) {\n                SolrException.log(log, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              } finally {\n                // we are all done with the old searcher we used\n                // for warming...\n                if (currSearcherHolderF != null) currSearcherHolderF.decref();\n              }\n              return null;\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof RuntimeException) throw (RuntimeException) e;\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      timerContext.close();\n\n      if (!success) {\n        newSearcherOtherErrorsCounter.inc();\n        ;\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(\"{}ERROR!!! onDeckSearchers after decrement={}\", logid, onDeckSearchers);\n            onDeckSearchers = 0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <code>forceNew==true</code> then\n   * A new searcher will be opened and registered regardless of whether there is already\n   * a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <code>forceNew==false</code> then:<ul>\n   * <li>If a searcher is already registered, that searcher will be returned</li>\n   * <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   * <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <code>returnSearcher==true</code> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <code>waitSearcher!=null</code> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <code>null</code> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   *\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      for (; ; ) { // this loop is so w can retry in the event that we exceed maxWarmingSearchers\n        // see if we can return the current searcher\n        if (_searcher != null && !forceNew) {\n          if (returnSearcher) {\n            _searcher.incref();\n            return _searcher;\n          } else {\n            return null;\n          }\n        }\n\n        // check to see if we can wait for someone else's searcher to be set\n        if (onDeckSearchers > 0 && !forceNew && _searcher == null) {\n          try {\n            searcherLock.wait();\n          } catch (InterruptedException e) {\n            if (log.isInfoEnabled()) {\n              log.info(SolrException.toStr(e));\n            }\n          }\n        }\n\n        // check again: see if we can return right now\n        if (_searcher != null && !forceNew) {\n          if (returnSearcher) {\n            _searcher.incref();\n            return _searcher;\n          } else {\n            return null;\n          }\n        }\n\n        // At this point, we know we need to open a new searcher...\n        // first: increment count to signal other threads that we are\n        //        opening a new searcher.\n        onDeckSearchers++;\n        newSearcherCounter.inc();\n        if (onDeckSearchers < 1) {\n          // should never happen... just a sanity check\n          log.error(\"{}ERROR!!! onDeckSearchers is {}\", logid, onDeckSearchers);\n          onDeckSearchers = 1;  // reset\n        } else if (onDeckSearchers > maxWarmingSearchers) {\n          onDeckSearchers--;\n          newSearcherMaxReachedCounter.inc();\n          try {\n            searcherLock.wait();\n          } catch (InterruptedException e) {\n            if (log.isInfoEnabled()) {\n              log.info(SolrException.toStr(e));\n            }\n          }\n          continue;  // go back to the top of the loop and retry\n        } else if (onDeckSearchers > 1) {\n          log.warn(\"{}PERFORMANCE WARNING: Overlapping onDeckSearchers={}\", logid, onDeckSearchers);\n        }\n\n        break; // I can now exit the loop and proceed to open a searcher\n      }\n    }\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount = new boolean[]{true};\n    RefCounted<SolrIndexSearcher> currSearcherHolder = null;     // searcher we are autowarming from\n    RefCounted<SolrIndexSearcher> searchHolder = null;\n    boolean success = false;\n\n    openSearcherLock.lock();\n    Timer.Context timerContext = newSearcherTimer.time();\n    try {\n      searchHolder = openNewSearcher(updateHandlerReopens, false);\n      // the searchHolder will be incremented once already (and it will eventually be assigned to _searcher when registered)\n      // increment it again if we are going to return it to the caller.\n      if (returnSearcher) {\n        searchHolder.incref();\n      }\n\n\n      final RefCounted<SolrIndexSearcher> newSearchHolder = searchHolder;\n      final SolrIndexSearcher newSearcher = newSearchHolder.get();\n\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0] = false;\n            alreadyRegistered = true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder = _searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder == null ? null : currSearcherHolder.get();\n\n      Future future = null;\n\n      // if the underlying searcher has not changed, no warming is needed\n      if (newSearcher != currSearcher) {\n\n        // warm the new searcher based on the current searcher.\n        // should this go before the other event handlers or after?\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            Timer.Context warmupContext = newSearcherWarmupTimer.time();\n            try {\n              newSearcher.warm(currSearcher);\n            } catch (Throwable e) {\n              SolrException.log(log, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            } finally {\n              warmupContext.close();\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher == null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : firstSearcherListeners) {\n                listener.newSearcher(newSearcher, null);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n        if (currSearcher != null) {\n          future = searcherExecutor.submit(() -> {\n            try {\n              for (SolrEventListener listener : newSearcherListeners) {\n                listener.newSearcher(newSearcher, currSearcher);\n              }\n            } catch (Throwable e) {\n              SolrException.log(log, null, e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            }\n            return null;\n          });\n        }\n\n      }\n\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n            () -> {\n              try {\n                // registerSearcher will decrement onDeckSearchers and\n                // do a notify, even if it fails.\n                registerSearcher(newSearchHolder);\n              } catch (Throwable e) {\n                SolrException.log(log, e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              } finally {\n                // we are all done with the old searcher we used\n                // for warming...\n                if (currSearcherHolderF != null) currSearcherHolderF.decref();\n              }\n              return null;\n            }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      success = true;\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      if (e instanceof RuntimeException) throw (RuntimeException) e;\n      throw new SolrException(ErrorCode.SERVER_ERROR, e);\n    } finally {\n\n      timerContext.close();\n\n      if (!success) {\n        newSearcherOtherErrorsCounter.inc();\n        ;\n        synchronized (searcherLock) {\n          onDeckSearchers--;\n\n          if (onDeckSearchers < 0) {\n            // sanity check... should never happen\n            log.error(\"{}ERROR!!! onDeckSearchers after decrement={}\", logid, onDeckSearchers);\n            onDeckSearchers = 0; // try and recover\n          }\n          // if we failed, we need to wake up at least one waiter to continue the process\n          searcherLock.notify();\n        }\n\n        if (currSearcherHolder != null) {\n          currSearcherHolder.decref();\n        }\n\n        if (searchHolder != null) {\n          searchHolder.decref();      // decrement 1 for _searcher (searchHolder will never become _searcher now)\n          if (returnSearcher) {\n            searchHolder.decref();    // decrement 1 because we won't be returning the searcher to the user\n          }\n        }\n      }\n\n      // we want to do this after we decrement onDeckSearchers so another thread\n      // doesn't increment first and throw a false warning.\n      openSearcherLock.unlock();\n\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["4d3e8520fd031bab31fd0e4d480e55958bc45efe","7530de27b87b961b51f01bd1299b7004d46e8823"],"75237075d8425856bf4bbf52a6be4f9162b8187d":["140be51d03394488536f4aacedace29f9b318347"],"96e0d4494fe54b31c7f0151f3a632124ab806351":["0265144286422ad99682a00904cc2536b79c8535"],"9220b7d1848f68bc299608612f8e0139c4036fcf":["773a737806859660d4756f710adc0ad53e05f9d5"],"beea4d4bbebcfb6689ed31936553c5e98bce2871":["f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"1ba7ea4168f8418335f06510cdcb5be262f35c73":["e22ffe8cc51a892ae103df018822d7873e901c2a"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["24792720c893049d53a1807bd0ae9b64d1cd7be5"],"ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00":["7a3554ff15950ad0e3bcbb4e4e2ddb45b0b0f27e","3615ce4a1f785ae1b779244de52c6a7d99227e60"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"c44cc06c26e456fe9c215072b79fce30babe3975":["6e360143e9d6f677ecfe06b0c5204ee70bdb2a3c"],"7a0b8b7d237d61dcead2d98e45b3479941a41db8":["eebf3ab509404167976d51dd135e5d95c74996a5"],"8a8259c922a83abc544609227a60d48e5ee93e7e":["7a0b8b7d237d61dcead2d98e45b3479941a41db8"],"7a3554ff15950ad0e3bcbb4e4e2ddb45b0b0f27e":["8a8259c922a83abc544609227a60d48e5ee93e7e"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["9d951133e62b079e1dde80890d60bf451997355b","9aea0485ecacb6734c17da2d02569816c23a69c1"],"9e3751ad4cc85eb979419cf5469dfba266eae56a":["c44cc06c26e456fe9c215072b79fce30babe3975"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["7b1605dda5afabdc06fd136fa0dd14ad326e3001","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"77cc5d33c4ecf450c71edad489df69de68a73a11":["7a3554ff15950ad0e3bcbb4e4e2ddb45b0b0f27e"],"5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf":["73457c9372b4f2f962ca916788a5fe9e1f644a9f","0265144286422ad99682a00904cc2536b79c8535"],"2668c99990e4c94a78bac005aa682b7c5986d23a":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"773a737806859660d4756f710adc0ad53e05f9d5":["9aea0485ecacb6734c17da2d02569816c23a69c1"],"140be51d03394488536f4aacedace29f9b318347":["9e3751ad4cc85eb979419cf5469dfba266eae56a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"da31fa73cb487fbb3136c9165470193515358b0b":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"a360f5e61c6281e4b1e4daa253ed716a6b2cd491":["b6284684320a9808c41a5e43de958b2da22f89bd"],"9d951133e62b079e1dde80890d60bf451997355b":["beea4d4bbebcfb6689ed31936553c5e98bce2871"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["da31fa73cb487fbb3136c9165470193515358b0b"],"7b1605dda5afabdc06fd136fa0dd14ad326e3001":["3615ce4a1f785ae1b779244de52c6a7d99227e60"],"9aea0485ecacb6734c17da2d02569816c23a69c1":["9d951133e62b079e1dde80890d60bf451997355b"],"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2":["7530de27b87b961b51f01bd1299b7004d46e8823"],"e22ffe8cc51a892ae103df018822d7873e901c2a":["c26f00b574427b55127e869b935845554afde1fa"],"043df2e9a841864922c32756a44c939ed768cb89":["9220b7d1848f68bc299608612f8e0139c4036fcf"],"6554f36a4636755009195a7840518bf6b4f03d6c":["73457c9372b4f2f962ca916788a5fe9e1f644a9f"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["7b1605dda5afabdc06fd136fa0dd14ad326e3001","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"24792720c893049d53a1807bd0ae9b64d1cd7be5":["96e0d4494fe54b31c7f0151f3a632124ab806351"],"c6ba9c6a7bb3418fae644fe4b821c94cf739338a":["6554f36a4636755009195a7840518bf6b4f03d6c"],"0265144286422ad99682a00904cc2536b79c8535":["c6ba9c6a7bb3418fae644fe4b821c94cf739338a"],"b6284684320a9808c41a5e43de958b2da22f89bd":["9220b7d1848f68bc299608612f8e0139c4036fcf","043df2e9a841864922c32756a44c939ed768cb89"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"6e360143e9d6f677ecfe06b0c5204ee70bdb2a3c":["2668c99990e4c94a78bac005aa682b7c5986d23a"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["da31fa73cb487fbb3136c9165470193515358b0b","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["7b1605dda5afabdc06fd136fa0dd14ad326e3001"],"3615ce4a1f785ae1b779244de52c6a7d99227e60":["7a3554ff15950ad0e3bcbb4e4e2ddb45b0b0f27e","77cc5d33c4ecf450c71edad489df69de68a73a11"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"eebf3ab509404167976d51dd135e5d95c74996a5":["1ba7ea4168f8418335f06510cdcb5be262f35c73"],"7530de27b87b961b51f01bd1299b7004d46e8823":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"73457c9372b4f2f962ca916788a5fe9e1f644a9f":["b6284684320a9808c41a5e43de958b2da22f89bd","a360f5e61c6281e4b1e4daa253ed716a6b2cd491"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["75237075d8425856bf4bbf52a6be4f9162b8187d"],"b0b597c65628ca9e73913a07e81691f8229bae35":["6e360143e9d6f677ecfe06b0c5204ee70bdb2a3c","c44cc06c26e456fe9c215072b79fce30babe3975"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"75237075d8425856bf4bbf52a6be4f9162b8187d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"96e0d4494fe54b31c7f0151f3a632124ab806351":["24792720c893049d53a1807bd0ae9b64d1cd7be5"],"9220b7d1848f68bc299608612f8e0139c4036fcf":["043df2e9a841864922c32756a44c939ed768cb89","b6284684320a9808c41a5e43de958b2da22f89bd"],"beea4d4bbebcfb6689ed31936553c5e98bce2871":["9d951133e62b079e1dde80890d60bf451997355b"],"1ba7ea4168f8418335f06510cdcb5be262f35c73":["eebf3ab509404167976d51dd135e5d95c74996a5"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["2668c99990e4c94a78bac005aa682b7c5986d23a"],"ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00":[],"c26f00b574427b55127e869b935845554afde1fa":["e22ffe8cc51a892ae103df018822d7873e901c2a"],"c44cc06c26e456fe9c215072b79fce30babe3975":["9e3751ad4cc85eb979419cf5469dfba266eae56a","b0b597c65628ca9e73913a07e81691f8229bae35"],"7a0b8b7d237d61dcead2d98e45b3479941a41db8":["8a8259c922a83abc544609227a60d48e5ee93e7e"],"8a8259c922a83abc544609227a60d48e5ee93e7e":["7a3554ff15950ad0e3bcbb4e4e2ddb45b0b0f27e"],"7a3554ff15950ad0e3bcbb4e4e2ddb45b0b0f27e":["ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00","77cc5d33c4ecf450c71edad489df69de68a73a11","3615ce4a1f785ae1b779244de52c6a7d99227e60"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"9e3751ad4cc85eb979419cf5469dfba266eae56a":["140be51d03394488536f4aacedace29f9b318347"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":[],"77cc5d33c4ecf450c71edad489df69de68a73a11":["3615ce4a1f785ae1b779244de52c6a7d99227e60"],"5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf":[],"773a737806859660d4756f710adc0ad53e05f9d5":["9220b7d1848f68bc299608612f8e0139c4036fcf"],"2668c99990e4c94a78bac005aa682b7c5986d23a":["6e360143e9d6f677ecfe06b0c5204ee70bdb2a3c"],"140be51d03394488536f4aacedace29f9b318347":["75237075d8425856bf4bbf52a6be4f9162b8187d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"da31fa73cb487fbb3136c9165470193515358b0b":["4d3e8520fd031bab31fd0e4d480e55958bc45efe","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"a360f5e61c6281e4b1e4daa253ed716a6b2cd491":["73457c9372b4f2f962ca916788a5fe9e1f644a9f"],"9d951133e62b079e1dde80890d60bf451997355b":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","9aea0485ecacb6734c17da2d02569816c23a69c1"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","fe33227f6805edab2036cbb80645cc4e2d1fa424","7530de27b87b961b51f01bd1299b7004d46e8823"],"7b1605dda5afabdc06fd136fa0dd14ad326e3001":["0d22ac6a4146774c1bc8400160fc0b6150294e92","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"9aea0485ecacb6734c17da2d02569816c23a69c1":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","773a737806859660d4756f710adc0ad53e05f9d5"],"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2":["beea4d4bbebcfb6689ed31936553c5e98bce2871"],"e22ffe8cc51a892ae103df018822d7873e901c2a":["1ba7ea4168f8418335f06510cdcb5be262f35c73"],"043df2e9a841864922c32756a44c939ed768cb89":["b6284684320a9808c41a5e43de958b2da22f89bd"],"6554f36a4636755009195a7840518bf6b4f03d6c":["c6ba9c6a7bb3418fae644fe4b821c94cf739338a"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":[],"24792720c893049d53a1807bd0ae9b64d1cd7be5":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"c6ba9c6a7bb3418fae644fe4b821c94cf739338a":["0265144286422ad99682a00904cc2536b79c8535"],"0265144286422ad99682a00904cc2536b79c8535":["96e0d4494fe54b31c7f0151f3a632124ab806351","5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf"],"b6284684320a9808c41a5e43de958b2da22f89bd":["a360f5e61c6281e4b1e4daa253ed716a6b2cd491","73457c9372b4f2f962ca916788a5fe9e1f644a9f"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"6e360143e9d6f677ecfe06b0c5204ee70bdb2a3c":["c44cc06c26e456fe9c215072b79fce30babe3975","b0b597c65628ca9e73913a07e81691f8229bae35"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"3615ce4a1f785ae1b779244de52c6a7d99227e60":["ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00","7b1605dda5afabdc06fd136fa0dd14ad326e3001"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["0d22ac6a4146774c1bc8400160fc0b6150294e92","da31fa73cb487fbb3136c9165470193515358b0b","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"eebf3ab509404167976d51dd135e5d95c74996a5":["7a0b8b7d237d61dcead2d98e45b3479941a41db8"],"7530de27b87b961b51f01bd1299b7004d46e8823":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"73457c9372b4f2f962ca916788a5fe9e1f644a9f":["5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf","6554f36a4636755009195a7840518bf6b4f03d6c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","0d22ac6a4146774c1bc8400160fc0b6150294e92","5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","fe33227f6805edab2036cbb80645cc4e2d1fa424","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}