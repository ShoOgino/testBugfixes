{"path":"solr/core/src/java/org/apache/solr/packagemanager/PackageManager#getPackagesDeployedAsClusterLevelPlugins().mjava","commits":[{"id":"a688687cbff91a8f44c95d31697c3ba8a47c8c25","date":1593512440,"type":0,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/packagemanager/PackageManager#getPackagesDeployedAsClusterLevelPlugins().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Get a list of packages that have their plugins deployed as cluster level plugins.\n   * The returned packages also contain the \"pluginMeta\" from \"clusterprops.json\" as custom data. \n   */\n  @SuppressWarnings(\"unchecked\")\n  public Map<String, SolrPackageInstance> getPackagesDeployedAsClusterLevelPlugins() {\n    Map<String, String> packageVersions = new HashMap<String, String>();\n    MultiValueMap packagePlugins = new MultiValueMap(); // map of package name to multiple values of pluginMeta (Map<String, String>)\n    Map<String, Object> result = (Map<String, Object>) Utils.executeGET(solrClient.getHttpClient(),\n        solrBaseUrl + PackageUtils.CLUSTERPROPS_PATH, Utils.JSONCONSUMER);\n    Map<String, Object> clusterPlugins = (Map<String, Object>) result.getOrDefault(\"plugin\", Collections.emptyMap());\n    for (String key: clusterPlugins.keySet()) {\n      // Map<String, String> pluginMeta = (Map<String, String>) clusterPlugins.get(key);\n      PluginMeta pluginMeta;\n      try {\n        pluginMeta = PackageUtils.getMapper().readValue(Utils.toJSON(clusterPlugins.get(key)), PluginMeta.class);\n      } catch (IOException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Exception while fetching plugins from /clusterprops.json in ZK.\", e);\n      }\n      if (pluginMeta.klass.contains(\":\")) {\n        String packageName = pluginMeta.klass.substring(0, pluginMeta.klass.indexOf(':'));\n        packageVersions.put(packageName, pluginMeta.version);\n        packagePlugins.put(packageName, pluginMeta);\n      }\n    }\n    Map<String, SolrPackageInstance> ret = new HashMap<>();\n    for (String packageName: packageVersions.keySet()) {\n      if (Strings.isNullOrEmpty(packageName) == false && // There can be an empty key, storing the version here\n          packageVersions.get(packageName) != null) { // null means the package was undeployed from this package before\n        ret.put(packageName, getPackageInstance(packageName, packageVersions.get(packageName)));\n        ret.get(packageName).setCustomData(packagePlugins.getCollection(packageName));\n      }\n    }\n    return ret;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"06eb5f96c63fb4bd8b194a33fd050326145d5070","date":1595538555,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/packagemanager/PackageManager#getPackagesDeployedAsClusterLevelPlugins().mjava","pathOld":"solr/core/src/java/org/apache/solr/packagemanager/PackageManager#getPackagesDeployedAsClusterLevelPlugins().mjava","sourceNew":"  /**\n   * Get a list of packages that have their plugins deployed as cluster level plugins.\n   * The returned packages also contain the \"pluginMeta\" from \"clusterprops.json\" as custom data. \n   */\n  public Map<String, SolrPackageInstance> getPackagesDeployedAsClusterLevelPlugins() {\n    Map<String, String> packageVersions = new HashMap<>();\n    MultiValuedMap<String, PluginMeta> packagePlugins = new HashSetValuedHashMap<>(); // map of package name to multiple values of pluginMeta (Map<String, String>)\n    @SuppressWarnings({\"unchecked\"})\n    Map<String, Object> result =  (Map<String, Object>)Utils.executeGET(solrClient.getHttpClient(),\n        solrBaseUrl + PackageUtils.CLUSTERPROPS_PATH, Utils.JSONCONSUMER);\n    @SuppressWarnings({\"unchecked\"})\n    Map<String, Object> clusterPlugins = (Map<String, Object>) result.getOrDefault(\"plugin\", Collections.emptyMap());\n    for (String key: clusterPlugins.keySet()) {\n      // Map<String, String> pluginMeta = (Map<String, String>) clusterPlugins.get(key);\n      PluginMeta pluginMeta;\n      try {\n        pluginMeta = PackageUtils.getMapper().readValue(Utils.toJSON(clusterPlugins.get(key)), PluginMeta.class);\n      } catch (IOException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Exception while fetching plugins from /clusterprops.json in ZK.\", e);\n      }\n      if (pluginMeta.klass.contains(\":\")) {\n        String packageName = pluginMeta.klass.substring(0, pluginMeta.klass.indexOf(':'));\n        packageVersions.put(packageName, pluginMeta.version);\n        packagePlugins.put(packageName, pluginMeta);\n      }\n    }\n    Map<String, SolrPackageInstance> ret = new HashMap<>();\n    for (String packageName: packageVersions.keySet()) {\n      if (Strings.isNullOrEmpty(packageName) == false && // There can be an empty key, storing the version here\n          packageVersions.get(packageName) != null) { // null means the package was undeployed from this package before\n        ret.put(packageName, getPackageInstance(packageName, packageVersions.get(packageName)));\n        ret.get(packageName).setCustomData(packagePlugins.get(packageName));\n      }\n    }\n    return ret;\n  }\n\n","sourceOld":"  /**\n   * Get a list of packages that have their plugins deployed as cluster level plugins.\n   * The returned packages also contain the \"pluginMeta\" from \"clusterprops.json\" as custom data. \n   */\n  @SuppressWarnings(\"unchecked\")\n  public Map<String, SolrPackageInstance> getPackagesDeployedAsClusterLevelPlugins() {\n    Map<String, String> packageVersions = new HashMap<String, String>();\n    MultiValueMap packagePlugins = new MultiValueMap(); // map of package name to multiple values of pluginMeta (Map<String, String>)\n    Map<String, Object> result = (Map<String, Object>) Utils.executeGET(solrClient.getHttpClient(),\n        solrBaseUrl + PackageUtils.CLUSTERPROPS_PATH, Utils.JSONCONSUMER);\n    Map<String, Object> clusterPlugins = (Map<String, Object>) result.getOrDefault(\"plugin\", Collections.emptyMap());\n    for (String key: clusterPlugins.keySet()) {\n      // Map<String, String> pluginMeta = (Map<String, String>) clusterPlugins.get(key);\n      PluginMeta pluginMeta;\n      try {\n        pluginMeta = PackageUtils.getMapper().readValue(Utils.toJSON(clusterPlugins.get(key)), PluginMeta.class);\n      } catch (IOException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Exception while fetching plugins from /clusterprops.json in ZK.\", e);\n      }\n      if (pluginMeta.klass.contains(\":\")) {\n        String packageName = pluginMeta.klass.substring(0, pluginMeta.klass.indexOf(':'));\n        packageVersions.put(packageName, pluginMeta.version);\n        packagePlugins.put(packageName, pluginMeta);\n      }\n    }\n    Map<String, SolrPackageInstance> ret = new HashMap<>();\n    for (String packageName: packageVersions.keySet()) {\n      if (Strings.isNullOrEmpty(packageName) == false && // There can be an empty key, storing the version here\n          packageVersions.get(packageName) != null) { // null means the package was undeployed from this package before\n        ret.put(packageName, getPackageInstance(packageName, packageVersions.get(packageName)));\n        ret.get(packageName).setCustomData(packagePlugins.getCollection(packageName));\n      }\n    }\n    return ret;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"30544190fa1b1f7b98cd8e9b84dd86060d89bdcd","date":1596533005,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/packagemanager/PackageManager#getPackagesDeployedAsClusterLevelPlugins().mjava","pathOld":"solr/core/src/java/org/apache/solr/packagemanager/PackageManager#getPackagesDeployedAsClusterLevelPlugins().mjava","sourceNew":"  /**\n   * Get a map of packages (key: package name, value: package instance) that have their plugins deployed as cluster level plugins.\n   * The returned packages also contain the \"pluginMeta\" from \"clusterprops.json\" as custom data.\n   */\n  @SuppressWarnings({\"unchecked\"})\n  public Map<String, SolrPackageInstance> getPackagesDeployedAsClusterLevelPlugins() {\n    Map<String, String> packageVersions = new HashMap<>();\n    MultiValuedMap<String, PluginMeta> packagePlugins = new HashSetValuedHashMap<>(); // map of package name to multiple values of pluginMeta (Map<String, String>)\n    @SuppressWarnings({\"unchecked\"})\n    Map<String, Object> result;\n    try {\n      result = (Map<String, Object>) Utils.executeGET(solrClient.getHttpClient(),\n               solrBaseUrl + PackageUtils.CLUSTERPROPS_PATH, Utils.JSONCONSUMER);\n    } catch (SolrException ex) {\n      if (ex.code() == ErrorCode.NOT_FOUND.code) {\n        result = Collections.emptyMap(); // Cluster props doesn't exist, that means there are no cluster level plugins installed.\n      } else {\n        throw ex;\n      }\n    }\n    @SuppressWarnings({\"unchecked\"})\n    Map<String, Object> clusterPlugins = (Map<String, Object>) result.getOrDefault(\"plugin\", Collections.emptyMap());\n    for (String key : clusterPlugins.keySet()) {\n      // Map<String, String> pluginMeta = (Map<String, String>) clusterPlugins.get(key);\n      PluginMeta pluginMeta;\n      try {\n        pluginMeta = PackageUtils.getMapper().readValue(Utils.toJSON(clusterPlugins.get(key)), PluginMeta.class);\n      } catch (IOException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Exception while fetching plugins from /clusterprops.json in ZK.\", e);\n      }\n      if (pluginMeta.klass.contains(\":\")) {\n        String packageName = pluginMeta.klass.substring(0, pluginMeta.klass.indexOf(':'));\n        packageVersions.put(packageName, pluginMeta.version);\n        packagePlugins.put(packageName, pluginMeta);\n      }\n    }\n    Map<String, SolrPackageInstance> ret = new HashMap<>();\n    for (String packageName: packageVersions.keySet()) {\n      if (Strings.isNullOrEmpty(packageName) == false && // There can be an empty key, storing the version here\n          packageVersions.get(packageName) != null) { // null means the package was undeployed from this package before\n        ret.put(packageName, getPackageInstance(packageName, packageVersions.get(packageName)));\n        ret.get(packageName).setCustomData(packagePlugins.get(packageName));\n      }\n    }\n    return ret;\n  }\n\n","sourceOld":"  /**\n   * Get a list of packages that have their plugins deployed as cluster level plugins.\n   * The returned packages also contain the \"pluginMeta\" from \"clusterprops.json\" as custom data. \n   */\n  public Map<String, SolrPackageInstance> getPackagesDeployedAsClusterLevelPlugins() {\n    Map<String, String> packageVersions = new HashMap<>();\n    MultiValuedMap<String, PluginMeta> packagePlugins = new HashSetValuedHashMap<>(); // map of package name to multiple values of pluginMeta (Map<String, String>)\n    @SuppressWarnings({\"unchecked\"})\n    Map<String, Object> result =  (Map<String, Object>)Utils.executeGET(solrClient.getHttpClient(),\n        solrBaseUrl + PackageUtils.CLUSTERPROPS_PATH, Utils.JSONCONSUMER);\n    @SuppressWarnings({\"unchecked\"})\n    Map<String, Object> clusterPlugins = (Map<String, Object>) result.getOrDefault(\"plugin\", Collections.emptyMap());\n    for (String key: clusterPlugins.keySet()) {\n      // Map<String, String> pluginMeta = (Map<String, String>) clusterPlugins.get(key);\n      PluginMeta pluginMeta;\n      try {\n        pluginMeta = PackageUtils.getMapper().readValue(Utils.toJSON(clusterPlugins.get(key)), PluginMeta.class);\n      } catch (IOException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Exception while fetching plugins from /clusterprops.json in ZK.\", e);\n      }\n      if (pluginMeta.klass.contains(\":\")) {\n        String packageName = pluginMeta.klass.substring(0, pluginMeta.klass.indexOf(':'));\n        packageVersions.put(packageName, pluginMeta.version);\n        packagePlugins.put(packageName, pluginMeta);\n      }\n    }\n    Map<String, SolrPackageInstance> ret = new HashMap<>();\n    for (String packageName: packageVersions.keySet()) {\n      if (Strings.isNullOrEmpty(packageName) == false && // There can be an empty key, storing the version here\n          packageVersions.get(packageName) != null) { // null means the package was undeployed from this package before\n        ret.put(packageName, getPackageInstance(packageName, packageVersions.get(packageName)));\n        ret.get(packageName).setCustomData(packagePlugins.get(packageName));\n      }\n    }\n    return ret;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"30544190fa1b1f7b98cd8e9b84dd86060d89bdcd":["06eb5f96c63fb4bd8b194a33fd050326145d5070"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"06eb5f96c63fb4bd8b194a33fd050326145d5070":["a688687cbff91a8f44c95d31697c3ba8a47c8c25"],"a688687cbff91a8f44c95d31697c3ba8a47c8c25":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["30544190fa1b1f7b98cd8e9b84dd86060d89bdcd"]},"commit2Childs":{"30544190fa1b1f7b98cd8e9b84dd86060d89bdcd":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a688687cbff91a8f44c95d31697c3ba8a47c8c25"],"06eb5f96c63fb4bd8b194a33fd050326145d5070":["30544190fa1b1f7b98cd8e9b84dd86060d89bdcd"],"a688687cbff91a8f44c95d31697c3ba8a47c8c25":["06eb5f96c63fb4bd8b194a33fd050326145d5070"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}