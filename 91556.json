{"path":"solr/core/src/test/org/apache/solr/util/hll/FullHLLTest#registerValueTest().mjava","commits":[{"id":"6faa211c4af605e3cf078a76d200c1dc348973f5","date":1437043657,"type":0,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/util/hll/FullHLLTest#registerValueTest().mjava","pathOld":"/dev/null","sourceNew":"    // ========================================================================\n    /**\n     * Tests the bounds on a register's value for a given raw input value.\n     */\n    @Test\n    public void registerValueTest() {\n        final int log2m = 4/*small enough to make testing easy (addRaw() shifts by one byte)*/;\n\n        // register width 4 (the minimum size)\n        { // scoped locally for sanity\n            final int regwidth = 4;\n            final HLL hll = new HLL(log2m, regwidth, 128/*explicitThreshold, arbitrary, unused*/, 256/*sparseThreshold, arbitrary, unused*/, HLLType.FULL);\n            final BitVector bitVector = hll.probabilisticStorage;\n\n            // lower-bounds of the register\n            hll.addRaw(0x000000000000001L/*'j'=1*/);\n            assertEquals(bitVector.getRegister(1/*'j'*/), 0);\n\n            hll.addRaw(0x0000000000000012L/*'j'=2*/);\n            assertEquals(bitVector.getRegister(2/*'j'*/), 1);\n\n            hll.addRaw(0x0000000000000023L/*'j'=3*/);\n            assertEquals(bitVector.getRegister(3/*'j'*/), 2);\n\n            hll.addRaw(0x0000000000000044L/*'j'=4*/);\n            assertEquals(bitVector.getRegister(4/*'j'*/), 3);\n\n            hll.addRaw(0x0000000000000085L/*'j'=5*/);\n            assertEquals(bitVector.getRegister(5/*'j'*/), 4);\n\n            // upper-bounds of the register\n            // NOTE:  bear in mind that BitVector itself does ensure that\n            //        overflow of a register is prevented\n            hll.addRaw(0x0000000000010006L/*'j'=6*/);\n            assertEquals(bitVector.getRegister(6/*'j'*/), 13);\n\n            hll.addRaw(0x0000000000020007L/*'j'=7*/);\n            assertEquals(bitVector.getRegister(7/*'j'*/), 14);\n\n            hll.addRaw(0x0000000000040008L/*'j'=8*/);\n            assertEquals(bitVector.getRegister(8/*'j'*/), 15);\n\n            hll.addRaw(0x0000000000080009L/*'j'=9*/);\n            assertEquals(bitVector.getRegister(9/*'j'*/), 15/*overflow*/);\n\n            // sanity checks to ensure that no other bits above the lowest-set\n            // bit matters\n            // NOTE:  same as case 'j = 6' above\n            hll.addRaw(0x000000000003000AL/*'j'=10*/);\n            assertEquals(bitVector.getRegister(10/*'j'*/), 13);\n\n            hll.addRaw(0x000000000011000BL/*'j'=11*/);\n            assertEquals(bitVector.getRegister(11/*'j'*/), 13);\n        }\n\n        // register width 5\n        { // scoped locally for sanity\n            final int regwidth = 5;\n            final HLL hll = new HLL(log2m, regwidth, 128/*explicitThreshold, arbitrary, unused*/, 256/*sparseThreshold, arbitrary, unused*/, HLLType.FULL);\n            final BitVector bitVector = hll.probabilisticStorage;\n\n            // lower-bounds of the register\n            hll.addRaw(0x0000000000000001L/*'j'=1*/);\n            assertEquals(bitVector.getRegister(1/*'j'*/), 0);\n\n            hll.addRaw(0x0000000000000012L/*'j'=2*/);\n            assertEquals(bitVector.getRegister(2/*'j'*/), 1);\n\n            hll.addRaw(0x0000000000000023L/*'j'=3*/);\n            assertEquals(bitVector.getRegister(3/*'j'*/), 2);\n\n            hll.addRaw(0x0000000000000044L/*'j'=4*/);\n            assertEquals(bitVector.getRegister(4/*'j'*/), 3);\n\n            hll.addRaw(0x0000000000000085L/*'j'=5*/);\n            assertEquals(bitVector.getRegister(5/*'j'*/), 4);\n\n            // upper-bounds of the register\n            // NOTE:  bear in mind that BitVector itself does ensure that\n            //        overflow of a register is prevented\n            hll.addRaw(0x0000000100000006L/*'j'=6*/);\n            assertEquals(bitVector.getRegister(6/*'j'*/), 29);\n\n            hll.addRaw(0x0000000200000007L/*'j'=7*/);\n            assertEquals(bitVector.getRegister(7/*'j'*/), 30);\n\n            hll.addRaw(0x0000000400000008L/*'j'=8*/);\n            assertEquals(bitVector.getRegister(8/*'j'*/), 31);\n\n            hll.addRaw(0x0000000800000009L/*'j'=9*/);\n            assertEquals(bitVector.getRegister(9/*'j'*/), 31/*overflow*/);\n        }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3b5ee4c66244bdfcc4796a114519d47701b2c026","date":1437132013,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/util/hll/FullHLLTest#registerValueTest().mjava","pathOld":"/dev/null","sourceNew":"    // ========================================================================\n    /**\n     * Tests the bounds on a register's value for a given raw input value.\n     */\n    @Test\n    public void registerValueTest() {\n        final int log2m = 4/*small enough to make testing easy (addRaw() shifts by one byte)*/;\n\n        // register width 4 (the minimum size)\n        { // scoped locally for sanity\n            final int regwidth = 4;\n            final HLL hll = new HLL(log2m, regwidth, 128/*explicitThreshold, arbitrary, unused*/, 256/*sparseThreshold, arbitrary, unused*/, HLLType.FULL);\n            final BitVector bitVector = hll.probabilisticStorage;\n\n            // lower-bounds of the register\n            hll.addRaw(0x000000000000001L/*'j'=1*/);\n            assertEquals(bitVector.getRegister(1/*'j'*/), 0);\n\n            hll.addRaw(0x0000000000000012L/*'j'=2*/);\n            assertEquals(bitVector.getRegister(2/*'j'*/), 1);\n\n            hll.addRaw(0x0000000000000023L/*'j'=3*/);\n            assertEquals(bitVector.getRegister(3/*'j'*/), 2);\n\n            hll.addRaw(0x0000000000000044L/*'j'=4*/);\n            assertEquals(bitVector.getRegister(4/*'j'*/), 3);\n\n            hll.addRaw(0x0000000000000085L/*'j'=5*/);\n            assertEquals(bitVector.getRegister(5/*'j'*/), 4);\n\n            // upper-bounds of the register\n            // NOTE:  bear in mind that BitVector itself does ensure that\n            //        overflow of a register is prevented\n            hll.addRaw(0x0000000000010006L/*'j'=6*/);\n            assertEquals(bitVector.getRegister(6/*'j'*/), 13);\n\n            hll.addRaw(0x0000000000020007L/*'j'=7*/);\n            assertEquals(bitVector.getRegister(7/*'j'*/), 14);\n\n            hll.addRaw(0x0000000000040008L/*'j'=8*/);\n            assertEquals(bitVector.getRegister(8/*'j'*/), 15);\n\n            hll.addRaw(0x0000000000080009L/*'j'=9*/);\n            assertEquals(bitVector.getRegister(9/*'j'*/), 15/*overflow*/);\n\n            // sanity checks to ensure that no other bits above the lowest-set\n            // bit matters\n            // NOTE:  same as case 'j = 6' above\n            hll.addRaw(0x000000000003000AL/*'j'=10*/);\n            assertEquals(bitVector.getRegister(10/*'j'*/), 13);\n\n            hll.addRaw(0x000000000011000BL/*'j'=11*/);\n            assertEquals(bitVector.getRegister(11/*'j'*/), 13);\n        }\n\n        // register width 5\n        { // scoped locally for sanity\n            final int regwidth = 5;\n            final HLL hll = new HLL(log2m, regwidth, 128/*explicitThreshold, arbitrary, unused*/, 256/*sparseThreshold, arbitrary, unused*/, HLLType.FULL);\n            final BitVector bitVector = hll.probabilisticStorage;\n\n            // lower-bounds of the register\n            hll.addRaw(0x0000000000000001L/*'j'=1*/);\n            assertEquals(bitVector.getRegister(1/*'j'*/), 0);\n\n            hll.addRaw(0x0000000000000012L/*'j'=2*/);\n            assertEquals(bitVector.getRegister(2/*'j'*/), 1);\n\n            hll.addRaw(0x0000000000000023L/*'j'=3*/);\n            assertEquals(bitVector.getRegister(3/*'j'*/), 2);\n\n            hll.addRaw(0x0000000000000044L/*'j'=4*/);\n            assertEquals(bitVector.getRegister(4/*'j'*/), 3);\n\n            hll.addRaw(0x0000000000000085L/*'j'=5*/);\n            assertEquals(bitVector.getRegister(5/*'j'*/), 4);\n\n            // upper-bounds of the register\n            // NOTE:  bear in mind that BitVector itself does ensure that\n            //        overflow of a register is prevented\n            hll.addRaw(0x0000000100000006L/*'j'=6*/);\n            assertEquals(bitVector.getRegister(6/*'j'*/), 29);\n\n            hll.addRaw(0x0000000200000007L/*'j'=7*/);\n            assertEquals(bitVector.getRegister(7/*'j'*/), 30);\n\n            hll.addRaw(0x0000000400000008L/*'j'=8*/);\n            assertEquals(bitVector.getRegister(8/*'j'*/), 31);\n\n            hll.addRaw(0x0000000800000009L/*'j'=9*/);\n            assertEquals(bitVector.getRegister(9/*'j'*/), 31/*overflow*/);\n        }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3b5ee4c66244bdfcc4796a114519d47701b2c026":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6faa211c4af605e3cf078a76d200c1dc348973f5"],"6faa211c4af605e3cf078a76d200c1dc348973f5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3b5ee4c66244bdfcc4796a114519d47701b2c026"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3b5ee4c66244bdfcc4796a114519d47701b2c026","6faa211c4af605e3cf078a76d200c1dc348973f5"],"3b5ee4c66244bdfcc4796a114519d47701b2c026":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6faa211c4af605e3cf078a76d200c1dc348973f5":["3b5ee4c66244bdfcc4796a114519d47701b2c026"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}