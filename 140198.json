{"path":"solr/core/src/java/org/apache/solr/util/SolrCLI.HealthcheckTool#runCloudTool(CloudSolrServer,CommandLine).mjava","commits":[{"id":"709714c6ee47950678dd2d2ef4e0473886909226","date":1407339661,"type":0,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/SolrCLI.HealthcheckTool#runCloudTool(CloudSolrServer,CommandLine).mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    protected void runCloudTool(CloudSolrServer cloudSolrServer, CommandLine cli) throws Exception {\n      \n      String collection = cli.getOptionValue(\"collection\");\n      if (collection == null)\n        throw new IllegalArgumentException(\"Must provide a collection to run a healthcheck against!\");\n      \n      log.info(\"Running healthcheck for \"+collection);\n      \n      ZkStateReader zkStateReader = cloudSolrServer.getZkStateReader();\n      Collection<Slice> slices = zkStateReader.getClusterState().getSlices(collection);\n      if (slices == null)\n        throw new IllegalArgumentException(\"Collection \"+collection+\" not found!\");\n      \n      SolrQuery q = new SolrQuery(\"*:*\");\n      q.setRows(0);      \n      QueryResponse qr = cloudSolrServer.query(q);\n      String collErr = null;\n      long docCount = -1;\n      try {\n        docCount = qr.getResults().getNumFound();\n      } catch (Exception exc) {\n        collErr = String.valueOf(exc);\n      }\n      \n      List<Object> shardList = new ArrayList<>();\n      boolean collectionIsHealthy = (docCount != -1);\n      \n      for (Slice slice : slices) {\n        String shardName = slice.getName();\n        // since we're reporting health of this shard, there's no guarantee of a leader\n        String leaderUrl = null;\n        try {\n          leaderUrl = zkStateReader.getLeaderUrl(collection, shardName, 1000);\n        } catch (Exception exc) {\n          log.warn(\"Failed to get leader for shard \"+shardName+\" due to: \"+exc);\n        }\n        \n        List<ReplicaHealth> replicaList = new ArrayList<ReplicaHealth>();        \n        for (Replica r : slice.getReplicas()) {\n          \n          String uptime = null;\n          String memory = null;\n          String replicaStatus = null;\n          long numDocs = -1L;\n          \n          ZkCoreNodeProps replicaCoreProps = new ZkCoreNodeProps(r);\n          String coreUrl = replicaCoreProps.getCoreUrl();\n          boolean isLeader = coreUrl.equals(leaderUrl);\n          \n          // query this replica directly to get doc count and assess health\n          HttpSolrServer solr = new HttpSolrServer(coreUrl);\n          String solrUrl = solr.getBaseURL();\n          q = new SolrQuery(\"*:*\");\n          q.setRows(0);\n          q.set(\"distrib\", \"false\");          \n          try {\n            qr = solr.query(q);\n            numDocs = qr.getResults().getNumFound();\n            \n            int lastSlash = solrUrl.lastIndexOf('/');            \n            String systemInfoUrl = solrUrl.substring(0,lastSlash)+\"/admin/info/system\";\n            Map<String,Object> info = getJson(solr.getHttpClient(), systemInfoUrl, 2);\n            uptime = uptime(asLong(\"/jvm/jmx/upTimeMS\", info));            \n            String usedMemory = asString(\"/jvm/memory/used\", info);\n            String totalMemory = asString(\"/jvm/memory/total\", info);\n            memory = usedMemory+\" of \"+totalMemory;\n            \n            // if we get here, we can trust the state\n            replicaStatus = replicaCoreProps.getState();                                                                      \n          } catch (Exception exc) {\n            log.error(\"ERROR: \" + exc + \" when trying to reach: \" + solrUrl);\n\n            if (checkCommunicationError(exc)) {\n              replicaStatus = \"down\";\n            } else {\n              replicaStatus = \"error: \"+exc;\n            }            \n          } finally {\n            solr.shutdown();\n          }\n          \n          replicaList.add(new ReplicaHealth(shardName, r.getName(), coreUrl, \n              replicaStatus, numDocs, isLeader, uptime, memory));          \n        }\n        \n        ShardHealth shardHealth = new ShardHealth(shardName, replicaList);        \n        if (ShardState.healthy != shardHealth.getShardState())\n          collectionIsHealthy = false; // at least one shard is un-healthy\n        \n        shardList.add(shardHealth.asMap());        \n      }\n      \n      \n      Map<String,Object> report = new LinkedHashMap<String,Object>();\n      report.put(\"collection\", collection);\n      report.put(\"status\", collectionIsHealthy ? \"healthy\" : \"degraded\");\n      if (collErr != null) {\n        report.put(\"error\", collErr);\n      }\n      report.put(\"numDocs\", docCount);\n      report.put(\"numShards\", slices.size());      \n      report.put(\"shards\", shardList);\n                        \n      CharArr arr = new CharArr();\n      new JSONWriter(arr, 2).write(report);\n      System.out.println(arr.toString());\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["abbeeaace38fe60785787cbd76514bf02f2c8af6"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"abbeeaace38fe60785787cbd76514bf02f2c8af6","date":1411403636,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/SolrCLI.HealthcheckTool#runCloudTool(CloudSolrServer,CommandLine).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/SolrCLI.HealthcheckTool#runCloudTool(CloudSolrServer,CommandLine).mjava","sourceNew":"    @Override\n    protected void runCloudTool(CloudSolrServer cloudSolrServer, CommandLine cli) throws Exception {\n      \n      String collection = cli.getOptionValue(\"collection\");\n      if (collection == null)\n        throw new IllegalArgumentException(\"Must provide a collection to run a healthcheck against!\");\n      \n      log.info(\"Running healthcheck for \"+collection);\n      \n      ZkStateReader zkStateReader = cloudSolrServer.getZkStateReader();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      Collection<Slice> slices = clusterState.getSlices(collection);\n      if (slices == null)\n        throw new IllegalArgumentException(\"Collection \"+collection+\" not found!\");\n      \n      SolrQuery q = new SolrQuery(\"*:*\");\n      q.setRows(0);      \n      QueryResponse qr = cloudSolrServer.query(q);\n      String collErr = null;\n      long docCount = -1;\n      try {\n        docCount = qr.getResults().getNumFound();\n      } catch (Exception exc) {\n        collErr = String.valueOf(exc);\n      }\n      \n      List<Object> shardList = new ArrayList<>();\n      boolean collectionIsHealthy = (docCount != -1);\n      \n      for (Slice slice : slices) {\n        String shardName = slice.getName();\n        // since we're reporting health of this shard, there's no guarantee of a leader\n        String leaderUrl = null;\n        try {\n          leaderUrl = zkStateReader.getLeaderUrl(collection, shardName, 1000);\n        } catch (Exception exc) {\n          log.warn(\"Failed to get leader for shard \"+shardName+\" due to: \"+exc);\n        }\n        \n        List<ReplicaHealth> replicaList = new ArrayList<ReplicaHealth>();        \n        for (Replica r : slice.getReplicas()) {\n          \n          String uptime = null;\n          String memory = null;\n          String replicaStatus = null;\n          long numDocs = -1L;\n          \n          ZkCoreNodeProps replicaCoreProps = new ZkCoreNodeProps(r);\n          String coreUrl = replicaCoreProps.getCoreUrl();\n          boolean isLeader = coreUrl.equals(leaderUrl);\n\n          // if replica's node is not live, it's status is DOWN\n          String nodeName = replicaCoreProps.getNodeName();\n          if (nodeName == null || !liveNodes.contains(nodeName)) {\n            replicaStatus = ZkStateReader.DOWN;\n          } else {\n            // query this replica directly to get doc count and assess health\n            HttpSolrServer solr = new HttpSolrServer(coreUrl);\n            String solrUrl = solr.getBaseURL();\n            q = new SolrQuery(\"*:*\");\n            q.setRows(0);\n            q.set(\"distrib\", \"false\");\n            try {\n              qr = solr.query(q);\n              numDocs = qr.getResults().getNumFound();\n\n              int lastSlash = solrUrl.lastIndexOf('/');\n              String systemInfoUrl = solrUrl.substring(0,lastSlash)+\"/admin/info/system\";\n              Map<String,Object> info = getJson(solr.getHttpClient(), systemInfoUrl, 2);\n              uptime = uptime(asLong(\"/jvm/jmx/upTimeMS\", info));\n              String usedMemory = asString(\"/jvm/memory/used\", info);\n              String totalMemory = asString(\"/jvm/memory/total\", info);\n              memory = usedMemory+\" of \"+totalMemory;\n\n              // if we get here, we can trust the state\n              replicaStatus = replicaCoreProps.getState();\n            } catch (Exception exc) {\n              log.error(\"ERROR: \" + exc + \" when trying to reach: \" + solrUrl);\n\n              if (checkCommunicationError(exc)) {\n                replicaStatus = \"down\";\n              } else {\n                replicaStatus = \"error: \"+exc;\n              }\n            } finally {\n              solr.shutdown();\n            }\n          }\n\n          replicaList.add(new ReplicaHealth(shardName, r.getName(), coreUrl, \n              replicaStatus, numDocs, isLeader, uptime, memory));          \n        }\n        \n        ShardHealth shardHealth = new ShardHealth(shardName, replicaList);        \n        if (ShardState.healthy != shardHealth.getShardState())\n          collectionIsHealthy = false; // at least one shard is un-healthy\n        \n        shardList.add(shardHealth.asMap());        \n      }\n      \n      \n      Map<String,Object> report = new LinkedHashMap<String,Object>();\n      report.put(\"collection\", collection);\n      report.put(\"status\", collectionIsHealthy ? \"healthy\" : \"degraded\");\n      if (collErr != null) {\n        report.put(\"error\", collErr);\n      }\n      report.put(\"numDocs\", docCount);\n      report.put(\"numShards\", slices.size());      \n      report.put(\"shards\", shardList);\n                        \n      CharArr arr = new CharArr();\n      new JSONWriter(arr, 2).write(report);\n      System.out.println(arr.toString());\n    }\n\n","sourceOld":"    @Override\n    protected void runCloudTool(CloudSolrServer cloudSolrServer, CommandLine cli) throws Exception {\n      \n      String collection = cli.getOptionValue(\"collection\");\n      if (collection == null)\n        throw new IllegalArgumentException(\"Must provide a collection to run a healthcheck against!\");\n      \n      log.info(\"Running healthcheck for \"+collection);\n      \n      ZkStateReader zkStateReader = cloudSolrServer.getZkStateReader();\n      Collection<Slice> slices = zkStateReader.getClusterState().getSlices(collection);\n      if (slices == null)\n        throw new IllegalArgumentException(\"Collection \"+collection+\" not found!\");\n      \n      SolrQuery q = new SolrQuery(\"*:*\");\n      q.setRows(0);      \n      QueryResponse qr = cloudSolrServer.query(q);\n      String collErr = null;\n      long docCount = -1;\n      try {\n        docCount = qr.getResults().getNumFound();\n      } catch (Exception exc) {\n        collErr = String.valueOf(exc);\n      }\n      \n      List<Object> shardList = new ArrayList<>();\n      boolean collectionIsHealthy = (docCount != -1);\n      \n      for (Slice slice : slices) {\n        String shardName = slice.getName();\n        // since we're reporting health of this shard, there's no guarantee of a leader\n        String leaderUrl = null;\n        try {\n          leaderUrl = zkStateReader.getLeaderUrl(collection, shardName, 1000);\n        } catch (Exception exc) {\n          log.warn(\"Failed to get leader for shard \"+shardName+\" due to: \"+exc);\n        }\n        \n        List<ReplicaHealth> replicaList = new ArrayList<ReplicaHealth>();        \n        for (Replica r : slice.getReplicas()) {\n          \n          String uptime = null;\n          String memory = null;\n          String replicaStatus = null;\n          long numDocs = -1L;\n          \n          ZkCoreNodeProps replicaCoreProps = new ZkCoreNodeProps(r);\n          String coreUrl = replicaCoreProps.getCoreUrl();\n          boolean isLeader = coreUrl.equals(leaderUrl);\n          \n          // query this replica directly to get doc count and assess health\n          HttpSolrServer solr = new HttpSolrServer(coreUrl);\n          String solrUrl = solr.getBaseURL();\n          q = new SolrQuery(\"*:*\");\n          q.setRows(0);\n          q.set(\"distrib\", \"false\");          \n          try {\n            qr = solr.query(q);\n            numDocs = qr.getResults().getNumFound();\n            \n            int lastSlash = solrUrl.lastIndexOf('/');            \n            String systemInfoUrl = solrUrl.substring(0,lastSlash)+\"/admin/info/system\";\n            Map<String,Object> info = getJson(solr.getHttpClient(), systemInfoUrl, 2);\n            uptime = uptime(asLong(\"/jvm/jmx/upTimeMS\", info));            \n            String usedMemory = asString(\"/jvm/memory/used\", info);\n            String totalMemory = asString(\"/jvm/memory/total\", info);\n            memory = usedMemory+\" of \"+totalMemory;\n            \n            // if we get here, we can trust the state\n            replicaStatus = replicaCoreProps.getState();                                                                      \n          } catch (Exception exc) {\n            log.error(\"ERROR: \" + exc + \" when trying to reach: \" + solrUrl);\n\n            if (checkCommunicationError(exc)) {\n              replicaStatus = \"down\";\n            } else {\n              replicaStatus = \"error: \"+exc;\n            }            \n          } finally {\n            solr.shutdown();\n          }\n          \n          replicaList.add(new ReplicaHealth(shardName, r.getName(), coreUrl, \n              replicaStatus, numDocs, isLeader, uptime, memory));          \n        }\n        \n        ShardHealth shardHealth = new ShardHealth(shardName, replicaList);        \n        if (ShardState.healthy != shardHealth.getShardState())\n          collectionIsHealthy = false; // at least one shard is un-healthy\n        \n        shardList.add(shardHealth.asMap());        \n      }\n      \n      \n      Map<String,Object> report = new LinkedHashMap<String,Object>();\n      report.put(\"collection\", collection);\n      report.put(\"status\", collectionIsHealthy ? \"healthy\" : \"degraded\");\n      if (collErr != null) {\n        report.put(\"error\", collErr);\n      }\n      report.put(\"numDocs\", docCount);\n      report.put(\"numShards\", slices.size());      \n      report.put(\"shards\", shardList);\n                        \n      CharArr arr = new CharArr();\n      new JSONWriter(arr, 2).write(report);\n      System.out.println(arr.toString());\n    }\n\n","bugFix":["709714c6ee47950678dd2d2ef4e0473886909226"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"209c0259a9b7087b2111411ec790d6557ef86307","date":1419393649,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/SolrCLI.HealthcheckTool#runCloudTool(CloudSolrServer,CommandLine).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/SolrCLI.HealthcheckTool#runCloudTool(CloudSolrServer,CommandLine).mjava","sourceNew":"    @Override\n    protected int runCloudTool(CloudSolrServer cloudSolrServer, CommandLine cli) throws Exception {\n      \n      String collection = cli.getOptionValue(\"collection\");\n      if (collection == null)\n        throw new IllegalArgumentException(\"Must provide a collection to run a healthcheck against!\");\n      \n      log.info(\"Running healthcheck for \"+collection);\n      \n      ZkStateReader zkStateReader = cloudSolrServer.getZkStateReader();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      Collection<Slice> slices = clusterState.getSlices(collection);\n      if (slices == null)\n        throw new IllegalArgumentException(\"Collection \"+collection+\" not found!\");\n      \n      SolrQuery q = new SolrQuery(\"*:*\");\n      q.setRows(0);      \n      QueryResponse qr = cloudSolrServer.query(q);\n      String collErr = null;\n      long docCount = -1;\n      try {\n        docCount = qr.getResults().getNumFound();\n      } catch (Exception exc) {\n        collErr = String.valueOf(exc);\n      }\n      \n      List<Object> shardList = new ArrayList<>();\n      boolean collectionIsHealthy = (docCount != -1);\n      \n      for (Slice slice : slices) {\n        String shardName = slice.getName();\n        // since we're reporting health of this shard, there's no guarantee of a leader\n        String leaderUrl = null;\n        try {\n          leaderUrl = zkStateReader.getLeaderUrl(collection, shardName, 1000);\n        } catch (Exception exc) {\n          log.warn(\"Failed to get leader for shard \"+shardName+\" due to: \"+exc);\n        }\n        \n        List<ReplicaHealth> replicaList = new ArrayList<ReplicaHealth>();        \n        for (Replica r : slice.getReplicas()) {\n          \n          String uptime = null;\n          String memory = null;\n          String replicaStatus = null;\n          long numDocs = -1L;\n          \n          ZkCoreNodeProps replicaCoreProps = new ZkCoreNodeProps(r);\n          String coreUrl = replicaCoreProps.getCoreUrl();\n          boolean isLeader = coreUrl.equals(leaderUrl);\n\n          // if replica's node is not live, it's status is DOWN\n          String nodeName = replicaCoreProps.getNodeName();\n          if (nodeName == null || !liveNodes.contains(nodeName)) {\n            replicaStatus = ZkStateReader.DOWN;\n          } else {\n            // query this replica directly to get doc count and assess health\n            HttpSolrServer solr = new HttpSolrServer(coreUrl);\n            String solrUrl = solr.getBaseURL();\n            q = new SolrQuery(\"*:*\");\n            q.setRows(0);\n            q.set(\"distrib\", \"false\");\n            try {\n              qr = solr.query(q);\n              numDocs = qr.getResults().getNumFound();\n\n              int lastSlash = solrUrl.lastIndexOf('/');\n              String systemInfoUrl = solrUrl.substring(0,lastSlash)+\"/admin/info/system\";\n              Map<String,Object> info = getJson(solr.getHttpClient(), systemInfoUrl, 2);\n              uptime = uptime(asLong(\"/jvm/jmx/upTimeMS\", info));\n              String usedMemory = asString(\"/jvm/memory/used\", info);\n              String totalMemory = asString(\"/jvm/memory/total\", info);\n              memory = usedMemory+\" of \"+totalMemory;\n\n              // if we get here, we can trust the state\n              replicaStatus = replicaCoreProps.getState();\n            } catch (Exception exc) {\n              log.error(\"ERROR: \" + exc + \" when trying to reach: \" + solrUrl);\n\n              if (checkCommunicationError(exc)) {\n                replicaStatus = \"down\";\n              } else {\n                replicaStatus = \"error: \"+exc;\n              }\n            } finally {\n              solr.shutdown();\n            }\n          }\n\n          replicaList.add(new ReplicaHealth(shardName, r.getName(), coreUrl, \n              replicaStatus, numDocs, isLeader, uptime, memory));          \n        }\n        \n        ShardHealth shardHealth = new ShardHealth(shardName, replicaList);        \n        if (ShardState.healthy != shardHealth.getShardState())\n          collectionIsHealthy = false; // at least one shard is un-healthy\n        \n        shardList.add(shardHealth.asMap());        \n      }\n      \n      \n      Map<String,Object> report = new LinkedHashMap<String,Object>();\n      report.put(\"collection\", collection);\n      report.put(\"status\", collectionIsHealthy ? \"healthy\" : \"degraded\");\n      if (collErr != null) {\n        report.put(\"error\", collErr);\n      }\n      report.put(\"numDocs\", docCount);\n      report.put(\"numShards\", slices.size());      \n      report.put(\"shards\", shardList);\n                        \n      CharArr arr = new CharArr();\n      new JSONWriter(arr, 2).write(report);\n      System.out.println(arr.toString());\n\n      return 0;\n    }\n\n","sourceOld":"    @Override\n    protected void runCloudTool(CloudSolrServer cloudSolrServer, CommandLine cli) throws Exception {\n      \n      String collection = cli.getOptionValue(\"collection\");\n      if (collection == null)\n        throw new IllegalArgumentException(\"Must provide a collection to run a healthcheck against!\");\n      \n      log.info(\"Running healthcheck for \"+collection);\n      \n      ZkStateReader zkStateReader = cloudSolrServer.getZkStateReader();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      Collection<Slice> slices = clusterState.getSlices(collection);\n      if (slices == null)\n        throw new IllegalArgumentException(\"Collection \"+collection+\" not found!\");\n      \n      SolrQuery q = new SolrQuery(\"*:*\");\n      q.setRows(0);      \n      QueryResponse qr = cloudSolrServer.query(q);\n      String collErr = null;\n      long docCount = -1;\n      try {\n        docCount = qr.getResults().getNumFound();\n      } catch (Exception exc) {\n        collErr = String.valueOf(exc);\n      }\n      \n      List<Object> shardList = new ArrayList<>();\n      boolean collectionIsHealthy = (docCount != -1);\n      \n      for (Slice slice : slices) {\n        String shardName = slice.getName();\n        // since we're reporting health of this shard, there's no guarantee of a leader\n        String leaderUrl = null;\n        try {\n          leaderUrl = zkStateReader.getLeaderUrl(collection, shardName, 1000);\n        } catch (Exception exc) {\n          log.warn(\"Failed to get leader for shard \"+shardName+\" due to: \"+exc);\n        }\n        \n        List<ReplicaHealth> replicaList = new ArrayList<ReplicaHealth>();        \n        for (Replica r : slice.getReplicas()) {\n          \n          String uptime = null;\n          String memory = null;\n          String replicaStatus = null;\n          long numDocs = -1L;\n          \n          ZkCoreNodeProps replicaCoreProps = new ZkCoreNodeProps(r);\n          String coreUrl = replicaCoreProps.getCoreUrl();\n          boolean isLeader = coreUrl.equals(leaderUrl);\n\n          // if replica's node is not live, it's status is DOWN\n          String nodeName = replicaCoreProps.getNodeName();\n          if (nodeName == null || !liveNodes.contains(nodeName)) {\n            replicaStatus = ZkStateReader.DOWN;\n          } else {\n            // query this replica directly to get doc count and assess health\n            HttpSolrServer solr = new HttpSolrServer(coreUrl);\n            String solrUrl = solr.getBaseURL();\n            q = new SolrQuery(\"*:*\");\n            q.setRows(0);\n            q.set(\"distrib\", \"false\");\n            try {\n              qr = solr.query(q);\n              numDocs = qr.getResults().getNumFound();\n\n              int lastSlash = solrUrl.lastIndexOf('/');\n              String systemInfoUrl = solrUrl.substring(0,lastSlash)+\"/admin/info/system\";\n              Map<String,Object> info = getJson(solr.getHttpClient(), systemInfoUrl, 2);\n              uptime = uptime(asLong(\"/jvm/jmx/upTimeMS\", info));\n              String usedMemory = asString(\"/jvm/memory/used\", info);\n              String totalMemory = asString(\"/jvm/memory/total\", info);\n              memory = usedMemory+\" of \"+totalMemory;\n\n              // if we get here, we can trust the state\n              replicaStatus = replicaCoreProps.getState();\n            } catch (Exception exc) {\n              log.error(\"ERROR: \" + exc + \" when trying to reach: \" + solrUrl);\n\n              if (checkCommunicationError(exc)) {\n                replicaStatus = \"down\";\n              } else {\n                replicaStatus = \"error: \"+exc;\n              }\n            } finally {\n              solr.shutdown();\n            }\n          }\n\n          replicaList.add(new ReplicaHealth(shardName, r.getName(), coreUrl, \n              replicaStatus, numDocs, isLeader, uptime, memory));          \n        }\n        \n        ShardHealth shardHealth = new ShardHealth(shardName, replicaList);        \n        if (ShardState.healthy != shardHealth.getShardState())\n          collectionIsHealthy = false; // at least one shard is un-healthy\n        \n        shardList.add(shardHealth.asMap());        \n      }\n      \n      \n      Map<String,Object> report = new LinkedHashMap<String,Object>();\n      report.put(\"collection\", collection);\n      report.put(\"status\", collectionIsHealthy ? \"healthy\" : \"degraded\");\n      if (collErr != null) {\n        report.put(\"error\", collErr);\n      }\n      report.put(\"numDocs\", docCount);\n      report.put(\"numShards\", slices.size());      \n      report.put(\"shards\", shardList);\n                        \n      CharArr arr = new CharArr();\n      new JSONWriter(arr, 2).write(report);\n      System.out.println(arr.toString());\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1","date":1419400138,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/SolrCLI.HealthcheckTool#runCloudTool(CloudSolrServer,CommandLine).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/SolrCLI.HealthcheckTool#runCloudTool(CloudSolrServer,CommandLine).mjava","sourceNew":"    @Override\n    protected int runCloudTool(CloudSolrServer cloudSolrServer, CommandLine cli) throws Exception {\n      \n      String collection = cli.getOptionValue(\"collection\");\n      if (collection == null)\n        throw new IllegalArgumentException(\"Must provide a collection to run a healthcheck against!\");\n      \n      log.info(\"Running healthcheck for \"+collection);\n      \n      ZkStateReader zkStateReader = cloudSolrServer.getZkStateReader();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      Collection<Slice> slices = clusterState.getSlices(collection);\n      if (slices == null)\n        throw new IllegalArgumentException(\"Collection \"+collection+\" not found!\");\n      \n      SolrQuery q = new SolrQuery(\"*:*\");\n      q.setRows(0);      \n      QueryResponse qr = cloudSolrServer.query(q);\n      String collErr = null;\n      long docCount = -1;\n      try {\n        docCount = qr.getResults().getNumFound();\n      } catch (Exception exc) {\n        collErr = String.valueOf(exc);\n      }\n      \n      List<Object> shardList = new ArrayList<>();\n      boolean collectionIsHealthy = (docCount != -1);\n      \n      for (Slice slice : slices) {\n        String shardName = slice.getName();\n        // since we're reporting health of this shard, there's no guarantee of a leader\n        String leaderUrl = null;\n        try {\n          leaderUrl = zkStateReader.getLeaderUrl(collection, shardName, 1000);\n        } catch (Exception exc) {\n          log.warn(\"Failed to get leader for shard \"+shardName+\" due to: \"+exc);\n        }\n        \n        List<ReplicaHealth> replicaList = new ArrayList<ReplicaHealth>();        \n        for (Replica r : slice.getReplicas()) {\n          \n          String uptime = null;\n          String memory = null;\n          String replicaStatus = null;\n          long numDocs = -1L;\n          \n          ZkCoreNodeProps replicaCoreProps = new ZkCoreNodeProps(r);\n          String coreUrl = replicaCoreProps.getCoreUrl();\n          boolean isLeader = coreUrl.equals(leaderUrl);\n\n          // if replica's node is not live, its status is DOWN\n          String nodeName = replicaCoreProps.getNodeName();\n          if (nodeName == null || !liveNodes.contains(nodeName)) {\n            replicaStatus = ZkStateReader.DOWN;\n          } else {\n            // query this replica directly to get doc count and assess health\n            HttpSolrServer solr = new HttpSolrServer(coreUrl);\n            String solrUrl = solr.getBaseURL();\n            q = new SolrQuery(\"*:*\");\n            q.setRows(0);\n            q.set(\"distrib\", \"false\");\n            try {\n              qr = solr.query(q);\n              numDocs = qr.getResults().getNumFound();\n\n              int lastSlash = solrUrl.lastIndexOf('/');\n              String systemInfoUrl = solrUrl.substring(0,lastSlash)+\"/admin/info/system\";\n              Map<String,Object> info = getJson(solr.getHttpClient(), systemInfoUrl, 2);\n              uptime = uptime(asLong(\"/jvm/jmx/upTimeMS\", info));\n              String usedMemory = asString(\"/jvm/memory/used\", info);\n              String totalMemory = asString(\"/jvm/memory/total\", info);\n              memory = usedMemory+\" of \"+totalMemory;\n\n              // if we get here, we can trust the state\n              replicaStatus = replicaCoreProps.getState();\n            } catch (Exception exc) {\n              log.error(\"ERROR: \" + exc + \" when trying to reach: \" + solrUrl);\n\n              if (checkCommunicationError(exc)) {\n                replicaStatus = \"down\";\n              } else {\n                replicaStatus = \"error: \"+exc;\n              }\n            } finally {\n              solr.shutdown();\n            }\n          }\n\n          replicaList.add(new ReplicaHealth(shardName, r.getName(), coreUrl, \n              replicaStatus, numDocs, isLeader, uptime, memory));          \n        }\n        \n        ShardHealth shardHealth = new ShardHealth(shardName, replicaList);        \n        if (ShardState.healthy != shardHealth.getShardState())\n          collectionIsHealthy = false; // at least one shard is un-healthy\n        \n        shardList.add(shardHealth.asMap());        \n      }\n      \n      \n      Map<String,Object> report = new LinkedHashMap<String,Object>();\n      report.put(\"collection\", collection);\n      report.put(\"status\", collectionIsHealthy ? \"healthy\" : \"degraded\");\n      if (collErr != null) {\n        report.put(\"error\", collErr);\n      }\n      report.put(\"numDocs\", docCount);\n      report.put(\"numShards\", slices.size());      \n      report.put(\"shards\", shardList);\n                        \n      CharArr arr = new CharArr();\n      new JSONWriter(arr, 2).write(report);\n      System.out.println(arr.toString());\n\n      return 0;\n    }\n\n","sourceOld":"    @Override\n    protected int runCloudTool(CloudSolrServer cloudSolrServer, CommandLine cli) throws Exception {\n      \n      String collection = cli.getOptionValue(\"collection\");\n      if (collection == null)\n        throw new IllegalArgumentException(\"Must provide a collection to run a healthcheck against!\");\n      \n      log.info(\"Running healthcheck for \"+collection);\n      \n      ZkStateReader zkStateReader = cloudSolrServer.getZkStateReader();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      Collection<Slice> slices = clusterState.getSlices(collection);\n      if (slices == null)\n        throw new IllegalArgumentException(\"Collection \"+collection+\" not found!\");\n      \n      SolrQuery q = new SolrQuery(\"*:*\");\n      q.setRows(0);      \n      QueryResponse qr = cloudSolrServer.query(q);\n      String collErr = null;\n      long docCount = -1;\n      try {\n        docCount = qr.getResults().getNumFound();\n      } catch (Exception exc) {\n        collErr = String.valueOf(exc);\n      }\n      \n      List<Object> shardList = new ArrayList<>();\n      boolean collectionIsHealthy = (docCount != -1);\n      \n      for (Slice slice : slices) {\n        String shardName = slice.getName();\n        // since we're reporting health of this shard, there's no guarantee of a leader\n        String leaderUrl = null;\n        try {\n          leaderUrl = zkStateReader.getLeaderUrl(collection, shardName, 1000);\n        } catch (Exception exc) {\n          log.warn(\"Failed to get leader for shard \"+shardName+\" due to: \"+exc);\n        }\n        \n        List<ReplicaHealth> replicaList = new ArrayList<ReplicaHealth>();        \n        for (Replica r : slice.getReplicas()) {\n          \n          String uptime = null;\n          String memory = null;\n          String replicaStatus = null;\n          long numDocs = -1L;\n          \n          ZkCoreNodeProps replicaCoreProps = new ZkCoreNodeProps(r);\n          String coreUrl = replicaCoreProps.getCoreUrl();\n          boolean isLeader = coreUrl.equals(leaderUrl);\n\n          // if replica's node is not live, it's status is DOWN\n          String nodeName = replicaCoreProps.getNodeName();\n          if (nodeName == null || !liveNodes.contains(nodeName)) {\n            replicaStatus = ZkStateReader.DOWN;\n          } else {\n            // query this replica directly to get doc count and assess health\n            HttpSolrServer solr = new HttpSolrServer(coreUrl);\n            String solrUrl = solr.getBaseURL();\n            q = new SolrQuery(\"*:*\");\n            q.setRows(0);\n            q.set(\"distrib\", \"false\");\n            try {\n              qr = solr.query(q);\n              numDocs = qr.getResults().getNumFound();\n\n              int lastSlash = solrUrl.lastIndexOf('/');\n              String systemInfoUrl = solrUrl.substring(0,lastSlash)+\"/admin/info/system\";\n              Map<String,Object> info = getJson(solr.getHttpClient(), systemInfoUrl, 2);\n              uptime = uptime(asLong(\"/jvm/jmx/upTimeMS\", info));\n              String usedMemory = asString(\"/jvm/memory/used\", info);\n              String totalMemory = asString(\"/jvm/memory/total\", info);\n              memory = usedMemory+\" of \"+totalMemory;\n\n              // if we get here, we can trust the state\n              replicaStatus = replicaCoreProps.getState();\n            } catch (Exception exc) {\n              log.error(\"ERROR: \" + exc + \" when trying to reach: \" + solrUrl);\n\n              if (checkCommunicationError(exc)) {\n                replicaStatus = \"down\";\n              } else {\n                replicaStatus = \"error: \"+exc;\n              }\n            } finally {\n              solr.shutdown();\n            }\n          }\n\n          replicaList.add(new ReplicaHealth(shardName, r.getName(), coreUrl, \n              replicaStatus, numDocs, isLeader, uptime, memory));          \n        }\n        \n        ShardHealth shardHealth = new ShardHealth(shardName, replicaList);        \n        if (ShardState.healthy != shardHealth.getShardState())\n          collectionIsHealthy = false; // at least one shard is un-healthy\n        \n        shardList.add(shardHealth.asMap());        \n      }\n      \n      \n      Map<String,Object> report = new LinkedHashMap<String,Object>();\n      report.put(\"collection\", collection);\n      report.put(\"status\", collectionIsHealthy ? \"healthy\" : \"degraded\");\n      if (collErr != null) {\n        report.put(\"error\", collErr);\n      }\n      report.put(\"numDocs\", docCount);\n      report.put(\"numShards\", slices.size());      \n      report.put(\"shards\", shardList);\n                        \n      CharArr arr = new CharArr();\n      new JSONWriter(arr, 2).write(report);\n      System.out.println(arr.toString());\n\n      return 0;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bafca15d8e408346a67f4282ad1143b88023893b","date":1420034748,"type":5,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/SolrCLI.HealthcheckTool#runCloudTool(CloudSolrClient,CommandLine).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/SolrCLI.HealthcheckTool#runCloudTool(CloudSolrServer,CommandLine).mjava","sourceNew":"    @Override\n    protected int runCloudTool(CloudSolrClient cloudSolrClient, CommandLine cli) throws Exception {\n      \n      String collection = cli.getOptionValue(\"collection\");\n      if (collection == null)\n        throw new IllegalArgumentException(\"Must provide a collection to run a healthcheck against!\");\n      \n      log.info(\"Running healthcheck for \"+collection);\n      \n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      Collection<Slice> slices = clusterState.getSlices(collection);\n      if (slices == null)\n        throw new IllegalArgumentException(\"Collection \"+collection+\" not found!\");\n      \n      SolrQuery q = new SolrQuery(\"*:*\");\n      q.setRows(0);      \n      QueryResponse qr = cloudSolrClient.query(q);\n      String collErr = null;\n      long docCount = -1;\n      try {\n        docCount = qr.getResults().getNumFound();\n      } catch (Exception exc) {\n        collErr = String.valueOf(exc);\n      }\n      \n      List<Object> shardList = new ArrayList<>();\n      boolean collectionIsHealthy = (docCount != -1);\n      \n      for (Slice slice : slices) {\n        String shardName = slice.getName();\n        // since we're reporting health of this shard, there's no guarantee of a leader\n        String leaderUrl = null;\n        try {\n          leaderUrl = zkStateReader.getLeaderUrl(collection, shardName, 1000);\n        } catch (Exception exc) {\n          log.warn(\"Failed to get leader for shard \"+shardName+\" due to: \"+exc);\n        }\n        \n        List<ReplicaHealth> replicaList = new ArrayList<ReplicaHealth>();        \n        for (Replica r : slice.getReplicas()) {\n          \n          String uptime = null;\n          String memory = null;\n          String replicaStatus = null;\n          long numDocs = -1L;\n          \n          ZkCoreNodeProps replicaCoreProps = new ZkCoreNodeProps(r);\n          String coreUrl = replicaCoreProps.getCoreUrl();\n          boolean isLeader = coreUrl.equals(leaderUrl);\n\n          // if replica's node is not live, its status is DOWN\n          String nodeName = replicaCoreProps.getNodeName();\n          if (nodeName == null || !liveNodes.contains(nodeName)) {\n            replicaStatus = ZkStateReader.DOWN;\n          } else {\n            // query this replica directly to get doc count and assess health\n            HttpSolrClient solr = new HttpSolrClient(coreUrl);\n            String solrUrl = solr.getBaseURL();\n            q = new SolrQuery(\"*:*\");\n            q.setRows(0);\n            q.set(\"distrib\", \"false\");\n            try {\n              qr = solr.query(q);\n              numDocs = qr.getResults().getNumFound();\n\n              int lastSlash = solrUrl.lastIndexOf('/');\n              String systemInfoUrl = solrUrl.substring(0,lastSlash)+\"/admin/info/system\";\n              Map<String,Object> info = getJson(solr.getHttpClient(), systemInfoUrl, 2);\n              uptime = uptime(asLong(\"/jvm/jmx/upTimeMS\", info));\n              String usedMemory = asString(\"/jvm/memory/used\", info);\n              String totalMemory = asString(\"/jvm/memory/total\", info);\n              memory = usedMemory+\" of \"+totalMemory;\n\n              // if we get here, we can trust the state\n              replicaStatus = replicaCoreProps.getState();\n            } catch (Exception exc) {\n              log.error(\"ERROR: \" + exc + \" when trying to reach: \" + solrUrl);\n\n              if (checkCommunicationError(exc)) {\n                replicaStatus = \"down\";\n              } else {\n                replicaStatus = \"error: \"+exc;\n              }\n            } finally {\n              solr.shutdown();\n            }\n          }\n\n          replicaList.add(new ReplicaHealth(shardName, r.getName(), coreUrl, \n              replicaStatus, numDocs, isLeader, uptime, memory));          \n        }\n        \n        ShardHealth shardHealth = new ShardHealth(shardName, replicaList);        \n        if (ShardState.healthy != shardHealth.getShardState())\n          collectionIsHealthy = false; // at least one shard is un-healthy\n        \n        shardList.add(shardHealth.asMap());        \n      }\n      \n      \n      Map<String,Object> report = new LinkedHashMap<String,Object>();\n      report.put(\"collection\", collection);\n      report.put(\"status\", collectionIsHealthy ? \"healthy\" : \"degraded\");\n      if (collErr != null) {\n        report.put(\"error\", collErr);\n      }\n      report.put(\"numDocs\", docCount);\n      report.put(\"numShards\", slices.size());      \n      report.put(\"shards\", shardList);\n                        \n      CharArr arr = new CharArr();\n      new JSONWriter(arr, 2).write(report);\n      System.out.println(arr.toString());\n\n      return 0;\n    }\n\n","sourceOld":"    @Override\n    protected int runCloudTool(CloudSolrServer cloudSolrServer, CommandLine cli) throws Exception {\n      \n      String collection = cli.getOptionValue(\"collection\");\n      if (collection == null)\n        throw new IllegalArgumentException(\"Must provide a collection to run a healthcheck against!\");\n      \n      log.info(\"Running healthcheck for \"+collection);\n      \n      ZkStateReader zkStateReader = cloudSolrServer.getZkStateReader();\n\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      Collection<Slice> slices = clusterState.getSlices(collection);\n      if (slices == null)\n        throw new IllegalArgumentException(\"Collection \"+collection+\" not found!\");\n      \n      SolrQuery q = new SolrQuery(\"*:*\");\n      q.setRows(0);      \n      QueryResponse qr = cloudSolrServer.query(q);\n      String collErr = null;\n      long docCount = -1;\n      try {\n        docCount = qr.getResults().getNumFound();\n      } catch (Exception exc) {\n        collErr = String.valueOf(exc);\n      }\n      \n      List<Object> shardList = new ArrayList<>();\n      boolean collectionIsHealthy = (docCount != -1);\n      \n      for (Slice slice : slices) {\n        String shardName = slice.getName();\n        // since we're reporting health of this shard, there's no guarantee of a leader\n        String leaderUrl = null;\n        try {\n          leaderUrl = zkStateReader.getLeaderUrl(collection, shardName, 1000);\n        } catch (Exception exc) {\n          log.warn(\"Failed to get leader for shard \"+shardName+\" due to: \"+exc);\n        }\n        \n        List<ReplicaHealth> replicaList = new ArrayList<ReplicaHealth>();        \n        for (Replica r : slice.getReplicas()) {\n          \n          String uptime = null;\n          String memory = null;\n          String replicaStatus = null;\n          long numDocs = -1L;\n          \n          ZkCoreNodeProps replicaCoreProps = new ZkCoreNodeProps(r);\n          String coreUrl = replicaCoreProps.getCoreUrl();\n          boolean isLeader = coreUrl.equals(leaderUrl);\n\n          // if replica's node is not live, its status is DOWN\n          String nodeName = replicaCoreProps.getNodeName();\n          if (nodeName == null || !liveNodes.contains(nodeName)) {\n            replicaStatus = ZkStateReader.DOWN;\n          } else {\n            // query this replica directly to get doc count and assess health\n            HttpSolrServer solr = new HttpSolrServer(coreUrl);\n            String solrUrl = solr.getBaseURL();\n            q = new SolrQuery(\"*:*\");\n            q.setRows(0);\n            q.set(\"distrib\", \"false\");\n            try {\n              qr = solr.query(q);\n              numDocs = qr.getResults().getNumFound();\n\n              int lastSlash = solrUrl.lastIndexOf('/');\n              String systemInfoUrl = solrUrl.substring(0,lastSlash)+\"/admin/info/system\";\n              Map<String,Object> info = getJson(solr.getHttpClient(), systemInfoUrl, 2);\n              uptime = uptime(asLong(\"/jvm/jmx/upTimeMS\", info));\n              String usedMemory = asString(\"/jvm/memory/used\", info);\n              String totalMemory = asString(\"/jvm/memory/total\", info);\n              memory = usedMemory+\" of \"+totalMemory;\n\n              // if we get here, we can trust the state\n              replicaStatus = replicaCoreProps.getState();\n            } catch (Exception exc) {\n              log.error(\"ERROR: \" + exc + \" when trying to reach: \" + solrUrl);\n\n              if (checkCommunicationError(exc)) {\n                replicaStatus = \"down\";\n              } else {\n                replicaStatus = \"error: \"+exc;\n              }\n            } finally {\n              solr.shutdown();\n            }\n          }\n\n          replicaList.add(new ReplicaHealth(shardName, r.getName(), coreUrl, \n              replicaStatus, numDocs, isLeader, uptime, memory));          \n        }\n        \n        ShardHealth shardHealth = new ShardHealth(shardName, replicaList);        \n        if (ShardState.healthy != shardHealth.getShardState())\n          collectionIsHealthy = false; // at least one shard is un-healthy\n        \n        shardList.add(shardHealth.asMap());        \n      }\n      \n      \n      Map<String,Object> report = new LinkedHashMap<String,Object>();\n      report.put(\"collection\", collection);\n      report.put(\"status\", collectionIsHealthy ? \"healthy\" : \"degraded\");\n      if (collErr != null) {\n        report.put(\"error\", collErr);\n      }\n      report.put(\"numDocs\", docCount);\n      report.put(\"numShards\", slices.size());      \n      report.put(\"shards\", shardList);\n                        \n      CharArr arr = new CharArr();\n      new JSONWriter(arr, 2).write(report);\n      System.out.println(arr.toString());\n\n      return 0;\n    }\n\n","bugFix":null,"bugIntro":["344b0840364d990b29b97467bfcc766ff8325d11"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"abbeeaace38fe60785787cbd76514bf02f2c8af6":["709714c6ee47950678dd2d2ef4e0473886909226"],"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1":["209c0259a9b7087b2111411ec790d6557ef86307"],"709714c6ee47950678dd2d2ef4e0473886909226":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"209c0259a9b7087b2111411ec790d6557ef86307":["abbeeaace38fe60785787cbd76514bf02f2c8af6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"bafca15d8e408346a67f4282ad1143b88023893b":["8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bafca15d8e408346a67f4282ad1143b88023893b"]},"commit2Childs":{"abbeeaace38fe60785787cbd76514bf02f2c8af6":["209c0259a9b7087b2111411ec790d6557ef86307"],"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1":["bafca15d8e408346a67f4282ad1143b88023893b"],"709714c6ee47950678dd2d2ef4e0473886909226":["abbeeaace38fe60785787cbd76514bf02f2c8af6"],"209c0259a9b7087b2111411ec790d6557ef86307":["8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["709714c6ee47950678dd2d2ef4e0473886909226"],"bafca15d8e408346a67f4282ad1143b88023893b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}