{"path":"lucene/analysis/nori/src/tools/java/org/apache/lucene/analysis/ko/util/BinaryDictionaryWriter#put(String[]).mjava","commits":[{"id":"8493925b2e70246f0961df584c01a8c2e61ee52f","date":1523611602,"type":0,"author":"Jim Ferenczi","isMerge":false,"pathNew":"lucene/analysis/nori/src/tools/java/org/apache/lucene/analysis/ko/util/BinaryDictionaryWriter#put(String[]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * put the entry in map\n   *\n   * mecab-ko-dic features\n   *\n   * 0   - surface\n   * 1   - left cost\n   * 2   - right cost\n   * 3   - word cost\n   * 4   - part of speech0+part of speech1+...\n   * 5   - semantic class\n   * 6   - T if the last character of the surface form has a coda, F otherwise\n   * 7   - reading\n   * 8   - POS type (*, Compound, Inflect, Preanalysis)\n   * 9   - left POS\n   * 10  - right POS\n   * 11  - expression\n   *\n   * @return current position of buffer, which will be wordId of next entry\n   */\n  public int put(String[] entry) {\n    short leftId = Short.parseShort(entry[1]);\n    short rightId = Short.parseShort(entry[2]);\n    short wordCost = Short.parseShort(entry[3]);\n\n    final POS.Type posType = POS.resolveType(entry[8]);\n    final POS.Tag leftPOS;\n    final POS.Tag rightPOS;\n    if (posType == POS.Type.MORPHEME || posType == POS.Type.COMPOUND || entry[9].equals(\"*\")) {\n      leftPOS = POS.resolveTag(entry[4]);\n      assert (entry[9].equals(\"*\") && entry[10].equals(\"*\"));\n      rightPOS = leftPOS;\n    } else {\n      leftPOS = POS.resolveTag(entry[9]);\n      rightPOS = POS.resolveTag(entry[10]);\n    }\n    final String reading = entry[7].equals(\"*\") ? \"\" : entry[0].equals(entry[7]) ? \"\" : entry[7];\n    final String expression = entry[11].equals(\"*\") ? \"\" : entry[11];\n\n    // extend buffer if necessary\n    int left = buffer.remaining();\n    // worst case, 3 short + 4 bytes and features (all as utf-16)\n    int worstCase = 9 + 2*(expression.length() + reading.length());\n    if (worstCase > left) {\n      ByteBuffer newBuffer = ByteBuffer.allocate(ArrayUtil.oversize(buffer.limit() + worstCase - left, 1));\n      buffer.flip();\n      newBuffer.put(buffer);\n      buffer = newBuffer;\n    }\n\n    // add pos mapping\n    int toFill = 1+leftId - posDict.size();\n    for (int i = 0; i < toFill; i++) {\n      posDict.add(null);\n    }\n    String fullPOSData = leftPOS.name() + \",\" + entry[5];\n    String existing = posDict.get(leftId);\n    assert existing == null || existing.equals(fullPOSData);\n    posDict.set(leftId, fullPOSData);\n\n    final Dictionary.Morpheme[] morphemes;\n    // true if the POS and decompounds of the token are all the same.\n    boolean hasSinglePOS = (leftPOS == rightPOS);\n    if (posType != POS.Type.MORPHEME && expression.length() > 0) {\n      String[] exprTokens = expression.split(\"\\\\+\");\n      morphemes = new Dictionary.Morpheme[exprTokens.length];\n      for (int i = 0; i < exprTokens.length; i++) {\n        String[] tokenSplit = exprTokens[i].split(\"\\\\/\");\n        assert tokenSplit.length == 3;\n        POS.Tag exprTag = POS.resolveTag(tokenSplit[1]);\n        morphemes[i] = new Dictionary.Morpheme(exprTag, tokenSplit[0]);\n        if (leftPOS != exprTag) {\n          hasSinglePOS = false;\n        }\n      }\n    } else {\n      morphemes = new Dictionary.Morpheme[0];\n    }\n\n    int flags = 0;\n    if (hasSinglePOS) {\n      flags |= BinaryDictionary.HAS_SINGLE_POS;\n    }\n    if (posType == POS.Type.MORPHEME && reading.length() > 0) {\n      flags |= BinaryDictionary.HAS_READING;\n    }\n\n    assert leftId < 8192; // there are still unused bits\n    assert posType.ordinal() < 4;\n    buffer.putShort((short)(leftId << 2 | posType.ordinal()));\n    buffer.putShort((short) (rightId << 2 | flags));\n    buffer.putShort(wordCost);\n\n    if (posType == POS.Type.MORPHEME) {\n      assert leftPOS == rightPOS;\n      if (reading.length() > 0) {\n        writeString(reading);\n      }\n    } else {\n      if (hasSinglePOS == false) {\n        buffer.put((byte) rightPOS.ordinal());\n      }\n      buffer.put((byte) morphemes.length);\n      int compoundOffset = 0;\n      for (int i = 0; i < morphemes.length; i++) {\n        if (hasSinglePOS == false) {\n          buffer.put((byte) morphemes[i].posTag.ordinal());\n        }\n        if (posType != POS.Type.INFLECT) {\n          buffer.put((byte) morphemes[i].surfaceForm.length());\n          compoundOffset += morphemes[i].surfaceForm.length();\n        } else {\n          writeString(morphemes[i].surfaceForm);\n        }\n        assert compoundOffset <= entry[0].length() : Arrays.toString(entry);\n      }\n    }\n    return buffer.position();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["12136ebc45a29f27a6ab47b007873d0f630f8d11"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5c6453827f947004a68ad9db7418781e9df2f660","date":1523626811,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/analysis/nori/src/tools/java/org/apache/lucene/analysis/ko/util/BinaryDictionaryWriter#put(String[]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * put the entry in map\n   *\n   * mecab-ko-dic features\n   *\n   * 0   - surface\n   * 1   - left cost\n   * 2   - right cost\n   * 3   - word cost\n   * 4   - part of speech0+part of speech1+...\n   * 5   - semantic class\n   * 6   - T if the last character of the surface form has a coda, F otherwise\n   * 7   - reading\n   * 8   - POS type (*, Compound, Inflect, Preanalysis)\n   * 9   - left POS\n   * 10  - right POS\n   * 11  - expression\n   *\n   * @return current position of buffer, which will be wordId of next entry\n   */\n  public int put(String[] entry) {\n    short leftId = Short.parseShort(entry[1]);\n    short rightId = Short.parseShort(entry[2]);\n    short wordCost = Short.parseShort(entry[3]);\n\n    final POS.Type posType = POS.resolveType(entry[8]);\n    final POS.Tag leftPOS;\n    final POS.Tag rightPOS;\n    if (posType == POS.Type.MORPHEME || posType == POS.Type.COMPOUND || entry[9].equals(\"*\")) {\n      leftPOS = POS.resolveTag(entry[4]);\n      assert (entry[9].equals(\"*\") && entry[10].equals(\"*\"));\n      rightPOS = leftPOS;\n    } else {\n      leftPOS = POS.resolveTag(entry[9]);\n      rightPOS = POS.resolveTag(entry[10]);\n    }\n    final String reading = entry[7].equals(\"*\") ? \"\" : entry[0].equals(entry[7]) ? \"\" : entry[7];\n    final String expression = entry[11].equals(\"*\") ? \"\" : entry[11];\n\n    // extend buffer if necessary\n    int left = buffer.remaining();\n    // worst case, 3 short + 4 bytes and features (all as utf-16)\n    int worstCase = 9 + 2*(expression.length() + reading.length());\n    if (worstCase > left) {\n      ByteBuffer newBuffer = ByteBuffer.allocate(ArrayUtil.oversize(buffer.limit() + worstCase - left, 1));\n      buffer.flip();\n      newBuffer.put(buffer);\n      buffer = newBuffer;\n    }\n\n    // add pos mapping\n    int toFill = 1+leftId - posDict.size();\n    for (int i = 0; i < toFill; i++) {\n      posDict.add(null);\n    }\n    String fullPOSData = leftPOS.name() + \",\" + entry[5];\n    String existing = posDict.get(leftId);\n    assert existing == null || existing.equals(fullPOSData);\n    posDict.set(leftId, fullPOSData);\n\n    final Dictionary.Morpheme[] morphemes;\n    // true if the POS and decompounds of the token are all the same.\n    boolean hasSinglePOS = (leftPOS == rightPOS);\n    if (posType != POS.Type.MORPHEME && expression.length() > 0) {\n      String[] exprTokens = expression.split(\"\\\\+\");\n      morphemes = new Dictionary.Morpheme[exprTokens.length];\n      for (int i = 0; i < exprTokens.length; i++) {\n        String[] tokenSplit = exprTokens[i].split(\"\\\\/\");\n        assert tokenSplit.length == 3;\n        POS.Tag exprTag = POS.resolveTag(tokenSplit[1]);\n        morphemes[i] = new Dictionary.Morpheme(exprTag, tokenSplit[0]);\n        if (leftPOS != exprTag) {\n          hasSinglePOS = false;\n        }\n      }\n    } else {\n      morphemes = new Dictionary.Morpheme[0];\n    }\n\n    int flags = 0;\n    if (hasSinglePOS) {\n      flags |= BinaryDictionary.HAS_SINGLE_POS;\n    }\n    if (posType == POS.Type.MORPHEME && reading.length() > 0) {\n      flags |= BinaryDictionary.HAS_READING;\n    }\n\n    assert leftId < 8192; // there are still unused bits\n    assert posType.ordinal() < 4;\n    buffer.putShort((short)(leftId << 2 | posType.ordinal()));\n    buffer.putShort((short) (rightId << 2 | flags));\n    buffer.putShort(wordCost);\n\n    if (posType == POS.Type.MORPHEME) {\n      assert leftPOS == rightPOS;\n      if (reading.length() > 0) {\n        writeString(reading);\n      }\n    } else {\n      if (hasSinglePOS == false) {\n        buffer.put((byte) rightPOS.ordinal());\n      }\n      buffer.put((byte) morphemes.length);\n      int compoundOffset = 0;\n      for (int i = 0; i < morphemes.length; i++) {\n        if (hasSinglePOS == false) {\n          buffer.put((byte) morphemes[i].posTag.ordinal());\n        }\n        if (posType != POS.Type.INFLECT) {\n          buffer.put((byte) morphemes[i].surfaceForm.length());\n          compoundOffset += morphemes[i].surfaceForm.length();\n        } else {\n          writeString(morphemes[i].surfaceForm);\n        }\n        assert compoundOffset <= entry[0].length() : Arrays.toString(entry);\n      }\n    }\n    return buffer.position();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"12136ebc45a29f27a6ab47b007873d0f630f8d11","date":1540542517,"type":3,"author":"Jim Ferenczi","isMerge":false,"pathNew":"lucene/analysis/nori/src/tools/java/org/apache/lucene/analysis/ko/util/BinaryDictionaryWriter#put(String[]).mjava","pathOld":"lucene/analysis/nori/src/tools/java/org/apache/lucene/analysis/ko/util/BinaryDictionaryWriter#put(String[]).mjava","sourceNew":"  /**\n   * put the entry in map\n   *\n   * mecab-ko-dic features\n   *\n   * 0   - surface\n   * 1   - left cost\n   * 2   - right cost\n   * 3   - word cost\n   * 4   - part of speech0+part of speech1+...\n   * 5   - semantic class\n   * 6   - T if the last character of the surface form has a coda, F otherwise\n   * 7   - reading\n   * 8   - POS type (*, Compound, Inflect, Preanalysis)\n   * 9   - left POS\n   * 10  - right POS\n   * 11  - expression\n   *\n   * @return current position of buffer, which will be wordId of next entry\n   */\n  public int put(String[] entry) {\n    short leftId = Short.parseShort(entry[1]);\n    short rightId = Short.parseShort(entry[2]);\n    short wordCost = Short.parseShort(entry[3]);\n\n    final POS.Type posType = POS.resolveType(entry[8]);\n    final POS.Tag leftPOS;\n    final POS.Tag rightPOS;\n    if (posType == POS.Type.MORPHEME || posType == POS.Type.COMPOUND || entry[9].equals(\"*\")) {\n      leftPOS = POS.resolveTag(entry[4]);\n      assert (entry[9].equals(\"*\") && entry[10].equals(\"*\"));\n      rightPOS = leftPOS;\n    } else {\n      leftPOS = POS.resolveTag(entry[9]);\n      rightPOS = POS.resolveTag(entry[10]);\n    }\n    final String reading = entry[7].equals(\"*\") ? \"\" : entry[0].equals(entry[7]) ? \"\" : entry[7];\n    final String expression = entry[11].equals(\"*\") ? \"\" : entry[11];\n\n    // extend buffer if necessary\n    int left = buffer.remaining();\n    // worst case, 3 short + 4 bytes and features (all as utf-16)\n    int worstCase = 9 + 2*(expression.length() + reading.length());\n    if (worstCase > left) {\n      ByteBuffer newBuffer = ByteBuffer.allocate(ArrayUtil.oversize(buffer.limit() + worstCase - left, 1));\n      buffer.flip();\n      newBuffer.put(buffer);\n      buffer = newBuffer;\n    }\n\n    // add pos mapping\n    int toFill = 1+leftId - posDict.size();\n    for (int i = 0; i < toFill; i++) {\n      posDict.add(null);\n    }\n    String fullPOSData = leftPOS.name() + \",\" + entry[5];\n    String existing = posDict.get(leftId);\n    assert existing == null || existing.equals(fullPOSData);\n    posDict.set(leftId, fullPOSData);\n\n    final List<Dictionary.Morpheme> morphemes = new ArrayList<>();\n    // true if the POS and decompounds of the token are all the same.\n    boolean hasSinglePOS = (leftPOS == rightPOS);\n    if (posType != POS.Type.MORPHEME && expression.length() > 0) {\n      String[] exprTokens = expression.split(\"\\\\+\");\n      for (int i = 0; i < exprTokens.length; i++) {\n        String[] tokenSplit = exprTokens[i].split(\"\\\\/\");\n        assert tokenSplit.length == 3;\n        String surfaceForm = tokenSplit[0].trim();\n        if (surfaceForm.isEmpty() == false) {\n          POS.Tag exprTag = POS.resolveTag(tokenSplit[1]);\n          morphemes.add(new Dictionary.Morpheme(exprTag, tokenSplit[0]));\n          if (leftPOS != exprTag) {\n            hasSinglePOS = false;\n          }\n        }\n      }\n    }\n\n    int flags = 0;\n    if (hasSinglePOS) {\n      flags |= BinaryDictionary.HAS_SINGLE_POS;\n    }\n    if (posType == POS.Type.MORPHEME && reading.length() > 0) {\n      flags |= BinaryDictionary.HAS_READING;\n    }\n\n    assert leftId < 8192; // there are still unused bits\n    assert posType.ordinal() < 4;\n    buffer.putShort((short)(leftId << 2 | posType.ordinal()));\n    buffer.putShort((short) (rightId << 2 | flags));\n    buffer.putShort(wordCost);\n\n    if (posType == POS.Type.MORPHEME) {\n      assert leftPOS == rightPOS;\n      if (reading.length() > 0) {\n        writeString(reading);\n      }\n    } else {\n      if (hasSinglePOS == false) {\n        buffer.put((byte) rightPOS.ordinal());\n      }\n      buffer.put((byte) morphemes.size());\n      int compoundOffset = 0;\n      for (Dictionary.Morpheme morpheme : morphemes) {\n        if (hasSinglePOS == false) {\n          buffer.put((byte) morpheme.posTag.ordinal());\n        }\n        if (posType != POS.Type.INFLECT) {\n          buffer.put((byte) morpheme.surfaceForm.length());\n          compoundOffset += morpheme.surfaceForm.length();\n        } else {\n          writeString(morpheme.surfaceForm);\n        }\n        assert compoundOffset <= entry[0].length() : Arrays.toString(entry);\n      }\n    }\n    return buffer.position();\n  }\n\n","sourceOld":"  /**\n   * put the entry in map\n   *\n   * mecab-ko-dic features\n   *\n   * 0   - surface\n   * 1   - left cost\n   * 2   - right cost\n   * 3   - word cost\n   * 4   - part of speech0+part of speech1+...\n   * 5   - semantic class\n   * 6   - T if the last character of the surface form has a coda, F otherwise\n   * 7   - reading\n   * 8   - POS type (*, Compound, Inflect, Preanalysis)\n   * 9   - left POS\n   * 10  - right POS\n   * 11  - expression\n   *\n   * @return current position of buffer, which will be wordId of next entry\n   */\n  public int put(String[] entry) {\n    short leftId = Short.parseShort(entry[1]);\n    short rightId = Short.parseShort(entry[2]);\n    short wordCost = Short.parseShort(entry[3]);\n\n    final POS.Type posType = POS.resolveType(entry[8]);\n    final POS.Tag leftPOS;\n    final POS.Tag rightPOS;\n    if (posType == POS.Type.MORPHEME || posType == POS.Type.COMPOUND || entry[9].equals(\"*\")) {\n      leftPOS = POS.resolveTag(entry[4]);\n      assert (entry[9].equals(\"*\") && entry[10].equals(\"*\"));\n      rightPOS = leftPOS;\n    } else {\n      leftPOS = POS.resolveTag(entry[9]);\n      rightPOS = POS.resolveTag(entry[10]);\n    }\n    final String reading = entry[7].equals(\"*\") ? \"\" : entry[0].equals(entry[7]) ? \"\" : entry[7];\n    final String expression = entry[11].equals(\"*\") ? \"\" : entry[11];\n\n    // extend buffer if necessary\n    int left = buffer.remaining();\n    // worst case, 3 short + 4 bytes and features (all as utf-16)\n    int worstCase = 9 + 2*(expression.length() + reading.length());\n    if (worstCase > left) {\n      ByteBuffer newBuffer = ByteBuffer.allocate(ArrayUtil.oversize(buffer.limit() + worstCase - left, 1));\n      buffer.flip();\n      newBuffer.put(buffer);\n      buffer = newBuffer;\n    }\n\n    // add pos mapping\n    int toFill = 1+leftId - posDict.size();\n    for (int i = 0; i < toFill; i++) {\n      posDict.add(null);\n    }\n    String fullPOSData = leftPOS.name() + \",\" + entry[5];\n    String existing = posDict.get(leftId);\n    assert existing == null || existing.equals(fullPOSData);\n    posDict.set(leftId, fullPOSData);\n\n    final Dictionary.Morpheme[] morphemes;\n    // true if the POS and decompounds of the token are all the same.\n    boolean hasSinglePOS = (leftPOS == rightPOS);\n    if (posType != POS.Type.MORPHEME && expression.length() > 0) {\n      String[] exprTokens = expression.split(\"\\\\+\");\n      morphemes = new Dictionary.Morpheme[exprTokens.length];\n      for (int i = 0; i < exprTokens.length; i++) {\n        String[] tokenSplit = exprTokens[i].split(\"\\\\/\");\n        assert tokenSplit.length == 3;\n        POS.Tag exprTag = POS.resolveTag(tokenSplit[1]);\n        morphemes[i] = new Dictionary.Morpheme(exprTag, tokenSplit[0]);\n        if (leftPOS != exprTag) {\n          hasSinglePOS = false;\n        }\n      }\n    } else {\n      morphemes = new Dictionary.Morpheme[0];\n    }\n\n    int flags = 0;\n    if (hasSinglePOS) {\n      flags |= BinaryDictionary.HAS_SINGLE_POS;\n    }\n    if (posType == POS.Type.MORPHEME && reading.length() > 0) {\n      flags |= BinaryDictionary.HAS_READING;\n    }\n\n    assert leftId < 8192; // there are still unused bits\n    assert posType.ordinal() < 4;\n    buffer.putShort((short)(leftId << 2 | posType.ordinal()));\n    buffer.putShort((short) (rightId << 2 | flags));\n    buffer.putShort(wordCost);\n\n    if (posType == POS.Type.MORPHEME) {\n      assert leftPOS == rightPOS;\n      if (reading.length() > 0) {\n        writeString(reading);\n      }\n    } else {\n      if (hasSinglePOS == false) {\n        buffer.put((byte) rightPOS.ordinal());\n      }\n      buffer.put((byte) morphemes.length);\n      int compoundOffset = 0;\n      for (int i = 0; i < morphemes.length; i++) {\n        if (hasSinglePOS == false) {\n          buffer.put((byte) morphemes[i].posTag.ordinal());\n        }\n        if (posType != POS.Type.INFLECT) {\n          buffer.put((byte) morphemes[i].surfaceForm.length());\n          compoundOffset += morphemes[i].surfaceForm.length();\n        } else {\n          writeString(morphemes[i].surfaceForm);\n        }\n        assert compoundOffset <= entry[0].length() : Arrays.toString(entry);\n      }\n    }\n    return buffer.position();\n  }\n\n","bugFix":["8493925b2e70246f0961df584c01a8c2e61ee52f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c149f6975379ebb860e93139126a8aabf8e2b66d","date":1562857174,"type":3,"author":"Namgyu Kim","isMerge":false,"pathNew":"lucene/analysis/nori/src/tools/java/org/apache/lucene/analysis/ko/util/BinaryDictionaryWriter#put(String[]).mjava","pathOld":"lucene/analysis/nori/src/tools/java/org/apache/lucene/analysis/ko/util/BinaryDictionaryWriter#put(String[]).mjava","sourceNew":"  /**\n   * put the entry in map\n   *\n   * mecab-ko-dic features\n   *\n   * 0   - surface\n   * 1   - left cost\n   * 2   - right cost\n   * 3   - word cost\n   * 4   - part of speech0+part of speech1+...\n   * 5   - semantic class\n   * 6   - T if the last character of the surface form has a coda, F otherwise\n   * 7   - reading\n   * 8   - POS type (*, Compound, Inflect, Preanalysis)\n   * 9   - left POS\n   * 10  - right POS\n   * 11  - expression\n   *\n   * @return current position of buffer, which will be wordId of next entry\n   */\n  public int put(String[] entry) {\n    short leftId = Short.parseShort(entry[1]);\n    short rightId = Short.parseShort(entry[2]);\n    short wordCost = Short.parseShort(entry[3]);\n\n    final POS.Type posType = POS.resolveType(entry[8]);\n    final POS.Tag leftPOS;\n    final POS.Tag rightPOS;\n    if (posType == POS.Type.MORPHEME || posType == POS.Type.COMPOUND || entry[9].equals(\"*\")) {\n      leftPOS = POS.resolveTag(entry[4]);\n      assert (entry[9].equals(\"*\") && entry[10].equals(\"*\"));\n      rightPOS = leftPOS;\n    } else {\n      leftPOS = POS.resolveTag(entry[9]);\n      rightPOS = POS.resolveTag(entry[10]);\n    }\n    final String reading = entry[7].equals(\"*\") ? \"\" : entry[0].equals(entry[7]) ? \"\" : entry[7];\n    final String expression = entry[11].equals(\"*\") ? \"\" : entry[11];\n\n    // extend buffer if necessary\n    int left = buffer.remaining();\n    // worst case, 3 short + 4 bytes and features (all as utf-16)\n    int worstCase = 9 + 2*(expression.length() + reading.length());\n    if (worstCase > left) {\n      ByteBuffer newBuffer = ByteBuffer.allocate(ArrayUtil.oversize(buffer.limit() + worstCase - left, 1));\n      buffer.flip();\n      newBuffer.put(buffer);\n      buffer = newBuffer;\n    }\n\n    // add pos mapping\n    int toFill = 1+leftId - posDict.size();\n    for (int i = 0; i < toFill; i++) {\n      posDict.add(null);\n    }\n    String fullPOSData = leftPOS.name() + \",\" + entry[5];\n    String existing = posDict.get(leftId);\n    assert existing == null || existing.equals(fullPOSData);\n    posDict.set(leftId, fullPOSData);\n\n    final List<Dictionary.Morpheme> morphemes = new ArrayList<>();\n    // true if the POS and decompounds of the token are all the same.\n    boolean hasSinglePOS = (leftPOS == rightPOS);\n    if (posType != POS.Type.MORPHEME && expression.length() > 0) {\n      String[] exprTokens = expression.split(\"\\\\+\");\n      for (int i = 0; i < exprTokens.length; i++) {\n        String[] tokenSplit = exprTokens[i].split(\"/\");\n        assert tokenSplit.length == 3;\n        String surfaceForm = tokenSplit[0].trim();\n        if (surfaceForm.isEmpty() == false) {\n          POS.Tag exprTag = POS.resolveTag(tokenSplit[1]);\n          morphemes.add(new Dictionary.Morpheme(exprTag, tokenSplit[0]));\n          if (leftPOS != exprTag) {\n            hasSinglePOS = false;\n          }\n        }\n      }\n    }\n\n    int flags = 0;\n    if (hasSinglePOS) {\n      flags |= BinaryDictionary.HAS_SINGLE_POS;\n    }\n    if (posType == POS.Type.MORPHEME && reading.length() > 0) {\n      flags |= BinaryDictionary.HAS_READING;\n    }\n\n    if (leftId >= ID_LIMIT) {\n      throw new IllegalArgumentException(\"leftId >= \" + ID_LIMIT + \": \" + leftId);\n    }\n    if (posType.ordinal() >= 4) {\n      throw new IllegalArgumentException(\"posType.ordinal() >= \" + 4 + \": \" + posType.name());\n    }\n    buffer.putShort((short)(leftId << 2 | posType.ordinal()));\n    buffer.putShort((short) (rightId << 2 | flags));\n    buffer.putShort(wordCost);\n\n    if (posType == POS.Type.MORPHEME) {\n      assert leftPOS == rightPOS;\n      if (reading.length() > 0) {\n        writeString(reading);\n      }\n    } else {\n      if (hasSinglePOS == false) {\n        buffer.put((byte) rightPOS.ordinal());\n      }\n      buffer.put((byte) morphemes.size());\n      int compoundOffset = 0;\n      for (Dictionary.Morpheme morpheme : morphemes) {\n        if (hasSinglePOS == false) {\n          buffer.put((byte) morpheme.posTag.ordinal());\n        }\n        if (posType != POS.Type.INFLECT) {\n          buffer.put((byte) morpheme.surfaceForm.length());\n          compoundOffset += morpheme.surfaceForm.length();\n        } else {\n          writeString(morpheme.surfaceForm);\n        }\n        assert compoundOffset <= entry[0].length() : Arrays.toString(entry);\n      }\n    }\n    return buffer.position();\n  }\n\n","sourceOld":"  /**\n   * put the entry in map\n   *\n   * mecab-ko-dic features\n   *\n   * 0   - surface\n   * 1   - left cost\n   * 2   - right cost\n   * 3   - word cost\n   * 4   - part of speech0+part of speech1+...\n   * 5   - semantic class\n   * 6   - T if the last character of the surface form has a coda, F otherwise\n   * 7   - reading\n   * 8   - POS type (*, Compound, Inflect, Preanalysis)\n   * 9   - left POS\n   * 10  - right POS\n   * 11  - expression\n   *\n   * @return current position of buffer, which will be wordId of next entry\n   */\n  public int put(String[] entry) {\n    short leftId = Short.parseShort(entry[1]);\n    short rightId = Short.parseShort(entry[2]);\n    short wordCost = Short.parseShort(entry[3]);\n\n    final POS.Type posType = POS.resolveType(entry[8]);\n    final POS.Tag leftPOS;\n    final POS.Tag rightPOS;\n    if (posType == POS.Type.MORPHEME || posType == POS.Type.COMPOUND || entry[9].equals(\"*\")) {\n      leftPOS = POS.resolveTag(entry[4]);\n      assert (entry[9].equals(\"*\") && entry[10].equals(\"*\"));\n      rightPOS = leftPOS;\n    } else {\n      leftPOS = POS.resolveTag(entry[9]);\n      rightPOS = POS.resolveTag(entry[10]);\n    }\n    final String reading = entry[7].equals(\"*\") ? \"\" : entry[0].equals(entry[7]) ? \"\" : entry[7];\n    final String expression = entry[11].equals(\"*\") ? \"\" : entry[11];\n\n    // extend buffer if necessary\n    int left = buffer.remaining();\n    // worst case, 3 short + 4 bytes and features (all as utf-16)\n    int worstCase = 9 + 2*(expression.length() + reading.length());\n    if (worstCase > left) {\n      ByteBuffer newBuffer = ByteBuffer.allocate(ArrayUtil.oversize(buffer.limit() + worstCase - left, 1));\n      buffer.flip();\n      newBuffer.put(buffer);\n      buffer = newBuffer;\n    }\n\n    // add pos mapping\n    int toFill = 1+leftId - posDict.size();\n    for (int i = 0; i < toFill; i++) {\n      posDict.add(null);\n    }\n    String fullPOSData = leftPOS.name() + \",\" + entry[5];\n    String existing = posDict.get(leftId);\n    assert existing == null || existing.equals(fullPOSData);\n    posDict.set(leftId, fullPOSData);\n\n    final List<Dictionary.Morpheme> morphemes = new ArrayList<>();\n    // true if the POS and decompounds of the token are all the same.\n    boolean hasSinglePOS = (leftPOS == rightPOS);\n    if (posType != POS.Type.MORPHEME && expression.length() > 0) {\n      String[] exprTokens = expression.split(\"\\\\+\");\n      for (int i = 0; i < exprTokens.length; i++) {\n        String[] tokenSplit = exprTokens[i].split(\"\\\\/\");\n        assert tokenSplit.length == 3;\n        String surfaceForm = tokenSplit[0].trim();\n        if (surfaceForm.isEmpty() == false) {\n          POS.Tag exprTag = POS.resolveTag(tokenSplit[1]);\n          morphemes.add(new Dictionary.Morpheme(exprTag, tokenSplit[0]));\n          if (leftPOS != exprTag) {\n            hasSinglePOS = false;\n          }\n        }\n      }\n    }\n\n    int flags = 0;\n    if (hasSinglePOS) {\n      flags |= BinaryDictionary.HAS_SINGLE_POS;\n    }\n    if (posType == POS.Type.MORPHEME && reading.length() > 0) {\n      flags |= BinaryDictionary.HAS_READING;\n    }\n\n    assert leftId < 8192; // there are still unused bits\n    assert posType.ordinal() < 4;\n    buffer.putShort((short)(leftId << 2 | posType.ordinal()));\n    buffer.putShort((short) (rightId << 2 | flags));\n    buffer.putShort(wordCost);\n\n    if (posType == POS.Type.MORPHEME) {\n      assert leftPOS == rightPOS;\n      if (reading.length() > 0) {\n        writeString(reading);\n      }\n    } else {\n      if (hasSinglePOS == false) {\n        buffer.put((byte) rightPOS.ordinal());\n      }\n      buffer.put((byte) morphemes.size());\n      int compoundOffset = 0;\n      for (Dictionary.Morpheme morpheme : morphemes) {\n        if (hasSinglePOS == false) {\n          buffer.put((byte) morpheme.posTag.ordinal());\n        }\n        if (posType != POS.Type.INFLECT) {\n          buffer.put((byte) morpheme.surfaceForm.length());\n          compoundOffset += morpheme.surfaceForm.length();\n        } else {\n          writeString(morpheme.surfaceForm);\n        }\n        assert compoundOffset <= entry[0].length() : Arrays.toString(entry);\n      }\n    }\n    return buffer.position();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e3010cab237afb0b81c042f263115756e3cc6d67","date":1564503244,"type":5,"author":"Namgyu Kim","isMerge":false,"pathNew":"lucene/analysis/nori/src/java/org/apache/lucene/analysis/ko/util/BinaryDictionaryWriter#put(String[]).mjava","pathOld":"lucene/analysis/nori/src/tools/java/org/apache/lucene/analysis/ko/util/BinaryDictionaryWriter#put(String[]).mjava","sourceNew":"  /**\n   * put the entry in map\n   *\n   * mecab-ko-dic features\n   *\n   * 0   - surface\n   * 1   - left cost\n   * 2   - right cost\n   * 3   - word cost\n   * 4   - part of speech0+part of speech1+...\n   * 5   - semantic class\n   * 6   - T if the last character of the surface form has a coda, F otherwise\n   * 7   - reading\n   * 8   - POS type (*, Compound, Inflect, Preanalysis)\n   * 9   - left POS\n   * 10  - right POS\n   * 11  - expression\n   *\n   * @return current position of buffer, which will be wordId of next entry\n   */\n  public int put(String[] entry) {\n    short leftId = Short.parseShort(entry[1]);\n    short rightId = Short.parseShort(entry[2]);\n    short wordCost = Short.parseShort(entry[3]);\n\n    final POS.Type posType = POS.resolveType(entry[8]);\n    final POS.Tag leftPOS;\n    final POS.Tag rightPOS;\n    if (posType == POS.Type.MORPHEME || posType == POS.Type.COMPOUND || entry[9].equals(\"*\")) {\n      leftPOS = POS.resolveTag(entry[4]);\n      assert (entry[9].equals(\"*\") && entry[10].equals(\"*\"));\n      rightPOS = leftPOS;\n    } else {\n      leftPOS = POS.resolveTag(entry[9]);\n      rightPOS = POS.resolveTag(entry[10]);\n    }\n    final String reading = entry[7].equals(\"*\") ? \"\" : entry[0].equals(entry[7]) ? \"\" : entry[7];\n    final String expression = entry[11].equals(\"*\") ? \"\" : entry[11];\n\n    // extend buffer if necessary\n    int left = buffer.remaining();\n    // worst case, 3 short + 4 bytes and features (all as utf-16)\n    int worstCase = 9 + 2*(expression.length() + reading.length());\n    if (worstCase > left) {\n      ByteBuffer newBuffer = ByteBuffer.allocate(ArrayUtil.oversize(buffer.limit() + worstCase - left, 1));\n      buffer.flip();\n      newBuffer.put(buffer);\n      buffer = newBuffer;\n    }\n\n    // add pos mapping\n    int toFill = 1+leftId - posDict.size();\n    for (int i = 0; i < toFill; i++) {\n      posDict.add(null);\n    }\n    String fullPOSData = leftPOS.name() + \",\" + entry[5];\n    String existing = posDict.get(leftId);\n    assert existing == null || existing.equals(fullPOSData);\n    posDict.set(leftId, fullPOSData);\n\n    final List<Dictionary.Morpheme> morphemes = new ArrayList<>();\n    // true if the POS and decompounds of the token are all the same.\n    boolean hasSinglePOS = (leftPOS == rightPOS);\n    if (posType != POS.Type.MORPHEME && expression.length() > 0) {\n      String[] exprTokens = expression.split(\"\\\\+\");\n      for (int i = 0; i < exprTokens.length; i++) {\n        String[] tokenSplit = exprTokens[i].split(\"/\");\n        assert tokenSplit.length == 3;\n        String surfaceForm = tokenSplit[0].trim();\n        if (surfaceForm.isEmpty() == false) {\n          POS.Tag exprTag = POS.resolveTag(tokenSplit[1]);\n          morphemes.add(new Dictionary.Morpheme(exprTag, tokenSplit[0]));\n          if (leftPOS != exprTag) {\n            hasSinglePOS = false;\n          }\n        }\n      }\n    }\n\n    int flags = 0;\n    if (hasSinglePOS) {\n      flags |= BinaryDictionary.HAS_SINGLE_POS;\n    }\n    if (posType == POS.Type.MORPHEME && reading.length() > 0) {\n      flags |= BinaryDictionary.HAS_READING;\n    }\n\n    if (leftId >= ID_LIMIT) {\n      throw new IllegalArgumentException(\"leftId >= \" + ID_LIMIT + \": \" + leftId);\n    }\n    if (posType.ordinal() >= 4) {\n      throw new IllegalArgumentException(\"posType.ordinal() >= \" + 4 + \": \" + posType.name());\n    }\n    buffer.putShort((short)(leftId << 2 | posType.ordinal()));\n    buffer.putShort((short) (rightId << 2 | flags));\n    buffer.putShort(wordCost);\n\n    if (posType == POS.Type.MORPHEME) {\n      assert leftPOS == rightPOS;\n      if (reading.length() > 0) {\n        writeString(reading);\n      }\n    } else {\n      if (hasSinglePOS == false) {\n        buffer.put((byte) rightPOS.ordinal());\n      }\n      buffer.put((byte) morphemes.size());\n      int compoundOffset = 0;\n      for (Dictionary.Morpheme morpheme : morphemes) {\n        if (hasSinglePOS == false) {\n          buffer.put((byte) morpheme.posTag.ordinal());\n        }\n        if (posType != POS.Type.INFLECT) {\n          buffer.put((byte) morpheme.surfaceForm.length());\n          compoundOffset += morpheme.surfaceForm.length();\n        } else {\n          writeString(morpheme.surfaceForm);\n        }\n        assert compoundOffset <= entry[0].length() : Arrays.toString(entry);\n      }\n    }\n    return buffer.position();\n  }\n\n","sourceOld":"  /**\n   * put the entry in map\n   *\n   * mecab-ko-dic features\n   *\n   * 0   - surface\n   * 1   - left cost\n   * 2   - right cost\n   * 3   - word cost\n   * 4   - part of speech0+part of speech1+...\n   * 5   - semantic class\n   * 6   - T if the last character of the surface form has a coda, F otherwise\n   * 7   - reading\n   * 8   - POS type (*, Compound, Inflect, Preanalysis)\n   * 9   - left POS\n   * 10  - right POS\n   * 11  - expression\n   *\n   * @return current position of buffer, which will be wordId of next entry\n   */\n  public int put(String[] entry) {\n    short leftId = Short.parseShort(entry[1]);\n    short rightId = Short.parseShort(entry[2]);\n    short wordCost = Short.parseShort(entry[3]);\n\n    final POS.Type posType = POS.resolveType(entry[8]);\n    final POS.Tag leftPOS;\n    final POS.Tag rightPOS;\n    if (posType == POS.Type.MORPHEME || posType == POS.Type.COMPOUND || entry[9].equals(\"*\")) {\n      leftPOS = POS.resolveTag(entry[4]);\n      assert (entry[9].equals(\"*\") && entry[10].equals(\"*\"));\n      rightPOS = leftPOS;\n    } else {\n      leftPOS = POS.resolveTag(entry[9]);\n      rightPOS = POS.resolveTag(entry[10]);\n    }\n    final String reading = entry[7].equals(\"*\") ? \"\" : entry[0].equals(entry[7]) ? \"\" : entry[7];\n    final String expression = entry[11].equals(\"*\") ? \"\" : entry[11];\n\n    // extend buffer if necessary\n    int left = buffer.remaining();\n    // worst case, 3 short + 4 bytes and features (all as utf-16)\n    int worstCase = 9 + 2*(expression.length() + reading.length());\n    if (worstCase > left) {\n      ByteBuffer newBuffer = ByteBuffer.allocate(ArrayUtil.oversize(buffer.limit() + worstCase - left, 1));\n      buffer.flip();\n      newBuffer.put(buffer);\n      buffer = newBuffer;\n    }\n\n    // add pos mapping\n    int toFill = 1+leftId - posDict.size();\n    for (int i = 0; i < toFill; i++) {\n      posDict.add(null);\n    }\n    String fullPOSData = leftPOS.name() + \",\" + entry[5];\n    String existing = posDict.get(leftId);\n    assert existing == null || existing.equals(fullPOSData);\n    posDict.set(leftId, fullPOSData);\n\n    final List<Dictionary.Morpheme> morphemes = new ArrayList<>();\n    // true if the POS and decompounds of the token are all the same.\n    boolean hasSinglePOS = (leftPOS == rightPOS);\n    if (posType != POS.Type.MORPHEME && expression.length() > 0) {\n      String[] exprTokens = expression.split(\"\\\\+\");\n      for (int i = 0; i < exprTokens.length; i++) {\n        String[] tokenSplit = exprTokens[i].split(\"/\");\n        assert tokenSplit.length == 3;\n        String surfaceForm = tokenSplit[0].trim();\n        if (surfaceForm.isEmpty() == false) {\n          POS.Tag exprTag = POS.resolveTag(tokenSplit[1]);\n          morphemes.add(new Dictionary.Morpheme(exprTag, tokenSplit[0]));\n          if (leftPOS != exprTag) {\n            hasSinglePOS = false;\n          }\n        }\n      }\n    }\n\n    int flags = 0;\n    if (hasSinglePOS) {\n      flags |= BinaryDictionary.HAS_SINGLE_POS;\n    }\n    if (posType == POS.Type.MORPHEME && reading.length() > 0) {\n      flags |= BinaryDictionary.HAS_READING;\n    }\n\n    if (leftId >= ID_LIMIT) {\n      throw new IllegalArgumentException(\"leftId >= \" + ID_LIMIT + \": \" + leftId);\n    }\n    if (posType.ordinal() >= 4) {\n      throw new IllegalArgumentException(\"posType.ordinal() >= \" + 4 + \": \" + posType.name());\n    }\n    buffer.putShort((short)(leftId << 2 | posType.ordinal()));\n    buffer.putShort((short) (rightId << 2 | flags));\n    buffer.putShort(wordCost);\n\n    if (posType == POS.Type.MORPHEME) {\n      assert leftPOS == rightPOS;\n      if (reading.length() > 0) {\n        writeString(reading);\n      }\n    } else {\n      if (hasSinglePOS == false) {\n        buffer.put((byte) rightPOS.ordinal());\n      }\n      buffer.put((byte) morphemes.size());\n      int compoundOffset = 0;\n      for (Dictionary.Morpheme morpheme : morphemes) {\n        if (hasSinglePOS == false) {\n          buffer.put((byte) morpheme.posTag.ordinal());\n        }\n        if (posType != POS.Type.INFLECT) {\n          buffer.put((byte) morpheme.surfaceForm.length());\n          compoundOffset += morpheme.surfaceForm.length();\n        } else {\n          writeString(morpheme.surfaceForm);\n        }\n        assert compoundOffset <= entry[0].length() : Arrays.toString(entry);\n      }\n    }\n    return buffer.position();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f8061ddd97f3352007d927dae445884a6f3d857b","date":1564988276,"type":5,"author":"Atri Sharma","isMerge":true,"pathNew":"lucene/analysis/nori/src/java/org/apache/lucene/analysis/ko/util/BinaryDictionaryWriter#put(String[]).mjava","pathOld":"lucene/analysis/nori/src/tools/java/org/apache/lucene/analysis/ko/util/BinaryDictionaryWriter#put(String[]).mjava","sourceNew":"  /**\n   * put the entry in map\n   *\n   * mecab-ko-dic features\n   *\n   * 0   - surface\n   * 1   - left cost\n   * 2   - right cost\n   * 3   - word cost\n   * 4   - part of speech0+part of speech1+...\n   * 5   - semantic class\n   * 6   - T if the last character of the surface form has a coda, F otherwise\n   * 7   - reading\n   * 8   - POS type (*, Compound, Inflect, Preanalysis)\n   * 9   - left POS\n   * 10  - right POS\n   * 11  - expression\n   *\n   * @return current position of buffer, which will be wordId of next entry\n   */\n  public int put(String[] entry) {\n    short leftId = Short.parseShort(entry[1]);\n    short rightId = Short.parseShort(entry[2]);\n    short wordCost = Short.parseShort(entry[3]);\n\n    final POS.Type posType = POS.resolveType(entry[8]);\n    final POS.Tag leftPOS;\n    final POS.Tag rightPOS;\n    if (posType == POS.Type.MORPHEME || posType == POS.Type.COMPOUND || entry[9].equals(\"*\")) {\n      leftPOS = POS.resolveTag(entry[4]);\n      assert (entry[9].equals(\"*\") && entry[10].equals(\"*\"));\n      rightPOS = leftPOS;\n    } else {\n      leftPOS = POS.resolveTag(entry[9]);\n      rightPOS = POS.resolveTag(entry[10]);\n    }\n    final String reading = entry[7].equals(\"*\") ? \"\" : entry[0].equals(entry[7]) ? \"\" : entry[7];\n    final String expression = entry[11].equals(\"*\") ? \"\" : entry[11];\n\n    // extend buffer if necessary\n    int left = buffer.remaining();\n    // worst case, 3 short + 4 bytes and features (all as utf-16)\n    int worstCase = 9 + 2*(expression.length() + reading.length());\n    if (worstCase > left) {\n      ByteBuffer newBuffer = ByteBuffer.allocate(ArrayUtil.oversize(buffer.limit() + worstCase - left, 1));\n      buffer.flip();\n      newBuffer.put(buffer);\n      buffer = newBuffer;\n    }\n\n    // add pos mapping\n    int toFill = 1+leftId - posDict.size();\n    for (int i = 0; i < toFill; i++) {\n      posDict.add(null);\n    }\n    String fullPOSData = leftPOS.name() + \",\" + entry[5];\n    String existing = posDict.get(leftId);\n    assert existing == null || existing.equals(fullPOSData);\n    posDict.set(leftId, fullPOSData);\n\n    final List<Dictionary.Morpheme> morphemes = new ArrayList<>();\n    // true if the POS and decompounds of the token are all the same.\n    boolean hasSinglePOS = (leftPOS == rightPOS);\n    if (posType != POS.Type.MORPHEME && expression.length() > 0) {\n      String[] exprTokens = expression.split(\"\\\\+\");\n      for (int i = 0; i < exprTokens.length; i++) {\n        String[] tokenSplit = exprTokens[i].split(\"/\");\n        assert tokenSplit.length == 3;\n        String surfaceForm = tokenSplit[0].trim();\n        if (surfaceForm.isEmpty() == false) {\n          POS.Tag exprTag = POS.resolveTag(tokenSplit[1]);\n          morphemes.add(new Dictionary.Morpheme(exprTag, tokenSplit[0]));\n          if (leftPOS != exprTag) {\n            hasSinglePOS = false;\n          }\n        }\n      }\n    }\n\n    int flags = 0;\n    if (hasSinglePOS) {\n      flags |= BinaryDictionary.HAS_SINGLE_POS;\n    }\n    if (posType == POS.Type.MORPHEME && reading.length() > 0) {\n      flags |= BinaryDictionary.HAS_READING;\n    }\n\n    if (leftId >= ID_LIMIT) {\n      throw new IllegalArgumentException(\"leftId >= \" + ID_LIMIT + \": \" + leftId);\n    }\n    if (posType.ordinal() >= 4) {\n      throw new IllegalArgumentException(\"posType.ordinal() >= \" + 4 + \": \" + posType.name());\n    }\n    buffer.putShort((short)(leftId << 2 | posType.ordinal()));\n    buffer.putShort((short) (rightId << 2 | flags));\n    buffer.putShort(wordCost);\n\n    if (posType == POS.Type.MORPHEME) {\n      assert leftPOS == rightPOS;\n      if (reading.length() > 0) {\n        writeString(reading);\n      }\n    } else {\n      if (hasSinglePOS == false) {\n        buffer.put((byte) rightPOS.ordinal());\n      }\n      buffer.put((byte) morphemes.size());\n      int compoundOffset = 0;\n      for (Dictionary.Morpheme morpheme : morphemes) {\n        if (hasSinglePOS == false) {\n          buffer.put((byte) morpheme.posTag.ordinal());\n        }\n        if (posType != POS.Type.INFLECT) {\n          buffer.put((byte) morpheme.surfaceForm.length());\n          compoundOffset += morpheme.surfaceForm.length();\n        } else {\n          writeString(morpheme.surfaceForm);\n        }\n        assert compoundOffset <= entry[0].length() : Arrays.toString(entry);\n      }\n    }\n    return buffer.position();\n  }\n\n","sourceOld":"  /**\n   * put the entry in map\n   *\n   * mecab-ko-dic features\n   *\n   * 0   - surface\n   * 1   - left cost\n   * 2   - right cost\n   * 3   - word cost\n   * 4   - part of speech0+part of speech1+...\n   * 5   - semantic class\n   * 6   - T if the last character of the surface form has a coda, F otherwise\n   * 7   - reading\n   * 8   - POS type (*, Compound, Inflect, Preanalysis)\n   * 9   - left POS\n   * 10  - right POS\n   * 11  - expression\n   *\n   * @return current position of buffer, which will be wordId of next entry\n   */\n  public int put(String[] entry) {\n    short leftId = Short.parseShort(entry[1]);\n    short rightId = Short.parseShort(entry[2]);\n    short wordCost = Short.parseShort(entry[3]);\n\n    final POS.Type posType = POS.resolveType(entry[8]);\n    final POS.Tag leftPOS;\n    final POS.Tag rightPOS;\n    if (posType == POS.Type.MORPHEME || posType == POS.Type.COMPOUND || entry[9].equals(\"*\")) {\n      leftPOS = POS.resolveTag(entry[4]);\n      assert (entry[9].equals(\"*\") && entry[10].equals(\"*\"));\n      rightPOS = leftPOS;\n    } else {\n      leftPOS = POS.resolveTag(entry[9]);\n      rightPOS = POS.resolveTag(entry[10]);\n    }\n    final String reading = entry[7].equals(\"*\") ? \"\" : entry[0].equals(entry[7]) ? \"\" : entry[7];\n    final String expression = entry[11].equals(\"*\") ? \"\" : entry[11];\n\n    // extend buffer if necessary\n    int left = buffer.remaining();\n    // worst case, 3 short + 4 bytes and features (all as utf-16)\n    int worstCase = 9 + 2*(expression.length() + reading.length());\n    if (worstCase > left) {\n      ByteBuffer newBuffer = ByteBuffer.allocate(ArrayUtil.oversize(buffer.limit() + worstCase - left, 1));\n      buffer.flip();\n      newBuffer.put(buffer);\n      buffer = newBuffer;\n    }\n\n    // add pos mapping\n    int toFill = 1+leftId - posDict.size();\n    for (int i = 0; i < toFill; i++) {\n      posDict.add(null);\n    }\n    String fullPOSData = leftPOS.name() + \",\" + entry[5];\n    String existing = posDict.get(leftId);\n    assert existing == null || existing.equals(fullPOSData);\n    posDict.set(leftId, fullPOSData);\n\n    final List<Dictionary.Morpheme> morphemes = new ArrayList<>();\n    // true if the POS and decompounds of the token are all the same.\n    boolean hasSinglePOS = (leftPOS == rightPOS);\n    if (posType != POS.Type.MORPHEME && expression.length() > 0) {\n      String[] exprTokens = expression.split(\"\\\\+\");\n      for (int i = 0; i < exprTokens.length; i++) {\n        String[] tokenSplit = exprTokens[i].split(\"/\");\n        assert tokenSplit.length == 3;\n        String surfaceForm = tokenSplit[0].trim();\n        if (surfaceForm.isEmpty() == false) {\n          POS.Tag exprTag = POS.resolveTag(tokenSplit[1]);\n          morphemes.add(new Dictionary.Morpheme(exprTag, tokenSplit[0]));\n          if (leftPOS != exprTag) {\n            hasSinglePOS = false;\n          }\n        }\n      }\n    }\n\n    int flags = 0;\n    if (hasSinglePOS) {\n      flags |= BinaryDictionary.HAS_SINGLE_POS;\n    }\n    if (posType == POS.Type.MORPHEME && reading.length() > 0) {\n      flags |= BinaryDictionary.HAS_READING;\n    }\n\n    if (leftId >= ID_LIMIT) {\n      throw new IllegalArgumentException(\"leftId >= \" + ID_LIMIT + \": \" + leftId);\n    }\n    if (posType.ordinal() >= 4) {\n      throw new IllegalArgumentException(\"posType.ordinal() >= \" + 4 + \": \" + posType.name());\n    }\n    buffer.putShort((short)(leftId << 2 | posType.ordinal()));\n    buffer.putShort((short) (rightId << 2 | flags));\n    buffer.putShort(wordCost);\n\n    if (posType == POS.Type.MORPHEME) {\n      assert leftPOS == rightPOS;\n      if (reading.length() > 0) {\n        writeString(reading);\n      }\n    } else {\n      if (hasSinglePOS == false) {\n        buffer.put((byte) rightPOS.ordinal());\n      }\n      buffer.put((byte) morphemes.size());\n      int compoundOffset = 0;\n      for (Dictionary.Morpheme morpheme : morphemes) {\n        if (hasSinglePOS == false) {\n          buffer.put((byte) morpheme.posTag.ordinal());\n        }\n        if (posType != POS.Type.INFLECT) {\n          buffer.put((byte) morpheme.surfaceForm.length());\n          compoundOffset += morpheme.surfaceForm.length();\n        } else {\n          writeString(morpheme.surfaceForm);\n        }\n        assert compoundOffset <= entry[0].length() : Arrays.toString(entry);\n      }\n    }\n    return buffer.position();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"12136ebc45a29f27a6ab47b007873d0f630f8d11":["5c6453827f947004a68ad9db7418781e9df2f660"],"c149f6975379ebb860e93139126a8aabf8e2b66d":["12136ebc45a29f27a6ab47b007873d0f630f8d11"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8493925b2e70246f0961df584c01a8c2e61ee52f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e3010cab237afb0b81c042f263115756e3cc6d67":["c149f6975379ebb860e93139126a8aabf8e2b66d"],"f8061ddd97f3352007d927dae445884a6f3d857b":["c149f6975379ebb860e93139126a8aabf8e2b66d","e3010cab237afb0b81c042f263115756e3cc6d67"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e3010cab237afb0b81c042f263115756e3cc6d67"],"5c6453827f947004a68ad9db7418781e9df2f660":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","8493925b2e70246f0961df584c01a8c2e61ee52f"]},"commit2Childs":{"12136ebc45a29f27a6ab47b007873d0f630f8d11":["c149f6975379ebb860e93139126a8aabf8e2b66d"],"c149f6975379ebb860e93139126a8aabf8e2b66d":["e3010cab237afb0b81c042f263115756e3cc6d67","f8061ddd97f3352007d927dae445884a6f3d857b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8493925b2e70246f0961df584c01a8c2e61ee52f","5c6453827f947004a68ad9db7418781e9df2f660"],"8493925b2e70246f0961df584c01a8c2e61ee52f":["5c6453827f947004a68ad9db7418781e9df2f660"],"e3010cab237afb0b81c042f263115756e3cc6d67":["f8061ddd97f3352007d927dae445884a6f3d857b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f8061ddd97f3352007d927dae445884a6f3d857b":[],"5c6453827f947004a68ad9db7418781e9df2f660":["12136ebc45a29f27a6ab47b007873d0f630f8d11"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["f8061ddd97f3352007d927dae445884a6f3d857b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}