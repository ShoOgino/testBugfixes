{"path":"src/java/org/apache/lucene/search/FieldCacheImpl#getCacheEntries().mjava","commits":[{"id":"e69f59b863731d864bf3047235e718f0f88f8841","date":1250105498,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FieldCacheImpl#getCacheEntries().mjava","pathOld":"/dev/null","sourceNew":"  public CacheEntry[] getCacheEntries() {\n    List result = new ArrayList(17);\n    Iterator outerKeys = caches.keySet().iterator();\n    while (outerKeys.hasNext()) {\n      Class cacheType = (Class)outerKeys.next();\n      Cache cache = (Cache)caches.get(cacheType);\n      Iterator innerKeys = cache.readerCache.keySet().iterator();\n      while (innerKeys.hasNext()) {\n        // we've now materialized a hard ref\n        Object readerKey = innerKeys.next();\n        // innerKeys was backed by WeakHashMap, sanity check\n        // that it wasn't GCed before we made hard ref\n        if (null != readerKey && cache.readerCache.containsKey(readerKey)) {\n          Map innerCache = ((Map)cache.readerCache.get(readerKey));\n          Iterator keys = innerCache.keySet().iterator();\n          while (keys.hasNext()) {\n            Entry entry = (Entry) keys.next();\n            result.add(new CacheEntryImpl(readerKey, entry.field,\n                                          cacheType, entry.type,\n                                          entry.custom, entry.locale,\n                                          innerCache.get(entry)));\n          }\n        }\n      }\n    }\n    return (CacheEntry[]) result.toArray(new CacheEntry[result.size()]);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"63a3cd934de70be8201bb9ab57198e3fb5c8985f","date":1251004373,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FieldCacheImpl#getCacheEntries().mjava","pathOld":"src/java/org/apache/lucene/search/FieldCacheImpl#getCacheEntries().mjava","sourceNew":"  public CacheEntry[] getCacheEntries() {\n    List result = new ArrayList(17);\n    Iterator outerKeys = caches.keySet().iterator();\n    while (outerKeys.hasNext()) {\n      Class cacheType = (Class)outerKeys.next();\n      Cache cache = (Cache)caches.get(cacheType);\n      Iterator innerKeys = cache.readerCache.keySet().iterator();\n      while (innerKeys.hasNext()) {\n        // we've now materialized a hard ref\n        Object readerKey = innerKeys.next();\n        // innerKeys was backed by WeakHashMap, sanity check\n        // that it wasn't GCed before we made hard ref\n        if (null != readerKey && cache.readerCache.containsKey(readerKey)) {\n          Map innerCache = ((Map)cache.readerCache.get(readerKey));\n          Iterator entrySetIterator = innerCache.entrySet().iterator();\n          while (entrySetIterator.hasNext()) {\n            Map.Entry mapEntry = (Map.Entry) entrySetIterator.next();\n            Entry entry = (Entry) mapEntry.getKey();\n            result.add(new CacheEntryImpl(readerKey, entry.field,\n                                          cacheType, entry.type,\n                                          entry.custom, entry.locale,\n                                          mapEntry.getValue()));\n          }\n        }\n      }\n    }\n    return (CacheEntry[]) result.toArray(new CacheEntry[result.size()]);\n  }\n\n","sourceOld":"  public CacheEntry[] getCacheEntries() {\n    List result = new ArrayList(17);\n    Iterator outerKeys = caches.keySet().iterator();\n    while (outerKeys.hasNext()) {\n      Class cacheType = (Class)outerKeys.next();\n      Cache cache = (Cache)caches.get(cacheType);\n      Iterator innerKeys = cache.readerCache.keySet().iterator();\n      while (innerKeys.hasNext()) {\n        // we've now materialized a hard ref\n        Object readerKey = innerKeys.next();\n        // innerKeys was backed by WeakHashMap, sanity check\n        // that it wasn't GCed before we made hard ref\n        if (null != readerKey && cache.readerCache.containsKey(readerKey)) {\n          Map innerCache = ((Map)cache.readerCache.get(readerKey));\n          Iterator keys = innerCache.keySet().iterator();\n          while (keys.hasNext()) {\n            Entry entry = (Entry) keys.next();\n            result.add(new CacheEntryImpl(readerKey, entry.field,\n                                          cacheType, entry.type,\n                                          entry.custom, entry.locale,\n                                          innerCache.get(entry)));\n          }\n        }\n      }\n    }\n    return (CacheEntry[]) result.toArray(new CacheEntry[result.size()]);\n  }\n\n","bugFix":null,"bugIntro":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"acf1430d6ee3e9aabb3279506194b6481881e472","date":1255445122,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FieldCacheImpl#getCacheEntries().mjava","pathOld":"src/java/org/apache/lucene/search/FieldCacheImpl#getCacheEntries().mjava","sourceNew":"  public CacheEntry[] getCacheEntries() {\n    List result = new ArrayList(17);\n    Iterator outerKeys = caches.keySet().iterator();\n    while (outerKeys.hasNext()) {\n      Class cacheType = (Class)outerKeys.next();\n      Cache cache = (Cache)caches.get(cacheType);\n      Iterator innerKeys = cache.readerCache.keySet().iterator();\n      while (innerKeys.hasNext()) {\n        // we've now materialized a hard ref\n        Object readerKey = innerKeys.next();\n        // innerKeys was backed by WeakHashMap, sanity check\n        // that it wasn't GCed before we made hard ref\n        if (null != readerKey && cache.readerCache.containsKey(readerKey)) {\n          Map innerCache = ((Map)cache.readerCache.get(readerKey));\n          Iterator entrySetIterator = innerCache.entrySet().iterator();\n          while (entrySetIterator.hasNext()) {\n            Map.Entry mapEntry = (Map.Entry) entrySetIterator.next();\n            Entry entry = (Entry) mapEntry.getKey();\n            result.add(new CacheEntryImpl(readerKey, entry.field,\n                                          cacheType, entry.custom,\n                                          mapEntry.getValue()));\n          }\n        }\n      }\n    }\n    return (CacheEntry[]) result.toArray(new CacheEntry[result.size()]);\n  }\n\n","sourceOld":"  public CacheEntry[] getCacheEntries() {\n    List result = new ArrayList(17);\n    Iterator outerKeys = caches.keySet().iterator();\n    while (outerKeys.hasNext()) {\n      Class cacheType = (Class)outerKeys.next();\n      Cache cache = (Cache)caches.get(cacheType);\n      Iterator innerKeys = cache.readerCache.keySet().iterator();\n      while (innerKeys.hasNext()) {\n        // we've now materialized a hard ref\n        Object readerKey = innerKeys.next();\n        // innerKeys was backed by WeakHashMap, sanity check\n        // that it wasn't GCed before we made hard ref\n        if (null != readerKey && cache.readerCache.containsKey(readerKey)) {\n          Map innerCache = ((Map)cache.readerCache.get(readerKey));\n          Iterator entrySetIterator = innerCache.entrySet().iterator();\n          while (entrySetIterator.hasNext()) {\n            Map.Entry mapEntry = (Map.Entry) entrySetIterator.next();\n            Entry entry = (Entry) mapEntry.getKey();\n            result.add(new CacheEntryImpl(readerKey, entry.field,\n                                          cacheType, entry.type,\n                                          entry.custom, entry.locale,\n                                          mapEntry.getValue()));\n          }\n        }\n      }\n    }\n    return (CacheEntry[]) result.toArray(new CacheEntry[result.size()]);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"20ff1ff2aa6f91149e9cd75f65a56fbdda5266ce","date":1255993146,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FieldCacheImpl#getCacheEntries().mjava","pathOld":"src/java/org/apache/lucene/search/FieldCacheImpl#getCacheEntries().mjava","sourceNew":"  public CacheEntry[] getCacheEntries() {\n    List<CacheEntry> result = new ArrayList<CacheEntry>(17);\n    for(final Class<?> cacheType: caches.keySet()) {\n      Cache cache = caches.get(cacheType);\n      for (final Object readerKey : cache.readerCache.keySet()) {\n        // we've now materialized a hard ref\n        \n        // innerKeys was backed by WeakHashMap, sanity check\n        // that it wasn't GCed before we made hard ref\n        if (null != readerKey && cache.readerCache.containsKey(readerKey)) {\n          Map<Entry, Object> innerCache = cache.readerCache.get(readerKey);\n          for (final Map.Entry<Entry, Object> mapEntry : innerCache.entrySet()) {\n            Entry entry = mapEntry.getKey();\n            result.add(new CacheEntryImpl(readerKey, entry.field,\n                                          cacheType, entry.custom,\n                                          mapEntry.getValue()));\n          }\n        }\n      }\n    }\n    return result.toArray(new CacheEntry[result.size()]);\n  }\n\n","sourceOld":"  public CacheEntry[] getCacheEntries() {\n    List result = new ArrayList(17);\n    Iterator outerKeys = caches.keySet().iterator();\n    while (outerKeys.hasNext()) {\n      Class cacheType = (Class)outerKeys.next();\n      Cache cache = (Cache)caches.get(cacheType);\n      Iterator innerKeys = cache.readerCache.keySet().iterator();\n      while (innerKeys.hasNext()) {\n        // we've now materialized a hard ref\n        Object readerKey = innerKeys.next();\n        // innerKeys was backed by WeakHashMap, sanity check\n        // that it wasn't GCed before we made hard ref\n        if (null != readerKey && cache.readerCache.containsKey(readerKey)) {\n          Map innerCache = ((Map)cache.readerCache.get(readerKey));\n          Iterator entrySetIterator = innerCache.entrySet().iterator();\n          while (entrySetIterator.hasNext()) {\n            Map.Entry mapEntry = (Map.Entry) entrySetIterator.next();\n            Entry entry = (Entry) mapEntry.getKey();\n            result.add(new CacheEntryImpl(readerKey, entry.field,\n                                          cacheType, entry.custom,\n                                          mapEntry.getValue()));\n          }\n        }\n      }\n    }\n    return (CacheEntry[]) result.toArray(new CacheEntry[result.size()]);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ec6d293ef8a20772c2e0c9274d41e2001deb94a3","date":1266751002,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FieldCacheImpl#getCacheEntries().mjava","pathOld":"src/java/org/apache/lucene/search/FieldCacheImpl#getCacheEntries().mjava","sourceNew":"  public synchronized CacheEntry[] getCacheEntries() {\n    List<CacheEntry> result = new ArrayList<CacheEntry>(17);\n    for(final Map.Entry<Class<?>,Cache> cacheEntry: caches.entrySet()) {\n      final Cache cache = cacheEntry.getValue();\n      final Class<?> cacheType = cacheEntry.getKey();\n      synchronized(cache.readerCache) {\n        for (final Map.Entry<Object,Map<Entry, Object>> readerCacheEntry : cache.readerCache.entrySet()) {\n          final Object readerKey = readerCacheEntry.getKey();\n          final Map<Entry, Object> innerCache = readerCacheEntry.getValue();\n          for (final Map.Entry<Entry, Object> mapEntry : innerCache.entrySet()) {\n            Entry entry = mapEntry.getKey();\n            result.add(new CacheEntryImpl(readerKey, entry.field,\n                                          cacheType, entry.custom,\n                                          mapEntry.getValue()));\n          }\n        }\n      }\n    }\n    return result.toArray(new CacheEntry[result.size()]);\n  }\n\n","sourceOld":"  public CacheEntry[] getCacheEntries() {\n    List<CacheEntry> result = new ArrayList<CacheEntry>(17);\n    for(final Class<?> cacheType: caches.keySet()) {\n      Cache cache = caches.get(cacheType);\n      for (final Object readerKey : cache.readerCache.keySet()) {\n        // we've now materialized a hard ref\n        \n        // innerKeys was backed by WeakHashMap, sanity check\n        // that it wasn't GCed before we made hard ref\n        if (null != readerKey && cache.readerCache.containsKey(readerKey)) {\n          Map<Entry, Object> innerCache = cache.readerCache.get(readerKey);\n          for (final Map.Entry<Entry, Object> mapEntry : innerCache.entrySet()) {\n            Entry entry = mapEntry.getKey();\n            result.add(new CacheEntryImpl(readerKey, entry.field,\n                                          cacheType, entry.custom,\n                                          mapEntry.getValue()));\n          }\n        }\n      }\n    }\n    return result.toArray(new CacheEntry[result.size()]);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c7743452081f24a080e3c4e206ac2c2103f46b67","date":1266751233,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FieldCacheImpl#getCacheEntries().mjava","pathOld":"src/java/org/apache/lucene/search/FieldCacheImpl#getCacheEntries().mjava","sourceNew":"  public synchronized CacheEntry[] getCacheEntries() {\n    List<CacheEntry> result = new ArrayList<CacheEntry>(17);\n    for(final Map.Entry<Class<?>,Cache> cacheEntry: caches.entrySet()) {\n      final Cache cache = cacheEntry.getValue();\n      final Class<?> cacheType = cacheEntry.getKey();\n      synchronized(cache.readerCache) {\n        for (final Map.Entry<Object,Map<Entry, Object>> readerCacheEntry : cache.readerCache.entrySet()) {\n          final Object readerKey = readerCacheEntry.getKey();\n          if (readerKey == null) continue;\n          final Map<Entry, Object> innerCache = readerCacheEntry.getValue();\n          for (final Map.Entry<Entry, Object> mapEntry : innerCache.entrySet()) {\n            Entry entry = mapEntry.getKey();\n            result.add(new CacheEntryImpl(readerKey, entry.field,\n                                          cacheType, entry.custom,\n                                          mapEntry.getValue()));\n          }\n        }\n      }\n    }\n    return result.toArray(new CacheEntry[result.size()]);\n  }\n\n","sourceOld":"  public synchronized CacheEntry[] getCacheEntries() {\n    List<CacheEntry> result = new ArrayList<CacheEntry>(17);\n    for(final Map.Entry<Class<?>,Cache> cacheEntry: caches.entrySet()) {\n      final Cache cache = cacheEntry.getValue();\n      final Class<?> cacheType = cacheEntry.getKey();\n      synchronized(cache.readerCache) {\n        for (final Map.Entry<Object,Map<Entry, Object>> readerCacheEntry : cache.readerCache.entrySet()) {\n          final Object readerKey = readerCacheEntry.getKey();\n          final Map<Entry, Object> innerCache = readerCacheEntry.getValue();\n          for (final Map.Entry<Entry, Object> mapEntry : innerCache.entrySet()) {\n            Entry entry = mapEntry.getKey();\n            result.add(new CacheEntryImpl(readerKey, entry.field,\n                                          cacheType, entry.custom,\n                                          mapEntry.getValue()));\n          }\n        }\n      }\n    }\n    return result.toArray(new CacheEntry[result.size()]);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/FieldCacheImpl#getCacheEntries().mjava","pathOld":"src/java/org/apache/lucene/search/FieldCacheImpl#getCacheEntries().mjava","sourceNew":"  public synchronized CacheEntry[] getCacheEntries() {\n    List<CacheEntry> result = new ArrayList<CacheEntry>(17);\n    for(final Map.Entry<Class<?>,Cache> cacheEntry: caches.entrySet()) {\n      final Cache cache = cacheEntry.getValue();\n      final Class<?> cacheType = cacheEntry.getKey();\n      synchronized(cache.readerCache) {\n        for (final Map.Entry<Object,Map<Entry, Object>> readerCacheEntry : cache.readerCache.entrySet()) {\n          final Object readerKey = readerCacheEntry.getKey();\n          if (readerKey == null) continue;\n          final Map<Entry, Object> innerCache = readerCacheEntry.getValue();\n          for (final Map.Entry<Entry, Object> mapEntry : innerCache.entrySet()) {\n            Entry entry = mapEntry.getKey();\n            result.add(new CacheEntryImpl(readerKey, entry.field,\n                                          cacheType, entry.custom,\n                                          mapEntry.getValue()));\n          }\n        }\n      }\n    }\n    return result.toArray(new CacheEntry[result.size()]);\n  }\n\n","sourceOld":"  public synchronized CacheEntry[] getCacheEntries() {\n    List<CacheEntry> result = new ArrayList<CacheEntry>(17);\n    for(final Map.Entry<Class<?>,Cache> cacheEntry: caches.entrySet()) {\n      final Cache cache = cacheEntry.getValue();\n      final Class<?> cacheType = cacheEntry.getKey();\n      synchronized(cache.readerCache) {\n        for (final Map.Entry<Object,Map<Entry, Object>> readerCacheEntry : cache.readerCache.entrySet()) {\n          final Object readerKey = readerCacheEntry.getKey();\n          if (readerKey == null) continue;\n          final Map<Entry, Object> innerCache = readerCacheEntry.getValue();\n          for (final Map.Entry<Entry, Object> mapEntry : innerCache.entrySet()) {\n            Entry entry = mapEntry.getKey();\n            result.add(new CacheEntryImpl(readerKey, entry.field,\n                                          cacheType, entry.custom,\n                                          mapEntry.getValue()));\n          }\n        }\n      }\n    }\n    return result.toArray(new CacheEntry[result.size()]);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"63a3cd934de70be8201bb9ab57198e3fb5c8985f":["e69f59b863731d864bf3047235e718f0f88f8841"],"c7743452081f24a080e3c4e206ac2c2103f46b67":["ec6d293ef8a20772c2e0c9274d41e2001deb94a3"],"ec6d293ef8a20772c2e0c9274d41e2001deb94a3":["20ff1ff2aa6f91149e9cd75f65a56fbdda5266ce"],"acf1430d6ee3e9aabb3279506194b6481881e472":["63a3cd934de70be8201bb9ab57198e3fb5c8985f"],"e69f59b863731d864bf3047235e718f0f88f8841":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"20ff1ff2aa6f91149e9cd75f65a56fbdda5266ce":["acf1430d6ee3e9aabb3279506194b6481881e472"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["c7743452081f24a080e3c4e206ac2c2103f46b67"]},"commit2Childs":{"63a3cd934de70be8201bb9ab57198e3fb5c8985f":["acf1430d6ee3e9aabb3279506194b6481881e472"],"c7743452081f24a080e3c4e206ac2c2103f46b67":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"ec6d293ef8a20772c2e0c9274d41e2001deb94a3":["c7743452081f24a080e3c4e206ac2c2103f46b67"],"acf1430d6ee3e9aabb3279506194b6481881e472":["20ff1ff2aa6f91149e9cd75f65a56fbdda5266ce"],"e69f59b863731d864bf3047235e718f0f88f8841":["63a3cd934de70be8201bb9ab57198e3fb5c8985f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e69f59b863731d864bf3047235e718f0f88f8841"],"20ff1ff2aa6f91149e9cd75f65a56fbdda5266ce":["ec6d293ef8a20772c2e0c9274d41e2001deb94a3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}