{"path":"lucene/core/src/test/org/apache/lucene/geo/TestGeoUtils#testRandomCircleToBBox().mjava","commits":[{"id":"546f71f5b1e19230d6e7e59f117d08dbcf59fbfe","date":1459623422,"type":1,"author":"nknize","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/geo/TestGeoUtils#testRandomCircleToBBox().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/util/TestGeoUtils#testRandomCircleToBBox().mjava","sourceNew":"  // We rely heavily on GeoUtils.circleToBBox so we test it here:\n  public void testRandomCircleToBBox() throws Exception {\n    int iters = atLeast(1000);\n    for(int iter=0;iter<iters;iter++) {\n\n      boolean useSmallRanges = random().nextBoolean();\n\n      double radiusMeters;\n\n      double centerLat = randomLat(useSmallRanges);\n      double centerLon = randomLon(useSmallRanges);\n\n      if (useSmallRanges) {\n        // Approx 4 degrees lon at the equator:\n        radiusMeters = random().nextDouble() * 444000;\n      } else {\n        radiusMeters = random().nextDouble() * 50000000;\n      }\n\n      // TODO: randomly quantize radius too, to provoke exact math errors?\n\n      Rectangle bbox = Rectangle.fromPointDistance(centerLat, centerLon, radiusMeters);\n\n      int numPointsToTry = 1000;\n      for(int i=0;i<numPointsToTry;i++) {\n\n        double lat;\n        double lon;\n\n        if (random().nextBoolean()) {\n          lat = randomLat(useSmallRanges);\n          lon = randomLon(useSmallRanges);\n        } else {\n          // pick a lat/lon within the bbox or \"slightly\" outside it to try to improve test efficiency\n          lat = GeoTestUtil.nextLatitudeAround(bbox.minLat, bbox.maxLat);\n          if (bbox.crossesDateline()) {\n            if (random().nextBoolean()) {\n              lon = GeoTestUtil.nextLongitudeAround(bbox.maxLon, -180);\n            } else {\n              lon = GeoTestUtil.nextLongitudeAround(0, bbox.minLon);\n            }\n          } else {\n            lon = GeoTestUtil.nextLongitudeAround(bbox.minLon, bbox.maxLon);\n          }\n        }\n\n        double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, lat, lon);\n\n        // Haversin says it's within the circle:\n        boolean haversinSays = distanceMeters <= radiusMeters;\n\n        // BBox says its within the box:\n        boolean bboxSays;\n        if (bbox.crossesDateline()) {\n          if (lat >= bbox.minLat && lat <= bbox.maxLat) {\n            bboxSays = lon <= bbox.maxLon || lon >= bbox.minLon;\n          } else {\n            bboxSays = false;\n          }\n        } else {\n          bboxSays = lat >= bbox.minLat && lat <= bbox.maxLat && lon >= bbox.minLon && lon <= bbox.maxLon;\n        }\n\n        if (haversinSays) {\n          if (bboxSays == false) {\n            System.out.println(\"small=\" + useSmallRanges + \" centerLat=\" + centerLat + \" cetnerLon=\" + centerLon + \" radiusMeters=\" + radiusMeters);\n            System.out.println(\"  bbox: lat=\" + bbox.minLat + \" to \" + bbox.maxLat + \" lon=\" + bbox.minLon + \" to \" + bbox.maxLon);\n            System.out.println(\"  point: lat=\" + lat + \" lon=\" + lon);\n            System.out.println(\"  haversin: \" + distanceMeters);\n            fail(\"point was within the distance according to haversin, but the bbox doesn't contain it\");\n          }\n        } else {\n          // it's fine if haversin said it was outside the radius and bbox said it was inside the box\n        }\n      }\n    }\n  }\n\n","sourceOld":"  // We rely heavily on GeoUtils.circleToBBox so we test it here:\n  public void testRandomCircleToBBox() throws Exception {\n    int iters = atLeast(1000);\n    for(int iter=0;iter<iters;iter++) {\n\n      boolean useSmallRanges = random().nextBoolean();\n\n      double radiusMeters;\n\n      double centerLat = randomLat(useSmallRanges);\n      double centerLon = randomLon(useSmallRanges);\n\n      if (useSmallRanges) {\n        // Approx 4 degrees lon at the equator:\n        radiusMeters = random().nextDouble() * 444000;\n      } else {\n        radiusMeters = random().nextDouble() * 50000000;\n      }\n\n      // TODO: randomly quantize radius too, to provoke exact math errors?\n\n      GeoRect bbox = GeoRect.fromPointDistance(centerLat, centerLon, radiusMeters);\n\n      int numPointsToTry = 1000;\n      for(int i=0;i<numPointsToTry;i++) {\n\n        double lat;\n        double lon;\n\n        if (random().nextBoolean()) {\n          lat = randomLat(useSmallRanges);\n          lon = randomLon(useSmallRanges);\n        } else {\n          // pick a lat/lon within the bbox or \"slightly\" outside it to try to improve test efficiency\n          lat = GeoTestUtil.nextLatitudeAround(bbox.minLat, bbox.maxLat);\n          if (bbox.crossesDateline()) {\n            if (random().nextBoolean()) {\n              lon = GeoTestUtil.nextLongitudeAround(bbox.maxLon, -180);\n            } else {\n              lon = GeoTestUtil.nextLongitudeAround(0, bbox.minLon);\n            }\n          } else {\n            lon = GeoTestUtil.nextLongitudeAround(bbox.minLon, bbox.maxLon);\n          }\n        }\n\n        double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, lat, lon);\n\n        // Haversin says it's within the circle:\n        boolean haversinSays = distanceMeters <= radiusMeters;\n\n        // BBox says its within the box:\n        boolean bboxSays;\n        if (bbox.crossesDateline()) {\n          if (lat >= bbox.minLat && lat <= bbox.maxLat) {\n            bboxSays = lon <= bbox.maxLon || lon >= bbox.minLon;\n          } else {\n            bboxSays = false;\n          }\n        } else {\n          bboxSays = lat >= bbox.minLat && lat <= bbox.maxLat && lon >= bbox.minLon && lon <= bbox.maxLon;\n        }\n\n        if (haversinSays) {\n          if (bboxSays == false) {\n            System.out.println(\"small=\" + useSmallRanges + \" centerLat=\" + centerLat + \" cetnerLon=\" + centerLon + \" radiusMeters=\" + radiusMeters);\n            System.out.println(\"  bbox: lat=\" + bbox.minLat + \" to \" + bbox.maxLat + \" lon=\" + bbox.minLon + \" to \" + bbox.maxLon);\n            System.out.println(\"  point: lat=\" + lat + \" lon=\" + lon);\n            System.out.println(\"  haversin: \" + distanceMeters);\n            fail(\"point was within the distance according to haversin, but the bbox doesn't contain it\");\n          }\n        } else {\n          // it's fine if haversin said it was outside the radius and bbox said it was inside the box\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3542cf82b8acd1e9ff2ee90fb0bf35e08698a1c2","date":1460953142,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/geo/TestGeoUtils#testRandomCircleToBBox().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/geo/TestGeoUtils#testRandomCircleToBBox().mjava","sourceNew":"  // We rely heavily on GeoUtils.circleToBBox so we test it here:\n  public void testRandomCircleToBBox() throws Exception {\n    int iters = atLeast(1000);\n    for(int iter=0;iter<iters;iter++) {\n\n      double centerLat = GeoTestUtil.nextLatitude();\n      double centerLon = GeoTestUtil.nextLongitude();\n\n      final double radiusMeters;\n      if (random().nextBoolean()) {\n        // Approx 4 degrees lon at the equator:\n        radiusMeters = random().nextDouble() * 444000;\n      } else {\n        radiusMeters = random().nextDouble() * 50000000;\n      }\n\n      // TODO: randomly quantize radius too, to provoke exact math errors?\n\n      Rectangle bbox = Rectangle.fromPointDistance(centerLat, centerLon, radiusMeters);\n\n      int numPointsToTry = 1000;\n      for(int i=0;i<numPointsToTry;i++) {\n\n        double point[] = GeoTestUtil.nextPointNear(bbox);\n        double lat = point[0];\n        double lon = point[1];\n\n        double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, lat, lon);\n\n        // Haversin says it's within the circle:\n        boolean haversinSays = distanceMeters <= radiusMeters;\n\n        // BBox says its within the box:\n        boolean bboxSays;\n        if (bbox.crossesDateline()) {\n          if (lat >= bbox.minLat && lat <= bbox.maxLat) {\n            bboxSays = lon <= bbox.maxLon || lon >= bbox.minLon;\n          } else {\n            bboxSays = false;\n          }\n        } else {\n          bboxSays = lat >= bbox.minLat && lat <= bbox.maxLat && lon >= bbox.minLon && lon <= bbox.maxLon;\n        }\n\n        if (haversinSays) {\n          if (bboxSays == false) {\n            System.out.println(\"centerLat=\" + centerLat + \" centerLon=\" + centerLon + \" radiusMeters=\" + radiusMeters);\n            System.out.println(\"  bbox: lat=\" + bbox.minLat + \" to \" + bbox.maxLat + \" lon=\" + bbox.minLon + \" to \" + bbox.maxLon);\n            System.out.println(\"  point: lat=\" + lat + \" lon=\" + lon);\n            System.out.println(\"  haversin: \" + distanceMeters);\n            fail(\"point was within the distance according to haversin, but the bbox doesn't contain it\");\n          }\n        } else {\n          // it's fine if haversin said it was outside the radius and bbox said it was inside the box\n        }\n      }\n    }\n  }\n\n","sourceOld":"  // We rely heavily on GeoUtils.circleToBBox so we test it here:\n  public void testRandomCircleToBBox() throws Exception {\n    int iters = atLeast(1000);\n    for(int iter=0;iter<iters;iter++) {\n\n      boolean useSmallRanges = random().nextBoolean();\n\n      double radiusMeters;\n\n      double centerLat = randomLat(useSmallRanges);\n      double centerLon = randomLon(useSmallRanges);\n\n      if (useSmallRanges) {\n        // Approx 4 degrees lon at the equator:\n        radiusMeters = random().nextDouble() * 444000;\n      } else {\n        radiusMeters = random().nextDouble() * 50000000;\n      }\n\n      // TODO: randomly quantize radius too, to provoke exact math errors?\n\n      Rectangle bbox = Rectangle.fromPointDistance(centerLat, centerLon, radiusMeters);\n\n      int numPointsToTry = 1000;\n      for(int i=0;i<numPointsToTry;i++) {\n\n        double lat;\n        double lon;\n\n        if (random().nextBoolean()) {\n          lat = randomLat(useSmallRanges);\n          lon = randomLon(useSmallRanges);\n        } else {\n          // pick a lat/lon within the bbox or \"slightly\" outside it to try to improve test efficiency\n          lat = GeoTestUtil.nextLatitudeAround(bbox.minLat, bbox.maxLat);\n          if (bbox.crossesDateline()) {\n            if (random().nextBoolean()) {\n              lon = GeoTestUtil.nextLongitudeAround(bbox.maxLon, -180);\n            } else {\n              lon = GeoTestUtil.nextLongitudeAround(0, bbox.minLon);\n            }\n          } else {\n            lon = GeoTestUtil.nextLongitudeAround(bbox.minLon, bbox.maxLon);\n          }\n        }\n\n        double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, lat, lon);\n\n        // Haversin says it's within the circle:\n        boolean haversinSays = distanceMeters <= radiusMeters;\n\n        // BBox says its within the box:\n        boolean bboxSays;\n        if (bbox.crossesDateline()) {\n          if (lat >= bbox.minLat && lat <= bbox.maxLat) {\n            bboxSays = lon <= bbox.maxLon || lon >= bbox.minLon;\n          } else {\n            bboxSays = false;\n          }\n        } else {\n          bboxSays = lat >= bbox.minLat && lat <= bbox.maxLat && lon >= bbox.minLon && lon <= bbox.maxLon;\n        }\n\n        if (haversinSays) {\n          if (bboxSays == false) {\n            System.out.println(\"small=\" + useSmallRanges + \" centerLat=\" + centerLat + \" cetnerLon=\" + centerLon + \" radiusMeters=\" + radiusMeters);\n            System.out.println(\"  bbox: lat=\" + bbox.minLat + \" to \" + bbox.maxLat + \" lon=\" + bbox.minLon + \" to \" + bbox.maxLon);\n            System.out.println(\"  point: lat=\" + lat + \" lon=\" + lon);\n            System.out.println(\"  haversin: \" + distanceMeters);\n            fail(\"point was within the distance according to haversin, but the bbox doesn't contain it\");\n          }\n        } else {\n          // it's fine if haversin said it was outside the radius and bbox said it was inside the box\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"713122036535651642e6d4fe57ce12b449e18473","date":1461000510,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/geo/TestGeoUtils#testRandomCircleToBBox().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/geo/TestGeoUtils#testRandomCircleToBBox().mjava","sourceNew":"  // We rely heavily on GeoUtils.circleToBBox so we test it here:\n  public void testRandomCircleToBBox() throws Exception {\n    int iters = atLeast(1000);\n    for(int iter=0;iter<iters;iter++) {\n\n      double centerLat = GeoTestUtil.nextLatitude();\n      double centerLon = GeoTestUtil.nextLongitude();\n\n      final double radiusMeters;\n      if (random().nextBoolean()) {\n        // Approx 4 degrees lon at the equator:\n        radiusMeters = random().nextDouble() * 444000;\n      } else {\n        radiusMeters = random().nextDouble() * 50000000;\n      }\n\n      // TODO: randomly quantize radius too, to provoke exact math errors?\n\n      Rectangle bbox = Rectangle.fromPointDistance(centerLat, centerLon, radiusMeters);\n\n      int numPointsToTry = 1000;\n      for(int i=0;i<numPointsToTry;i++) {\n\n        double point[] = GeoTestUtil.nextPointNear(bbox);\n        double lat = point[0];\n        double lon = point[1];\n\n        double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, lat, lon);\n\n        // Haversin says it's within the circle:\n        boolean haversinSays = distanceMeters <= radiusMeters;\n\n        // BBox says its within the box:\n        boolean bboxSays;\n        if (bbox.crossesDateline()) {\n          if (lat >= bbox.minLat && lat <= bbox.maxLat) {\n            bboxSays = lon <= bbox.maxLon || lon >= bbox.minLon;\n          } else {\n            bboxSays = false;\n          }\n        } else {\n          bboxSays = lat >= bbox.minLat && lat <= bbox.maxLat && lon >= bbox.minLon && lon <= bbox.maxLon;\n        }\n\n        if (haversinSays) {\n          if (bboxSays == false) {\n            System.out.println(\"centerLat=\" + centerLat + \" centerLon=\" + centerLon + \" radiusMeters=\" + radiusMeters);\n            System.out.println(\"  bbox: lat=\" + bbox.minLat + \" to \" + bbox.maxLat + \" lon=\" + bbox.minLon + \" to \" + bbox.maxLon);\n            System.out.println(\"  point: lat=\" + lat + \" lon=\" + lon);\n            System.out.println(\"  haversin: \" + distanceMeters);\n            fail(\"point was within the distance according to haversin, but the bbox doesn't contain it\");\n          }\n        } else {\n          // it's fine if haversin said it was outside the radius and bbox said it was inside the box\n        }\n      }\n    }\n  }\n\n","sourceOld":"  // We rely heavily on GeoUtils.circleToBBox so we test it here:\n  public void testRandomCircleToBBox() throws Exception {\n    int iters = atLeast(1000);\n    for(int iter=0;iter<iters;iter++) {\n\n      boolean useSmallRanges = random().nextBoolean();\n\n      double radiusMeters;\n\n      double centerLat = randomLat(useSmallRanges);\n      double centerLon = randomLon(useSmallRanges);\n\n      if (useSmallRanges) {\n        // Approx 4 degrees lon at the equator:\n        radiusMeters = random().nextDouble() * 444000;\n      } else {\n        radiusMeters = random().nextDouble() * 50000000;\n      }\n\n      // TODO: randomly quantize radius too, to provoke exact math errors?\n\n      Rectangle bbox = Rectangle.fromPointDistance(centerLat, centerLon, radiusMeters);\n\n      int numPointsToTry = 1000;\n      for(int i=0;i<numPointsToTry;i++) {\n\n        double lat;\n        double lon;\n\n        if (random().nextBoolean()) {\n          lat = randomLat(useSmallRanges);\n          lon = randomLon(useSmallRanges);\n        } else {\n          // pick a lat/lon within the bbox or \"slightly\" outside it to try to improve test efficiency\n          lat = GeoTestUtil.nextLatitudeAround(bbox.minLat, bbox.maxLat);\n          if (bbox.crossesDateline()) {\n            if (random().nextBoolean()) {\n              lon = GeoTestUtil.nextLongitudeAround(bbox.maxLon, -180);\n            } else {\n              lon = GeoTestUtil.nextLongitudeAround(0, bbox.minLon);\n            }\n          } else {\n            lon = GeoTestUtil.nextLongitudeAround(bbox.minLon, bbox.maxLon);\n          }\n        }\n\n        double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, lat, lon);\n\n        // Haversin says it's within the circle:\n        boolean haversinSays = distanceMeters <= radiusMeters;\n\n        // BBox says its within the box:\n        boolean bboxSays;\n        if (bbox.crossesDateline()) {\n          if (lat >= bbox.minLat && lat <= bbox.maxLat) {\n            bboxSays = lon <= bbox.maxLon || lon >= bbox.minLon;\n          } else {\n            bboxSays = false;\n          }\n        } else {\n          bboxSays = lat >= bbox.minLat && lat <= bbox.maxLat && lon >= bbox.minLon && lon <= bbox.maxLon;\n        }\n\n        if (haversinSays) {\n          if (bboxSays == false) {\n            System.out.println(\"small=\" + useSmallRanges + \" centerLat=\" + centerLat + \" cetnerLon=\" + centerLon + \" radiusMeters=\" + radiusMeters);\n            System.out.println(\"  bbox: lat=\" + bbox.minLat + \" to \" + bbox.maxLat + \" lon=\" + bbox.minLon + \" to \" + bbox.maxLon);\n            System.out.println(\"  point: lat=\" + lat + \" lon=\" + lon);\n            System.out.println(\"  haversin: \" + distanceMeters);\n            fail(\"point was within the distance according to haversin, but the bbox doesn't contain it\");\n          }\n        } else {\n          // it's fine if haversin said it was outside the radius and bbox said it was inside the box\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9dea8da13fd1a227ae1071e8f4ce66bff42174de","date":1471439735,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/geo/TestGeoUtils#testRandomCircleToBBox().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/geo/TestGeoUtils#testRandomCircleToBBox().mjava","sourceNew":"  // We rely heavily on GeoUtils.circleToBBox so we test it here:\n  public void testRandomCircleToBBox() throws Exception {\n    int iters = atLeast(100);\n    for(int iter=0;iter<iters;iter++) {\n\n      double centerLat = GeoTestUtil.nextLatitude();\n      double centerLon = GeoTestUtil.nextLongitude();\n\n      final double radiusMeters;\n      if (random().nextBoolean()) {\n        // Approx 4 degrees lon at the equator:\n        radiusMeters = random().nextDouble() * 444000;\n      } else {\n        radiusMeters = random().nextDouble() * 50000000;\n      }\n\n      // TODO: randomly quantize radius too, to provoke exact math errors?\n\n      Rectangle bbox = Rectangle.fromPointDistance(centerLat, centerLon, radiusMeters);\n\n      int numPointsToTry = 1000;\n      for(int i=0;i<numPointsToTry;i++) {\n\n        double point[] = GeoTestUtil.nextPointNear(bbox);\n        double lat = point[0];\n        double lon = point[1];\n\n        double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, lat, lon);\n\n        // Haversin says it's within the circle:\n        boolean haversinSays = distanceMeters <= radiusMeters;\n\n        // BBox says its within the box:\n        boolean bboxSays;\n        if (bbox.crossesDateline()) {\n          if (lat >= bbox.minLat && lat <= bbox.maxLat) {\n            bboxSays = lon <= bbox.maxLon || lon >= bbox.minLon;\n          } else {\n            bboxSays = false;\n          }\n        } else {\n          bboxSays = lat >= bbox.minLat && lat <= bbox.maxLat && lon >= bbox.minLon && lon <= bbox.maxLon;\n        }\n\n        if (haversinSays) {\n          if (bboxSays == false) {\n            System.out.println(\"centerLat=\" + centerLat + \" centerLon=\" + centerLon + \" radiusMeters=\" + radiusMeters);\n            System.out.println(\"  bbox: lat=\" + bbox.minLat + \" to \" + bbox.maxLat + \" lon=\" + bbox.minLon + \" to \" + bbox.maxLon);\n            System.out.println(\"  point: lat=\" + lat + \" lon=\" + lon);\n            System.out.println(\"  haversin: \" + distanceMeters);\n            fail(\"point was within the distance according to haversin, but the bbox doesn't contain it\");\n          }\n        } else {\n          // it's fine if haversin said it was outside the radius and bbox said it was inside the box\n        }\n      }\n    }\n  }\n\n","sourceOld":"  // We rely heavily on GeoUtils.circleToBBox so we test it here:\n  public void testRandomCircleToBBox() throws Exception {\n    int iters = atLeast(1000);\n    for(int iter=0;iter<iters;iter++) {\n\n      double centerLat = GeoTestUtil.nextLatitude();\n      double centerLon = GeoTestUtil.nextLongitude();\n\n      final double radiusMeters;\n      if (random().nextBoolean()) {\n        // Approx 4 degrees lon at the equator:\n        radiusMeters = random().nextDouble() * 444000;\n      } else {\n        radiusMeters = random().nextDouble() * 50000000;\n      }\n\n      // TODO: randomly quantize radius too, to provoke exact math errors?\n\n      Rectangle bbox = Rectangle.fromPointDistance(centerLat, centerLon, radiusMeters);\n\n      int numPointsToTry = 1000;\n      for(int i=0;i<numPointsToTry;i++) {\n\n        double point[] = GeoTestUtil.nextPointNear(bbox);\n        double lat = point[0];\n        double lon = point[1];\n\n        double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, lat, lon);\n\n        // Haversin says it's within the circle:\n        boolean haversinSays = distanceMeters <= radiusMeters;\n\n        // BBox says its within the box:\n        boolean bboxSays;\n        if (bbox.crossesDateline()) {\n          if (lat >= bbox.minLat && lat <= bbox.maxLat) {\n            bboxSays = lon <= bbox.maxLon || lon >= bbox.minLon;\n          } else {\n            bboxSays = false;\n          }\n        } else {\n          bboxSays = lat >= bbox.minLat && lat <= bbox.maxLat && lon >= bbox.minLon && lon <= bbox.maxLon;\n        }\n\n        if (haversinSays) {\n          if (bboxSays == false) {\n            System.out.println(\"centerLat=\" + centerLat + \" centerLon=\" + centerLon + \" radiusMeters=\" + radiusMeters);\n            System.out.println(\"  bbox: lat=\" + bbox.minLat + \" to \" + bbox.maxLat + \" lon=\" + bbox.minLon + \" to \" + bbox.maxLon);\n            System.out.println(\"  point: lat=\" + lat + \" lon=\" + lon);\n            System.out.println(\"  haversin: \" + distanceMeters);\n            fail(\"point was within the distance according to haversin, but the bbox doesn't contain it\");\n          }\n        } else {\n          // it's fine if haversin said it was outside the radius and bbox said it was inside the box\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2c8bedceb91e64a3f0e831450058fc4a76d2c0a6","date":1471496851,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/geo/TestGeoUtils#testRandomCircleToBBox().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/geo/TestGeoUtils#testRandomCircleToBBox().mjava","sourceNew":"  // We rely heavily on GeoUtils.circleToBBox so we test it here:\n  public void testRandomCircleToBBox() throws Exception {\n    int iters = atLeast(100);\n    for(int iter=0;iter<iters;iter++) {\n\n      double centerLat = GeoTestUtil.nextLatitude();\n      double centerLon = GeoTestUtil.nextLongitude();\n\n      final double radiusMeters;\n      if (random().nextBoolean()) {\n        // Approx 4 degrees lon at the equator:\n        radiusMeters = random().nextDouble() * 444000;\n      } else {\n        radiusMeters = random().nextDouble() * 50000000;\n      }\n\n      // TODO: randomly quantize radius too, to provoke exact math errors?\n\n      Rectangle bbox = Rectangle.fromPointDistance(centerLat, centerLon, radiusMeters);\n\n      int numPointsToTry = 1000;\n      for(int i=0;i<numPointsToTry;i++) {\n\n        double point[] = GeoTestUtil.nextPointNear(bbox);\n        double lat = point[0];\n        double lon = point[1];\n\n        double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, lat, lon);\n\n        // Haversin says it's within the circle:\n        boolean haversinSays = distanceMeters <= radiusMeters;\n\n        // BBox says its within the box:\n        boolean bboxSays;\n        if (bbox.crossesDateline()) {\n          if (lat >= bbox.minLat && lat <= bbox.maxLat) {\n            bboxSays = lon <= bbox.maxLon || lon >= bbox.minLon;\n          } else {\n            bboxSays = false;\n          }\n        } else {\n          bboxSays = lat >= bbox.minLat && lat <= bbox.maxLat && lon >= bbox.minLon && lon <= bbox.maxLon;\n        }\n\n        if (haversinSays) {\n          if (bboxSays == false) {\n            System.out.println(\"centerLat=\" + centerLat + \" centerLon=\" + centerLon + \" radiusMeters=\" + radiusMeters);\n            System.out.println(\"  bbox: lat=\" + bbox.minLat + \" to \" + bbox.maxLat + \" lon=\" + bbox.minLon + \" to \" + bbox.maxLon);\n            System.out.println(\"  point: lat=\" + lat + \" lon=\" + lon);\n            System.out.println(\"  haversin: \" + distanceMeters);\n            fail(\"point was within the distance according to haversin, but the bbox doesn't contain it\");\n          }\n        } else {\n          // it's fine if haversin said it was outside the radius and bbox said it was inside the box\n        }\n      }\n    }\n  }\n\n","sourceOld":"  // We rely heavily on GeoUtils.circleToBBox so we test it here:\n  public void testRandomCircleToBBox() throws Exception {\n    int iters = atLeast(1000);\n    for(int iter=0;iter<iters;iter++) {\n\n      double centerLat = GeoTestUtil.nextLatitude();\n      double centerLon = GeoTestUtil.nextLongitude();\n\n      final double radiusMeters;\n      if (random().nextBoolean()) {\n        // Approx 4 degrees lon at the equator:\n        radiusMeters = random().nextDouble() * 444000;\n      } else {\n        radiusMeters = random().nextDouble() * 50000000;\n      }\n\n      // TODO: randomly quantize radius too, to provoke exact math errors?\n\n      Rectangle bbox = Rectangle.fromPointDistance(centerLat, centerLon, radiusMeters);\n\n      int numPointsToTry = 1000;\n      for(int i=0;i<numPointsToTry;i++) {\n\n        double point[] = GeoTestUtil.nextPointNear(bbox);\n        double lat = point[0];\n        double lon = point[1];\n\n        double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, lat, lon);\n\n        // Haversin says it's within the circle:\n        boolean haversinSays = distanceMeters <= radiusMeters;\n\n        // BBox says its within the box:\n        boolean bboxSays;\n        if (bbox.crossesDateline()) {\n          if (lat >= bbox.minLat && lat <= bbox.maxLat) {\n            bboxSays = lon <= bbox.maxLon || lon >= bbox.minLon;\n          } else {\n            bboxSays = false;\n          }\n        } else {\n          bboxSays = lat >= bbox.minLat && lat <= bbox.maxLat && lon >= bbox.minLon && lon <= bbox.maxLon;\n        }\n\n        if (haversinSays) {\n          if (bboxSays == false) {\n            System.out.println(\"centerLat=\" + centerLat + \" centerLon=\" + centerLon + \" radiusMeters=\" + radiusMeters);\n            System.out.println(\"  bbox: lat=\" + bbox.minLat + \" to \" + bbox.maxLat + \" lon=\" + bbox.minLon + \" to \" + bbox.maxLon);\n            System.out.println(\"  point: lat=\" + lat + \" lon=\" + lon);\n            System.out.println(\"  haversin: \" + distanceMeters);\n            fail(\"point was within the distance according to haversin, but the bbox doesn't contain it\");\n          }\n        } else {\n          // it's fine if haversin said it was outside the radius and bbox said it was inside the box\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"403d05f7f8d69b65659157eff1bc1d2717f04c66","date":1471692961,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/geo/TestGeoUtils#testRandomCircleToBBox().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/geo/TestGeoUtils#testRandomCircleToBBox().mjava","sourceNew":"  // We rely heavily on GeoUtils.circleToBBox so we test it here:\n  public void testRandomCircleToBBox() throws Exception {\n    int iters = atLeast(100);\n    for(int iter=0;iter<iters;iter++) {\n\n      double centerLat = GeoTestUtil.nextLatitude();\n      double centerLon = GeoTestUtil.nextLongitude();\n\n      final double radiusMeters;\n      if (random().nextBoolean()) {\n        // Approx 4 degrees lon at the equator:\n        radiusMeters = random().nextDouble() * 444000;\n      } else {\n        radiusMeters = random().nextDouble() * 50000000;\n      }\n\n      // TODO: randomly quantize radius too, to provoke exact math errors?\n\n      Rectangle bbox = Rectangle.fromPointDistance(centerLat, centerLon, radiusMeters);\n\n      int numPointsToTry = 1000;\n      for(int i=0;i<numPointsToTry;i++) {\n\n        double point[] = GeoTestUtil.nextPointNear(bbox);\n        double lat = point[0];\n        double lon = point[1];\n\n        double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, lat, lon);\n\n        // Haversin says it's within the circle:\n        boolean haversinSays = distanceMeters <= radiusMeters;\n\n        // BBox says its within the box:\n        boolean bboxSays;\n        if (bbox.crossesDateline()) {\n          if (lat >= bbox.minLat && lat <= bbox.maxLat) {\n            bboxSays = lon <= bbox.maxLon || lon >= bbox.minLon;\n          } else {\n            bboxSays = false;\n          }\n        } else {\n          bboxSays = lat >= bbox.minLat && lat <= bbox.maxLat && lon >= bbox.minLon && lon <= bbox.maxLon;\n        }\n\n        if (haversinSays) {\n          if (bboxSays == false) {\n            System.out.println(\"centerLat=\" + centerLat + \" centerLon=\" + centerLon + \" radiusMeters=\" + radiusMeters);\n            System.out.println(\"  bbox: lat=\" + bbox.minLat + \" to \" + bbox.maxLat + \" lon=\" + bbox.minLon + \" to \" + bbox.maxLon);\n            System.out.println(\"  point: lat=\" + lat + \" lon=\" + lon);\n            System.out.println(\"  haversin: \" + distanceMeters);\n            fail(\"point was within the distance according to haversin, but the bbox doesn't contain it\");\n          }\n        } else {\n          // it's fine if haversin said it was outside the radius and bbox said it was inside the box\n        }\n      }\n    }\n  }\n\n","sourceOld":"  // We rely heavily on GeoUtils.circleToBBox so we test it here:\n  public void testRandomCircleToBBox() throws Exception {\n    int iters = atLeast(1000);\n    for(int iter=0;iter<iters;iter++) {\n\n      double centerLat = GeoTestUtil.nextLatitude();\n      double centerLon = GeoTestUtil.nextLongitude();\n\n      final double radiusMeters;\n      if (random().nextBoolean()) {\n        // Approx 4 degrees lon at the equator:\n        radiusMeters = random().nextDouble() * 444000;\n      } else {\n        radiusMeters = random().nextDouble() * 50000000;\n      }\n\n      // TODO: randomly quantize radius too, to provoke exact math errors?\n\n      Rectangle bbox = Rectangle.fromPointDistance(centerLat, centerLon, radiusMeters);\n\n      int numPointsToTry = 1000;\n      for(int i=0;i<numPointsToTry;i++) {\n\n        double point[] = GeoTestUtil.nextPointNear(bbox);\n        double lat = point[0];\n        double lon = point[1];\n\n        double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, lat, lon);\n\n        // Haversin says it's within the circle:\n        boolean haversinSays = distanceMeters <= radiusMeters;\n\n        // BBox says its within the box:\n        boolean bboxSays;\n        if (bbox.crossesDateline()) {\n          if (lat >= bbox.minLat && lat <= bbox.maxLat) {\n            bboxSays = lon <= bbox.maxLon || lon >= bbox.minLon;\n          } else {\n            bboxSays = false;\n          }\n        } else {\n          bboxSays = lat >= bbox.minLat && lat <= bbox.maxLat && lon >= bbox.minLon && lon <= bbox.maxLon;\n        }\n\n        if (haversinSays) {\n          if (bboxSays == false) {\n            System.out.println(\"centerLat=\" + centerLat + \" centerLon=\" + centerLon + \" radiusMeters=\" + radiusMeters);\n            System.out.println(\"  bbox: lat=\" + bbox.minLat + \" to \" + bbox.maxLat + \" lon=\" + bbox.minLon + \" to \" + bbox.maxLon);\n            System.out.println(\"  point: lat=\" + lat + \" lon=\" + lon);\n            System.out.println(\"  haversin: \" + distanceMeters);\n            fail(\"point was within the distance according to haversin, but the bbox doesn't contain it\");\n          }\n        } else {\n          // it's fine if haversin said it was outside the radius and bbox said it was inside the box\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/geo/TestGeoUtils#testRandomCircleToBBox().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/geo/TestGeoUtils#testRandomCircleToBBox().mjava","sourceNew":"  // We rely heavily on GeoUtils.circleToBBox so we test it here:\n  public void testRandomCircleToBBox() throws Exception {\n    int iters = atLeast(100);\n    for(int iter=0;iter<iters;iter++) {\n\n      double centerLat = GeoTestUtil.nextLatitude();\n      double centerLon = GeoTestUtil.nextLongitude();\n\n      final double radiusMeters;\n      if (random().nextBoolean()) {\n        // Approx 4 degrees lon at the equator:\n        radiusMeters = random().nextDouble() * 444000;\n      } else {\n        radiusMeters = random().nextDouble() * 50000000;\n      }\n\n      // TODO: randomly quantize radius too, to provoke exact math errors?\n\n      Rectangle bbox = Rectangle.fromPointDistance(centerLat, centerLon, radiusMeters);\n\n      int numPointsToTry = 1000;\n      for(int i=0;i<numPointsToTry;i++) {\n\n        double point[] = GeoTestUtil.nextPointNear(bbox);\n        double lat = point[0];\n        double lon = point[1];\n\n        double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, lat, lon);\n\n        // Haversin says it's within the circle:\n        boolean haversinSays = distanceMeters <= radiusMeters;\n\n        // BBox says its within the box:\n        boolean bboxSays;\n        if (bbox.crossesDateline()) {\n          if (lat >= bbox.minLat && lat <= bbox.maxLat) {\n            bboxSays = lon <= bbox.maxLon || lon >= bbox.minLon;\n          } else {\n            bboxSays = false;\n          }\n        } else {\n          bboxSays = lat >= bbox.minLat && lat <= bbox.maxLat && lon >= bbox.minLon && lon <= bbox.maxLon;\n        }\n\n        if (haversinSays) {\n          if (bboxSays == false) {\n            System.out.println(\"centerLat=\" + centerLat + \" centerLon=\" + centerLon + \" radiusMeters=\" + radiusMeters);\n            System.out.println(\"  bbox: lat=\" + bbox.minLat + \" to \" + bbox.maxLat + \" lon=\" + bbox.minLon + \" to \" + bbox.maxLon);\n            System.out.println(\"  point: lat=\" + lat + \" lon=\" + lon);\n            System.out.println(\"  haversin: \" + distanceMeters);\n            fail(\"point was within the distance according to haversin, but the bbox doesn't contain it\");\n          }\n        } else {\n          // it's fine if haversin said it was outside the radius and bbox said it was inside the box\n        }\n      }\n    }\n  }\n\n","sourceOld":"  // We rely heavily on GeoUtils.circleToBBox so we test it here:\n  public void testRandomCircleToBBox() throws Exception {\n    int iters = atLeast(1000);\n    for(int iter=0;iter<iters;iter++) {\n\n      double centerLat = GeoTestUtil.nextLatitude();\n      double centerLon = GeoTestUtil.nextLongitude();\n\n      final double radiusMeters;\n      if (random().nextBoolean()) {\n        // Approx 4 degrees lon at the equator:\n        radiusMeters = random().nextDouble() * 444000;\n      } else {\n        radiusMeters = random().nextDouble() * 50000000;\n      }\n\n      // TODO: randomly quantize radius too, to provoke exact math errors?\n\n      Rectangle bbox = Rectangle.fromPointDistance(centerLat, centerLon, radiusMeters);\n\n      int numPointsToTry = 1000;\n      for(int i=0;i<numPointsToTry;i++) {\n\n        double point[] = GeoTestUtil.nextPointNear(bbox);\n        double lat = point[0];\n        double lon = point[1];\n\n        double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, lat, lon);\n\n        // Haversin says it's within the circle:\n        boolean haversinSays = distanceMeters <= radiusMeters;\n\n        // BBox says its within the box:\n        boolean bboxSays;\n        if (bbox.crossesDateline()) {\n          if (lat >= bbox.minLat && lat <= bbox.maxLat) {\n            bboxSays = lon <= bbox.maxLon || lon >= bbox.minLon;\n          } else {\n            bboxSays = false;\n          }\n        } else {\n          bboxSays = lat >= bbox.minLat && lat <= bbox.maxLat && lon >= bbox.minLon && lon <= bbox.maxLon;\n        }\n\n        if (haversinSays) {\n          if (bboxSays == false) {\n            System.out.println(\"centerLat=\" + centerLat + \" centerLon=\" + centerLon + \" radiusMeters=\" + radiusMeters);\n            System.out.println(\"  bbox: lat=\" + bbox.minLat + \" to \" + bbox.maxLat + \" lon=\" + bbox.minLon + \" to \" + bbox.maxLon);\n            System.out.println(\"  point: lat=\" + lat + \" lon=\" + lon);\n            System.out.println(\"  haversin: \" + distanceMeters);\n            fail(\"point was within the distance according to haversin, but the bbox doesn't contain it\");\n          }\n        } else {\n          // it's fine if haversin said it was outside the radius and bbox said it was inside the box\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"403d05f7f8d69b65659157eff1bc1d2717f04c66":["713122036535651642e6d4fe57ce12b449e18473","2c8bedceb91e64a3f0e831450058fc4a76d2c0a6"],"713122036535651642e6d4fe57ce12b449e18473":["546f71f5b1e19230d6e7e59f117d08dbcf59fbfe","3542cf82b8acd1e9ff2ee90fb0bf35e08698a1c2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"546f71f5b1e19230d6e7e59f117d08dbcf59fbfe":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3542cf82b8acd1e9ff2ee90fb0bf35e08698a1c2":["546f71f5b1e19230d6e7e59f117d08dbcf59fbfe"],"2c8bedceb91e64a3f0e831450058fc4a76d2c0a6":["713122036535651642e6d4fe57ce12b449e18473","9dea8da13fd1a227ae1071e8f4ce66bff42174de"],"9dea8da13fd1a227ae1071e8f4ce66bff42174de":["713122036535651642e6d4fe57ce12b449e18473"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["713122036535651642e6d4fe57ce12b449e18473","403d05f7f8d69b65659157eff1bc1d2717f04c66"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["403d05f7f8d69b65659157eff1bc1d2717f04c66"]},"commit2Childs":{"403d05f7f8d69b65659157eff1bc1d2717f04c66":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"713122036535651642e6d4fe57ce12b449e18473":["403d05f7f8d69b65659157eff1bc1d2717f04c66","2c8bedceb91e64a3f0e831450058fc4a76d2c0a6","9dea8da13fd1a227ae1071e8f4ce66bff42174de","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["546f71f5b1e19230d6e7e59f117d08dbcf59fbfe"],"546f71f5b1e19230d6e7e59f117d08dbcf59fbfe":["713122036535651642e6d4fe57ce12b449e18473","3542cf82b8acd1e9ff2ee90fb0bf35e08698a1c2"],"2c8bedceb91e64a3f0e831450058fc4a76d2c0a6":["403d05f7f8d69b65659157eff1bc1d2717f04c66"],"3542cf82b8acd1e9ff2ee90fb0bf35e08698a1c2":["713122036535651642e6d4fe57ce12b449e18473"],"9dea8da13fd1a227ae1071e8f4ce66bff42174de":["2c8bedceb91e64a3f0e831450058fc4a76d2c0a6"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}