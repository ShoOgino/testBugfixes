{"path":"solr/core/src/java/org/apache/solr/request/json/RequestUtil#processParams(SolrRequestHandler,SolrQueryRequest,SolrParams,SolrParams,SolrParams).mjava","commits":[{"id":"ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d","date":1426480823,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/json/RequestUtil#processParams(SolrRequestHandler,SolrQueryRequest,SolrParams,SolrParams,SolrParams).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Set default-ish params on a SolrQueryRequest as well as do standard macro processing and JSON request parsing.\n   *\n   * @param handler The search handler this is for (may be null if you don't want this method touching the content streams)\n   * @param req The request whose params we are interested in\n   * @param defaults values to be used if no values are specified in the request params\n   * @param appends values to be appended to those from the request (or defaults) when dealing with multi-val params, or treated as another layer of defaults for singl-val params.\n   * @param invariants values which will be used instead of any request, or default values, regardless of context.\n   */\n  public static void processParams(SolrRequestHandler handler, SolrQueryRequest req, SolrParams defaults,\n                                   SolrParams appends, SolrParams invariants) {\n\n    boolean searchHandler = handler instanceof SearchHandler;\n    SolrParams params = req.getParams();\n\n    // Handle JSON stream for search requests\n    if (searchHandler && req.getContentStreams() != null) {\n\n      Map<String,String[]> map = MultiMapSolrParams.asMultiMap(params, false);\n\n      if (!(params instanceof MultiMapSolrParams || params instanceof ModifiableSolrParams)) {\n        // need to set params on request since we weren't able to access the original map\n        params = new MultiMapSolrParams(map);\n        req.setParams(params);\n      }\n\n      String[] jsonFromParams = map.remove(\"json\");  // params from the query string should come after (and hence override) JSON content streams\n\n      for (ContentStream cs : req.getContentStreams()) {\n        String contentType = cs.getContentType();\n        if (contentType==null || !contentType.contains(\"/json\")) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad contentType for search handler :\" + contentType + \" request=\"+req);\n        }\n\n        try {\n          String jsonString = IOUtils.toString( cs.getReader() );\n          MultiMapSolrParams.addParam(\"json\", jsonString, map);\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Exception reading content stream for request:\"+req, e);\n        }\n      }\n\n      // append existing \"json\" params\n      if (jsonFromParams != null) {\n        for (String json : jsonFromParams) {\n          MultiMapSolrParams.addParam(\"json\", json, map);\n        }\n      }\n    }\n\n    String[] jsonS = params.getParams(\"json\");\n\n    boolean hasAdditions = defaults != null || invariants != null || appends != null || jsonS != null;\n\n    // short circuit processing\n    if (!hasAdditions && !params.getBool(\"expandMacros\", true)) {\n      return;  // nothing to do...\n    }\n\n    boolean isShard = params.getBool(\"isShard\", false);\n\n    Map<String, String[]> newMap = MultiMapSolrParams.asMultiMap(params, hasAdditions);\n\n\n    // see if the json has a \"params\" section\n    // TODO: we should currently *not* do this if this is a leaf of a distributed search since it could overwrite parameters set by the top-level\n    // The parameters we extract will be propagated anyway.\n    if (jsonS != null && !isShard) {\n      for (String json : jsonS) {\n        getParamsFromJSON(newMap, json);\n      }\n    }\n\n    // first populate defaults, etc..\n    if (defaults != null) {\n      Map<String, String[]> defaultsMap = MultiMapSolrParams.asMultiMap(defaults);\n      for (Map.Entry<String, String[]> entry : defaultsMap.entrySet()) {\n        String key = entry.getKey();\n        if (!newMap.containsKey(key)) {\n          newMap.put(key, entry.getValue());\n        }\n      }\n    }\n\n    if (appends != null) {\n      Map<String, String[]> appendsMap = MultiMapSolrParams.asMultiMap(appends);\n\n      for (Map.Entry<String, String[]> entry : appendsMap.entrySet()) {\n        String key = entry.getKey();\n        String[] arr = newMap.get(key);\n        if (arr == null) {\n          newMap.put(key, entry.getValue());\n        } else {\n          String[] appendArr = entry.getValue();\n          String[] newArr = new String[arr.length + appendArr.length];\n          System.arraycopy(arr, 0, newArr, 0, arr.length);\n          System.arraycopy(appendArr, 0, newArr, arr.length, appendArr.length);\n          newMap.put(key, newArr);\n        }\n      }\n    }\n\n\n    if (invariants != null) {\n      newMap.putAll( MultiMapSolrParams.asMultiMap(invariants) );\n    }\n\n    String[] doMacrosStr = newMap.get(\"expandMacros\");\n    boolean doMacros = true;\n    if (doMacrosStr != null) {\n      doMacros = \"true\".equals(doMacrosStr[0]);\n    }\n\n    if (doMacros) {\n      newMap = MacroExpander.expand(newMap);\n    }\n    // Set these params as soon as possible so if there is an error processing later, things like\n    // \"wt=json\" will take effect from the defaults.\n    SolrParams newParams = new MultiMapSolrParams(newMap);  // newMap may still change below, but that should be OK\n    req.setParams(newParams);\n\n\n    // Skip the rest of the processing (including json processing for now) if this isn't a search handler.\n    // For example json.command started to be used  in SOLR-6294, and that caused errors here.\n    if (!searchHandler) return;\n\n\n    Map<String, Object> json = null;\n    // Handle JSON body first, so query params will always overlay on that\n    jsonS = newMap.get(\"json\");\n    if (jsonS != null) {\n      if (json == null) {\n        json = new LinkedHashMap<>();\n      }\n      mergeJSON(json, \"json\", jsonS, new ObjectUtil.ConflictHandler());\n    }\n    for (String key : newMap.keySet()) {\n      // json.nl, json.wrf are existing query parameters\n      if (key.startsWith(\"json.\") && !(\"json.nl\".equals(key) || \"json.wrf\".equals(key))) {\n        if (json == null) {\n          json = new LinkedHashMap<>();\n        }\n        mergeJSON(json, key, newMap.get(key), new ObjectUtil.ConflictHandler());\n      }\n    }\n\n    // implement compat for existing components...\n    if (json != null && !isShard) {\n      for (Map.Entry<String,Object> entry : json.entrySet()) {\n        String key = entry.getKey();\n        String out = null;\n        boolean arr = false;\n        if (\"query\".equals(key)) {\n          out = \"q\";\n        } else if (\"filter\".equals(key)) {\n          out = \"fq\";\n          arr = true;\n        } else if (\"fields\".equals(key)) {\n          out = \"fl\";\n          arr = true;\n        } else if (\"offset\".equals(key)) {\n          out = \"start\";\n        } else if (\"limit\".equals(key)) {\n          out = \"rows\";\n        } else if (\"sort\".equals(key)) {\n          out = \"sort\";\n        } else if (\"params\".equals(key) || \"facet\".equals(key) ) {\n          // handled elsewhere\n          continue;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown top-level key in JSON request : \" + key);\n        }\n\n        Object val = entry.getValue();\n\n        if (arr) {\n          String[] existing = newMap.get(out);\n          List lst = val instanceof List ? (List)val : null;\n          int existingSize = existing==null ? 0 : existing.length;\n          int jsonSize = lst==null ? 1 : lst.size();\n          String[] newval = new String[ existingSize + jsonSize ];\n          for (int i=0; i<existingSize; i++) {\n            newval[i] = existing[i];\n          }\n          if (lst != null) {\n            for (int i = 0; i < jsonSize; i++) {\n              Object v = lst.get(i);\n              newval[existingSize + i] = v.toString();\n            }\n          } else {\n            newval[newval.length-1] = val.toString();\n          }\n          newMap.put(out, newval);\n        } else {\n          newMap.put(out, new String[]{val.toString()});\n        }\n\n      }\n\n\n    }\n\n    if (json != null) {\n      req.setJSON(json);\n    }\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["8c19c480d77a53905bbd65f04e90fa35925c0f9b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":0,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/json/RequestUtil#processParams(SolrRequestHandler,SolrQueryRequest,SolrParams,SolrParams,SolrParams).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Set default-ish params on a SolrQueryRequest as well as do standard macro processing and JSON request parsing.\n   *\n   * @param handler The search handler this is for (may be null if you don't want this method touching the content streams)\n   * @param req The request whose params we are interested in\n   * @param defaults values to be used if no values are specified in the request params\n   * @param appends values to be appended to those from the request (or defaults) when dealing with multi-val params, or treated as another layer of defaults for singl-val params.\n   * @param invariants values which will be used instead of any request, or default values, regardless of context.\n   */\n  public static void processParams(SolrRequestHandler handler, SolrQueryRequest req, SolrParams defaults,\n                                   SolrParams appends, SolrParams invariants) {\n\n    boolean searchHandler = handler instanceof SearchHandler;\n    SolrParams params = req.getParams();\n\n    // Handle JSON stream for search requests\n    if (searchHandler && req.getContentStreams() != null) {\n\n      Map<String,String[]> map = MultiMapSolrParams.asMultiMap(params, false);\n\n      if (!(params instanceof MultiMapSolrParams || params instanceof ModifiableSolrParams)) {\n        // need to set params on request since we weren't able to access the original map\n        params = new MultiMapSolrParams(map);\n        req.setParams(params);\n      }\n\n      String[] jsonFromParams = map.remove(\"json\");  // params from the query string should come after (and hence override) JSON content streams\n\n      for (ContentStream cs : req.getContentStreams()) {\n        String contentType = cs.getContentType();\n        if (contentType==null || !contentType.contains(\"/json\")) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad contentType for search handler :\" + contentType + \" request=\"+req);\n        }\n\n        try {\n          String jsonString = IOUtils.toString( cs.getReader() );\n          MultiMapSolrParams.addParam(\"json\", jsonString, map);\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Exception reading content stream for request:\"+req, e);\n        }\n      }\n\n      // append existing \"json\" params\n      if (jsonFromParams != null) {\n        for (String json : jsonFromParams) {\n          MultiMapSolrParams.addParam(\"json\", json, map);\n        }\n      }\n    }\n\n    String[] jsonS = params.getParams(\"json\");\n\n    boolean hasAdditions = defaults != null || invariants != null || appends != null || jsonS != null;\n\n    // short circuit processing\n    if (!hasAdditions && !params.getBool(\"expandMacros\", true)) {\n      return;  // nothing to do...\n    }\n\n    boolean isShard = params.getBool(\"isShard\", false);\n\n    Map<String, String[]> newMap = MultiMapSolrParams.asMultiMap(params, hasAdditions);\n\n\n    // see if the json has a \"params\" section\n    // TODO: we should currently *not* do this if this is a leaf of a distributed search since it could overwrite parameters set by the top-level\n    // The parameters we extract will be propagated anyway.\n    if (jsonS != null && !isShard) {\n      for (String json : jsonS) {\n        getParamsFromJSON(newMap, json);\n      }\n    }\n\n    // first populate defaults, etc..\n    if (defaults != null) {\n      Map<String, String[]> defaultsMap = MultiMapSolrParams.asMultiMap(defaults);\n      for (Map.Entry<String, String[]> entry : defaultsMap.entrySet()) {\n        String key = entry.getKey();\n        if (!newMap.containsKey(key)) {\n          newMap.put(key, entry.getValue());\n        }\n      }\n    }\n\n    if (appends != null) {\n      Map<String, String[]> appendsMap = MultiMapSolrParams.asMultiMap(appends);\n\n      for (Map.Entry<String, String[]> entry : appendsMap.entrySet()) {\n        String key = entry.getKey();\n        String[] arr = newMap.get(key);\n        if (arr == null) {\n          newMap.put(key, entry.getValue());\n        } else {\n          String[] appendArr = entry.getValue();\n          String[] newArr = new String[arr.length + appendArr.length];\n          System.arraycopy(arr, 0, newArr, 0, arr.length);\n          System.arraycopy(appendArr, 0, newArr, arr.length, appendArr.length);\n          newMap.put(key, newArr);\n        }\n      }\n    }\n\n\n    if (invariants != null) {\n      newMap.putAll( MultiMapSolrParams.asMultiMap(invariants) );\n    }\n\n    String[] doMacrosStr = newMap.get(\"expandMacros\");\n    boolean doMacros = true;\n    if (doMacrosStr != null) {\n      doMacros = \"true\".equals(doMacrosStr[0]);\n    }\n\n    if (doMacros) {\n      newMap = MacroExpander.expand(newMap);\n    }\n    // Set these params as soon as possible so if there is an error processing later, things like\n    // \"wt=json\" will take effect from the defaults.\n    SolrParams newParams = new MultiMapSolrParams(newMap);  // newMap may still change below, but that should be OK\n    req.setParams(newParams);\n\n\n    // Skip the rest of the processing (including json processing for now) if this isn't a search handler.\n    // For example json.command started to be used  in SOLR-6294, and that caused errors here.\n    if (!searchHandler) return;\n\n\n    Map<String, Object> json = null;\n    // Handle JSON body first, so query params will always overlay on that\n    jsonS = newMap.get(\"json\");\n    if (jsonS != null) {\n      if (json == null) {\n        json = new LinkedHashMap<>();\n      }\n      mergeJSON(json, \"json\", jsonS, new ObjectUtil.ConflictHandler());\n    }\n    for (String key : newMap.keySet()) {\n      // json.nl, json.wrf are existing query parameters\n      if (key.startsWith(\"json.\") && !(\"json.nl\".equals(key) || \"json.wrf\".equals(key))) {\n        if (json == null) {\n          json = new LinkedHashMap<>();\n        }\n        mergeJSON(json, key, newMap.get(key), new ObjectUtil.ConflictHandler());\n      }\n    }\n\n    // implement compat for existing components...\n    if (json != null && !isShard) {\n      for (Map.Entry<String,Object> entry : json.entrySet()) {\n        String key = entry.getKey();\n        String out = null;\n        boolean arr = false;\n        if (\"query\".equals(key)) {\n          out = \"q\";\n        } else if (\"filter\".equals(key)) {\n          out = \"fq\";\n          arr = true;\n        } else if (\"fields\".equals(key)) {\n          out = \"fl\";\n          arr = true;\n        } else if (\"offset\".equals(key)) {\n          out = \"start\";\n        } else if (\"limit\".equals(key)) {\n          out = \"rows\";\n        } else if (\"sort\".equals(key)) {\n          out = \"sort\";\n        } else if (\"params\".equals(key) || \"facet\".equals(key) ) {\n          // handled elsewhere\n          continue;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown top-level key in JSON request : \" + key);\n        }\n\n        Object val = entry.getValue();\n\n        if (arr) {\n          String[] existing = newMap.get(out);\n          List lst = val instanceof List ? (List)val : null;\n          int existingSize = existing==null ? 0 : existing.length;\n          int jsonSize = lst==null ? 1 : lst.size();\n          String[] newval = new String[ existingSize + jsonSize ];\n          for (int i=0; i<existingSize; i++) {\n            newval[i] = existing[i];\n          }\n          if (lst != null) {\n            for (int i = 0; i < jsonSize; i++) {\n              Object v = lst.get(i);\n              newval[existingSize + i] = v.toString();\n            }\n          } else {\n            newval[newval.length-1] = val.toString();\n          }\n          newMap.put(out, newval);\n        } else {\n          newMap.put(out, new String[]{val.toString()});\n        }\n\n      }\n\n\n    }\n\n    if (json != null) {\n      req.setJSON(json);\n    }\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1390137e395d2f07f9ba5b8c43d293befe84d563","date":1427947685,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/json/RequestUtil#processParams(SolrRequestHandler,SolrQueryRequest,SolrParams,SolrParams,SolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/json/RequestUtil#processParams(SolrRequestHandler,SolrQueryRequest,SolrParams,SolrParams,SolrParams).mjava","sourceNew":"  /**\n   * Set default-ish params on a SolrQueryRequest as well as do standard macro processing and JSON request parsing.\n   *\n   * @param handler The search handler this is for (may be null if you don't want this method touching the content streams)\n   * @param req The request whose params we are interested in\n   * @param defaults values to be used if no values are specified in the request params\n   * @param appends values to be appended to those from the request (or defaults) when dealing with multi-val params, or treated as another layer of defaults for singl-val params.\n   * @param invariants values which will be used instead of any request, or default values, regardless of context.\n   */\n  public static void processParams(SolrRequestHandler handler, SolrQueryRequest req, SolrParams defaults,\n                                   SolrParams appends, SolrParams invariants) {\n\n    boolean searchHandler = handler instanceof SearchHandler;\n    SolrParams params = req.getParams();\n\n    // Handle JSON stream for search requests\n    if (searchHandler && req.getContentStreams() != null) {\n\n      Map<String,String[]> map = MultiMapSolrParams.asMultiMap(params, false);\n\n      if (!(params instanceof MultiMapSolrParams || params instanceof ModifiableSolrParams)) {\n        // need to set params on request since we weren't able to access the original map\n        params = new MultiMapSolrParams(map);\n        req.setParams(params);\n      }\n\n      String[] jsonFromParams = map.remove(JSON);  // params from the query string should come after (and hence override) JSON content streams\n\n      for (ContentStream cs : req.getContentStreams()) {\n        String contentType = cs.getContentType();\n        if (contentType==null || !contentType.contains(\"/json\")) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad contentType for search handler :\" + contentType + \" request=\"+req);\n        }\n\n        try {\n          String jsonString = IOUtils.toString( cs.getReader() );\n          MultiMapSolrParams.addParam(JSON, jsonString, map);\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Exception reading content stream for request:\"+req, e);\n        }\n      }\n\n      // append existing \"json\" params\n      if (jsonFromParams != null) {\n        for (String json : jsonFromParams) {\n          MultiMapSolrParams.addParam(JSON, json, map);\n        }\n      }\n    }\n\n    String[] jsonS = params.getParams(JSON);\n\n    boolean hasAdditions = defaults != null || invariants != null || appends != null || jsonS != null;\n\n    // short circuit processing\n    if (!hasAdditions && !params.getBool(\"expandMacros\", true)) {\n      return;  // nothing to do...\n    }\n\n    boolean isShard = params.getBool(\"isShard\", false);\n\n    Map<String, String[]> newMap = MultiMapSolrParams.asMultiMap(params, hasAdditions);\n\n\n    // see if the json has a \"params\" section\n    // TODO: we should currently *not* do this if this is a leaf of a distributed search since it could overwrite parameters set by the top-level\n    // The parameters we extract will be propagated anyway.\n    if (jsonS != null && !isShard) {\n      for (String json : jsonS) {\n        getParamsFromJSON(newMap, json);\n      }\n    }\n\n    // first populate defaults, etc..\n    if (defaults != null) {\n      Map<String, String[]> defaultsMap = MultiMapSolrParams.asMultiMap(defaults);\n      for (Map.Entry<String, String[]> entry : defaultsMap.entrySet()) {\n        String key = entry.getKey();\n        if (!newMap.containsKey(key)) {\n          newMap.put(key, entry.getValue());\n        }\n      }\n    }\n\n    if (appends != null) {\n      Map<String, String[]> appendsMap = MultiMapSolrParams.asMultiMap(appends);\n\n      for (Map.Entry<String, String[]> entry : appendsMap.entrySet()) {\n        String key = entry.getKey();\n        String[] arr = newMap.get(key);\n        if (arr == null) {\n          newMap.put(key, entry.getValue());\n        } else {\n          String[] appendArr = entry.getValue();\n          String[] newArr = new String[arr.length + appendArr.length];\n          System.arraycopy(arr, 0, newArr, 0, arr.length);\n          System.arraycopy(appendArr, 0, newArr, arr.length, appendArr.length);\n          newMap.put(key, newArr);\n        }\n      }\n    }\n\n\n    if (invariants != null) {\n      newMap.putAll( MultiMapSolrParams.asMultiMap(invariants) );\n    }\n\n    String[] doMacrosStr = newMap.get(\"expandMacros\");\n    boolean doMacros = true;\n    if (doMacrosStr != null) {\n      doMacros = \"true\".equals(doMacrosStr[0]);\n    }\n\n    if (doMacros) {\n      newMap = MacroExpander.expand(newMap);\n    }\n    // Set these params as soon as possible so if there is an error processing later, things like\n    // \"wt=json\" will take effect from the defaults.\n    SolrParams newParams = new MultiMapSolrParams(newMap);  // newMap may still change below, but that should be OK\n    req.setParams(newParams);\n\n\n    // Skip the rest of the processing (including json processing for now) if this isn't a search handler.\n    // For example json.command started to be used  in SOLR-6294, and that caused errors here.\n    if (!searchHandler) return;\n\n\n    Map<String, Object> json = null;\n    // Handle JSON body first, so query params will always overlay on that\n    jsonS = newMap.get(JSON);\n    if (jsonS != null) {\n      if (json == null) {\n        json = new LinkedHashMap<>();\n      }\n      mergeJSON(json, JSON, jsonS, new ObjectUtil.ConflictHandler());\n    }\n    for (String key : newMap.keySet()) {\n      // json.nl, json.wrf are existing query parameters\n      if (key.startsWith(\"json.\") && !(\"json.nl\".equals(key) || \"json.wrf\".equals(key))) {\n        if (json == null) {\n          json = new LinkedHashMap<>();\n        }\n        mergeJSON(json, key, newMap.get(key), new ObjectUtil.ConflictHandler());\n      }\n    }\n\n    // implement compat for existing components...\n    if (json != null && !isShard) {\n      for (Map.Entry<String,Object> entry : json.entrySet()) {\n        String key = entry.getKey();\n        String out = null;\n        boolean arr = false;\n        if (\"query\".equals(key)) {\n          out = \"q\";\n        } else if (\"filter\".equals(key)) {\n          out = \"fq\";\n          arr = true;\n        } else if (\"fields\".equals(key)) {\n          out = \"fl\";\n          arr = true;\n        } else if (\"offset\".equals(key)) {\n          out = \"start\";\n        } else if (\"limit\".equals(key)) {\n          out = \"rows\";\n        } else if (\"sort\".equals(key)) {\n          out = \"sort\";\n        } else if (\"params\".equals(key) || \"facet\".equals(key) ) {\n          // handled elsewhere\n          continue;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown top-level key in JSON request : \" + key);\n        }\n\n        Object val = entry.getValue();\n\n        if (arr) {\n          String[] existing = newMap.get(out);\n          List lst = val instanceof List ? (List)val : null;\n          int existingSize = existing==null ? 0 : existing.length;\n          int jsonSize = lst==null ? 1 : lst.size();\n          String[] newval = new String[ existingSize + jsonSize ];\n          for (int i=0; i<existingSize; i++) {\n            newval[i] = existing[i];\n          }\n          if (lst != null) {\n            for (int i = 0; i < jsonSize; i++) {\n              Object v = lst.get(i);\n              newval[existingSize + i] = v.toString();\n            }\n          } else {\n            newval[newval.length-1] = val.toString();\n          }\n          newMap.put(out, newval);\n        } else {\n          newMap.put(out, new String[]{val.toString()});\n        }\n\n      }\n\n\n    }\n\n    if (json != null) {\n      req.setJSON(json);\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Set default-ish params on a SolrQueryRequest as well as do standard macro processing and JSON request parsing.\n   *\n   * @param handler The search handler this is for (may be null if you don't want this method touching the content streams)\n   * @param req The request whose params we are interested in\n   * @param defaults values to be used if no values are specified in the request params\n   * @param appends values to be appended to those from the request (or defaults) when dealing with multi-val params, or treated as another layer of defaults for singl-val params.\n   * @param invariants values which will be used instead of any request, or default values, regardless of context.\n   */\n  public static void processParams(SolrRequestHandler handler, SolrQueryRequest req, SolrParams defaults,\n                                   SolrParams appends, SolrParams invariants) {\n\n    boolean searchHandler = handler instanceof SearchHandler;\n    SolrParams params = req.getParams();\n\n    // Handle JSON stream for search requests\n    if (searchHandler && req.getContentStreams() != null) {\n\n      Map<String,String[]> map = MultiMapSolrParams.asMultiMap(params, false);\n\n      if (!(params instanceof MultiMapSolrParams || params instanceof ModifiableSolrParams)) {\n        // need to set params on request since we weren't able to access the original map\n        params = new MultiMapSolrParams(map);\n        req.setParams(params);\n      }\n\n      String[] jsonFromParams = map.remove(\"json\");  // params from the query string should come after (and hence override) JSON content streams\n\n      for (ContentStream cs : req.getContentStreams()) {\n        String contentType = cs.getContentType();\n        if (contentType==null || !contentType.contains(\"/json\")) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad contentType for search handler :\" + contentType + \" request=\"+req);\n        }\n\n        try {\n          String jsonString = IOUtils.toString( cs.getReader() );\n          MultiMapSolrParams.addParam(\"json\", jsonString, map);\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Exception reading content stream for request:\"+req, e);\n        }\n      }\n\n      // append existing \"json\" params\n      if (jsonFromParams != null) {\n        for (String json : jsonFromParams) {\n          MultiMapSolrParams.addParam(\"json\", json, map);\n        }\n      }\n    }\n\n    String[] jsonS = params.getParams(\"json\");\n\n    boolean hasAdditions = defaults != null || invariants != null || appends != null || jsonS != null;\n\n    // short circuit processing\n    if (!hasAdditions && !params.getBool(\"expandMacros\", true)) {\n      return;  // nothing to do...\n    }\n\n    boolean isShard = params.getBool(\"isShard\", false);\n\n    Map<String, String[]> newMap = MultiMapSolrParams.asMultiMap(params, hasAdditions);\n\n\n    // see if the json has a \"params\" section\n    // TODO: we should currently *not* do this if this is a leaf of a distributed search since it could overwrite parameters set by the top-level\n    // The parameters we extract will be propagated anyway.\n    if (jsonS != null && !isShard) {\n      for (String json : jsonS) {\n        getParamsFromJSON(newMap, json);\n      }\n    }\n\n    // first populate defaults, etc..\n    if (defaults != null) {\n      Map<String, String[]> defaultsMap = MultiMapSolrParams.asMultiMap(defaults);\n      for (Map.Entry<String, String[]> entry : defaultsMap.entrySet()) {\n        String key = entry.getKey();\n        if (!newMap.containsKey(key)) {\n          newMap.put(key, entry.getValue());\n        }\n      }\n    }\n\n    if (appends != null) {\n      Map<String, String[]> appendsMap = MultiMapSolrParams.asMultiMap(appends);\n\n      for (Map.Entry<String, String[]> entry : appendsMap.entrySet()) {\n        String key = entry.getKey();\n        String[] arr = newMap.get(key);\n        if (arr == null) {\n          newMap.put(key, entry.getValue());\n        } else {\n          String[] appendArr = entry.getValue();\n          String[] newArr = new String[arr.length + appendArr.length];\n          System.arraycopy(arr, 0, newArr, 0, arr.length);\n          System.arraycopy(appendArr, 0, newArr, arr.length, appendArr.length);\n          newMap.put(key, newArr);\n        }\n      }\n    }\n\n\n    if (invariants != null) {\n      newMap.putAll( MultiMapSolrParams.asMultiMap(invariants) );\n    }\n\n    String[] doMacrosStr = newMap.get(\"expandMacros\");\n    boolean doMacros = true;\n    if (doMacrosStr != null) {\n      doMacros = \"true\".equals(doMacrosStr[0]);\n    }\n\n    if (doMacros) {\n      newMap = MacroExpander.expand(newMap);\n    }\n    // Set these params as soon as possible so if there is an error processing later, things like\n    // \"wt=json\" will take effect from the defaults.\n    SolrParams newParams = new MultiMapSolrParams(newMap);  // newMap may still change below, but that should be OK\n    req.setParams(newParams);\n\n\n    // Skip the rest of the processing (including json processing for now) if this isn't a search handler.\n    // For example json.command started to be used  in SOLR-6294, and that caused errors here.\n    if (!searchHandler) return;\n\n\n    Map<String, Object> json = null;\n    // Handle JSON body first, so query params will always overlay on that\n    jsonS = newMap.get(\"json\");\n    if (jsonS != null) {\n      if (json == null) {\n        json = new LinkedHashMap<>();\n      }\n      mergeJSON(json, \"json\", jsonS, new ObjectUtil.ConflictHandler());\n    }\n    for (String key : newMap.keySet()) {\n      // json.nl, json.wrf are existing query parameters\n      if (key.startsWith(\"json.\") && !(\"json.nl\".equals(key) || \"json.wrf\".equals(key))) {\n        if (json == null) {\n          json = new LinkedHashMap<>();\n        }\n        mergeJSON(json, key, newMap.get(key), new ObjectUtil.ConflictHandler());\n      }\n    }\n\n    // implement compat for existing components...\n    if (json != null && !isShard) {\n      for (Map.Entry<String,Object> entry : json.entrySet()) {\n        String key = entry.getKey();\n        String out = null;\n        boolean arr = false;\n        if (\"query\".equals(key)) {\n          out = \"q\";\n        } else if (\"filter\".equals(key)) {\n          out = \"fq\";\n          arr = true;\n        } else if (\"fields\".equals(key)) {\n          out = \"fl\";\n          arr = true;\n        } else if (\"offset\".equals(key)) {\n          out = \"start\";\n        } else if (\"limit\".equals(key)) {\n          out = \"rows\";\n        } else if (\"sort\".equals(key)) {\n          out = \"sort\";\n        } else if (\"params\".equals(key) || \"facet\".equals(key) ) {\n          // handled elsewhere\n          continue;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown top-level key in JSON request : \" + key);\n        }\n\n        Object val = entry.getValue();\n\n        if (arr) {\n          String[] existing = newMap.get(out);\n          List lst = val instanceof List ? (List)val : null;\n          int existingSize = existing==null ? 0 : existing.length;\n          int jsonSize = lst==null ? 1 : lst.size();\n          String[] newval = new String[ existingSize + jsonSize ];\n          for (int i=0; i<existingSize; i++) {\n            newval[i] = existing[i];\n          }\n          if (lst != null) {\n            for (int i = 0; i < jsonSize; i++) {\n              Object v = lst.get(i);\n              newval[existingSize + i] = v.toString();\n            }\n          } else {\n            newval[newval.length-1] = val.toString();\n          }\n          newMap.put(out, newval);\n        } else {\n          newMap.put(out, new String[]{val.toString()});\n        }\n\n      }\n\n\n    }\n\n    if (json != null) {\n      req.setJSON(json);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":["f6e0714179918847970d4daef77cf2d18dbd069f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d2638f781be724518ff6c2263d14a48cf6e68017","date":1427989059,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/json/RequestUtil#processParams(SolrRequestHandler,SolrQueryRequest,SolrParams,SolrParams,SolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/json/RequestUtil#processParams(SolrRequestHandler,SolrQueryRequest,SolrParams,SolrParams,SolrParams).mjava","sourceNew":"  /**\n   * Set default-ish params on a SolrQueryRequest as well as do standard macro processing and JSON request parsing.\n   *\n   * @param handler The search handler this is for (may be null if you don't want this method touching the content streams)\n   * @param req The request whose params we are interested in\n   * @param defaults values to be used if no values are specified in the request params\n   * @param appends values to be appended to those from the request (or defaults) when dealing with multi-val params, or treated as another layer of defaults for singl-val params.\n   * @param invariants values which will be used instead of any request, or default values, regardless of context.\n   */\n  public static void processParams(SolrRequestHandler handler, SolrQueryRequest req, SolrParams defaults,\n                                   SolrParams appends, SolrParams invariants) {\n\n    boolean searchHandler = handler instanceof SearchHandler;\n    SolrParams params = req.getParams();\n\n    // Handle JSON stream for search requests\n    if (searchHandler && req.getContentStreams() != null) {\n\n      Map<String,String[]> map = MultiMapSolrParams.asMultiMap(params, false);\n\n      if (!(params instanceof MultiMapSolrParams || params instanceof ModifiableSolrParams)) {\n        // need to set params on request since we weren't able to access the original map\n        params = new MultiMapSolrParams(map);\n        req.setParams(params);\n      }\n\n      String[] jsonFromParams = map.remove(JSON);  // params from the query string should come after (and hence override) JSON content streams\n\n      for (ContentStream cs : req.getContentStreams()) {\n        String contentType = cs.getContentType();\n        if (contentType==null || !contentType.contains(\"/json\")) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad contentType for search handler :\" + contentType + \" request=\"+req);\n        }\n\n        try {\n          String jsonString = IOUtils.toString( cs.getReader() );\n          MultiMapSolrParams.addParam(JSON, jsonString, map);\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Exception reading content stream for request:\"+req, e);\n        }\n      }\n\n      // append existing \"json\" params\n      if (jsonFromParams != null) {\n        for (String json : jsonFromParams) {\n          MultiMapSolrParams.addParam(JSON, json, map);\n        }\n      }\n    }\n\n    String[] jsonS = params.getParams(JSON);\n\n    boolean hasAdditions = defaults != null || invariants != null || appends != null || jsonS != null;\n\n    // short circuit processing\n    if (!hasAdditions && !params.getBool(\"expandMacros\", true)) {\n      return;  // nothing to do...\n    }\n\n    boolean isShard = params.getBool(\"isShard\", false);\n\n    Map<String, String[]> newMap = MultiMapSolrParams.asMultiMap(params, hasAdditions);\n\n\n    // see if the json has a \"params\" section\n    // TODO: we should currently *not* do this if this is a leaf of a distributed search since it could overwrite parameters set by the top-level\n    // The parameters we extract will be propagated anyway.\n    if (jsonS != null && !isShard) {\n      for (String json : jsonS) {\n        getParamsFromJSON(newMap, json);\n      }\n    }\n\n    // first populate defaults, etc..\n    if (defaults != null) {\n      Map<String, String[]> defaultsMap = MultiMapSolrParams.asMultiMap(defaults);\n      for (Map.Entry<String, String[]> entry : defaultsMap.entrySet()) {\n        String key = entry.getKey();\n        if (!newMap.containsKey(key)) {\n          newMap.put(key, entry.getValue());\n        }\n      }\n    }\n\n    if (appends != null) {\n      Map<String, String[]> appendsMap = MultiMapSolrParams.asMultiMap(appends);\n\n      for (Map.Entry<String, String[]> entry : appendsMap.entrySet()) {\n        String key = entry.getKey();\n        String[] arr = newMap.get(key);\n        if (arr == null) {\n          newMap.put(key, entry.getValue());\n        } else {\n          String[] appendArr = entry.getValue();\n          String[] newArr = new String[arr.length + appendArr.length];\n          System.arraycopy(arr, 0, newArr, 0, arr.length);\n          System.arraycopy(appendArr, 0, newArr, arr.length, appendArr.length);\n          newMap.put(key, newArr);\n        }\n      }\n    }\n\n\n    if (invariants != null) {\n      newMap.putAll( MultiMapSolrParams.asMultiMap(invariants) );\n    }\n\n    String[] doMacrosStr = newMap.get(\"expandMacros\");\n    boolean doMacros = true;\n    if (doMacrosStr != null) {\n      doMacros = \"true\".equals(doMacrosStr[0]);\n    }\n\n    if (doMacros) {\n      newMap = MacroExpander.expand(newMap);\n    }\n    // Set these params as soon as possible so if there is an error processing later, things like\n    // \"wt=json\" will take effect from the defaults.\n    SolrParams newParams = new MultiMapSolrParams(newMap);  // newMap may still change below, but that should be OK\n    req.setParams(newParams);\n\n\n    // Skip the rest of the processing (including json processing for now) if this isn't a search handler.\n    // For example json.command started to be used  in SOLR-6294, and that caused errors here.\n    if (!searchHandler) return;\n\n\n    Map<String, Object> json = null;\n    // Handle JSON body first, so query params will always overlay on that\n    jsonS = newMap.get(JSON);\n    if (jsonS != null) {\n      if (json == null) {\n        json = new LinkedHashMap<>();\n      }\n      mergeJSON(json, JSON, jsonS, new ObjectUtil.ConflictHandler());\n    }\n    for (String key : newMap.keySet()) {\n      // json.nl, json.wrf are existing query parameters\n      if (key.startsWith(\"json.\") && !(\"json.nl\".equals(key) || \"json.wrf\".equals(key))) {\n        if (json == null) {\n          json = new LinkedHashMap<>();\n        }\n        mergeJSON(json, key, newMap.get(key), new ObjectUtil.ConflictHandler());\n      }\n    }\n\n    // implement compat for existing components...\n    if (json != null && !isShard) {\n      for (Map.Entry<String,Object> entry : json.entrySet()) {\n        String key = entry.getKey();\n        String out = null;\n        boolean arr = false;\n        if (\"query\".equals(key)) {\n          out = \"q\";\n        } else if (\"filter\".equals(key)) {\n          out = \"fq\";\n          arr = true;\n        } else if (\"fields\".equals(key)) {\n          out = \"fl\";\n          arr = true;\n        } else if (\"offset\".equals(key)) {\n          out = \"start\";\n        } else if (\"limit\".equals(key)) {\n          out = \"rows\";\n        } else if (\"sort\".equals(key)) {\n          out = \"sort\";\n        } else if (\"params\".equals(key) || \"facet\".equals(key) ) {\n          // handled elsewhere\n          continue;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown top-level key in JSON request : \" + key);\n        }\n\n        Object val = entry.getValue();\n\n        if (arr) {\n          String[] existing = newMap.get(out);\n          List lst = val instanceof List ? (List)val : null;\n          int existingSize = existing==null ? 0 : existing.length;\n          int jsonSize = lst==null ? 1 : lst.size();\n          String[] newval = new String[ existingSize + jsonSize ];\n          for (int i=0; i<existingSize; i++) {\n            newval[i] = existing[i];\n          }\n          if (lst != null) {\n            for (int i = 0; i < jsonSize; i++) {\n              Object v = lst.get(i);\n              newval[existingSize + i] = v.toString();\n            }\n          } else {\n            newval[newval.length-1] = val.toString();\n          }\n          newMap.put(out, newval);\n        } else {\n          newMap.put(out, new String[]{val.toString()});\n        }\n\n      }\n\n\n    }\n\n    if (json != null) {\n      req.setJSON(json);\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Set default-ish params on a SolrQueryRequest as well as do standard macro processing and JSON request parsing.\n   *\n   * @param handler The search handler this is for (may be null if you don't want this method touching the content streams)\n   * @param req The request whose params we are interested in\n   * @param defaults values to be used if no values are specified in the request params\n   * @param appends values to be appended to those from the request (or defaults) when dealing with multi-val params, or treated as another layer of defaults for singl-val params.\n   * @param invariants values which will be used instead of any request, or default values, regardless of context.\n   */\n  public static void processParams(SolrRequestHandler handler, SolrQueryRequest req, SolrParams defaults,\n                                   SolrParams appends, SolrParams invariants) {\n\n    boolean searchHandler = handler instanceof SearchHandler;\n    SolrParams params = req.getParams();\n\n    // Handle JSON stream for search requests\n    if (searchHandler && req.getContentStreams() != null) {\n\n      Map<String,String[]> map = MultiMapSolrParams.asMultiMap(params, false);\n\n      if (!(params instanceof MultiMapSolrParams || params instanceof ModifiableSolrParams)) {\n        // need to set params on request since we weren't able to access the original map\n        params = new MultiMapSolrParams(map);\n        req.setParams(params);\n      }\n\n      String[] jsonFromParams = map.remove(\"json\");  // params from the query string should come after (and hence override) JSON content streams\n\n      for (ContentStream cs : req.getContentStreams()) {\n        String contentType = cs.getContentType();\n        if (contentType==null || !contentType.contains(\"/json\")) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad contentType for search handler :\" + contentType + \" request=\"+req);\n        }\n\n        try {\n          String jsonString = IOUtils.toString( cs.getReader() );\n          MultiMapSolrParams.addParam(\"json\", jsonString, map);\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Exception reading content stream for request:\"+req, e);\n        }\n      }\n\n      // append existing \"json\" params\n      if (jsonFromParams != null) {\n        for (String json : jsonFromParams) {\n          MultiMapSolrParams.addParam(\"json\", json, map);\n        }\n      }\n    }\n\n    String[] jsonS = params.getParams(\"json\");\n\n    boolean hasAdditions = defaults != null || invariants != null || appends != null || jsonS != null;\n\n    // short circuit processing\n    if (!hasAdditions && !params.getBool(\"expandMacros\", true)) {\n      return;  // nothing to do...\n    }\n\n    boolean isShard = params.getBool(\"isShard\", false);\n\n    Map<String, String[]> newMap = MultiMapSolrParams.asMultiMap(params, hasAdditions);\n\n\n    // see if the json has a \"params\" section\n    // TODO: we should currently *not* do this if this is a leaf of a distributed search since it could overwrite parameters set by the top-level\n    // The parameters we extract will be propagated anyway.\n    if (jsonS != null && !isShard) {\n      for (String json : jsonS) {\n        getParamsFromJSON(newMap, json);\n      }\n    }\n\n    // first populate defaults, etc..\n    if (defaults != null) {\n      Map<String, String[]> defaultsMap = MultiMapSolrParams.asMultiMap(defaults);\n      for (Map.Entry<String, String[]> entry : defaultsMap.entrySet()) {\n        String key = entry.getKey();\n        if (!newMap.containsKey(key)) {\n          newMap.put(key, entry.getValue());\n        }\n      }\n    }\n\n    if (appends != null) {\n      Map<String, String[]> appendsMap = MultiMapSolrParams.asMultiMap(appends);\n\n      for (Map.Entry<String, String[]> entry : appendsMap.entrySet()) {\n        String key = entry.getKey();\n        String[] arr = newMap.get(key);\n        if (arr == null) {\n          newMap.put(key, entry.getValue());\n        } else {\n          String[] appendArr = entry.getValue();\n          String[] newArr = new String[arr.length + appendArr.length];\n          System.arraycopy(arr, 0, newArr, 0, arr.length);\n          System.arraycopy(appendArr, 0, newArr, arr.length, appendArr.length);\n          newMap.put(key, newArr);\n        }\n      }\n    }\n\n\n    if (invariants != null) {\n      newMap.putAll( MultiMapSolrParams.asMultiMap(invariants) );\n    }\n\n    String[] doMacrosStr = newMap.get(\"expandMacros\");\n    boolean doMacros = true;\n    if (doMacrosStr != null) {\n      doMacros = \"true\".equals(doMacrosStr[0]);\n    }\n\n    if (doMacros) {\n      newMap = MacroExpander.expand(newMap);\n    }\n    // Set these params as soon as possible so if there is an error processing later, things like\n    // \"wt=json\" will take effect from the defaults.\n    SolrParams newParams = new MultiMapSolrParams(newMap);  // newMap may still change below, but that should be OK\n    req.setParams(newParams);\n\n\n    // Skip the rest of the processing (including json processing for now) if this isn't a search handler.\n    // For example json.command started to be used  in SOLR-6294, and that caused errors here.\n    if (!searchHandler) return;\n\n\n    Map<String, Object> json = null;\n    // Handle JSON body first, so query params will always overlay on that\n    jsonS = newMap.get(\"json\");\n    if (jsonS != null) {\n      if (json == null) {\n        json = new LinkedHashMap<>();\n      }\n      mergeJSON(json, \"json\", jsonS, new ObjectUtil.ConflictHandler());\n    }\n    for (String key : newMap.keySet()) {\n      // json.nl, json.wrf are existing query parameters\n      if (key.startsWith(\"json.\") && !(\"json.nl\".equals(key) || \"json.wrf\".equals(key))) {\n        if (json == null) {\n          json = new LinkedHashMap<>();\n        }\n        mergeJSON(json, key, newMap.get(key), new ObjectUtil.ConflictHandler());\n      }\n    }\n\n    // implement compat for existing components...\n    if (json != null && !isShard) {\n      for (Map.Entry<String,Object> entry : json.entrySet()) {\n        String key = entry.getKey();\n        String out = null;\n        boolean arr = false;\n        if (\"query\".equals(key)) {\n          out = \"q\";\n        } else if (\"filter\".equals(key)) {\n          out = \"fq\";\n          arr = true;\n        } else if (\"fields\".equals(key)) {\n          out = \"fl\";\n          arr = true;\n        } else if (\"offset\".equals(key)) {\n          out = \"start\";\n        } else if (\"limit\".equals(key)) {\n          out = \"rows\";\n        } else if (\"sort\".equals(key)) {\n          out = \"sort\";\n        } else if (\"params\".equals(key) || \"facet\".equals(key) ) {\n          // handled elsewhere\n          continue;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown top-level key in JSON request : \" + key);\n        }\n\n        Object val = entry.getValue();\n\n        if (arr) {\n          String[] existing = newMap.get(out);\n          List lst = val instanceof List ? (List)val : null;\n          int existingSize = existing==null ? 0 : existing.length;\n          int jsonSize = lst==null ? 1 : lst.size();\n          String[] newval = new String[ existingSize + jsonSize ];\n          for (int i=0; i<existingSize; i++) {\n            newval[i] = existing[i];\n          }\n          if (lst != null) {\n            for (int i = 0; i < jsonSize; i++) {\n              Object v = lst.get(i);\n              newval[existingSize + i] = v.toString();\n            }\n          } else {\n            newval[newval.length-1] = val.toString();\n          }\n          newMap.put(out, newval);\n        } else {\n          newMap.put(out, new String[]{val.toString()});\n        }\n\n      }\n\n\n    }\n\n    if (json != null) {\n      req.setJSON(json);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f6e0714179918847970d4daef77cf2d18dbd069f","date":1433864896,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/json/RequestUtil#processParams(SolrRequestHandler,SolrQueryRequest,SolrParams,SolrParams,SolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/json/RequestUtil#processParams(SolrRequestHandler,SolrQueryRequest,SolrParams,SolrParams,SolrParams).mjava","sourceNew":"  /**\n   * Set default-ish params on a SolrQueryRequest as well as do standard macro processing and JSON request parsing.\n   *\n   * @param handler The search handler this is for (may be null if you don't want this method touching the content streams)\n   * @param req The request whose params we are interested in\n   * @param defaults values to be used if no values are specified in the request params\n   * @param appends values to be appended to those from the request (or defaults) when dealing with multi-val params, or treated as another layer of defaults for singl-val params.\n   * @param invariants values which will be used instead of any request, or default values, regardless of context.\n   */\n  public static void processParams(SolrRequestHandler handler, SolrQueryRequest req, SolrParams defaults,\n                                   SolrParams appends, SolrParams invariants) {\n\n    boolean searchHandler = handler instanceof SearchHandler;\n    SolrParams params = req.getParams();\n\n    // Handle JSON stream for search requests\n    if (searchHandler && req.getContentStreams() != null) {\n\n      Map<String,String[]> map = MultiMapSolrParams.asMultiMap(params, false);\n\n      if (!(params instanceof MultiMapSolrParams || params instanceof ModifiableSolrParams)) {\n        // need to set params on request since we weren't able to access the original map\n        params = new MultiMapSolrParams(map);\n        req.setParams(params);\n      }\n\n      String[] jsonFromParams = map.remove(JSON);  // params from the query string should come after (and hence override) JSON content streams\n\n      for (ContentStream cs : req.getContentStreams()) {\n        String contentType = cs.getContentType();\n        if (contentType==null || !contentType.contains(\"/json\")) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad contentType for search handler :\" + contentType + \" request=\"+req);\n        }\n\n        try {\n          String jsonString = IOUtils.toString( cs.getReader() );\n          if (jsonString != null) {\n            MultiMapSolrParams.addParam(JSON, jsonString, map);\n          }\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Exception reading content stream for request:\"+req, e);\n        }\n      }\n\n      // append existing \"json\" params\n      if (jsonFromParams != null) {\n        for (String json : jsonFromParams) {\n          MultiMapSolrParams.addParam(JSON, json, map);\n        }\n      }\n    }\n\n    String[] jsonS = params.getParams(JSON);\n\n    boolean hasAdditions = defaults != null || invariants != null || appends != null || jsonS != null;\n\n    // short circuit processing\n    if (!hasAdditions && !params.getBool(\"expandMacros\", true)) {\n      return;  // nothing to do...\n    }\n\n    boolean isShard = params.getBool(\"isShard\", false);\n\n    Map<String, String[]> newMap = MultiMapSolrParams.asMultiMap(params, hasAdditions);\n\n\n    // see if the json has a \"params\" section\n    // TODO: we should currently *not* do this if this is a leaf of a distributed search since it could overwrite parameters set by the top-level\n    // The parameters we extract will be propagated anyway.\n    if (jsonS != null && !isShard) {\n      for (String json : jsonS) {\n        getParamsFromJSON(newMap, json);\n      }\n    }\n\n    // first populate defaults, etc..\n    if (defaults != null) {\n      Map<String, String[]> defaultsMap = MultiMapSolrParams.asMultiMap(defaults);\n      for (Map.Entry<String, String[]> entry : defaultsMap.entrySet()) {\n        String key = entry.getKey();\n        if (!newMap.containsKey(key)) {\n          newMap.put(key, entry.getValue());\n        }\n      }\n    }\n\n    if (appends != null) {\n      Map<String, String[]> appendsMap = MultiMapSolrParams.asMultiMap(appends);\n\n      for (Map.Entry<String, String[]> entry : appendsMap.entrySet()) {\n        String key = entry.getKey();\n        String[] arr = newMap.get(key);\n        if (arr == null) {\n          newMap.put(key, entry.getValue());\n        } else {\n          String[] appendArr = entry.getValue();\n          String[] newArr = new String[arr.length + appendArr.length];\n          System.arraycopy(arr, 0, newArr, 0, arr.length);\n          System.arraycopy(appendArr, 0, newArr, arr.length, appendArr.length);\n          newMap.put(key, newArr);\n        }\n      }\n    }\n\n\n    if (invariants != null) {\n      newMap.putAll( MultiMapSolrParams.asMultiMap(invariants) );\n    }\n\n    String[] doMacrosStr = newMap.get(\"expandMacros\");\n    boolean doMacros = true;\n    if (doMacrosStr != null) {\n      doMacros = \"true\".equals(doMacrosStr[0]);\n    }\n\n    if (doMacros) {\n      newMap = MacroExpander.expand(newMap);\n    }\n    // Set these params as soon as possible so if there is an error processing later, things like\n    // \"wt=json\" will take effect from the defaults.\n    SolrParams newParams = new MultiMapSolrParams(newMap);  // newMap may still change below, but that should be OK\n    req.setParams(newParams);\n\n\n    // Skip the rest of the processing (including json processing for now) if this isn't a search handler.\n    // For example json.command started to be used  in SOLR-6294, and that caused errors here.\n    if (!searchHandler) return;\n\n\n    Map<String, Object> json = null;\n    // Handle JSON body first, so query params will always overlay on that\n    jsonS = newMap.get(JSON);\n    if (jsonS != null) {\n      if (json == null) {\n        json = new LinkedHashMap<>();\n      }\n      mergeJSON(json, JSON, jsonS, new ObjectUtil.ConflictHandler());\n    }\n    for (String key : newMap.keySet()) {\n      // json.nl, json.wrf are existing query parameters\n      if (key.startsWith(\"json.\") && !(\"json.nl\".equals(key) || \"json.wrf\".equals(key))) {\n        if (json == null) {\n          json = new LinkedHashMap<>();\n        }\n        mergeJSON(json, key, newMap.get(key), new ObjectUtil.ConflictHandler());\n      }\n    }\n\n    // implement compat for existing components...\n    if (json != null && !isShard) {\n      for (Map.Entry<String,Object> entry : json.entrySet()) {\n        String key = entry.getKey();\n        String out = null;\n        boolean arr = false;\n        if (\"query\".equals(key)) {\n          out = \"q\";\n        } else if (\"filter\".equals(key)) {\n          out = \"fq\";\n          arr = true;\n        } else if (\"fields\".equals(key)) {\n          out = \"fl\";\n          arr = true;\n        } else if (\"offset\".equals(key)) {\n          out = \"start\";\n        } else if (\"limit\".equals(key)) {\n          out = \"rows\";\n        } else if (\"sort\".equals(key)) {\n          out = \"sort\";\n        } else if (\"params\".equals(key) || \"facet\".equals(key) ) {\n          // handled elsewhere\n          continue;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown top-level key in JSON request : \" + key);\n        }\n\n        Object val = entry.getValue();\n\n        if (arr) {\n          String[] existing = newMap.get(out);\n          List lst = val instanceof List ? (List)val : null;\n          int existingSize = existing==null ? 0 : existing.length;\n          int jsonSize = lst==null ? 1 : lst.size();\n          String[] newval = new String[ existingSize + jsonSize ];\n          for (int i=0; i<existingSize; i++) {\n            newval[i] = existing[i];\n          }\n          if (lst != null) {\n            for (int i = 0; i < jsonSize; i++) {\n              Object v = lst.get(i);\n              newval[existingSize + i] = v.toString();\n            }\n          } else {\n            newval[newval.length-1] = val.toString();\n          }\n          newMap.put(out, newval);\n        } else {\n          newMap.put(out, new String[]{val.toString()});\n        }\n\n      }\n\n\n    }\n\n    if (json != null) {\n      req.setJSON(json);\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Set default-ish params on a SolrQueryRequest as well as do standard macro processing and JSON request parsing.\n   *\n   * @param handler The search handler this is for (may be null if you don't want this method touching the content streams)\n   * @param req The request whose params we are interested in\n   * @param defaults values to be used if no values are specified in the request params\n   * @param appends values to be appended to those from the request (or defaults) when dealing with multi-val params, or treated as another layer of defaults for singl-val params.\n   * @param invariants values which will be used instead of any request, or default values, regardless of context.\n   */\n  public static void processParams(SolrRequestHandler handler, SolrQueryRequest req, SolrParams defaults,\n                                   SolrParams appends, SolrParams invariants) {\n\n    boolean searchHandler = handler instanceof SearchHandler;\n    SolrParams params = req.getParams();\n\n    // Handle JSON stream for search requests\n    if (searchHandler && req.getContentStreams() != null) {\n\n      Map<String,String[]> map = MultiMapSolrParams.asMultiMap(params, false);\n\n      if (!(params instanceof MultiMapSolrParams || params instanceof ModifiableSolrParams)) {\n        // need to set params on request since we weren't able to access the original map\n        params = new MultiMapSolrParams(map);\n        req.setParams(params);\n      }\n\n      String[] jsonFromParams = map.remove(JSON);  // params from the query string should come after (and hence override) JSON content streams\n\n      for (ContentStream cs : req.getContentStreams()) {\n        String contentType = cs.getContentType();\n        if (contentType==null || !contentType.contains(\"/json\")) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad contentType for search handler :\" + contentType + \" request=\"+req);\n        }\n\n        try {\n          String jsonString = IOUtils.toString( cs.getReader() );\n          MultiMapSolrParams.addParam(JSON, jsonString, map);\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Exception reading content stream for request:\"+req, e);\n        }\n      }\n\n      // append existing \"json\" params\n      if (jsonFromParams != null) {\n        for (String json : jsonFromParams) {\n          MultiMapSolrParams.addParam(JSON, json, map);\n        }\n      }\n    }\n\n    String[] jsonS = params.getParams(JSON);\n\n    boolean hasAdditions = defaults != null || invariants != null || appends != null || jsonS != null;\n\n    // short circuit processing\n    if (!hasAdditions && !params.getBool(\"expandMacros\", true)) {\n      return;  // nothing to do...\n    }\n\n    boolean isShard = params.getBool(\"isShard\", false);\n\n    Map<String, String[]> newMap = MultiMapSolrParams.asMultiMap(params, hasAdditions);\n\n\n    // see if the json has a \"params\" section\n    // TODO: we should currently *not* do this if this is a leaf of a distributed search since it could overwrite parameters set by the top-level\n    // The parameters we extract will be propagated anyway.\n    if (jsonS != null && !isShard) {\n      for (String json : jsonS) {\n        getParamsFromJSON(newMap, json);\n      }\n    }\n\n    // first populate defaults, etc..\n    if (defaults != null) {\n      Map<String, String[]> defaultsMap = MultiMapSolrParams.asMultiMap(defaults);\n      for (Map.Entry<String, String[]> entry : defaultsMap.entrySet()) {\n        String key = entry.getKey();\n        if (!newMap.containsKey(key)) {\n          newMap.put(key, entry.getValue());\n        }\n      }\n    }\n\n    if (appends != null) {\n      Map<String, String[]> appendsMap = MultiMapSolrParams.asMultiMap(appends);\n\n      for (Map.Entry<String, String[]> entry : appendsMap.entrySet()) {\n        String key = entry.getKey();\n        String[] arr = newMap.get(key);\n        if (arr == null) {\n          newMap.put(key, entry.getValue());\n        } else {\n          String[] appendArr = entry.getValue();\n          String[] newArr = new String[arr.length + appendArr.length];\n          System.arraycopy(arr, 0, newArr, 0, arr.length);\n          System.arraycopy(appendArr, 0, newArr, arr.length, appendArr.length);\n          newMap.put(key, newArr);\n        }\n      }\n    }\n\n\n    if (invariants != null) {\n      newMap.putAll( MultiMapSolrParams.asMultiMap(invariants) );\n    }\n\n    String[] doMacrosStr = newMap.get(\"expandMacros\");\n    boolean doMacros = true;\n    if (doMacrosStr != null) {\n      doMacros = \"true\".equals(doMacrosStr[0]);\n    }\n\n    if (doMacros) {\n      newMap = MacroExpander.expand(newMap);\n    }\n    // Set these params as soon as possible so if there is an error processing later, things like\n    // \"wt=json\" will take effect from the defaults.\n    SolrParams newParams = new MultiMapSolrParams(newMap);  // newMap may still change below, but that should be OK\n    req.setParams(newParams);\n\n\n    // Skip the rest of the processing (including json processing for now) if this isn't a search handler.\n    // For example json.command started to be used  in SOLR-6294, and that caused errors here.\n    if (!searchHandler) return;\n\n\n    Map<String, Object> json = null;\n    // Handle JSON body first, so query params will always overlay on that\n    jsonS = newMap.get(JSON);\n    if (jsonS != null) {\n      if (json == null) {\n        json = new LinkedHashMap<>();\n      }\n      mergeJSON(json, JSON, jsonS, new ObjectUtil.ConflictHandler());\n    }\n    for (String key : newMap.keySet()) {\n      // json.nl, json.wrf are existing query parameters\n      if (key.startsWith(\"json.\") && !(\"json.nl\".equals(key) || \"json.wrf\".equals(key))) {\n        if (json == null) {\n          json = new LinkedHashMap<>();\n        }\n        mergeJSON(json, key, newMap.get(key), new ObjectUtil.ConflictHandler());\n      }\n    }\n\n    // implement compat for existing components...\n    if (json != null && !isShard) {\n      for (Map.Entry<String,Object> entry : json.entrySet()) {\n        String key = entry.getKey();\n        String out = null;\n        boolean arr = false;\n        if (\"query\".equals(key)) {\n          out = \"q\";\n        } else if (\"filter\".equals(key)) {\n          out = \"fq\";\n          arr = true;\n        } else if (\"fields\".equals(key)) {\n          out = \"fl\";\n          arr = true;\n        } else if (\"offset\".equals(key)) {\n          out = \"start\";\n        } else if (\"limit\".equals(key)) {\n          out = \"rows\";\n        } else if (\"sort\".equals(key)) {\n          out = \"sort\";\n        } else if (\"params\".equals(key) || \"facet\".equals(key) ) {\n          // handled elsewhere\n          continue;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown top-level key in JSON request : \" + key);\n        }\n\n        Object val = entry.getValue();\n\n        if (arr) {\n          String[] existing = newMap.get(out);\n          List lst = val instanceof List ? (List)val : null;\n          int existingSize = existing==null ? 0 : existing.length;\n          int jsonSize = lst==null ? 1 : lst.size();\n          String[] newval = new String[ existingSize + jsonSize ];\n          for (int i=0; i<existingSize; i++) {\n            newval[i] = existing[i];\n          }\n          if (lst != null) {\n            for (int i = 0; i < jsonSize; i++) {\n              Object v = lst.get(i);\n              newval[existingSize + i] = v.toString();\n            }\n          } else {\n            newval[newval.length-1] = val.toString();\n          }\n          newMap.put(out, newval);\n        } else {\n          newMap.put(out, new String[]{val.toString()});\n        }\n\n      }\n\n\n    }\n\n    if (json != null) {\n      req.setJSON(json);\n    }\n\n  }\n\n","bugFix":["1390137e395d2f07f9ba5b8c43d293befe84d563"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8c19c480d77a53905bbd65f04e90fa35925c0f9b","date":1484765582,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/json/RequestUtil#processParams(SolrRequestHandler,SolrQueryRequest,SolrParams,SolrParams,SolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/json/RequestUtil#processParams(SolrRequestHandler,SolrQueryRequest,SolrParams,SolrParams,SolrParams).mjava","sourceNew":"  /**\n   * Set default-ish params on a SolrQueryRequest as well as do standard macro processing and JSON request parsing.\n   *\n   * @param handler The search handler this is for (may be null if you don't want this method touching the content streams)\n   * @param req The request whose params we are interested in\n   * @param defaults values to be used if no values are specified in the request params\n   * @param appends values to be appended to those from the request (or defaults) when dealing with multi-val params, or treated as another layer of defaults for singl-val params.\n   * @param invariants values which will be used instead of any request, or default values, regardless of context.\n   */\n  public static void processParams(SolrRequestHandler handler, SolrQueryRequest req, SolrParams defaults,\n                                   SolrParams appends, SolrParams invariants) {\n\n    boolean searchHandler = handler instanceof SearchHandler;\n    SolrParams params = req.getParams();\n\n    // Handle JSON stream for search requests\n    if (searchHandler && req.getContentStreams() != null) {\n\n      Map<String,String[]> map = MultiMapSolrParams.asMultiMap(params, false);\n\n      if (!(params instanceof MultiMapSolrParams || params instanceof ModifiableSolrParams)) {\n        // need to set params on request since we weren't able to access the original map\n        params = new MultiMapSolrParams(map);\n        req.setParams(params);\n      }\n\n      String[] jsonFromParams = map.remove(JSON);  // params from the query string should come after (and hence override) JSON content streams\n\n      for (ContentStream cs : req.getContentStreams()) {\n        String contentType = cs.getContentType();\n        if (contentType==null || !contentType.contains(\"/json\")) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad contentType for search handler :\" + contentType + \" request=\"+req);\n        }\n\n        try {\n          String jsonString = IOUtils.toString( cs.getReader() );\n          if (jsonString != null) {\n            MultiMapSolrParams.addParam(JSON, jsonString, map);\n          }\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Exception reading content stream for request:\"+req, e);\n        }\n      }\n\n      // append existing \"json\" params\n      if (jsonFromParams != null) {\n        for (String json : jsonFromParams) {\n          MultiMapSolrParams.addParam(JSON, json, map);\n        }\n      }\n    }\n\n    String[] jsonS = params.getParams(JSON);\n\n    boolean hasAdditions = defaults != null || invariants != null || appends != null || jsonS != null;\n\n    // short circuit processing\n    if (!hasAdditions && !params.getBool(\"expandMacros\", true)) {\n      return;  // nothing to do...\n    }\n\n    boolean isShard = params.getBool(\"isShard\", false);\n\n    Map<String, String[]> newMap = MultiMapSolrParams.asMultiMap(params, hasAdditions);\n\n\n    // see if the json has a \"params\" section\n    // TODO: we should currently *not* do this if this is a leaf of a distributed search since it could overwrite parameters set by the top-level\n    // The parameters we extract will be propagated anyway.\n    if (jsonS != null && !isShard) {\n      for (String json : jsonS) {\n        getParamsFromJSON(newMap, json);\n      }\n    }\n\n    // first populate defaults, etc..\n    if (defaults != null) {\n      Map<String, String[]> defaultsMap = MultiMapSolrParams.asMultiMap(defaults);\n      for (Map.Entry<String, String[]> entry : defaultsMap.entrySet()) {\n        String key = entry.getKey();\n        if (!newMap.containsKey(key)) {\n          newMap.put(key, entry.getValue());\n        }\n      }\n    }\n\n    if (appends != null) {\n      Map<String, String[]> appendsMap = MultiMapSolrParams.asMultiMap(appends);\n\n      for (Map.Entry<String, String[]> entry : appendsMap.entrySet()) {\n        String key = entry.getKey();\n        String[] arr = newMap.get(key);\n        if (arr == null) {\n          newMap.put(key, entry.getValue());\n        } else {\n          String[] appendArr = entry.getValue();\n          String[] newArr = new String[arr.length + appendArr.length];\n          System.arraycopy(arr, 0, newArr, 0, arr.length);\n          System.arraycopy(appendArr, 0, newArr, arr.length, appendArr.length);\n          newMap.put(key, newArr);\n        }\n      }\n    }\n\n\n    if (invariants != null) {\n      newMap.putAll( MultiMapSolrParams.asMultiMap(invariants) );\n    }\n\n    if (!isShard) { // Don't expand macros in shard requests\n      String[] doMacrosStr = newMap.get(\"expandMacros\");\n      boolean doMacros = true;\n      if (doMacrosStr != null) {\n        doMacros = \"true\".equals(doMacrosStr[0]);\n      }\n\n      if (doMacros) {\n        newMap = MacroExpander.expand(newMap);\n      }\n    }\n    // Set these params as soon as possible so if there is an error processing later, things like\n    // \"wt=json\" will take effect from the defaults.\n    SolrParams newParams = new MultiMapSolrParams(newMap);  // newMap may still change below, but that should be OK\n    req.setParams(newParams);\n\n\n    // Skip the rest of the processing (including json processing for now) if this isn't a search handler.\n    // For example json.command started to be used  in SOLR-6294, and that caused errors here.\n    if (!searchHandler) return;\n\n\n    Map<String, Object> json = null;\n    // Handle JSON body first, so query params will always overlay on that\n    jsonS = newMap.get(JSON);\n    if (jsonS != null) {\n      if (json == null) {\n        json = new LinkedHashMap<>();\n      }\n      mergeJSON(json, JSON, jsonS, new ObjectUtil.ConflictHandler());\n    }\n    for (String key : newMap.keySet()) {\n      // json.nl, json.wrf are existing query parameters\n      if (key.startsWith(\"json.\") && !(\"json.nl\".equals(key) || \"json.wrf\".equals(key))) {\n        if (json == null) {\n          json = new LinkedHashMap<>();\n        }\n        mergeJSON(json, key, newMap.get(key), new ObjectUtil.ConflictHandler());\n      }\n    }\n\n    // implement compat for existing components...\n    if (json != null && !isShard) {\n      for (Map.Entry<String,Object> entry : json.entrySet()) {\n        String key = entry.getKey();\n        String out = null;\n        boolean arr = false;\n        if (\"query\".equals(key)) {\n          out = \"q\";\n        } else if (\"filter\".equals(key)) {\n          out = \"fq\";\n          arr = true;\n        } else if (\"fields\".equals(key)) {\n          out = \"fl\";\n          arr = true;\n        } else if (\"offset\".equals(key)) {\n          out = \"start\";\n        } else if (\"limit\".equals(key)) {\n          out = \"rows\";\n        } else if (\"sort\".equals(key)) {\n          out = \"sort\";\n        } else if (\"params\".equals(key) || \"facet\".equals(key) ) {\n          // handled elsewhere\n          continue;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown top-level key in JSON request : \" + key);\n        }\n\n        Object val = entry.getValue();\n\n        if (arr) {\n          String[] existing = newMap.get(out);\n          List lst = val instanceof List ? (List)val : null;\n          int existingSize = existing==null ? 0 : existing.length;\n          int jsonSize = lst==null ? 1 : lst.size();\n          String[] newval = new String[ existingSize + jsonSize ];\n          for (int i=0; i<existingSize; i++) {\n            newval[i] = existing[i];\n          }\n          if (lst != null) {\n            for (int i = 0; i < jsonSize; i++) {\n              Object v = lst.get(i);\n              newval[existingSize + i] = v.toString();\n            }\n          } else {\n            newval[newval.length-1] = val.toString();\n          }\n          newMap.put(out, newval);\n        } else {\n          newMap.put(out, new String[]{val.toString()});\n        }\n\n      }\n\n\n    }\n\n    if (json != null) {\n      req.setJSON(json);\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Set default-ish params on a SolrQueryRequest as well as do standard macro processing and JSON request parsing.\n   *\n   * @param handler The search handler this is for (may be null if you don't want this method touching the content streams)\n   * @param req The request whose params we are interested in\n   * @param defaults values to be used if no values are specified in the request params\n   * @param appends values to be appended to those from the request (or defaults) when dealing with multi-val params, or treated as another layer of defaults for singl-val params.\n   * @param invariants values which will be used instead of any request, or default values, regardless of context.\n   */\n  public static void processParams(SolrRequestHandler handler, SolrQueryRequest req, SolrParams defaults,\n                                   SolrParams appends, SolrParams invariants) {\n\n    boolean searchHandler = handler instanceof SearchHandler;\n    SolrParams params = req.getParams();\n\n    // Handle JSON stream for search requests\n    if (searchHandler && req.getContentStreams() != null) {\n\n      Map<String,String[]> map = MultiMapSolrParams.asMultiMap(params, false);\n\n      if (!(params instanceof MultiMapSolrParams || params instanceof ModifiableSolrParams)) {\n        // need to set params on request since we weren't able to access the original map\n        params = new MultiMapSolrParams(map);\n        req.setParams(params);\n      }\n\n      String[] jsonFromParams = map.remove(JSON);  // params from the query string should come after (and hence override) JSON content streams\n\n      for (ContentStream cs : req.getContentStreams()) {\n        String contentType = cs.getContentType();\n        if (contentType==null || !contentType.contains(\"/json\")) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad contentType for search handler :\" + contentType + \" request=\"+req);\n        }\n\n        try {\n          String jsonString = IOUtils.toString( cs.getReader() );\n          if (jsonString != null) {\n            MultiMapSolrParams.addParam(JSON, jsonString, map);\n          }\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Exception reading content stream for request:\"+req, e);\n        }\n      }\n\n      // append existing \"json\" params\n      if (jsonFromParams != null) {\n        for (String json : jsonFromParams) {\n          MultiMapSolrParams.addParam(JSON, json, map);\n        }\n      }\n    }\n\n    String[] jsonS = params.getParams(JSON);\n\n    boolean hasAdditions = defaults != null || invariants != null || appends != null || jsonS != null;\n\n    // short circuit processing\n    if (!hasAdditions && !params.getBool(\"expandMacros\", true)) {\n      return;  // nothing to do...\n    }\n\n    boolean isShard = params.getBool(\"isShard\", false);\n\n    Map<String, String[]> newMap = MultiMapSolrParams.asMultiMap(params, hasAdditions);\n\n\n    // see if the json has a \"params\" section\n    // TODO: we should currently *not* do this if this is a leaf of a distributed search since it could overwrite parameters set by the top-level\n    // The parameters we extract will be propagated anyway.\n    if (jsonS != null && !isShard) {\n      for (String json : jsonS) {\n        getParamsFromJSON(newMap, json);\n      }\n    }\n\n    // first populate defaults, etc..\n    if (defaults != null) {\n      Map<String, String[]> defaultsMap = MultiMapSolrParams.asMultiMap(defaults);\n      for (Map.Entry<String, String[]> entry : defaultsMap.entrySet()) {\n        String key = entry.getKey();\n        if (!newMap.containsKey(key)) {\n          newMap.put(key, entry.getValue());\n        }\n      }\n    }\n\n    if (appends != null) {\n      Map<String, String[]> appendsMap = MultiMapSolrParams.asMultiMap(appends);\n\n      for (Map.Entry<String, String[]> entry : appendsMap.entrySet()) {\n        String key = entry.getKey();\n        String[] arr = newMap.get(key);\n        if (arr == null) {\n          newMap.put(key, entry.getValue());\n        } else {\n          String[] appendArr = entry.getValue();\n          String[] newArr = new String[arr.length + appendArr.length];\n          System.arraycopy(arr, 0, newArr, 0, arr.length);\n          System.arraycopy(appendArr, 0, newArr, arr.length, appendArr.length);\n          newMap.put(key, newArr);\n        }\n      }\n    }\n\n\n    if (invariants != null) {\n      newMap.putAll( MultiMapSolrParams.asMultiMap(invariants) );\n    }\n\n    String[] doMacrosStr = newMap.get(\"expandMacros\");\n    boolean doMacros = true;\n    if (doMacrosStr != null) {\n      doMacros = \"true\".equals(doMacrosStr[0]);\n    }\n\n    if (doMacros) {\n      newMap = MacroExpander.expand(newMap);\n    }\n    // Set these params as soon as possible so if there is an error processing later, things like\n    // \"wt=json\" will take effect from the defaults.\n    SolrParams newParams = new MultiMapSolrParams(newMap);  // newMap may still change below, but that should be OK\n    req.setParams(newParams);\n\n\n    // Skip the rest of the processing (including json processing for now) if this isn't a search handler.\n    // For example json.command started to be used  in SOLR-6294, and that caused errors here.\n    if (!searchHandler) return;\n\n\n    Map<String, Object> json = null;\n    // Handle JSON body first, so query params will always overlay on that\n    jsonS = newMap.get(JSON);\n    if (jsonS != null) {\n      if (json == null) {\n        json = new LinkedHashMap<>();\n      }\n      mergeJSON(json, JSON, jsonS, new ObjectUtil.ConflictHandler());\n    }\n    for (String key : newMap.keySet()) {\n      // json.nl, json.wrf are existing query parameters\n      if (key.startsWith(\"json.\") && !(\"json.nl\".equals(key) || \"json.wrf\".equals(key))) {\n        if (json == null) {\n          json = new LinkedHashMap<>();\n        }\n        mergeJSON(json, key, newMap.get(key), new ObjectUtil.ConflictHandler());\n      }\n    }\n\n    // implement compat for existing components...\n    if (json != null && !isShard) {\n      for (Map.Entry<String,Object> entry : json.entrySet()) {\n        String key = entry.getKey();\n        String out = null;\n        boolean arr = false;\n        if (\"query\".equals(key)) {\n          out = \"q\";\n        } else if (\"filter\".equals(key)) {\n          out = \"fq\";\n          arr = true;\n        } else if (\"fields\".equals(key)) {\n          out = \"fl\";\n          arr = true;\n        } else if (\"offset\".equals(key)) {\n          out = \"start\";\n        } else if (\"limit\".equals(key)) {\n          out = \"rows\";\n        } else if (\"sort\".equals(key)) {\n          out = \"sort\";\n        } else if (\"params\".equals(key) || \"facet\".equals(key) ) {\n          // handled elsewhere\n          continue;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown top-level key in JSON request : \" + key);\n        }\n\n        Object val = entry.getValue();\n\n        if (arr) {\n          String[] existing = newMap.get(out);\n          List lst = val instanceof List ? (List)val : null;\n          int existingSize = existing==null ? 0 : existing.length;\n          int jsonSize = lst==null ? 1 : lst.size();\n          String[] newval = new String[ existingSize + jsonSize ];\n          for (int i=0; i<existingSize; i++) {\n            newval[i] = existing[i];\n          }\n          if (lst != null) {\n            for (int i = 0; i < jsonSize; i++) {\n              Object v = lst.get(i);\n              newval[existingSize + i] = v.toString();\n            }\n          } else {\n            newval[newval.length-1] = val.toString();\n          }\n          newMap.put(out, newval);\n        } else {\n          newMap.put(out, new String[]{val.toString()});\n        }\n\n      }\n\n\n    }\n\n    if (json != null) {\n      req.setJSON(json);\n    }\n\n  }\n\n","bugFix":["ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"90a682dc1bfd188ef61cc28373c7f5d700b4ac75","date":1485186128,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/json/RequestUtil#processParams(SolrRequestHandler,SolrQueryRequest,SolrParams,SolrParams,SolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/json/RequestUtil#processParams(SolrRequestHandler,SolrQueryRequest,SolrParams,SolrParams,SolrParams).mjava","sourceNew":"  /**\n   * Set default-ish params on a SolrQueryRequest as well as do standard macro processing and JSON request parsing.\n   *\n   * @param handler The search handler this is for (may be null if you don't want this method touching the content streams)\n   * @param req The request whose params we are interested in\n   * @param defaults values to be used if no values are specified in the request params\n   * @param appends values to be appended to those from the request (or defaults) when dealing with multi-val params, or treated as another layer of defaults for singl-val params.\n   * @param invariants values which will be used instead of any request, or default values, regardless of context.\n   */\n  public static void processParams(SolrRequestHandler handler, SolrQueryRequest req, SolrParams defaults,\n                                   SolrParams appends, SolrParams invariants) {\n\n    boolean searchHandler = handler instanceof SearchHandler;\n    SolrParams params = req.getParams();\n\n    // Handle JSON stream for search requests\n    if (searchHandler && req.getContentStreams() != null) {\n\n      Map<String,String[]> map = MultiMapSolrParams.asMultiMap(params, false);\n\n      if (!(params instanceof MultiMapSolrParams || params instanceof ModifiableSolrParams)) {\n        // need to set params on request since we weren't able to access the original map\n        params = new MultiMapSolrParams(map);\n        req.setParams(params);\n      }\n\n      String[] jsonFromParams = map.remove(JSON);  // params from the query string should come after (and hence override) JSON content streams\n\n      for (ContentStream cs : req.getContentStreams()) {\n        String contentType = cs.getContentType();\n        if (contentType==null || !contentType.contains(\"/json\")) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad contentType for search handler :\" + contentType + \" request=\"+req);\n        }\n\n        try {\n          String jsonString = IOUtils.toString( cs.getReader() );\n          if (jsonString != null) {\n            MultiMapSolrParams.addParam(JSON, jsonString, map);\n          }\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Exception reading content stream for request:\"+req, e);\n        }\n      }\n\n      // append existing \"json\" params\n      if (jsonFromParams != null) {\n        for (String json : jsonFromParams) {\n          MultiMapSolrParams.addParam(JSON, json, map);\n        }\n      }\n    }\n\n    String[] jsonS = params.getParams(JSON);\n\n    boolean hasAdditions = defaults != null || invariants != null || appends != null || jsonS != null;\n\n    // short circuit processing\n    if (!hasAdditions && !params.getBool(\"expandMacros\", true)) {\n      return;  // nothing to do...\n    }\n\n    boolean isShard = params.getBool(\"isShard\", false);\n\n    Map<String, String[]> newMap = MultiMapSolrParams.asMultiMap(params, hasAdditions);\n\n\n    // see if the json has a \"params\" section\n    // TODO: we should currently *not* do this if this is a leaf of a distributed search since it could overwrite parameters set by the top-level\n    // The parameters we extract will be propagated anyway.\n    if (jsonS != null && !isShard) {\n      for (String json : jsonS) {\n        getParamsFromJSON(newMap, json);\n      }\n    }\n\n    // first populate defaults, etc..\n    if (defaults != null) {\n      Map<String, String[]> defaultsMap = MultiMapSolrParams.asMultiMap(defaults);\n      for (Map.Entry<String, String[]> entry : defaultsMap.entrySet()) {\n        String key = entry.getKey();\n        if (!newMap.containsKey(key)) {\n          newMap.put(key, entry.getValue());\n        }\n      }\n    }\n\n    if (appends != null) {\n      Map<String, String[]> appendsMap = MultiMapSolrParams.asMultiMap(appends);\n\n      for (Map.Entry<String, String[]> entry : appendsMap.entrySet()) {\n        String key = entry.getKey();\n        String[] arr = newMap.get(key);\n        if (arr == null) {\n          newMap.put(key, entry.getValue());\n        } else {\n          String[] appendArr = entry.getValue();\n          String[] newArr = new String[arr.length + appendArr.length];\n          System.arraycopy(arr, 0, newArr, 0, arr.length);\n          System.arraycopy(appendArr, 0, newArr, arr.length, appendArr.length);\n          newMap.put(key, newArr);\n        }\n      }\n    }\n\n\n    if (invariants != null) {\n      newMap.putAll( MultiMapSolrParams.asMultiMap(invariants) );\n    }\n\n    if (!isShard) { // Don't expand macros in shard requests\n      String[] doMacrosStr = newMap.get(\"expandMacros\");\n      boolean doMacros = true;\n      if (doMacrosStr != null) {\n        doMacros = \"true\".equals(doMacrosStr[0]);\n      }\n\n      if (doMacros) {\n        newMap = MacroExpander.expand(newMap);\n      }\n    }\n    // Set these params as soon as possible so if there is an error processing later, things like\n    // \"wt=json\" will take effect from the defaults.\n    SolrParams newParams = new MultiMapSolrParams(newMap);  // newMap may still change below, but that should be OK\n    req.setParams(newParams);\n\n\n    // Skip the rest of the processing (including json processing for now) if this isn't a search handler.\n    // For example json.command started to be used  in SOLR-6294, and that caused errors here.\n    if (!searchHandler) return;\n\n\n    Map<String, Object> json = null;\n    // Handle JSON body first, so query params will always overlay on that\n    jsonS = newMap.get(JSON);\n    if (jsonS != null) {\n      if (json == null) {\n        json = new LinkedHashMap<>();\n      }\n      mergeJSON(json, JSON, jsonS, new ObjectUtil.ConflictHandler());\n    }\n    for (String key : newMap.keySet()) {\n      // json.nl, json.wrf are existing query parameters\n      if (key.startsWith(\"json.\") && !(\"json.nl\".equals(key) || \"json.wrf\".equals(key))) {\n        if (json == null) {\n          json = new LinkedHashMap<>();\n        }\n        mergeJSON(json, key, newMap.get(key), new ObjectUtil.ConflictHandler());\n      }\n    }\n\n    // implement compat for existing components...\n    if (json != null && !isShard) {\n      for (Map.Entry<String,Object> entry : json.entrySet()) {\n        String key = entry.getKey();\n        String out = null;\n        boolean arr = false;\n        if (\"query\".equals(key)) {\n          out = \"q\";\n        } else if (\"filter\".equals(key)) {\n          out = \"fq\";\n          arr = true;\n        } else if (\"fields\".equals(key)) {\n          out = \"fl\";\n          arr = true;\n        } else if (\"offset\".equals(key)) {\n          out = \"start\";\n        } else if (\"limit\".equals(key)) {\n          out = \"rows\";\n        } else if (\"sort\".equals(key)) {\n          out = \"sort\";\n        } else if (\"params\".equals(key) || \"facet\".equals(key) ) {\n          // handled elsewhere\n          continue;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown top-level key in JSON request : \" + key);\n        }\n\n        Object val = entry.getValue();\n\n        if (arr) {\n          String[] existing = newMap.get(out);\n          List lst = val instanceof List ? (List)val : null;\n          int existingSize = existing==null ? 0 : existing.length;\n          int jsonSize = lst==null ? 1 : lst.size();\n          String[] newval = new String[ existingSize + jsonSize ];\n          for (int i=0; i<existingSize; i++) {\n            newval[i] = existing[i];\n          }\n          if (lst != null) {\n            for (int i = 0; i < jsonSize; i++) {\n              Object v = lst.get(i);\n              newval[existingSize + i] = v.toString();\n            }\n          } else {\n            newval[newval.length-1] = val.toString();\n          }\n          newMap.put(out, newval);\n        } else {\n          newMap.put(out, new String[]{val.toString()});\n        }\n\n      }\n\n\n    }\n\n    if (json != null) {\n      req.setJSON(json);\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Set default-ish params on a SolrQueryRequest as well as do standard macro processing and JSON request parsing.\n   *\n   * @param handler The search handler this is for (may be null if you don't want this method touching the content streams)\n   * @param req The request whose params we are interested in\n   * @param defaults values to be used if no values are specified in the request params\n   * @param appends values to be appended to those from the request (or defaults) when dealing with multi-val params, or treated as another layer of defaults for singl-val params.\n   * @param invariants values which will be used instead of any request, or default values, regardless of context.\n   */\n  public static void processParams(SolrRequestHandler handler, SolrQueryRequest req, SolrParams defaults,\n                                   SolrParams appends, SolrParams invariants) {\n\n    boolean searchHandler = handler instanceof SearchHandler;\n    SolrParams params = req.getParams();\n\n    // Handle JSON stream for search requests\n    if (searchHandler && req.getContentStreams() != null) {\n\n      Map<String,String[]> map = MultiMapSolrParams.asMultiMap(params, false);\n\n      if (!(params instanceof MultiMapSolrParams || params instanceof ModifiableSolrParams)) {\n        // need to set params on request since we weren't able to access the original map\n        params = new MultiMapSolrParams(map);\n        req.setParams(params);\n      }\n\n      String[] jsonFromParams = map.remove(JSON);  // params from the query string should come after (and hence override) JSON content streams\n\n      for (ContentStream cs : req.getContentStreams()) {\n        String contentType = cs.getContentType();\n        if (contentType==null || !contentType.contains(\"/json\")) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad contentType for search handler :\" + contentType + \" request=\"+req);\n        }\n\n        try {\n          String jsonString = IOUtils.toString( cs.getReader() );\n          if (jsonString != null) {\n            MultiMapSolrParams.addParam(JSON, jsonString, map);\n          }\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Exception reading content stream for request:\"+req, e);\n        }\n      }\n\n      // append existing \"json\" params\n      if (jsonFromParams != null) {\n        for (String json : jsonFromParams) {\n          MultiMapSolrParams.addParam(JSON, json, map);\n        }\n      }\n    }\n\n    String[] jsonS = params.getParams(JSON);\n\n    boolean hasAdditions = defaults != null || invariants != null || appends != null || jsonS != null;\n\n    // short circuit processing\n    if (!hasAdditions && !params.getBool(\"expandMacros\", true)) {\n      return;  // nothing to do...\n    }\n\n    boolean isShard = params.getBool(\"isShard\", false);\n\n    Map<String, String[]> newMap = MultiMapSolrParams.asMultiMap(params, hasAdditions);\n\n\n    // see if the json has a \"params\" section\n    // TODO: we should currently *not* do this if this is a leaf of a distributed search since it could overwrite parameters set by the top-level\n    // The parameters we extract will be propagated anyway.\n    if (jsonS != null && !isShard) {\n      for (String json : jsonS) {\n        getParamsFromJSON(newMap, json);\n      }\n    }\n\n    // first populate defaults, etc..\n    if (defaults != null) {\n      Map<String, String[]> defaultsMap = MultiMapSolrParams.asMultiMap(defaults);\n      for (Map.Entry<String, String[]> entry : defaultsMap.entrySet()) {\n        String key = entry.getKey();\n        if (!newMap.containsKey(key)) {\n          newMap.put(key, entry.getValue());\n        }\n      }\n    }\n\n    if (appends != null) {\n      Map<String, String[]> appendsMap = MultiMapSolrParams.asMultiMap(appends);\n\n      for (Map.Entry<String, String[]> entry : appendsMap.entrySet()) {\n        String key = entry.getKey();\n        String[] arr = newMap.get(key);\n        if (arr == null) {\n          newMap.put(key, entry.getValue());\n        } else {\n          String[] appendArr = entry.getValue();\n          String[] newArr = new String[arr.length + appendArr.length];\n          System.arraycopy(arr, 0, newArr, 0, arr.length);\n          System.arraycopy(appendArr, 0, newArr, arr.length, appendArr.length);\n          newMap.put(key, newArr);\n        }\n      }\n    }\n\n\n    if (invariants != null) {\n      newMap.putAll( MultiMapSolrParams.asMultiMap(invariants) );\n    }\n\n    String[] doMacrosStr = newMap.get(\"expandMacros\");\n    boolean doMacros = true;\n    if (doMacrosStr != null) {\n      doMacros = \"true\".equals(doMacrosStr[0]);\n    }\n\n    if (doMacros) {\n      newMap = MacroExpander.expand(newMap);\n    }\n    // Set these params as soon as possible so if there is an error processing later, things like\n    // \"wt=json\" will take effect from the defaults.\n    SolrParams newParams = new MultiMapSolrParams(newMap);  // newMap may still change below, but that should be OK\n    req.setParams(newParams);\n\n\n    // Skip the rest of the processing (including json processing for now) if this isn't a search handler.\n    // For example json.command started to be used  in SOLR-6294, and that caused errors here.\n    if (!searchHandler) return;\n\n\n    Map<String, Object> json = null;\n    // Handle JSON body first, so query params will always overlay on that\n    jsonS = newMap.get(JSON);\n    if (jsonS != null) {\n      if (json == null) {\n        json = new LinkedHashMap<>();\n      }\n      mergeJSON(json, JSON, jsonS, new ObjectUtil.ConflictHandler());\n    }\n    for (String key : newMap.keySet()) {\n      // json.nl, json.wrf are existing query parameters\n      if (key.startsWith(\"json.\") && !(\"json.nl\".equals(key) || \"json.wrf\".equals(key))) {\n        if (json == null) {\n          json = new LinkedHashMap<>();\n        }\n        mergeJSON(json, key, newMap.get(key), new ObjectUtil.ConflictHandler());\n      }\n    }\n\n    // implement compat for existing components...\n    if (json != null && !isShard) {\n      for (Map.Entry<String,Object> entry : json.entrySet()) {\n        String key = entry.getKey();\n        String out = null;\n        boolean arr = false;\n        if (\"query\".equals(key)) {\n          out = \"q\";\n        } else if (\"filter\".equals(key)) {\n          out = \"fq\";\n          arr = true;\n        } else if (\"fields\".equals(key)) {\n          out = \"fl\";\n          arr = true;\n        } else if (\"offset\".equals(key)) {\n          out = \"start\";\n        } else if (\"limit\".equals(key)) {\n          out = \"rows\";\n        } else if (\"sort\".equals(key)) {\n          out = \"sort\";\n        } else if (\"params\".equals(key) || \"facet\".equals(key) ) {\n          // handled elsewhere\n          continue;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown top-level key in JSON request : \" + key);\n        }\n\n        Object val = entry.getValue();\n\n        if (arr) {\n          String[] existing = newMap.get(out);\n          List lst = val instanceof List ? (List)val : null;\n          int existingSize = existing==null ? 0 : existing.length;\n          int jsonSize = lst==null ? 1 : lst.size();\n          String[] newval = new String[ existingSize + jsonSize ];\n          for (int i=0; i<existingSize; i++) {\n            newval[i] = existing[i];\n          }\n          if (lst != null) {\n            for (int i = 0; i < jsonSize; i++) {\n              Object v = lst.get(i);\n              newval[existingSize + i] = v.toString();\n            }\n          } else {\n            newval[newval.length-1] = val.toString();\n          }\n          newMap.put(out, newval);\n        } else {\n          newMap.put(out, new String[]{val.toString()});\n        }\n\n      }\n\n\n    }\n\n    if (json != null) {\n      req.setJSON(json);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"01624b85de12fb02335810bdf325124e59040772","date":1490254940,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/json/RequestUtil#processParams(SolrRequestHandler,SolrQueryRequest,SolrParams,SolrParams,SolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/json/RequestUtil#processParams(SolrRequestHandler,SolrQueryRequest,SolrParams,SolrParams,SolrParams).mjava","sourceNew":"  /**\n   * Set default-ish params on a SolrQueryRequest as well as do standard macro processing and JSON request parsing.\n   *\n   * @param handler The search handler this is for (may be null if you don't want this method touching the content streams)\n   * @param req The request whose params we are interested in\n   * @param defaults values to be used if no values are specified in the request params\n   * @param appends values to be appended to those from the request (or defaults) when dealing with multi-val params, or treated as another layer of defaults for singl-val params.\n   * @param invariants values which will be used instead of any request, or default values, regardless of context.\n   */\n  public static void processParams(SolrRequestHandler handler, SolrQueryRequest req, SolrParams defaults,\n                                   SolrParams appends, SolrParams invariants) {\n\n    boolean searchHandler = handler instanceof SearchHandler;\n    SolrParams params = req.getParams();\n\n    // Handle JSON stream for search requests\n    if (searchHandler && req.getContentStreams() != null) {\n\n      Map<String,String[]> map = MultiMapSolrParams.asMultiMap(params, false);\n\n      if (!(params instanceof MultiMapSolrParams || params instanceof ModifiableSolrParams)) {\n        // need to set params on request since we weren't able to access the original map\n        params = new MultiMapSolrParams(map);\n        req.setParams(params);\n      }\n\n      String[] jsonFromParams = map.remove(JSON);  // params from the query string should come after (and hence override) JSON content streams\n\n      for (ContentStream cs : req.getContentStreams()) {\n        String contentType = cs.getContentType();\n        if (contentType==null || !contentType.contains(\"/json\")) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad contentType for search handler :\" + contentType + \" request=\"+req);\n        }\n\n        try {\n          String jsonString = IOUtils.toString( cs.getReader() );\n          if (jsonString != null) {\n            MultiMapSolrParams.addParam(JSON, jsonString, map);\n          }\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Exception reading content stream for request:\"+req, e);\n        }\n      }\n\n      // append existing \"json\" params\n      if (jsonFromParams != null) {\n        for (String json : jsonFromParams) {\n          MultiMapSolrParams.addParam(JSON, json, map);\n        }\n      }\n    }\n\n    String[] jsonS = params.getParams(JSON);\n\n    boolean hasAdditions = defaults != null || invariants != null || appends != null || jsonS != null;\n\n    // short circuit processing\n    if (!hasAdditions && !params.getBool(\"expandMacros\", true)) {\n      return;  // nothing to do...\n    }\n\n    boolean isShard = params.getBool(\"isShard\", false);\n\n    Map<String, String[]> newMap = MultiMapSolrParams.asMultiMap(params, hasAdditions);\n\n\n    // see if the json has a \"params\" section\n    // TODO: we should currently *not* do this if this is a leaf of a distributed search since it could overwrite parameters set by the top-level\n    // The parameters we extract will be propagated anyway.\n    if (jsonS != null && !isShard) {\n      for (String json : jsonS) {\n        getParamsFromJSON(newMap, json);\n      }\n    }\n\n    // first populate defaults, etc..\n    if (defaults != null) {\n      Map<String, String[]> defaultsMap = MultiMapSolrParams.asMultiMap(defaults);\n      for (Map.Entry<String, String[]> entry : defaultsMap.entrySet()) {\n        String key = entry.getKey();\n        if (!newMap.containsKey(key)) {\n          newMap.put(key, entry.getValue());\n        }\n      }\n    }\n\n    if (appends != null) {\n      Map<String, String[]> appendsMap = MultiMapSolrParams.asMultiMap(appends);\n\n      for (Map.Entry<String, String[]> entry : appendsMap.entrySet()) {\n        String key = entry.getKey();\n        String[] arr = newMap.get(key);\n        if (arr == null) {\n          newMap.put(key, entry.getValue());\n        } else {\n          String[] appendArr = entry.getValue();\n          String[] newArr = new String[arr.length + appendArr.length];\n          System.arraycopy(arr, 0, newArr, 0, arr.length);\n          System.arraycopy(appendArr, 0, newArr, arr.length, appendArr.length);\n          newMap.put(key, newArr);\n        }\n      }\n    }\n\n\n    if (invariants != null) {\n      newMap.putAll( MultiMapSolrParams.asMultiMap(invariants) );\n    }\n\n    if (!isShard) { // Don't expand macros in shard requests\n      String[] doMacrosStr = newMap.get(\"expandMacros\");\n      boolean doMacros = true;\n      if (doMacrosStr != null) {\n        doMacros = \"true\".equals(doMacrosStr[0]);\n      }\n\n      if (doMacros) {\n        newMap = MacroExpander.expand(newMap);\n      }\n    }\n    // Set these params as soon as possible so if there is an error processing later, things like\n    // \"wt=json\" will take effect from the defaults.\n    SolrParams newParams = new MultiMapSolrParams(newMap);  // newMap may still change below, but that should be OK\n    req.setParams(newParams);\n\n\n    // Skip the rest of the processing (including json processing for now) if this isn't a search handler.\n    // For example json.command started to be used  in SOLR-6294, and that caused errors here.\n    if (!searchHandler) return;\n\n\n    Map<String, Object> json = null;\n    // Handle JSON body first, so query params will always overlay on that\n    jsonS = newMap.get(JSON);\n    if (jsonS != null) {\n      if (json == null) {\n        json = new LinkedHashMap<>();\n      }\n      mergeJSON(json, JSON, jsonS, new ObjectUtil.ConflictHandler());\n    }\n    for (String key : newMap.keySet()) {\n      // json.nl, json.wrf are existing query parameters\n      if (key.startsWith(\"json.\") && !(\"json.nl\".equals(key) || \"json.wrf\".equals(key))) {\n        if (json == null) {\n          json = new LinkedHashMap<>();\n        }\n        mergeJSON(json, key, newMap.get(key), new ObjectUtil.ConflictHandler());\n      }\n    }\n\n    // implement compat for existing components...\n    if (json != null && !isShard) {\n      for (Map.Entry<String,Object> entry : json.entrySet()) {\n        String key = entry.getKey();\n        String out = null;\n        boolean arr = false;\n        if (\"query\".equals(key)) {\n          out = \"q\";\n        } else if (\"filter\".equals(key)) {\n          out = \"fq\";\n          arr = true;\n        } else if (\"fields\".equals(key)) {\n          out = \"fl\";\n          arr = true;\n        } else if (\"offset\".equals(key)) {\n          out = \"start\";\n        } else if (\"limit\".equals(key)) {\n          out = \"rows\";\n        } else if (SORT.equals(key)) {\n          out = SORT;\n        } else if (\"params\".equals(key) || \"facet\".equals(key) ) {\n          // handled elsewhere\n          continue;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown top-level key in JSON request : \" + key);\n        }\n\n        Object val = entry.getValue();\n\n        if (arr) {\n          String[] existing = newMap.get(out);\n          List lst = val instanceof List ? (List)val : null;\n          int existingSize = existing==null ? 0 : existing.length;\n          int jsonSize = lst==null ? 1 : lst.size();\n          String[] newval = new String[ existingSize + jsonSize ];\n          for (int i=0; i<existingSize; i++) {\n            newval[i] = existing[i];\n          }\n          if (lst != null) {\n            for (int i = 0; i < jsonSize; i++) {\n              Object v = lst.get(i);\n              newval[existingSize + i] = v.toString();\n            }\n          } else {\n            newval[newval.length-1] = val.toString();\n          }\n          newMap.put(out, newval);\n        } else {\n          newMap.put(out, new String[]{val.toString()});\n        }\n\n      }\n\n\n    }\n\n    if (json != null) {\n      req.setJSON(json);\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Set default-ish params on a SolrQueryRequest as well as do standard macro processing and JSON request parsing.\n   *\n   * @param handler The search handler this is for (may be null if you don't want this method touching the content streams)\n   * @param req The request whose params we are interested in\n   * @param defaults values to be used if no values are specified in the request params\n   * @param appends values to be appended to those from the request (or defaults) when dealing with multi-val params, or treated as another layer of defaults for singl-val params.\n   * @param invariants values which will be used instead of any request, or default values, regardless of context.\n   */\n  public static void processParams(SolrRequestHandler handler, SolrQueryRequest req, SolrParams defaults,\n                                   SolrParams appends, SolrParams invariants) {\n\n    boolean searchHandler = handler instanceof SearchHandler;\n    SolrParams params = req.getParams();\n\n    // Handle JSON stream for search requests\n    if (searchHandler && req.getContentStreams() != null) {\n\n      Map<String,String[]> map = MultiMapSolrParams.asMultiMap(params, false);\n\n      if (!(params instanceof MultiMapSolrParams || params instanceof ModifiableSolrParams)) {\n        // need to set params on request since we weren't able to access the original map\n        params = new MultiMapSolrParams(map);\n        req.setParams(params);\n      }\n\n      String[] jsonFromParams = map.remove(JSON);  // params from the query string should come after (and hence override) JSON content streams\n\n      for (ContentStream cs : req.getContentStreams()) {\n        String contentType = cs.getContentType();\n        if (contentType==null || !contentType.contains(\"/json\")) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad contentType for search handler :\" + contentType + \" request=\"+req);\n        }\n\n        try {\n          String jsonString = IOUtils.toString( cs.getReader() );\n          if (jsonString != null) {\n            MultiMapSolrParams.addParam(JSON, jsonString, map);\n          }\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Exception reading content stream for request:\"+req, e);\n        }\n      }\n\n      // append existing \"json\" params\n      if (jsonFromParams != null) {\n        for (String json : jsonFromParams) {\n          MultiMapSolrParams.addParam(JSON, json, map);\n        }\n      }\n    }\n\n    String[] jsonS = params.getParams(JSON);\n\n    boolean hasAdditions = defaults != null || invariants != null || appends != null || jsonS != null;\n\n    // short circuit processing\n    if (!hasAdditions && !params.getBool(\"expandMacros\", true)) {\n      return;  // nothing to do...\n    }\n\n    boolean isShard = params.getBool(\"isShard\", false);\n\n    Map<String, String[]> newMap = MultiMapSolrParams.asMultiMap(params, hasAdditions);\n\n\n    // see if the json has a \"params\" section\n    // TODO: we should currently *not* do this if this is a leaf of a distributed search since it could overwrite parameters set by the top-level\n    // The parameters we extract will be propagated anyway.\n    if (jsonS != null && !isShard) {\n      for (String json : jsonS) {\n        getParamsFromJSON(newMap, json);\n      }\n    }\n\n    // first populate defaults, etc..\n    if (defaults != null) {\n      Map<String, String[]> defaultsMap = MultiMapSolrParams.asMultiMap(defaults);\n      for (Map.Entry<String, String[]> entry : defaultsMap.entrySet()) {\n        String key = entry.getKey();\n        if (!newMap.containsKey(key)) {\n          newMap.put(key, entry.getValue());\n        }\n      }\n    }\n\n    if (appends != null) {\n      Map<String, String[]> appendsMap = MultiMapSolrParams.asMultiMap(appends);\n\n      for (Map.Entry<String, String[]> entry : appendsMap.entrySet()) {\n        String key = entry.getKey();\n        String[] arr = newMap.get(key);\n        if (arr == null) {\n          newMap.put(key, entry.getValue());\n        } else {\n          String[] appendArr = entry.getValue();\n          String[] newArr = new String[arr.length + appendArr.length];\n          System.arraycopy(arr, 0, newArr, 0, arr.length);\n          System.arraycopy(appendArr, 0, newArr, arr.length, appendArr.length);\n          newMap.put(key, newArr);\n        }\n      }\n    }\n\n\n    if (invariants != null) {\n      newMap.putAll( MultiMapSolrParams.asMultiMap(invariants) );\n    }\n\n    if (!isShard) { // Don't expand macros in shard requests\n      String[] doMacrosStr = newMap.get(\"expandMacros\");\n      boolean doMacros = true;\n      if (doMacrosStr != null) {\n        doMacros = \"true\".equals(doMacrosStr[0]);\n      }\n\n      if (doMacros) {\n        newMap = MacroExpander.expand(newMap);\n      }\n    }\n    // Set these params as soon as possible so if there is an error processing later, things like\n    // \"wt=json\" will take effect from the defaults.\n    SolrParams newParams = new MultiMapSolrParams(newMap);  // newMap may still change below, but that should be OK\n    req.setParams(newParams);\n\n\n    // Skip the rest of the processing (including json processing for now) if this isn't a search handler.\n    // For example json.command started to be used  in SOLR-6294, and that caused errors here.\n    if (!searchHandler) return;\n\n\n    Map<String, Object> json = null;\n    // Handle JSON body first, so query params will always overlay on that\n    jsonS = newMap.get(JSON);\n    if (jsonS != null) {\n      if (json == null) {\n        json = new LinkedHashMap<>();\n      }\n      mergeJSON(json, JSON, jsonS, new ObjectUtil.ConflictHandler());\n    }\n    for (String key : newMap.keySet()) {\n      // json.nl, json.wrf are existing query parameters\n      if (key.startsWith(\"json.\") && !(\"json.nl\".equals(key) || \"json.wrf\".equals(key))) {\n        if (json == null) {\n          json = new LinkedHashMap<>();\n        }\n        mergeJSON(json, key, newMap.get(key), new ObjectUtil.ConflictHandler());\n      }\n    }\n\n    // implement compat for existing components...\n    if (json != null && !isShard) {\n      for (Map.Entry<String,Object> entry : json.entrySet()) {\n        String key = entry.getKey();\n        String out = null;\n        boolean arr = false;\n        if (\"query\".equals(key)) {\n          out = \"q\";\n        } else if (\"filter\".equals(key)) {\n          out = \"fq\";\n          arr = true;\n        } else if (\"fields\".equals(key)) {\n          out = \"fl\";\n          arr = true;\n        } else if (\"offset\".equals(key)) {\n          out = \"start\";\n        } else if (\"limit\".equals(key)) {\n          out = \"rows\";\n        } else if (\"sort\".equals(key)) {\n          out = \"sort\";\n        } else if (\"params\".equals(key) || \"facet\".equals(key) ) {\n          // handled elsewhere\n          continue;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown top-level key in JSON request : \" + key);\n        }\n\n        Object val = entry.getValue();\n\n        if (arr) {\n          String[] existing = newMap.get(out);\n          List lst = val instanceof List ? (List)val : null;\n          int existingSize = existing==null ? 0 : existing.length;\n          int jsonSize = lst==null ? 1 : lst.size();\n          String[] newval = new String[ existingSize + jsonSize ];\n          for (int i=0; i<existingSize; i++) {\n            newval[i] = existing[i];\n          }\n          if (lst != null) {\n            for (int i = 0; i < jsonSize; i++) {\n              Object v = lst.get(i);\n              newval[existingSize + i] = v.toString();\n            }\n          } else {\n            newval[newval.length-1] = val.toString();\n          }\n          newMap.put(out, newval);\n        } else {\n          newMap.put(out, new String[]{val.toString()});\n        }\n\n      }\n\n\n    }\n\n    if (json != null) {\n      req.setJSON(json);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6f4c5d3859373c3a74734e85efa122b17514e3e8","date":1490280013,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/json/RequestUtil#processParams(SolrRequestHandler,SolrQueryRequest,SolrParams,SolrParams,SolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/json/RequestUtil#processParams(SolrRequestHandler,SolrQueryRequest,SolrParams,SolrParams,SolrParams).mjava","sourceNew":"  /**\n   * Set default-ish params on a SolrQueryRequest as well as do standard macro processing and JSON request parsing.\n   *\n   * @param handler The search handler this is for (may be null if you don't want this method touching the content streams)\n   * @param req The request whose params we are interested in\n   * @param defaults values to be used if no values are specified in the request params\n   * @param appends values to be appended to those from the request (or defaults) when dealing with multi-val params, or treated as another layer of defaults for singl-val params.\n   * @param invariants values which will be used instead of any request, or default values, regardless of context.\n   */\n  public static void processParams(SolrRequestHandler handler, SolrQueryRequest req, SolrParams defaults,\n                                   SolrParams appends, SolrParams invariants) {\n\n    boolean searchHandler = handler instanceof SearchHandler;\n    SolrParams params = req.getParams();\n\n    // Handle JSON stream for search requests\n    if (searchHandler && req.getContentStreams() != null) {\n\n      Map<String,String[]> map = MultiMapSolrParams.asMultiMap(params, false);\n\n      if (!(params instanceof MultiMapSolrParams || params instanceof ModifiableSolrParams)) {\n        // need to set params on request since we weren't able to access the original map\n        params = new MultiMapSolrParams(map);\n        req.setParams(params);\n      }\n\n      String[] jsonFromParams = map.remove(JSON);  // params from the query string should come after (and hence override) JSON content streams\n\n      for (ContentStream cs : req.getContentStreams()) {\n        String contentType = cs.getContentType();\n        if (contentType==null || !contentType.contains(\"/json\")) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad contentType for search handler :\" + contentType + \" request=\"+req);\n        }\n\n        try {\n          String jsonString = IOUtils.toString( cs.getReader() );\n          if (jsonString != null) {\n            MultiMapSolrParams.addParam(JSON, jsonString, map);\n          }\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Exception reading content stream for request:\"+req, e);\n        }\n      }\n\n      // append existing \"json\" params\n      if (jsonFromParams != null) {\n        for (String json : jsonFromParams) {\n          MultiMapSolrParams.addParam(JSON, json, map);\n        }\n      }\n    }\n\n    String[] jsonS = params.getParams(JSON);\n\n    boolean hasAdditions = defaults != null || invariants != null || appends != null || jsonS != null;\n\n    // short circuit processing\n    if (!hasAdditions && !params.getBool(\"expandMacros\", true)) {\n      return;  // nothing to do...\n    }\n\n    boolean isShard = params.getBool(\"isShard\", false);\n\n    Map<String, String[]> newMap = MultiMapSolrParams.asMultiMap(params, hasAdditions);\n\n\n    // see if the json has a \"params\" section\n    // TODO: we should currently *not* do this if this is a leaf of a distributed search since it could overwrite parameters set by the top-level\n    // The parameters we extract will be propagated anyway.\n    if (jsonS != null && !isShard) {\n      for (String json : jsonS) {\n        getParamsFromJSON(newMap, json);\n      }\n    }\n\n    // first populate defaults, etc..\n    if (defaults != null) {\n      Map<String, String[]> defaultsMap = MultiMapSolrParams.asMultiMap(defaults);\n      for (Map.Entry<String, String[]> entry : defaultsMap.entrySet()) {\n        String key = entry.getKey();\n        if (!newMap.containsKey(key)) {\n          newMap.put(key, entry.getValue());\n        }\n      }\n    }\n\n    if (appends != null) {\n      Map<String, String[]> appendsMap = MultiMapSolrParams.asMultiMap(appends);\n\n      for (Map.Entry<String, String[]> entry : appendsMap.entrySet()) {\n        String key = entry.getKey();\n        String[] arr = newMap.get(key);\n        if (arr == null) {\n          newMap.put(key, entry.getValue());\n        } else {\n          String[] appendArr = entry.getValue();\n          String[] newArr = new String[arr.length + appendArr.length];\n          System.arraycopy(arr, 0, newArr, 0, arr.length);\n          System.arraycopy(appendArr, 0, newArr, arr.length, appendArr.length);\n          newMap.put(key, newArr);\n        }\n      }\n    }\n\n\n    if (invariants != null) {\n      newMap.putAll( MultiMapSolrParams.asMultiMap(invariants) );\n    }\n\n    if (!isShard) { // Don't expand macros in shard requests\n      String[] doMacrosStr = newMap.get(\"expandMacros\");\n      boolean doMacros = true;\n      if (doMacrosStr != null) {\n        doMacros = \"true\".equals(doMacrosStr[0]);\n      }\n\n      if (doMacros) {\n        newMap = MacroExpander.expand(newMap);\n      }\n    }\n    // Set these params as soon as possible so if there is an error processing later, things like\n    // \"wt=json\" will take effect from the defaults.\n    SolrParams newParams = new MultiMapSolrParams(newMap);  // newMap may still change below, but that should be OK\n    req.setParams(newParams);\n\n\n    // Skip the rest of the processing (including json processing for now) if this isn't a search handler.\n    // For example json.command started to be used  in SOLR-6294, and that caused errors here.\n    if (!searchHandler) return;\n\n\n    Map<String, Object> json = null;\n    // Handle JSON body first, so query params will always overlay on that\n    jsonS = newMap.get(JSON);\n    if (jsonS != null) {\n      if (json == null) {\n        json = new LinkedHashMap<>();\n      }\n      mergeJSON(json, JSON, jsonS, new ObjectUtil.ConflictHandler());\n    }\n    for (String key : newMap.keySet()) {\n      // json.nl, json.wrf are existing query parameters\n      if (key.startsWith(\"json.\") && !(\"json.nl\".equals(key) || \"json.wrf\".equals(key))) {\n        if (json == null) {\n          json = new LinkedHashMap<>();\n        }\n        mergeJSON(json, key, newMap.get(key), new ObjectUtil.ConflictHandler());\n      }\n    }\n\n    // implement compat for existing components...\n    if (json != null && !isShard) {\n      for (Map.Entry<String,Object> entry : json.entrySet()) {\n        String key = entry.getKey();\n        String out = null;\n        boolean arr = false;\n        if (\"query\".equals(key)) {\n          out = \"q\";\n        } else if (\"filter\".equals(key)) {\n          out = \"fq\";\n          arr = true;\n        } else if (\"fields\".equals(key)) {\n          out = \"fl\";\n          arr = true;\n        } else if (\"offset\".equals(key)) {\n          out = \"start\";\n        } else if (\"limit\".equals(key)) {\n          out = \"rows\";\n        } else if (SORT.equals(key)) {\n          out = SORT;\n        } else if (\"params\".equals(key) || \"facet\".equals(key) ) {\n          // handled elsewhere\n          continue;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown top-level key in JSON request : \" + key);\n        }\n\n        Object val = entry.getValue();\n\n        if (arr) {\n          String[] existing = newMap.get(out);\n          List lst = val instanceof List ? (List)val : null;\n          int existingSize = existing==null ? 0 : existing.length;\n          int jsonSize = lst==null ? 1 : lst.size();\n          String[] newval = new String[ existingSize + jsonSize ];\n          for (int i=0; i<existingSize; i++) {\n            newval[i] = existing[i];\n          }\n          if (lst != null) {\n            for (int i = 0; i < jsonSize; i++) {\n              Object v = lst.get(i);\n              newval[existingSize + i] = v.toString();\n            }\n          } else {\n            newval[newval.length-1] = val.toString();\n          }\n          newMap.put(out, newval);\n        } else {\n          newMap.put(out, new String[]{val.toString()});\n        }\n\n      }\n\n\n    }\n\n    if (json != null) {\n      req.setJSON(json);\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Set default-ish params on a SolrQueryRequest as well as do standard macro processing and JSON request parsing.\n   *\n   * @param handler The search handler this is for (may be null if you don't want this method touching the content streams)\n   * @param req The request whose params we are interested in\n   * @param defaults values to be used if no values are specified in the request params\n   * @param appends values to be appended to those from the request (or defaults) when dealing with multi-val params, or treated as another layer of defaults for singl-val params.\n   * @param invariants values which will be used instead of any request, or default values, regardless of context.\n   */\n  public static void processParams(SolrRequestHandler handler, SolrQueryRequest req, SolrParams defaults,\n                                   SolrParams appends, SolrParams invariants) {\n\n    boolean searchHandler = handler instanceof SearchHandler;\n    SolrParams params = req.getParams();\n\n    // Handle JSON stream for search requests\n    if (searchHandler && req.getContentStreams() != null) {\n\n      Map<String,String[]> map = MultiMapSolrParams.asMultiMap(params, false);\n\n      if (!(params instanceof MultiMapSolrParams || params instanceof ModifiableSolrParams)) {\n        // need to set params on request since we weren't able to access the original map\n        params = new MultiMapSolrParams(map);\n        req.setParams(params);\n      }\n\n      String[] jsonFromParams = map.remove(JSON);  // params from the query string should come after (and hence override) JSON content streams\n\n      for (ContentStream cs : req.getContentStreams()) {\n        String contentType = cs.getContentType();\n        if (contentType==null || !contentType.contains(\"/json\")) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad contentType for search handler :\" + contentType + \" request=\"+req);\n        }\n\n        try {\n          String jsonString = IOUtils.toString( cs.getReader() );\n          if (jsonString != null) {\n            MultiMapSolrParams.addParam(JSON, jsonString, map);\n          }\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Exception reading content stream for request:\"+req, e);\n        }\n      }\n\n      // append existing \"json\" params\n      if (jsonFromParams != null) {\n        for (String json : jsonFromParams) {\n          MultiMapSolrParams.addParam(JSON, json, map);\n        }\n      }\n    }\n\n    String[] jsonS = params.getParams(JSON);\n\n    boolean hasAdditions = defaults != null || invariants != null || appends != null || jsonS != null;\n\n    // short circuit processing\n    if (!hasAdditions && !params.getBool(\"expandMacros\", true)) {\n      return;  // nothing to do...\n    }\n\n    boolean isShard = params.getBool(\"isShard\", false);\n\n    Map<String, String[]> newMap = MultiMapSolrParams.asMultiMap(params, hasAdditions);\n\n\n    // see if the json has a \"params\" section\n    // TODO: we should currently *not* do this if this is a leaf of a distributed search since it could overwrite parameters set by the top-level\n    // The parameters we extract will be propagated anyway.\n    if (jsonS != null && !isShard) {\n      for (String json : jsonS) {\n        getParamsFromJSON(newMap, json);\n      }\n    }\n\n    // first populate defaults, etc..\n    if (defaults != null) {\n      Map<String, String[]> defaultsMap = MultiMapSolrParams.asMultiMap(defaults);\n      for (Map.Entry<String, String[]> entry : defaultsMap.entrySet()) {\n        String key = entry.getKey();\n        if (!newMap.containsKey(key)) {\n          newMap.put(key, entry.getValue());\n        }\n      }\n    }\n\n    if (appends != null) {\n      Map<String, String[]> appendsMap = MultiMapSolrParams.asMultiMap(appends);\n\n      for (Map.Entry<String, String[]> entry : appendsMap.entrySet()) {\n        String key = entry.getKey();\n        String[] arr = newMap.get(key);\n        if (arr == null) {\n          newMap.put(key, entry.getValue());\n        } else {\n          String[] appendArr = entry.getValue();\n          String[] newArr = new String[arr.length + appendArr.length];\n          System.arraycopy(arr, 0, newArr, 0, arr.length);\n          System.arraycopy(appendArr, 0, newArr, arr.length, appendArr.length);\n          newMap.put(key, newArr);\n        }\n      }\n    }\n\n\n    if (invariants != null) {\n      newMap.putAll( MultiMapSolrParams.asMultiMap(invariants) );\n    }\n\n    if (!isShard) { // Don't expand macros in shard requests\n      String[] doMacrosStr = newMap.get(\"expandMacros\");\n      boolean doMacros = true;\n      if (doMacrosStr != null) {\n        doMacros = \"true\".equals(doMacrosStr[0]);\n      }\n\n      if (doMacros) {\n        newMap = MacroExpander.expand(newMap);\n      }\n    }\n    // Set these params as soon as possible so if there is an error processing later, things like\n    // \"wt=json\" will take effect from the defaults.\n    SolrParams newParams = new MultiMapSolrParams(newMap);  // newMap may still change below, but that should be OK\n    req.setParams(newParams);\n\n\n    // Skip the rest of the processing (including json processing for now) if this isn't a search handler.\n    // For example json.command started to be used  in SOLR-6294, and that caused errors here.\n    if (!searchHandler) return;\n\n\n    Map<String, Object> json = null;\n    // Handle JSON body first, so query params will always overlay on that\n    jsonS = newMap.get(JSON);\n    if (jsonS != null) {\n      if (json == null) {\n        json = new LinkedHashMap<>();\n      }\n      mergeJSON(json, JSON, jsonS, new ObjectUtil.ConflictHandler());\n    }\n    for (String key : newMap.keySet()) {\n      // json.nl, json.wrf are existing query parameters\n      if (key.startsWith(\"json.\") && !(\"json.nl\".equals(key) || \"json.wrf\".equals(key))) {\n        if (json == null) {\n          json = new LinkedHashMap<>();\n        }\n        mergeJSON(json, key, newMap.get(key), new ObjectUtil.ConflictHandler());\n      }\n    }\n\n    // implement compat for existing components...\n    if (json != null && !isShard) {\n      for (Map.Entry<String,Object> entry : json.entrySet()) {\n        String key = entry.getKey();\n        String out = null;\n        boolean arr = false;\n        if (\"query\".equals(key)) {\n          out = \"q\";\n        } else if (\"filter\".equals(key)) {\n          out = \"fq\";\n          arr = true;\n        } else if (\"fields\".equals(key)) {\n          out = \"fl\";\n          arr = true;\n        } else if (\"offset\".equals(key)) {\n          out = \"start\";\n        } else if (\"limit\".equals(key)) {\n          out = \"rows\";\n        } else if (\"sort\".equals(key)) {\n          out = \"sort\";\n        } else if (\"params\".equals(key) || \"facet\".equals(key) ) {\n          // handled elsewhere\n          continue;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown top-level key in JSON request : \" + key);\n        }\n\n        Object val = entry.getValue();\n\n        if (arr) {\n          String[] existing = newMap.get(out);\n          List lst = val instanceof List ? (List)val : null;\n          int existingSize = existing==null ? 0 : existing.length;\n          int jsonSize = lst==null ? 1 : lst.size();\n          String[] newval = new String[ existingSize + jsonSize ];\n          for (int i=0; i<existingSize; i++) {\n            newval[i] = existing[i];\n          }\n          if (lst != null) {\n            for (int i = 0; i < jsonSize; i++) {\n              Object v = lst.get(i);\n              newval[existingSize + i] = v.toString();\n            }\n          } else {\n            newval[newval.length-1] = val.toString();\n          }\n          newMap.put(out, newval);\n        } else {\n          newMap.put(out, new String[]{val.toString()});\n        }\n\n      }\n\n\n    }\n\n    if (json != null) {\n      req.setJSON(json);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"10eda272dbca4b0397f9b0c2aa6fadad3601db47","date":1504272103,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/json/RequestUtil#processParams(SolrRequestHandler,SolrQueryRequest,SolrParams,SolrParams,SolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/json/RequestUtil#processParams(SolrRequestHandler,SolrQueryRequest,SolrParams,SolrParams,SolrParams).mjava","sourceNew":"  /**\n   * Set default-ish params on a SolrQueryRequest as well as do standard macro processing and JSON request parsing.\n   *\n   * @param handler The search handler this is for (may be null if you don't want this method touching the content streams)\n   * @param req The request whose params we are interested in\n   * @param defaults values to be used if no values are specified in the request params\n   * @param appends values to be appended to those from the request (or defaults) when dealing with multi-val params, or treated as another layer of defaults for singl-val params.\n   * @param invariants values which will be used instead of any request, or default values, regardless of context.\n   */\n  public static void processParams(SolrRequestHandler handler, SolrQueryRequest req, SolrParams defaults,\n                                   SolrParams appends, SolrParams invariants) {\n\n    boolean searchHandler = handler instanceof SearchHandler;\n    SolrParams params = req.getParams();\n\n    // Handle JSON stream for search requests\n    if (searchHandler && req.getContentStreams() != null) {\n\n      Map<String,String[]> map = MultiMapSolrParams.asMultiMap(params, false);\n\n      if (!(params instanceof MultiMapSolrParams || params instanceof ModifiableSolrParams)) {\n        // need to set params on request since we weren't able to access the original map\n        params = new MultiMapSolrParams(map);\n        req.setParams(params);\n      }\n\n      String[] jsonFromParams = map.remove(JSON);  // params from the query string should come after (and hence override) JSON content streams\n\n      for (ContentStream cs : req.getContentStreams()) {\n        String contentType = cs.getContentType();\n        if (contentType==null || !contentType.contains(\"/json\")) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad contentType for search handler :\" + contentType + \" request=\"+req);\n        }\n\n        try {\n          String jsonString = IOUtils.toString( cs.getReader() );\n          if (jsonString != null) {\n            MultiMapSolrParams.addParam(JSON, jsonString, map);\n          }\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Exception reading content stream for request:\"+req, e);\n        }\n      }\n\n      // append existing \"json\" params\n      if (jsonFromParams != null) {\n        for (String json : jsonFromParams) {\n          MultiMapSolrParams.addParam(JSON, json, map);\n        }\n      }\n    }\n\n    String[] jsonS = params.getParams(JSON);\n\n    boolean hasAdditions = defaults != null || invariants != null || appends != null || jsonS != null;\n\n    // short circuit processing\n    if (!hasAdditions && !params.getBool(\"expandMacros\", true)) {\n      return;  // nothing to do...\n    }\n\n    boolean isShard = params.getBool(\"isShard\", false);\n\n    Map<String, String[]> newMap = MultiMapSolrParams.asMultiMap(params, hasAdditions);\n\n\n    // see if the json has a \"params\" section\n    // TODO: we should currently *not* do this if this is a leaf of a distributed search since it could overwrite parameters set by the top-level\n    // The parameters we extract will be propagated anyway.\n    if (jsonS != null && !isShard) {\n      for (String json : jsonS) {\n        getParamsFromJSON(newMap, json);\n      }\n    }\n\n    // first populate defaults, etc..\n    if (defaults != null) {\n      Map<String, String[]> defaultsMap = MultiMapSolrParams.asMultiMap(defaults);\n      for (Map.Entry<String, String[]> entry : defaultsMap.entrySet()) {\n        String key = entry.getKey();\n        if (!newMap.containsKey(key)) {\n          newMap.put(key, entry.getValue());\n        }\n      }\n    }\n\n    if (appends != null) {\n      Map<String, String[]> appendsMap = MultiMapSolrParams.asMultiMap(appends);\n\n      for (Map.Entry<String, String[]> entry : appendsMap.entrySet()) {\n        String key = entry.getKey();\n        String[] arr = newMap.get(key);\n        if (arr == null) {\n          newMap.put(key, entry.getValue());\n        } else {\n          String[] appendArr = entry.getValue();\n          String[] newArr = new String[arr.length + appendArr.length];\n          System.arraycopy(arr, 0, newArr, 0, arr.length);\n          System.arraycopy(appendArr, 0, newArr, arr.length, appendArr.length);\n          newMap.put(key, newArr);\n        }\n      }\n    }\n\n\n    if (invariants != null) {\n      newMap.putAll( MultiMapSolrParams.asMultiMap(invariants) );\n    }\n\n    if (!isShard) { // Don't expand macros in shard requests\n      String[] doMacrosStr = newMap.get(\"expandMacros\");\n      boolean doMacros = true;\n      if (doMacrosStr != null) {\n        doMacros = \"true\".equals(doMacrosStr[0]);\n      }\n\n      if (doMacros) {\n        newMap = MacroExpander.expand(newMap);\n      }\n    }\n    // Set these params as soon as possible so if there is an error processing later, things like\n    // \"wt=json\" will take effect from the defaults.\n    SolrParams newParams = new MultiMapSolrParams(newMap);  // newMap may still change below, but that should be OK\n    req.setParams(newParams);\n\n\n    // Skip the rest of the processing (including json processing for now) if this isn't a search handler.\n    // For example json.command started to be used  in SOLR-6294, and that caused errors here.\n    if (!searchHandler) return;\n\n\n    Map<String, Object> json = null;\n    // Handle JSON body first, so query params will always overlay on that\n    jsonS = newMap.get(JSON);\n    if (jsonS != null) {\n      if (json == null) {\n        json = new LinkedHashMap<>();\n      }\n      mergeJSON(json, JSON, jsonS, new ObjectUtil.ConflictHandler());\n    }\n    for (String key : newMap.keySet()) {\n      // json.nl, json.wrf are existing query parameters\n      if (key.startsWith(\"json.\") && !(\"json.nl\".equals(key) || \"json.wrf\".equals(key))) {\n        if (json == null) {\n          json = new LinkedHashMap<>();\n        }\n        mergeJSON(json, key, newMap.get(key), new ObjectUtil.ConflictHandler());\n      }\n    }\n\n    // implement compat for existing components...\n    JsonQueryConverter jsonQueryConverter = new JsonQueryConverter();\n    if (json != null && !isShard) {\n      for (Map.Entry<String,Object> entry : json.entrySet()) {\n        String key = entry.getKey();\n        String out = null;\n        boolean isQuery = false;\n        boolean arr = false;\n        if (\"query\".equals(key)) {\n          out = \"q\";\n          isQuery = true;\n        } else if (\"filter\".equals(key)) {\n          out = \"fq\";\n          arr = true;\n          isQuery = true;\n        } else if (\"fields\".equals(key)) {\n          out = \"fl\";\n          arr = true;\n        } else if (\"offset\".equals(key)) {\n          out = \"start\";\n        } else if (\"limit\".equals(key)) {\n          out = \"rows\";\n        } else if (SORT.equals(key)) {\n          out = SORT;\n        } else if (\"params\".equals(key) || \"facet\".equals(key) ) {\n          // handled elsewhere\n          continue;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown top-level key in JSON request : \" + key);\n        }\n\n        Object val = entry.getValue();\n\n        if (arr) {\n          String[] existing = newMap.get(out);\n          List lst = val instanceof List ? (List)val : null;\n          int existingSize = existing==null ? 0 : existing.length;\n          int jsonSize = lst==null ? 1 : lst.size();\n          String[] newval = new String[ existingSize + jsonSize ];\n          for (int i=0; i<existingSize; i++) {\n            newval[i] = existing[i];\n          }\n          if (lst != null) {\n            for (int i = 0; i < jsonSize; i++) {\n              Object v = lst.get(i);\n              newval[existingSize + i] = isQuery ? jsonQueryConverter.toLocalParams(v, newMap) : v.toString();\n            }\n          } else {\n            newval[newval.length-1] = isQuery ? jsonQueryConverter.toLocalParams(val, newMap) : val.toString();\n          }\n          newMap.put(out, newval);\n        } else {\n          newMap.put(out, new String[]{isQuery ? jsonQueryConverter.toLocalParams(val, newMap) : val.toString()});\n        }\n\n      }\n\n\n    }\n\n    if (json != null) {\n      req.setJSON(json);\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Set default-ish params on a SolrQueryRequest as well as do standard macro processing and JSON request parsing.\n   *\n   * @param handler The search handler this is for (may be null if you don't want this method touching the content streams)\n   * @param req The request whose params we are interested in\n   * @param defaults values to be used if no values are specified in the request params\n   * @param appends values to be appended to those from the request (or defaults) when dealing with multi-val params, or treated as another layer of defaults for singl-val params.\n   * @param invariants values which will be used instead of any request, or default values, regardless of context.\n   */\n  public static void processParams(SolrRequestHandler handler, SolrQueryRequest req, SolrParams defaults,\n                                   SolrParams appends, SolrParams invariants) {\n\n    boolean searchHandler = handler instanceof SearchHandler;\n    SolrParams params = req.getParams();\n\n    // Handle JSON stream for search requests\n    if (searchHandler && req.getContentStreams() != null) {\n\n      Map<String,String[]> map = MultiMapSolrParams.asMultiMap(params, false);\n\n      if (!(params instanceof MultiMapSolrParams || params instanceof ModifiableSolrParams)) {\n        // need to set params on request since we weren't able to access the original map\n        params = new MultiMapSolrParams(map);\n        req.setParams(params);\n      }\n\n      String[] jsonFromParams = map.remove(JSON);  // params from the query string should come after (and hence override) JSON content streams\n\n      for (ContentStream cs : req.getContentStreams()) {\n        String contentType = cs.getContentType();\n        if (contentType==null || !contentType.contains(\"/json\")) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad contentType for search handler :\" + contentType + \" request=\"+req);\n        }\n\n        try {\n          String jsonString = IOUtils.toString( cs.getReader() );\n          if (jsonString != null) {\n            MultiMapSolrParams.addParam(JSON, jsonString, map);\n          }\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Exception reading content stream for request:\"+req, e);\n        }\n      }\n\n      // append existing \"json\" params\n      if (jsonFromParams != null) {\n        for (String json : jsonFromParams) {\n          MultiMapSolrParams.addParam(JSON, json, map);\n        }\n      }\n    }\n\n    String[] jsonS = params.getParams(JSON);\n\n    boolean hasAdditions = defaults != null || invariants != null || appends != null || jsonS != null;\n\n    // short circuit processing\n    if (!hasAdditions && !params.getBool(\"expandMacros\", true)) {\n      return;  // nothing to do...\n    }\n\n    boolean isShard = params.getBool(\"isShard\", false);\n\n    Map<String, String[]> newMap = MultiMapSolrParams.asMultiMap(params, hasAdditions);\n\n\n    // see if the json has a \"params\" section\n    // TODO: we should currently *not* do this if this is a leaf of a distributed search since it could overwrite parameters set by the top-level\n    // The parameters we extract will be propagated anyway.\n    if (jsonS != null && !isShard) {\n      for (String json : jsonS) {\n        getParamsFromJSON(newMap, json);\n      }\n    }\n\n    // first populate defaults, etc..\n    if (defaults != null) {\n      Map<String, String[]> defaultsMap = MultiMapSolrParams.asMultiMap(defaults);\n      for (Map.Entry<String, String[]> entry : defaultsMap.entrySet()) {\n        String key = entry.getKey();\n        if (!newMap.containsKey(key)) {\n          newMap.put(key, entry.getValue());\n        }\n      }\n    }\n\n    if (appends != null) {\n      Map<String, String[]> appendsMap = MultiMapSolrParams.asMultiMap(appends);\n\n      for (Map.Entry<String, String[]> entry : appendsMap.entrySet()) {\n        String key = entry.getKey();\n        String[] arr = newMap.get(key);\n        if (arr == null) {\n          newMap.put(key, entry.getValue());\n        } else {\n          String[] appendArr = entry.getValue();\n          String[] newArr = new String[arr.length + appendArr.length];\n          System.arraycopy(arr, 0, newArr, 0, arr.length);\n          System.arraycopy(appendArr, 0, newArr, arr.length, appendArr.length);\n          newMap.put(key, newArr);\n        }\n      }\n    }\n\n\n    if (invariants != null) {\n      newMap.putAll( MultiMapSolrParams.asMultiMap(invariants) );\n    }\n\n    if (!isShard) { // Don't expand macros in shard requests\n      String[] doMacrosStr = newMap.get(\"expandMacros\");\n      boolean doMacros = true;\n      if (doMacrosStr != null) {\n        doMacros = \"true\".equals(doMacrosStr[0]);\n      }\n\n      if (doMacros) {\n        newMap = MacroExpander.expand(newMap);\n      }\n    }\n    // Set these params as soon as possible so if there is an error processing later, things like\n    // \"wt=json\" will take effect from the defaults.\n    SolrParams newParams = new MultiMapSolrParams(newMap);  // newMap may still change below, but that should be OK\n    req.setParams(newParams);\n\n\n    // Skip the rest of the processing (including json processing for now) if this isn't a search handler.\n    // For example json.command started to be used  in SOLR-6294, and that caused errors here.\n    if (!searchHandler) return;\n\n\n    Map<String, Object> json = null;\n    // Handle JSON body first, so query params will always overlay on that\n    jsonS = newMap.get(JSON);\n    if (jsonS != null) {\n      if (json == null) {\n        json = new LinkedHashMap<>();\n      }\n      mergeJSON(json, JSON, jsonS, new ObjectUtil.ConflictHandler());\n    }\n    for (String key : newMap.keySet()) {\n      // json.nl, json.wrf are existing query parameters\n      if (key.startsWith(\"json.\") && !(\"json.nl\".equals(key) || \"json.wrf\".equals(key))) {\n        if (json == null) {\n          json = new LinkedHashMap<>();\n        }\n        mergeJSON(json, key, newMap.get(key), new ObjectUtil.ConflictHandler());\n      }\n    }\n\n    // implement compat for existing components...\n    if (json != null && !isShard) {\n      for (Map.Entry<String,Object> entry : json.entrySet()) {\n        String key = entry.getKey();\n        String out = null;\n        boolean arr = false;\n        if (\"query\".equals(key)) {\n          out = \"q\";\n        } else if (\"filter\".equals(key)) {\n          out = \"fq\";\n          arr = true;\n        } else if (\"fields\".equals(key)) {\n          out = \"fl\";\n          arr = true;\n        } else if (\"offset\".equals(key)) {\n          out = \"start\";\n        } else if (\"limit\".equals(key)) {\n          out = \"rows\";\n        } else if (SORT.equals(key)) {\n          out = SORT;\n        } else if (\"params\".equals(key) || \"facet\".equals(key) ) {\n          // handled elsewhere\n          continue;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown top-level key in JSON request : \" + key);\n        }\n\n        Object val = entry.getValue();\n\n        if (arr) {\n          String[] existing = newMap.get(out);\n          List lst = val instanceof List ? (List)val : null;\n          int existingSize = existing==null ? 0 : existing.length;\n          int jsonSize = lst==null ? 1 : lst.size();\n          String[] newval = new String[ existingSize + jsonSize ];\n          for (int i=0; i<existingSize; i++) {\n            newval[i] = existing[i];\n          }\n          if (lst != null) {\n            for (int i = 0; i < jsonSize; i++) {\n              Object v = lst.get(i);\n              newval[existingSize + i] = v.toString();\n            }\n          } else {\n            newval[newval.length-1] = val.toString();\n          }\n          newMap.put(out, newval);\n        } else {\n          newMap.put(out, new String[]{val.toString()});\n        }\n\n      }\n\n\n    }\n\n    if (json != null) {\n      req.setJSON(json);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a7809d1d753b67f48b1a706e17034bf8b624ea3","date":1504366927,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/json/RequestUtil#processParams(SolrRequestHandler,SolrQueryRequest,SolrParams,SolrParams,SolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/json/RequestUtil#processParams(SolrRequestHandler,SolrQueryRequest,SolrParams,SolrParams,SolrParams).mjava","sourceNew":"  /**\n   * Set default-ish params on a SolrQueryRequest as well as do standard macro processing and JSON request parsing.\n   *\n   * @param handler The search handler this is for (may be null if you don't want this method touching the content streams)\n   * @param req The request whose params we are interested in\n   * @param defaults values to be used if no values are specified in the request params\n   * @param appends values to be appended to those from the request (or defaults) when dealing with multi-val params, or treated as another layer of defaults for singl-val params.\n   * @param invariants values which will be used instead of any request, or default values, regardless of context.\n   */\n  public static void processParams(SolrRequestHandler handler, SolrQueryRequest req, SolrParams defaults,\n                                   SolrParams appends, SolrParams invariants) {\n\n    boolean searchHandler = handler instanceof SearchHandler;\n    SolrParams params = req.getParams();\n\n    // Handle JSON stream for search requests\n    if (searchHandler && req.getContentStreams() != null) {\n\n      Map<String,String[]> map = MultiMapSolrParams.asMultiMap(params, false);\n\n      if (!(params instanceof MultiMapSolrParams || params instanceof ModifiableSolrParams)) {\n        // need to set params on request since we weren't able to access the original map\n        params = new MultiMapSolrParams(map);\n        req.setParams(params);\n      }\n\n      String[] jsonFromParams = map.remove(JSON);  // params from the query string should come after (and hence override) JSON content streams\n\n      for (ContentStream cs : req.getContentStreams()) {\n        String contentType = cs.getContentType();\n        if (contentType==null || !contentType.contains(\"/json\")) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad contentType for search handler :\" + contentType + \" request=\"+req);\n        }\n\n        try {\n          String jsonString = IOUtils.toString( cs.getReader() );\n          if (jsonString != null) {\n            MultiMapSolrParams.addParam(JSON, jsonString, map);\n          }\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Exception reading content stream for request:\"+req, e);\n        }\n      }\n\n      // append existing \"json\" params\n      if (jsonFromParams != null) {\n        for (String json : jsonFromParams) {\n          MultiMapSolrParams.addParam(JSON, json, map);\n        }\n      }\n    }\n\n    String[] jsonS = params.getParams(JSON);\n\n    boolean hasAdditions = defaults != null || invariants != null || appends != null || jsonS != null;\n\n    // short circuit processing\n    if (!hasAdditions && !params.getBool(\"expandMacros\", true)) {\n      return;  // nothing to do...\n    }\n\n    boolean isShard = params.getBool(\"isShard\", false);\n\n    Map<String, String[]> newMap = MultiMapSolrParams.asMultiMap(params, hasAdditions);\n\n\n    // see if the json has a \"params\" section\n    // TODO: we should currently *not* do this if this is a leaf of a distributed search since it could overwrite parameters set by the top-level\n    // The parameters we extract will be propagated anyway.\n    if (jsonS != null && !isShard) {\n      for (String json : jsonS) {\n        getParamsFromJSON(newMap, json);\n      }\n    }\n\n    // first populate defaults, etc..\n    if (defaults != null) {\n      Map<String, String[]> defaultsMap = MultiMapSolrParams.asMultiMap(defaults);\n      for (Map.Entry<String, String[]> entry : defaultsMap.entrySet()) {\n        String key = entry.getKey();\n        if (!newMap.containsKey(key)) {\n          newMap.put(key, entry.getValue());\n        }\n      }\n    }\n\n    if (appends != null) {\n      Map<String, String[]> appendsMap = MultiMapSolrParams.asMultiMap(appends);\n\n      for (Map.Entry<String, String[]> entry : appendsMap.entrySet()) {\n        String key = entry.getKey();\n        String[] arr = newMap.get(key);\n        if (arr == null) {\n          newMap.put(key, entry.getValue());\n        } else {\n          String[] appendArr = entry.getValue();\n          String[] newArr = new String[arr.length + appendArr.length];\n          System.arraycopy(arr, 0, newArr, 0, arr.length);\n          System.arraycopy(appendArr, 0, newArr, arr.length, appendArr.length);\n          newMap.put(key, newArr);\n        }\n      }\n    }\n\n\n    if (invariants != null) {\n      newMap.putAll( MultiMapSolrParams.asMultiMap(invariants) );\n    }\n\n    if (!isShard) { // Don't expand macros in shard requests\n      String[] doMacrosStr = newMap.get(\"expandMacros\");\n      boolean doMacros = true;\n      if (doMacrosStr != null) {\n        doMacros = \"true\".equals(doMacrosStr[0]);\n      }\n\n      if (doMacros) {\n        newMap = MacroExpander.expand(newMap);\n      }\n    }\n    // Set these params as soon as possible so if there is an error processing later, things like\n    // \"wt=json\" will take effect from the defaults.\n    SolrParams newParams = new MultiMapSolrParams(newMap);  // newMap may still change below, but that should be OK\n    req.setParams(newParams);\n\n\n    // Skip the rest of the processing (including json processing for now) if this isn't a search handler.\n    // For example json.command started to be used  in SOLR-6294, and that caused errors here.\n    if (!searchHandler) return;\n\n\n    Map<String, Object> json = null;\n    // Handle JSON body first, so query params will always overlay on that\n    jsonS = newMap.get(JSON);\n    if (jsonS != null) {\n      if (json == null) {\n        json = new LinkedHashMap<>();\n      }\n      mergeJSON(json, JSON, jsonS, new ObjectUtil.ConflictHandler());\n    }\n    for (String key : newMap.keySet()) {\n      // json.nl, json.wrf are existing query parameters\n      if (key.startsWith(\"json.\") && !(\"json.nl\".equals(key) || \"json.wrf\".equals(key))) {\n        if (json == null) {\n          json = new LinkedHashMap<>();\n        }\n        mergeJSON(json, key, newMap.get(key), new ObjectUtil.ConflictHandler());\n      }\n    }\n\n    // implement compat for existing components...\n    JsonQueryConverter jsonQueryConverter = new JsonQueryConverter();\n    if (json != null && !isShard) {\n      for (Map.Entry<String,Object> entry : json.entrySet()) {\n        String key = entry.getKey();\n        String out = null;\n        boolean isQuery = false;\n        boolean arr = false;\n        if (\"query\".equals(key)) {\n          out = \"q\";\n          isQuery = true;\n        } else if (\"filter\".equals(key)) {\n          out = \"fq\";\n          arr = true;\n          isQuery = true;\n        } else if (\"fields\".equals(key)) {\n          out = \"fl\";\n          arr = true;\n        } else if (\"offset\".equals(key)) {\n          out = \"start\";\n        } else if (\"limit\".equals(key)) {\n          out = \"rows\";\n        } else if (SORT.equals(key)) {\n          out = SORT;\n        } else if (\"params\".equals(key) || \"facet\".equals(key) ) {\n          // handled elsewhere\n          continue;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown top-level key in JSON request : \" + key);\n        }\n\n        Object val = entry.getValue();\n\n        if (arr) {\n          String[] existing = newMap.get(out);\n          List lst = val instanceof List ? (List)val : null;\n          int existingSize = existing==null ? 0 : existing.length;\n          int jsonSize = lst==null ? 1 : lst.size();\n          String[] newval = new String[ existingSize + jsonSize ];\n          for (int i=0; i<existingSize; i++) {\n            newval[i] = existing[i];\n          }\n          if (lst != null) {\n            for (int i = 0; i < jsonSize; i++) {\n              Object v = lst.get(i);\n              newval[existingSize + i] = isQuery ? jsonQueryConverter.toLocalParams(v, newMap) : v.toString();\n            }\n          } else {\n            newval[newval.length-1] = isQuery ? jsonQueryConverter.toLocalParams(val, newMap) : val.toString();\n          }\n          newMap.put(out, newval);\n        } else {\n          newMap.put(out, new String[]{isQuery ? jsonQueryConverter.toLocalParams(val, newMap) : val.toString()});\n        }\n\n      }\n\n\n    }\n\n    if (json != null) {\n      req.setJSON(json);\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Set default-ish params on a SolrQueryRequest as well as do standard macro processing and JSON request parsing.\n   *\n   * @param handler The search handler this is for (may be null if you don't want this method touching the content streams)\n   * @param req The request whose params we are interested in\n   * @param defaults values to be used if no values are specified in the request params\n   * @param appends values to be appended to those from the request (or defaults) when dealing with multi-val params, or treated as another layer of defaults for singl-val params.\n   * @param invariants values which will be used instead of any request, or default values, regardless of context.\n   */\n  public static void processParams(SolrRequestHandler handler, SolrQueryRequest req, SolrParams defaults,\n                                   SolrParams appends, SolrParams invariants) {\n\n    boolean searchHandler = handler instanceof SearchHandler;\n    SolrParams params = req.getParams();\n\n    // Handle JSON stream for search requests\n    if (searchHandler && req.getContentStreams() != null) {\n\n      Map<String,String[]> map = MultiMapSolrParams.asMultiMap(params, false);\n\n      if (!(params instanceof MultiMapSolrParams || params instanceof ModifiableSolrParams)) {\n        // need to set params on request since we weren't able to access the original map\n        params = new MultiMapSolrParams(map);\n        req.setParams(params);\n      }\n\n      String[] jsonFromParams = map.remove(JSON);  // params from the query string should come after (and hence override) JSON content streams\n\n      for (ContentStream cs : req.getContentStreams()) {\n        String contentType = cs.getContentType();\n        if (contentType==null || !contentType.contains(\"/json\")) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad contentType for search handler :\" + contentType + \" request=\"+req);\n        }\n\n        try {\n          String jsonString = IOUtils.toString( cs.getReader() );\n          if (jsonString != null) {\n            MultiMapSolrParams.addParam(JSON, jsonString, map);\n          }\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Exception reading content stream for request:\"+req, e);\n        }\n      }\n\n      // append existing \"json\" params\n      if (jsonFromParams != null) {\n        for (String json : jsonFromParams) {\n          MultiMapSolrParams.addParam(JSON, json, map);\n        }\n      }\n    }\n\n    String[] jsonS = params.getParams(JSON);\n\n    boolean hasAdditions = defaults != null || invariants != null || appends != null || jsonS != null;\n\n    // short circuit processing\n    if (!hasAdditions && !params.getBool(\"expandMacros\", true)) {\n      return;  // nothing to do...\n    }\n\n    boolean isShard = params.getBool(\"isShard\", false);\n\n    Map<String, String[]> newMap = MultiMapSolrParams.asMultiMap(params, hasAdditions);\n\n\n    // see if the json has a \"params\" section\n    // TODO: we should currently *not* do this if this is a leaf of a distributed search since it could overwrite parameters set by the top-level\n    // The parameters we extract will be propagated anyway.\n    if (jsonS != null && !isShard) {\n      for (String json : jsonS) {\n        getParamsFromJSON(newMap, json);\n      }\n    }\n\n    // first populate defaults, etc..\n    if (defaults != null) {\n      Map<String, String[]> defaultsMap = MultiMapSolrParams.asMultiMap(defaults);\n      for (Map.Entry<String, String[]> entry : defaultsMap.entrySet()) {\n        String key = entry.getKey();\n        if (!newMap.containsKey(key)) {\n          newMap.put(key, entry.getValue());\n        }\n      }\n    }\n\n    if (appends != null) {\n      Map<String, String[]> appendsMap = MultiMapSolrParams.asMultiMap(appends);\n\n      for (Map.Entry<String, String[]> entry : appendsMap.entrySet()) {\n        String key = entry.getKey();\n        String[] arr = newMap.get(key);\n        if (arr == null) {\n          newMap.put(key, entry.getValue());\n        } else {\n          String[] appendArr = entry.getValue();\n          String[] newArr = new String[arr.length + appendArr.length];\n          System.arraycopy(arr, 0, newArr, 0, arr.length);\n          System.arraycopy(appendArr, 0, newArr, arr.length, appendArr.length);\n          newMap.put(key, newArr);\n        }\n      }\n    }\n\n\n    if (invariants != null) {\n      newMap.putAll( MultiMapSolrParams.asMultiMap(invariants) );\n    }\n\n    if (!isShard) { // Don't expand macros in shard requests\n      String[] doMacrosStr = newMap.get(\"expandMacros\");\n      boolean doMacros = true;\n      if (doMacrosStr != null) {\n        doMacros = \"true\".equals(doMacrosStr[0]);\n      }\n\n      if (doMacros) {\n        newMap = MacroExpander.expand(newMap);\n      }\n    }\n    // Set these params as soon as possible so if there is an error processing later, things like\n    // \"wt=json\" will take effect from the defaults.\n    SolrParams newParams = new MultiMapSolrParams(newMap);  // newMap may still change below, but that should be OK\n    req.setParams(newParams);\n\n\n    // Skip the rest of the processing (including json processing for now) if this isn't a search handler.\n    // For example json.command started to be used  in SOLR-6294, and that caused errors here.\n    if (!searchHandler) return;\n\n\n    Map<String, Object> json = null;\n    // Handle JSON body first, so query params will always overlay on that\n    jsonS = newMap.get(JSON);\n    if (jsonS != null) {\n      if (json == null) {\n        json = new LinkedHashMap<>();\n      }\n      mergeJSON(json, JSON, jsonS, new ObjectUtil.ConflictHandler());\n    }\n    for (String key : newMap.keySet()) {\n      // json.nl, json.wrf are existing query parameters\n      if (key.startsWith(\"json.\") && !(\"json.nl\".equals(key) || \"json.wrf\".equals(key))) {\n        if (json == null) {\n          json = new LinkedHashMap<>();\n        }\n        mergeJSON(json, key, newMap.get(key), new ObjectUtil.ConflictHandler());\n      }\n    }\n\n    // implement compat for existing components...\n    if (json != null && !isShard) {\n      for (Map.Entry<String,Object> entry : json.entrySet()) {\n        String key = entry.getKey();\n        String out = null;\n        boolean arr = false;\n        if (\"query\".equals(key)) {\n          out = \"q\";\n        } else if (\"filter\".equals(key)) {\n          out = \"fq\";\n          arr = true;\n        } else if (\"fields\".equals(key)) {\n          out = \"fl\";\n          arr = true;\n        } else if (\"offset\".equals(key)) {\n          out = \"start\";\n        } else if (\"limit\".equals(key)) {\n          out = \"rows\";\n        } else if (SORT.equals(key)) {\n          out = SORT;\n        } else if (\"params\".equals(key) || \"facet\".equals(key) ) {\n          // handled elsewhere\n          continue;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown top-level key in JSON request : \" + key);\n        }\n\n        Object val = entry.getValue();\n\n        if (arr) {\n          String[] existing = newMap.get(out);\n          List lst = val instanceof List ? (List)val : null;\n          int existingSize = existing==null ? 0 : existing.length;\n          int jsonSize = lst==null ? 1 : lst.size();\n          String[] newval = new String[ existingSize + jsonSize ];\n          for (int i=0; i<existingSize; i++) {\n            newval[i] = existing[i];\n          }\n          if (lst != null) {\n            for (int i = 0; i < jsonSize; i++) {\n              Object v = lst.get(i);\n              newval[existingSize + i] = v.toString();\n            }\n          } else {\n            newval[newval.length-1] = val.toString();\n          }\n          newMap.put(out, newval);\n        } else {\n          newMap.put(out, new String[]{val.toString()});\n        }\n\n      }\n\n\n    }\n\n    if (json != null) {\n      req.setJSON(json);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b21283ed01203901a7257aa4b7f0a0899c86e56e","date":1504689720,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/json/RequestUtil#processParams(SolrRequestHandler,SolrQueryRequest,SolrParams,SolrParams,SolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/json/RequestUtil#processParams(SolrRequestHandler,SolrQueryRequest,SolrParams,SolrParams,SolrParams).mjava","sourceNew":"  /**\n   * Set default-ish params on a SolrQueryRequest as well as do standard macro processing and JSON request parsing.\n   *\n   * @param handler The search handler this is for (may be null if you don't want this method touching the content streams)\n   * @param req The request whose params we are interested in\n   * @param defaults values to be used if no values are specified in the request params\n   * @param appends values to be appended to those from the request (or defaults) when dealing with multi-val params, or treated as another layer of defaults for singl-val params.\n   * @param invariants values which will be used instead of any request, or default values, regardless of context.\n   */\n  public static void processParams(SolrRequestHandler handler, SolrQueryRequest req, SolrParams defaults,\n                                   SolrParams appends, SolrParams invariants) {\n\n    boolean searchHandler = handler instanceof SearchHandler;\n    SolrParams params = req.getParams();\n\n    // Handle JSON stream for search requests\n    if (searchHandler && req.getContentStreams() != null) {\n\n      Map<String,String[]> map = MultiMapSolrParams.asMultiMap(params, false);\n\n      if (!(params instanceof MultiMapSolrParams || params instanceof ModifiableSolrParams)) {\n        // need to set params on request since we weren't able to access the original map\n        params = new MultiMapSolrParams(map);\n        req.setParams(params);\n      }\n\n      String[] jsonFromParams = map.remove(JSON);  // params from the query string should come after (and hence override) JSON content streams\n\n      for (ContentStream cs : req.getContentStreams()) {\n        String contentType = cs.getContentType();\n        if (contentType==null || !contentType.contains(\"/json\")) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad contentType for search handler :\" + contentType + \" request=\"+req);\n        }\n\n        try {\n          String jsonString = IOUtils.toString( cs.getReader() );\n          if (jsonString != null) {\n            MultiMapSolrParams.addParam(JSON, jsonString, map);\n          }\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Exception reading content stream for request:\"+req, e);\n        }\n      }\n\n      // append existing \"json\" params\n      if (jsonFromParams != null) {\n        for (String json : jsonFromParams) {\n          MultiMapSolrParams.addParam(JSON, json, map);\n        }\n      }\n    }\n\n    String[] jsonS = params.getParams(JSON);\n\n    boolean hasAdditions = defaults != null || invariants != null || appends != null || jsonS != null;\n\n    // short circuit processing\n    if (!hasAdditions && !params.getBool(\"expandMacros\", true)) {\n      return;  // nothing to do...\n    }\n\n    boolean isShard = params.getBool(\"isShard\", false);\n\n    Map<String, String[]> newMap = MultiMapSolrParams.asMultiMap(params, hasAdditions);\n\n\n    // see if the json has a \"params\" section\n    // TODO: we should currently *not* do this if this is a leaf of a distributed search since it could overwrite parameters set by the top-level\n    // The parameters we extract will be propagated anyway.\n    if (jsonS != null && !isShard) {\n      for (String json : jsonS) {\n        getParamsFromJSON(newMap, json);\n      }\n    }\n\n    // first populate defaults, etc..\n    if (defaults != null) {\n      Map<String, String[]> defaultsMap = MultiMapSolrParams.asMultiMap(defaults);\n      for (Map.Entry<String, String[]> entry : defaultsMap.entrySet()) {\n        String key = entry.getKey();\n        if (!newMap.containsKey(key)) {\n          newMap.put(key, entry.getValue());\n        }\n      }\n    }\n\n    if (appends != null) {\n      Map<String, String[]> appendsMap = MultiMapSolrParams.asMultiMap(appends);\n\n      for (Map.Entry<String, String[]> entry : appendsMap.entrySet()) {\n        String key = entry.getKey();\n        String[] arr = newMap.get(key);\n        if (arr == null) {\n          newMap.put(key, entry.getValue());\n        } else {\n          String[] appendArr = entry.getValue();\n          String[] newArr = new String[arr.length + appendArr.length];\n          System.arraycopy(arr, 0, newArr, 0, arr.length);\n          System.arraycopy(appendArr, 0, newArr, arr.length, appendArr.length);\n          newMap.put(key, newArr);\n        }\n      }\n    }\n\n\n    if (invariants != null) {\n      newMap.putAll( MultiMapSolrParams.asMultiMap(invariants) );\n    }\n\n    if (!isShard) { // Don't expand macros in shard requests\n      String[] doMacrosStr = newMap.get(\"expandMacros\");\n      boolean doMacros = true;\n      if (doMacrosStr != null) {\n        doMacros = \"true\".equals(doMacrosStr[0]);\n      }\n\n      if (doMacros) {\n        newMap = MacroExpander.expand(newMap);\n      }\n    }\n    // Set these params as soon as possible so if there is an error processing later, things like\n    // \"wt=json\" will take effect from the defaults.\n    SolrParams newParams = new MultiMapSolrParams(newMap);  // newMap may still change below, but that should be OK\n    req.setParams(newParams);\n\n\n    // Skip the rest of the processing (including json processing for now) if this isn't a search handler.\n    // For example json.command started to be used  in SOLR-6294, and that caused errors here.\n    if (!searchHandler) return;\n\n\n    Map<String, Object> json = null;\n    // Handle JSON body first, so query params will always overlay on that\n    jsonS = newMap.get(JSON);\n    if (jsonS != null) {\n      if (json == null) {\n        json = new LinkedHashMap<>();\n      }\n      mergeJSON(json, JSON, jsonS, new ObjectUtil.ConflictHandler());\n    }\n    for (String key : newMap.keySet()) {\n      // json.nl, json.wrf are existing query parameters\n      if (key.startsWith(\"json.\") && !(\"json.nl\".equals(key) || \"json.wrf\".equals(key))) {\n        if (json == null) {\n          json = new LinkedHashMap<>();\n        }\n        mergeJSON(json, key, newMap.get(key), new ObjectUtil.ConflictHandler());\n      }\n    }\n\n    // implement compat for existing components...\n    JsonQueryConverter jsonQueryConverter = new JsonQueryConverter();\n    if (json != null && !isShard) {\n      for (Map.Entry<String,Object> entry : json.entrySet()) {\n        String key = entry.getKey();\n        String out = null;\n        boolean isQuery = false;\n        boolean arr = false;\n        if (\"query\".equals(key)) {\n          out = \"q\";\n          isQuery = true;\n        } else if (\"filter\".equals(key)) {\n          out = \"fq\";\n          arr = true;\n          isQuery = true;\n        } else if (\"fields\".equals(key)) {\n          out = \"fl\";\n          arr = true;\n        } else if (\"offset\".equals(key)) {\n          out = \"start\";\n        } else if (\"limit\".equals(key)) {\n          out = \"rows\";\n        } else if (SORT.equals(key)) {\n          out = SORT;\n        } else if (\"params\".equals(key) || \"facet\".equals(key) ) {\n          // handled elsewhere\n          continue;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown top-level key in JSON request : \" + key);\n        }\n\n        Object val = entry.getValue();\n\n        if (arr) {\n          String[] existing = newMap.get(out);\n          List lst = val instanceof List ? (List)val : null;\n          int existingSize = existing==null ? 0 : existing.length;\n          int jsonSize = lst==null ? 1 : lst.size();\n          String[] newval = new String[ existingSize + jsonSize ];\n          for (int i=0; i<existingSize; i++) {\n            newval[i] = existing[i];\n          }\n          if (lst != null) {\n            for (int i = 0; i < jsonSize; i++) {\n              Object v = lst.get(i);\n              newval[existingSize + i] = isQuery ? jsonQueryConverter.toLocalParams(v, newMap) : v.toString();\n            }\n          } else {\n            newval[newval.length-1] = isQuery ? jsonQueryConverter.toLocalParams(val, newMap) : val.toString();\n          }\n          newMap.put(out, newval);\n        } else {\n          newMap.put(out, new String[]{isQuery ? jsonQueryConverter.toLocalParams(val, newMap) : val.toString()});\n        }\n\n      }\n\n\n    }\n\n    if (json != null) {\n      req.setJSON(json);\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Set default-ish params on a SolrQueryRequest as well as do standard macro processing and JSON request parsing.\n   *\n   * @param handler The search handler this is for (may be null if you don't want this method touching the content streams)\n   * @param req The request whose params we are interested in\n   * @param defaults values to be used if no values are specified in the request params\n   * @param appends values to be appended to those from the request (or defaults) when dealing with multi-val params, or treated as another layer of defaults for singl-val params.\n   * @param invariants values which will be used instead of any request, or default values, regardless of context.\n   */\n  public static void processParams(SolrRequestHandler handler, SolrQueryRequest req, SolrParams defaults,\n                                   SolrParams appends, SolrParams invariants) {\n\n    boolean searchHandler = handler instanceof SearchHandler;\n    SolrParams params = req.getParams();\n\n    // Handle JSON stream for search requests\n    if (searchHandler && req.getContentStreams() != null) {\n\n      Map<String,String[]> map = MultiMapSolrParams.asMultiMap(params, false);\n\n      if (!(params instanceof MultiMapSolrParams || params instanceof ModifiableSolrParams)) {\n        // need to set params on request since we weren't able to access the original map\n        params = new MultiMapSolrParams(map);\n        req.setParams(params);\n      }\n\n      String[] jsonFromParams = map.remove(JSON);  // params from the query string should come after (and hence override) JSON content streams\n\n      for (ContentStream cs : req.getContentStreams()) {\n        String contentType = cs.getContentType();\n        if (contentType==null || !contentType.contains(\"/json\")) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad contentType for search handler :\" + contentType + \" request=\"+req);\n        }\n\n        try {\n          String jsonString = IOUtils.toString( cs.getReader() );\n          if (jsonString != null) {\n            MultiMapSolrParams.addParam(JSON, jsonString, map);\n          }\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Exception reading content stream for request:\"+req, e);\n        }\n      }\n\n      // append existing \"json\" params\n      if (jsonFromParams != null) {\n        for (String json : jsonFromParams) {\n          MultiMapSolrParams.addParam(JSON, json, map);\n        }\n      }\n    }\n\n    String[] jsonS = params.getParams(JSON);\n\n    boolean hasAdditions = defaults != null || invariants != null || appends != null || jsonS != null;\n\n    // short circuit processing\n    if (!hasAdditions && !params.getBool(\"expandMacros\", true)) {\n      return;  // nothing to do...\n    }\n\n    boolean isShard = params.getBool(\"isShard\", false);\n\n    Map<String, String[]> newMap = MultiMapSolrParams.asMultiMap(params, hasAdditions);\n\n\n    // see if the json has a \"params\" section\n    // TODO: we should currently *not* do this if this is a leaf of a distributed search since it could overwrite parameters set by the top-level\n    // The parameters we extract will be propagated anyway.\n    if (jsonS != null && !isShard) {\n      for (String json : jsonS) {\n        getParamsFromJSON(newMap, json);\n      }\n    }\n\n    // first populate defaults, etc..\n    if (defaults != null) {\n      Map<String, String[]> defaultsMap = MultiMapSolrParams.asMultiMap(defaults);\n      for (Map.Entry<String, String[]> entry : defaultsMap.entrySet()) {\n        String key = entry.getKey();\n        if (!newMap.containsKey(key)) {\n          newMap.put(key, entry.getValue());\n        }\n      }\n    }\n\n    if (appends != null) {\n      Map<String, String[]> appendsMap = MultiMapSolrParams.asMultiMap(appends);\n\n      for (Map.Entry<String, String[]> entry : appendsMap.entrySet()) {\n        String key = entry.getKey();\n        String[] arr = newMap.get(key);\n        if (arr == null) {\n          newMap.put(key, entry.getValue());\n        } else {\n          String[] appendArr = entry.getValue();\n          String[] newArr = new String[arr.length + appendArr.length];\n          System.arraycopy(arr, 0, newArr, 0, arr.length);\n          System.arraycopy(appendArr, 0, newArr, arr.length, appendArr.length);\n          newMap.put(key, newArr);\n        }\n      }\n    }\n\n\n    if (invariants != null) {\n      newMap.putAll( MultiMapSolrParams.asMultiMap(invariants) );\n    }\n\n    if (!isShard) { // Don't expand macros in shard requests\n      String[] doMacrosStr = newMap.get(\"expandMacros\");\n      boolean doMacros = true;\n      if (doMacrosStr != null) {\n        doMacros = \"true\".equals(doMacrosStr[0]);\n      }\n\n      if (doMacros) {\n        newMap = MacroExpander.expand(newMap);\n      }\n    }\n    // Set these params as soon as possible so if there is an error processing later, things like\n    // \"wt=json\" will take effect from the defaults.\n    SolrParams newParams = new MultiMapSolrParams(newMap);  // newMap may still change below, but that should be OK\n    req.setParams(newParams);\n\n\n    // Skip the rest of the processing (including json processing for now) if this isn't a search handler.\n    // For example json.command started to be used  in SOLR-6294, and that caused errors here.\n    if (!searchHandler) return;\n\n\n    Map<String, Object> json = null;\n    // Handle JSON body first, so query params will always overlay on that\n    jsonS = newMap.get(JSON);\n    if (jsonS != null) {\n      if (json == null) {\n        json = new LinkedHashMap<>();\n      }\n      mergeJSON(json, JSON, jsonS, new ObjectUtil.ConflictHandler());\n    }\n    for (String key : newMap.keySet()) {\n      // json.nl, json.wrf are existing query parameters\n      if (key.startsWith(\"json.\") && !(\"json.nl\".equals(key) || \"json.wrf\".equals(key))) {\n        if (json == null) {\n          json = new LinkedHashMap<>();\n        }\n        mergeJSON(json, key, newMap.get(key), new ObjectUtil.ConflictHandler());\n      }\n    }\n\n    // implement compat for existing components...\n    if (json != null && !isShard) {\n      for (Map.Entry<String,Object> entry : json.entrySet()) {\n        String key = entry.getKey();\n        String out = null;\n        boolean arr = false;\n        if (\"query\".equals(key)) {\n          out = \"q\";\n        } else if (\"filter\".equals(key)) {\n          out = \"fq\";\n          arr = true;\n        } else if (\"fields\".equals(key)) {\n          out = \"fl\";\n          arr = true;\n        } else if (\"offset\".equals(key)) {\n          out = \"start\";\n        } else if (\"limit\".equals(key)) {\n          out = \"rows\";\n        } else if (SORT.equals(key)) {\n          out = SORT;\n        } else if (\"params\".equals(key) || \"facet\".equals(key) ) {\n          // handled elsewhere\n          continue;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown top-level key in JSON request : \" + key);\n        }\n\n        Object val = entry.getValue();\n\n        if (arr) {\n          String[] existing = newMap.get(out);\n          List lst = val instanceof List ? (List)val : null;\n          int existingSize = existing==null ? 0 : existing.length;\n          int jsonSize = lst==null ? 1 : lst.size();\n          String[] newval = new String[ existingSize + jsonSize ];\n          for (int i=0; i<existingSize; i++) {\n            newval[i] = existing[i];\n          }\n          if (lst != null) {\n            for (int i = 0; i < jsonSize; i++) {\n              Object v = lst.get(i);\n              newval[existingSize + i] = v.toString();\n            }\n          } else {\n            newval[newval.length-1] = val.toString();\n          }\n          newMap.put(out, newval);\n        } else {\n          newMap.put(out, new String[]{val.toString()});\n        }\n\n      }\n\n\n    }\n\n    if (json != null) {\n      req.setJSON(json);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"104a3f62ee393d48b5596de76ed4d9a4e0ea6de7","date":1504848000,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/json/RequestUtil#processParams(SolrRequestHandler,SolrQueryRequest,SolrParams,SolrParams,SolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/json/RequestUtil#processParams(SolrRequestHandler,SolrQueryRequest,SolrParams,SolrParams,SolrParams).mjava","sourceNew":"  /**\n   * Set default-ish params on a SolrQueryRequest as well as do standard macro processing and JSON request parsing.\n   *\n   * @param handler The search handler this is for (may be null if you don't want this method touching the content streams)\n   * @param req The request whose params we are interested in\n   * @param defaults values to be used if no values are specified in the request params\n   * @param appends values to be appended to those from the request (or defaults) when dealing with multi-val params, or treated as another layer of defaults for singl-val params.\n   * @param invariants values which will be used instead of any request, or default values, regardless of context.\n   */\n  public static void processParams(SolrRequestHandler handler, SolrQueryRequest req, SolrParams defaults,\n                                   SolrParams appends, SolrParams invariants) {\n\n    boolean searchHandler = handler instanceof SearchHandler;\n    SolrParams params = req.getParams();\n\n    // Handle JSON stream for search requests\n    if (searchHandler && req.getContentStreams() != null) {\n\n      Map<String,String[]> map = MultiMapSolrParams.asMultiMap(params, false);\n\n      if (!(params instanceof MultiMapSolrParams || params instanceof ModifiableSolrParams)) {\n        // need to set params on request since we weren't able to access the original map\n        params = new MultiMapSolrParams(map);\n        req.setParams(params);\n      }\n\n      String[] jsonFromParams = map.remove(JSON);  // params from the query string should come after (and hence override) JSON content streams\n\n      for (ContentStream cs : req.getContentStreams()) {\n        String contentType = cs.getContentType();\n        if (contentType==null || !contentType.contains(\"/json\")) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad contentType for search handler :\" + contentType + \" request=\"+req);\n        }\n\n        try {\n          String jsonString = IOUtils.toString( cs.getReader() );\n          if (jsonString != null) {\n            MultiMapSolrParams.addParam(JSON, jsonString, map);\n          }\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Exception reading content stream for request:\"+req, e);\n        }\n      }\n\n      // append existing \"json\" params\n      if (jsonFromParams != null) {\n        for (String json : jsonFromParams) {\n          MultiMapSolrParams.addParam(JSON, json, map);\n        }\n      }\n    }\n\n    String[] jsonS = params.getParams(JSON);\n\n    boolean hasAdditions = defaults != null || invariants != null || appends != null || jsonS != null;\n\n    // short circuit processing\n    if (!hasAdditions && !params.getBool(\"expandMacros\", true)) {\n      return;  // nothing to do...\n    }\n\n    boolean isShard = params.getBool(\"isShard\", false);\n\n    Map<String, String[]> newMap = MultiMapSolrParams.asMultiMap(params, hasAdditions);\n\n\n    // see if the json has a \"params\" section\n    // TODO: we should currently *not* do this if this is a leaf of a distributed search since it could overwrite parameters set by the top-level\n    // The parameters we extract will be propagated anyway.\n    if (jsonS != null && !isShard) {\n      for (String json : jsonS) {\n        getParamsFromJSON(newMap, json);\n      }\n    }\n\n    // first populate defaults, etc..\n    if (defaults != null) {\n      Map<String, String[]> defaultsMap = MultiMapSolrParams.asMultiMap(defaults);\n      for (Map.Entry<String, String[]> entry : defaultsMap.entrySet()) {\n        String key = entry.getKey();\n        if (!newMap.containsKey(key)) {\n          newMap.put(key, entry.getValue());\n        }\n      }\n    }\n\n    if (appends != null) {\n      Map<String, String[]> appendsMap = MultiMapSolrParams.asMultiMap(appends);\n\n      for (Map.Entry<String, String[]> entry : appendsMap.entrySet()) {\n        String key = entry.getKey();\n        String[] arr = newMap.get(key);\n        if (arr == null) {\n          newMap.put(key, entry.getValue());\n        } else {\n          String[] appendArr = entry.getValue();\n          String[] newArr = new String[arr.length + appendArr.length];\n          System.arraycopy(arr, 0, newArr, 0, arr.length);\n          System.arraycopy(appendArr, 0, newArr, arr.length, appendArr.length);\n          newMap.put(key, newArr);\n        }\n      }\n    }\n\n\n    if (invariants != null) {\n      newMap.putAll( MultiMapSolrParams.asMultiMap(invariants) );\n    }\n\n    if (!isShard) { // Don't expand macros in shard requests\n      String[] doMacrosStr = newMap.get(\"expandMacros\");\n      boolean doMacros = true;\n      if (doMacrosStr != null) {\n        doMacros = \"true\".equals(doMacrosStr[0]);\n      }\n\n      if (doMacros) {\n        newMap = MacroExpander.expand(newMap);\n      }\n    }\n    // Set these params as soon as possible so if there is an error processing later, things like\n    // \"wt=json\" will take effect from the defaults.\n    SolrParams newParams = new MultiMapSolrParams(newMap);  // newMap may still change below, but that should be OK\n    req.setParams(newParams);\n\n\n    // Skip the rest of the processing (including json processing for now) if this isn't a search handler.\n    // For example json.command started to be used  in SOLR-6294, and that caused errors here.\n    if (!searchHandler) return;\n\n\n    Map<String, Object> json = null;\n    // Handle JSON body first, so query params will always overlay on that\n    jsonS = newMap.get(JSON);\n    if (jsonS != null) {\n      if (json == null) {\n        json = new LinkedHashMap<>();\n      }\n      mergeJSON(json, JSON, jsonS, new ObjectUtil.ConflictHandler());\n    }\n    for (String key : newMap.keySet()) {\n      // json.nl, json.wrf are existing query parameters\n      if (key.startsWith(\"json.\") && !(\"json.nl\".equals(key) || \"json.wrf\".equals(key))) {\n        if (json == null) {\n          json = new LinkedHashMap<>();\n        }\n        mergeJSON(json, key, newMap.get(key), new ObjectUtil.ConflictHandler());\n      }\n    }\n\n    // implement compat for existing components...\n    JsonQueryConverter jsonQueryConverter = new JsonQueryConverter();\n    if (json != null && !isShard) {\n      for (Map.Entry<String,Object> entry : json.entrySet()) {\n        String key = entry.getKey();\n        String out = null;\n        boolean isQuery = false;\n        boolean arr = false;\n        if (\"query\".equals(key)) {\n          out = \"q\";\n          isQuery = true;\n        } else if (\"filter\".equals(key)) {\n          out = \"fq\";\n          arr = true;\n          isQuery = true;\n        } else if (\"fields\".equals(key)) {\n          out = \"fl\";\n          arr = true;\n        } else if (\"offset\".equals(key)) {\n          out = \"start\";\n        } else if (\"limit\".equals(key)) {\n          out = \"rows\";\n        } else if (SORT.equals(key)) {\n          out = SORT;\n        } else if (\"params\".equals(key) || \"facet\".equals(key) ) {\n          // handled elsewhere\n          continue;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown top-level key in JSON request : \" + key);\n        }\n\n        Object val = entry.getValue();\n\n        if (arr) {\n          String[] existing = newMap.get(out);\n          List lst = val instanceof List ? (List)val : null;\n          int existingSize = existing==null ? 0 : existing.length;\n          int jsonSize = lst==null ? 1 : lst.size();\n          String[] newval = new String[ existingSize + jsonSize ];\n          for (int i=0; i<existingSize; i++) {\n            newval[i] = existing[i];\n          }\n          if (lst != null) {\n            for (int i = 0; i < jsonSize; i++) {\n              Object v = lst.get(i);\n              newval[existingSize + i] = isQuery ? jsonQueryConverter.toLocalParams(v, newMap) : v.toString();\n            }\n          } else {\n            newval[newval.length-1] = isQuery ? jsonQueryConverter.toLocalParams(val, newMap) : val.toString();\n          }\n          newMap.put(out, newval);\n        } else {\n          newMap.put(out, new String[]{isQuery ? jsonQueryConverter.toLocalParams(val, newMap) : val.toString()});\n        }\n\n      }\n\n\n    }\n\n    if (json != null) {\n      req.setJSON(json);\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Set default-ish params on a SolrQueryRequest as well as do standard macro processing and JSON request parsing.\n   *\n   * @param handler The search handler this is for (may be null if you don't want this method touching the content streams)\n   * @param req The request whose params we are interested in\n   * @param defaults values to be used if no values are specified in the request params\n   * @param appends values to be appended to those from the request (or defaults) when dealing with multi-val params, or treated as another layer of defaults for singl-val params.\n   * @param invariants values which will be used instead of any request, or default values, regardless of context.\n   */\n  public static void processParams(SolrRequestHandler handler, SolrQueryRequest req, SolrParams defaults,\n                                   SolrParams appends, SolrParams invariants) {\n\n    boolean searchHandler = handler instanceof SearchHandler;\n    SolrParams params = req.getParams();\n\n    // Handle JSON stream for search requests\n    if (searchHandler && req.getContentStreams() != null) {\n\n      Map<String,String[]> map = MultiMapSolrParams.asMultiMap(params, false);\n\n      if (!(params instanceof MultiMapSolrParams || params instanceof ModifiableSolrParams)) {\n        // need to set params on request since we weren't able to access the original map\n        params = new MultiMapSolrParams(map);\n        req.setParams(params);\n      }\n\n      String[] jsonFromParams = map.remove(JSON);  // params from the query string should come after (and hence override) JSON content streams\n\n      for (ContentStream cs : req.getContentStreams()) {\n        String contentType = cs.getContentType();\n        if (contentType==null || !contentType.contains(\"/json\")) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad contentType for search handler :\" + contentType + \" request=\"+req);\n        }\n\n        try {\n          String jsonString = IOUtils.toString( cs.getReader() );\n          if (jsonString != null) {\n            MultiMapSolrParams.addParam(JSON, jsonString, map);\n          }\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Exception reading content stream for request:\"+req, e);\n        }\n      }\n\n      // append existing \"json\" params\n      if (jsonFromParams != null) {\n        for (String json : jsonFromParams) {\n          MultiMapSolrParams.addParam(JSON, json, map);\n        }\n      }\n    }\n\n    String[] jsonS = params.getParams(JSON);\n\n    boolean hasAdditions = defaults != null || invariants != null || appends != null || jsonS != null;\n\n    // short circuit processing\n    if (!hasAdditions && !params.getBool(\"expandMacros\", true)) {\n      return;  // nothing to do...\n    }\n\n    boolean isShard = params.getBool(\"isShard\", false);\n\n    Map<String, String[]> newMap = MultiMapSolrParams.asMultiMap(params, hasAdditions);\n\n\n    // see if the json has a \"params\" section\n    // TODO: we should currently *not* do this if this is a leaf of a distributed search since it could overwrite parameters set by the top-level\n    // The parameters we extract will be propagated anyway.\n    if (jsonS != null && !isShard) {\n      for (String json : jsonS) {\n        getParamsFromJSON(newMap, json);\n      }\n    }\n\n    // first populate defaults, etc..\n    if (defaults != null) {\n      Map<String, String[]> defaultsMap = MultiMapSolrParams.asMultiMap(defaults);\n      for (Map.Entry<String, String[]> entry : defaultsMap.entrySet()) {\n        String key = entry.getKey();\n        if (!newMap.containsKey(key)) {\n          newMap.put(key, entry.getValue());\n        }\n      }\n    }\n\n    if (appends != null) {\n      Map<String, String[]> appendsMap = MultiMapSolrParams.asMultiMap(appends);\n\n      for (Map.Entry<String, String[]> entry : appendsMap.entrySet()) {\n        String key = entry.getKey();\n        String[] arr = newMap.get(key);\n        if (arr == null) {\n          newMap.put(key, entry.getValue());\n        } else {\n          String[] appendArr = entry.getValue();\n          String[] newArr = new String[arr.length + appendArr.length];\n          System.arraycopy(arr, 0, newArr, 0, arr.length);\n          System.arraycopy(appendArr, 0, newArr, arr.length, appendArr.length);\n          newMap.put(key, newArr);\n        }\n      }\n    }\n\n\n    if (invariants != null) {\n      newMap.putAll( MultiMapSolrParams.asMultiMap(invariants) );\n    }\n\n    if (!isShard) { // Don't expand macros in shard requests\n      String[] doMacrosStr = newMap.get(\"expandMacros\");\n      boolean doMacros = true;\n      if (doMacrosStr != null) {\n        doMacros = \"true\".equals(doMacrosStr[0]);\n      }\n\n      if (doMacros) {\n        newMap = MacroExpander.expand(newMap);\n      }\n    }\n    // Set these params as soon as possible so if there is an error processing later, things like\n    // \"wt=json\" will take effect from the defaults.\n    SolrParams newParams = new MultiMapSolrParams(newMap);  // newMap may still change below, but that should be OK\n    req.setParams(newParams);\n\n\n    // Skip the rest of the processing (including json processing for now) if this isn't a search handler.\n    // For example json.command started to be used  in SOLR-6294, and that caused errors here.\n    if (!searchHandler) return;\n\n\n    Map<String, Object> json = null;\n    // Handle JSON body first, so query params will always overlay on that\n    jsonS = newMap.get(JSON);\n    if (jsonS != null) {\n      if (json == null) {\n        json = new LinkedHashMap<>();\n      }\n      mergeJSON(json, JSON, jsonS, new ObjectUtil.ConflictHandler());\n    }\n    for (String key : newMap.keySet()) {\n      // json.nl, json.wrf are existing query parameters\n      if (key.startsWith(\"json.\") && !(\"json.nl\".equals(key) || \"json.wrf\".equals(key))) {\n        if (json == null) {\n          json = new LinkedHashMap<>();\n        }\n        mergeJSON(json, key, newMap.get(key), new ObjectUtil.ConflictHandler());\n      }\n    }\n\n    // implement compat for existing components...\n    if (json != null && !isShard) {\n      for (Map.Entry<String,Object> entry : json.entrySet()) {\n        String key = entry.getKey();\n        String out = null;\n        boolean arr = false;\n        if (\"query\".equals(key)) {\n          out = \"q\";\n        } else if (\"filter\".equals(key)) {\n          out = \"fq\";\n          arr = true;\n        } else if (\"fields\".equals(key)) {\n          out = \"fl\";\n          arr = true;\n        } else if (\"offset\".equals(key)) {\n          out = \"start\";\n        } else if (\"limit\".equals(key)) {\n          out = \"rows\";\n        } else if (SORT.equals(key)) {\n          out = SORT;\n        } else if (\"params\".equals(key) || \"facet\".equals(key) ) {\n          // handled elsewhere\n          continue;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown top-level key in JSON request : \" + key);\n        }\n\n        Object val = entry.getValue();\n\n        if (arr) {\n          String[] existing = newMap.get(out);\n          List lst = val instanceof List ? (List)val : null;\n          int existingSize = existing==null ? 0 : existing.length;\n          int jsonSize = lst==null ? 1 : lst.size();\n          String[] newval = new String[ existingSize + jsonSize ];\n          for (int i=0; i<existingSize; i++) {\n            newval[i] = existing[i];\n          }\n          if (lst != null) {\n            for (int i = 0; i < jsonSize; i++) {\n              Object v = lst.get(i);\n              newval[existingSize + i] = v.toString();\n            }\n          } else {\n            newval[newval.length-1] = val.toString();\n          }\n          newMap.put(out, newval);\n        } else {\n          newMap.put(out, new String[]{val.toString()});\n        }\n\n      }\n\n\n    }\n\n    if (json != null) {\n      req.setJSON(json);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f97fc3d287be2a8d7f513f0de3249b50dda47299","date":1568378558,"type":3,"author":"Koen De Groote","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/json/RequestUtil#processParams(SolrRequestHandler,SolrQueryRequest,SolrParams,SolrParams,SolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/json/RequestUtil#processParams(SolrRequestHandler,SolrQueryRequest,SolrParams,SolrParams,SolrParams).mjava","sourceNew":"  /**\n   * Set default-ish params on a SolrQueryRequest as well as do standard macro processing and JSON request parsing.\n   *\n   * @param handler The search handler this is for (may be null if you don't want this method touching the content streams)\n   * @param req The request whose params we are interested in\n   * @param defaults values to be used if no values are specified in the request params\n   * @param appends values to be appended to those from the request (or defaults) when dealing with multi-val params, or treated as another layer of defaults for singl-val params.\n   * @param invariants values which will be used instead of any request, or default values, regardless of context.\n   */\n  public static void processParams(SolrRequestHandler handler, SolrQueryRequest req, SolrParams defaults,\n                                   SolrParams appends, SolrParams invariants) {\n\n    boolean searchHandler = handler instanceof SearchHandler;\n    SolrParams params = req.getParams();\n\n    // Handle JSON stream for search requests\n    if (searchHandler && req.getContentStreams() != null) {\n\n      Map<String,String[]> map = MultiMapSolrParams.asMultiMap(params, false);\n\n      if (!(params instanceof MultiMapSolrParams || params instanceof ModifiableSolrParams)) {\n        // need to set params on request since we weren't able to access the original map\n        params = new MultiMapSolrParams(map);\n        req.setParams(params);\n      }\n\n      String[] jsonFromParams = map.remove(JSON);  // params from the query string should come after (and hence override) JSON content streams\n\n      for (ContentStream cs : req.getContentStreams()) {\n        String contentType = cs.getContentType();\n        if (contentType==null || !contentType.contains(\"/json\")) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad contentType for search handler :\" + contentType + \" request=\"+req);\n        }\n\n        try {\n          String jsonString = IOUtils.toString( cs.getReader() );\n          if (jsonString != null) {\n            MultiMapSolrParams.addParam(JSON, jsonString, map);\n          }\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Exception reading content stream for request:\"+req, e);\n        }\n      }\n\n      // append existing \"json\" params\n      if (jsonFromParams != null) {\n        for (String json : jsonFromParams) {\n          MultiMapSolrParams.addParam(JSON, json, map);\n        }\n      }\n    }\n\n    String[] jsonS = params.getParams(JSON);\n\n    boolean hasAdditions = defaults != null || invariants != null || appends != null || jsonS != null;\n\n    // short circuit processing\n    if (!hasAdditions && !params.getBool(\"expandMacros\", true)) {\n      return;  // nothing to do...\n    }\n\n    boolean isShard = params.getBool(\"isShard\", false);\n\n    Map<String, String[]> newMap = MultiMapSolrParams.asMultiMap(params, hasAdditions);\n\n\n    // see if the json has a \"params\" section\n    // TODO: we should currently *not* do this if this is a leaf of a distributed search since it could overwrite parameters set by the top-level\n    // The parameters we extract will be propagated anyway.\n    if (jsonS != null && !isShard) {\n      for (String json : jsonS) {\n        getParamsFromJSON(newMap, json);\n      }\n    }\n\n    // first populate defaults, etc..\n    if (defaults != null) {\n      Map<String, String[]> defaultsMap = MultiMapSolrParams.asMultiMap(defaults);\n      for (Map.Entry<String, String[]> entry : defaultsMap.entrySet()) {\n        String key = entry.getKey();\n        if (!newMap.containsKey(key)) {\n          newMap.put(key, entry.getValue());\n        }\n      }\n    }\n\n    if (appends != null) {\n      Map<String, String[]> appendsMap = MultiMapSolrParams.asMultiMap(appends);\n\n      for (Map.Entry<String, String[]> entry : appendsMap.entrySet()) {\n        String key = entry.getKey();\n        String[] arr = newMap.get(key);\n        if (arr == null) {\n          newMap.put(key, entry.getValue());\n        } else {\n          String[] appendArr = entry.getValue();\n          String[] newArr = new String[arr.length + appendArr.length];\n          System.arraycopy(arr, 0, newArr, 0, arr.length);\n          System.arraycopy(appendArr, 0, newArr, arr.length, appendArr.length);\n          newMap.put(key, newArr);\n        }\n      }\n    }\n\n\n    if (invariants != null) {\n      newMap.putAll( MultiMapSolrParams.asMultiMap(invariants) );\n    }\n\n    if (!isShard) { // Don't expand macros in shard requests\n      String[] doMacrosStr = newMap.get(\"expandMacros\");\n      boolean doMacros = true;\n      if (doMacrosStr != null) {\n        doMacros = \"true\".equals(doMacrosStr[0]);\n      }\n\n      if (doMacros) {\n        newMap = MacroExpander.expand(newMap);\n      }\n    }\n    // Set these params as soon as possible so if there is an error processing later, things like\n    // \"wt=json\" will take effect from the defaults.\n    SolrParams newParams = new MultiMapSolrParams(newMap);  // newMap may still change below, but that should be OK\n    req.setParams(newParams);\n\n\n    // Skip the rest of the processing (including json processing for now) if this isn't a search handler.\n    // For example json.command started to be used  in SOLR-6294, and that caused errors here.\n    if (!searchHandler) return;\n\n\n    Map<String, Object> json = null;\n    // Handle JSON body first, so query params will always overlay on that\n    jsonS = newMap.get(JSON);\n    if (jsonS != null) {\n      if (json == null) {\n        json = new LinkedHashMap<>();\n      }\n      mergeJSON(json, JSON, jsonS, new ObjectUtil.ConflictHandler());\n    }\n    for (Map.Entry<String, String[]> entry : newMap.entrySet()) {\n      String key = entry.getKey();\n      // json.nl, json.wrf are existing query parameters\n      if (key.startsWith(\"json.\") && !(\"json.nl\".equals(key) || \"json.wrf\".equals(key))) {\n        if (json == null) {\n          json = new LinkedHashMap<>();\n        }\n        mergeJSON(json, key, entry.getValue(), new ObjectUtil.ConflictHandler());\n      }\n    }\n\n    // implement compat for existing components...\n    JsonQueryConverter jsonQueryConverter = new JsonQueryConverter();\n    if (json != null && !isShard) {\n      for (Map.Entry<String,Object> entry : json.entrySet()) {\n        String key = entry.getKey();\n        String out = null;\n        boolean isQuery = false;\n        boolean arr = false;\n        if (\"query\".equals(key)) {\n          out = \"q\";\n          isQuery = true;\n        } else if (\"filter\".equals(key)) {\n          out = \"fq\";\n          arr = true;\n          isQuery = true;\n        } else if (\"fields\".equals(key)) {\n          out = \"fl\";\n          arr = true;\n        } else if (\"offset\".equals(key)) {\n          out = \"start\";\n        } else if (\"limit\".equals(key)) {\n          out = \"rows\";\n        } else if (SORT.equals(key)) {\n          out = SORT;\n        } else if (\"params\".equals(key) || \"facet\".equals(key) ) {\n          // handled elsewhere\n          continue;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown top-level key in JSON request : \" + key);\n        }\n\n        Object val = entry.getValue();\n\n        if (arr) {\n          String[] existing = newMap.get(out);\n          List lst = val instanceof List ? (List)val : null;\n          int existingSize = existing==null ? 0 : existing.length;\n          int jsonSize = lst==null ? 1 : lst.size();\n          String[] newval = new String[ existingSize + jsonSize ];\n          for (int i=0; i<existingSize; i++) {\n            newval[i] = existing[i];\n          }\n          if (lst != null) {\n            for (int i = 0; i < jsonSize; i++) {\n              Object v = lst.get(i);\n              newval[existingSize + i] = isQuery ? jsonQueryConverter.toLocalParams(v, newMap) : v.toString();\n            }\n          } else {\n            newval[newval.length-1] = isQuery ? jsonQueryConverter.toLocalParams(val, newMap) : val.toString();\n          }\n          newMap.put(out, newval);\n        } else {\n          newMap.put(out, new String[]{isQuery ? jsonQueryConverter.toLocalParams(val, newMap) : val.toString()});\n        }\n\n      }\n\n\n    }\n\n    if (json != null) {\n      req.setJSON(json);\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Set default-ish params on a SolrQueryRequest as well as do standard macro processing and JSON request parsing.\n   *\n   * @param handler The search handler this is for (may be null if you don't want this method touching the content streams)\n   * @param req The request whose params we are interested in\n   * @param defaults values to be used if no values are specified in the request params\n   * @param appends values to be appended to those from the request (or defaults) when dealing with multi-val params, or treated as another layer of defaults for singl-val params.\n   * @param invariants values which will be used instead of any request, or default values, regardless of context.\n   */\n  public static void processParams(SolrRequestHandler handler, SolrQueryRequest req, SolrParams defaults,\n                                   SolrParams appends, SolrParams invariants) {\n\n    boolean searchHandler = handler instanceof SearchHandler;\n    SolrParams params = req.getParams();\n\n    // Handle JSON stream for search requests\n    if (searchHandler && req.getContentStreams() != null) {\n\n      Map<String,String[]> map = MultiMapSolrParams.asMultiMap(params, false);\n\n      if (!(params instanceof MultiMapSolrParams || params instanceof ModifiableSolrParams)) {\n        // need to set params on request since we weren't able to access the original map\n        params = new MultiMapSolrParams(map);\n        req.setParams(params);\n      }\n\n      String[] jsonFromParams = map.remove(JSON);  // params from the query string should come after (and hence override) JSON content streams\n\n      for (ContentStream cs : req.getContentStreams()) {\n        String contentType = cs.getContentType();\n        if (contentType==null || !contentType.contains(\"/json\")) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad contentType for search handler :\" + contentType + \" request=\"+req);\n        }\n\n        try {\n          String jsonString = IOUtils.toString( cs.getReader() );\n          if (jsonString != null) {\n            MultiMapSolrParams.addParam(JSON, jsonString, map);\n          }\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Exception reading content stream for request:\"+req, e);\n        }\n      }\n\n      // append existing \"json\" params\n      if (jsonFromParams != null) {\n        for (String json : jsonFromParams) {\n          MultiMapSolrParams.addParam(JSON, json, map);\n        }\n      }\n    }\n\n    String[] jsonS = params.getParams(JSON);\n\n    boolean hasAdditions = defaults != null || invariants != null || appends != null || jsonS != null;\n\n    // short circuit processing\n    if (!hasAdditions && !params.getBool(\"expandMacros\", true)) {\n      return;  // nothing to do...\n    }\n\n    boolean isShard = params.getBool(\"isShard\", false);\n\n    Map<String, String[]> newMap = MultiMapSolrParams.asMultiMap(params, hasAdditions);\n\n\n    // see if the json has a \"params\" section\n    // TODO: we should currently *not* do this if this is a leaf of a distributed search since it could overwrite parameters set by the top-level\n    // The parameters we extract will be propagated anyway.\n    if (jsonS != null && !isShard) {\n      for (String json : jsonS) {\n        getParamsFromJSON(newMap, json);\n      }\n    }\n\n    // first populate defaults, etc..\n    if (defaults != null) {\n      Map<String, String[]> defaultsMap = MultiMapSolrParams.asMultiMap(defaults);\n      for (Map.Entry<String, String[]> entry : defaultsMap.entrySet()) {\n        String key = entry.getKey();\n        if (!newMap.containsKey(key)) {\n          newMap.put(key, entry.getValue());\n        }\n      }\n    }\n\n    if (appends != null) {\n      Map<String, String[]> appendsMap = MultiMapSolrParams.asMultiMap(appends);\n\n      for (Map.Entry<String, String[]> entry : appendsMap.entrySet()) {\n        String key = entry.getKey();\n        String[] arr = newMap.get(key);\n        if (arr == null) {\n          newMap.put(key, entry.getValue());\n        } else {\n          String[] appendArr = entry.getValue();\n          String[] newArr = new String[arr.length + appendArr.length];\n          System.arraycopy(arr, 0, newArr, 0, arr.length);\n          System.arraycopy(appendArr, 0, newArr, arr.length, appendArr.length);\n          newMap.put(key, newArr);\n        }\n      }\n    }\n\n\n    if (invariants != null) {\n      newMap.putAll( MultiMapSolrParams.asMultiMap(invariants) );\n    }\n\n    if (!isShard) { // Don't expand macros in shard requests\n      String[] doMacrosStr = newMap.get(\"expandMacros\");\n      boolean doMacros = true;\n      if (doMacrosStr != null) {\n        doMacros = \"true\".equals(doMacrosStr[0]);\n      }\n\n      if (doMacros) {\n        newMap = MacroExpander.expand(newMap);\n      }\n    }\n    // Set these params as soon as possible so if there is an error processing later, things like\n    // \"wt=json\" will take effect from the defaults.\n    SolrParams newParams = new MultiMapSolrParams(newMap);  // newMap may still change below, but that should be OK\n    req.setParams(newParams);\n\n\n    // Skip the rest of the processing (including json processing for now) if this isn't a search handler.\n    // For example json.command started to be used  in SOLR-6294, and that caused errors here.\n    if (!searchHandler) return;\n\n\n    Map<String, Object> json = null;\n    // Handle JSON body first, so query params will always overlay on that\n    jsonS = newMap.get(JSON);\n    if (jsonS != null) {\n      if (json == null) {\n        json = new LinkedHashMap<>();\n      }\n      mergeJSON(json, JSON, jsonS, new ObjectUtil.ConflictHandler());\n    }\n    for (String key : newMap.keySet()) {\n      // json.nl, json.wrf are existing query parameters\n      if (key.startsWith(\"json.\") && !(\"json.nl\".equals(key) || \"json.wrf\".equals(key))) {\n        if (json == null) {\n          json = new LinkedHashMap<>();\n        }\n        mergeJSON(json, key, newMap.get(key), new ObjectUtil.ConflictHandler());\n      }\n    }\n\n    // implement compat for existing components...\n    JsonQueryConverter jsonQueryConverter = new JsonQueryConverter();\n    if (json != null && !isShard) {\n      for (Map.Entry<String,Object> entry : json.entrySet()) {\n        String key = entry.getKey();\n        String out = null;\n        boolean isQuery = false;\n        boolean arr = false;\n        if (\"query\".equals(key)) {\n          out = \"q\";\n          isQuery = true;\n        } else if (\"filter\".equals(key)) {\n          out = \"fq\";\n          arr = true;\n          isQuery = true;\n        } else if (\"fields\".equals(key)) {\n          out = \"fl\";\n          arr = true;\n        } else if (\"offset\".equals(key)) {\n          out = \"start\";\n        } else if (\"limit\".equals(key)) {\n          out = \"rows\";\n        } else if (SORT.equals(key)) {\n          out = SORT;\n        } else if (\"params\".equals(key) || \"facet\".equals(key) ) {\n          // handled elsewhere\n          continue;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown top-level key in JSON request : \" + key);\n        }\n\n        Object val = entry.getValue();\n\n        if (arr) {\n          String[] existing = newMap.get(out);\n          List lst = val instanceof List ? (List)val : null;\n          int existingSize = existing==null ? 0 : existing.length;\n          int jsonSize = lst==null ? 1 : lst.size();\n          String[] newval = new String[ existingSize + jsonSize ];\n          for (int i=0; i<existingSize; i++) {\n            newval[i] = existing[i];\n          }\n          if (lst != null) {\n            for (int i = 0; i < jsonSize; i++) {\n              Object v = lst.get(i);\n              newval[existingSize + i] = isQuery ? jsonQueryConverter.toLocalParams(v, newMap) : v.toString();\n            }\n          } else {\n            newval[newval.length-1] = isQuery ? jsonQueryConverter.toLocalParams(val, newMap) : val.toString();\n          }\n          newMap.put(out, newval);\n        } else {\n          newMap.put(out, new String[]{isQuery ? jsonQueryConverter.toLocalParams(val, newMap) : val.toString()});\n        }\n\n      }\n\n\n    }\n\n    if (json != null) {\n      req.setJSON(json);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0dec8faa342587767c2f95ad26a8315b8068392b","date":1578083291,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/json/RequestUtil#processParams(SolrRequestHandler,SolrQueryRequest,SolrParams,SolrParams,SolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/json/RequestUtil#processParams(SolrRequestHandler,SolrQueryRequest,SolrParams,SolrParams,SolrParams).mjava","sourceNew":"  /**\n   * Set default-ish params on a SolrQueryRequest as well as do standard macro processing and JSON request parsing.\n   *\n   * @param handler The search handler this is for (may be null if you don't want this method touching the content streams)\n   * @param req The request whose params we are interested in\n   * @param defaults values to be used if no values are specified in the request params\n   * @param appends values to be appended to those from the request (or defaults) when dealing with multi-val params, or treated as another layer of defaults for singl-val params.\n   * @param invariants values which will be used instead of any request, or default values, regardless of context.\n   */\n  public static void processParams(SolrRequestHandler handler, SolrQueryRequest req, SolrParams defaults,\n                                   SolrParams appends, SolrParams invariants) {\n\n    boolean searchHandler = handler instanceof SearchHandler;\n    SolrParams params = req.getParams();\n\n    // Handle JSON stream for search requests\n    if (searchHandler && req.getContentStreams() != null) {\n\n      Map<String,String[]> map = MultiMapSolrParams.asMultiMap(params, false);\n\n      if (!(params instanceof MultiMapSolrParams || params instanceof ModifiableSolrParams)) {\n        // need to set params on request since we weren't able to access the original map\n        params = new MultiMapSolrParams(map);\n        req.setParams(params);\n      }\n\n      String[] jsonFromParams = map.remove(JSON);  // params from the query string should come after (and hence override) JSON content streams\n\n      for (ContentStream cs : req.getContentStreams()) {\n        String contentType = cs.getContentType();\n        if (contentType==null || !contentType.contains(\"/json\")) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad contentType for search handler :\" + contentType + \" request=\"+req);\n        }\n\n        try {\n          String jsonString = IOUtils.toString( cs.getReader() );\n          if (jsonString != null) {\n            MultiMapSolrParams.addParam(JSON, jsonString, map);\n          }\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Exception reading content stream for request:\"+req, e);\n        }\n      }\n\n      // append existing \"json\" params\n      if (jsonFromParams != null) {\n        for (String json : jsonFromParams) {\n          MultiMapSolrParams.addParam(JSON, json, map);\n        }\n      }\n    }\n\n    String[] jsonS = params.getParams(JSON);\n\n    boolean hasAdditions = defaults != null || invariants != null || appends != null || jsonS != null;\n\n    // short circuit processing\n    if (!hasAdditions && !params.getBool(\"expandMacros\", true)) {\n      return;  // nothing to do...\n    }\n\n    boolean isShard = params.getBool(\"isShard\", false);\n\n    Map<String, String[]> newMap = MultiMapSolrParams.asMultiMap(params, hasAdditions);\n\n\n    // see if the json has a \"params\" section\n    // TODO: we should currently *not* do this if this is a leaf of a distributed search since it could overwrite parameters set by the top-level\n    // The parameters we extract will be propagated anyway.\n    if (jsonS != null && !isShard) {\n      for (String json : jsonS) {\n        getParamsFromJSON(newMap, json);\n      }\n    }\n\n    // first populate defaults, etc..\n    if (defaults != null) {\n      Map<String, String[]> defaultsMap = MultiMapSolrParams.asMultiMap(defaults);\n      for (Map.Entry<String, String[]> entry : defaultsMap.entrySet()) {\n        String key = entry.getKey();\n        if (!newMap.containsKey(key)) {\n          newMap.put(key, entry.getValue());\n        }\n      }\n    }\n\n    if (appends != null) {\n      Map<String, String[]> appendsMap = MultiMapSolrParams.asMultiMap(appends);\n\n      for (Map.Entry<String, String[]> entry : appendsMap.entrySet()) {\n        String key = entry.getKey();\n        String[] arr = newMap.get(key);\n        if (arr == null) {\n          newMap.put(key, entry.getValue());\n        } else {\n          String[] appendArr = entry.getValue();\n          String[] newArr = new String[arr.length + appendArr.length];\n          System.arraycopy(arr, 0, newArr, 0, arr.length);\n          System.arraycopy(appendArr, 0, newArr, arr.length, appendArr.length);\n          newMap.put(key, newArr);\n        }\n      }\n    }\n\n\n    if (invariants != null) {\n      newMap.putAll( MultiMapSolrParams.asMultiMap(invariants) );\n    }\n\n    if (!isShard) { // Don't expand macros in shard requests\n      String[] doMacrosStr = newMap.get(\"expandMacros\");\n      boolean doMacros = true;\n      if (doMacrosStr != null) {\n        doMacros = \"true\".equals(doMacrosStr[0]);\n      }\n\n      if (doMacros) {\n        newMap = MacroExpander.expand(newMap);\n      }\n    }\n    // Set these params as soon as possible so if there is an error processing later, things like\n    // \"wt=json\" will take effect from the defaults.\n    SolrParams newParams = new MultiMapSolrParams(newMap);  // newMap may still change below, but that should be OK\n    req.setParams(newParams);\n\n\n    // Skip the rest of the processing (including json processing for now) if this isn't a search handler.\n    // For example json.command started to be used  in SOLR-6294, and that caused errors here.\n    if (!searchHandler) return;\n\n\n    Map<String, Object> json = null;\n    // Handle JSON body first, so query params will always overlay on that\n    jsonS = newMap.get(JSON);\n    if (jsonS != null) {\n      if (json == null) {\n        json = new LinkedHashMap<>();\n      }\n      mergeJSON(json, JSON, jsonS, new ObjectUtil.ConflictHandler());\n    }\n    for (Map.Entry<String, String[]> entry : newMap.entrySet()) {\n      String key = entry.getKey();\n      // json.nl, json.wrf are existing query parameters\n      if (key.startsWith(\"json.\") && !(\"json.nl\".equals(key) || \"json.wrf\".equals(key))) {\n        if (json == null) {\n          json = new LinkedHashMap<>();\n        }\n        mergeJSON(json, key, entry.getValue(), new ObjectUtil.ConflictHandler());\n      }\n    }\n\n    // implement compat for existing components...\n    JsonQueryConverter jsonQueryConverter = new JsonQueryConverter();\n\n    if (json != null && !isShard) {\n      for (Map.Entry<String,Object> entry : json.entrySet()) {\n        String key = entry.getKey();\n        String out = null;\n        boolean isQuery = false;\n        boolean arr = false;\n        if (\"query\".equals(key)) {\n          out = \"q\";\n          isQuery = true;\n        } else if (\"filter\".equals(key)) {\n          out = \"fq\";\n          arr = true;\n          isQuery = true;\n        } else if (\"fields\".equals(key)) {\n          out = \"fl\";\n          arr = true;\n        } else if (\"offset\".equals(key)) {\n          out = \"start\";\n        } else if (\"limit\".equals(key)) {\n          out = \"rows\";\n        } else if (SORT.equals(key)) {\n          out = SORT;\n        } else if (\"queries\".equals(key)) {\n          Object queriesJsonObj = entry.getValue();\n          if (queriesJsonObj instanceof Map && queriesJsonObj != null) {\n            @SuppressWarnings(\"unchecked\")\n            final Map<String,Object> queriesAsMap = (Map<String,Object>) queriesJsonObj;\n            for (Map.Entry<String,Object> queryJsonProperty : queriesAsMap.entrySet()) {\n              out = queryJsonProperty.getKey();\n              arr = true;\n              isQuery = true;\n              convertJsonPropertyToLocalParams(newMap, jsonQueryConverter, queryJsonProperty, out, isQuery, arr);\n            }\n            continue;\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"Expected Map for 'queries', received \" + queriesJsonObj);\n          }\n        } else if (\"params\".equals(key) || \"facet\".equals(key) ) {\n          // handled elsewhere\n          continue;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown top-level key in JSON request : \" + key);\n        }\n        convertJsonPropertyToLocalParams(newMap, jsonQueryConverter, entry, out, isQuery, arr);\n      }\n    }\n\n    if (json != null) {\n      req.setJSON(json);\n    }\n  }\n\n","sourceOld":"  /**\n   * Set default-ish params on a SolrQueryRequest as well as do standard macro processing and JSON request parsing.\n   *\n   * @param handler The search handler this is for (may be null if you don't want this method touching the content streams)\n   * @param req The request whose params we are interested in\n   * @param defaults values to be used if no values are specified in the request params\n   * @param appends values to be appended to those from the request (or defaults) when dealing with multi-val params, or treated as another layer of defaults for singl-val params.\n   * @param invariants values which will be used instead of any request, or default values, regardless of context.\n   */\n  public static void processParams(SolrRequestHandler handler, SolrQueryRequest req, SolrParams defaults,\n                                   SolrParams appends, SolrParams invariants) {\n\n    boolean searchHandler = handler instanceof SearchHandler;\n    SolrParams params = req.getParams();\n\n    // Handle JSON stream for search requests\n    if (searchHandler && req.getContentStreams() != null) {\n\n      Map<String,String[]> map = MultiMapSolrParams.asMultiMap(params, false);\n\n      if (!(params instanceof MultiMapSolrParams || params instanceof ModifiableSolrParams)) {\n        // need to set params on request since we weren't able to access the original map\n        params = new MultiMapSolrParams(map);\n        req.setParams(params);\n      }\n\n      String[] jsonFromParams = map.remove(JSON);  // params from the query string should come after (and hence override) JSON content streams\n\n      for (ContentStream cs : req.getContentStreams()) {\n        String contentType = cs.getContentType();\n        if (contentType==null || !contentType.contains(\"/json\")) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad contentType for search handler :\" + contentType + \" request=\"+req);\n        }\n\n        try {\n          String jsonString = IOUtils.toString( cs.getReader() );\n          if (jsonString != null) {\n            MultiMapSolrParams.addParam(JSON, jsonString, map);\n          }\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Exception reading content stream for request:\"+req, e);\n        }\n      }\n\n      // append existing \"json\" params\n      if (jsonFromParams != null) {\n        for (String json : jsonFromParams) {\n          MultiMapSolrParams.addParam(JSON, json, map);\n        }\n      }\n    }\n\n    String[] jsonS = params.getParams(JSON);\n\n    boolean hasAdditions = defaults != null || invariants != null || appends != null || jsonS != null;\n\n    // short circuit processing\n    if (!hasAdditions && !params.getBool(\"expandMacros\", true)) {\n      return;  // nothing to do...\n    }\n\n    boolean isShard = params.getBool(\"isShard\", false);\n\n    Map<String, String[]> newMap = MultiMapSolrParams.asMultiMap(params, hasAdditions);\n\n\n    // see if the json has a \"params\" section\n    // TODO: we should currently *not* do this if this is a leaf of a distributed search since it could overwrite parameters set by the top-level\n    // The parameters we extract will be propagated anyway.\n    if (jsonS != null && !isShard) {\n      for (String json : jsonS) {\n        getParamsFromJSON(newMap, json);\n      }\n    }\n\n    // first populate defaults, etc..\n    if (defaults != null) {\n      Map<String, String[]> defaultsMap = MultiMapSolrParams.asMultiMap(defaults);\n      for (Map.Entry<String, String[]> entry : defaultsMap.entrySet()) {\n        String key = entry.getKey();\n        if (!newMap.containsKey(key)) {\n          newMap.put(key, entry.getValue());\n        }\n      }\n    }\n\n    if (appends != null) {\n      Map<String, String[]> appendsMap = MultiMapSolrParams.asMultiMap(appends);\n\n      for (Map.Entry<String, String[]> entry : appendsMap.entrySet()) {\n        String key = entry.getKey();\n        String[] arr = newMap.get(key);\n        if (arr == null) {\n          newMap.put(key, entry.getValue());\n        } else {\n          String[] appendArr = entry.getValue();\n          String[] newArr = new String[arr.length + appendArr.length];\n          System.arraycopy(arr, 0, newArr, 0, arr.length);\n          System.arraycopy(appendArr, 0, newArr, arr.length, appendArr.length);\n          newMap.put(key, newArr);\n        }\n      }\n    }\n\n\n    if (invariants != null) {\n      newMap.putAll( MultiMapSolrParams.asMultiMap(invariants) );\n    }\n\n    if (!isShard) { // Don't expand macros in shard requests\n      String[] doMacrosStr = newMap.get(\"expandMacros\");\n      boolean doMacros = true;\n      if (doMacrosStr != null) {\n        doMacros = \"true\".equals(doMacrosStr[0]);\n      }\n\n      if (doMacros) {\n        newMap = MacroExpander.expand(newMap);\n      }\n    }\n    // Set these params as soon as possible so if there is an error processing later, things like\n    // \"wt=json\" will take effect from the defaults.\n    SolrParams newParams = new MultiMapSolrParams(newMap);  // newMap may still change below, but that should be OK\n    req.setParams(newParams);\n\n\n    // Skip the rest of the processing (including json processing for now) if this isn't a search handler.\n    // For example json.command started to be used  in SOLR-6294, and that caused errors here.\n    if (!searchHandler) return;\n\n\n    Map<String, Object> json = null;\n    // Handle JSON body first, so query params will always overlay on that\n    jsonS = newMap.get(JSON);\n    if (jsonS != null) {\n      if (json == null) {\n        json = new LinkedHashMap<>();\n      }\n      mergeJSON(json, JSON, jsonS, new ObjectUtil.ConflictHandler());\n    }\n    for (Map.Entry<String, String[]> entry : newMap.entrySet()) {\n      String key = entry.getKey();\n      // json.nl, json.wrf are existing query parameters\n      if (key.startsWith(\"json.\") && !(\"json.nl\".equals(key) || \"json.wrf\".equals(key))) {\n        if (json == null) {\n          json = new LinkedHashMap<>();\n        }\n        mergeJSON(json, key, entry.getValue(), new ObjectUtil.ConflictHandler());\n      }\n    }\n\n    // implement compat for existing components...\n    JsonQueryConverter jsonQueryConverter = new JsonQueryConverter();\n    if (json != null && !isShard) {\n      for (Map.Entry<String,Object> entry : json.entrySet()) {\n        String key = entry.getKey();\n        String out = null;\n        boolean isQuery = false;\n        boolean arr = false;\n        if (\"query\".equals(key)) {\n          out = \"q\";\n          isQuery = true;\n        } else if (\"filter\".equals(key)) {\n          out = \"fq\";\n          arr = true;\n          isQuery = true;\n        } else if (\"fields\".equals(key)) {\n          out = \"fl\";\n          arr = true;\n        } else if (\"offset\".equals(key)) {\n          out = \"start\";\n        } else if (\"limit\".equals(key)) {\n          out = \"rows\";\n        } else if (SORT.equals(key)) {\n          out = SORT;\n        } else if (\"params\".equals(key) || \"facet\".equals(key) ) {\n          // handled elsewhere\n          continue;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown top-level key in JSON request : \" + key);\n        }\n\n        Object val = entry.getValue();\n\n        if (arr) {\n          String[] existing = newMap.get(out);\n          List lst = val instanceof List ? (List)val : null;\n          int existingSize = existing==null ? 0 : existing.length;\n          int jsonSize = lst==null ? 1 : lst.size();\n          String[] newval = new String[ existingSize + jsonSize ];\n          for (int i=0; i<existingSize; i++) {\n            newval[i] = existing[i];\n          }\n          if (lst != null) {\n            for (int i = 0; i < jsonSize; i++) {\n              Object v = lst.get(i);\n              newval[existingSize + i] = isQuery ? jsonQueryConverter.toLocalParams(v, newMap) : v.toString();\n            }\n          } else {\n            newval[newval.length-1] = isQuery ? jsonQueryConverter.toLocalParams(val, newMap) : val.toString();\n          }\n          newMap.put(out, newval);\n        } else {\n          newMap.put(out, new String[]{isQuery ? jsonQueryConverter.toLocalParams(val, newMap) : val.toString()});\n        }\n\n      }\n\n\n    }\n\n    if (json != null) {\n      req.setJSON(json);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ca62564055241632cd20d65b5ecb8c8e93bd60c4","date":1578383112,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/json/RequestUtil#processParams(SolrRequestHandler,SolrQueryRequest,SolrParams,SolrParams,SolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/json/RequestUtil#processParams(SolrRequestHandler,SolrQueryRequest,SolrParams,SolrParams,SolrParams).mjava","sourceNew":"  /**\n   * Set default-ish params on a SolrQueryRequest as well as do standard macro processing and JSON request parsing.\n   *\n   * @param handler The search handler this is for (may be null if you don't want this method touching the content streams)\n   * @param req The request whose params we are interested in\n   * @param defaults values to be used if no values are specified in the request params\n   * @param appends values to be appended to those from the request (or defaults) when dealing with multi-val params, or treated as another layer of defaults for singl-val params.\n   * @param invariants values which will be used instead of any request, or default values, regardless of context.\n   */\n  public static void processParams(SolrRequestHandler handler, SolrQueryRequest req, SolrParams defaults,\n                                   SolrParams appends, SolrParams invariants) {\n\n    boolean searchHandler = handler instanceof SearchHandler;\n    SolrParams params = req.getParams();\n\n    // Handle JSON stream for search requests\n    if (searchHandler && req.getContentStreams() != null) {\n\n      Map<String,String[]> map = MultiMapSolrParams.asMultiMap(params, false);\n\n      if (!(params instanceof MultiMapSolrParams || params instanceof ModifiableSolrParams)) {\n        // need to set params on request since we weren't able to access the original map\n        params = new MultiMapSolrParams(map);\n        req.setParams(params);\n      }\n\n      String[] jsonFromParams = map.remove(JSON);  // params from the query string should come after (and hence override) JSON content streams\n\n      for (ContentStream cs : req.getContentStreams()) {\n        String contentType = cs.getContentType();\n        if (contentType==null || !contentType.contains(\"/json\")) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad contentType for search handler :\" + contentType + \" request=\"+req);\n        }\n\n        try {\n          String jsonString = IOUtils.toString( cs.getReader() );\n          if (jsonString != null) {\n            MultiMapSolrParams.addParam(JSON, jsonString, map);\n          }\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Exception reading content stream for request:\"+req, e);\n        }\n      }\n\n      // append existing \"json\" params\n      if (jsonFromParams != null) {\n        for (String json : jsonFromParams) {\n          MultiMapSolrParams.addParam(JSON, json, map);\n        }\n      }\n    }\n\n    String[] jsonS = params.getParams(JSON);\n\n    boolean hasAdditions = defaults != null || invariants != null || appends != null || jsonS != null;\n\n    // short circuit processing\n    if (!hasAdditions && !params.getBool(\"expandMacros\", true)) {\n      return;  // nothing to do...\n    }\n\n    boolean isShard = params.getBool(\"isShard\", false);\n\n    Map<String, String[]> newMap = MultiMapSolrParams.asMultiMap(params, hasAdditions);\n\n\n    // see if the json has a \"params\" section\n    // TODO: we should currently *not* do this if this is a leaf of a distributed search since it could overwrite parameters set by the top-level\n    // The parameters we extract will be propagated anyway.\n    if (jsonS != null && !isShard) {\n      for (String json : jsonS) {\n        getParamsFromJSON(newMap, json);\n      }\n    }\n\n    // first populate defaults, etc..\n    if (defaults != null) {\n      Map<String, String[]> defaultsMap = MultiMapSolrParams.asMultiMap(defaults);\n      for (Map.Entry<String, String[]> entry : defaultsMap.entrySet()) {\n        String key = entry.getKey();\n        if (!newMap.containsKey(key)) {\n          newMap.put(key, entry.getValue());\n        }\n      }\n    }\n\n    if (appends != null) {\n      Map<String, String[]> appendsMap = MultiMapSolrParams.asMultiMap(appends);\n\n      for (Map.Entry<String, String[]> entry : appendsMap.entrySet()) {\n        String key = entry.getKey();\n        String[] arr = newMap.get(key);\n        if (arr == null) {\n          newMap.put(key, entry.getValue());\n        } else {\n          String[] appendArr = entry.getValue();\n          String[] newArr = new String[arr.length + appendArr.length];\n          System.arraycopy(arr, 0, newArr, 0, arr.length);\n          System.arraycopy(appendArr, 0, newArr, arr.length, appendArr.length);\n          newMap.put(key, newArr);\n        }\n      }\n    }\n\n\n    if (invariants != null) {\n      newMap.putAll( MultiMapSolrParams.asMultiMap(invariants) );\n    }\n\n    if (!isShard) { // Don't expand macros in shard requests\n      String[] doMacrosStr = newMap.get(\"expandMacros\");\n      boolean doMacros = true;\n      if (doMacrosStr != null) {\n        doMacros = \"true\".equals(doMacrosStr[0]);\n      }\n\n      if (doMacros) {\n        newMap = MacroExpander.expand(newMap);\n      }\n    }\n    // Set these params as soon as possible so if there is an error processing later, things like\n    // \"wt=json\" will take effect from the defaults.\n    SolrParams newParams = new MultiMapSolrParams(newMap);  // newMap may still change below, but that should be OK\n    req.setParams(newParams);\n\n\n    // Skip the rest of the processing (including json processing for now) if this isn't a search handler.\n    // For example json.command started to be used  in SOLR-6294, and that caused errors here.\n    if (!searchHandler) return;\n\n\n    Map<String, Object> json = null;\n    // Handle JSON body first, so query params will always overlay on that\n    jsonS = newMap.get(JSON);\n    if (jsonS != null) {\n      if (json == null) {\n        json = new LinkedHashMap<>();\n      }\n      mergeJSON(json, JSON, jsonS, new ObjectUtil.ConflictHandler());\n    }\n    for (Map.Entry<String, String[]> entry : newMap.entrySet()) {\n      String key = entry.getKey();\n      // json.nl, json.wrf are existing query parameters\n      if (key.startsWith(\"json.\") && !(\"json.nl\".equals(key) || \"json.wrf\".equals(key))) {\n        if (json == null) {\n          json = new LinkedHashMap<>();\n        }\n        mergeJSON(json, key, entry.getValue(), new ObjectUtil.ConflictHandler());\n      }\n    }\n\n    // implement compat for existing components...\n    JsonQueryConverter jsonQueryConverter = new JsonQueryConverter();\n\n    if (json != null && !isShard) {\n      for (Map.Entry<String,Object> entry : json.entrySet()) {\n        String key = entry.getKey();\n        String out = null;\n        boolean isQuery = false;\n        boolean arr = false;\n        if (\"query\".equals(key)) {\n          out = \"q\";\n          isQuery = true;\n        } else if (\"filter\".equals(key)) {\n          out = \"fq\";\n          arr = true;\n          isQuery = true;\n        } else if (\"fields\".equals(key)) {\n          out = \"fl\";\n          arr = true;\n        } else if (\"offset\".equals(key)) {\n          out = \"start\";\n        } else if (\"limit\".equals(key)) {\n          out = \"rows\";\n        } else if (SORT.equals(key)) {\n          out = SORT;\n        } else if (\"queries\".equals(key)) {\n          Object queriesJsonObj = entry.getValue();\n          if (queriesJsonObj instanceof Map && queriesJsonObj != null) {\n            @SuppressWarnings(\"unchecked\")\n            final Map<String,Object> queriesAsMap = (Map<String,Object>) queriesJsonObj;\n            for (Map.Entry<String,Object> queryJsonProperty : queriesAsMap.entrySet()) {\n              out = queryJsonProperty.getKey();\n              arr = true;\n              isQuery = true;\n              convertJsonPropertyToLocalParams(newMap, jsonQueryConverter, queryJsonProperty, out, isQuery, arr);\n            }\n            continue;\n          } else {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"Expected Map for 'queries', received \" + queriesJsonObj);\n          }\n        } else if (\"params\".equals(key) || \"facet\".equals(key) ) {\n          // handled elsewhere\n          continue;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown top-level key in JSON request : \" + key);\n        }\n        convertJsonPropertyToLocalParams(newMap, jsonQueryConverter, entry, out, isQuery, arr);\n      }\n    }\n\n    if (json != null) {\n      req.setJSON(json);\n    }\n  }\n\n","sourceOld":"  /**\n   * Set default-ish params on a SolrQueryRequest as well as do standard macro processing and JSON request parsing.\n   *\n   * @param handler The search handler this is for (may be null if you don't want this method touching the content streams)\n   * @param req The request whose params we are interested in\n   * @param defaults values to be used if no values are specified in the request params\n   * @param appends values to be appended to those from the request (or defaults) when dealing with multi-val params, or treated as another layer of defaults for singl-val params.\n   * @param invariants values which will be used instead of any request, or default values, regardless of context.\n   */\n  public static void processParams(SolrRequestHandler handler, SolrQueryRequest req, SolrParams defaults,\n                                   SolrParams appends, SolrParams invariants) {\n\n    boolean searchHandler = handler instanceof SearchHandler;\n    SolrParams params = req.getParams();\n\n    // Handle JSON stream for search requests\n    if (searchHandler && req.getContentStreams() != null) {\n\n      Map<String,String[]> map = MultiMapSolrParams.asMultiMap(params, false);\n\n      if (!(params instanceof MultiMapSolrParams || params instanceof ModifiableSolrParams)) {\n        // need to set params on request since we weren't able to access the original map\n        params = new MultiMapSolrParams(map);\n        req.setParams(params);\n      }\n\n      String[] jsonFromParams = map.remove(JSON);  // params from the query string should come after (and hence override) JSON content streams\n\n      for (ContentStream cs : req.getContentStreams()) {\n        String contentType = cs.getContentType();\n        if (contentType==null || !contentType.contains(\"/json\")) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Bad contentType for search handler :\" + contentType + \" request=\"+req);\n        }\n\n        try {\n          String jsonString = IOUtils.toString( cs.getReader() );\n          if (jsonString != null) {\n            MultiMapSolrParams.addParam(JSON, jsonString, map);\n          }\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Exception reading content stream for request:\"+req, e);\n        }\n      }\n\n      // append existing \"json\" params\n      if (jsonFromParams != null) {\n        for (String json : jsonFromParams) {\n          MultiMapSolrParams.addParam(JSON, json, map);\n        }\n      }\n    }\n\n    String[] jsonS = params.getParams(JSON);\n\n    boolean hasAdditions = defaults != null || invariants != null || appends != null || jsonS != null;\n\n    // short circuit processing\n    if (!hasAdditions && !params.getBool(\"expandMacros\", true)) {\n      return;  // nothing to do...\n    }\n\n    boolean isShard = params.getBool(\"isShard\", false);\n\n    Map<String, String[]> newMap = MultiMapSolrParams.asMultiMap(params, hasAdditions);\n\n\n    // see if the json has a \"params\" section\n    // TODO: we should currently *not* do this if this is a leaf of a distributed search since it could overwrite parameters set by the top-level\n    // The parameters we extract will be propagated anyway.\n    if (jsonS != null && !isShard) {\n      for (String json : jsonS) {\n        getParamsFromJSON(newMap, json);\n      }\n    }\n\n    // first populate defaults, etc..\n    if (defaults != null) {\n      Map<String, String[]> defaultsMap = MultiMapSolrParams.asMultiMap(defaults);\n      for (Map.Entry<String, String[]> entry : defaultsMap.entrySet()) {\n        String key = entry.getKey();\n        if (!newMap.containsKey(key)) {\n          newMap.put(key, entry.getValue());\n        }\n      }\n    }\n\n    if (appends != null) {\n      Map<String, String[]> appendsMap = MultiMapSolrParams.asMultiMap(appends);\n\n      for (Map.Entry<String, String[]> entry : appendsMap.entrySet()) {\n        String key = entry.getKey();\n        String[] arr = newMap.get(key);\n        if (arr == null) {\n          newMap.put(key, entry.getValue());\n        } else {\n          String[] appendArr = entry.getValue();\n          String[] newArr = new String[arr.length + appendArr.length];\n          System.arraycopy(arr, 0, newArr, 0, arr.length);\n          System.arraycopy(appendArr, 0, newArr, arr.length, appendArr.length);\n          newMap.put(key, newArr);\n        }\n      }\n    }\n\n\n    if (invariants != null) {\n      newMap.putAll( MultiMapSolrParams.asMultiMap(invariants) );\n    }\n\n    if (!isShard) { // Don't expand macros in shard requests\n      String[] doMacrosStr = newMap.get(\"expandMacros\");\n      boolean doMacros = true;\n      if (doMacrosStr != null) {\n        doMacros = \"true\".equals(doMacrosStr[0]);\n      }\n\n      if (doMacros) {\n        newMap = MacroExpander.expand(newMap);\n      }\n    }\n    // Set these params as soon as possible so if there is an error processing later, things like\n    // \"wt=json\" will take effect from the defaults.\n    SolrParams newParams = new MultiMapSolrParams(newMap);  // newMap may still change below, but that should be OK\n    req.setParams(newParams);\n\n\n    // Skip the rest of the processing (including json processing for now) if this isn't a search handler.\n    // For example json.command started to be used  in SOLR-6294, and that caused errors here.\n    if (!searchHandler) return;\n\n\n    Map<String, Object> json = null;\n    // Handle JSON body first, so query params will always overlay on that\n    jsonS = newMap.get(JSON);\n    if (jsonS != null) {\n      if (json == null) {\n        json = new LinkedHashMap<>();\n      }\n      mergeJSON(json, JSON, jsonS, new ObjectUtil.ConflictHandler());\n    }\n    for (Map.Entry<String, String[]> entry : newMap.entrySet()) {\n      String key = entry.getKey();\n      // json.nl, json.wrf are existing query parameters\n      if (key.startsWith(\"json.\") && !(\"json.nl\".equals(key) || \"json.wrf\".equals(key))) {\n        if (json == null) {\n          json = new LinkedHashMap<>();\n        }\n        mergeJSON(json, key, entry.getValue(), new ObjectUtil.ConflictHandler());\n      }\n    }\n\n    // implement compat for existing components...\n    JsonQueryConverter jsonQueryConverter = new JsonQueryConverter();\n    if (json != null && !isShard) {\n      for (Map.Entry<String,Object> entry : json.entrySet()) {\n        String key = entry.getKey();\n        String out = null;\n        boolean isQuery = false;\n        boolean arr = false;\n        if (\"query\".equals(key)) {\n          out = \"q\";\n          isQuery = true;\n        } else if (\"filter\".equals(key)) {\n          out = \"fq\";\n          arr = true;\n          isQuery = true;\n        } else if (\"fields\".equals(key)) {\n          out = \"fl\";\n          arr = true;\n        } else if (\"offset\".equals(key)) {\n          out = \"start\";\n        } else if (\"limit\".equals(key)) {\n          out = \"rows\";\n        } else if (SORT.equals(key)) {\n          out = SORT;\n        } else if (\"params\".equals(key) || \"facet\".equals(key) ) {\n          // handled elsewhere\n          continue;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown top-level key in JSON request : \" + key);\n        }\n\n        Object val = entry.getValue();\n\n        if (arr) {\n          String[] existing = newMap.get(out);\n          List lst = val instanceof List ? (List)val : null;\n          int existingSize = existing==null ? 0 : existing.length;\n          int jsonSize = lst==null ? 1 : lst.size();\n          String[] newval = new String[ existingSize + jsonSize ];\n          for (int i=0; i<existingSize; i++) {\n            newval[i] = existing[i];\n          }\n          if (lst != null) {\n            for (int i = 0; i < jsonSize; i++) {\n              Object v = lst.get(i);\n              newval[existingSize + i] = isQuery ? jsonQueryConverter.toLocalParams(v, newMap) : v.toString();\n            }\n          } else {\n            newval[newval.length-1] = isQuery ? jsonQueryConverter.toLocalParams(val, newMap) : val.toString();\n          }\n          newMap.put(out, newval);\n        } else {\n          newMap.put(out, new String[]{isQuery ? jsonQueryConverter.toLocalParams(val, newMap) : val.toString()});\n        }\n\n      }\n\n\n    }\n\n    if (json != null) {\n      req.setJSON(json);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"f6e0714179918847970d4daef77cf2d18dbd069f":["1390137e395d2f07f9ba5b8c43d293befe84d563"],"b21283ed01203901a7257aa4b7f0a0899c86e56e":["01624b85de12fb02335810bdf325124e59040772","10eda272dbca4b0397f9b0c2aa6fadad3601db47"],"0dec8faa342587767c2f95ad26a8315b8068392b":["f97fc3d287be2a8d7f513f0de3249b50dda47299"],"6f4c5d3859373c3a74734e85efa122b17514e3e8":["8c19c480d77a53905bbd65f04e90fa35925c0f9b"],"ca62564055241632cd20d65b5ecb8c8e93bd60c4":["f97fc3d287be2a8d7f513f0de3249b50dda47299","0dec8faa342587767c2f95ad26a8315b8068392b"],"01624b85de12fb02335810bdf325124e59040772":["8c19c480d77a53905bbd65f04e90fa35925c0f9b"],"90a682dc1bfd188ef61cc28373c7f5d700b4ac75":["f6e0714179918847970d4daef77cf2d18dbd069f","8c19c480d77a53905bbd65f04e90fa35925c0f9b"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d"],"104a3f62ee393d48b5596de76ed4d9a4e0ea6de7":["01624b85de12fb02335810bdf325124e59040772","b21283ed01203901a7257aa4b7f0a0899c86e56e"],"10eda272dbca4b0397f9b0c2aa6fadad3601db47":["01624b85de12fb02335810bdf325124e59040772"],"3a7809d1d753b67f48b1a706e17034bf8b624ea3":["6f4c5d3859373c3a74734e85efa122b17514e3e8","10eda272dbca4b0397f9b0c2aa6fadad3601db47"],"1390137e395d2f07f9ba5b8c43d293befe84d563":["ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d2638f781be724518ff6c2263d14a48cf6e68017":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","1390137e395d2f07f9ba5b8c43d293befe84d563"],"ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f97fc3d287be2a8d7f513f0de3249b50dda47299":["104a3f62ee393d48b5596de76ed4d9a4e0ea6de7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0dec8faa342587767c2f95ad26a8315b8068392b"],"8c19c480d77a53905bbd65f04e90fa35925c0f9b":["f6e0714179918847970d4daef77cf2d18dbd069f"]},"commit2Childs":{"f6e0714179918847970d4daef77cf2d18dbd069f":["90a682dc1bfd188ef61cc28373c7f5d700b4ac75","8c19c480d77a53905bbd65f04e90fa35925c0f9b"],"b21283ed01203901a7257aa4b7f0a0899c86e56e":["104a3f62ee393d48b5596de76ed4d9a4e0ea6de7"],"0dec8faa342587767c2f95ad26a8315b8068392b":["ca62564055241632cd20d65b5ecb8c8e93bd60c4","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6f4c5d3859373c3a74734e85efa122b17514e3e8":["3a7809d1d753b67f48b1a706e17034bf8b624ea3"],"ca62564055241632cd20d65b5ecb8c8e93bd60c4":[],"01624b85de12fb02335810bdf325124e59040772":["b21283ed01203901a7257aa4b7f0a0899c86e56e","104a3f62ee393d48b5596de76ed4d9a4e0ea6de7","10eda272dbca4b0397f9b0c2aa6fadad3601db47"],"90a682dc1bfd188ef61cc28373c7f5d700b4ac75":[],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["d2638f781be724518ff6c2263d14a48cf6e68017"],"10eda272dbca4b0397f9b0c2aa6fadad3601db47":["b21283ed01203901a7257aa4b7f0a0899c86e56e","3a7809d1d753b67f48b1a706e17034bf8b624ea3"],"104a3f62ee393d48b5596de76ed4d9a4e0ea6de7":["f97fc3d287be2a8d7f513f0de3249b50dda47299"],"3a7809d1d753b67f48b1a706e17034bf8b624ea3":[],"1390137e395d2f07f9ba5b8c43d293befe84d563":["f6e0714179918847970d4daef77cf2d18dbd069f","d2638f781be724518ff6c2263d14a48cf6e68017"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d"],"d2638f781be724518ff6c2263d14a48cf6e68017":[],"ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","1390137e395d2f07f9ba5b8c43d293befe84d563"],"f97fc3d287be2a8d7f513f0de3249b50dda47299":["0dec8faa342587767c2f95ad26a8315b8068392b","ca62564055241632cd20d65b5ecb8c8e93bd60c4"],"8c19c480d77a53905bbd65f04e90fa35925c0f9b":["6f4c5d3859373c3a74734e85efa122b17514e3e8","01624b85de12fb02335810bdf325124e59040772","90a682dc1bfd188ef61cc28373c7f5d700b4ac75"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ca62564055241632cd20d65b5ecb8c8e93bd60c4","90a682dc1bfd188ef61cc28373c7f5d700b4ac75","3a7809d1d753b67f48b1a706e17034bf8b624ea3","d2638f781be724518ff6c2263d14a48cf6e68017","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}