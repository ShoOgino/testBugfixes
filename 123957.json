{"path":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/tree/DateRangePrefixTree#DateRangePrefixTree(Calendar).mjava","commits":[{"id":"17bb09a766d49e4c0bb1049cebc1cf10236004f7","date":1463076873,"type":0,"author":"David Smiley","isMerge":false,"pathNew":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/tree/DateRangePrefixTree#DateRangePrefixTree(Calendar).mjava","pathOld":"/dev/null","sourceNew":"  /** Constructs with the specified calendar used as a template to be cloned whenever a new\n   * Calendar needs to be created.  See {@link #DEFAULT_CAL} and {@link #JAVA_UTIL_TIME_COMPAT_CAL}. */\n  public DateRangePrefixTree(Calendar templateCal) {\n    super(new int[]{//sublevels by level\n        NUM_MYEARS,\n        1000,//1 thousand thousand-years in a million years\n        1000,//1 thousand years in a thousand-year\n        calFieldLen(templateCal, Calendar.MONTH),\n        calFieldLen(templateCal, Calendar.DAY_OF_MONTH),\n        calFieldLen(templateCal, Calendar.HOUR_OF_DAY),\n        calFieldLen(templateCal, Calendar.MINUTE),\n        calFieldLen(templateCal, Calendar.SECOND),\n        calFieldLen(templateCal, Calendar.MILLISECOND),\n    });\n    CAL_TMP = (Calendar) templateCal.clone();// defensive copy\n    MINCAL = (Calendar) CAL_TMP.clone();\n    MINCAL.setTimeInMillis(Long.MIN_VALUE);\n    MAXCAL = (Calendar) CAL_TMP.clone();\n    MAXCAL.setTimeInMillis(Long.MAX_VALUE);\n    //BC years are decreasing, remember.  Yet ActualMaximum is the numerically high value, ActualMinimum is 1.\n    BC_FIRSTYEAR = MINCAL.getActualMaximum(Calendar.YEAR);\n    BC_LASTYEAR = MINCAL.getActualMinimum(Calendar.YEAR); // 1\n    BC_YEARS = BC_FIRSTYEAR - BC_LASTYEAR + 1;\n    AD_FIRSTYEAR = MAXCAL.getActualMinimum(Calendar.YEAR); // 1\n    AD_LASTYEAR = MAXCAL.getActualMaximum(Calendar.YEAR);\n    AD_YEAR_BASE = (((BC_YEARS-1) / 1000_000)+1) * 1000_000;\n    assert BC_LASTYEAR == 1 && AD_FIRSTYEAR == 1;\n    assert NUM_MYEARS == (AD_YEAR_BASE + AD_LASTYEAR) / 1000_000;\n\n    maxLV = toShape((Calendar)MAXCAL.clone());\n    minLV = toShape((Calendar)MINCAL.clone());\n    if (MAXCAL instanceof GregorianCalendar) {\n      GregorianCalendar gCal = (GregorianCalendar)MAXCAL;\n      gregorianChangeDateLV = toUnitShape(gCal.getGregorianChange());\n    } else {\n      gregorianChangeDateLV = null;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["8d90de7424532c309a28f841ccfbf21899a0d1f4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0ad30c6a479e764150a3316e57263319775f1df2","date":1463395403,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/tree/DateRangePrefixTree#DateRangePrefixTree(Calendar).mjava","pathOld":"/dev/null","sourceNew":"  /** Constructs with the specified calendar used as a template to be cloned whenever a new\n   * Calendar needs to be created.  See {@link #DEFAULT_CAL} and {@link #JAVA_UTIL_TIME_COMPAT_CAL}. */\n  public DateRangePrefixTree(Calendar templateCal) {\n    super(new int[]{//sublevels by level\n        NUM_MYEARS,\n        1000,//1 thousand thousand-years in a million years\n        1000,//1 thousand years in a thousand-year\n        calFieldLen(templateCal, Calendar.MONTH),\n        calFieldLen(templateCal, Calendar.DAY_OF_MONTH),\n        calFieldLen(templateCal, Calendar.HOUR_OF_DAY),\n        calFieldLen(templateCal, Calendar.MINUTE),\n        calFieldLen(templateCal, Calendar.SECOND),\n        calFieldLen(templateCal, Calendar.MILLISECOND),\n    });\n    CAL_TMP = (Calendar) templateCal.clone();// defensive copy\n    MINCAL = (Calendar) CAL_TMP.clone();\n    MINCAL.setTimeInMillis(Long.MIN_VALUE);\n    MAXCAL = (Calendar) CAL_TMP.clone();\n    MAXCAL.setTimeInMillis(Long.MAX_VALUE);\n    //BC years are decreasing, remember.  Yet ActualMaximum is the numerically high value, ActualMinimum is 1.\n    BC_FIRSTYEAR = MINCAL.getActualMaximum(Calendar.YEAR);\n    BC_LASTYEAR = MINCAL.getActualMinimum(Calendar.YEAR); // 1\n    BC_YEARS = BC_FIRSTYEAR - BC_LASTYEAR + 1;\n    AD_FIRSTYEAR = MAXCAL.getActualMinimum(Calendar.YEAR); // 1\n    AD_LASTYEAR = MAXCAL.getActualMaximum(Calendar.YEAR);\n    AD_YEAR_BASE = (((BC_YEARS-1) / 1000_000)+1) * 1000_000;\n    assert BC_LASTYEAR == 1 && AD_FIRSTYEAR == 1;\n    assert NUM_MYEARS == (AD_YEAR_BASE + AD_LASTYEAR) / 1000_000;\n\n    maxLV = toShape((Calendar)MAXCAL.clone());\n    minLV = toShape((Calendar)MINCAL.clone());\n    if (MAXCAL instanceof GregorianCalendar) {\n      GregorianCalendar gCal = (GregorianCalendar)MAXCAL;\n      gregorianChangeDateLV = toUnitShape(gCal.getGregorianChange());\n    } else {\n      gregorianChangeDateLV = null;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/tree/DateRangePrefixTree#DateRangePrefixTree(Calendar).mjava","pathOld":"/dev/null","sourceNew":"  /** Constructs with the specified calendar used as a template to be cloned whenever a new\n   * Calendar needs to be created.  See {@link #DEFAULT_CAL} and {@link #JAVA_UTIL_TIME_COMPAT_CAL}. */\n  public DateRangePrefixTree(Calendar templateCal) {\n    super(new int[]{//sublevels by level\n        NUM_MYEARS,\n        1000,//1 thousand thousand-years in a million years\n        1000,//1 thousand years in a thousand-year\n        calFieldLen(templateCal, Calendar.MONTH),\n        calFieldLen(templateCal, Calendar.DAY_OF_MONTH),\n        calFieldLen(templateCal, Calendar.HOUR_OF_DAY),\n        calFieldLen(templateCal, Calendar.MINUTE),\n        calFieldLen(templateCal, Calendar.SECOND),\n        calFieldLen(templateCal, Calendar.MILLISECOND),\n    });\n    CAL_TMP = (Calendar) templateCal.clone();// defensive copy\n    MINCAL = (Calendar) CAL_TMP.clone();\n    MINCAL.setTimeInMillis(Long.MIN_VALUE);\n    MAXCAL = (Calendar) CAL_TMP.clone();\n    MAXCAL.setTimeInMillis(Long.MAX_VALUE);\n    //BC years are decreasing, remember.  Yet ActualMaximum is the numerically high value, ActualMinimum is 1.\n    BC_FIRSTYEAR = MINCAL.getActualMaximum(Calendar.YEAR);\n    BC_LASTYEAR = MINCAL.getActualMinimum(Calendar.YEAR); // 1\n    BC_YEARS = BC_FIRSTYEAR - BC_LASTYEAR + 1;\n    AD_FIRSTYEAR = MAXCAL.getActualMinimum(Calendar.YEAR); // 1\n    AD_LASTYEAR = MAXCAL.getActualMaximum(Calendar.YEAR);\n    AD_YEAR_BASE = (((BC_YEARS-1) / 1000_000)+1) * 1000_000;\n    assert BC_LASTYEAR == 1 && AD_FIRSTYEAR == 1;\n    assert NUM_MYEARS == (AD_YEAR_BASE + AD_LASTYEAR) / 1000_000;\n\n    maxLV = toShape((Calendar)MAXCAL.clone());\n    minLV = toShape((Calendar)MINCAL.clone());\n    if (MAXCAL instanceof GregorianCalendar) {\n      GregorianCalendar gCal = (GregorianCalendar)MAXCAL;\n      gregorianChangeDateLV = toUnitShape(gCal.getGregorianChange());\n    } else {\n      gregorianChangeDateLV = null;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/tree/DateRangePrefixTree#DateRangePrefixTree(Calendar).mjava","pathOld":"/dev/null","sourceNew":"  /** Constructs with the specified calendar used as a template to be cloned whenever a new\n   * Calendar needs to be created.  See {@link #DEFAULT_CAL} and {@link #JAVA_UTIL_TIME_COMPAT_CAL}. */\n  public DateRangePrefixTree(Calendar templateCal) {\n    super(new int[]{//sublevels by level\n        NUM_MYEARS,\n        1000,//1 thousand thousand-years in a million years\n        1000,//1 thousand years in a thousand-year\n        calFieldLen(templateCal, Calendar.MONTH),\n        calFieldLen(templateCal, Calendar.DAY_OF_MONTH),\n        calFieldLen(templateCal, Calendar.HOUR_OF_DAY),\n        calFieldLen(templateCal, Calendar.MINUTE),\n        calFieldLen(templateCal, Calendar.SECOND),\n        calFieldLen(templateCal, Calendar.MILLISECOND),\n    });\n    CAL_TMP = (Calendar) templateCal.clone();// defensive copy\n    MINCAL = (Calendar) CAL_TMP.clone();\n    MINCAL.setTimeInMillis(Long.MIN_VALUE);\n    MAXCAL = (Calendar) CAL_TMP.clone();\n    MAXCAL.setTimeInMillis(Long.MAX_VALUE);\n    //BC years are decreasing, remember.  Yet ActualMaximum is the numerically high value, ActualMinimum is 1.\n    BC_FIRSTYEAR = MINCAL.getActualMaximum(Calendar.YEAR);\n    BC_LASTYEAR = MINCAL.getActualMinimum(Calendar.YEAR); // 1\n    BC_YEARS = BC_FIRSTYEAR - BC_LASTYEAR + 1;\n    AD_FIRSTYEAR = MAXCAL.getActualMinimum(Calendar.YEAR); // 1\n    AD_LASTYEAR = MAXCAL.getActualMaximum(Calendar.YEAR);\n    AD_YEAR_BASE = (((BC_YEARS-1) / 1000_000)+1) * 1000_000;\n    assert BC_LASTYEAR == 1 && AD_FIRSTYEAR == 1;\n    assert NUM_MYEARS == (AD_YEAR_BASE + AD_LASTYEAR) / 1000_000;\n\n    maxLV = toShape((Calendar)MAXCAL.clone());\n    minLV = toShape((Calendar)MINCAL.clone());\n    if (MAXCAL instanceof GregorianCalendar) {\n      GregorianCalendar gCal = (GregorianCalendar)MAXCAL;\n      gregorianChangeDateLV = toUnitShape(gCal.getGregorianChange());\n    } else {\n      gregorianChangeDateLV = null;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8d90de7424532c309a28f841ccfbf21899a0d1f4","date":1493841034,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/tree/DateRangePrefixTree#DateRangePrefixTree(Calendar).mjava","pathOld":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/tree/DateRangePrefixTree#DateRangePrefixTree(Calendar).mjava","sourceNew":"  /** Constructs with the specified calendar used as a template to be cloned whenever a new\n   * Calendar needs to be created.  See {@link #DEFAULT_CAL} and {@link #JAVA_UTIL_TIME_COMPAT_CAL}. */\n  public DateRangePrefixTree(Calendar templateCal) {\n    super(new int[]{//sublevels by level\n        NUM_MYEARS,\n        1000,//1 thousand thousand-years in a million years\n        1000,//1 thousand years in a thousand-year\n        calFieldLen(templateCal, Calendar.MONTH),\n        calFieldLen(templateCal, Calendar.DAY_OF_MONTH),\n        calFieldLen(templateCal, Calendar.HOUR_OF_DAY),\n        calFieldLen(templateCal, Calendar.MINUTE),\n        calFieldLen(templateCal, Calendar.SECOND),\n        calFieldLen(templateCal, Calendar.MILLISECOND),\n    });\n    CAL_TMP = (Calendar) templateCal.clone();// defensive copy\n    MINCAL = (Calendar) CAL_TMP.clone();\n    MINCAL.setTimeInMillis(Long.MIN_VALUE);\n    MAXCAL = (Calendar) CAL_TMP.clone();\n    MAXCAL.setTimeInMillis(Long.MAX_VALUE);\n    //BC years are decreasing, remember.  Yet ActualMaximum is the numerically high value, ActualMinimum is 1.\n    BC_FIRSTYEAR = MINCAL.getActualMaximum(Calendar.YEAR);\n    BC_LASTYEAR = MINCAL.getActualMinimum(Calendar.YEAR); // 1\n    BC_YEARS = BC_FIRSTYEAR - BC_LASTYEAR + 1;\n    AD_FIRSTYEAR = MAXCAL.getActualMinimum(Calendar.YEAR); // 1\n    AD_LASTYEAR = MAXCAL.getActualMaximum(Calendar.YEAR);\n    AD_YEAR_BASE = (((BC_YEARS-1) / 1000_000)+1) * 1000_000; // align year 0 at an even # of million years\n    assert BC_LASTYEAR == 1 && AD_FIRSTYEAR == 1;\n    assert NUM_MYEARS == (AD_YEAR_BASE + AD_LASTYEAR) / 1000_000 + 1;\n\n    maxLV = toShape((Calendar)MAXCAL.clone());\n    minLV = toShape((Calendar)MINCAL.clone());\n    if (MAXCAL instanceof GregorianCalendar) {\n      GregorianCalendar gCal = (GregorianCalendar)MAXCAL;\n      gregorianChangeDateLV = toUnitShape(gCal.getGregorianChange());\n    } else {\n      gregorianChangeDateLV = null;\n    }\n  }\n\n","sourceOld":"  /** Constructs with the specified calendar used as a template to be cloned whenever a new\n   * Calendar needs to be created.  See {@link #DEFAULT_CAL} and {@link #JAVA_UTIL_TIME_COMPAT_CAL}. */\n  public DateRangePrefixTree(Calendar templateCal) {\n    super(new int[]{//sublevels by level\n        NUM_MYEARS,\n        1000,//1 thousand thousand-years in a million years\n        1000,//1 thousand years in a thousand-year\n        calFieldLen(templateCal, Calendar.MONTH),\n        calFieldLen(templateCal, Calendar.DAY_OF_MONTH),\n        calFieldLen(templateCal, Calendar.HOUR_OF_DAY),\n        calFieldLen(templateCal, Calendar.MINUTE),\n        calFieldLen(templateCal, Calendar.SECOND),\n        calFieldLen(templateCal, Calendar.MILLISECOND),\n    });\n    CAL_TMP = (Calendar) templateCal.clone();// defensive copy\n    MINCAL = (Calendar) CAL_TMP.clone();\n    MINCAL.setTimeInMillis(Long.MIN_VALUE);\n    MAXCAL = (Calendar) CAL_TMP.clone();\n    MAXCAL.setTimeInMillis(Long.MAX_VALUE);\n    //BC years are decreasing, remember.  Yet ActualMaximum is the numerically high value, ActualMinimum is 1.\n    BC_FIRSTYEAR = MINCAL.getActualMaximum(Calendar.YEAR);\n    BC_LASTYEAR = MINCAL.getActualMinimum(Calendar.YEAR); // 1\n    BC_YEARS = BC_FIRSTYEAR - BC_LASTYEAR + 1;\n    AD_FIRSTYEAR = MAXCAL.getActualMinimum(Calendar.YEAR); // 1\n    AD_LASTYEAR = MAXCAL.getActualMaximum(Calendar.YEAR);\n    AD_YEAR_BASE = (((BC_YEARS-1) / 1000_000)+1) * 1000_000;\n    assert BC_LASTYEAR == 1 && AD_FIRSTYEAR == 1;\n    assert NUM_MYEARS == (AD_YEAR_BASE + AD_LASTYEAR) / 1000_000;\n\n    maxLV = toShape((Calendar)MAXCAL.clone());\n    minLV = toShape((Calendar)MINCAL.clone());\n    if (MAXCAL instanceof GregorianCalendar) {\n      GregorianCalendar gCal = (GregorianCalendar)MAXCAL;\n      gregorianChangeDateLV = toUnitShape(gCal.getGregorianChange());\n    } else {\n      gregorianChangeDateLV = null;\n    }\n  }\n\n","bugFix":["17bb09a766d49e4c0bb1049cebc1cf10236004f7"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/tree/DateRangePrefixTree#DateRangePrefixTree(Calendar).mjava","pathOld":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/tree/DateRangePrefixTree#DateRangePrefixTree(Calendar).mjava","sourceNew":"  /** Constructs with the specified calendar used as a template to be cloned whenever a new\n   * Calendar needs to be created.  See {@link #DEFAULT_CAL} and {@link #JAVA_UTIL_TIME_COMPAT_CAL}. */\n  public DateRangePrefixTree(Calendar templateCal) {\n    super(new int[]{//sublevels by level\n        NUM_MYEARS,\n        1000,//1 thousand thousand-years in a million years\n        1000,//1 thousand years in a thousand-year\n        calFieldLen(templateCal, Calendar.MONTH),\n        calFieldLen(templateCal, Calendar.DAY_OF_MONTH),\n        calFieldLen(templateCal, Calendar.HOUR_OF_DAY),\n        calFieldLen(templateCal, Calendar.MINUTE),\n        calFieldLen(templateCal, Calendar.SECOND),\n        calFieldLen(templateCal, Calendar.MILLISECOND),\n    });\n    CAL_TMP = (Calendar) templateCal.clone();// defensive copy\n    MINCAL = (Calendar) CAL_TMP.clone();\n    MINCAL.setTimeInMillis(Long.MIN_VALUE);\n    MAXCAL = (Calendar) CAL_TMP.clone();\n    MAXCAL.setTimeInMillis(Long.MAX_VALUE);\n    //BC years are decreasing, remember.  Yet ActualMaximum is the numerically high value, ActualMinimum is 1.\n    BC_FIRSTYEAR = MINCAL.getActualMaximum(Calendar.YEAR);\n    BC_LASTYEAR = MINCAL.getActualMinimum(Calendar.YEAR); // 1\n    BC_YEARS = BC_FIRSTYEAR - BC_LASTYEAR + 1;\n    AD_FIRSTYEAR = MAXCAL.getActualMinimum(Calendar.YEAR); // 1\n    AD_LASTYEAR = MAXCAL.getActualMaximum(Calendar.YEAR);\n    AD_YEAR_BASE = (((BC_YEARS-1) / 1000_000)+1) * 1000_000; // align year 0 at an even # of million years\n    assert BC_LASTYEAR == 1 && AD_FIRSTYEAR == 1;\n    assert NUM_MYEARS == (AD_YEAR_BASE + AD_LASTYEAR) / 1000_000 + 1;\n\n    maxLV = toShape((Calendar)MAXCAL.clone());\n    minLV = toShape((Calendar)MINCAL.clone());\n    if (MAXCAL instanceof GregorianCalendar) {\n      GregorianCalendar gCal = (GregorianCalendar)MAXCAL;\n      gregorianChangeDateLV = toUnitShape(gCal.getGregorianChange());\n    } else {\n      gregorianChangeDateLV = null;\n    }\n  }\n\n","sourceOld":"  /** Constructs with the specified calendar used as a template to be cloned whenever a new\n   * Calendar needs to be created.  See {@link #DEFAULT_CAL} and {@link #JAVA_UTIL_TIME_COMPAT_CAL}. */\n  public DateRangePrefixTree(Calendar templateCal) {\n    super(new int[]{//sublevels by level\n        NUM_MYEARS,\n        1000,//1 thousand thousand-years in a million years\n        1000,//1 thousand years in a thousand-year\n        calFieldLen(templateCal, Calendar.MONTH),\n        calFieldLen(templateCal, Calendar.DAY_OF_MONTH),\n        calFieldLen(templateCal, Calendar.HOUR_OF_DAY),\n        calFieldLen(templateCal, Calendar.MINUTE),\n        calFieldLen(templateCal, Calendar.SECOND),\n        calFieldLen(templateCal, Calendar.MILLISECOND),\n    });\n    CAL_TMP = (Calendar) templateCal.clone();// defensive copy\n    MINCAL = (Calendar) CAL_TMP.clone();\n    MINCAL.setTimeInMillis(Long.MIN_VALUE);\n    MAXCAL = (Calendar) CAL_TMP.clone();\n    MAXCAL.setTimeInMillis(Long.MAX_VALUE);\n    //BC years are decreasing, remember.  Yet ActualMaximum is the numerically high value, ActualMinimum is 1.\n    BC_FIRSTYEAR = MINCAL.getActualMaximum(Calendar.YEAR);\n    BC_LASTYEAR = MINCAL.getActualMinimum(Calendar.YEAR); // 1\n    BC_YEARS = BC_FIRSTYEAR - BC_LASTYEAR + 1;\n    AD_FIRSTYEAR = MAXCAL.getActualMinimum(Calendar.YEAR); // 1\n    AD_LASTYEAR = MAXCAL.getActualMaximum(Calendar.YEAR);\n    AD_YEAR_BASE = (((BC_YEARS-1) / 1000_000)+1) * 1000_000;\n    assert BC_LASTYEAR == 1 && AD_FIRSTYEAR == 1;\n    assert NUM_MYEARS == (AD_YEAR_BASE + AD_LASTYEAR) / 1000_000;\n\n    maxLV = toShape((Calendar)MAXCAL.clone());\n    minLV = toShape((Calendar)MINCAL.clone());\n    if (MAXCAL instanceof GregorianCalendar) {\n      GregorianCalendar gCal = (GregorianCalendar)MAXCAL;\n      gregorianChangeDateLV = toUnitShape(gCal.getGregorianChange());\n    } else {\n      gregorianChangeDateLV = null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e9017cf144952056066919f1ebc7897ff9bd71b1":["d470c8182e92b264680e34081b75e70a9f2b3c89","8d90de7424532c309a28f841ccfbf21899a0d1f4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0ad30c6a479e764150a3316e57263319775f1df2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","17bb09a766d49e4c0bb1049cebc1cf10236004f7"],"17bb09a766d49e4c0bb1049cebc1cf10236004f7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"8d90de7424532c309a28f841ccfbf21899a0d1f4":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","d470c8182e92b264680e34081b75e70a9f2b3c89"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8d90de7424532c309a28f841ccfbf21899a0d1f4"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","0ad30c6a479e764150a3316e57263319775f1df2"]},"commit2Childs":{"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0ad30c6a479e764150a3316e57263319775f1df2","17bb09a766d49e4c0bb1049cebc1cf10236004f7","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","d470c8182e92b264680e34081b75e70a9f2b3c89"],"0ad30c6a479e764150a3316e57263319775f1df2":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"17bb09a766d49e4c0bb1049cebc1cf10236004f7":["0ad30c6a479e764150a3316e57263319775f1df2"],"8d90de7424532c309a28f841ccfbf21899a0d1f4":["e9017cf144952056066919f1ebc7897ff9bd71b1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"d470c8182e92b264680e34081b75e70a9f2b3c89":["e9017cf144952056066919f1ebc7897ff9bd71b1","8d90de7424532c309a28f841ccfbf21899a0d1f4","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["e9017cf144952056066919f1ebc7897ff9bd71b1","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}