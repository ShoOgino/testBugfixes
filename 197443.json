{"path":"lucene/src/java/org/apache/lucene/search/FieldCacheImpl.StringIndexCache#createValue(IndexReader,Entry).mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/FieldCacheImpl.StringIndexCache#createValue(IndexReader,Entry).mjava","pathOld":"src/java/org/apache/lucene/search/FieldCacheImpl.StringIndexCache#createValue(IndexReader,Entry).mjava","sourceNew":"    @Override\n    protected Object createValue(IndexReader reader, Entry entryKey)\n        throws IOException {\n      String field = StringHelper.intern(entryKey.field);\n      final int[] retArray = new int[reader.maxDoc()];\n      String[] mterms = new String[reader.maxDoc()+1];\n      TermDocs termDocs = reader.termDocs();\n      TermEnum termEnum = reader.terms (new Term (field));\n      int t = 0;  // current term number\n\n      // an entry for documents that have no terms in this field\n      // should a document with no terms be at top or bottom?\n      // this puts them at the top - if it is changed, FieldDocSortedHitQueue\n      // needs to change as well.\n      mterms[t++] = null;\n\n      try {\n        do {\n          Term term = termEnum.term();\n          if (term==null || term.field() != field) break;\n\n          // store term text\n          mterms[t] = term.text();\n\n          termDocs.seek (termEnum);\n          while (termDocs.next()) {\n            retArray[termDocs.doc()] = t;\n          }\n\n          t++;\n        } while (termEnum.next());\n      } finally {\n        termDocs.close();\n        termEnum.close();\n      }\n\n      if (t == 0) {\n        // if there are no terms, make the term array\n        // have a single null entry\n        mterms = new String[1];\n      } else if (t < mterms.length) {\n        // if there are less terms than documents,\n        // trim off the dead array space\n        String[] terms = new String[t];\n        System.arraycopy (mterms, 0, terms, 0, t);\n        mterms = terms;\n      }\n\n      StringIndex value = new StringIndex (retArray, mterms);\n      return value;\n    }\n\n","sourceOld":"    @Override\n    protected Object createValue(IndexReader reader, Entry entryKey)\n        throws IOException {\n      String field = StringHelper.intern(entryKey.field);\n      final int[] retArray = new int[reader.maxDoc()];\n      String[] mterms = new String[reader.maxDoc()+1];\n      TermDocs termDocs = reader.termDocs();\n      TermEnum termEnum = reader.terms (new Term (field));\n      int t = 0;  // current term number\n\n      // an entry for documents that have no terms in this field\n      // should a document with no terms be at top or bottom?\n      // this puts them at the top - if it is changed, FieldDocSortedHitQueue\n      // needs to change as well.\n      mterms[t++] = null;\n\n      try {\n        do {\n          Term term = termEnum.term();\n          if (term==null || term.field() != field) break;\n\n          // store term text\n          mterms[t] = term.text();\n\n          termDocs.seek (termEnum);\n          while (termDocs.next()) {\n            retArray[termDocs.doc()] = t;\n          }\n\n          t++;\n        } while (termEnum.next());\n      } finally {\n        termDocs.close();\n        termEnum.close();\n      }\n\n      if (t == 0) {\n        // if there are no terms, make the term array\n        // have a single null entry\n        mterms = new String[1];\n      } else if (t < mterms.length) {\n        // if there are less terms than documents,\n        // trim off the dead array space\n        String[] terms = new String[t];\n        System.arraycopy (mterms, 0, terms, 0, t);\n        mterms = terms;\n      }\n\n      StringIndex value = new StringIndex (retArray, mterms);\n      return value;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"955c32f886db6f6356c9fcdea6b1f1cb4effda24","date":1270581567,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/FieldCacheImpl.StringIndexCache#createValue(IndexReader,Entry).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FieldCacheImpl.StringIndexCache#createValue(IndexReader,Entry).mjava","sourceNew":"    @Override\n    protected Object createValue(IndexReader reader, Entry entryKey)\n        throws IOException {\n      String field = StringHelper.intern(entryKey.field);\n      final int[] retArray = new int[reader.maxDoc()];\n      String[] mterms = new String[reader.maxDoc()+1];\n\n      //System.out.println(\"FC: getStringIndex field=\" + field);\n      Terms terms = MultiFields.getTerms(reader, field);\n\n      int t = 0;  // current term number\n\n      // an entry for documents that have no terms in this field\n      // should a document with no terms be at top or bottom?\n      // this puts them at the top - if it is changed, FieldDocSortedHitQueue\n      // needs to change as well.\n      mterms[t++] = null;\n\n      if (terms != null) {\n        final TermsEnum termsEnum = terms.iterator();\n        final Bits delDocs = MultiFields.getDeletedDocs(reader);\n        DocsEnum docs = null;\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n\n          // store term text\n          mterms[t] = term.utf8ToString();\n          //System.out.println(\"FC:  ord=\" + t + \" term=\" + term.toBytesString());\n\n          docs = termsEnum.docs(delDocs, docs);\n          while (true) {\n            final int docID = docs.nextDoc();\n            if (docID == DocsEnum.NO_MORE_DOCS) {\n              break;\n            }\n            //System.out.println(\"FC:    docID=\" + docID);\n            retArray[docID] = t;\n          }\n          t++;\n        }\n      }\n\n      if (t == 0) {\n        // if there are no terms, make the term array\n        // have a single null entry\n        mterms = new String[1];\n      } else if (t < mterms.length) {\n        // if there are less terms than documents,\n        // trim off the dead array space\n        String[] newTerms = new String[t];\n        System.arraycopy (mterms, 0, newTerms, 0, t);\n        mterms = newTerms;\n      }\n\n      StringIndex value = new StringIndex (retArray, mterms);\n      //System.out.println(\"FC: done\\n\");\n      return value;\n    }\n\n","sourceOld":"    @Override\n    protected Object createValue(IndexReader reader, Entry entryKey)\n        throws IOException {\n      String field = StringHelper.intern(entryKey.field);\n      final int[] retArray = new int[reader.maxDoc()];\n      String[] mterms = new String[reader.maxDoc()+1];\n      TermDocs termDocs = reader.termDocs();\n      TermEnum termEnum = reader.terms (new Term (field));\n      int t = 0;  // current term number\n\n      // an entry for documents that have no terms in this field\n      // should a document with no terms be at top or bottom?\n      // this puts them at the top - if it is changed, FieldDocSortedHitQueue\n      // needs to change as well.\n      mterms[t++] = null;\n\n      try {\n        do {\n          Term term = termEnum.term();\n          if (term==null || term.field() != field) break;\n\n          // store term text\n          mterms[t] = term.text();\n\n          termDocs.seek (termEnum);\n          while (termDocs.next()) {\n            retArray[termDocs.doc()] = t;\n          }\n\n          t++;\n        } while (termEnum.next());\n      } finally {\n        termDocs.close();\n        termEnum.close();\n      }\n\n      if (t == 0) {\n        // if there are no terms, make the term array\n        // have a single null entry\n        mterms = new String[1];\n      } else if (t < mterms.length) {\n        // if there are less terms than documents,\n        // trim off the dead array space\n        String[] terms = new String[t];\n        System.arraycopy (mterms, 0, terms, 0, t);\n        mterms = terms;\n      }\n\n      StringIndex value = new StringIndex (retArray, mterms);\n      return value;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"be20f9fed1d3edcb1c84abcc39df87a90fab22df","date":1275590285,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/search/FieldCacheImpl.StringIndexCache#createValue(IndexReader,Entry).mjava","sourceNew":null,"sourceOld":"    @Override\n    protected Object createValue(IndexReader reader, Entry entryKey)\n        throws IOException {\n      String field = StringHelper.intern(entryKey.field);\n      final int[] retArray = new int[reader.maxDoc()];\n      String[] mterms = new String[reader.maxDoc()+1];\n\n      //System.out.println(\"FC: getStringIndex field=\" + field);\n      Terms terms = MultiFields.getTerms(reader, field);\n\n      int t = 0;  // current term number\n\n      // an entry for documents that have no terms in this field\n      // should a document with no terms be at top or bottom?\n      // this puts them at the top - if it is changed, FieldDocSortedHitQueue\n      // needs to change as well.\n      mterms[t++] = null;\n\n      if (terms != null) {\n        final TermsEnum termsEnum = terms.iterator();\n        final Bits delDocs = MultiFields.getDeletedDocs(reader);\n        DocsEnum docs = null;\n        while(true) {\n          final BytesRef term = termsEnum.next();\n          if (term == null) {\n            break;\n          }\n\n          // store term text\n          mterms[t] = term.utf8ToString();\n          //System.out.println(\"FC:  ord=\" + t + \" term=\" + term.toBytesString());\n\n          docs = termsEnum.docs(delDocs, docs);\n          while (true) {\n            final int docID = docs.nextDoc();\n            if (docID == DocsEnum.NO_MORE_DOCS) {\n              break;\n            }\n            //System.out.println(\"FC:    docID=\" + docID);\n            retArray[docID] = t;\n          }\n          t++;\n        }\n      }\n\n      if (t == 0) {\n        // if there are no terms, make the term array\n        // have a single null entry\n        mterms = new String[1];\n      } else if (t < mterms.length) {\n        // if there are less terms than documents,\n        // trim off the dead array space\n        String[] newTerms = new String[t];\n        System.arraycopy (mterms, 0, newTerms, 0, t);\n        mterms = newTerms;\n      }\n\n      StringIndex value = new StringIndex (retArray, mterms);\n      //System.out.println(\"FC: done\\n\");\n      return value;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"be20f9fed1d3edcb1c84abcc39df87a90fab22df":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["be20f9fed1d3edcb1c84abcc39df87a90fab22df"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"be20f9fed1d3edcb1c84abcc39df87a90fab22df":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["be20f9fed1d3edcb1c84abcc39df87a90fab22df"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}