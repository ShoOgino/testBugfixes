{"path":"lucene/src/java/org/apache/lucene/index/IndexWriter#createCompoundFile(Directory,String,CheckAbort,SegmentInfo,IOContext).mjava","commits":[{"id":"3cc749c053615f5871f3b95715fe292f34e70a53","date":1321470575,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#createCompoundFile(Directory,String,CheckAbort,SegmentInfo,IOContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentMerger#createCompoundFile(String,SegmentInfo,IOContext).mjava","sourceNew":"  /**\n   * NOTE: this method creates a compound file for all files returned by\n   * info.files(). While, generally, this may include separate norms and\n   * deletion files, this SegmentInfo must not reference such files when this\n   * method is called, because they are not allowed within a compound file.\n   */\n  static final Collection<String> createCompoundFile(Directory directory, String fileName, CheckAbort checkAbort, final SegmentInfo info, IOContext context)\n          throws IOException {\n\n    // Now merge all added files\n    Collection<String> files = info.files();\n    CompoundFileDirectory cfsDir = new CompoundFileDirectory(directory, fileName, context, true);\n    try {\n      for (String file : files) {\n        assert !IndexFileNames.matchesExtension(file, IndexFileNames.DELETES_EXTENSION) \n                  : \".del file is not allowed in .cfs: \" + file;\n        assert !IndexFileNames.isSeparateNormsFile(file) \n                  : \"separate norms file (.s[0-9]+) is not allowed in .cfs: \" + file;\n        directory.copy(cfsDir, file, file, context);\n        checkAbort.work(directory.fileLength(file));\n      }\n    } finally {\n      cfsDir.close();\n    }\n\n    return files;\n  }\n\n","sourceOld":"  /**\n   * NOTE: this method creates a compound file for all files returned by\n   * info.files(). While, generally, this may include separate norms and\n   * deletion files, this SegmentInfo must not reference such files when this\n   * method is called, because they are not allowed within a compound file.\n   */\n  final Collection<String> createCompoundFile(String fileName, final SegmentInfo info, IOContext context)\n          throws IOException {\n\n    // Now merge all added files\n    Collection<String> files = info.files();\n    CompoundFileDirectory cfsDir = new CompoundFileDirectory(directory, fileName, context, true);\n    try {\n      for (String file : files) {\n        assert !IndexFileNames.matchesExtension(file, IndexFileNames.DELETES_EXTENSION) \n                  : \".del file is not allowed in .cfs: \" + file;\n        assert !IndexFileNames.isSeparateNormsFile(file) \n                  : \"separate norms file (.s[0-9]+) is not allowed in .cfs: \" + file;\n        directory.copy(cfsDir, file, file, context);\n        mergeState.checkAbort.work(directory.fileLength(file));\n      }\n    } finally {\n      cfsDir.close();\n    }\n\n    return files;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae7b1abd869bbf7d8ae72b0e7ae3852b363bb074","date":1323052749,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#createCompoundFile(Directory,String,CheckAbort,SegmentInfo,IOContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#createCompoundFile(Directory,String,CheckAbort,SegmentInfo,IOContext).mjava","sourceNew":"  /**\n   * NOTE: this method creates a compound file for all files returned by\n   * info.files(). While, generally, this may include separate norms and\n   * deletion files, this SegmentInfo must not reference such files when this\n   * method is called, because they are not allowed within a compound file.\n   */\n  static final Collection<String> createCompoundFile(Directory directory, String fileName, CheckAbort checkAbort, final SegmentInfo info, IOContext context)\n          throws IOException {\n\n    // Now merge all added files\n    Collection<String> files = info.files();\n    CompoundFileDirectory cfsDir = new CompoundFileDirectory(directory, fileName, context, true);\n    try {\n      for (String file : files) {\n        assert !IndexFileNames.matchesExtension(file, IndexFileNames.DELETES_EXTENSION) \n                  : \".del file is not allowed in .cfs: \" + file;\n        assert !isSeparateNormsFile(file) \n                  : \"separate norms file (.s[0-9]+) is not allowed in .cfs: \" + file;\n        directory.copy(cfsDir, file, file, context);\n        checkAbort.work(directory.fileLength(file));\n      }\n    } finally {\n      cfsDir.close();\n    }\n\n    return files;\n  }\n\n","sourceOld":"  /**\n   * NOTE: this method creates a compound file for all files returned by\n   * info.files(). While, generally, this may include separate norms and\n   * deletion files, this SegmentInfo must not reference such files when this\n   * method is called, because they are not allowed within a compound file.\n   */\n  static final Collection<String> createCompoundFile(Directory directory, String fileName, CheckAbort checkAbort, final SegmentInfo info, IOContext context)\n          throws IOException {\n\n    // Now merge all added files\n    Collection<String> files = info.files();\n    CompoundFileDirectory cfsDir = new CompoundFileDirectory(directory, fileName, context, true);\n    try {\n      for (String file : files) {\n        assert !IndexFileNames.matchesExtension(file, IndexFileNames.DELETES_EXTENSION) \n                  : \".del file is not allowed in .cfs: \" + file;\n        assert !IndexFileNames.isSeparateNormsFile(file) \n                  : \"separate norms file (.s[0-9]+) is not allowed in .cfs: \" + file;\n        directory.copy(cfsDir, file, file, context);\n        checkAbort.work(directory.fileLength(file));\n      }\n    } finally {\n      cfsDir.close();\n    }\n\n    return files;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3615ce4a1f785ae1b779244de52c6a7d99227e60","date":1323422019,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#createCompoundFile(Directory,String,CheckAbort,SegmentInfo,IOContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#createCompoundFile(Directory,String,CheckAbort,SegmentInfo,IOContext).mjava","sourceNew":"  /**\n   * NOTE: this method creates a compound file for all files returned by\n   * info.files(). While, generally, this may include separate norms and\n   * deletion files, this SegmentInfo must not reference such files when this\n   * method is called, because they are not allowed within a compound file.\n   */\n  static final Collection<String> createCompoundFile(Directory directory, String fileName, CheckAbort checkAbort, final SegmentInfo info, IOContext context)\n          throws IOException {\n\n    // Now merge all added files\n    Collection<String> files = info.files();\n    CompoundFileDirectory cfsDir = new CompoundFileDirectory(directory, fileName, context, true);\n    try {\n      for (String file : files) {\n        assert !IndexFileNames.matchesExtension(file, IndexFileNames.DELETES_EXTENSION) \n                  : \".del file is not allowed in .cfs: \" + file;\n        assert !isSeparateNormsFile(file) \n                  : \"separate norms file (.s[0-9]+) is not allowed in .cfs: \" + file;\n        directory.copy(cfsDir, file, file, context);\n        checkAbort.work(directory.fileLength(file));\n      }\n    } finally {\n      cfsDir.close();\n    }\n\n    return files;\n  }\n\n","sourceOld":"  /**\n   * NOTE: this method creates a compound file for all files returned by\n   * info.files(). While, generally, this may include separate norms and\n   * deletion files, this SegmentInfo must not reference such files when this\n   * method is called, because they are not allowed within a compound file.\n   */\n  static final Collection<String> createCompoundFile(Directory directory, String fileName, CheckAbort checkAbort, final SegmentInfo info, IOContext context)\n          throws IOException {\n\n    // Now merge all added files\n    Collection<String> files = info.files();\n    CompoundFileDirectory cfsDir = new CompoundFileDirectory(directory, fileName, context, true);\n    try {\n      for (String file : files) {\n        assert !IndexFileNames.matchesExtension(file, IndexFileNames.DELETES_EXTENSION) \n                  : \".del file is not allowed in .cfs: \" + file;\n        assert !IndexFileNames.isSeparateNormsFile(file) \n                  : \"separate norms file (.s[0-9]+) is not allowed in .cfs: \" + file;\n        directory.copy(cfsDir, file, file, context);\n        checkAbort.work(directory.fileLength(file));\n      }\n    } finally {\n      cfsDir.close();\n    }\n\n    return files;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00","date":1323437438,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#createCompoundFile(Directory,String,CheckAbort,SegmentInfo,IOContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#createCompoundFile(Directory,String,CheckAbort,SegmentInfo,IOContext).mjava","sourceNew":"  /**\n   * NOTE: this method creates a compound file for all files returned by\n   * info.files(). While, generally, this may include separate norms and\n   * deletion files, this SegmentInfo must not reference such files when this\n   * method is called, because they are not allowed within a compound file.\n   */\n  static final Collection<String> createCompoundFile(Directory directory, String fileName, CheckAbort checkAbort, final SegmentInfo info, IOContext context)\n          throws IOException {\n\n    // Now merge all added files\n    Collection<String> files = info.files();\n    CompoundFileDirectory cfsDir = new CompoundFileDirectory(directory, fileName, context, true);\n    try {\n      for (String file : files) {\n        assert !IndexFileNames.matchesExtension(file, IndexFileNames.DELETES_EXTENSION) \n                  : \".del file is not allowed in .cfs: \" + file;\n        assert !isSeparateNormsFile(file) \n                  : \"separate norms file (.s[0-9]+) is not allowed in .cfs: \" + file;\n        directory.copy(cfsDir, file, file, context);\n        checkAbort.work(directory.fileLength(file));\n      }\n    } finally {\n      cfsDir.close();\n    }\n\n    return files;\n  }\n\n","sourceOld":"  /**\n   * NOTE: this method creates a compound file for all files returned by\n   * info.files(). While, generally, this may include separate norms and\n   * deletion files, this SegmentInfo must not reference such files when this\n   * method is called, because they are not allowed within a compound file.\n   */\n  static final Collection<String> createCompoundFile(Directory directory, String fileName, CheckAbort checkAbort, final SegmentInfo info, IOContext context)\n          throws IOException {\n\n    // Now merge all added files\n    Collection<String> files = info.files();\n    CompoundFileDirectory cfsDir = new CompoundFileDirectory(directory, fileName, context, true);\n    try {\n      for (String file : files) {\n        assert !IndexFileNames.matchesExtension(file, IndexFileNames.DELETES_EXTENSION) \n                  : \".del file is not allowed in .cfs: \" + file;\n        assert !IndexFileNames.isSeparateNormsFile(file) \n                  : \"separate norms file (.s[0-9]+) is not allowed in .cfs: \" + file;\n        directory.copy(cfsDir, file, file, context);\n        checkAbort.work(directory.fileLength(file));\n      }\n    } finally {\n      cfsDir.close();\n    }\n\n    return files;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ee7817a665237cb0657ed2bd7ae2a2b91ce6aaf9","date":1327025939,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#createCompoundFile(Directory,String,CheckAbort,SegmentInfo,IOContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#createCompoundFile(Directory,String,CheckAbort,SegmentInfo,IOContext).mjava","sourceNew":"  /**\n   * NOTE: this method creates a compound file for all files returned by\n   * info.files(). While, generally, this may include separate norms and\n   * deletion files, this SegmentInfo must not reference such files when this\n   * method is called, because they are not allowed within a compound file.\n   */\n  static final Collection<String> createCompoundFile(Directory directory, String fileName, CheckAbort checkAbort, final SegmentInfo info, IOContext context)\n          throws IOException {\n\n    // Now merge all added files\n    Collection<String> files = info.files();\n    CompoundFileDirectory cfsDir = new CompoundFileDirectory(directory, fileName, context, true);\n    try {\n      assert assertNoSeparateFiles(files, directory, info);\n      for (String file : files) {\n        directory.copy(cfsDir, file, file, context);\n        checkAbort.work(directory.fileLength(file));\n      }\n    } finally {\n      cfsDir.close();\n    }\n\n    return files;\n  }\n\n","sourceOld":"  /**\n   * NOTE: this method creates a compound file for all files returned by\n   * info.files(). While, generally, this may include separate norms and\n   * deletion files, this SegmentInfo must not reference such files when this\n   * method is called, because they are not allowed within a compound file.\n   */\n  static final Collection<String> createCompoundFile(Directory directory, String fileName, CheckAbort checkAbort, final SegmentInfo info, IOContext context)\n          throws IOException {\n\n    // Now merge all added files\n    Collection<String> files = info.files();\n    CompoundFileDirectory cfsDir = new CompoundFileDirectory(directory, fileName, context, true);\n    try {\n      for (String file : files) {\n        assert !IndexFileNames.matchesExtension(file, IndexFileNames.DELETES_EXTENSION) \n                  : \".del file is not allowed in .cfs: \" + file;\n        assert !isSeparateNormsFile(file) \n                  : \"separate norms file (.s[0-9]+) is not allowed in .cfs: \" + file;\n        directory.copy(cfsDir, file, file, context);\n        checkAbort.work(directory.fileLength(file));\n      }\n    } finally {\n      cfsDir.close();\n    }\n\n    return files;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9f2d6bb11ccaac366d9b7652b2feb0c715d9c31","date":1327836826,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#createCompoundFile(Directory,String,CheckAbort,SegmentInfo,IOContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#createCompoundFile(Directory,String,CheckAbort,SegmentInfo,IOContext).mjava","sourceNew":"  /**\n   * NOTE: this method creates a compound file for all files returned by\n   * info.files(). While, generally, this may include separate norms and\n   * deletion files, this SegmentInfo must not reference such files when this\n   * method is called, because they are not allowed within a compound file.\n   */\n  static final Collection<String> createCompoundFile(Directory directory, String fileName, CheckAbort checkAbort, final SegmentInfo info, IOContext context)\n          throws IOException {\n\n    // Now merge all added files\n    Collection<String> files = info.files();\n    CompoundFileDirectory cfsDir = new CompoundFileDirectory(directory, fileName, context, true);\n    try {\n      assert assertNoSeparateFiles(files, directory, info);\n      for (String file : files) {\n        directory.copy(cfsDir, file, file, context);\n        checkAbort.work(directory.fileLength(file));\n      }\n    } finally {\n      cfsDir.close();\n    }\n\n    return files;\n  }\n\n","sourceOld":"  /**\n   * NOTE: this method creates a compound file for all files returned by\n   * info.files(). While, generally, this may include separate norms and\n   * deletion files, this SegmentInfo must not reference such files when this\n   * method is called, because they are not allowed within a compound file.\n   */\n  static final Collection<String> createCompoundFile(Directory directory, String fileName, CheckAbort checkAbort, final SegmentInfo info, IOContext context)\n          throws IOException {\n\n    // Now merge all added files\n    Collection<String> files = info.files();\n    CompoundFileDirectory cfsDir = new CompoundFileDirectory(directory, fileName, context, true);\n    try {\n      for (String file : files) {\n        assert !IndexFileNames.matchesExtension(file, IndexFileNames.DELETES_EXTENSION) \n                  : \".del file is not allowed in .cfs: \" + file;\n        assert !isSeparateNormsFile(file) \n                  : \"separate norms file (.s[0-9]+) is not allowed in .cfs: \" + file;\n        directory.copy(cfsDir, file, file, context);\n        checkAbort.work(directory.fileLength(file));\n      }\n    } finally {\n      cfsDir.close();\n    }\n\n    return files;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fd92b8bcc88e969302510acf77bd6970da3994c4","date":1327839530,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#createCompoundFile(Directory,String,CheckAbort,SegmentInfo,IOContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#createCompoundFile(Directory,String,CheckAbort,SegmentInfo,IOContext).mjava","sourceNew":"  /**\n   * NOTE: this method creates a compound file for all files returned by\n   * info.files(). While, generally, this may include separate norms and\n   * deletion files, this SegmentInfo must not reference such files when this\n   * method is called, because they are not allowed within a compound file.\n   */\n  static final Collection<String> createCompoundFile(Directory directory, String fileName, CheckAbort checkAbort, final SegmentInfo info, IOContext context)\n          throws IOException {\n\n    // Now merge all added files\n    Collection<String> files = info.files();\n    CompoundFileDirectory cfsDir = new CompoundFileDirectory(directory, fileName, context, true);\n    try {\n      assert assertNoSeparateFiles(files, directory, info);\n      for (String file : files) {\n        directory.copy(cfsDir, file, file, context);\n        checkAbort.work(directory.fileLength(file));\n      }\n    } finally {\n      cfsDir.close();\n    }\n\n    return files;\n  }\n\n","sourceOld":"  /**\n   * NOTE: this method creates a compound file for all files returned by\n   * info.files(). While, generally, this may include separate norms and\n   * deletion files, this SegmentInfo must not reference such files when this\n   * method is called, because they are not allowed within a compound file.\n   */\n  static final Collection<String> createCompoundFile(Directory directory, String fileName, CheckAbort checkAbort, final SegmentInfo info, IOContext context)\n          throws IOException {\n\n    // Now merge all added files\n    Collection<String> files = info.files();\n    CompoundFileDirectory cfsDir = new CompoundFileDirectory(directory, fileName, context, true);\n    try {\n      for (String file : files) {\n        assert !IndexFileNames.matchesExtension(file, IndexFileNames.DELETES_EXTENSION) \n                  : \".del file is not allowed in .cfs: \" + file;\n        assert !isSeparateNormsFile(file) \n                  : \"separate norms file (.s[0-9]+) is not allowed in .cfs: \" + file;\n        directory.copy(cfsDir, file, file, context);\n        checkAbort.work(directory.fileLength(file));\n      }\n    } finally {\n      cfsDir.close();\n    }\n\n    return files;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"be9e3e7d2fc880996ffcfe9a8fc47057b647e9e3","date":1327944832,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#createCompoundFile(Directory,String,CheckAbort,SegmentInfo,IOContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#createCompoundFile(Directory,String,CheckAbort,SegmentInfo,IOContext).mjava","sourceNew":"  /**\n   * NOTE: this method creates a compound file for all files returned by\n   * info.files(). While, generally, this may include separate norms and\n   * deletion files, this SegmentInfo must not reference such files when this\n   * method is called, because they are not allowed within a compound file.\n   */\n  static final Collection<String> createCompoundFile(Directory directory, String fileName, CheckAbort checkAbort, final SegmentInfo info, IOContext context)\n          throws IOException {\n    assert info.getDocStoreOffset() == -1;\n    // Now merge all added files\n    Collection<String> files = info.files();\n    CompoundFileDirectory cfsDir = new CompoundFileDirectory(directory, fileName, context, true);\n    try {\n      // nocommit: we could make a crappy regex like before...\n      // assert assertNoSeparateFiles(files, directory, info);\n      for (String file : files) {\n        directory.copy(cfsDir, file, file, context);\n        checkAbort.work(directory.fileLength(file));\n      }\n    } finally {\n      cfsDir.close();\n    }\n\n    return files;\n  }\n\n","sourceOld":"  /**\n   * NOTE: this method creates a compound file for all files returned by\n   * info.files(). While, generally, this may include separate norms and\n   * deletion files, this SegmentInfo must not reference such files when this\n   * method is called, because they are not allowed within a compound file.\n   */\n  static final Collection<String> createCompoundFile(Directory directory, String fileName, CheckAbort checkAbort, final SegmentInfo info, IOContext context)\n          throws IOException {\n\n    // Now merge all added files\n    Collection<String> files = info.files();\n    CompoundFileDirectory cfsDir = new CompoundFileDirectory(directory, fileName, context, true);\n    try {\n      assert assertNoSeparateFiles(files, directory, info);\n      for (String file : files) {\n        directory.copy(cfsDir, file, file, context);\n        checkAbort.work(directory.fileLength(file));\n      }\n    } finally {\n      cfsDir.close();\n    }\n\n    return files;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"122efe6336951966ccae14c860899b9f26882bd3","date":1327945037,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#createCompoundFile(Directory,String,CheckAbort,SegmentInfo,IOContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#createCompoundFile(Directory,String,CheckAbort,SegmentInfo,IOContext).mjava","sourceNew":"  /**\n   * NOTE: this method creates a compound file for all files returned by\n   * info.files(). While, generally, this may include separate norms and\n   * deletion files, this SegmentInfo must not reference such files when this\n   * method is called, because they are not allowed within a compound file.\n   */\n  static final Collection<String> createCompoundFile(Directory directory, String fileName, CheckAbort checkAbort, final SegmentInfo info, IOContext context)\n          throws IOException {\n    assert info.getDocStoreOffset() == -1;\n    // Now merge all added files\n    Collection<String> files = info.files();\n    CompoundFileDirectory cfsDir = new CompoundFileDirectory(directory, fileName, context, true);\n    try {\n      for (String file : files) {\n        directory.copy(cfsDir, file, file, context);\n        checkAbort.work(directory.fileLength(file));\n      }\n    } finally {\n      cfsDir.close();\n    }\n\n    return files;\n  }\n\n","sourceOld":"  /**\n   * NOTE: this method creates a compound file for all files returned by\n   * info.files(). While, generally, this may include separate norms and\n   * deletion files, this SegmentInfo must not reference such files when this\n   * method is called, because they are not allowed within a compound file.\n   */\n  static final Collection<String> createCompoundFile(Directory directory, String fileName, CheckAbort checkAbort, final SegmentInfo info, IOContext context)\n          throws IOException {\n    assert info.getDocStoreOffset() == -1;\n    // Now merge all added files\n    Collection<String> files = info.files();\n    CompoundFileDirectory cfsDir = new CompoundFileDirectory(directory, fileName, context, true);\n    try {\n      // nocommit: we could make a crappy regex like before...\n      // assert assertNoSeparateFiles(files, directory, info);\n      for (String file : files) {\n        directory.copy(cfsDir, file, file, context);\n        checkAbort.work(directory.fileLength(file));\n      }\n    } finally {\n      cfsDir.close();\n    }\n\n    return files;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"296df632fd63421ea20756fa11ad36fbc6f4c8a9","date":1327957998,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#createCompoundFile(Directory,String,CheckAbort,SegmentInfo,IOContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#createCompoundFile(Directory,String,CheckAbort,SegmentInfo,IOContext).mjava","sourceNew":"  /**\n   * NOTE: this method creates a compound file for all files returned by\n   * info.files(). While, generally, this may include separate norms and\n   * deletion files, this SegmentInfo must not reference such files when this\n   * method is called, because they are not allowed within a compound file.\n   */\n  static final Collection<String> createCompoundFile(Directory directory, String fileName, CheckAbort checkAbort, final SegmentInfo info, IOContext context)\n          throws IOException {\n    assert info.getDocStoreOffset() == -1;\n    // Now merge all added files\n    Collection<String> files = info.files();\n    CompoundFileDirectory cfsDir = new CompoundFileDirectory(directory, fileName, context, true);\n    try {\n      for (String file : files) {\n        directory.copy(cfsDir, file, file, context);\n        checkAbort.work(directory.fileLength(file));\n      }\n    } finally {\n      cfsDir.close();\n    }\n\n    return files;\n  }\n\n","sourceOld":"  /**\n   * NOTE: this method creates a compound file for all files returned by\n   * info.files(). While, generally, this may include separate norms and\n   * deletion files, this SegmentInfo must not reference such files when this\n   * method is called, because they are not allowed within a compound file.\n   */\n  static final Collection<String> createCompoundFile(Directory directory, String fileName, CheckAbort checkAbort, final SegmentInfo info, IOContext context)\n          throws IOException {\n\n    // Now merge all added files\n    Collection<String> files = info.files();\n    CompoundFileDirectory cfsDir = new CompoundFileDirectory(directory, fileName, context, true);\n    try {\n      assert assertNoSeparateFiles(files, directory, info);\n      for (String file : files) {\n        directory.copy(cfsDir, file, file, context);\n        checkAbort.work(directory.fileLength(file));\n      }\n    } finally {\n      cfsDir.close();\n    }\n\n    return files;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"410e066f093e407222d9681429d209084e783149","date":1327958394,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#createCompoundFile(Directory,String,CheckAbort,SegmentInfo,IOContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#createCompoundFile(Directory,String,CheckAbort,SegmentInfo,IOContext).mjava","sourceNew":"  /**\n   * NOTE: this method creates a compound file for all files returned by\n   * info.files(). While, generally, this may include separate norms and\n   * deletion files, this SegmentInfo must not reference such files when this\n   * method is called, because they are not allowed within a compound file.\n   */\n  static final Collection<String> createCompoundFile(Directory directory, String fileName, CheckAbort checkAbort, final SegmentInfo info, IOContext context)\n          throws IOException {\n    assert info.getDocStoreOffset() == -1;\n    // Now merge all added files\n    Collection<String> files = info.files();\n    CompoundFileDirectory cfsDir = new CompoundFileDirectory(directory, fileName, context, true);\n    try {\n      for (String file : files) {\n        directory.copy(cfsDir, file, file, context);\n        checkAbort.work(directory.fileLength(file));\n      }\n    } finally {\n      cfsDir.close();\n    }\n\n    return files;\n  }\n\n","sourceOld":"  /**\n   * NOTE: this method creates a compound file for all files returned by\n   * info.files(). While, generally, this may include separate norms and\n   * deletion files, this SegmentInfo must not reference such files when this\n   * method is called, because they are not allowed within a compound file.\n   */\n  static final Collection<String> createCompoundFile(Directory directory, String fileName, CheckAbort checkAbort, final SegmentInfo info, IOContext context)\n          throws IOException {\n\n    // Now merge all added files\n    Collection<String> files = info.files();\n    CompoundFileDirectory cfsDir = new CompoundFileDirectory(directory, fileName, context, true);\n    try {\n      assert assertNoSeparateFiles(files, directory, info);\n      for (String file : files) {\n        directory.copy(cfsDir, file, file, context);\n        checkAbort.work(directory.fileLength(file));\n      }\n    } finally {\n      cfsDir.close();\n    }\n\n    return files;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#createCompoundFile(Directory,String,CheckAbort,SegmentInfo,IOContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#createCompoundFile(Directory,String,CheckAbort,SegmentInfo,IOContext).mjava","sourceNew":"  /**\n   * NOTE: this method creates a compound file for all files returned by\n   * info.files(). While, generally, this may include separate norms and\n   * deletion files, this SegmentInfo must not reference such files when this\n   * method is called, because they are not allowed within a compound file.\n   */\n  static final Collection<String> createCompoundFile(Directory directory, String fileName, CheckAbort checkAbort, final SegmentInfo info, IOContext context)\n          throws IOException {\n    assert info.getDocStoreOffset() == -1;\n    // Now merge all added files\n    Collection<String> files = info.files();\n    CompoundFileDirectory cfsDir = new CompoundFileDirectory(directory, fileName, context, true);\n    try {\n      for (String file : files) {\n        directory.copy(cfsDir, file, file, context);\n        checkAbort.work(directory.fileLength(file));\n      }\n    } finally {\n      cfsDir.close();\n    }\n\n    return files;\n  }\n\n","sourceOld":"  /**\n   * NOTE: this method creates a compound file for all files returned by\n   * info.files(). While, generally, this may include separate norms and\n   * deletion files, this SegmentInfo must not reference such files when this\n   * method is called, because they are not allowed within a compound file.\n   */\n  static final Collection<String> createCompoundFile(Directory directory, String fileName, CheckAbort checkAbort, final SegmentInfo info, IOContext context)\n          throws IOException {\n    assert info.getDocStoreOffset() == -1;\n    // Now merge all added files\n    Collection<String> files = info.files();\n    CompoundFileDirectory cfsDir = new CompoundFileDirectory(directory, fileName, context, true);\n    try {\n      for (String file : files) {\n        directory.copy(cfsDir, file, file, context);\n        checkAbort.work(directory.fileLength(file));\n      }\n    } finally {\n      cfsDir.close();\n    }\n\n    return files;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ee7817a665237cb0657ed2bd7ae2a2b91ce6aaf9":["3615ce4a1f785ae1b779244de52c6a7d99227e60"],"410e066f093e407222d9681429d209084e783149":["fd92b8bcc88e969302510acf77bd6970da3994c4","296df632fd63421ea20756fa11ad36fbc6f4c8a9"],"ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00":["3cc749c053615f5871f3b95715fe292f34e70a53","3615ce4a1f785ae1b779244de52c6a7d99227e60"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["296df632fd63421ea20756fa11ad36fbc6f4c8a9"],"122efe6336951966ccae14c860899b9f26882bd3":["be9e3e7d2fc880996ffcfe9a8fc47057b647e9e3"],"fd92b8bcc88e969302510acf77bd6970da3994c4":["3615ce4a1f785ae1b779244de52c6a7d99227e60","c9f2d6bb11ccaac366d9b7652b2feb0c715d9c31"],"3cc749c053615f5871f3b95715fe292f34e70a53":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"296df632fd63421ea20756fa11ad36fbc6f4c8a9":["c9f2d6bb11ccaac366d9b7652b2feb0c715d9c31","122efe6336951966ccae14c860899b9f26882bd3"],"be9e3e7d2fc880996ffcfe9a8fc47057b647e9e3":["ee7817a665237cb0657ed2bd7ae2a2b91ce6aaf9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3615ce4a1f785ae1b779244de52c6a7d99227e60":["3cc749c053615f5871f3b95715fe292f34e70a53","ae7b1abd869bbf7d8ae72b0e7ae3852b363bb074"],"ae7b1abd869bbf7d8ae72b0e7ae3852b363bb074":["3cc749c053615f5871f3b95715fe292f34e70a53"],"c9f2d6bb11ccaac366d9b7652b2feb0c715d9c31":["3615ce4a1f785ae1b779244de52c6a7d99227e60","ee7817a665237cb0657ed2bd7ae2a2b91ce6aaf9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"ee7817a665237cb0657ed2bd7ae2a2b91ce6aaf9":["be9e3e7d2fc880996ffcfe9a8fc47057b647e9e3","c9f2d6bb11ccaac366d9b7652b2feb0c715d9c31"],"410e066f093e407222d9681429d209084e783149":[],"ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00":[],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"122efe6336951966ccae14c860899b9f26882bd3":["296df632fd63421ea20756fa11ad36fbc6f4c8a9"],"fd92b8bcc88e969302510acf77bd6970da3994c4":["410e066f093e407222d9681429d209084e783149"],"3cc749c053615f5871f3b95715fe292f34e70a53":["ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00","3615ce4a1f785ae1b779244de52c6a7d99227e60","ae7b1abd869bbf7d8ae72b0e7ae3852b363bb074"],"296df632fd63421ea20756fa11ad36fbc6f4c8a9":["410e066f093e407222d9681429d209084e783149","3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"be9e3e7d2fc880996ffcfe9a8fc47057b647e9e3":["122efe6336951966ccae14c860899b9f26882bd3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3cc749c053615f5871f3b95715fe292f34e70a53"],"3615ce4a1f785ae1b779244de52c6a7d99227e60":["ee7817a665237cb0657ed2bd7ae2a2b91ce6aaf9","ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00","fd92b8bcc88e969302510acf77bd6970da3994c4","c9f2d6bb11ccaac366d9b7652b2feb0c715d9c31"],"ae7b1abd869bbf7d8ae72b0e7ae3852b363bb074":["3615ce4a1f785ae1b779244de52c6a7d99227e60"],"c9f2d6bb11ccaac366d9b7652b2feb0c715d9c31":["fd92b8bcc88e969302510acf77bd6970da3994c4","296df632fd63421ea20756fa11ad36fbc6f4c8a9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["410e066f093e407222d9681429d209084e783149","ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}