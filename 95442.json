{"path":"src/test/org/apache/lucene/store/TestHugeRamFile#testHugeFile().mjava","commits":[{"id":"1acc0d4d75fc7ad1dae131d00a9ffa438b257ebe","date":1184862468,"type":0,"author":"Doron Cohen","isMerge":false,"pathNew":"src/test/org/apache/lucene/store/TestHugeRamFile#testHugeFile().mjava","pathOld":"/dev/null","sourceNew":"  /** Test huge RAMFile with more than Integer.MAX_VALUE bytes. (LUCENE-957) */\n  public void testHugeFile() throws IOException {\n    DenseRAMFile f = new DenseRAMFile();\n    // output part\n    RAMOutputStream out = new RAMOutputStream(f);\n    byte b1[] = new byte[RAMOutputStream.BUFFER_SIZE];\n    byte b2[] = new byte[RAMOutputStream.BUFFER_SIZE / 3];\n    for (int i = 0; i < b1.length; i++) {\n      b1[i] = (byte) (i & 0x0007F);\n    }\n    for (int i = 0; i < b2.length; i++) {\n      b2[i] = (byte) (i & 0x0003F);\n    }\n    long n = 0;\n    assertEquals(\"output length must match\",n,out.length());\n    while (n <= MAX_VALUE - b1.length) {\n      out.writeBytes(b1,0,b1.length);\n      out.flush();\n      n += b1.length;\n      assertEquals(\"output length must match\",n,out.length());\n    }\n    //System.out.println(\"after writing b1's, length = \"+out.length()+\" (MAX_VALUE=\"+MAX_VALUE+\")\");\n    int m = b2.length;\n    long L = 12;\n    for (int j=0; j<L; j++) {\n      for (int i = 0; i < b2.length; i++) {\n        b2[i]++;\n      }\n      out.writeBytes(b2,0,m);\n      out.flush();\n      n += m;\n      assertEquals(\"output length must match\",n,out.length());\n    }\n    out.close();\n    // input part\n    RAMInputStream in = new RAMInputStream(f);\n    assertEquals(\"input length must match\",n,in.length());\n    //System.out.println(\"input length = \"+in.length()+\" % 1024 = \"+in.length()%1024);\n    for (int j=0; j<L; j++) {\n      long loc = n - (L-j)*m; \n      in.seek(loc/3);\n      in.seek(loc);\n      for (int i=0; i<m; i++) {\n        byte bt = in.readByte();\n        byte expected = (byte) (1 + j + (i & 0x0003F));\n        assertEquals(\"must read same value that was written! j=\"+j+\" i=\"+i,expected,bt);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/store/TestHugeRamFile#testHugeFile().mjava","pathOld":"src/test/org/apache/lucene/store/TestHugeRamFile#testHugeFile().mjava","sourceNew":"  /** Test huge RAMFile with more than Integer.MAX_VALUE bytes. (LUCENE-957) */\n  public void testHugeFile() throws IOException {\n    DenseRAMFile f = new DenseRAMFile();\n    // output part\n    RAMOutputStream out = new RAMOutputStream(f);\n    byte b1[] = new byte[RAMOutputStream.BUFFER_SIZE];\n    byte b2[] = new byte[RAMOutputStream.BUFFER_SIZE / 3];\n    for (int i = 0; i < b1.length; i++) {\n      b1[i] = (byte) (i & 0x0007F);\n    }\n    for (int i = 0; i < b2.length; i++) {\n      b2[i] = (byte) (i & 0x0003F);\n    }\n    long n = 0;\n    assertEquals(\"output length must match\",n,out.length());\n    while (n <= MAX_VALUE - b1.length) {\n      out.writeBytes(b1,0,b1.length);\n      out.flush();\n      n += b1.length;\n      assertEquals(\"output length must match\",n,out.length());\n    }\n    //System.out.println(\"after writing b1's, length = \"+out.length()+\" (MAX_VALUE=\"+MAX_VALUE+\")\");\n    int m = b2.length;\n    long L = 12;\n    for (int j=0; j<L; j++) {\n      for (int i = 0; i < b2.length; i++) {\n        b2[i]++;\n      }\n      out.writeBytes(b2,0,m);\n      out.flush();\n      n += m;\n      assertEquals(\"output length must match\",n,out.length());\n    }\n    out.close();\n    // input part\n    RAMInputStream in = new RAMInputStream(f);\n    assertEquals(\"input length must match\",n,in.length());\n    //System.out.println(\"input length = \"+in.length()+\" % 1024 = \"+in.length()%1024);\n    for (int j=0; j<L; j++) {\n      long loc = n - (L-j)*m; \n      in.seek(loc/3);\n      in.seek(loc);\n      for (int i=0; i<m; i++) {\n        byte bt = in.readByte();\n        byte expected = (byte) (1 + j + (i & 0x0003F));\n        assertEquals(\"must read same value that was written! j=\"+j+\" i=\"+i,expected,bt);\n      }\n    }\n  }\n\n","sourceOld":"  /** Test huge RAMFile with more than Integer.MAX_VALUE bytes. (LUCENE-957) */\n  public void testHugeFile() throws IOException {\n    DenseRAMFile f = new DenseRAMFile();\n    // output part\n    RAMOutputStream out = new RAMOutputStream(f);\n    byte b1[] = new byte[RAMOutputStream.BUFFER_SIZE];\n    byte b2[] = new byte[RAMOutputStream.BUFFER_SIZE / 3];\n    for (int i = 0; i < b1.length; i++) {\n      b1[i] = (byte) (i & 0x0007F);\n    }\n    for (int i = 0; i < b2.length; i++) {\n      b2[i] = (byte) (i & 0x0003F);\n    }\n    long n = 0;\n    assertEquals(\"output length must match\",n,out.length());\n    while (n <= MAX_VALUE - b1.length) {\n      out.writeBytes(b1,0,b1.length);\n      out.flush();\n      n += b1.length;\n      assertEquals(\"output length must match\",n,out.length());\n    }\n    //System.out.println(\"after writing b1's, length = \"+out.length()+\" (MAX_VALUE=\"+MAX_VALUE+\")\");\n    int m = b2.length;\n    long L = 12;\n    for (int j=0; j<L; j++) {\n      for (int i = 0; i < b2.length; i++) {\n        b2[i]++;\n      }\n      out.writeBytes(b2,0,m);\n      out.flush();\n      n += m;\n      assertEquals(\"output length must match\",n,out.length());\n    }\n    out.close();\n    // input part\n    RAMInputStream in = new RAMInputStream(f);\n    assertEquals(\"input length must match\",n,in.length());\n    //System.out.println(\"input length = \"+in.length()+\" % 1024 = \"+in.length()%1024);\n    for (int j=0; j<L; j++) {\n      long loc = n - (L-j)*m; \n      in.seek(loc/3);\n      in.seek(loc);\n      for (int i=0; i<m; i++) {\n        byte bt = in.readByte();\n        byte expected = (byte) (1 + j + (i & 0x0003F));\n        assertEquals(\"must read same value that was written! j=\"+j+\" i=\"+i,expected,bt);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1acc0d4d75fc7ad1dae131d00a9ffa438b257ebe":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["1acc0d4d75fc7ad1dae131d00a9ffa438b257ebe"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1acc0d4d75fc7ad1dae131d00a9ffa438b257ebe"],"1acc0d4d75fc7ad1dae131d00a9ffa438b257ebe":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}