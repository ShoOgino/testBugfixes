{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer#request(SolrRequest,ResponseParser).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer#request(SolrRequest,ResponseParser).mjava","pathOld":"solr/src/solrj/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer#request(SolrRequest,ResponseParser).mjava","sourceNew":"  public NamedList<Object> request(final SolrRequest request, ResponseParser processor) throws SolrServerException, IOException {\n    HttpMethod method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if( path == null || !path.startsWith( \"/\" ) ) {\n      path = \"/select\";\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if( parser == null ) {\n      parser = _parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original params\n    ModifiableSolrParams wparams = new ModifiableSolrParams();\n    wparams.set( CommonParams.WT, parser.getWriterType() );\n    wparams.set( CommonParams.VERSION, parser.getVersion());\n    if( params == null ) {\n      params = wparams;\n    }\n    else {\n      params = new DefaultSolrParams( wparams, params );\n    }\n    \n    if( _invariantParams != null ) {\n      params = new DefaultSolrParams( _invariantParams, params );\n    }\n\n    int tries = _maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new GetMethod( _baseURL + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = _baseURL + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            if (streams == null || isMultipart) {\n              PostMethod post = new PostMethod(url);\n              post.getParams().setContentCharset(\"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addRequestHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<Part> parts = new LinkedList<Part>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new StringPart(p, v, \"UTF-8\"));\n                    } else {\n                      post.addParameter(p, v);\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                int i = 0;\n                for (ContentStream content : streams) {\n                  final ContentStream c = content;\n\n                  String charSet = null;\n                  String transferEncoding = null;\n                  parts.add(new PartBase(c.getName(), c.getContentType(),\n                      charSet, transferEncoding) {\n                    @Override\n                    protected long lengthOfData() throws IOException {\n                      return c.getSize();\n                    }\n\n                    @Override\n                    protected void sendData(OutputStream out)\n                        throws IOException {\n                      InputStream in = c.getStream();\n                      try {\n                        IOUtils.copy(in, out);\n                      } finally {\n                        in.close();\n                      }\n                    }\n                  });\n                }\n              }\n              if (parts.size() > 0) {\n                post.setRequestEntity(new MultipartRequestEntity(parts\n                    .toArray(new Part[parts.size()]), post.getParams()));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              PostMethod post = new PostMethod(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setRequestEntity(new RequestEntity() {\n                  public long getContentLength() {\n                    return -1;\n                  }\n\n                  public String getContentType() {\n                    return contentStream[0].getContentType();\n                  }\n\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n\n                  public void writeRequest(OutputStream outputStream) throws IOException {\n                    ((RequestWriter.LazyContentStream) contentStream[0]).writeTo(outputStream);\n                  }\n                }\n                );\n\n              } else {\n                is = contentStream[0].getStream();\n                post.setRequestEntity(new InputStreamRequestEntity(is, contentStream[0].getContentType()));\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          // This is generally safe to retry on\n          method.releaseConnection();\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if( ( tries < 1 ) ) {\n            throw r;\n          }\n          //log.warn( \"Caught: \" + r + \". Retrying...\" );\n        }\n      }\n    }\n    catch( IOException ex ) {\n      throw new SolrServerException(\"error reading streams\", ex );\n    }\n\n    method.setFollowRedirects( _followRedirects );\n    method.addRequestHeader( \"User-Agent\", AGENT );\n    if( _allowCompression ) {\n      method.setRequestHeader( new Header( \"Accept-Encoding\", \"gzip,deflate\" ) );\n    }\n\n    try {\n      // Execute the method.\n      //System.out.println( \"EXECUTE:\"+method.getURI() );\n\n      int statusCode = _httpClient.executeMethod(method);\n      if (statusCode != HttpStatus.SC_OK) {\n        StringBuilder msg = new StringBuilder();\n        msg.append( method.getStatusLine().getReasonPhrase() );\n        msg.append( \"\\n\\n\" );\n        msg.append( method.getStatusText() );\n        msg.append( \"\\n\\n\" );\n        msg.append( \"request: \"+method.getURI() );\n        throw new SolrException(statusCode, java.net.URLDecoder.decode(msg.toString(), \"UTF-8\") );\n      }\n\n      // Read the contents\n      String charset = \"UTF-8\";\n      if( method instanceof HttpMethodBase ) {\n        charset = ((HttpMethodBase)method).getResponseCharSet();\n      }\n      InputStream respBody = method.getResponseBodyAsStream();\n      // Jakarta Commons HTTPClient doesn't handle any\n      // compression natively.  Handle gzip or deflate\n      // here if applicable.\n      if( _allowCompression ) {\n        Header contentEncodingHeader = method.getResponseHeader( \"Content-Encoding\" );\n        if( contentEncodingHeader != null ) {\n          String contentEncoding = contentEncodingHeader.getValue();\n          if( contentEncoding.contains( \"gzip\" ) ) {\n            //log.debug( \"wrapping response in GZIPInputStream\" );\n            respBody = new GZIPInputStream( respBody );\n          }\n          else if( contentEncoding.contains( \"deflate\" ) ) {\n            //log.debug( \"wrapping response in InflaterInputStream\" );\n            respBody = new InflaterInputStream(respBody);\n          }\n        }\n        else {\n          Header contentTypeHeader = method.getResponseHeader( \"Content-Type\" );\n          if( contentTypeHeader != null ) {\n            String contentType = contentTypeHeader.getValue();\n            if( contentType != null ) {\n              if( contentType.startsWith( \"application/x-gzip-compressed\" ) ) {\n                //log.debug( \"wrapping response in GZIPInputStream\" );\n                respBody = new GZIPInputStream( respBody );\n              }\n              else if ( contentType.startsWith(\"application/x-deflate\") ) {\n                //log.debug( \"wrapping response in InflaterInputStream\" );\n                respBody = new InflaterInputStream(respBody);\n              }\n            }\n          }\n        }\n      }\n      return processor.processResponse(respBody, charset);\n    }\n    catch (HttpException e) {\n      throw new SolrServerException( e );\n    }\n    catch (IOException e) {\n      throw new SolrServerException( e );\n    }\n    finally {\n      method.releaseConnection();\n      if(is != null) {\n        is.close();\n      }\n    }\n  }\n\n","sourceOld":"  public NamedList<Object> request(final SolrRequest request, ResponseParser processor) throws SolrServerException, IOException {\n    HttpMethod method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if( path == null || !path.startsWith( \"/\" ) ) {\n      path = \"/select\";\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if( parser == null ) {\n      parser = _parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original params\n    ModifiableSolrParams wparams = new ModifiableSolrParams();\n    wparams.set( CommonParams.WT, parser.getWriterType() );\n    wparams.set( CommonParams.VERSION, parser.getVersion());\n    if( params == null ) {\n      params = wparams;\n    }\n    else {\n      params = new DefaultSolrParams( wparams, params );\n    }\n    \n    if( _invariantParams != null ) {\n      params = new DefaultSolrParams( _invariantParams, params );\n    }\n\n    int tries = _maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new GetMethod( _baseURL + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = _baseURL + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            if (streams == null || isMultipart) {\n              PostMethod post = new PostMethod(url);\n              post.getParams().setContentCharset(\"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addRequestHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<Part> parts = new LinkedList<Part>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new StringPart(p, v, \"UTF-8\"));\n                    } else {\n                      post.addParameter(p, v);\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                int i = 0;\n                for (ContentStream content : streams) {\n                  final ContentStream c = content;\n\n                  String charSet = null;\n                  String transferEncoding = null;\n                  parts.add(new PartBase(c.getName(), c.getContentType(),\n                      charSet, transferEncoding) {\n                    @Override\n                    protected long lengthOfData() throws IOException {\n                      return c.getSize();\n                    }\n\n                    @Override\n                    protected void sendData(OutputStream out)\n                        throws IOException {\n                      InputStream in = c.getStream();\n                      try {\n                        IOUtils.copy(in, out);\n                      } finally {\n                        in.close();\n                      }\n                    }\n                  });\n                }\n              }\n              if (parts.size() > 0) {\n                post.setRequestEntity(new MultipartRequestEntity(parts\n                    .toArray(new Part[parts.size()]), post.getParams()));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              PostMethod post = new PostMethod(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setRequestEntity(new RequestEntity() {\n                  public long getContentLength() {\n                    return -1;\n                  }\n\n                  public String getContentType() {\n                    return contentStream[0].getContentType();\n                  }\n\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n\n                  public void writeRequest(OutputStream outputStream) throws IOException {\n                    ((RequestWriter.LazyContentStream) contentStream[0]).writeTo(outputStream);\n                  }\n                }\n                );\n\n              } else {\n                is = contentStream[0].getStream();\n                post.setRequestEntity(new InputStreamRequestEntity(is, contentStream[0].getContentType()));\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          // This is generally safe to retry on\n          method.releaseConnection();\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if( ( tries < 1 ) ) {\n            throw r;\n          }\n          //log.warn( \"Caught: \" + r + \". Retrying...\" );\n        }\n      }\n    }\n    catch( IOException ex ) {\n      throw new SolrServerException(\"error reading streams\", ex );\n    }\n\n    method.setFollowRedirects( _followRedirects );\n    method.addRequestHeader( \"User-Agent\", AGENT );\n    if( _allowCompression ) {\n      method.setRequestHeader( new Header( \"Accept-Encoding\", \"gzip,deflate\" ) );\n    }\n\n    try {\n      // Execute the method.\n      //System.out.println( \"EXECUTE:\"+method.getURI() );\n\n      int statusCode = _httpClient.executeMethod(method);\n      if (statusCode != HttpStatus.SC_OK) {\n        StringBuilder msg = new StringBuilder();\n        msg.append( method.getStatusLine().getReasonPhrase() );\n        msg.append( \"\\n\\n\" );\n        msg.append( method.getStatusText() );\n        msg.append( \"\\n\\n\" );\n        msg.append( \"request: \"+method.getURI() );\n        throw new SolrException(statusCode, java.net.URLDecoder.decode(msg.toString(), \"UTF-8\") );\n      }\n\n      // Read the contents\n      String charset = \"UTF-8\";\n      if( method instanceof HttpMethodBase ) {\n        charset = ((HttpMethodBase)method).getResponseCharSet();\n      }\n      InputStream respBody = method.getResponseBodyAsStream();\n      // Jakarta Commons HTTPClient doesn't handle any\n      // compression natively.  Handle gzip or deflate\n      // here if applicable.\n      if( _allowCompression ) {\n        Header contentEncodingHeader = method.getResponseHeader( \"Content-Encoding\" );\n        if( contentEncodingHeader != null ) {\n          String contentEncoding = contentEncodingHeader.getValue();\n          if( contentEncoding.contains( \"gzip\" ) ) {\n            //log.debug( \"wrapping response in GZIPInputStream\" );\n            respBody = new GZIPInputStream( respBody );\n          }\n          else if( contentEncoding.contains( \"deflate\" ) ) {\n            //log.debug( \"wrapping response in InflaterInputStream\" );\n            respBody = new InflaterInputStream(respBody);\n          }\n        }\n        else {\n          Header contentTypeHeader = method.getResponseHeader( \"Content-Type\" );\n          if( contentTypeHeader != null ) {\n            String contentType = contentTypeHeader.getValue();\n            if( contentType != null ) {\n              if( contentType.startsWith( \"application/x-gzip-compressed\" ) ) {\n                //log.debug( \"wrapping response in GZIPInputStream\" );\n                respBody = new GZIPInputStream( respBody );\n              }\n              else if ( contentType.startsWith(\"application/x-deflate\") ) {\n                //log.debug( \"wrapping response in InflaterInputStream\" );\n                respBody = new InflaterInputStream(respBody);\n              }\n            }\n          }\n        }\n      }\n      return processor.processResponse(respBody, charset);\n    }\n    catch (HttpException e) {\n      throw new SolrServerException( e );\n    }\n    catch (IOException e) {\n      throw new SolrServerException( e );\n    }\n    finally {\n      method.releaseConnection();\n      if(is != null) {\n        is.close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer#request(SolrRequest,ResponseParser).mjava","pathOld":"solr/src/solrj/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer#request(SolrRequest,ResponseParser).mjava","sourceNew":"  public NamedList<Object> request(final SolrRequest request, ResponseParser processor) throws SolrServerException, IOException {\n    HttpMethod method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if( path == null || !path.startsWith( \"/\" ) ) {\n      path = \"/select\";\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if( parser == null ) {\n      parser = _parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original params\n    ModifiableSolrParams wparams = new ModifiableSolrParams();\n    wparams.set( CommonParams.WT, parser.getWriterType() );\n    wparams.set( CommonParams.VERSION, parser.getVersion());\n    if( params == null ) {\n      params = wparams;\n    }\n    else {\n      params = new DefaultSolrParams( wparams, params );\n    }\n    \n    if( _invariantParams != null ) {\n      params = new DefaultSolrParams( _invariantParams, params );\n    }\n\n    int tries = _maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new GetMethod( _baseURL + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = _baseURL + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            if (streams == null || isMultipart) {\n              PostMethod post = new PostMethod(url);\n              post.getParams().setContentCharset(\"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addRequestHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<Part> parts = new LinkedList<Part>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new StringPart(p, v, \"UTF-8\"));\n                    } else {\n                      post.addParameter(p, v);\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                int i = 0;\n                for (ContentStream content : streams) {\n                  final ContentStream c = content;\n\n                  String charSet = null;\n                  PartSource source = new PartSource() {\n                    @Override\n                    public long getLength() {\n                      return c.getSize();\n                    }\n                      \n                    public String getFileName() {\n                      return c.getName();\n                    }\n\n                    @Override\n                    public InputStream createInputStream() throws IOException {\n                      return c.getStream();\n                    }\n                  };\n                \n                  parts.add(new FilePart(c.getName(), source, \n                                         c.getContentType(), charSet));\n                }\n              }\n              if (parts.size() > 0) {\n                post.setRequestEntity(new MultipartRequestEntity(parts\n                    .toArray(new Part[parts.size()]), post.getParams()));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              PostMethod post = new PostMethod(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setRequestEntity(new RequestEntity() {\n                  public long getContentLength() {\n                    return -1;\n                  }\n\n                  public String getContentType() {\n                    return contentStream[0].getContentType();\n                  }\n\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n\n                  public void writeRequest(OutputStream outputStream) throws IOException {\n                    ((RequestWriter.LazyContentStream) contentStream[0]).writeTo(outputStream);\n                  }\n                }\n                );\n\n              } else {\n                is = contentStream[0].getStream();\n                post.setRequestEntity(new InputStreamRequestEntity(is, contentStream[0].getContentType()));\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          // This is generally safe to retry on\n          method.releaseConnection();\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if( ( tries < 1 ) ) {\n            throw r;\n          }\n          //log.warn( \"Caught: \" + r + \". Retrying...\" );\n        }\n      }\n    }\n    catch( IOException ex ) {\n      throw new SolrServerException(\"error reading streams\", ex );\n    }\n\n    method.setFollowRedirects( _followRedirects );\n    method.addRequestHeader( \"User-Agent\", AGENT );\n    if( _allowCompression ) {\n      method.setRequestHeader( new Header( \"Accept-Encoding\", \"gzip,deflate\" ) );\n    }\n\n    try {\n      // Execute the method.\n      //System.out.println( \"EXECUTE:\"+method.getURI() );\n\n      int statusCode = _httpClient.executeMethod(method);\n      if (statusCode != HttpStatus.SC_OK) {\n        StringBuilder msg = new StringBuilder();\n        msg.append( method.getStatusLine().getReasonPhrase() );\n        msg.append( \"\\n\\n\" );\n        msg.append( method.getStatusText() );\n        msg.append( \"\\n\\n\" );\n        msg.append( \"request: \"+method.getURI() );\n        throw new SolrException(statusCode, java.net.URLDecoder.decode(msg.toString(), \"UTF-8\") );\n      }\n\n      // Read the contents\n      String charset = \"UTF-8\";\n      if( method instanceof HttpMethodBase ) {\n        charset = ((HttpMethodBase)method).getResponseCharSet();\n      }\n      InputStream respBody = method.getResponseBodyAsStream();\n      // Jakarta Commons HTTPClient doesn't handle any\n      // compression natively.  Handle gzip or deflate\n      // here if applicable.\n      if( _allowCompression ) {\n        Header contentEncodingHeader = method.getResponseHeader( \"Content-Encoding\" );\n        if( contentEncodingHeader != null ) {\n          String contentEncoding = contentEncodingHeader.getValue();\n          if( contentEncoding.contains( \"gzip\" ) ) {\n            //log.debug( \"wrapping response in GZIPInputStream\" );\n            respBody = new GZIPInputStream( respBody );\n          }\n          else if( contentEncoding.contains( \"deflate\" ) ) {\n            //log.debug( \"wrapping response in InflaterInputStream\" );\n            respBody = new InflaterInputStream(respBody);\n          }\n        }\n        else {\n          Header contentTypeHeader = method.getResponseHeader( \"Content-Type\" );\n          if( contentTypeHeader != null ) {\n            String contentType = contentTypeHeader.getValue();\n            if( contentType != null ) {\n              if( contentType.startsWith( \"application/x-gzip-compressed\" ) ) {\n                //log.debug( \"wrapping response in GZIPInputStream\" );\n                respBody = new GZIPInputStream( respBody );\n              }\n              else if ( contentType.startsWith(\"application/x-deflate\") ) {\n                //log.debug( \"wrapping response in InflaterInputStream\" );\n                respBody = new InflaterInputStream(respBody);\n              }\n            }\n          }\n        }\n      }\n      return processor.processResponse(respBody, charset);\n    }\n    catch (HttpException e) {\n      throw new SolrServerException( e );\n    }\n    catch (IOException e) {\n      throw new SolrServerException( e );\n    }\n    finally {\n      method.releaseConnection();\n      if(is != null) {\n        is.close();\n      }\n    }\n  }\n\n","sourceOld":"  public NamedList<Object> request(final SolrRequest request, ResponseParser processor) throws SolrServerException, IOException {\n    HttpMethod method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if( path == null || !path.startsWith( \"/\" ) ) {\n      path = \"/select\";\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if( parser == null ) {\n      parser = _parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original params\n    ModifiableSolrParams wparams = new ModifiableSolrParams();\n    wparams.set( CommonParams.WT, parser.getWriterType() );\n    wparams.set( CommonParams.VERSION, parser.getVersion());\n    if( params == null ) {\n      params = wparams;\n    }\n    else {\n      params = new DefaultSolrParams( wparams, params );\n    }\n    \n    if( _invariantParams != null ) {\n      params = new DefaultSolrParams( _invariantParams, params );\n    }\n\n    int tries = _maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new GetMethod( _baseURL + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = _baseURL + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            if (streams == null || isMultipart) {\n              PostMethod post = new PostMethod(url);\n              post.getParams().setContentCharset(\"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addRequestHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<Part> parts = new LinkedList<Part>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new StringPart(p, v, \"UTF-8\"));\n                    } else {\n                      post.addParameter(p, v);\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                int i = 0;\n                for (ContentStream content : streams) {\n                  final ContentStream c = content;\n\n                  String charSet = null;\n                  PartSource source = new PartSource() {\n                    @Override\n                    public long getLength() {\n                      return c.getSize();\n                    }\n                      \n                    public String getFileName() {\n                      return c.getName();\n                    }\n\n                    @Override\n                    public InputStream createInputStream() throws IOException {\n                      return c.getStream();\n                    }\n                  };\n                \n                  parts.add(new FilePart(c.getName(), source, \n                                         c.getContentType(), charSet));\n                }\n              }\n              if (parts.size() > 0) {\n                post.setRequestEntity(new MultipartRequestEntity(parts\n                    .toArray(new Part[parts.size()]), post.getParams()));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              PostMethod post = new PostMethod(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setRequestEntity(new RequestEntity() {\n                  public long getContentLength() {\n                    return -1;\n                  }\n\n                  public String getContentType() {\n                    return contentStream[0].getContentType();\n                  }\n\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n\n                  public void writeRequest(OutputStream outputStream) throws IOException {\n                    ((RequestWriter.LazyContentStream) contentStream[0]).writeTo(outputStream);\n                  }\n                }\n                );\n\n              } else {\n                is = contentStream[0].getStream();\n                post.setRequestEntity(new InputStreamRequestEntity(is, contentStream[0].getContentType()));\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          // This is generally safe to retry on\n          method.releaseConnection();\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if( ( tries < 1 ) ) {\n            throw r;\n          }\n          //log.warn( \"Caught: \" + r + \". Retrying...\" );\n        }\n      }\n    }\n    catch( IOException ex ) {\n      throw new SolrServerException(\"error reading streams\", ex );\n    }\n\n    method.setFollowRedirects( _followRedirects );\n    method.addRequestHeader( \"User-Agent\", AGENT );\n    if( _allowCompression ) {\n      method.setRequestHeader( new Header( \"Accept-Encoding\", \"gzip,deflate\" ) );\n    }\n\n    try {\n      // Execute the method.\n      //System.out.println( \"EXECUTE:\"+method.getURI() );\n\n      int statusCode = _httpClient.executeMethod(method);\n      if (statusCode != HttpStatus.SC_OK) {\n        StringBuilder msg = new StringBuilder();\n        msg.append( method.getStatusLine().getReasonPhrase() );\n        msg.append( \"\\n\\n\" );\n        msg.append( method.getStatusText() );\n        msg.append( \"\\n\\n\" );\n        msg.append( \"request: \"+method.getURI() );\n        throw new SolrException(statusCode, java.net.URLDecoder.decode(msg.toString(), \"UTF-8\") );\n      }\n\n      // Read the contents\n      String charset = \"UTF-8\";\n      if( method instanceof HttpMethodBase ) {\n        charset = ((HttpMethodBase)method).getResponseCharSet();\n      }\n      InputStream respBody = method.getResponseBodyAsStream();\n      // Jakarta Commons HTTPClient doesn't handle any\n      // compression natively.  Handle gzip or deflate\n      // here if applicable.\n      if( _allowCompression ) {\n        Header contentEncodingHeader = method.getResponseHeader( \"Content-Encoding\" );\n        if( contentEncodingHeader != null ) {\n          String contentEncoding = contentEncodingHeader.getValue();\n          if( contentEncoding.contains( \"gzip\" ) ) {\n            //log.debug( \"wrapping response in GZIPInputStream\" );\n            respBody = new GZIPInputStream( respBody );\n          }\n          else if( contentEncoding.contains( \"deflate\" ) ) {\n            //log.debug( \"wrapping response in InflaterInputStream\" );\n            respBody = new InflaterInputStream(respBody);\n          }\n        }\n        else {\n          Header contentTypeHeader = method.getResponseHeader( \"Content-Type\" );\n          if( contentTypeHeader != null ) {\n            String contentType = contentTypeHeader.getValue();\n            if( contentType != null ) {\n              if( contentType.startsWith( \"application/x-gzip-compressed\" ) ) {\n                //log.debug( \"wrapping response in GZIPInputStream\" );\n                respBody = new GZIPInputStream( respBody );\n              }\n              else if ( contentType.startsWith(\"application/x-deflate\") ) {\n                //log.debug( \"wrapping response in InflaterInputStream\" );\n                respBody = new InflaterInputStream(respBody);\n              }\n            }\n          }\n        }\n      }\n      return processor.processResponse(respBody, charset);\n    }\n    catch (HttpException e) {\n      throw new SolrServerException( e );\n    }\n    catch (IOException e) {\n      throw new SolrServerException( e );\n    }\n    finally {\n      method.releaseConnection();\n      if(is != null) {\n        is.close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f0b9507caf22f292ac0e5e59f62db4275adf4511","date":1310107283,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer#request(SolrRequest,ResponseParser).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer#request(SolrRequest,ResponseParser).mjava","sourceNew":"  public NamedList<Object> request(final SolrRequest request, ResponseParser processor) throws SolrServerException, IOException {\n    HttpMethod method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if( path == null || !path.startsWith( \"/\" ) ) {\n      path = \"/select\";\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if( parser == null ) {\n      parser = _parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original params\n    ModifiableSolrParams wparams = new ModifiableSolrParams();\n    wparams.set( CommonParams.WT, parser.getWriterType() );\n    wparams.set( CommonParams.VERSION, parser.getVersion());\n    if( params == null ) {\n      params = wparams;\n    }\n    else {\n      params = new DefaultSolrParams( wparams, params );\n    }\n    \n    if( _invariantParams != null ) {\n      params = new DefaultSolrParams( _invariantParams, params );\n    }\n\n    int tries = _maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new GetMethod( _baseURL + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = _baseURL + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            if (streams == null || isMultipart) {\n              PostMethod post = new PostMethod(url);\n              post.getParams().setContentCharset(\"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addRequestHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<Part> parts = new LinkedList<Part>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new StringPart(p, v, \"UTF-8\"));\n                    } else {\n                      post.addParameter(p, v);\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                int i = 0;\n                for (ContentStream content : streams) {\n                  final ContentStream c = content;\n\n                  String charSet = null;\n                  PartSource source = new PartSource() {\n                    @Override\n                    public long getLength() {\n                      return c.getSize();\n                    }\n                      \n                    public String getFileName() {\n                      return c.getName();\n                    }\n\n                    @Override\n                    public InputStream createInputStream() throws IOException {\n                      return c.getStream();\n                    }\n                  };\n                \n                  parts.add(new FilePart(c.getName(), source, \n                                         c.getContentType(), charSet));\n                }\n              }\n              if (parts.size() > 0) {\n                post.setRequestEntity(new MultipartRequestEntity(parts\n                    .toArray(new Part[parts.size()]), post.getParams()));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              PostMethod post = new PostMethod(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setRequestEntity(new RequestEntity() {\n                  public long getContentLength() {\n                    return -1;\n                  }\n\n                  public String getContentType() {\n                    return contentStream[0].getContentType();\n                  }\n\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n\n                  public void writeRequest(OutputStream outputStream) throws IOException {\n                    ((RequestWriter.LazyContentStream) contentStream[0]).writeTo(outputStream);\n                  }\n                }\n                );\n\n              } else {\n                is = contentStream[0].getStream();\n                post.setRequestEntity(new InputStreamRequestEntity(is, contentStream[0].getContentType()));\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          // This is generally safe to retry on\n          method.releaseConnection();\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if( ( tries < 1 ) ) {\n            throw r;\n          }\n          //log.warn( \"Caught: \" + r + \". Retrying...\" );\n        }\n      }\n    }\n    catch( IOException ex ) {\n      throw new SolrServerException(\"error reading streams\", ex );\n    }\n\n    method.setFollowRedirects( _followRedirects );\n    method.addRequestHeader( \"User-Agent\", AGENT );\n    if( _allowCompression ) {\n      method.setRequestHeader( new Header( \"Accept-Encoding\", \"gzip,deflate\" ) );\n    }\n\n    try {\n      // Execute the method.\n      //System.out.println( \"EXECUTE:\"+method.getURI() );\n\n      int statusCode = _httpClient.executeMethod(method);\n      if (statusCode != HttpStatus.SC_OK) {\n        StringBuilder msg = new StringBuilder();\n        msg.append( method.getStatusLine().getReasonPhrase() );\n        msg.append( \"\\n\\n\" );\n        msg.append( method.getStatusText() );\n        msg.append( \"\\n\\n\" );\n        msg.append( \"request: \"+method.getURI() );\n        throw new SolrException(statusCode, java.net.URLDecoder.decode(msg.toString(), \"UTF-8\") );\n      }\n\n      // Read the contents\n      String charset = \"UTF-8\";\n      if( method instanceof HttpMethodBase ) {\n        charset = ((HttpMethodBase)method).getResponseCharSet();\n      }\n      InputStream respBody = method.getResponseBodyAsStream();\n      // Jakarta Commons HTTPClient doesn't handle any\n      // compression natively.  Handle gzip or deflate\n      // here if applicable.\n      if( _allowCompression ) {\n        Header contentEncodingHeader = method.getResponseHeader( \"Content-Encoding\" );\n        if( contentEncodingHeader != null ) {\n          String contentEncoding = contentEncodingHeader.getValue();\n          if( contentEncoding.contains( \"gzip\" ) ) {\n            //log.debug( \"wrapping response in GZIPInputStream\" );\n            respBody = new GZIPInputStream( respBody );\n          }\n          else if( contentEncoding.contains( \"deflate\" ) ) {\n            //log.debug( \"wrapping response in InflaterInputStream\" );\n            respBody = new InflaterInputStream(respBody);\n          }\n        }\n        else {\n          Header contentTypeHeader = method.getResponseHeader( \"Content-Type\" );\n          if( contentTypeHeader != null ) {\n            String contentType = contentTypeHeader.getValue();\n            if( contentType != null ) {\n              if( contentType.startsWith( \"application/x-gzip-compressed\" ) ) {\n                //log.debug( \"wrapping response in GZIPInputStream\" );\n                respBody = new GZIPInputStream( respBody );\n              }\n              else if ( contentType.startsWith(\"application/x-deflate\") ) {\n                //log.debug( \"wrapping response in InflaterInputStream\" );\n                respBody = new InflaterInputStream(respBody);\n              }\n            }\n          }\n        }\n      }\n      return processor.processResponse(respBody, charset);\n    }\n    catch (HttpException e) {\n      throw new SolrServerException( e );\n    }\n    catch (IOException e) {\n      throw new SolrServerException( e );\n    }\n    finally {\n      method.releaseConnection();\n      if(is != null) {\n        is.close();\n      }\n    }\n  }\n\n","sourceOld":"  public NamedList<Object> request(final SolrRequest request, ResponseParser processor) throws SolrServerException, IOException {\n    HttpMethod method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if( path == null || !path.startsWith( \"/\" ) ) {\n      path = \"/select\";\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if( parser == null ) {\n      parser = _parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original params\n    ModifiableSolrParams wparams = new ModifiableSolrParams();\n    wparams.set( CommonParams.WT, parser.getWriterType() );\n    wparams.set( CommonParams.VERSION, parser.getVersion());\n    if( params == null ) {\n      params = wparams;\n    }\n    else {\n      params = new DefaultSolrParams( wparams, params );\n    }\n    \n    if( _invariantParams != null ) {\n      params = new DefaultSolrParams( _invariantParams, params );\n    }\n\n    int tries = _maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new GetMethod( _baseURL + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = _baseURL + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            if (streams == null || isMultipart) {\n              PostMethod post = new PostMethod(url);\n              post.getParams().setContentCharset(\"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addRequestHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<Part> parts = new LinkedList<Part>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new StringPart(p, v, \"UTF-8\"));\n                    } else {\n                      post.addParameter(p, v);\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                int i = 0;\n                for (ContentStream content : streams) {\n                  final ContentStream c = content;\n\n                  String charSet = null;\n                  String transferEncoding = null;\n                  parts.add(new PartBase(c.getName(), c.getContentType(),\n                      charSet, transferEncoding) {\n                    @Override\n                    protected long lengthOfData() throws IOException {\n                      return c.getSize();\n                    }\n\n                    @Override\n                    protected void sendData(OutputStream out)\n                        throws IOException {\n                      InputStream in = c.getStream();\n                      try {\n                        IOUtils.copy(in, out);\n                      } finally {\n                        in.close();\n                      }\n                    }\n                  });\n                }\n              }\n              if (parts.size() > 0) {\n                post.setRequestEntity(new MultipartRequestEntity(parts\n                    .toArray(new Part[parts.size()]), post.getParams()));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              PostMethod post = new PostMethod(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setRequestEntity(new RequestEntity() {\n                  public long getContentLength() {\n                    return -1;\n                  }\n\n                  public String getContentType() {\n                    return contentStream[0].getContentType();\n                  }\n\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n\n                  public void writeRequest(OutputStream outputStream) throws IOException {\n                    ((RequestWriter.LazyContentStream) contentStream[0]).writeTo(outputStream);\n                  }\n                }\n                );\n\n              } else {\n                is = contentStream[0].getStream();\n                post.setRequestEntity(new InputStreamRequestEntity(is, contentStream[0].getContentType()));\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          // This is generally safe to retry on\n          method.releaseConnection();\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if( ( tries < 1 ) ) {\n            throw r;\n          }\n          //log.warn( \"Caught: \" + r + \". Retrying...\" );\n        }\n      }\n    }\n    catch( IOException ex ) {\n      throw new SolrServerException(\"error reading streams\", ex );\n    }\n\n    method.setFollowRedirects( _followRedirects );\n    method.addRequestHeader( \"User-Agent\", AGENT );\n    if( _allowCompression ) {\n      method.setRequestHeader( new Header( \"Accept-Encoding\", \"gzip,deflate\" ) );\n    }\n\n    try {\n      // Execute the method.\n      //System.out.println( \"EXECUTE:\"+method.getURI() );\n\n      int statusCode = _httpClient.executeMethod(method);\n      if (statusCode != HttpStatus.SC_OK) {\n        StringBuilder msg = new StringBuilder();\n        msg.append( method.getStatusLine().getReasonPhrase() );\n        msg.append( \"\\n\\n\" );\n        msg.append( method.getStatusText() );\n        msg.append( \"\\n\\n\" );\n        msg.append( \"request: \"+method.getURI() );\n        throw new SolrException(statusCode, java.net.URLDecoder.decode(msg.toString(), \"UTF-8\") );\n      }\n\n      // Read the contents\n      String charset = \"UTF-8\";\n      if( method instanceof HttpMethodBase ) {\n        charset = ((HttpMethodBase)method).getResponseCharSet();\n      }\n      InputStream respBody = method.getResponseBodyAsStream();\n      // Jakarta Commons HTTPClient doesn't handle any\n      // compression natively.  Handle gzip or deflate\n      // here if applicable.\n      if( _allowCompression ) {\n        Header contentEncodingHeader = method.getResponseHeader( \"Content-Encoding\" );\n        if( contentEncodingHeader != null ) {\n          String contentEncoding = contentEncodingHeader.getValue();\n          if( contentEncoding.contains( \"gzip\" ) ) {\n            //log.debug( \"wrapping response in GZIPInputStream\" );\n            respBody = new GZIPInputStream( respBody );\n          }\n          else if( contentEncoding.contains( \"deflate\" ) ) {\n            //log.debug( \"wrapping response in InflaterInputStream\" );\n            respBody = new InflaterInputStream(respBody);\n          }\n        }\n        else {\n          Header contentTypeHeader = method.getResponseHeader( \"Content-Type\" );\n          if( contentTypeHeader != null ) {\n            String contentType = contentTypeHeader.getValue();\n            if( contentType != null ) {\n              if( contentType.startsWith( \"application/x-gzip-compressed\" ) ) {\n                //log.debug( \"wrapping response in GZIPInputStream\" );\n                respBody = new GZIPInputStream( respBody );\n              }\n              else if ( contentType.startsWith(\"application/x-deflate\") ) {\n                //log.debug( \"wrapping response in InflaterInputStream\" );\n                respBody = new InflaterInputStream(respBody);\n              }\n            }\n          }\n        }\n      }\n      return processor.processResponse(respBody, charset);\n    }\n    catch (HttpException e) {\n      throw new SolrServerException( e );\n    }\n    catch (IOException e) {\n      throw new SolrServerException( e );\n    }\n    finally {\n      method.releaseConnection();\n      if(is != null) {\n        is.close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer#request(SolrRequest,ResponseParser).mjava","pathOld":"solr/src/solrj/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer#request(SolrRequest,ResponseParser).mjava","sourceNew":"  public NamedList<Object> request(final SolrRequest request, ResponseParser processor) throws SolrServerException, IOException {\n    HttpMethod method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if( path == null || !path.startsWith( \"/\" ) ) {\n      path = \"/select\";\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if( parser == null ) {\n      parser = _parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original params\n    ModifiableSolrParams wparams = new ModifiableSolrParams();\n    wparams.set( CommonParams.WT, parser.getWriterType() );\n    wparams.set( CommonParams.VERSION, parser.getVersion());\n    if( params == null ) {\n      params = wparams;\n    }\n    else {\n      params = new DefaultSolrParams( wparams, params );\n    }\n    \n    if( _invariantParams != null ) {\n      params = new DefaultSolrParams( _invariantParams, params );\n    }\n\n    int tries = _maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new GetMethod( _baseURL + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = _baseURL + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            if (streams == null || isMultipart) {\n              PostMethod post = new PostMethod(url);\n              post.getParams().setContentCharset(\"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addRequestHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<Part> parts = new LinkedList<Part>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new StringPart(p, v, \"UTF-8\"));\n                    } else {\n                      post.addParameter(p, v);\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                int i = 0;\n                for (ContentStream content : streams) {\n                  final ContentStream c = content;\n\n                  String charSet = null;\n                  PartSource source = new PartSource() {\n                    @Override\n                    public long getLength() {\n                      return c.getSize();\n                    }\n                      \n                    public String getFileName() {\n                      return c.getName();\n                    }\n\n                    @Override\n                    public InputStream createInputStream() throws IOException {\n                      return c.getStream();\n                    }\n                  };\n                \n                  parts.add(new FilePart(c.getName(), source, \n                                         c.getContentType(), charSet));\n                }\n              }\n              if (parts.size() > 0) {\n                post.setRequestEntity(new MultipartRequestEntity(parts\n                    .toArray(new Part[parts.size()]), post.getParams()));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              PostMethod post = new PostMethod(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setRequestEntity(new RequestEntity() {\n                  public long getContentLength() {\n                    return -1;\n                  }\n\n                  public String getContentType() {\n                    return contentStream[0].getContentType();\n                  }\n\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n\n                  public void writeRequest(OutputStream outputStream) throws IOException {\n                    ((RequestWriter.LazyContentStream) contentStream[0]).writeTo(outputStream);\n                  }\n                }\n                );\n\n              } else {\n                is = contentStream[0].getStream();\n                post.setRequestEntity(new InputStreamRequestEntity(is, contentStream[0].getContentType()));\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          // This is generally safe to retry on\n          method.releaseConnection();\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if( ( tries < 1 ) ) {\n            throw r;\n          }\n          //log.warn( \"Caught: \" + r + \". Retrying...\" );\n        }\n      }\n    }\n    catch( IOException ex ) {\n      throw new SolrServerException(\"error reading streams\", ex );\n    }\n\n    method.setFollowRedirects( _followRedirects );\n    method.addRequestHeader( \"User-Agent\", AGENT );\n    if( _allowCompression ) {\n      method.setRequestHeader( new Header( \"Accept-Encoding\", \"gzip,deflate\" ) );\n    }\n\n    try {\n      // Execute the method.\n      //System.out.println( \"EXECUTE:\"+method.getURI() );\n\n      int statusCode = _httpClient.executeMethod(method);\n      if (statusCode != HttpStatus.SC_OK) {\n        StringBuilder msg = new StringBuilder();\n        msg.append( method.getStatusLine().getReasonPhrase() );\n        msg.append( \"\\n\\n\" );\n        msg.append( method.getStatusText() );\n        msg.append( \"\\n\\n\" );\n        msg.append( \"request: \"+method.getURI() );\n        throw new SolrException(statusCode, java.net.URLDecoder.decode(msg.toString(), \"UTF-8\") );\n      }\n\n      // Read the contents\n      String charset = \"UTF-8\";\n      if( method instanceof HttpMethodBase ) {\n        charset = ((HttpMethodBase)method).getResponseCharSet();\n      }\n      InputStream respBody = method.getResponseBodyAsStream();\n      // Jakarta Commons HTTPClient doesn't handle any\n      // compression natively.  Handle gzip or deflate\n      // here if applicable.\n      if( _allowCompression ) {\n        Header contentEncodingHeader = method.getResponseHeader( \"Content-Encoding\" );\n        if( contentEncodingHeader != null ) {\n          String contentEncoding = contentEncodingHeader.getValue();\n          if( contentEncoding.contains( \"gzip\" ) ) {\n            //log.debug( \"wrapping response in GZIPInputStream\" );\n            respBody = new GZIPInputStream( respBody );\n          }\n          else if( contentEncoding.contains( \"deflate\" ) ) {\n            //log.debug( \"wrapping response in InflaterInputStream\" );\n            respBody = new InflaterInputStream(respBody);\n          }\n        }\n        else {\n          Header contentTypeHeader = method.getResponseHeader( \"Content-Type\" );\n          if( contentTypeHeader != null ) {\n            String contentType = contentTypeHeader.getValue();\n            if( contentType != null ) {\n              if( contentType.startsWith( \"application/x-gzip-compressed\" ) ) {\n                //log.debug( \"wrapping response in GZIPInputStream\" );\n                respBody = new GZIPInputStream( respBody );\n              }\n              else if ( contentType.startsWith(\"application/x-deflate\") ) {\n                //log.debug( \"wrapping response in InflaterInputStream\" );\n                respBody = new InflaterInputStream(respBody);\n              }\n            }\n          }\n        }\n      }\n      return processor.processResponse(respBody, charset);\n    }\n    catch (HttpException e) {\n      throw new SolrServerException( e );\n    }\n    catch (IOException e) {\n      throw new SolrServerException( e );\n    }\n    finally {\n      method.releaseConnection();\n      if(is != null) {\n        is.close();\n      }\n    }\n  }\n\n","sourceOld":"  public NamedList<Object> request(final SolrRequest request, ResponseParser processor) throws SolrServerException, IOException {\n    HttpMethod method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if( path == null || !path.startsWith( \"/\" ) ) {\n      path = \"/select\";\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if( parser == null ) {\n      parser = _parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original params\n    ModifiableSolrParams wparams = new ModifiableSolrParams();\n    wparams.set( CommonParams.WT, parser.getWriterType() );\n    wparams.set( CommonParams.VERSION, parser.getVersion());\n    if( params == null ) {\n      params = wparams;\n    }\n    else {\n      params = new DefaultSolrParams( wparams, params );\n    }\n    \n    if( _invariantParams != null ) {\n      params = new DefaultSolrParams( _invariantParams, params );\n    }\n\n    int tries = _maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new GetMethod( _baseURL + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = _baseURL + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            if (streams == null || isMultipart) {\n              PostMethod post = new PostMethod(url);\n              post.getParams().setContentCharset(\"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addRequestHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<Part> parts = new LinkedList<Part>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new StringPart(p, v, \"UTF-8\"));\n                    } else {\n                      post.addParameter(p, v);\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                int i = 0;\n                for (ContentStream content : streams) {\n                  final ContentStream c = content;\n\n                  String charSet = null;\n                  PartSource source = new PartSource() {\n                    @Override\n                    public long getLength() {\n                      return c.getSize();\n                    }\n                      \n                    public String getFileName() {\n                      return c.getName();\n                    }\n\n                    @Override\n                    public InputStream createInputStream() throws IOException {\n                      return c.getStream();\n                    }\n                  };\n                \n                  parts.add(new FilePart(c.getName(), source, \n                                         c.getContentType(), charSet));\n                }\n              }\n              if (parts.size() > 0) {\n                post.setRequestEntity(new MultipartRequestEntity(parts\n                    .toArray(new Part[parts.size()]), post.getParams()));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              PostMethod post = new PostMethod(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setRequestEntity(new RequestEntity() {\n                  public long getContentLength() {\n                    return -1;\n                  }\n\n                  public String getContentType() {\n                    return contentStream[0].getContentType();\n                  }\n\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n\n                  public void writeRequest(OutputStream outputStream) throws IOException {\n                    ((RequestWriter.LazyContentStream) contentStream[0]).writeTo(outputStream);\n                  }\n                }\n                );\n\n              } else {\n                is = contentStream[0].getStream();\n                post.setRequestEntity(new InputStreamRequestEntity(is, contentStream[0].getContentType()));\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          // This is generally safe to retry on\n          method.releaseConnection();\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if( ( tries < 1 ) ) {\n            throw r;\n          }\n          //log.warn( \"Caught: \" + r + \". Retrying...\" );\n        }\n      }\n    }\n    catch( IOException ex ) {\n      throw new SolrServerException(\"error reading streams\", ex );\n    }\n\n    method.setFollowRedirects( _followRedirects );\n    method.addRequestHeader( \"User-Agent\", AGENT );\n    if( _allowCompression ) {\n      method.setRequestHeader( new Header( \"Accept-Encoding\", \"gzip,deflate\" ) );\n    }\n\n    try {\n      // Execute the method.\n      //System.out.println( \"EXECUTE:\"+method.getURI() );\n\n      int statusCode = _httpClient.executeMethod(method);\n      if (statusCode != HttpStatus.SC_OK) {\n        StringBuilder msg = new StringBuilder();\n        msg.append( method.getStatusLine().getReasonPhrase() );\n        msg.append( \"\\n\\n\" );\n        msg.append( method.getStatusText() );\n        msg.append( \"\\n\\n\" );\n        msg.append( \"request: \"+method.getURI() );\n        throw new SolrException(statusCode, java.net.URLDecoder.decode(msg.toString(), \"UTF-8\") );\n      }\n\n      // Read the contents\n      String charset = \"UTF-8\";\n      if( method instanceof HttpMethodBase ) {\n        charset = ((HttpMethodBase)method).getResponseCharSet();\n      }\n      InputStream respBody = method.getResponseBodyAsStream();\n      // Jakarta Commons HTTPClient doesn't handle any\n      // compression natively.  Handle gzip or deflate\n      // here if applicable.\n      if( _allowCompression ) {\n        Header contentEncodingHeader = method.getResponseHeader( \"Content-Encoding\" );\n        if( contentEncodingHeader != null ) {\n          String contentEncoding = contentEncodingHeader.getValue();\n          if( contentEncoding.contains( \"gzip\" ) ) {\n            //log.debug( \"wrapping response in GZIPInputStream\" );\n            respBody = new GZIPInputStream( respBody );\n          }\n          else if( contentEncoding.contains( \"deflate\" ) ) {\n            //log.debug( \"wrapping response in InflaterInputStream\" );\n            respBody = new InflaterInputStream(respBody);\n          }\n        }\n        else {\n          Header contentTypeHeader = method.getResponseHeader( \"Content-Type\" );\n          if( contentTypeHeader != null ) {\n            String contentType = contentTypeHeader.getValue();\n            if( contentType != null ) {\n              if( contentType.startsWith( \"application/x-gzip-compressed\" ) ) {\n                //log.debug( \"wrapping response in GZIPInputStream\" );\n                respBody = new GZIPInputStream( respBody );\n              }\n              else if ( contentType.startsWith(\"application/x-deflate\") ) {\n                //log.debug( \"wrapping response in InflaterInputStream\" );\n                respBody = new InflaterInputStream(respBody);\n              }\n            }\n          }\n        }\n      }\n      return processor.processResponse(respBody, charset);\n    }\n    catch (HttpException e) {\n      throw new SolrServerException( e );\n    }\n    catch (IOException e) {\n      throw new SolrServerException( e );\n    }\n    finally {\n      method.releaseConnection();\n      if(is != null) {\n        is.close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"78badada2c6b767bf3df3ab958519ee29ea32b89","date":1319718607,"type":3,"author":"Erik Hatcher","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer#request(SolrRequest,ResponseParser).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer#request(SolrRequest,ResponseParser).mjava","sourceNew":"  public NamedList<Object> request(final SolrRequest request, ResponseParser processor) throws SolrServerException, IOException {\n    HttpMethod method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if( path == null || !path.startsWith( \"/\" ) ) {\n      path = \"/select\";\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if( parser == null ) {\n      parser = _parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original params\n    ModifiableSolrParams wparams = new ModifiableSolrParams();\n    wparams.set( CommonParams.WT, parser.getWriterType() );\n    wparams.set( CommonParams.VERSION, parser.getVersion());\n    if( params == null ) {\n      params = wparams;\n    }\n    else {\n      params = new DefaultSolrParams( wparams, params );\n    }\n    \n    if( _invariantParams != null ) {\n      params = new DefaultSolrParams( _invariantParams, params );\n    }\n\n    int tries = _maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't doing intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new GetMethod( _baseURL + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = _baseURL + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            if (streams == null || isMultipart) {\n              PostMethod post = new PostMethod(url);\n              post.getParams().setContentCharset(\"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addRequestHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<Part> parts = new LinkedList<Part>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new StringPart(p, v, \"UTF-8\"));\n                    } else {\n                      post.addParameter(p, v);\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                int i = 0;\n                for (ContentStream content : streams) {\n                  final ContentStream c = content;\n\n                  String charSet = null;\n                  PartSource source = new PartSource() {\n                    @Override\n                    public long getLength() {\n                      return c.getSize();\n                    }\n                      \n                    public String getFileName() {\n                      return c.getName();\n                    }\n\n                    @Override\n                    public InputStream createInputStream() throws IOException {\n                      return c.getStream();\n                    }\n                  };\n                \n                  parts.add(new FilePart(c.getName(), source, \n                                         c.getContentType(), charSet));\n                }\n              }\n              if (parts.size() > 0) {\n                post.setRequestEntity(new MultipartRequestEntity(parts\n                    .toArray(new Part[parts.size()]), post.getParams()));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              PostMethod post = new PostMethod(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setRequestEntity(new RequestEntity() {\n                  public long getContentLength() {\n                    return -1;\n                  }\n\n                  public String getContentType() {\n                    return contentStream[0].getContentType();\n                  }\n\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n\n                  public void writeRequest(OutputStream outputStream) throws IOException {\n                    ((RequestWriter.LazyContentStream) contentStream[0]).writeTo(outputStream);\n                  }\n                }\n                );\n\n              } else {\n                is = contentStream[0].getStream();\n                post.setRequestEntity(new InputStreamRequestEntity(is, contentStream[0].getContentType()));\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          // This is generally safe to retry on\n          method.releaseConnection();\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if( ( tries < 1 ) ) {\n            throw r;\n          }\n          //log.warn( \"Caught: \" + r + \". Retrying...\" );\n        }\n      }\n    }\n    catch( IOException ex ) {\n      throw new SolrServerException(\"error reading streams\", ex );\n    }\n\n    method.setFollowRedirects( _followRedirects );\n    method.addRequestHeader( \"User-Agent\", AGENT );\n    if( _allowCompression ) {\n      method.setRequestHeader( new Header( \"Accept-Encoding\", \"gzip,deflate\" ) );\n    }\n\n    try {\n      // Execute the method.\n      //System.out.println( \"EXECUTE:\"+method.getURI() );\n\n      int statusCode = _httpClient.executeMethod(method);\n      if (statusCode != HttpStatus.SC_OK) {\n        StringBuilder msg = new StringBuilder();\n        msg.append( method.getStatusLine().getReasonPhrase() );\n        msg.append( \"\\n\\n\" );\n        msg.append( method.getStatusText() );\n        msg.append( \"\\n\\n\" );\n        msg.append( \"request: \"+method.getURI() );\n        throw new SolrException(statusCode, java.net.URLDecoder.decode(msg.toString(), \"UTF-8\") );\n      }\n\n      // Read the contents\n      String charset = \"UTF-8\";\n      if( method instanceof HttpMethodBase ) {\n        charset = ((HttpMethodBase)method).getResponseCharSet();\n      }\n      InputStream respBody = method.getResponseBodyAsStream();\n      // Jakarta Commons HTTPClient doesn't handle any\n      // compression natively.  Handle gzip or deflate\n      // here if applicable.\n      if( _allowCompression ) {\n        Header contentEncodingHeader = method.getResponseHeader( \"Content-Encoding\" );\n        if( contentEncodingHeader != null ) {\n          String contentEncoding = contentEncodingHeader.getValue();\n          if( contentEncoding.contains( \"gzip\" ) ) {\n            //log.debug( \"wrapping response in GZIPInputStream\" );\n            respBody = new GZIPInputStream( respBody );\n          }\n          else if( contentEncoding.contains( \"deflate\" ) ) {\n            //log.debug( \"wrapping response in InflaterInputStream\" );\n            respBody = new InflaterInputStream(respBody);\n          }\n        }\n        else {\n          Header contentTypeHeader = method.getResponseHeader( \"Content-Type\" );\n          if( contentTypeHeader != null ) {\n            String contentType = contentTypeHeader.getValue();\n            if( contentType != null ) {\n              if( contentType.startsWith( \"application/x-gzip-compressed\" ) ) {\n                //log.debug( \"wrapping response in GZIPInputStream\" );\n                respBody = new GZIPInputStream( respBody );\n              }\n              else if ( contentType.startsWith(\"application/x-deflate\") ) {\n                //log.debug( \"wrapping response in InflaterInputStream\" );\n                respBody = new InflaterInputStream(respBody);\n              }\n            }\n          }\n        }\n      }\n      return processor.processResponse(respBody, charset);\n    }\n    catch (HttpException e) {\n      throw new SolrServerException( e );\n    }\n    catch (IOException e) {\n      throw new SolrServerException( e );\n    }\n    finally {\n      method.releaseConnection();\n      if(is != null) {\n        is.close();\n      }\n    }\n  }\n\n","sourceOld":"  public NamedList<Object> request(final SolrRequest request, ResponseParser processor) throws SolrServerException, IOException {\n    HttpMethod method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if( path == null || !path.startsWith( \"/\" ) ) {\n      path = \"/select\";\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if( parser == null ) {\n      parser = _parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original params\n    ModifiableSolrParams wparams = new ModifiableSolrParams();\n    wparams.set( CommonParams.WT, parser.getWriterType() );\n    wparams.set( CommonParams.VERSION, parser.getVersion());\n    if( params == null ) {\n      params = wparams;\n    }\n    else {\n      params = new DefaultSolrParams( wparams, params );\n    }\n    \n    if( _invariantParams != null ) {\n      params = new DefaultSolrParams( _invariantParams, params );\n    }\n\n    int tries = _maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't do intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new GetMethod( _baseURL + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = _baseURL + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            if (streams == null || isMultipart) {\n              PostMethod post = new PostMethod(url);\n              post.getParams().setContentCharset(\"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addRequestHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<Part> parts = new LinkedList<Part>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new StringPart(p, v, \"UTF-8\"));\n                    } else {\n                      post.addParameter(p, v);\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                int i = 0;\n                for (ContentStream content : streams) {\n                  final ContentStream c = content;\n\n                  String charSet = null;\n                  PartSource source = new PartSource() {\n                    @Override\n                    public long getLength() {\n                      return c.getSize();\n                    }\n                      \n                    public String getFileName() {\n                      return c.getName();\n                    }\n\n                    @Override\n                    public InputStream createInputStream() throws IOException {\n                      return c.getStream();\n                    }\n                  };\n                \n                  parts.add(new FilePart(c.getName(), source, \n                                         c.getContentType(), charSet));\n                }\n              }\n              if (parts.size() > 0) {\n                post.setRequestEntity(new MultipartRequestEntity(parts\n                    .toArray(new Part[parts.size()]), post.getParams()));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              PostMethod post = new PostMethod(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setRequestEntity(new RequestEntity() {\n                  public long getContentLength() {\n                    return -1;\n                  }\n\n                  public String getContentType() {\n                    return contentStream[0].getContentType();\n                  }\n\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n\n                  public void writeRequest(OutputStream outputStream) throws IOException {\n                    ((RequestWriter.LazyContentStream) contentStream[0]).writeTo(outputStream);\n                  }\n                }\n                );\n\n              } else {\n                is = contentStream[0].getStream();\n                post.setRequestEntity(new InputStreamRequestEntity(is, contentStream[0].getContentType()));\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          // This is generally safe to retry on\n          method.releaseConnection();\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if( ( tries < 1 ) ) {\n            throw r;\n          }\n          //log.warn( \"Caught: \" + r + \". Retrying...\" );\n        }\n      }\n    }\n    catch( IOException ex ) {\n      throw new SolrServerException(\"error reading streams\", ex );\n    }\n\n    method.setFollowRedirects( _followRedirects );\n    method.addRequestHeader( \"User-Agent\", AGENT );\n    if( _allowCompression ) {\n      method.setRequestHeader( new Header( \"Accept-Encoding\", \"gzip,deflate\" ) );\n    }\n\n    try {\n      // Execute the method.\n      //System.out.println( \"EXECUTE:\"+method.getURI() );\n\n      int statusCode = _httpClient.executeMethod(method);\n      if (statusCode != HttpStatus.SC_OK) {\n        StringBuilder msg = new StringBuilder();\n        msg.append( method.getStatusLine().getReasonPhrase() );\n        msg.append( \"\\n\\n\" );\n        msg.append( method.getStatusText() );\n        msg.append( \"\\n\\n\" );\n        msg.append( \"request: \"+method.getURI() );\n        throw new SolrException(statusCode, java.net.URLDecoder.decode(msg.toString(), \"UTF-8\") );\n      }\n\n      // Read the contents\n      String charset = \"UTF-8\";\n      if( method instanceof HttpMethodBase ) {\n        charset = ((HttpMethodBase)method).getResponseCharSet();\n      }\n      InputStream respBody = method.getResponseBodyAsStream();\n      // Jakarta Commons HTTPClient doesn't handle any\n      // compression natively.  Handle gzip or deflate\n      // here if applicable.\n      if( _allowCompression ) {\n        Header contentEncodingHeader = method.getResponseHeader( \"Content-Encoding\" );\n        if( contentEncodingHeader != null ) {\n          String contentEncoding = contentEncodingHeader.getValue();\n          if( contentEncoding.contains( \"gzip\" ) ) {\n            //log.debug( \"wrapping response in GZIPInputStream\" );\n            respBody = new GZIPInputStream( respBody );\n          }\n          else if( contentEncoding.contains( \"deflate\" ) ) {\n            //log.debug( \"wrapping response in InflaterInputStream\" );\n            respBody = new InflaterInputStream(respBody);\n          }\n        }\n        else {\n          Header contentTypeHeader = method.getResponseHeader( \"Content-Type\" );\n          if( contentTypeHeader != null ) {\n            String contentType = contentTypeHeader.getValue();\n            if( contentType != null ) {\n              if( contentType.startsWith( \"application/x-gzip-compressed\" ) ) {\n                //log.debug( \"wrapping response in GZIPInputStream\" );\n                respBody = new GZIPInputStream( respBody );\n              }\n              else if ( contentType.startsWith(\"application/x-deflate\") ) {\n                //log.debug( \"wrapping response in InflaterInputStream\" );\n                respBody = new InflaterInputStream(respBody);\n              }\n            }\n          }\n        }\n      }\n      return processor.processResponse(respBody, charset);\n    }\n    catch (HttpException e) {\n      throw new SolrServerException( e );\n    }\n    catch (IOException e) {\n      throw new SolrServerException( e );\n    }\n    finally {\n      method.releaseConnection();\n      if(is != null) {\n        is.close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0dcbe407b62ce0c91dc171a4695a9f442c46ce14","date":1323729111,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer#request(SolrRequest,ResponseParser).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer#request(SolrRequest,ResponseParser).mjava","sourceNew":"  public NamedList<Object> request(final SolrRequest request, ResponseParser processor) throws SolrServerException, IOException {\n    HttpMethod method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if( path == null || !path.startsWith( \"/\" ) ) {\n      path = \"/select\";\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if( parser == null ) {\n      parser = _parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original params\n    ModifiableSolrParams wparams = new ModifiableSolrParams();\n    wparams.set( CommonParams.WT, parser.getWriterType() );\n    wparams.set( CommonParams.VERSION, parser.getVersion());\n    params = SolrParams.wrapDefaults(wparams, params);\n    params = SolrParams.wrapDefaults(_invariantParams, params);\n\n    int tries = _maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't doing intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new GetMethod( _baseURL + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = _baseURL + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            if (streams == null || isMultipart) {\n              PostMethod post = new PostMethod(url);\n              post.getParams().setContentCharset(\"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addRequestHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<Part> parts = new LinkedList<Part>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new StringPart(p, v, \"UTF-8\"));\n                    } else {\n                      post.addParameter(p, v);\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                int i = 0;\n                for (ContentStream content : streams) {\n                  final ContentStream c = content;\n\n                  String charSet = null;\n                  PartSource source = new PartSource() {\n                    @Override\n                    public long getLength() {\n                      return c.getSize();\n                    }\n                      \n                    public String getFileName() {\n                      return c.getName();\n                    }\n\n                    @Override\n                    public InputStream createInputStream() throws IOException {\n                      return c.getStream();\n                    }\n                  };\n                \n                  parts.add(new FilePart(c.getName(), source, \n                                         c.getContentType(), charSet));\n                }\n              }\n              if (parts.size() > 0) {\n                post.setRequestEntity(new MultipartRequestEntity(parts\n                    .toArray(new Part[parts.size()]), post.getParams()));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              PostMethod post = new PostMethod(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setRequestEntity(new RequestEntity() {\n                  public long getContentLength() {\n                    return -1;\n                  }\n\n                  public String getContentType() {\n                    return contentStream[0].getContentType();\n                  }\n\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n\n                  public void writeRequest(OutputStream outputStream) throws IOException {\n                    ((RequestWriter.LazyContentStream) contentStream[0]).writeTo(outputStream);\n                  }\n                }\n                );\n\n              } else {\n                is = contentStream[0].getStream();\n                post.setRequestEntity(new InputStreamRequestEntity(is, contentStream[0].getContentType()));\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          // This is generally safe to retry on\n          method.releaseConnection();\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if( ( tries < 1 ) ) {\n            throw r;\n          }\n          //log.warn( \"Caught: \" + r + \". Retrying...\" );\n        }\n      }\n    }\n    catch( IOException ex ) {\n      throw new SolrServerException(\"error reading streams\", ex );\n    }\n\n    method.setFollowRedirects( _followRedirects );\n    method.addRequestHeader( \"User-Agent\", AGENT );\n    if( _allowCompression ) {\n      method.setRequestHeader( new Header( \"Accept-Encoding\", \"gzip,deflate\" ) );\n    }\n\n    try {\n      // Execute the method.\n      //System.out.println( \"EXECUTE:\"+method.getURI() );\n\n      int statusCode = _httpClient.executeMethod(method);\n      if (statusCode != HttpStatus.SC_OK) {\n        StringBuilder msg = new StringBuilder();\n        msg.append( method.getStatusLine().getReasonPhrase() );\n        msg.append( \"\\n\\n\" );\n        msg.append( method.getStatusText() );\n        msg.append( \"\\n\\n\" );\n        msg.append( \"request: \"+method.getURI() );\n        throw new SolrException(statusCode, java.net.URLDecoder.decode(msg.toString(), \"UTF-8\") );\n      }\n\n      // Read the contents\n      String charset = \"UTF-8\";\n      if( method instanceof HttpMethodBase ) {\n        charset = ((HttpMethodBase)method).getResponseCharSet();\n      }\n      InputStream respBody = method.getResponseBodyAsStream();\n      // Jakarta Commons HTTPClient doesn't handle any\n      // compression natively.  Handle gzip or deflate\n      // here if applicable.\n      if( _allowCompression ) {\n        Header contentEncodingHeader = method.getResponseHeader( \"Content-Encoding\" );\n        if( contentEncodingHeader != null ) {\n          String contentEncoding = contentEncodingHeader.getValue();\n          if( contentEncoding.contains( \"gzip\" ) ) {\n            //log.debug( \"wrapping response in GZIPInputStream\" );\n            respBody = new GZIPInputStream( respBody );\n          }\n          else if( contentEncoding.contains( \"deflate\" ) ) {\n            //log.debug( \"wrapping response in InflaterInputStream\" );\n            respBody = new InflaterInputStream(respBody);\n          }\n        }\n        else {\n          Header contentTypeHeader = method.getResponseHeader( \"Content-Type\" );\n          if( contentTypeHeader != null ) {\n            String contentType = contentTypeHeader.getValue();\n            if( contentType != null ) {\n              if( contentType.startsWith( \"application/x-gzip-compressed\" ) ) {\n                //log.debug( \"wrapping response in GZIPInputStream\" );\n                respBody = new GZIPInputStream( respBody );\n              }\n              else if ( contentType.startsWith(\"application/x-deflate\") ) {\n                //log.debug( \"wrapping response in InflaterInputStream\" );\n                respBody = new InflaterInputStream(respBody);\n              }\n            }\n          }\n        }\n      }\n      return processor.processResponse(respBody, charset);\n    }\n    catch (HttpException e) {\n      throw new SolrServerException( e );\n    }\n    catch (IOException e) {\n      throw new SolrServerException( e );\n    }\n    finally {\n      method.releaseConnection();\n      if(is != null) {\n        is.close();\n      }\n    }\n  }\n\n","sourceOld":"  public NamedList<Object> request(final SolrRequest request, ResponseParser processor) throws SolrServerException, IOException {\n    HttpMethod method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if( path == null || !path.startsWith( \"/\" ) ) {\n      path = \"/select\";\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if( parser == null ) {\n      parser = _parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original params\n    ModifiableSolrParams wparams = new ModifiableSolrParams();\n    wparams.set( CommonParams.WT, parser.getWriterType() );\n    wparams.set( CommonParams.VERSION, parser.getVersion());\n    if( params == null ) {\n      params = wparams;\n    }\n    else {\n      params = new DefaultSolrParams( wparams, params );\n    }\n    \n    if( _invariantParams != null ) {\n      params = new DefaultSolrParams( _invariantParams, params );\n    }\n\n    int tries = _maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't doing intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new GetMethod( _baseURL + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = _baseURL + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            if (streams == null || isMultipart) {\n              PostMethod post = new PostMethod(url);\n              post.getParams().setContentCharset(\"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addRequestHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<Part> parts = new LinkedList<Part>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new StringPart(p, v, \"UTF-8\"));\n                    } else {\n                      post.addParameter(p, v);\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                int i = 0;\n                for (ContentStream content : streams) {\n                  final ContentStream c = content;\n\n                  String charSet = null;\n                  PartSource source = new PartSource() {\n                    @Override\n                    public long getLength() {\n                      return c.getSize();\n                    }\n                      \n                    public String getFileName() {\n                      return c.getName();\n                    }\n\n                    @Override\n                    public InputStream createInputStream() throws IOException {\n                      return c.getStream();\n                    }\n                  };\n                \n                  parts.add(new FilePart(c.getName(), source, \n                                         c.getContentType(), charSet));\n                }\n              }\n              if (parts.size() > 0) {\n                post.setRequestEntity(new MultipartRequestEntity(parts\n                    .toArray(new Part[parts.size()]), post.getParams()));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              PostMethod post = new PostMethod(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setRequestEntity(new RequestEntity() {\n                  public long getContentLength() {\n                    return -1;\n                  }\n\n                  public String getContentType() {\n                    return contentStream[0].getContentType();\n                  }\n\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n\n                  public void writeRequest(OutputStream outputStream) throws IOException {\n                    ((RequestWriter.LazyContentStream) contentStream[0]).writeTo(outputStream);\n                  }\n                }\n                );\n\n              } else {\n                is = contentStream[0].getStream();\n                post.setRequestEntity(new InputStreamRequestEntity(is, contentStream[0].getContentType()));\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          // This is generally safe to retry on\n          method.releaseConnection();\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if( ( tries < 1 ) ) {\n            throw r;\n          }\n          //log.warn( \"Caught: \" + r + \". Retrying...\" );\n        }\n      }\n    }\n    catch( IOException ex ) {\n      throw new SolrServerException(\"error reading streams\", ex );\n    }\n\n    method.setFollowRedirects( _followRedirects );\n    method.addRequestHeader( \"User-Agent\", AGENT );\n    if( _allowCompression ) {\n      method.setRequestHeader( new Header( \"Accept-Encoding\", \"gzip,deflate\" ) );\n    }\n\n    try {\n      // Execute the method.\n      //System.out.println( \"EXECUTE:\"+method.getURI() );\n\n      int statusCode = _httpClient.executeMethod(method);\n      if (statusCode != HttpStatus.SC_OK) {\n        StringBuilder msg = new StringBuilder();\n        msg.append( method.getStatusLine().getReasonPhrase() );\n        msg.append( \"\\n\\n\" );\n        msg.append( method.getStatusText() );\n        msg.append( \"\\n\\n\" );\n        msg.append( \"request: \"+method.getURI() );\n        throw new SolrException(statusCode, java.net.URLDecoder.decode(msg.toString(), \"UTF-8\") );\n      }\n\n      // Read the contents\n      String charset = \"UTF-8\";\n      if( method instanceof HttpMethodBase ) {\n        charset = ((HttpMethodBase)method).getResponseCharSet();\n      }\n      InputStream respBody = method.getResponseBodyAsStream();\n      // Jakarta Commons HTTPClient doesn't handle any\n      // compression natively.  Handle gzip or deflate\n      // here if applicable.\n      if( _allowCompression ) {\n        Header contentEncodingHeader = method.getResponseHeader( \"Content-Encoding\" );\n        if( contentEncodingHeader != null ) {\n          String contentEncoding = contentEncodingHeader.getValue();\n          if( contentEncoding.contains( \"gzip\" ) ) {\n            //log.debug( \"wrapping response in GZIPInputStream\" );\n            respBody = new GZIPInputStream( respBody );\n          }\n          else if( contentEncoding.contains( \"deflate\" ) ) {\n            //log.debug( \"wrapping response in InflaterInputStream\" );\n            respBody = new InflaterInputStream(respBody);\n          }\n        }\n        else {\n          Header contentTypeHeader = method.getResponseHeader( \"Content-Type\" );\n          if( contentTypeHeader != null ) {\n            String contentType = contentTypeHeader.getValue();\n            if( contentType != null ) {\n              if( contentType.startsWith( \"application/x-gzip-compressed\" ) ) {\n                //log.debug( \"wrapping response in GZIPInputStream\" );\n                respBody = new GZIPInputStream( respBody );\n              }\n              else if ( contentType.startsWith(\"application/x-deflate\") ) {\n                //log.debug( \"wrapping response in InflaterInputStream\" );\n                respBody = new InflaterInputStream(respBody);\n              }\n            }\n          }\n        }\n      }\n      return processor.processResponse(respBody, charset);\n    }\n    catch (HttpException e) {\n      throw new SolrServerException( e );\n    }\n    catch (IOException e) {\n      throw new SolrServerException( e );\n    }\n    finally {\n      method.releaseConnection();\n      if(is != null) {\n        is.close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4ceb6a6c707ada1df8bde804e25c98668e699a18","date":1323800602,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer#request(SolrRequest,ResponseParser).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer#request(SolrRequest,ResponseParser).mjava","sourceNew":"  public NamedList<Object> request(final SolrRequest request, ResponseParser processor) throws SolrServerException, IOException {\n    HttpMethod method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if( path == null || !path.startsWith( \"/\" ) ) {\n      path = \"/select\";\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if( parser == null ) {\n      parser = _parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original params\n    ModifiableSolrParams wparams = new ModifiableSolrParams();\n    wparams.set( CommonParams.WT, parser.getWriterType() );\n    wparams.set( CommonParams.VERSION, parser.getVersion());\n    params = SolrParams.wrapDefaults(wparams, params);\n    params = SolrParams.wrapDefaults(_invariantParams, params);\n\n    int tries = _maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't doing intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new GetMethod( _baseURL + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = _baseURL + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            if (streams == null || isMultipart) {\n              PostMethod post = new PostMethod(url);\n              post.getParams().setContentCharset(\"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addRequestHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<Part> parts = new LinkedList<Part>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new StringPart(p, v, \"UTF-8\"));\n                    } else {\n                      post.addParameter(p, v);\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                int i = 0;\n                for (ContentStream content : streams) {\n                  final ContentStream c = content;\n\n                  String charSet = null;\n                  PartSource source = new PartSource() {\n                    @Override\n                    public long getLength() {\n                      return c.getSize();\n                    }\n                      \n                    public String getFileName() {\n                      return c.getName();\n                    }\n\n                    @Override\n                    public InputStream createInputStream() throws IOException {\n                      return c.getStream();\n                    }\n                  };\n                \n                  parts.add(new FilePart(c.getName(), source, \n                                         c.getContentType(), charSet));\n                }\n              }\n              if (parts.size() > 0) {\n                post.setRequestEntity(new MultipartRequestEntity(parts\n                    .toArray(new Part[parts.size()]), post.getParams()));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              PostMethod post = new PostMethod(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setRequestEntity(new RequestEntity() {\n                  public long getContentLength() {\n                    return -1;\n                  }\n\n                  public String getContentType() {\n                    return contentStream[0].getContentType();\n                  }\n\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n\n                  public void writeRequest(OutputStream outputStream) throws IOException {\n                    ((RequestWriter.LazyContentStream) contentStream[0]).writeTo(outputStream);\n                  }\n                }\n                );\n\n              } else {\n                is = contentStream[0].getStream();\n                post.setRequestEntity(new InputStreamRequestEntity(is, contentStream[0].getContentType()));\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          // This is generally safe to retry on\n          method.releaseConnection();\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if( ( tries < 1 ) ) {\n            throw r;\n          }\n          //log.warn( \"Caught: \" + r + \". Retrying...\" );\n        }\n      }\n    }\n    catch( IOException ex ) {\n      throw new SolrServerException(\"error reading streams\", ex );\n    }\n\n    method.setFollowRedirects( _followRedirects );\n    method.addRequestHeader( \"User-Agent\", AGENT );\n    if( _allowCompression ) {\n      method.setRequestHeader( new Header( \"Accept-Encoding\", \"gzip,deflate\" ) );\n    }\n\n    try {\n      // Execute the method.\n      //System.out.println( \"EXECUTE:\"+method.getURI() );\n\n      int statusCode = _httpClient.executeMethod(method);\n      if (statusCode != HttpStatus.SC_OK) {\n        StringBuilder msg = new StringBuilder();\n        msg.append( method.getStatusLine().getReasonPhrase() );\n        msg.append( \"\\n\\n\" );\n        msg.append( method.getStatusText() );\n        msg.append( \"\\n\\n\" );\n        msg.append( \"request: \"+method.getURI() );\n        throw new SolrException(statusCode, java.net.URLDecoder.decode(msg.toString(), \"UTF-8\") );\n      }\n\n      // Read the contents\n      String charset = \"UTF-8\";\n      if( method instanceof HttpMethodBase ) {\n        charset = ((HttpMethodBase)method).getResponseCharSet();\n      }\n      InputStream respBody = method.getResponseBodyAsStream();\n      // Jakarta Commons HTTPClient doesn't handle any\n      // compression natively.  Handle gzip or deflate\n      // here if applicable.\n      if( _allowCompression ) {\n        Header contentEncodingHeader = method.getResponseHeader( \"Content-Encoding\" );\n        if( contentEncodingHeader != null ) {\n          String contentEncoding = contentEncodingHeader.getValue();\n          if( contentEncoding.contains( \"gzip\" ) ) {\n            //log.debug( \"wrapping response in GZIPInputStream\" );\n            respBody = new GZIPInputStream( respBody );\n          }\n          else if( contentEncoding.contains( \"deflate\" ) ) {\n            //log.debug( \"wrapping response in InflaterInputStream\" );\n            respBody = new InflaterInputStream(respBody);\n          }\n        }\n        else {\n          Header contentTypeHeader = method.getResponseHeader( \"Content-Type\" );\n          if( contentTypeHeader != null ) {\n            String contentType = contentTypeHeader.getValue();\n            if( contentType != null ) {\n              if( contentType.startsWith( \"application/x-gzip-compressed\" ) ) {\n                //log.debug( \"wrapping response in GZIPInputStream\" );\n                respBody = new GZIPInputStream( respBody );\n              }\n              else if ( contentType.startsWith(\"application/x-deflate\") ) {\n                //log.debug( \"wrapping response in InflaterInputStream\" );\n                respBody = new InflaterInputStream(respBody);\n              }\n            }\n          }\n        }\n      }\n      return processor.processResponse(respBody, charset);\n    }\n    catch (HttpException e) {\n      throw new SolrServerException( e );\n    }\n    catch (IOException e) {\n      throw new SolrServerException( e );\n    }\n    finally {\n      method.releaseConnection();\n      if(is != null) {\n        is.close();\n      }\n    }\n  }\n\n","sourceOld":"  public NamedList<Object> request(final SolrRequest request, ResponseParser processor) throws SolrServerException, IOException {\n    HttpMethod method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if( path == null || !path.startsWith( \"/\" ) ) {\n      path = \"/select\";\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if( parser == null ) {\n      parser = _parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original params\n    ModifiableSolrParams wparams = new ModifiableSolrParams();\n    wparams.set( CommonParams.WT, parser.getWriterType() );\n    wparams.set( CommonParams.VERSION, parser.getVersion());\n    if( params == null ) {\n      params = wparams;\n    }\n    else {\n      params = new DefaultSolrParams( wparams, params );\n    }\n    \n    if( _invariantParams != null ) {\n      params = new DefaultSolrParams( _invariantParams, params );\n    }\n\n    int tries = _maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't doing intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new GetMethod( _baseURL + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = _baseURL + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            if (streams == null || isMultipart) {\n              PostMethod post = new PostMethod(url);\n              post.getParams().setContentCharset(\"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addRequestHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<Part> parts = new LinkedList<Part>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new StringPart(p, v, \"UTF-8\"));\n                    } else {\n                      post.addParameter(p, v);\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                int i = 0;\n                for (ContentStream content : streams) {\n                  final ContentStream c = content;\n\n                  String charSet = null;\n                  PartSource source = new PartSource() {\n                    @Override\n                    public long getLength() {\n                      return c.getSize();\n                    }\n                      \n                    public String getFileName() {\n                      return c.getName();\n                    }\n\n                    @Override\n                    public InputStream createInputStream() throws IOException {\n                      return c.getStream();\n                    }\n                  };\n                \n                  parts.add(new FilePart(c.getName(), source, \n                                         c.getContentType(), charSet));\n                }\n              }\n              if (parts.size() > 0) {\n                post.setRequestEntity(new MultipartRequestEntity(parts\n                    .toArray(new Part[parts.size()]), post.getParams()));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              PostMethod post = new PostMethod(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setRequestEntity(new RequestEntity() {\n                  public long getContentLength() {\n                    return -1;\n                  }\n\n                  public String getContentType() {\n                    return contentStream[0].getContentType();\n                  }\n\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n\n                  public void writeRequest(OutputStream outputStream) throws IOException {\n                    ((RequestWriter.LazyContentStream) contentStream[0]).writeTo(outputStream);\n                  }\n                }\n                );\n\n              } else {\n                is = contentStream[0].getStream();\n                post.setRequestEntity(new InputStreamRequestEntity(is, contentStream[0].getContentType()));\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          // This is generally safe to retry on\n          method.releaseConnection();\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if( ( tries < 1 ) ) {\n            throw r;\n          }\n          //log.warn( \"Caught: \" + r + \". Retrying...\" );\n        }\n      }\n    }\n    catch( IOException ex ) {\n      throw new SolrServerException(\"error reading streams\", ex );\n    }\n\n    method.setFollowRedirects( _followRedirects );\n    method.addRequestHeader( \"User-Agent\", AGENT );\n    if( _allowCompression ) {\n      method.setRequestHeader( new Header( \"Accept-Encoding\", \"gzip,deflate\" ) );\n    }\n\n    try {\n      // Execute the method.\n      //System.out.println( \"EXECUTE:\"+method.getURI() );\n\n      int statusCode = _httpClient.executeMethod(method);\n      if (statusCode != HttpStatus.SC_OK) {\n        StringBuilder msg = new StringBuilder();\n        msg.append( method.getStatusLine().getReasonPhrase() );\n        msg.append( \"\\n\\n\" );\n        msg.append( method.getStatusText() );\n        msg.append( \"\\n\\n\" );\n        msg.append( \"request: \"+method.getURI() );\n        throw new SolrException(statusCode, java.net.URLDecoder.decode(msg.toString(), \"UTF-8\") );\n      }\n\n      // Read the contents\n      String charset = \"UTF-8\";\n      if( method instanceof HttpMethodBase ) {\n        charset = ((HttpMethodBase)method).getResponseCharSet();\n      }\n      InputStream respBody = method.getResponseBodyAsStream();\n      // Jakarta Commons HTTPClient doesn't handle any\n      // compression natively.  Handle gzip or deflate\n      // here if applicable.\n      if( _allowCompression ) {\n        Header contentEncodingHeader = method.getResponseHeader( \"Content-Encoding\" );\n        if( contentEncodingHeader != null ) {\n          String contentEncoding = contentEncodingHeader.getValue();\n          if( contentEncoding.contains( \"gzip\" ) ) {\n            //log.debug( \"wrapping response in GZIPInputStream\" );\n            respBody = new GZIPInputStream( respBody );\n          }\n          else if( contentEncoding.contains( \"deflate\" ) ) {\n            //log.debug( \"wrapping response in InflaterInputStream\" );\n            respBody = new InflaterInputStream(respBody);\n          }\n        }\n        else {\n          Header contentTypeHeader = method.getResponseHeader( \"Content-Type\" );\n          if( contentTypeHeader != null ) {\n            String contentType = contentTypeHeader.getValue();\n            if( contentType != null ) {\n              if( contentType.startsWith( \"application/x-gzip-compressed\" ) ) {\n                //log.debug( \"wrapping response in GZIPInputStream\" );\n                respBody = new GZIPInputStream( respBody );\n              }\n              else if ( contentType.startsWith(\"application/x-deflate\") ) {\n                //log.debug( \"wrapping response in InflaterInputStream\" );\n                respBody = new InflaterInputStream(respBody);\n              }\n            }\n          }\n        }\n      }\n      return processor.processResponse(respBody, charset);\n    }\n    catch (HttpException e) {\n      throw new SolrServerException( e );\n    }\n    catch (IOException e) {\n      throw new SolrServerException( e );\n    }\n    finally {\n      method.releaseConnection();\n      if(is != null) {\n        is.close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b1605dda5afabdc06fd136fa0dd14ad326e3001","date":1326751633,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer#request(SolrRequest,ResponseParser).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer#request(SolrRequest,ResponseParser).mjava","sourceNew":"  public NamedList<Object> request(final SolrRequest request, ResponseParser processor) throws SolrServerException, IOException {\n    HttpMethod method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if( path == null || !path.startsWith( \"/\" ) ) {\n      path = \"/select\";\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if( parser == null ) {\n      parser = _parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original params\n    ModifiableSolrParams wparams = new ModifiableSolrParams();\n    wparams.set( CommonParams.WT, parser.getWriterType() );\n    wparams.set( CommonParams.VERSION, parser.getVersion());\n    params = SolrParams.wrapDefaults(wparams, params);\n    params = SolrParams.wrapDefaults(_invariantParams, params);\n\n    int tries = _maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't doing intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new GetMethod( _baseURL + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = _baseURL + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            if (streams == null || isMultipart) {\n              PostMethod post = new PostMethod(url);\n              post.getParams().setContentCharset(\"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addRequestHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<Part> parts = new LinkedList<Part>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new StringPart(p, v, \"UTF-8\"));\n                    } else {\n                      post.addParameter(p, v);\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                int i = 0;\n                for (ContentStream content : streams) {\n                  final ContentStream c = content;\n\n                  String charSet = null;\n                  PartSource source = new PartSource() {\n                    @Override\n                    public long getLength() {\n                      return c.getSize();\n                    }\n                      \n                    public String getFileName() {\n                      return c.getName();\n                    }\n\n                    @Override\n                    public InputStream createInputStream() throws IOException {\n                      return c.getStream();\n                    }\n                  };\n                \n                  parts.add(new FilePart(c.getName(), source, \n                                         c.getContentType(), charSet));\n                }\n              }\n              if (parts.size() > 0) {\n                post.setRequestEntity(new MultipartRequestEntity(parts\n                    .toArray(new Part[parts.size()]), post.getParams()));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              PostMethod post = new PostMethod(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setRequestEntity(new RequestEntity() {\n                  public long getContentLength() {\n                    return -1;\n                  }\n\n                  public String getContentType() {\n                    return contentStream[0].getContentType();\n                  }\n\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n\n                  public void writeRequest(OutputStream outputStream) throws IOException {\n                    ((RequestWriter.LazyContentStream) contentStream[0]).writeTo(outputStream);\n                  }\n                }\n                );\n\n              } else {\n                is = contentStream[0].getStream();\n                post.setRequestEntity(new InputStreamRequestEntity(is, contentStream[0].getContentType()));\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          // This is generally safe to retry on\n          method.releaseConnection();\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if( ( tries < 1 ) ) {\n            throw r;\n          }\n          //log.warn( \"Caught: \" + r + \". Retrying...\" );\n        }\n      }\n    }\n    catch( IOException ex ) {\n      throw new SolrServerException(\"error reading streams\", ex );\n    }\n\n    method.setFollowRedirects( _followRedirects );\n    method.addRequestHeader( \"User-Agent\", AGENT );\n    if( _allowCompression ) {\n      method.setRequestHeader( new Header( \"Accept-Encoding\", \"gzip,deflate\" ) );\n    }\n\n    try {\n      // Execute the method.\n      //System.out.println( \"EXECUTE:\"+method.getURI() );\n\n      int statusCode = _httpClient.executeMethod(method);\n      if (statusCode != HttpStatus.SC_OK) {\n        StringBuilder msg = new StringBuilder();\n        msg.append( method.getStatusLine().getReasonPhrase() );\n        msg.append( \"\\n\\n\" );\n        msg.append( method.getStatusText() );\n        msg.append( \"\\n\\n\" );\n        msg.append( \"request: \"+method.getURI() );\n        throw new SolrException(SolrException.ErrorCode.getErrorCode(statusCode), java.net.URLDecoder.decode(msg.toString(), \"UTF-8\") );\n      }\n\n      // Read the contents\n      String charset = \"UTF-8\";\n      if( method instanceof HttpMethodBase ) {\n        charset = ((HttpMethodBase)method).getResponseCharSet();\n      }\n      InputStream respBody = method.getResponseBodyAsStream();\n      // Jakarta Commons HTTPClient doesn't handle any\n      // compression natively.  Handle gzip or deflate\n      // here if applicable.\n      if( _allowCompression ) {\n        Header contentEncodingHeader = method.getResponseHeader( \"Content-Encoding\" );\n        if( contentEncodingHeader != null ) {\n          String contentEncoding = contentEncodingHeader.getValue();\n          if( contentEncoding.contains( \"gzip\" ) ) {\n            //log.debug( \"wrapping response in GZIPInputStream\" );\n            respBody = new GZIPInputStream( respBody );\n          }\n          else if( contentEncoding.contains( \"deflate\" ) ) {\n            //log.debug( \"wrapping response in InflaterInputStream\" );\n            respBody = new InflaterInputStream(respBody);\n          }\n        }\n        else {\n          Header contentTypeHeader = method.getResponseHeader( \"Content-Type\" );\n          if( contentTypeHeader != null ) {\n            String contentType = contentTypeHeader.getValue();\n            if( contentType != null ) {\n              if( contentType.startsWith( \"application/x-gzip-compressed\" ) ) {\n                //log.debug( \"wrapping response in GZIPInputStream\" );\n                respBody = new GZIPInputStream( respBody );\n              }\n              else if ( contentType.startsWith(\"application/x-deflate\") ) {\n                //log.debug( \"wrapping response in InflaterInputStream\" );\n                respBody = new InflaterInputStream(respBody);\n              }\n            }\n          }\n        }\n      }\n      return processor.processResponse(respBody, charset);\n    }\n    catch (HttpException e) {\n      throw new SolrServerException( e );\n    }\n    catch (IOException e) {\n      throw new SolrServerException( e );\n    }\n    finally {\n      method.releaseConnection();\n      if(is != null) {\n        is.close();\n      }\n    }\n  }\n\n","sourceOld":"  public NamedList<Object> request(final SolrRequest request, ResponseParser processor) throws SolrServerException, IOException {\n    HttpMethod method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if( path == null || !path.startsWith( \"/\" ) ) {\n      path = \"/select\";\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if( parser == null ) {\n      parser = _parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original params\n    ModifiableSolrParams wparams = new ModifiableSolrParams();\n    wparams.set( CommonParams.WT, parser.getWriterType() );\n    wparams.set( CommonParams.VERSION, parser.getVersion());\n    params = SolrParams.wrapDefaults(wparams, params);\n    params = SolrParams.wrapDefaults(_invariantParams, params);\n\n    int tries = _maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't doing intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new GetMethod( _baseURL + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = _baseURL + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            if (streams == null || isMultipart) {\n              PostMethod post = new PostMethod(url);\n              post.getParams().setContentCharset(\"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addRequestHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<Part> parts = new LinkedList<Part>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new StringPart(p, v, \"UTF-8\"));\n                    } else {\n                      post.addParameter(p, v);\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                int i = 0;\n                for (ContentStream content : streams) {\n                  final ContentStream c = content;\n\n                  String charSet = null;\n                  PartSource source = new PartSource() {\n                    @Override\n                    public long getLength() {\n                      return c.getSize();\n                    }\n                      \n                    public String getFileName() {\n                      return c.getName();\n                    }\n\n                    @Override\n                    public InputStream createInputStream() throws IOException {\n                      return c.getStream();\n                    }\n                  };\n                \n                  parts.add(new FilePart(c.getName(), source, \n                                         c.getContentType(), charSet));\n                }\n              }\n              if (parts.size() > 0) {\n                post.setRequestEntity(new MultipartRequestEntity(parts\n                    .toArray(new Part[parts.size()]), post.getParams()));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              PostMethod post = new PostMethod(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setRequestEntity(new RequestEntity() {\n                  public long getContentLength() {\n                    return -1;\n                  }\n\n                  public String getContentType() {\n                    return contentStream[0].getContentType();\n                  }\n\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n\n                  public void writeRequest(OutputStream outputStream) throws IOException {\n                    ((RequestWriter.LazyContentStream) contentStream[0]).writeTo(outputStream);\n                  }\n                }\n                );\n\n              } else {\n                is = contentStream[0].getStream();\n                post.setRequestEntity(new InputStreamRequestEntity(is, contentStream[0].getContentType()));\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          // This is generally safe to retry on\n          method.releaseConnection();\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if( ( tries < 1 ) ) {\n            throw r;\n          }\n          //log.warn( \"Caught: \" + r + \". Retrying...\" );\n        }\n      }\n    }\n    catch( IOException ex ) {\n      throw new SolrServerException(\"error reading streams\", ex );\n    }\n\n    method.setFollowRedirects( _followRedirects );\n    method.addRequestHeader( \"User-Agent\", AGENT );\n    if( _allowCompression ) {\n      method.setRequestHeader( new Header( \"Accept-Encoding\", \"gzip,deflate\" ) );\n    }\n\n    try {\n      // Execute the method.\n      //System.out.println( \"EXECUTE:\"+method.getURI() );\n\n      int statusCode = _httpClient.executeMethod(method);\n      if (statusCode != HttpStatus.SC_OK) {\n        StringBuilder msg = new StringBuilder();\n        msg.append( method.getStatusLine().getReasonPhrase() );\n        msg.append( \"\\n\\n\" );\n        msg.append( method.getStatusText() );\n        msg.append( \"\\n\\n\" );\n        msg.append( \"request: \"+method.getURI() );\n        throw new SolrException(statusCode, java.net.URLDecoder.decode(msg.toString(), \"UTF-8\") );\n      }\n\n      // Read the contents\n      String charset = \"UTF-8\";\n      if( method instanceof HttpMethodBase ) {\n        charset = ((HttpMethodBase)method).getResponseCharSet();\n      }\n      InputStream respBody = method.getResponseBodyAsStream();\n      // Jakarta Commons HTTPClient doesn't handle any\n      // compression natively.  Handle gzip or deflate\n      // here if applicable.\n      if( _allowCompression ) {\n        Header contentEncodingHeader = method.getResponseHeader( \"Content-Encoding\" );\n        if( contentEncodingHeader != null ) {\n          String contentEncoding = contentEncodingHeader.getValue();\n          if( contentEncoding.contains( \"gzip\" ) ) {\n            //log.debug( \"wrapping response in GZIPInputStream\" );\n            respBody = new GZIPInputStream( respBody );\n          }\n          else if( contentEncoding.contains( \"deflate\" ) ) {\n            //log.debug( \"wrapping response in InflaterInputStream\" );\n            respBody = new InflaterInputStream(respBody);\n          }\n        }\n        else {\n          Header contentTypeHeader = method.getResponseHeader( \"Content-Type\" );\n          if( contentTypeHeader != null ) {\n            String contentType = contentTypeHeader.getValue();\n            if( contentType != null ) {\n              if( contentType.startsWith( \"application/x-gzip-compressed\" ) ) {\n                //log.debug( \"wrapping response in GZIPInputStream\" );\n                respBody = new GZIPInputStream( respBody );\n              }\n              else if ( contentType.startsWith(\"application/x-deflate\") ) {\n                //log.debug( \"wrapping response in InflaterInputStream\" );\n                respBody = new InflaterInputStream(respBody);\n              }\n            }\n          }\n        }\n      }\n      return processor.processResponse(respBody, charset);\n    }\n    catch (HttpException e) {\n      throw new SolrServerException( e );\n    }\n    catch (IOException e) {\n      throw new SolrServerException( e );\n    }\n    finally {\n      method.releaseConnection();\n      if(is != null) {\n        is.close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"81aa2e433d28e073af6e9fe45ff2ba35bce42450","date":1327600370,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer#request(SolrRequest,ResponseParser).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer#request(SolrRequest,ResponseParser).mjava","sourceNew":"  public NamedList<Object> request(final SolrRequest request, ResponseParser processor) throws SolrServerException, IOException {\n    HttpMethod method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if( path == null || !path.startsWith( \"/\" ) ) {\n      path = \"/select\";\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if( parser == null ) {\n      parser = _parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original params\n    ModifiableSolrParams wparams = new ModifiableSolrParams();\n    wparams.set( CommonParams.WT, parser.getWriterType() );\n    wparams.set( CommonParams.VERSION, parser.getVersion());\n    params = SolrParams.wrapDefaults(wparams, params);\n    params = SolrParams.wrapDefaults(_invariantParams, params);\n\n    int tries = _maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't doing intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new GetMethod( _baseURL + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = _baseURL + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            if (streams == null || isMultipart) {\n              PostMethod post = new PostMethod(url);\n              post.getParams().setContentCharset(\"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addRequestHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<Part> parts = new LinkedList<Part>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new StringPart(p, v, \"UTF-8\"));\n                    } else {\n                      post.addParameter(p, v);\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                int i = 0;\n                for (ContentStream content : streams) {\n                  final ContentStream c = content;\n\n                  String charSet = null;\n                  PartSource source = new PartSource() {\n                    @Override\n                    public long getLength() {\n                      return c.getSize();\n                    }\n                      \n                    public String getFileName() {\n                      return c.getName();\n                    }\n\n                    @Override\n                    public InputStream createInputStream() throws IOException {\n                      return c.getStream();\n                    }\n                  };\n                \n                  parts.add(new FilePart(c.getName(), source, \n                                         c.getContentType(), charSet));\n                }\n              }\n              if (parts.size() > 0) {\n                post.setRequestEntity(new MultipartRequestEntity(parts\n                    .toArray(new Part[parts.size()]), post.getParams()));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              PostMethod post = new PostMethod(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setRequestEntity(new RequestEntity() {\n                  public long getContentLength() {\n                    return -1;\n                  }\n\n                  public String getContentType() {\n                    return contentStream[0].getContentType();\n                  }\n\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n\n                  public void writeRequest(OutputStream outputStream) throws IOException {\n                    ((RequestWriter.LazyContentStream) contentStream[0]).writeTo(outputStream);\n                  }\n                }\n                );\n\n              } else {\n                is = contentStream[0].getStream();\n                post.setRequestEntity(new InputStreamRequestEntity(is, contentStream[0].getContentType()));\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          // This is generally safe to retry on\n          method.releaseConnection();\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if( ( tries < 1 ) ) {\n            throw r;\n          }\n          //log.warn( \"Caught: \" + r + \". Retrying...\" );\n        }\n      }\n    }\n    catch( IOException ex ) {\n      throw new SolrServerException(\"error reading streams\", ex );\n    }\n\n    method.setFollowRedirects( _followRedirects );\n    method.addRequestHeader( \"User-Agent\", AGENT );\n    if( _allowCompression ) {\n      method.setRequestHeader( new Header( \"Accept-Encoding\", \"gzip,deflate\" ) );\n    }\n\n    try {\n      // Execute the method.\n      //System.out.println( \"EXECUTE:\"+method.getURI() );\n\n      int statusCode = _httpClient.executeMethod(method);\n      if (statusCode != HttpStatus.SC_OK) {\n        StringBuilder msg = new StringBuilder();\n        msg.append( method.getStatusLine().getReasonPhrase() );\n        msg.append( \"\\n\\n\" );\n        msg.append( method.getStatusText() );\n        msg.append( \"\\n\\n\" );\n        msg.append( \"request: \"+method.getURI() );\n        throw new SolrException(SolrException.ErrorCode.getErrorCode(statusCode), java.net.URLDecoder.decode(msg.toString(), \"UTF-8\") );\n      }\n\n      // Read the contents\n      String charset = \"UTF-8\";\n      if( method instanceof HttpMethodBase ) {\n        charset = ((HttpMethodBase)method).getResponseCharSet();\n      }\n      InputStream respBody = method.getResponseBodyAsStream();\n      // Jakarta Commons HTTPClient doesn't handle any\n      // compression natively.  Handle gzip or deflate\n      // here if applicable.\n      if( _allowCompression ) {\n        Header contentEncodingHeader = method.getResponseHeader( \"Content-Encoding\" );\n        if( contentEncodingHeader != null ) {\n          String contentEncoding = contentEncodingHeader.getValue();\n          if( contentEncoding.contains( \"gzip\" ) ) {\n            //log.debug( \"wrapping response in GZIPInputStream\" );\n            respBody = new GZIPInputStream( respBody );\n          }\n          else if( contentEncoding.contains( \"deflate\" ) ) {\n            //log.debug( \"wrapping response in InflaterInputStream\" );\n            respBody = new InflaterInputStream(respBody);\n          }\n        }\n        else {\n          Header contentTypeHeader = method.getResponseHeader( \"Content-Type\" );\n          if( contentTypeHeader != null ) {\n            String contentType = contentTypeHeader.getValue();\n            if( contentType != null ) {\n              if( contentType.startsWith( \"application/x-gzip-compressed\" ) ) {\n                //log.debug( \"wrapping response in GZIPInputStream\" );\n                respBody = new GZIPInputStream( respBody );\n              }\n              else if ( contentType.startsWith(\"application/x-deflate\") ) {\n                //log.debug( \"wrapping response in InflaterInputStream\" );\n                respBody = new InflaterInputStream(respBody);\n              }\n            }\n          }\n        }\n      }\n      return processor.processResponse(respBody, charset);\n    }\n    catch (HttpException e) {\n      throw new SolrServerException(getBaseURL(), e);\n    }\n    catch (IOException e) {\n      throw new SolrServerException(getBaseURL(), e);\n    }\n    finally {\n      method.releaseConnection();\n      if(is != null) {\n        is.close();\n      }\n    }\n  }\n\n","sourceOld":"  public NamedList<Object> request(final SolrRequest request, ResponseParser processor) throws SolrServerException, IOException {\n    HttpMethod method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if( path == null || !path.startsWith( \"/\" ) ) {\n      path = \"/select\";\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if( parser == null ) {\n      parser = _parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original params\n    ModifiableSolrParams wparams = new ModifiableSolrParams();\n    wparams.set( CommonParams.WT, parser.getWriterType() );\n    wparams.set( CommonParams.VERSION, parser.getVersion());\n    params = SolrParams.wrapDefaults(wparams, params);\n    params = SolrParams.wrapDefaults(_invariantParams, params);\n\n    int tries = _maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't doing intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new GetMethod( _baseURL + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = _baseURL + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            if (streams == null || isMultipart) {\n              PostMethod post = new PostMethod(url);\n              post.getParams().setContentCharset(\"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addRequestHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<Part> parts = new LinkedList<Part>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new StringPart(p, v, \"UTF-8\"));\n                    } else {\n                      post.addParameter(p, v);\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                int i = 0;\n                for (ContentStream content : streams) {\n                  final ContentStream c = content;\n\n                  String charSet = null;\n                  PartSource source = new PartSource() {\n                    @Override\n                    public long getLength() {\n                      return c.getSize();\n                    }\n                      \n                    public String getFileName() {\n                      return c.getName();\n                    }\n\n                    @Override\n                    public InputStream createInputStream() throws IOException {\n                      return c.getStream();\n                    }\n                  };\n                \n                  parts.add(new FilePart(c.getName(), source, \n                                         c.getContentType(), charSet));\n                }\n              }\n              if (parts.size() > 0) {\n                post.setRequestEntity(new MultipartRequestEntity(parts\n                    .toArray(new Part[parts.size()]), post.getParams()));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              PostMethod post = new PostMethod(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setRequestEntity(new RequestEntity() {\n                  public long getContentLength() {\n                    return -1;\n                  }\n\n                  public String getContentType() {\n                    return contentStream[0].getContentType();\n                  }\n\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n\n                  public void writeRequest(OutputStream outputStream) throws IOException {\n                    ((RequestWriter.LazyContentStream) contentStream[0]).writeTo(outputStream);\n                  }\n                }\n                );\n\n              } else {\n                is = contentStream[0].getStream();\n                post.setRequestEntity(new InputStreamRequestEntity(is, contentStream[0].getContentType()));\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          // This is generally safe to retry on\n          method.releaseConnection();\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if( ( tries < 1 ) ) {\n            throw r;\n          }\n          //log.warn( \"Caught: \" + r + \". Retrying...\" );\n        }\n      }\n    }\n    catch( IOException ex ) {\n      throw new SolrServerException(\"error reading streams\", ex );\n    }\n\n    method.setFollowRedirects( _followRedirects );\n    method.addRequestHeader( \"User-Agent\", AGENT );\n    if( _allowCompression ) {\n      method.setRequestHeader( new Header( \"Accept-Encoding\", \"gzip,deflate\" ) );\n    }\n\n    try {\n      // Execute the method.\n      //System.out.println( \"EXECUTE:\"+method.getURI() );\n\n      int statusCode = _httpClient.executeMethod(method);\n      if (statusCode != HttpStatus.SC_OK) {\n        StringBuilder msg = new StringBuilder();\n        msg.append( method.getStatusLine().getReasonPhrase() );\n        msg.append( \"\\n\\n\" );\n        msg.append( method.getStatusText() );\n        msg.append( \"\\n\\n\" );\n        msg.append( \"request: \"+method.getURI() );\n        throw new SolrException(SolrException.ErrorCode.getErrorCode(statusCode), java.net.URLDecoder.decode(msg.toString(), \"UTF-8\") );\n      }\n\n      // Read the contents\n      String charset = \"UTF-8\";\n      if( method instanceof HttpMethodBase ) {\n        charset = ((HttpMethodBase)method).getResponseCharSet();\n      }\n      InputStream respBody = method.getResponseBodyAsStream();\n      // Jakarta Commons HTTPClient doesn't handle any\n      // compression natively.  Handle gzip or deflate\n      // here if applicable.\n      if( _allowCompression ) {\n        Header contentEncodingHeader = method.getResponseHeader( \"Content-Encoding\" );\n        if( contentEncodingHeader != null ) {\n          String contentEncoding = contentEncodingHeader.getValue();\n          if( contentEncoding.contains( \"gzip\" ) ) {\n            //log.debug( \"wrapping response in GZIPInputStream\" );\n            respBody = new GZIPInputStream( respBody );\n          }\n          else if( contentEncoding.contains( \"deflate\" ) ) {\n            //log.debug( \"wrapping response in InflaterInputStream\" );\n            respBody = new InflaterInputStream(respBody);\n          }\n        }\n        else {\n          Header contentTypeHeader = method.getResponseHeader( \"Content-Type\" );\n          if( contentTypeHeader != null ) {\n            String contentType = contentTypeHeader.getValue();\n            if( contentType != null ) {\n              if( contentType.startsWith( \"application/x-gzip-compressed\" ) ) {\n                //log.debug( \"wrapping response in GZIPInputStream\" );\n                respBody = new GZIPInputStream( respBody );\n              }\n              else if ( contentType.startsWith(\"application/x-deflate\") ) {\n                //log.debug( \"wrapping response in InflaterInputStream\" );\n                respBody = new InflaterInputStream(respBody);\n              }\n            }\n          }\n        }\n      }\n      return processor.processResponse(respBody, charset);\n    }\n    catch (HttpException e) {\n      throw new SolrServerException( e );\n    }\n    catch (IOException e) {\n      throw new SolrServerException( e );\n    }\n    finally {\n      method.releaseConnection();\n      if(is != null) {\n        is.close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"78a55f24d9b493c2a1cecf79f1d78279062b545b","date":1327688152,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer#request(SolrRequest,ResponseParser).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer#request(SolrRequest,ResponseParser).mjava","sourceNew":"  public NamedList<Object> request(final SolrRequest request, ResponseParser processor) throws SolrServerException, IOException {\n    HttpMethod method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if( path == null || !path.startsWith( \"/\" ) ) {\n      path = \"/select\";\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if( parser == null ) {\n      parser = _parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original params\n    ModifiableSolrParams wparams = new ModifiableSolrParams();\n    wparams.set( CommonParams.WT, parser.getWriterType() );\n    wparams.set( CommonParams.VERSION, parser.getVersion());\n    params = SolrParams.wrapDefaults(wparams, params);\n    params = SolrParams.wrapDefaults(_invariantParams, params);\n\n    int tries = _maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't doing intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new GetMethod( _baseURL + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = _baseURL + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            if (streams == null || isMultipart) {\n              PostMethod post = new PostMethod(url);\n              post.getParams().setContentCharset(\"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addRequestHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<Part> parts = new LinkedList<Part>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new StringPart(p, v, \"UTF-8\"));\n                    } else {\n                      post.addParameter(p, v);\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                int i = 0;\n                for (ContentStream content : streams) {\n                  final ContentStream c = content;\n\n                  String charSet = null;\n                  PartSource source = new PartSource() {\n                    @Override\n                    public long getLength() {\n                      return c.getSize();\n                    }\n                      \n                    public String getFileName() {\n                      return c.getName();\n                    }\n\n                    @Override\n                    public InputStream createInputStream() throws IOException {\n                      return c.getStream();\n                    }\n                  };\n                \n                  parts.add(new FilePart(c.getName(), source, \n                                         c.getContentType(), charSet));\n                }\n              }\n              if (parts.size() > 0) {\n                post.setRequestEntity(new MultipartRequestEntity(parts\n                    .toArray(new Part[parts.size()]), post.getParams()));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              PostMethod post = new PostMethod(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setRequestEntity(new RequestEntity() {\n                  public long getContentLength() {\n                    return -1;\n                  }\n\n                  public String getContentType() {\n                    return contentStream[0].getContentType();\n                  }\n\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n\n                  public void writeRequest(OutputStream outputStream) throws IOException {\n                    ((RequestWriter.LazyContentStream) contentStream[0]).writeTo(outputStream);\n                  }\n                }\n                );\n\n              } else {\n                is = contentStream[0].getStream();\n                post.setRequestEntity(new InputStreamRequestEntity(is, contentStream[0].getContentType()));\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          // This is generally safe to retry on\n          method.releaseConnection();\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if( ( tries < 1 ) ) {\n            throw r;\n          }\n          //log.warn( \"Caught: \" + r + \". Retrying...\" );\n        }\n      }\n    }\n    catch( IOException ex ) {\n      throw new SolrServerException(\"error reading streams\", ex );\n    }\n\n    method.setFollowRedirects( _followRedirects );\n    method.addRequestHeader( \"User-Agent\", AGENT );\n    if( _allowCompression ) {\n      method.setRequestHeader( new Header( \"Accept-Encoding\", \"gzip,deflate\" ) );\n    }\n\n    try {\n      // Execute the method.\n      //System.out.println( \"EXECUTE:\"+method.getURI() );\n\n      int statusCode = _httpClient.executeMethod(method);\n      if (statusCode != HttpStatus.SC_OK) {\n        StringBuilder msg = new StringBuilder();\n        msg.append( method.getStatusLine().getReasonPhrase() );\n        msg.append( \"\\n\\n\" );\n        msg.append( method.getStatusText() );\n        msg.append( \"\\n\\n\" );\n        msg.append( \"request: \"+method.getURI() );\n        throw new SolrException(SolrException.ErrorCode.getErrorCode(statusCode), java.net.URLDecoder.decode(msg.toString(), \"UTF-8\") );\n      }\n\n      // Read the contents\n      String charset = \"UTF-8\";\n      if( method instanceof HttpMethodBase ) {\n        charset = ((HttpMethodBase)method).getResponseCharSet();\n      }\n      InputStream respBody = method.getResponseBodyAsStream();\n      // Jakarta Commons HTTPClient doesn't handle any\n      // compression natively.  Handle gzip or deflate\n      // here if applicable.\n      if( _allowCompression ) {\n        Header contentEncodingHeader = method.getResponseHeader( \"Content-Encoding\" );\n        if( contentEncodingHeader != null ) {\n          String contentEncoding = contentEncodingHeader.getValue();\n          if( contentEncoding.contains( \"gzip\" ) ) {\n            //log.debug( \"wrapping response in GZIPInputStream\" );\n            respBody = new GZIPInputStream( respBody );\n          }\n          else if( contentEncoding.contains( \"deflate\" ) ) {\n            //log.debug( \"wrapping response in InflaterInputStream\" );\n            respBody = new InflaterInputStream(respBody);\n          }\n        }\n        else {\n          Header contentTypeHeader = method.getResponseHeader( \"Content-Type\" );\n          if( contentTypeHeader != null ) {\n            String contentType = contentTypeHeader.getValue();\n            if( contentType != null ) {\n              if( contentType.startsWith( \"application/x-gzip-compressed\" ) ) {\n                //log.debug( \"wrapping response in GZIPInputStream\" );\n                respBody = new GZIPInputStream( respBody );\n              }\n              else if ( contentType.startsWith(\"application/x-deflate\") ) {\n                //log.debug( \"wrapping response in InflaterInputStream\" );\n                respBody = new InflaterInputStream(respBody);\n              }\n            }\n          }\n        }\n      }\n      return processor.processResponse(respBody, charset);\n    }\n    catch (HttpException e) {\n      throw new SolrServerException(getBaseURL(), e);\n    }\n    catch (IOException e) {\n      throw new SolrServerException(getBaseURL(), e);\n    }\n    finally {\n      method.releaseConnection();\n      if(is != null) {\n        is.close();\n      }\n    }\n  }\n\n","sourceOld":"  public NamedList<Object> request(final SolrRequest request, ResponseParser processor) throws SolrServerException, IOException {\n    HttpMethod method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if( path == null || !path.startsWith( \"/\" ) ) {\n      path = \"/select\";\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if( parser == null ) {\n      parser = _parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original params\n    ModifiableSolrParams wparams = new ModifiableSolrParams();\n    wparams.set( CommonParams.WT, parser.getWriterType() );\n    wparams.set( CommonParams.VERSION, parser.getVersion());\n    params = SolrParams.wrapDefaults(wparams, params);\n    params = SolrParams.wrapDefaults(_invariantParams, params);\n\n    int tries = _maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't doing intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new GetMethod( _baseURL + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = _baseURL + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            if (streams == null || isMultipart) {\n              PostMethod post = new PostMethod(url);\n              post.getParams().setContentCharset(\"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addRequestHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<Part> parts = new LinkedList<Part>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new StringPart(p, v, \"UTF-8\"));\n                    } else {\n                      post.addParameter(p, v);\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                int i = 0;\n                for (ContentStream content : streams) {\n                  final ContentStream c = content;\n\n                  String charSet = null;\n                  PartSource source = new PartSource() {\n                    @Override\n                    public long getLength() {\n                      return c.getSize();\n                    }\n                      \n                    public String getFileName() {\n                      return c.getName();\n                    }\n\n                    @Override\n                    public InputStream createInputStream() throws IOException {\n                      return c.getStream();\n                    }\n                  };\n                \n                  parts.add(new FilePart(c.getName(), source, \n                                         c.getContentType(), charSet));\n                }\n              }\n              if (parts.size() > 0) {\n                post.setRequestEntity(new MultipartRequestEntity(parts\n                    .toArray(new Part[parts.size()]), post.getParams()));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              PostMethod post = new PostMethod(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setRequestEntity(new RequestEntity() {\n                  public long getContentLength() {\n                    return -1;\n                  }\n\n                  public String getContentType() {\n                    return contentStream[0].getContentType();\n                  }\n\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n\n                  public void writeRequest(OutputStream outputStream) throws IOException {\n                    ((RequestWriter.LazyContentStream) contentStream[0]).writeTo(outputStream);\n                  }\n                }\n                );\n\n              } else {\n                is = contentStream[0].getStream();\n                post.setRequestEntity(new InputStreamRequestEntity(is, contentStream[0].getContentType()));\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          // This is generally safe to retry on\n          method.releaseConnection();\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if( ( tries < 1 ) ) {\n            throw r;\n          }\n          //log.warn( \"Caught: \" + r + \". Retrying...\" );\n        }\n      }\n    }\n    catch( IOException ex ) {\n      throw new SolrServerException(\"error reading streams\", ex );\n    }\n\n    method.setFollowRedirects( _followRedirects );\n    method.addRequestHeader( \"User-Agent\", AGENT );\n    if( _allowCompression ) {\n      method.setRequestHeader( new Header( \"Accept-Encoding\", \"gzip,deflate\" ) );\n    }\n\n    try {\n      // Execute the method.\n      //System.out.println( \"EXECUTE:\"+method.getURI() );\n\n      int statusCode = _httpClient.executeMethod(method);\n      if (statusCode != HttpStatus.SC_OK) {\n        StringBuilder msg = new StringBuilder();\n        msg.append( method.getStatusLine().getReasonPhrase() );\n        msg.append( \"\\n\\n\" );\n        msg.append( method.getStatusText() );\n        msg.append( \"\\n\\n\" );\n        msg.append( \"request: \"+method.getURI() );\n        throw new SolrException(SolrException.ErrorCode.getErrorCode(statusCode), java.net.URLDecoder.decode(msg.toString(), \"UTF-8\") );\n      }\n\n      // Read the contents\n      String charset = \"UTF-8\";\n      if( method instanceof HttpMethodBase ) {\n        charset = ((HttpMethodBase)method).getResponseCharSet();\n      }\n      InputStream respBody = method.getResponseBodyAsStream();\n      // Jakarta Commons HTTPClient doesn't handle any\n      // compression natively.  Handle gzip or deflate\n      // here if applicable.\n      if( _allowCompression ) {\n        Header contentEncodingHeader = method.getResponseHeader( \"Content-Encoding\" );\n        if( contentEncodingHeader != null ) {\n          String contentEncoding = contentEncodingHeader.getValue();\n          if( contentEncoding.contains( \"gzip\" ) ) {\n            //log.debug( \"wrapping response in GZIPInputStream\" );\n            respBody = new GZIPInputStream( respBody );\n          }\n          else if( contentEncoding.contains( \"deflate\" ) ) {\n            //log.debug( \"wrapping response in InflaterInputStream\" );\n            respBody = new InflaterInputStream(respBody);\n          }\n        }\n        else {\n          Header contentTypeHeader = method.getResponseHeader( \"Content-Type\" );\n          if( contentTypeHeader != null ) {\n            String contentType = contentTypeHeader.getValue();\n            if( contentType != null ) {\n              if( contentType.startsWith( \"application/x-gzip-compressed\" ) ) {\n                //log.debug( \"wrapping response in GZIPInputStream\" );\n                respBody = new GZIPInputStream( respBody );\n              }\n              else if ( contentType.startsWith(\"application/x-deflate\") ) {\n                //log.debug( \"wrapping response in InflaterInputStream\" );\n                respBody = new InflaterInputStream(respBody);\n              }\n            }\n          }\n        }\n      }\n      return processor.processResponse(respBody, charset);\n    }\n    catch (HttpException e) {\n      throw new SolrServerException( e );\n    }\n    catch (IOException e) {\n      throw new SolrServerException( e );\n    }\n    finally {\n      method.releaseConnection();\n      if(is != null) {\n        is.close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fd92b8bcc88e969302510acf77bd6970da3994c4","date":1327839530,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer#request(SolrRequest,ResponseParser).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer#request(SolrRequest,ResponseParser).mjava","sourceNew":"  public NamedList<Object> request(final SolrRequest request, ResponseParser processor) throws SolrServerException, IOException {\n    HttpMethod method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if( path == null || !path.startsWith( \"/\" ) ) {\n      path = \"/select\";\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if( parser == null ) {\n      parser = _parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original params\n    ModifiableSolrParams wparams = new ModifiableSolrParams();\n    wparams.set( CommonParams.WT, parser.getWriterType() );\n    wparams.set( CommonParams.VERSION, parser.getVersion());\n    params = SolrParams.wrapDefaults(wparams, params);\n    params = SolrParams.wrapDefaults(_invariantParams, params);\n\n    int tries = _maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't doing intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new GetMethod( _baseURL + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = _baseURL + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            if (streams == null || isMultipart) {\n              PostMethod post = new PostMethod(url);\n              post.getParams().setContentCharset(\"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addRequestHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<Part> parts = new LinkedList<Part>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new StringPart(p, v, \"UTF-8\"));\n                    } else {\n                      post.addParameter(p, v);\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                int i = 0;\n                for (ContentStream content : streams) {\n                  final ContentStream c = content;\n\n                  String charSet = null;\n                  PartSource source = new PartSource() {\n                    @Override\n                    public long getLength() {\n                      return c.getSize();\n                    }\n                      \n                    public String getFileName() {\n                      return c.getName();\n                    }\n\n                    @Override\n                    public InputStream createInputStream() throws IOException {\n                      return c.getStream();\n                    }\n                  };\n                \n                  parts.add(new FilePart(c.getName(), source, \n                                         c.getContentType(), charSet));\n                }\n              }\n              if (parts.size() > 0) {\n                post.setRequestEntity(new MultipartRequestEntity(parts\n                    .toArray(new Part[parts.size()]), post.getParams()));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              PostMethod post = new PostMethod(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setRequestEntity(new RequestEntity() {\n                  public long getContentLength() {\n                    return -1;\n                  }\n\n                  public String getContentType() {\n                    return contentStream[0].getContentType();\n                  }\n\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n\n                  public void writeRequest(OutputStream outputStream) throws IOException {\n                    ((RequestWriter.LazyContentStream) contentStream[0]).writeTo(outputStream);\n                  }\n                }\n                );\n\n              } else {\n                is = contentStream[0].getStream();\n                post.setRequestEntity(new InputStreamRequestEntity(is, contentStream[0].getContentType()));\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          // This is generally safe to retry on\n          method.releaseConnection();\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if( ( tries < 1 ) ) {\n            throw r;\n          }\n          //log.warn( \"Caught: \" + r + \". Retrying...\" );\n        }\n      }\n    }\n    catch( IOException ex ) {\n      throw new SolrServerException(\"error reading streams\", ex );\n    }\n\n    method.setFollowRedirects( _followRedirects );\n    method.addRequestHeader( \"User-Agent\", AGENT );\n    if( _allowCompression ) {\n      method.setRequestHeader( new Header( \"Accept-Encoding\", \"gzip,deflate\" ) );\n    }\n\n    try {\n      // Execute the method.\n      //System.out.println( \"EXECUTE:\"+method.getURI() );\n\n      int statusCode = _httpClient.executeMethod(method);\n      if (statusCode != HttpStatus.SC_OK) {\n        StringBuilder msg = new StringBuilder();\n        msg.append( method.getStatusLine().getReasonPhrase() );\n        msg.append( \"\\n\\n\" );\n        msg.append( method.getStatusText() );\n        msg.append( \"\\n\\n\" );\n        msg.append( \"request: \"+method.getURI() );\n        throw new SolrException(SolrException.ErrorCode.getErrorCode(statusCode), java.net.URLDecoder.decode(msg.toString(), \"UTF-8\") );\n      }\n\n      // Read the contents\n      String charset = \"UTF-8\";\n      if( method instanceof HttpMethodBase ) {\n        charset = ((HttpMethodBase)method).getResponseCharSet();\n      }\n      InputStream respBody = method.getResponseBodyAsStream();\n      // Jakarta Commons HTTPClient doesn't handle any\n      // compression natively.  Handle gzip or deflate\n      // here if applicable.\n      if( _allowCompression ) {\n        Header contentEncodingHeader = method.getResponseHeader( \"Content-Encoding\" );\n        if( contentEncodingHeader != null ) {\n          String contentEncoding = contentEncodingHeader.getValue();\n          if( contentEncoding.contains( \"gzip\" ) ) {\n            //log.debug( \"wrapping response in GZIPInputStream\" );\n            respBody = new GZIPInputStream( respBody );\n          }\n          else if( contentEncoding.contains( \"deflate\" ) ) {\n            //log.debug( \"wrapping response in InflaterInputStream\" );\n            respBody = new InflaterInputStream(respBody);\n          }\n        }\n        else {\n          Header contentTypeHeader = method.getResponseHeader( \"Content-Type\" );\n          if( contentTypeHeader != null ) {\n            String contentType = contentTypeHeader.getValue();\n            if( contentType != null ) {\n              if( contentType.startsWith( \"application/x-gzip-compressed\" ) ) {\n                //log.debug( \"wrapping response in GZIPInputStream\" );\n                respBody = new GZIPInputStream( respBody );\n              }\n              else if ( contentType.startsWith(\"application/x-deflate\") ) {\n                //log.debug( \"wrapping response in InflaterInputStream\" );\n                respBody = new InflaterInputStream(respBody);\n              }\n            }\n          }\n        }\n      }\n      return processor.processResponse(respBody, charset);\n    }\n    catch (HttpException e) {\n      throw new SolrServerException(getBaseURL(), e);\n    }\n    catch (IOException e) {\n      throw new SolrServerException(getBaseURL(), e);\n    }\n    finally {\n      method.releaseConnection();\n      if(is != null) {\n        is.close();\n      }\n    }\n  }\n\n","sourceOld":"  public NamedList<Object> request(final SolrRequest request, ResponseParser processor) throws SolrServerException, IOException {\n    HttpMethod method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if( path == null || !path.startsWith( \"/\" ) ) {\n      path = \"/select\";\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if( parser == null ) {\n      parser = _parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original params\n    ModifiableSolrParams wparams = new ModifiableSolrParams();\n    wparams.set( CommonParams.WT, parser.getWriterType() );\n    wparams.set( CommonParams.VERSION, parser.getVersion());\n    params = SolrParams.wrapDefaults(wparams, params);\n    params = SolrParams.wrapDefaults(_invariantParams, params);\n\n    int tries = _maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't doing intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new GetMethod( _baseURL + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = _baseURL + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            if (streams == null || isMultipart) {\n              PostMethod post = new PostMethod(url);\n              post.getParams().setContentCharset(\"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addRequestHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<Part> parts = new LinkedList<Part>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new StringPart(p, v, \"UTF-8\"));\n                    } else {\n                      post.addParameter(p, v);\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                int i = 0;\n                for (ContentStream content : streams) {\n                  final ContentStream c = content;\n\n                  String charSet = null;\n                  PartSource source = new PartSource() {\n                    @Override\n                    public long getLength() {\n                      return c.getSize();\n                    }\n                      \n                    public String getFileName() {\n                      return c.getName();\n                    }\n\n                    @Override\n                    public InputStream createInputStream() throws IOException {\n                      return c.getStream();\n                    }\n                  };\n                \n                  parts.add(new FilePart(c.getName(), source, \n                                         c.getContentType(), charSet));\n                }\n              }\n              if (parts.size() > 0) {\n                post.setRequestEntity(new MultipartRequestEntity(parts\n                    .toArray(new Part[parts.size()]), post.getParams()));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              PostMethod post = new PostMethod(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setRequestEntity(new RequestEntity() {\n                  public long getContentLength() {\n                    return -1;\n                  }\n\n                  public String getContentType() {\n                    return contentStream[0].getContentType();\n                  }\n\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n\n                  public void writeRequest(OutputStream outputStream) throws IOException {\n                    ((RequestWriter.LazyContentStream) contentStream[0]).writeTo(outputStream);\n                  }\n                }\n                );\n\n              } else {\n                is = contentStream[0].getStream();\n                post.setRequestEntity(new InputStreamRequestEntity(is, contentStream[0].getContentType()));\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          // This is generally safe to retry on\n          method.releaseConnection();\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if( ( tries < 1 ) ) {\n            throw r;\n          }\n          //log.warn( \"Caught: \" + r + \". Retrying...\" );\n        }\n      }\n    }\n    catch( IOException ex ) {\n      throw new SolrServerException(\"error reading streams\", ex );\n    }\n\n    method.setFollowRedirects( _followRedirects );\n    method.addRequestHeader( \"User-Agent\", AGENT );\n    if( _allowCompression ) {\n      method.setRequestHeader( new Header( \"Accept-Encoding\", \"gzip,deflate\" ) );\n    }\n\n    try {\n      // Execute the method.\n      //System.out.println( \"EXECUTE:\"+method.getURI() );\n\n      int statusCode = _httpClient.executeMethod(method);\n      if (statusCode != HttpStatus.SC_OK) {\n        StringBuilder msg = new StringBuilder();\n        msg.append( method.getStatusLine().getReasonPhrase() );\n        msg.append( \"\\n\\n\" );\n        msg.append( method.getStatusText() );\n        msg.append( \"\\n\\n\" );\n        msg.append( \"request: \"+method.getURI() );\n        throw new SolrException(SolrException.ErrorCode.getErrorCode(statusCode), java.net.URLDecoder.decode(msg.toString(), \"UTF-8\") );\n      }\n\n      // Read the contents\n      String charset = \"UTF-8\";\n      if( method instanceof HttpMethodBase ) {\n        charset = ((HttpMethodBase)method).getResponseCharSet();\n      }\n      InputStream respBody = method.getResponseBodyAsStream();\n      // Jakarta Commons HTTPClient doesn't handle any\n      // compression natively.  Handle gzip or deflate\n      // here if applicable.\n      if( _allowCompression ) {\n        Header contentEncodingHeader = method.getResponseHeader( \"Content-Encoding\" );\n        if( contentEncodingHeader != null ) {\n          String contentEncoding = contentEncodingHeader.getValue();\n          if( contentEncoding.contains( \"gzip\" ) ) {\n            //log.debug( \"wrapping response in GZIPInputStream\" );\n            respBody = new GZIPInputStream( respBody );\n          }\n          else if( contentEncoding.contains( \"deflate\" ) ) {\n            //log.debug( \"wrapping response in InflaterInputStream\" );\n            respBody = new InflaterInputStream(respBody);\n          }\n        }\n        else {\n          Header contentTypeHeader = method.getResponseHeader( \"Content-Type\" );\n          if( contentTypeHeader != null ) {\n            String contentType = contentTypeHeader.getValue();\n            if( contentType != null ) {\n              if( contentType.startsWith( \"application/x-gzip-compressed\" ) ) {\n                //log.debug( \"wrapping response in GZIPInputStream\" );\n                respBody = new GZIPInputStream( respBody );\n              }\n              else if ( contentType.startsWith(\"application/x-deflate\") ) {\n                //log.debug( \"wrapping response in InflaterInputStream\" );\n                respBody = new InflaterInputStream(respBody);\n              }\n            }\n          }\n        }\n      }\n      return processor.processResponse(respBody, charset);\n    }\n    catch (HttpException e) {\n      throw new SolrServerException( e );\n    }\n    catch (IOException e) {\n      throw new SolrServerException( e );\n    }\n    finally {\n      method.releaseConnection();\n      if(is != null) {\n        is.close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ee6a6e59a364f15fd1651db1b6ba39acbf577895","date":1330386502,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer#request(SolrRequest,ResponseParser).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer#request(SolrRequest,ResponseParser).mjava","sourceNew":"  public NamedList<Object> request(final SolrRequest request, ResponseParser processor) throws SolrServerException, IOException {\n    HttpMethod method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if( path == null || !path.startsWith( \"/\" ) ) {\n      path = \"/select\";\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if( parser == null ) {\n      parser = _parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    wparams.set( CommonParams.WT, parser.getWriterType() );\n    wparams.set( CommonParams.VERSION, parser.getVersion());\n    if (_invariantParams != null) {\n      wparams.add( _invariantParams );\n    }\n    params = wparams;\n\n    int tries = _maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't doing intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new GetMethod( _baseURL + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = _baseURL + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            if (streams == null || isMultipart) {\n              PostMethod post = new PostMethod(url);\n              post.getParams().setContentCharset(\"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addRequestHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<Part> parts = new LinkedList<Part>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new StringPart(p, v, \"UTF-8\"));\n                    } else {\n                      post.addParameter(p, v);\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                int i = 0;\n                for (ContentStream content : streams) {\n                  final ContentStream c = content;\n\n                  String charSet = null;\n                  PartSource source = new PartSource() {\n                    @Override\n                    public long getLength() {\n                      return c.getSize();\n                    }\n                      \n                    public String getFileName() {\n                      return c.getName();\n                    }\n\n                    @Override\n                    public InputStream createInputStream() throws IOException {\n                      return c.getStream();\n                    }\n                  };\n                \n                  parts.add(new FilePart(c.getName(), source, \n                                         c.getContentType(), charSet));\n                }\n              }\n              if (parts.size() > 0) {\n                post.setRequestEntity(new MultipartRequestEntity(parts\n                    .toArray(new Part[parts.size()]), post.getParams()));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              PostMethod post = new PostMethod(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setRequestEntity(new RequestEntity() {\n                  public long getContentLength() {\n                    return -1;\n                  }\n\n                  public String getContentType() {\n                    return contentStream[0].getContentType();\n                  }\n\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n\n                  public void writeRequest(OutputStream outputStream) throws IOException {\n                    ((RequestWriter.LazyContentStream) contentStream[0]).writeTo(outputStream);\n                  }\n                }\n                );\n\n              } else {\n                is = contentStream[0].getStream();\n                post.setRequestEntity(new InputStreamRequestEntity(is, contentStream[0].getContentType()));\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          // This is generally safe to retry on\n          method.releaseConnection();\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if( ( tries < 1 ) ) {\n            throw r;\n          }\n          //log.warn( \"Caught: \" + r + \". Retrying...\" );\n        }\n      }\n    }\n    catch( IOException ex ) {\n      throw new SolrServerException(\"error reading streams\", ex );\n    }\n\n    method.setFollowRedirects( _followRedirects );\n    method.addRequestHeader( \"User-Agent\", AGENT );\n    if( _allowCompression ) {\n      method.setRequestHeader( new Header( \"Accept-Encoding\", \"gzip,deflate\" ) );\n    }\n\n    try {\n      // Execute the method.\n      //System.out.println( \"EXECUTE:\"+method.getURI() );\n\n      int statusCode = _httpClient.executeMethod(method);\n      if (statusCode != HttpStatus.SC_OK) {\n        StringBuilder msg = new StringBuilder();\n        msg.append( method.getStatusLine().getReasonPhrase() );\n        msg.append( \"\\n\\n\" );\n        msg.append( method.getStatusText() );\n        msg.append( \"\\n\\n\" );\n        msg.append( \"request: \"+method.getURI() );\n        throw new SolrException(SolrException.ErrorCode.getErrorCode(statusCode), java.net.URLDecoder.decode(msg.toString(), \"UTF-8\") );\n      }\n\n      // Read the contents\n      String charset = \"UTF-8\";\n      if( method instanceof HttpMethodBase ) {\n        charset = ((HttpMethodBase)method).getResponseCharSet();\n      }\n      InputStream respBody = method.getResponseBodyAsStream();\n      // Jakarta Commons HTTPClient doesn't handle any\n      // compression natively.  Handle gzip or deflate\n      // here if applicable.\n      if( _allowCompression ) {\n        Header contentEncodingHeader = method.getResponseHeader( \"Content-Encoding\" );\n        if( contentEncodingHeader != null ) {\n          String contentEncoding = contentEncodingHeader.getValue();\n          if( contentEncoding.contains( \"gzip\" ) ) {\n            //log.debug( \"wrapping response in GZIPInputStream\" );\n            respBody = new GZIPInputStream( respBody );\n          }\n          else if( contentEncoding.contains( \"deflate\" ) ) {\n            //log.debug( \"wrapping response in InflaterInputStream\" );\n            respBody = new InflaterInputStream(respBody);\n          }\n        }\n        else {\n          Header contentTypeHeader = method.getResponseHeader( \"Content-Type\" );\n          if( contentTypeHeader != null ) {\n            String contentType = contentTypeHeader.getValue();\n            if( contentType != null ) {\n              if( contentType.startsWith( \"application/x-gzip-compressed\" ) ) {\n                //log.debug( \"wrapping response in GZIPInputStream\" );\n                respBody = new GZIPInputStream( respBody );\n              }\n              else if ( contentType.startsWith(\"application/x-deflate\") ) {\n                //log.debug( \"wrapping response in InflaterInputStream\" );\n                respBody = new InflaterInputStream(respBody);\n              }\n            }\n          }\n        }\n      }\n      return processor.processResponse(respBody, charset);\n    }\n    catch (HttpException e) {\n      throw new SolrServerException(getBaseURL(), e);\n    }\n    catch (IOException e) {\n      throw new SolrServerException(getBaseURL(), e);\n    }\n    finally {\n      method.releaseConnection();\n      if(is != null) {\n        is.close();\n      }\n    }\n  }\n\n","sourceOld":"  public NamedList<Object> request(final SolrRequest request, ResponseParser processor) throws SolrServerException, IOException {\n    HttpMethod method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if( path == null || !path.startsWith( \"/\" ) ) {\n      path = \"/select\";\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if( parser == null ) {\n      parser = _parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original params\n    ModifiableSolrParams wparams = new ModifiableSolrParams();\n    wparams.set( CommonParams.WT, parser.getWriterType() );\n    wparams.set( CommonParams.VERSION, parser.getVersion());\n    params = SolrParams.wrapDefaults(wparams, params);\n    params = SolrParams.wrapDefaults(_invariantParams, params);\n\n    int tries = _maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't doing intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new GetMethod( _baseURL + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = _baseURL + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            if (streams == null || isMultipart) {\n              PostMethod post = new PostMethod(url);\n              post.getParams().setContentCharset(\"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addRequestHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<Part> parts = new LinkedList<Part>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new StringPart(p, v, \"UTF-8\"));\n                    } else {\n                      post.addParameter(p, v);\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                int i = 0;\n                for (ContentStream content : streams) {\n                  final ContentStream c = content;\n\n                  String charSet = null;\n                  PartSource source = new PartSource() {\n                    @Override\n                    public long getLength() {\n                      return c.getSize();\n                    }\n                      \n                    public String getFileName() {\n                      return c.getName();\n                    }\n\n                    @Override\n                    public InputStream createInputStream() throws IOException {\n                      return c.getStream();\n                    }\n                  };\n                \n                  parts.add(new FilePart(c.getName(), source, \n                                         c.getContentType(), charSet));\n                }\n              }\n              if (parts.size() > 0) {\n                post.setRequestEntity(new MultipartRequestEntity(parts\n                    .toArray(new Part[parts.size()]), post.getParams()));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              PostMethod post = new PostMethod(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setRequestEntity(new RequestEntity() {\n                  public long getContentLength() {\n                    return -1;\n                  }\n\n                  public String getContentType() {\n                    return contentStream[0].getContentType();\n                  }\n\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n\n                  public void writeRequest(OutputStream outputStream) throws IOException {\n                    ((RequestWriter.LazyContentStream) contentStream[0]).writeTo(outputStream);\n                  }\n                }\n                );\n\n              } else {\n                is = contentStream[0].getStream();\n                post.setRequestEntity(new InputStreamRequestEntity(is, contentStream[0].getContentType()));\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          // This is generally safe to retry on\n          method.releaseConnection();\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if( ( tries < 1 ) ) {\n            throw r;\n          }\n          //log.warn( \"Caught: \" + r + \". Retrying...\" );\n        }\n      }\n    }\n    catch( IOException ex ) {\n      throw new SolrServerException(\"error reading streams\", ex );\n    }\n\n    method.setFollowRedirects( _followRedirects );\n    method.addRequestHeader( \"User-Agent\", AGENT );\n    if( _allowCompression ) {\n      method.setRequestHeader( new Header( \"Accept-Encoding\", \"gzip,deflate\" ) );\n    }\n\n    try {\n      // Execute the method.\n      //System.out.println( \"EXECUTE:\"+method.getURI() );\n\n      int statusCode = _httpClient.executeMethod(method);\n      if (statusCode != HttpStatus.SC_OK) {\n        StringBuilder msg = new StringBuilder();\n        msg.append( method.getStatusLine().getReasonPhrase() );\n        msg.append( \"\\n\\n\" );\n        msg.append( method.getStatusText() );\n        msg.append( \"\\n\\n\" );\n        msg.append( \"request: \"+method.getURI() );\n        throw new SolrException(SolrException.ErrorCode.getErrorCode(statusCode), java.net.URLDecoder.decode(msg.toString(), \"UTF-8\") );\n      }\n\n      // Read the contents\n      String charset = \"UTF-8\";\n      if( method instanceof HttpMethodBase ) {\n        charset = ((HttpMethodBase)method).getResponseCharSet();\n      }\n      InputStream respBody = method.getResponseBodyAsStream();\n      // Jakarta Commons HTTPClient doesn't handle any\n      // compression natively.  Handle gzip or deflate\n      // here if applicable.\n      if( _allowCompression ) {\n        Header contentEncodingHeader = method.getResponseHeader( \"Content-Encoding\" );\n        if( contentEncodingHeader != null ) {\n          String contentEncoding = contentEncodingHeader.getValue();\n          if( contentEncoding.contains( \"gzip\" ) ) {\n            //log.debug( \"wrapping response in GZIPInputStream\" );\n            respBody = new GZIPInputStream( respBody );\n          }\n          else if( contentEncoding.contains( \"deflate\" ) ) {\n            //log.debug( \"wrapping response in InflaterInputStream\" );\n            respBody = new InflaterInputStream(respBody);\n          }\n        }\n        else {\n          Header contentTypeHeader = method.getResponseHeader( \"Content-Type\" );\n          if( contentTypeHeader != null ) {\n            String contentType = contentTypeHeader.getValue();\n            if( contentType != null ) {\n              if( contentType.startsWith( \"application/x-gzip-compressed\" ) ) {\n                //log.debug( \"wrapping response in GZIPInputStream\" );\n                respBody = new GZIPInputStream( respBody );\n              }\n              else if ( contentType.startsWith(\"application/x-deflate\") ) {\n                //log.debug( \"wrapping response in InflaterInputStream\" );\n                respBody = new InflaterInputStream(respBody);\n              }\n            }\n          }\n        }\n      }\n      return processor.processResponse(respBody, charset);\n    }\n    catch (HttpException e) {\n      throw new SolrServerException(getBaseURL(), e);\n    }\n    catch (IOException e) {\n      throw new SolrServerException(getBaseURL(), e);\n    }\n    finally {\n      method.releaseConnection();\n      if(is != null) {\n        is.close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d8d46584d4a299aaed53fdd79f1cd77f222aee1e","date":1331071171,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer#request(SolrRequest,ResponseParser).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer#request(SolrRequest,ResponseParser).mjava","sourceNew":"  public NamedList<Object> request(final SolrRequest request, ResponseParser processor) throws SolrServerException, IOException {\n    HttpMethod method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if( path == null || !path.startsWith( \"/\" ) ) {\n      path = \"/select\";\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if( parser == null ) {\n      parser = _parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    wparams.set( CommonParams.WT, parser.getWriterType() );\n    wparams.set( CommonParams.VERSION, parser.getVersion());\n    if (_invariantParams != null) {\n      wparams.add( _invariantParams );\n    }\n    params = wparams;\n\n    int tries = _maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't doing intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new GetMethod( _baseURL + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = _baseURL + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            if (streams == null || isMultipart) {\n              PostMethod post = new PostMethod(url);\n              post.getParams().setContentCharset(\"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addRequestHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<Part> parts = new LinkedList<Part>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new StringPart(p, v, \"UTF-8\"));\n                    } else {\n                      post.addParameter(p, v);\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                int i = 0;\n                for (ContentStream content : streams) {\n                  final ContentStream c = content;\n\n                  String charSet = null;\n                  PartSource source = new PartSource() {\n                    @Override\n                    public long getLength() {\n                      return c.getSize();\n                    }\n                      \n                    public String getFileName() {\n                      return c.getName();\n                    }\n\n                    @Override\n                    public InputStream createInputStream() throws IOException {\n                      return c.getStream();\n                    }\n                  };\n                \n                  parts.add(new FilePart(c.getName(), source, \n                                         c.getContentType(), charSet));\n                }\n              }\n              if (parts.size() > 0) {\n                post.setRequestEntity(new MultipartRequestEntity(parts\n                    .toArray(new Part[parts.size()]), post.getParams()));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              PostMethod post = new PostMethod(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setRequestEntity(new RequestEntity() {\n                  public long getContentLength() {\n                    return -1;\n                  }\n\n                  public String getContentType() {\n                    return contentStream[0].getContentType();\n                  }\n\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n\n                  public void writeRequest(OutputStream outputStream) throws IOException {\n                    ((RequestWriter.LazyContentStream) contentStream[0]).writeTo(outputStream);\n                  }\n                }\n                );\n\n              } else {\n                is = contentStream[0].getStream();\n                post.setRequestEntity(new InputStreamRequestEntity(is, contentStream[0].getContentType()));\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          // This is generally safe to retry on\n          method.releaseConnection();\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if( ( tries < 1 ) ) {\n            throw r;\n          }\n          //log.warn( \"Caught: \" + r + \". Retrying...\" );\n        }\n      }\n    }\n    catch( IOException ex ) {\n      throw new SolrServerException(\"error reading streams\", ex );\n    }\n\n    method.setFollowRedirects( _followRedirects );\n    method.addRequestHeader( \"User-Agent\", AGENT );\n    if( _allowCompression ) {\n      method.setRequestHeader( new Header( \"Accept-Encoding\", \"gzip,deflate\" ) );\n    }\n\n    try {\n      // Execute the method.\n      //System.out.println( \"EXECUTE:\"+method.getURI() );\n      int statusCode = _httpClient.executeMethod(method);\n\n      // Read the contents\n      String charset = \"UTF-8\";\n      if( method instanceof HttpMethodBase ) {\n        charset = ((HttpMethodBase)method).getResponseCharSet();\n      }\n      InputStream respBody = method.getResponseBodyAsStream();\n      // Jakarta Commons HTTPClient doesn't handle any\n      // compression natively.  Handle gzip or deflate\n      // here if applicable.\n      if( _allowCompression ) {\n        Header contentEncodingHeader = method.getResponseHeader( \"Content-Encoding\" );\n        if( contentEncodingHeader != null ) {\n          String contentEncoding = contentEncodingHeader.getValue();\n          if( contentEncoding.contains( \"gzip\" ) ) {\n            //log.debug( \"wrapping response in GZIPInputStream\" );\n            respBody = new GZIPInputStream( respBody );\n          }\n          else if( contentEncoding.contains( \"deflate\" ) ) {\n            //log.debug( \"wrapping response in InflaterInputStream\" );\n            respBody = new InflaterInputStream(respBody);\n          }\n        }\n        else {\n          Header contentTypeHeader = method.getResponseHeader( \"Content-Type\" );\n          if( contentTypeHeader != null ) {\n            String contentType = contentTypeHeader.getValue();\n            if( contentType != null ) {\n              if( contentType.startsWith( \"application/x-gzip-compressed\" ) ) {\n                //log.debug( \"wrapping response in GZIPInputStream\" );\n                respBody = new GZIPInputStream( respBody );\n              }\n              else if ( contentType.startsWith(\"application/x-deflate\") ) {\n                //log.debug( \"wrapping response in InflaterInputStream\" );\n                respBody = new InflaterInputStream(respBody);\n              }\n            }\n          }\n        }\n      }\n      \n      NamedList<Object> rsp = processor.processResponse(respBody, charset);\n      if (statusCode != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList)rsp.get(\"error\");\n          if(err!=null) {\n            reason = (String)err.get(\"msg\");\n            // TODO? get the trace?\n          }\n        }\n        catch(Exception ex) {}\n        if(reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append( method.getStatusLine().getReasonPhrase() );\n          msg.append( \"\\n\\n\" );\n          msg.append( method.getStatusText() );\n          msg.append( \"\\n\\n\" );\n          msg.append( \"request: \"+method.getURI() );\n          reason = java.net.URLDecoder.decode(msg.toString(), \"UTF-8\");\n        }\n        throw new SolrException(SolrException.ErrorCode.getErrorCode(statusCode), reason );\n      }\n      return rsp;\n    }\n    catch (HttpException e) {\n      throw new SolrServerException(getBaseURL(), e);\n    }\n    catch (IOException e) {\n      throw new SolrServerException(getBaseURL(), e);\n    }\n    finally {\n      method.releaseConnection();\n      if(is != null) {\n        is.close();\n      }\n    }\n  }\n\n","sourceOld":"  public NamedList<Object> request(final SolrRequest request, ResponseParser processor) throws SolrServerException, IOException {\n    HttpMethod method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if( path == null || !path.startsWith( \"/\" ) ) {\n      path = \"/select\";\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if( parser == null ) {\n      parser = _parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    wparams.set( CommonParams.WT, parser.getWriterType() );\n    wparams.set( CommonParams.VERSION, parser.getVersion());\n    if (_invariantParams != null) {\n      wparams.add( _invariantParams );\n    }\n    params = wparams;\n\n    int tries = _maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't doing intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new GetMethod( _baseURL + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = _baseURL + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            if (streams == null || isMultipart) {\n              PostMethod post = new PostMethod(url);\n              post.getParams().setContentCharset(\"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addRequestHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<Part> parts = new LinkedList<Part>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new StringPart(p, v, \"UTF-8\"));\n                    } else {\n                      post.addParameter(p, v);\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                int i = 0;\n                for (ContentStream content : streams) {\n                  final ContentStream c = content;\n\n                  String charSet = null;\n                  PartSource source = new PartSource() {\n                    @Override\n                    public long getLength() {\n                      return c.getSize();\n                    }\n                      \n                    public String getFileName() {\n                      return c.getName();\n                    }\n\n                    @Override\n                    public InputStream createInputStream() throws IOException {\n                      return c.getStream();\n                    }\n                  };\n                \n                  parts.add(new FilePart(c.getName(), source, \n                                         c.getContentType(), charSet));\n                }\n              }\n              if (parts.size() > 0) {\n                post.setRequestEntity(new MultipartRequestEntity(parts\n                    .toArray(new Part[parts.size()]), post.getParams()));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              PostMethod post = new PostMethod(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setRequestEntity(new RequestEntity() {\n                  public long getContentLength() {\n                    return -1;\n                  }\n\n                  public String getContentType() {\n                    return contentStream[0].getContentType();\n                  }\n\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n\n                  public void writeRequest(OutputStream outputStream) throws IOException {\n                    ((RequestWriter.LazyContentStream) contentStream[0]).writeTo(outputStream);\n                  }\n                }\n                );\n\n              } else {\n                is = contentStream[0].getStream();\n                post.setRequestEntity(new InputStreamRequestEntity(is, contentStream[0].getContentType()));\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          // This is generally safe to retry on\n          method.releaseConnection();\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if( ( tries < 1 ) ) {\n            throw r;\n          }\n          //log.warn( \"Caught: \" + r + \". Retrying...\" );\n        }\n      }\n    }\n    catch( IOException ex ) {\n      throw new SolrServerException(\"error reading streams\", ex );\n    }\n\n    method.setFollowRedirects( _followRedirects );\n    method.addRequestHeader( \"User-Agent\", AGENT );\n    if( _allowCompression ) {\n      method.setRequestHeader( new Header( \"Accept-Encoding\", \"gzip,deflate\" ) );\n    }\n\n    try {\n      // Execute the method.\n      //System.out.println( \"EXECUTE:\"+method.getURI() );\n\n      int statusCode = _httpClient.executeMethod(method);\n      if (statusCode != HttpStatus.SC_OK) {\n        StringBuilder msg = new StringBuilder();\n        msg.append( method.getStatusLine().getReasonPhrase() );\n        msg.append( \"\\n\\n\" );\n        msg.append( method.getStatusText() );\n        msg.append( \"\\n\\n\" );\n        msg.append( \"request: \"+method.getURI() );\n        throw new SolrException(SolrException.ErrorCode.getErrorCode(statusCode), java.net.URLDecoder.decode(msg.toString(), \"UTF-8\") );\n      }\n\n      // Read the contents\n      String charset = \"UTF-8\";\n      if( method instanceof HttpMethodBase ) {\n        charset = ((HttpMethodBase)method).getResponseCharSet();\n      }\n      InputStream respBody = method.getResponseBodyAsStream();\n      // Jakarta Commons HTTPClient doesn't handle any\n      // compression natively.  Handle gzip or deflate\n      // here if applicable.\n      if( _allowCompression ) {\n        Header contentEncodingHeader = method.getResponseHeader( \"Content-Encoding\" );\n        if( contentEncodingHeader != null ) {\n          String contentEncoding = contentEncodingHeader.getValue();\n          if( contentEncoding.contains( \"gzip\" ) ) {\n            //log.debug( \"wrapping response in GZIPInputStream\" );\n            respBody = new GZIPInputStream( respBody );\n          }\n          else if( contentEncoding.contains( \"deflate\" ) ) {\n            //log.debug( \"wrapping response in InflaterInputStream\" );\n            respBody = new InflaterInputStream(respBody);\n          }\n        }\n        else {\n          Header contentTypeHeader = method.getResponseHeader( \"Content-Type\" );\n          if( contentTypeHeader != null ) {\n            String contentType = contentTypeHeader.getValue();\n            if( contentType != null ) {\n              if( contentType.startsWith( \"application/x-gzip-compressed\" ) ) {\n                //log.debug( \"wrapping response in GZIPInputStream\" );\n                respBody = new GZIPInputStream( respBody );\n              }\n              else if ( contentType.startsWith(\"application/x-deflate\") ) {\n                //log.debug( \"wrapping response in InflaterInputStream\" );\n                respBody = new InflaterInputStream(respBody);\n              }\n            }\n          }\n        }\n      }\n      return processor.processResponse(respBody, charset);\n    }\n    catch (HttpException e) {\n      throw new SolrServerException(getBaseURL(), e);\n    }\n    catch (IOException e) {\n      throw new SolrServerException(getBaseURL(), e);\n    }\n    finally {\n      method.releaseConnection();\n      if(is != null) {\n        is.close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer#request(SolrRequest,ResponseParser).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer#request(SolrRequest,ResponseParser).mjava","sourceNew":"  public NamedList<Object> request(final SolrRequest request, ResponseParser processor) throws SolrServerException, IOException {\n    HttpMethod method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if( path == null || !path.startsWith( \"/\" ) ) {\n      path = \"/select\";\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if( parser == null ) {\n      parser = _parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    wparams.set( CommonParams.WT, parser.getWriterType() );\n    wparams.set( CommonParams.VERSION, parser.getVersion());\n    if (_invariantParams != null) {\n      wparams.add( _invariantParams );\n    }\n    params = wparams;\n\n    int tries = _maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't doing intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new GetMethod( _baseURL + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = _baseURL + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            if (streams == null || isMultipart) {\n              PostMethod post = new PostMethod(url);\n              post.getParams().setContentCharset(\"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addRequestHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<Part> parts = new LinkedList<Part>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new StringPart(p, v, \"UTF-8\"));\n                    } else {\n                      post.addParameter(p, v);\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                int i = 0;\n                for (ContentStream content : streams) {\n                  final ContentStream c = content;\n\n                  String charSet = null;\n                  PartSource source = new PartSource() {\n                    @Override\n                    public long getLength() {\n                      return c.getSize();\n                    }\n                      \n                    public String getFileName() {\n                      return c.getName();\n                    }\n\n                    @Override\n                    public InputStream createInputStream() throws IOException {\n                      return c.getStream();\n                    }\n                  };\n                \n                  parts.add(new FilePart(c.getName(), source, \n                                         c.getContentType(), charSet));\n                }\n              }\n              if (parts.size() > 0) {\n                post.setRequestEntity(new MultipartRequestEntity(parts\n                    .toArray(new Part[parts.size()]), post.getParams()));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              PostMethod post = new PostMethod(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setRequestEntity(new RequestEntity() {\n                  public long getContentLength() {\n                    return -1;\n                  }\n\n                  public String getContentType() {\n                    return contentStream[0].getContentType();\n                  }\n\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n\n                  public void writeRequest(OutputStream outputStream) throws IOException {\n                    ((RequestWriter.LazyContentStream) contentStream[0]).writeTo(outputStream);\n                  }\n                }\n                );\n\n              } else {\n                is = contentStream[0].getStream();\n                post.setRequestEntity(new InputStreamRequestEntity(is, contentStream[0].getContentType()));\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          // This is generally safe to retry on\n          method.releaseConnection();\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if( ( tries < 1 ) ) {\n            throw r;\n          }\n          //log.warn( \"Caught: \" + r + \". Retrying...\" );\n        }\n      }\n    }\n    catch( IOException ex ) {\n      throw new SolrServerException(\"error reading streams\", ex );\n    }\n\n    method.setFollowRedirects( _followRedirects );\n    method.addRequestHeader( \"User-Agent\", AGENT );\n    if( _allowCompression ) {\n      method.setRequestHeader( new Header( \"Accept-Encoding\", \"gzip,deflate\" ) );\n    }\n\n    try {\n      // Execute the method.\n      //System.out.println( \"EXECUTE:\"+method.getURI() );\n      int statusCode = _httpClient.executeMethod(method);\n\n      // Read the contents\n      String charset = \"UTF-8\";\n      if( method instanceof HttpMethodBase ) {\n        charset = ((HttpMethodBase)method).getResponseCharSet();\n      }\n      InputStream respBody = method.getResponseBodyAsStream();\n      // Jakarta Commons HTTPClient doesn't handle any\n      // compression natively.  Handle gzip or deflate\n      // here if applicable.\n      if( _allowCompression ) {\n        Header contentEncodingHeader = method.getResponseHeader( \"Content-Encoding\" );\n        if( contentEncodingHeader != null ) {\n          String contentEncoding = contentEncodingHeader.getValue();\n          if( contentEncoding.contains( \"gzip\" ) ) {\n            //log.debug( \"wrapping response in GZIPInputStream\" );\n            respBody = new GZIPInputStream( respBody );\n          }\n          else if( contentEncoding.contains( \"deflate\" ) ) {\n            //log.debug( \"wrapping response in InflaterInputStream\" );\n            respBody = new InflaterInputStream(respBody);\n          }\n        }\n        else {\n          Header contentTypeHeader = method.getResponseHeader( \"Content-Type\" );\n          if( contentTypeHeader != null ) {\n            String contentType = contentTypeHeader.getValue();\n            if( contentType != null ) {\n              if( contentType.startsWith( \"application/x-gzip-compressed\" ) ) {\n                //log.debug( \"wrapping response in GZIPInputStream\" );\n                respBody = new GZIPInputStream( respBody );\n              }\n              else if ( contentType.startsWith(\"application/x-deflate\") ) {\n                //log.debug( \"wrapping response in InflaterInputStream\" );\n                respBody = new InflaterInputStream(respBody);\n              }\n            }\n          }\n        }\n      }\n      \n      NamedList<Object> rsp = processor.processResponse(respBody, charset);\n      if (statusCode != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList)rsp.get(\"error\");\n          if(err!=null) {\n            reason = (String)err.get(\"msg\");\n            // TODO? get the trace?\n          }\n        }\n        catch(Exception ex) {}\n        if(reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append( method.getStatusLine().getReasonPhrase() );\n          msg.append( \"\\n\\n\" );\n          msg.append( method.getStatusText() );\n          msg.append( \"\\n\\n\" );\n          msg.append( \"request: \"+method.getURI() );\n          reason = java.net.URLDecoder.decode(msg.toString(), \"UTF-8\");\n        }\n        throw new SolrException(SolrException.ErrorCode.getErrorCode(statusCode), reason );\n      }\n      return rsp;\n    }\n    catch (HttpException e) {\n      throw new SolrServerException(getBaseURL(), e);\n    }\n    catch (IOException e) {\n      throw new SolrServerException(getBaseURL(), e);\n    }\n    finally {\n      method.releaseConnection();\n      if(is != null) {\n        is.close();\n      }\n    }\n  }\n\n","sourceOld":"  public NamedList<Object> request(final SolrRequest request, ResponseParser processor) throws SolrServerException, IOException {\n    HttpMethod method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if( path == null || !path.startsWith( \"/\" ) ) {\n      path = \"/select\";\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if( parser == null ) {\n      parser = _parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original params\n    ModifiableSolrParams wparams = new ModifiableSolrParams();\n    wparams.set( CommonParams.WT, parser.getWriterType() );\n    wparams.set( CommonParams.VERSION, parser.getVersion());\n    params = SolrParams.wrapDefaults(wparams, params);\n    params = SolrParams.wrapDefaults(_invariantParams, params);\n\n    int tries = _maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't doing intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new GetMethod( _baseURL + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = _baseURL + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            if (streams == null || isMultipart) {\n              PostMethod post = new PostMethod(url);\n              post.getParams().setContentCharset(\"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addRequestHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<Part> parts = new LinkedList<Part>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new StringPart(p, v, \"UTF-8\"));\n                    } else {\n                      post.addParameter(p, v);\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                int i = 0;\n                for (ContentStream content : streams) {\n                  final ContentStream c = content;\n\n                  String charSet = null;\n                  PartSource source = new PartSource() {\n                    @Override\n                    public long getLength() {\n                      return c.getSize();\n                    }\n                      \n                    public String getFileName() {\n                      return c.getName();\n                    }\n\n                    @Override\n                    public InputStream createInputStream() throws IOException {\n                      return c.getStream();\n                    }\n                  };\n                \n                  parts.add(new FilePart(c.getName(), source, \n                                         c.getContentType(), charSet));\n                }\n              }\n              if (parts.size() > 0) {\n                post.setRequestEntity(new MultipartRequestEntity(parts\n                    .toArray(new Part[parts.size()]), post.getParams()));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              PostMethod post = new PostMethod(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setRequestEntity(new RequestEntity() {\n                  public long getContentLength() {\n                    return -1;\n                  }\n\n                  public String getContentType() {\n                    return contentStream[0].getContentType();\n                  }\n\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n\n                  public void writeRequest(OutputStream outputStream) throws IOException {\n                    ((RequestWriter.LazyContentStream) contentStream[0]).writeTo(outputStream);\n                  }\n                }\n                );\n\n              } else {\n                is = contentStream[0].getStream();\n                post.setRequestEntity(new InputStreamRequestEntity(is, contentStream[0].getContentType()));\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          // This is generally safe to retry on\n          method.releaseConnection();\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if( ( tries < 1 ) ) {\n            throw r;\n          }\n          //log.warn( \"Caught: \" + r + \". Retrying...\" );\n        }\n      }\n    }\n    catch( IOException ex ) {\n      throw new SolrServerException(\"error reading streams\", ex );\n    }\n\n    method.setFollowRedirects( _followRedirects );\n    method.addRequestHeader( \"User-Agent\", AGENT );\n    if( _allowCompression ) {\n      method.setRequestHeader( new Header( \"Accept-Encoding\", \"gzip,deflate\" ) );\n    }\n\n    try {\n      // Execute the method.\n      //System.out.println( \"EXECUTE:\"+method.getURI() );\n\n      int statusCode = _httpClient.executeMethod(method);\n      if (statusCode != HttpStatus.SC_OK) {\n        StringBuilder msg = new StringBuilder();\n        msg.append( method.getStatusLine().getReasonPhrase() );\n        msg.append( \"\\n\\n\" );\n        msg.append( method.getStatusText() );\n        msg.append( \"\\n\\n\" );\n        msg.append( \"request: \"+method.getURI() );\n        throw new SolrException(SolrException.ErrorCode.getErrorCode(statusCode), java.net.URLDecoder.decode(msg.toString(), \"UTF-8\") );\n      }\n\n      // Read the contents\n      String charset = \"UTF-8\";\n      if( method instanceof HttpMethodBase ) {\n        charset = ((HttpMethodBase)method).getResponseCharSet();\n      }\n      InputStream respBody = method.getResponseBodyAsStream();\n      // Jakarta Commons HTTPClient doesn't handle any\n      // compression natively.  Handle gzip or deflate\n      // here if applicable.\n      if( _allowCompression ) {\n        Header contentEncodingHeader = method.getResponseHeader( \"Content-Encoding\" );\n        if( contentEncodingHeader != null ) {\n          String contentEncoding = contentEncodingHeader.getValue();\n          if( contentEncoding.contains( \"gzip\" ) ) {\n            //log.debug( \"wrapping response in GZIPInputStream\" );\n            respBody = new GZIPInputStream( respBody );\n          }\n          else if( contentEncoding.contains( \"deflate\" ) ) {\n            //log.debug( \"wrapping response in InflaterInputStream\" );\n            respBody = new InflaterInputStream(respBody);\n          }\n        }\n        else {\n          Header contentTypeHeader = method.getResponseHeader( \"Content-Type\" );\n          if( contentTypeHeader != null ) {\n            String contentType = contentTypeHeader.getValue();\n            if( contentType != null ) {\n              if( contentType.startsWith( \"application/x-gzip-compressed\" ) ) {\n                //log.debug( \"wrapping response in GZIPInputStream\" );\n                respBody = new GZIPInputStream( respBody );\n              }\n              else if ( contentType.startsWith(\"application/x-deflate\") ) {\n                //log.debug( \"wrapping response in InflaterInputStream\" );\n                respBody = new InflaterInputStream(respBody);\n              }\n            }\n          }\n        }\n      }\n      return processor.processResponse(respBody, charset);\n    }\n    catch (HttpException e) {\n      throw new SolrServerException(getBaseURL(), e);\n    }\n    catch (IOException e) {\n      throw new SolrServerException(getBaseURL(), e);\n    }\n    finally {\n      method.releaseConnection();\n      if(is != null) {\n        is.close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eb57e8385192a8db78b9a00d00a1425c3d1977b0","date":1331153368,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer#request(SolrRequest,ResponseParser).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer#request(SolrRequest,ResponseParser).mjava","sourceNew":"  public NamedList<Object> request(final SolrRequest request, ResponseParser processor) throws SolrServerException, IOException {\n    HttpMethod method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if( path == null || !path.startsWith( \"/\" ) ) {\n      path = \"/select\";\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if( parser == null ) {\n      parser = _parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    wparams.set( CommonParams.WT, parser.getWriterType() );\n    wparams.set( CommonParams.VERSION, parser.getVersion());\n    if (_invariantParams != null) {\n      wparams.add( _invariantParams );\n    }\n    params = wparams;\n\n    int tries = _maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't doing intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new GetMethod( _baseURL + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = _baseURL + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            if (streams == null || isMultipart) {\n              PostMethod post = new PostMethod(url);\n              post.getParams().setContentCharset(\"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addRequestHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<Part> parts = new LinkedList<Part>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new StringPart(p, v, \"UTF-8\"));\n                    } else {\n                      post.addParameter(p, v);\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                int i = 0;\n                for (ContentStream content : streams) {\n                  final ContentStream c = content;\n\n                  String charSet = null;\n                  PartSource source = new PartSource() {\n                    @Override\n                    public long getLength() {\n                      return c.getSize();\n                    }\n                      \n                    public String getFileName() {\n                      return c.getName();\n                    }\n\n                    @Override\n                    public InputStream createInputStream() throws IOException {\n                      return c.getStream();\n                    }\n                  };\n                \n                  parts.add(new FilePart(c.getName(), source, \n                                         c.getContentType(), charSet));\n                }\n              }\n              if (parts.size() > 0) {\n                post.setRequestEntity(new MultipartRequestEntity(parts\n                    .toArray(new Part[parts.size()]), post.getParams()));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              PostMethod post = new PostMethod(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setRequestEntity(new RequestEntity() {\n                  public long getContentLength() {\n                    return -1;\n                  }\n\n                  public String getContentType() {\n                    return contentStream[0].getContentType();\n                  }\n\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n\n                  public void writeRequest(OutputStream outputStream) throws IOException {\n                    ((RequestWriter.LazyContentStream) contentStream[0]).writeTo(outputStream);\n                  }\n                }\n                );\n\n              } else {\n                is = contentStream[0].getStream();\n                post.setRequestEntity(new InputStreamRequestEntity(is, contentStream[0].getContentType()));\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          // This is generally safe to retry on\n          method.releaseConnection();\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if( ( tries < 1 ) ) {\n            throw r;\n          }\n          //log.warn( \"Caught: \" + r + \". Retrying...\" );\n        }\n      }\n    }\n    catch( IOException ex ) {\n      throw new SolrServerException(\"error reading streams\", ex );\n    }\n\n    method.setFollowRedirects( _followRedirects );\n    method.addRequestHeader( \"User-Agent\", AGENT );\n    if( _allowCompression ) {\n      method.setRequestHeader( new Header( \"Accept-Encoding\", \"gzip,deflate\" ) );\n    }\n\n    try {\n      // Execute the method.\n      //System.out.println( \"EXECUTE:\"+method.getURI() );\n      int statusCode = _httpClient.executeMethod(method);\n\n      // Read the contents\n      String charset = \"UTF-8\";\n      if( method instanceof HttpMethodBase ) {\n        charset = ((HttpMethodBase)method).getResponseCharSet();\n      }\n      InputStream respBody = method.getResponseBodyAsStream();\n      // Jakarta Commons HTTPClient doesn't handle any\n      // compression natively.  Handle gzip or deflate\n      // here if applicable.\n      if( _allowCompression ) {\n        Header contentEncodingHeader = method.getResponseHeader( \"Content-Encoding\" );\n        if( contentEncodingHeader != null ) {\n          String contentEncoding = contentEncodingHeader.getValue();\n          if( contentEncoding.contains( \"gzip\" ) ) {\n            //log.debug( \"wrapping response in GZIPInputStream\" );\n            respBody = new GZIPInputStream( respBody );\n          }\n          else if( contentEncoding.contains( \"deflate\" ) ) {\n            //log.debug( \"wrapping response in InflaterInputStream\" );\n            respBody = new InflaterInputStream(respBody);\n          }\n        }\n        else {\n          Header contentTypeHeader = method.getResponseHeader( \"Content-Type\" );\n          if( contentTypeHeader != null ) {\n            String contentType = contentTypeHeader.getValue();\n            if( contentType != null ) {\n              if( contentType.startsWith( \"application/x-gzip-compressed\" ) ) {\n                //log.debug( \"wrapping response in GZIPInputStream\" );\n                respBody = new GZIPInputStream( respBody );\n              }\n              else if ( contentType.startsWith(\"application/x-deflate\") ) {\n                //log.debug( \"wrapping response in InflaterInputStream\" );\n                respBody = new InflaterInputStream(respBody);\n              }\n            }\n          }\n        }\n      }\n      \n      NamedList<Object> rsp = processor.processResponse(respBody, charset);\n      if (statusCode != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList)rsp.get(\"error\");\n          if(err!=null) {\n            reason = (String)err.get(\"msg\");\n            // TODO? get the trace?\n    }\n        }\n        catch(Exception ex) {}\n        if(reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append( method.getStatusLine().getReasonPhrase() );\n          msg.append( \"\\n\\n\" );\n          msg.append( method.getStatusText() );\n          msg.append( \"\\n\\n\" );\n          msg.append( \"request: \"+method.getURI() );\n          reason = java.net.URLDecoder.decode(msg.toString(), \"UTF-8\");\n        }\n        throw new SolrException(SolrException.ErrorCode.getErrorCode(statusCode), reason );\n      }\n      return rsp;\n    }\n    catch (HttpException e) {\n      throw new SolrServerException(getBaseURL(), e);\n    }\n    catch (IOException e) {\n      throw new SolrServerException(getBaseURL(), e);\n    }\n    finally {\n      method.releaseConnection();\n      if(is != null) {\n        is.close();\n      }\n    }\n  }\n\n","sourceOld":"  public NamedList<Object> request(final SolrRequest request, ResponseParser processor) throws SolrServerException, IOException {\n    HttpMethod method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if( path == null || !path.startsWith( \"/\" ) ) {\n      path = \"/select\";\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if( parser == null ) {\n      parser = _parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    wparams.set( CommonParams.WT, parser.getWriterType() );\n    wparams.set( CommonParams.VERSION, parser.getVersion());\n    if (_invariantParams != null) {\n      wparams.add( _invariantParams );\n    }\n    params = wparams;\n\n    int tries = _maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't doing intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new GetMethod( _baseURL + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = _baseURL + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            if (streams == null || isMultipart) {\n              PostMethod post = new PostMethod(url);\n              post.getParams().setContentCharset(\"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addRequestHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<Part> parts = new LinkedList<Part>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new StringPart(p, v, \"UTF-8\"));\n                    } else {\n                      post.addParameter(p, v);\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                int i = 0;\n                for (ContentStream content : streams) {\n                  final ContentStream c = content;\n\n                  String charSet = null;\n                  PartSource source = new PartSource() {\n                    @Override\n                    public long getLength() {\n                      return c.getSize();\n                    }\n                      \n                    public String getFileName() {\n                      return c.getName();\n                    }\n\n                    @Override\n                    public InputStream createInputStream() throws IOException {\n                      return c.getStream();\n                    }\n                  };\n                \n                  parts.add(new FilePart(c.getName(), source, \n                                         c.getContentType(), charSet));\n                }\n              }\n              if (parts.size() > 0) {\n                post.setRequestEntity(new MultipartRequestEntity(parts\n                    .toArray(new Part[parts.size()]), post.getParams()));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              PostMethod post = new PostMethod(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setRequestEntity(new RequestEntity() {\n                  public long getContentLength() {\n                    return -1;\n                  }\n\n                  public String getContentType() {\n                    return contentStream[0].getContentType();\n                  }\n\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n\n                  public void writeRequest(OutputStream outputStream) throws IOException {\n                    ((RequestWriter.LazyContentStream) contentStream[0]).writeTo(outputStream);\n                  }\n                }\n                );\n\n              } else {\n                is = contentStream[0].getStream();\n                post.setRequestEntity(new InputStreamRequestEntity(is, contentStream[0].getContentType()));\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          // This is generally safe to retry on\n          method.releaseConnection();\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if( ( tries < 1 ) ) {\n            throw r;\n          }\n          //log.warn( \"Caught: \" + r + \". Retrying...\" );\n        }\n      }\n    }\n    catch( IOException ex ) {\n      throw new SolrServerException(\"error reading streams\", ex );\n    }\n\n    method.setFollowRedirects( _followRedirects );\n    method.addRequestHeader( \"User-Agent\", AGENT );\n    if( _allowCompression ) {\n      method.setRequestHeader( new Header( \"Accept-Encoding\", \"gzip,deflate\" ) );\n    }\n\n    try {\n      // Execute the method.\n      //System.out.println( \"EXECUTE:\"+method.getURI() );\n      int statusCode = _httpClient.executeMethod(method);\n\n      // Read the contents\n      String charset = \"UTF-8\";\n      if( method instanceof HttpMethodBase ) {\n        charset = ((HttpMethodBase)method).getResponseCharSet();\n      }\n      InputStream respBody = method.getResponseBodyAsStream();\n      // Jakarta Commons HTTPClient doesn't handle any\n      // compression natively.  Handle gzip or deflate\n      // here if applicable.\n      if( _allowCompression ) {\n        Header contentEncodingHeader = method.getResponseHeader( \"Content-Encoding\" );\n        if( contentEncodingHeader != null ) {\n          String contentEncoding = contentEncodingHeader.getValue();\n          if( contentEncoding.contains( \"gzip\" ) ) {\n            //log.debug( \"wrapping response in GZIPInputStream\" );\n            respBody = new GZIPInputStream( respBody );\n          }\n          else if( contentEncoding.contains( \"deflate\" ) ) {\n            //log.debug( \"wrapping response in InflaterInputStream\" );\n            respBody = new InflaterInputStream(respBody);\n          }\n        }\n        else {\n          Header contentTypeHeader = method.getResponseHeader( \"Content-Type\" );\n          if( contentTypeHeader != null ) {\n            String contentType = contentTypeHeader.getValue();\n            if( contentType != null ) {\n              if( contentType.startsWith( \"application/x-gzip-compressed\" ) ) {\n                //log.debug( \"wrapping response in GZIPInputStream\" );\n                respBody = new GZIPInputStream( respBody );\n              }\n              else if ( contentType.startsWith(\"application/x-deflate\") ) {\n                //log.debug( \"wrapping response in InflaterInputStream\" );\n                respBody = new InflaterInputStream(respBody);\n              }\n            }\n          }\n        }\n      }\n      \n      NamedList<Object> rsp = processor.processResponse(respBody, charset);\n      if (statusCode != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList)rsp.get(\"error\");\n          if(err!=null) {\n            reason = (String)err.get(\"msg\");\n            // TODO? get the trace?\n          }\n        }\n        catch(Exception ex) {}\n        if(reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append( method.getStatusLine().getReasonPhrase() );\n          msg.append( \"\\n\\n\" );\n          msg.append( method.getStatusText() );\n          msg.append( \"\\n\\n\" );\n          msg.append( \"request: \"+method.getURI() );\n          reason = java.net.URLDecoder.decode(msg.toString(), \"UTF-8\");\n        }\n        throw new SolrException(SolrException.ErrorCode.getErrorCode(statusCode), reason );\n      }\n      return rsp;\n    }\n    catch (HttpException e) {\n      throw new SolrServerException(getBaseURL(), e);\n    }\n    catch (IOException e) {\n      throw new SolrServerException(getBaseURL(), e);\n    }\n    finally {\n      method.releaseConnection();\n      if(is != null) {\n        is.close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"38e3b736c7ca086d61b7dbb841c905ee115490da","date":1331657018,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer#request(SolrRequest,ResponseParser).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer#request(SolrRequest,ResponseParser).mjava","sourceNew":"  public NamedList<Object> request(final SolrRequest request, ResponseParser processor) throws SolrServerException, IOException {\n    HttpMethod method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if( path == null || !path.startsWith( \"/\" ) ) {\n      path = \"/select\";\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if( parser == null ) {\n      parser = _parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    wparams.set( CommonParams.WT, parser.getWriterType() );\n    wparams.set( CommonParams.VERSION, parser.getVersion());\n    if (_invariantParams != null) {\n      wparams.add( _invariantParams );\n    }\n    params = wparams;\n\n    int tries = _maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't doing intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new GetMethod( _baseURL + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = _baseURL + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            if (streams == null || isMultipart) {\n              PostMethod post = new PostMethod(url);\n              post.getParams().setContentCharset(\"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addRequestHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<Part> parts = new LinkedList<Part>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new StringPart(p, v, \"UTF-8\"));\n                    } else {\n                      post.addParameter(p, v);\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                int i = 0;\n                for (ContentStream content : streams) {\n                  final ContentStream c = content;\n\n                  String charSet = null;\n                  PartSource source = new PartSource() {\n                    @Override\n                    public long getLength() {\n                      return c.getSize();\n                    }\n                      \n                    public String getFileName() {\n                      return c.getName();\n                    }\n\n                    @Override\n                    public InputStream createInputStream() throws IOException {\n                      return c.getStream();\n                    }\n                  };\n                \n                  parts.add(new FilePart(c.getName(), source, \n                                         c.getContentType(), charSet));\n                }\n              }\n              if (parts.size() > 0) {\n                post.setRequestEntity(new MultipartRequestEntity(parts\n                    .toArray(new Part[parts.size()]), post.getParams()));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              PostMethod post = new PostMethod(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setRequestEntity(new RequestEntity() {\n                  public long getContentLength() {\n                    return -1;\n                  }\n\n                  public String getContentType() {\n                    return contentStream[0].getContentType();\n                  }\n\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n\n                  public void writeRequest(OutputStream outputStream) throws IOException {\n                    ((RequestWriter.LazyContentStream) contentStream[0]).writeTo(outputStream);\n                  }\n                }\n                );\n\n              } else {\n                is = contentStream[0].getStream();\n                post.setRequestEntity(new InputStreamRequestEntity(is, contentStream[0].getContentType()));\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          // This is generally safe to retry on\n          method.releaseConnection();\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if( ( tries < 1 ) ) {\n            throw r;\n          }\n          //log.warn( \"Caught: \" + r + \". Retrying...\" );\n        }\n      }\n    }\n    catch( IOException ex ) {\n      throw new SolrServerException(\"error reading streams\", ex );\n    }\n\n    method.setFollowRedirects( _followRedirects );\n    method.addRequestHeader( \"User-Agent\", AGENT );\n    if( _allowCompression ) {\n      method.setRequestHeader( new Header( \"Accept-Encoding\", \"gzip,deflate\" ) );\n    }\n\n    try {\n      // Execute the method.\n      //System.out.println( \"EXECUTE:\"+method.getURI() );\n      int statusCode = _httpClient.executeMethod(method);\n\n      // Read the contents\n      String charset = \"UTF-8\";\n      if( method instanceof HttpMethodBase ) {\n        charset = ((HttpMethodBase)method).getResponseCharSet();\n      }\n      InputStream respBody = method.getResponseBodyAsStream();\n      // Jakarta Commons HTTPClient doesn't handle any\n      // compression natively.  Handle gzip or deflate\n      // here if applicable.\n      if( _allowCompression ) {\n        Header contentEncodingHeader = method.getResponseHeader( \"Content-Encoding\" );\n        if( contentEncodingHeader != null ) {\n          String contentEncoding = contentEncodingHeader.getValue();\n          if( contentEncoding.contains( \"gzip\" ) ) {\n            //log.debug( \"wrapping response in GZIPInputStream\" );\n            respBody = new GZIPInputStream( respBody );\n          }\n          else if( contentEncoding.contains( \"deflate\" ) ) {\n            //log.debug( \"wrapping response in InflaterInputStream\" );\n            respBody = new InflaterInputStream(respBody);\n          }\n        }\n        else {\n          Header contentTypeHeader = method.getResponseHeader( \"Content-Type\" );\n          if( contentTypeHeader != null ) {\n            String contentType = contentTypeHeader.getValue();\n            if( contentType != null ) {\n              if( contentType.startsWith( \"application/x-gzip-compressed\" ) ) {\n                //log.debug( \"wrapping response in GZIPInputStream\" );\n                respBody = new GZIPInputStream( respBody );\n              }\n              else if ( contentType.startsWith(\"application/x-deflate\") ) {\n                //log.debug( \"wrapping response in InflaterInputStream\" );\n                respBody = new InflaterInputStream(respBody);\n              }\n            }\n          }\n        }\n      }\n      \n      NamedList<Object> rsp = processor.processResponse(respBody, charset);\n      if (statusCode != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList)rsp.get(\"error\");\n          if(err!=null) {\n            reason = (String)err.get(\"msg\");\n            // TODO? get the trace?\n    }\n        }\n        catch(Exception ex) {}\n        if(reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append( method.getStatusLine().getReasonPhrase() );\n          msg.append( \"\\n\\n\" );\n          msg.append( method.getStatusText() );\n          msg.append( \"\\n\\n\" );\n          msg.append( \"request: \"+method.getURI() );\n          reason = java.net.URLDecoder.decode(msg.toString(), \"UTF-8\");\n        }\n        throw new SolrException(SolrException.ErrorCode.getErrorCode(statusCode), reason );\n      }\n      return rsp;\n    }\n    catch (HttpException e) {\n      throw new SolrServerException(getBaseURL(), e);\n    }\n    catch (IOException e) {\n      throw new SolrServerException(getBaseURL(), e);\n    }\n    finally {\n      method.releaseConnection();\n      if(is != null) {\n        is.close();\n      }\n    }\n  }\n\n","sourceOld":"  public NamedList<Object> request(final SolrRequest request, ResponseParser processor) throws SolrServerException, IOException {\n    HttpMethod method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if( path == null || !path.startsWith( \"/\" ) ) {\n      path = \"/select\";\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if( parser == null ) {\n      parser = _parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    wparams.set( CommonParams.WT, parser.getWriterType() );\n    wparams.set( CommonParams.VERSION, parser.getVersion());\n    if (_invariantParams != null) {\n      wparams.add( _invariantParams );\n    }\n    params = wparams;\n\n    int tries = _maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't doing intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new GetMethod( _baseURL + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = _baseURL + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            if (streams == null || isMultipart) {\n              PostMethod post = new PostMethod(url);\n              post.getParams().setContentCharset(\"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addRequestHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<Part> parts = new LinkedList<Part>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new StringPart(p, v, \"UTF-8\"));\n                    } else {\n                      post.addParameter(p, v);\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                int i = 0;\n                for (ContentStream content : streams) {\n                  final ContentStream c = content;\n\n                  String charSet = null;\n                  PartSource source = new PartSource() {\n                    @Override\n                    public long getLength() {\n                      return c.getSize();\n                    }\n                      \n                    public String getFileName() {\n                      return c.getName();\n                    }\n\n                    @Override\n                    public InputStream createInputStream() throws IOException {\n                      return c.getStream();\n                    }\n                  };\n                \n                  parts.add(new FilePart(c.getName(), source, \n                                         c.getContentType(), charSet));\n                }\n              }\n              if (parts.size() > 0) {\n                post.setRequestEntity(new MultipartRequestEntity(parts\n                    .toArray(new Part[parts.size()]), post.getParams()));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              PostMethod post = new PostMethod(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setRequestEntity(new RequestEntity() {\n                  public long getContentLength() {\n                    return -1;\n                  }\n\n                  public String getContentType() {\n                    return contentStream[0].getContentType();\n                  }\n\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n\n                  public void writeRequest(OutputStream outputStream) throws IOException {\n                    ((RequestWriter.LazyContentStream) contentStream[0]).writeTo(outputStream);\n                  }\n                }\n                );\n\n              } else {\n                is = contentStream[0].getStream();\n                post.setRequestEntity(new InputStreamRequestEntity(is, contentStream[0].getContentType()));\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          // This is generally safe to retry on\n          method.releaseConnection();\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if( ( tries < 1 ) ) {\n            throw r;\n          }\n          //log.warn( \"Caught: \" + r + \". Retrying...\" );\n        }\n      }\n    }\n    catch( IOException ex ) {\n      throw new SolrServerException(\"error reading streams\", ex );\n    }\n\n    method.setFollowRedirects( _followRedirects );\n    method.addRequestHeader( \"User-Agent\", AGENT );\n    if( _allowCompression ) {\n      method.setRequestHeader( new Header( \"Accept-Encoding\", \"gzip,deflate\" ) );\n    }\n\n    try {\n      // Execute the method.\n      //System.out.println( \"EXECUTE:\"+method.getURI() );\n      int statusCode = _httpClient.executeMethod(method);\n\n      // Read the contents\n      String charset = \"UTF-8\";\n      if( method instanceof HttpMethodBase ) {\n        charset = ((HttpMethodBase)method).getResponseCharSet();\n      }\n      InputStream respBody = method.getResponseBodyAsStream();\n      // Jakarta Commons HTTPClient doesn't handle any\n      // compression natively.  Handle gzip or deflate\n      // here if applicable.\n      if( _allowCompression ) {\n        Header contentEncodingHeader = method.getResponseHeader( \"Content-Encoding\" );\n        if( contentEncodingHeader != null ) {\n          String contentEncoding = contentEncodingHeader.getValue();\n          if( contentEncoding.contains( \"gzip\" ) ) {\n            //log.debug( \"wrapping response in GZIPInputStream\" );\n            respBody = new GZIPInputStream( respBody );\n          }\n          else if( contentEncoding.contains( \"deflate\" ) ) {\n            //log.debug( \"wrapping response in InflaterInputStream\" );\n            respBody = new InflaterInputStream(respBody);\n          }\n        }\n        else {\n          Header contentTypeHeader = method.getResponseHeader( \"Content-Type\" );\n          if( contentTypeHeader != null ) {\n            String contentType = contentTypeHeader.getValue();\n            if( contentType != null ) {\n              if( contentType.startsWith( \"application/x-gzip-compressed\" ) ) {\n                //log.debug( \"wrapping response in GZIPInputStream\" );\n                respBody = new GZIPInputStream( respBody );\n              }\n              else if ( contentType.startsWith(\"application/x-deflate\") ) {\n                //log.debug( \"wrapping response in InflaterInputStream\" );\n                respBody = new InflaterInputStream(respBody);\n              }\n            }\n          }\n        }\n      }\n      \n      NamedList<Object> rsp = processor.processResponse(respBody, charset);\n      if (statusCode != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList)rsp.get(\"error\");\n          if(err!=null) {\n            reason = (String)err.get(\"msg\");\n            // TODO? get the trace?\n          }\n        }\n        catch(Exception ex) {}\n        if(reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append( method.getStatusLine().getReasonPhrase() );\n          msg.append( \"\\n\\n\" );\n          msg.append( method.getStatusText() );\n          msg.append( \"\\n\\n\" );\n          msg.append( \"request: \"+method.getURI() );\n          reason = java.net.URLDecoder.decode(msg.toString(), \"UTF-8\");\n        }\n        throw new SolrException(SolrException.ErrorCode.getErrorCode(statusCode), reason );\n      }\n      return rsp;\n    }\n    catch (HttpException e) {\n      throw new SolrServerException(getBaseURL(), e);\n    }\n    catch (IOException e) {\n      throw new SolrServerException(getBaseURL(), e);\n    }\n    finally {\n      method.releaseConnection();\n      if(is != null) {\n        is.close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7321b77a7bc3edfebd637ef273e9dfaa9969eba6","date":1333023097,"type":4,"author":"Sami Siren","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer#request(SolrRequest,ResponseParser).mjava","sourceNew":null,"sourceOld":"  public NamedList<Object> request(final SolrRequest request, ResponseParser processor) throws SolrServerException, IOException {\n    HttpMethod method = null;\n    InputStream is = null;\n    SolrParams params = request.getParams();\n    Collection<ContentStream> streams = requestWriter.getContentStreams(request);\n    String path = requestWriter.getPath(request);\n    if( path == null || !path.startsWith( \"/\" ) ) {\n      path = \"/select\";\n    }\n    \n    ResponseParser parser = request.getResponseParser();\n    if( parser == null ) {\n      parser = _parser;\n    }\n    \n    // The parser 'wt=' and 'version=' params are used instead of the original params\n    ModifiableSolrParams wparams = new ModifiableSolrParams(params);\n    wparams.set( CommonParams.WT, parser.getWriterType() );\n    wparams.set( CommonParams.VERSION, parser.getVersion());\n    if (_invariantParams != null) {\n      wparams.add( _invariantParams );\n    }\n    params = wparams;\n\n    int tries = _maxRetries + 1;\n    try {\n      while( tries-- > 0 ) {\n        // Note: since we aren't doing intermittent time keeping\n        // ourselves, the potential non-timeout latency could be as\n        // much as tries-times (plus scheduling effects) the given\n        // timeAllowed.\n        try {\n          if( SolrRequest.METHOD.GET == request.getMethod() ) {\n            if( streams != null ) {\n              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\" );\n            }\n            method = new GetMethod( _baseURL + path + ClientUtils.toQueryString( params, false ) );\n          }\n          else if( SolrRequest.METHOD.POST == request.getMethod() ) {\n\n            String url = _baseURL + path;\n            boolean isMultipart = ( streams != null && streams.size() > 1 );\n\n            if (streams == null || isMultipart) {\n              PostMethod post = new PostMethod(url);\n              post.getParams().setContentCharset(\"UTF-8\");\n              if (!this.useMultiPartPost && !isMultipart) {\n                post.addRequestHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded; charset=UTF-8\");\n              }\n\n              List<Part> parts = new LinkedList<Part>();\n              Iterator<String> iter = params.getParameterNamesIterator();\n              while (iter.hasNext()) {\n                String p = iter.next();\n                String[] vals = params.getParams(p);\n                if (vals != null) {\n                  for (String v : vals) {\n                    if (this.useMultiPartPost || isMultipart) {\n                      parts.add(new StringPart(p, v, \"UTF-8\"));\n                    } else {\n                      post.addParameter(p, v);\n                    }\n                  }\n                }\n              }\n\n              if (isMultipart) {\n                int i = 0;\n                for (ContentStream content : streams) {\n                  final ContentStream c = content;\n\n                  String charSet = null;\n                  PartSource source = new PartSource() {\n                    @Override\n                    public long getLength() {\n                      return c.getSize();\n                    }\n                      \n                    public String getFileName() {\n                      return c.getName();\n                    }\n\n                    @Override\n                    public InputStream createInputStream() throws IOException {\n                      return c.getStream();\n                    }\n                  };\n                \n                  parts.add(new FilePart(c.getName(), source, \n                                         c.getContentType(), charSet));\n                }\n              }\n              if (parts.size() > 0) {\n                post.setRequestEntity(new MultipartRequestEntity(parts\n                    .toArray(new Part[parts.size()]), post.getParams()));\n              }\n\n              method = post;\n            }\n            // It is has one stream, it is the post body, put the params in the URL\n            else {\n              String pstr = ClientUtils.toQueryString(params, false);\n              PostMethod post = new PostMethod(url + pstr);\n\n              // Single stream as body\n              // Using a loop just to get the first one\n              final ContentStream[] contentStream = new ContentStream[1];\n              for (ContentStream content : streams) {\n                contentStream[0] = content;\n                break;\n              }\n              if (contentStream[0] instanceof RequestWriter.LazyContentStream) {\n                post.setRequestEntity(new RequestEntity() {\n                  public long getContentLength() {\n                    return -1;\n                  }\n\n                  public String getContentType() {\n                    return contentStream[0].getContentType();\n                  }\n\n                  public boolean isRepeatable() {\n                    return false;\n                  }\n\n                  public void writeRequest(OutputStream outputStream) throws IOException {\n                    ((RequestWriter.LazyContentStream) contentStream[0]).writeTo(outputStream);\n                  }\n                }\n                );\n\n              } else {\n                is = contentStream[0].getStream();\n                post.setRequestEntity(new InputStreamRequestEntity(is, contentStream[0].getContentType()));\n              }\n              method = post;\n            }\n          }\n          else {\n            throw new SolrServerException(\"Unsupported method: \"+request.getMethod() );\n          }\n        }\n        catch( NoHttpResponseException r ) {\n          // This is generally safe to retry on\n          method.releaseConnection();\n          method = null;\n          if(is != null) {\n            is.close();\n          }\n          // If out of tries then just rethrow (as normal error).\n          if( ( tries < 1 ) ) {\n            throw r;\n          }\n          //log.warn( \"Caught: \" + r + \". Retrying...\" );\n        }\n      }\n    }\n    catch( IOException ex ) {\n      throw new SolrServerException(\"error reading streams\", ex );\n    }\n\n    method.setFollowRedirects( _followRedirects );\n    method.addRequestHeader( \"User-Agent\", AGENT );\n    if( _allowCompression ) {\n      method.setRequestHeader( new Header( \"Accept-Encoding\", \"gzip,deflate\" ) );\n    }\n\n    try {\n      // Execute the method.\n      //System.out.println( \"EXECUTE:\"+method.getURI() );\n      int statusCode = _httpClient.executeMethod(method);\n\n      // Read the contents\n      String charset = \"UTF-8\";\n      if( method instanceof HttpMethodBase ) {\n        charset = ((HttpMethodBase)method).getResponseCharSet();\n      }\n      InputStream respBody = method.getResponseBodyAsStream();\n      // Jakarta Commons HTTPClient doesn't handle any\n      // compression natively.  Handle gzip or deflate\n      // here if applicable.\n      if( _allowCompression ) {\n        Header contentEncodingHeader = method.getResponseHeader( \"Content-Encoding\" );\n        if( contentEncodingHeader != null ) {\n          String contentEncoding = contentEncodingHeader.getValue();\n          if( contentEncoding.contains( \"gzip\" ) ) {\n            //log.debug( \"wrapping response in GZIPInputStream\" );\n            respBody = new GZIPInputStream( respBody );\n          }\n          else if( contentEncoding.contains( \"deflate\" ) ) {\n            //log.debug( \"wrapping response in InflaterInputStream\" );\n            respBody = new InflaterInputStream(respBody);\n          }\n        }\n        else {\n          Header contentTypeHeader = method.getResponseHeader( \"Content-Type\" );\n          if( contentTypeHeader != null ) {\n            String contentType = contentTypeHeader.getValue();\n            if( contentType != null ) {\n              if( contentType.startsWith( \"application/x-gzip-compressed\" ) ) {\n                //log.debug( \"wrapping response in GZIPInputStream\" );\n                respBody = new GZIPInputStream( respBody );\n              }\n              else if ( contentType.startsWith(\"application/x-deflate\") ) {\n                //log.debug( \"wrapping response in InflaterInputStream\" );\n                respBody = new InflaterInputStream(respBody);\n              }\n            }\n          }\n        }\n      }\n      \n      NamedList<Object> rsp = processor.processResponse(respBody, charset);\n      if (statusCode != HttpStatus.SC_OK) {\n        String reason = null;\n        try {\n          NamedList err = (NamedList)rsp.get(\"error\");\n          if(err!=null) {\n            reason = (String)err.get(\"msg\");\n            // TODO? get the trace?\n    }\n        }\n        catch(Exception ex) {}\n        if(reason == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append( method.getStatusLine().getReasonPhrase() );\n          msg.append( \"\\n\\n\" );\n          msg.append( method.getStatusText() );\n          msg.append( \"\\n\\n\" );\n          msg.append( \"request: \"+method.getURI() );\n          reason = java.net.URLDecoder.decode(msg.toString(), \"UTF-8\");\n        }\n        throw new SolrException(SolrException.ErrorCode.getErrorCode(statusCode), reason );\n      }\n      return rsp;\n    }\n    catch (HttpException e) {\n      throw new SolrServerException(getBaseURL(), e);\n    }\n    catch (IOException e) {\n      throw new SolrServerException(getBaseURL(), e);\n    }\n    finally {\n      method.releaseConnection();\n      if(is != null) {\n        is.close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"38e3b736c7ca086d61b7dbb841c905ee115490da":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","eb57e8385192a8db78b9a00d00a1425c3d1977b0"],"d8d46584d4a299aaed53fdd79f1cd77f222aee1e":["ee6a6e59a364f15fd1651db1b6ba39acbf577895"],"78a55f24d9b493c2a1cecf79f1d78279062b545b":["7b1605dda5afabdc06fd136fa0dd14ad326e3001","81aa2e433d28e073af6e9fe45ff2ba35bce42450"],"4ceb6a6c707ada1df8bde804e25c98668e699a18":["78badada2c6b767bf3df3ab958519ee29ea32b89","0dcbe407b62ce0c91dc171a4695a9f442c46ce14"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["81aa2e433d28e073af6e9fe45ff2ba35bce42450","d8d46584d4a299aaed53fdd79f1cd77f222aee1e"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","f0b9507caf22f292ac0e5e59f62db4275adf4511"],"7321b77a7bc3edfebd637ef273e9dfaa9969eba6":["eb57e8385192a8db78b9a00d00a1425c3d1977b0"],"eb57e8385192a8db78b9a00d00a1425c3d1977b0":["d8d46584d4a299aaed53fdd79f1cd77f222aee1e"],"fd92b8bcc88e969302510acf77bd6970da3994c4":["7b1605dda5afabdc06fd136fa0dd14ad326e3001","81aa2e433d28e073af6e9fe45ff2ba35bce42450"],"78badada2c6b767bf3df3ab958519ee29ea32b89":["c26f00b574427b55127e869b935845554afde1fa"],"f0b9507caf22f292ac0e5e59f62db4275adf4511":["c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0dcbe407b62ce0c91dc171a4695a9f442c46ce14":["78badada2c6b767bf3df3ab958519ee29ea32b89"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"81aa2e433d28e073af6e9fe45ff2ba35bce42450":["7b1605dda5afabdc06fd136fa0dd14ad326e3001"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7b1605dda5afabdc06fd136fa0dd14ad326e3001":["0dcbe407b62ce0c91dc171a4695a9f442c46ce14"],"ee6a6e59a364f15fd1651db1b6ba39acbf577895":["81aa2e433d28e073af6e9fe45ff2ba35bce42450"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7321b77a7bc3edfebd637ef273e9dfaa9969eba6"]},"commit2Childs":{"38e3b736c7ca086d61b7dbb841c905ee115490da":[],"d8d46584d4a299aaed53fdd79f1cd77f222aee1e":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","eb57e8385192a8db78b9a00d00a1425c3d1977b0"],"78a55f24d9b493c2a1cecf79f1d78279062b545b":[],"4ceb6a6c707ada1df8bde804e25c98668e699a18":[],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["38e3b736c7ca086d61b7dbb841c905ee115490da"],"c26f00b574427b55127e869b935845554afde1fa":["78badada2c6b767bf3df3ab958519ee29ea32b89"],"eb57e8385192a8db78b9a00d00a1425c3d1977b0":["38e3b736c7ca086d61b7dbb841c905ee115490da","7321b77a7bc3edfebd637ef273e9dfaa9969eba6"],"7321b77a7bc3edfebd637ef273e9dfaa9969eba6":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"fd92b8bcc88e969302510acf77bd6970da3994c4":[],"78badada2c6b767bf3df3ab958519ee29ea32b89":["4ceb6a6c707ada1df8bde804e25c98668e699a18","0dcbe407b62ce0c91dc171a4695a9f442c46ce14"],"f0b9507caf22f292ac0e5e59f62db4275adf4511":["c26f00b574427b55127e869b935845554afde1fa"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["f0b9507caf22f292ac0e5e59f62db4275adf4511"],"0dcbe407b62ce0c91dc171a4695a9f442c46ce14":["4ceb6a6c707ada1df8bde804e25c98668e699a18","7b1605dda5afabdc06fd136fa0dd14ad326e3001"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"81aa2e433d28e073af6e9fe45ff2ba35bce42450":["78a55f24d9b493c2a1cecf79f1d78279062b545b","9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","fd92b8bcc88e969302510acf77bd6970da3994c4","ee6a6e59a364f15fd1651db1b6ba39acbf577895"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["f0b9507caf22f292ac0e5e59f62db4275adf4511"],"7b1605dda5afabdc06fd136fa0dd14ad326e3001":["78a55f24d9b493c2a1cecf79f1d78279062b545b","fd92b8bcc88e969302510acf77bd6970da3994c4","81aa2e433d28e073af6e9fe45ff2ba35bce42450"],"ee6a6e59a364f15fd1651db1b6ba39acbf577895":["d8d46584d4a299aaed53fdd79f1cd77f222aee1e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["38e3b736c7ca086d61b7dbb841c905ee115490da","78a55f24d9b493c2a1cecf79f1d78279062b545b","4ceb6a6c707ada1df8bde804e25c98668e699a18","fd92b8bcc88e969302510acf77bd6970da3994c4","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}