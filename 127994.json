{"path":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FuzzySuggester#FuzzySuggester(Analyzer,Analyzer,int,int,int,boolean,int,boolean,int,int,boolean).mjava","commits":[{"id":"d4e0095ef720d1b8e7406847147af69f19af3ab6","date":1383131477,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FuzzySuggester#FuzzySuggester(Analyzer,Analyzer,int,int,int,boolean,int,boolean,int,int,boolean).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FuzzySuggester#FuzzySuggester(Analyzer,Analyzer,int,int,int,int,boolean,int,int,boolean).mjava","sourceNew":"  /**\n   * Creates a {@link FuzzySuggester} instance.\n   * \n   * @param indexAnalyzer Analyzer that will be used for\n   *        analyzing suggestions while building the index.\n   * @param queryAnalyzer Analyzer that will be used for\n   *        analyzing query text during lookup\n   * @param options see {@link #EXACT_FIRST}, {@link #PRESERVE_SEP}\n   * @param maxSurfaceFormsPerAnalyzedForm Maximum number of\n   *        surface forms to keep for a single analyzed form.\n   *        When there are too many surface forms we discard the\n   *        lowest weighted ones.\n   * @param maxGraphExpansions Maximum number of graph paths\n   *        to expand from the analyzed form.  Set this to -1 for\n   *        no limit.\n   * @param preservePositionIncrements Whether position holes should appear in the automaton\n   * @param maxEdits must be >= 0 and <= {@link LevenshteinAutomata#MAXIMUM_SUPPORTED_DISTANCE} .\n   * @param transpositions <code>true</code> if transpositions should be treated as a primitive \n   *        edit operation. If this is false, comparisons will implement the classic\n   *        Levenshtein algorithm.\n   * @param nonFuzzyPrefix length of common (non-fuzzy) prefix (see default {@link #DEFAULT_NON_FUZZY_PREFIX}\n   * @param minFuzzyLength minimum length of lookup key before any edits are allowed (see default {@link #DEFAULT_MIN_FUZZY_LENGTH})\n   * @param unicodeAware operate Unicode code points instead of bytes.\n   */\n  public FuzzySuggester(Analyzer indexAnalyzer, Analyzer queryAnalyzer,\n                        int options, int maxSurfaceFormsPerAnalyzedForm, int maxGraphExpansions,\n                        boolean preservePositionIncrements, int maxEdits, boolean transpositions,\n                        int nonFuzzyPrefix, int minFuzzyLength, boolean unicodeAware) {\n    super(indexAnalyzer, queryAnalyzer, options, maxSurfaceFormsPerAnalyzedForm, maxGraphExpansions, preservePositionIncrements);\n    if (maxEdits < 0 || maxEdits > LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE) {\n      throw new IllegalArgumentException(\"maxEdits must be between 0 and \" + LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE);\n    }\n    if (nonFuzzyPrefix < 0) {\n      throw new IllegalArgumentException(\"nonFuzzyPrefix must not be >= 0 (got \" + nonFuzzyPrefix + \")\");\n    }\n    if (minFuzzyLength < 0) {\n      throw new IllegalArgumentException(\"minFuzzyLength must not be >= 0 (got \" + minFuzzyLength + \")\");\n    }\n    \n    this.maxEdits = maxEdits;\n    this.transpositions = transpositions;\n    this.nonFuzzyPrefix = nonFuzzyPrefix;\n    this.minFuzzyLength = minFuzzyLength;\n    this.unicodeAware = unicodeAware;\n  }\n\n","sourceOld":"  /**\n   * Creates a {@link FuzzySuggester} instance.\n   * \n   * @param indexAnalyzer Analyzer that will be used for\n   *        analyzing suggestions while building the index.\n   * @param queryAnalyzer Analyzer that will be used for\n   *        analyzing query text during lookup\n   * @param options see {@link #EXACT_FIRST}, {@link #PRESERVE_SEP}\n   * @param maxSurfaceFormsPerAnalyzedForm Maximum number of\n   *        surface forms to keep for a single analyzed form.\n   *        When there are too many surface forms we discard the\n   *        lowest weighted ones.\n   * @param maxGraphExpansions Maximum number of graph paths\n   *        to expand from the analyzed form.  Set this to -1 for\n   *        no limit.\n   * @param maxEdits must be >= 0 and <= {@link LevenshteinAutomata#MAXIMUM_SUPPORTED_DISTANCE} .\n   * @param transpositions <code>true</code> if transpositions should be treated as a primitive \n   *        edit operation. If this is false, comparisons will implement the classic\n   *        Levenshtein algorithm.\n   * @param nonFuzzyPrefix length of common (non-fuzzy) prefix (see default {@link #DEFAULT_NON_FUZZY_PREFIX}\n   * @param minFuzzyLength minimum length of lookup key before any edits are allowed (see default {@link #DEFAULT_MIN_FUZZY_LENGTH})\n   * @param unicodeAware operate Unicode code points instead of bytes.\n   */\n  public FuzzySuggester(Analyzer indexAnalyzer, Analyzer queryAnalyzer,\n                        int options, int maxSurfaceFormsPerAnalyzedForm, int maxGraphExpansions,\n                        int maxEdits, boolean transpositions, int nonFuzzyPrefix,\n                        int minFuzzyLength, boolean unicodeAware) {\n    super(indexAnalyzer, queryAnalyzer, options, maxSurfaceFormsPerAnalyzedForm, maxGraphExpansions);\n    if (maxEdits < 0 || maxEdits > LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE) {\n      throw new IllegalArgumentException(\"maxEdits must be between 0 and \" + LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE);\n    }\n    if (nonFuzzyPrefix < 0) {\n      throw new IllegalArgumentException(\"nonFuzzyPrefix must not be >= 0 (got \" + nonFuzzyPrefix + \")\");\n    }\n    if (minFuzzyLength < 0) {\n      throw new IllegalArgumentException(\"minFuzzyLength must not be >= 0 (got \" + minFuzzyLength + \")\");\n    }\n    \n    this.maxEdits = maxEdits;\n    this.transpositions = transpositions;\n    this.nonFuzzyPrefix = nonFuzzyPrefix;\n    this.minFuzzyLength = minFuzzyLength;\n    this.unicodeAware = unicodeAware;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b1eb427f2c6beed80d1724555fc1db003ccf3030","date":1417137397,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FuzzySuggester#FuzzySuggester(Analyzer,Analyzer,int,int,int,boolean,int,boolean,int,int,boolean).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FuzzySuggester#FuzzySuggester(Analyzer,Analyzer,int,int,int,boolean,int,boolean,int,int,boolean).mjava","sourceNew":"  /**\n   * Creates a {@link FuzzySuggester} instance.\n   * \n   * @param indexAnalyzer Analyzer that will be used for\n   *        analyzing suggestions while building the index.\n   * @param queryAnalyzer Analyzer that will be used for\n   *        analyzing query text during lookup\n   * @param options see {@link #EXACT_FIRST}, {@link #PRESERVE_SEP}\n   * @param maxSurfaceFormsPerAnalyzedForm Maximum number of\n   *        surface forms to keep for a single analyzed form.\n   *        When there are too many surface forms we discard the\n   *        lowest weighted ones.\n   * @param maxGraphExpansions Maximum number of graph paths\n   *        to expand from the analyzed form.  Set this to -1 for\n   *        no limit.\n   * @param preservePositionIncrements Whether position holes should appear in the automaton\n   * @param maxEdits must be &gt;= 0 and &lt;= {@link LevenshteinAutomata#MAXIMUM_SUPPORTED_DISTANCE} .\n   * @param transpositions <code>true</code> if transpositions should be treated as a primitive \n   *        edit operation. If this is false, comparisons will implement the classic\n   *        Levenshtein algorithm.\n   * @param nonFuzzyPrefix length of common (non-fuzzy) prefix (see default {@link #DEFAULT_NON_FUZZY_PREFIX}\n   * @param minFuzzyLength minimum length of lookup key before any edits are allowed (see default {@link #DEFAULT_MIN_FUZZY_LENGTH})\n   * @param unicodeAware operate Unicode code points instead of bytes.\n   */\n  public FuzzySuggester(Analyzer indexAnalyzer, Analyzer queryAnalyzer,\n                        int options, int maxSurfaceFormsPerAnalyzedForm, int maxGraphExpansions,\n                        boolean preservePositionIncrements, int maxEdits, boolean transpositions,\n                        int nonFuzzyPrefix, int minFuzzyLength, boolean unicodeAware) {\n    super(indexAnalyzer, queryAnalyzer, options, maxSurfaceFormsPerAnalyzedForm, maxGraphExpansions, preservePositionIncrements);\n    if (maxEdits < 0 || maxEdits > LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE) {\n      throw new IllegalArgumentException(\"maxEdits must be between 0 and \" + LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE);\n    }\n    if (nonFuzzyPrefix < 0) {\n      throw new IllegalArgumentException(\"nonFuzzyPrefix must not be >= 0 (got \" + nonFuzzyPrefix + \")\");\n    }\n    if (minFuzzyLength < 0) {\n      throw new IllegalArgumentException(\"minFuzzyLength must not be >= 0 (got \" + minFuzzyLength + \")\");\n    }\n    \n    this.maxEdits = maxEdits;\n    this.transpositions = transpositions;\n    this.nonFuzzyPrefix = nonFuzzyPrefix;\n    this.minFuzzyLength = minFuzzyLength;\n    this.unicodeAware = unicodeAware;\n  }\n\n","sourceOld":"  /**\n   * Creates a {@link FuzzySuggester} instance.\n   * \n   * @param indexAnalyzer Analyzer that will be used for\n   *        analyzing suggestions while building the index.\n   * @param queryAnalyzer Analyzer that will be used for\n   *        analyzing query text during lookup\n   * @param options see {@link #EXACT_FIRST}, {@link #PRESERVE_SEP}\n   * @param maxSurfaceFormsPerAnalyzedForm Maximum number of\n   *        surface forms to keep for a single analyzed form.\n   *        When there are too many surface forms we discard the\n   *        lowest weighted ones.\n   * @param maxGraphExpansions Maximum number of graph paths\n   *        to expand from the analyzed form.  Set this to -1 for\n   *        no limit.\n   * @param preservePositionIncrements Whether position holes should appear in the automaton\n   * @param maxEdits must be >= 0 and <= {@link LevenshteinAutomata#MAXIMUM_SUPPORTED_DISTANCE} .\n   * @param transpositions <code>true</code> if transpositions should be treated as a primitive \n   *        edit operation. If this is false, comparisons will implement the classic\n   *        Levenshtein algorithm.\n   * @param nonFuzzyPrefix length of common (non-fuzzy) prefix (see default {@link #DEFAULT_NON_FUZZY_PREFIX}\n   * @param minFuzzyLength minimum length of lookup key before any edits are allowed (see default {@link #DEFAULT_MIN_FUZZY_LENGTH})\n   * @param unicodeAware operate Unicode code points instead of bytes.\n   */\n  public FuzzySuggester(Analyzer indexAnalyzer, Analyzer queryAnalyzer,\n                        int options, int maxSurfaceFormsPerAnalyzedForm, int maxGraphExpansions,\n                        boolean preservePositionIncrements, int maxEdits, boolean transpositions,\n                        int nonFuzzyPrefix, int minFuzzyLength, boolean unicodeAware) {\n    super(indexAnalyzer, queryAnalyzer, options, maxSurfaceFormsPerAnalyzedForm, maxGraphExpansions, preservePositionIncrements);\n    if (maxEdits < 0 || maxEdits > LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE) {\n      throw new IllegalArgumentException(\"maxEdits must be between 0 and \" + LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE);\n    }\n    if (nonFuzzyPrefix < 0) {\n      throw new IllegalArgumentException(\"nonFuzzyPrefix must not be >= 0 (got \" + nonFuzzyPrefix + \")\");\n    }\n    if (minFuzzyLength < 0) {\n      throw new IllegalArgumentException(\"minFuzzyLength must not be >= 0 (got \" + minFuzzyLength + \")\");\n    }\n    \n    this.maxEdits = maxEdits;\n    this.transpositions = transpositions;\n    this.nonFuzzyPrefix = nonFuzzyPrefix;\n    this.minFuzzyLength = minFuzzyLength;\n    this.unicodeAware = unicodeAware;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"867e3d9153fb761456b54a9dcce566e1545c5ef6","date":1444903098,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FuzzySuggester#FuzzySuggester(Directory,String,Analyzer,Analyzer,int,int,int,boolean,int,boolean,int,int,boolean).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FuzzySuggester#FuzzySuggester(Analyzer,Analyzer,int,int,int,boolean,int,boolean,int,int,boolean).mjava","sourceNew":"  /**\n   * Creates a {@link FuzzySuggester} instance.\n   * \n   * @param indexAnalyzer Analyzer that will be used for\n   *        analyzing suggestions while building the index.\n   * @param queryAnalyzer Analyzer that will be used for\n   *        analyzing query text during lookup\n   * @param options see {@link #EXACT_FIRST}, {@link #PRESERVE_SEP}\n   * @param maxSurfaceFormsPerAnalyzedForm Maximum number of\n   *        surface forms to keep for a single analyzed form.\n   *        When there are too many surface forms we discard the\n   *        lowest weighted ones.\n   * @param maxGraphExpansions Maximum number of graph paths\n   *        to expand from the analyzed form.  Set this to -1 for\n   *        no limit.\n   * @param preservePositionIncrements Whether position holes should appear in the automaton\n   * @param maxEdits must be &gt;= 0 and &lt;= {@link LevenshteinAutomata#MAXIMUM_SUPPORTED_DISTANCE} .\n   * @param transpositions <code>true</code> if transpositions should be treated as a primitive \n   *        edit operation. If this is false, comparisons will implement the classic\n   *        Levenshtein algorithm.\n   * @param nonFuzzyPrefix length of common (non-fuzzy) prefix (see default {@link #DEFAULT_NON_FUZZY_PREFIX}\n   * @param minFuzzyLength minimum length of lookup key before any edits are allowed (see default {@link #DEFAULT_MIN_FUZZY_LENGTH})\n   * @param unicodeAware operate Unicode code points instead of bytes.\n   */\n  public FuzzySuggester(Directory tempDir, String tempFileNamePrefix, Analyzer indexAnalyzer, Analyzer queryAnalyzer,\n                        int options, int maxSurfaceFormsPerAnalyzedForm, int maxGraphExpansions,\n                        boolean preservePositionIncrements, int maxEdits, boolean transpositions,\n                        int nonFuzzyPrefix, int minFuzzyLength, boolean unicodeAware) {\n    super(tempDir, tempFileNamePrefix, indexAnalyzer, queryAnalyzer, options, maxSurfaceFormsPerAnalyzedForm, maxGraphExpansions, preservePositionIncrements);\n    if (maxEdits < 0 || maxEdits > LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE) {\n      throw new IllegalArgumentException(\"maxEdits must be between 0 and \" + LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE);\n    }\n    if (nonFuzzyPrefix < 0) {\n      throw new IllegalArgumentException(\"nonFuzzyPrefix must not be >= 0 (got \" + nonFuzzyPrefix + \")\");\n    }\n    if (minFuzzyLength < 0) {\n      throw new IllegalArgumentException(\"minFuzzyLength must not be >= 0 (got \" + minFuzzyLength + \")\");\n    }\n    \n    this.maxEdits = maxEdits;\n    this.transpositions = transpositions;\n    this.nonFuzzyPrefix = nonFuzzyPrefix;\n    this.minFuzzyLength = minFuzzyLength;\n    this.unicodeAware = unicodeAware;\n  }\n\n","sourceOld":"  /**\n   * Creates a {@link FuzzySuggester} instance.\n   * \n   * @param indexAnalyzer Analyzer that will be used for\n   *        analyzing suggestions while building the index.\n   * @param queryAnalyzer Analyzer that will be used for\n   *        analyzing query text during lookup\n   * @param options see {@link #EXACT_FIRST}, {@link #PRESERVE_SEP}\n   * @param maxSurfaceFormsPerAnalyzedForm Maximum number of\n   *        surface forms to keep for a single analyzed form.\n   *        When there are too many surface forms we discard the\n   *        lowest weighted ones.\n   * @param maxGraphExpansions Maximum number of graph paths\n   *        to expand from the analyzed form.  Set this to -1 for\n   *        no limit.\n   * @param preservePositionIncrements Whether position holes should appear in the automaton\n   * @param maxEdits must be &gt;= 0 and &lt;= {@link LevenshteinAutomata#MAXIMUM_SUPPORTED_DISTANCE} .\n   * @param transpositions <code>true</code> if transpositions should be treated as a primitive \n   *        edit operation. If this is false, comparisons will implement the classic\n   *        Levenshtein algorithm.\n   * @param nonFuzzyPrefix length of common (non-fuzzy) prefix (see default {@link #DEFAULT_NON_FUZZY_PREFIX}\n   * @param minFuzzyLength minimum length of lookup key before any edits are allowed (see default {@link #DEFAULT_MIN_FUZZY_LENGTH})\n   * @param unicodeAware operate Unicode code points instead of bytes.\n   */\n  public FuzzySuggester(Analyzer indexAnalyzer, Analyzer queryAnalyzer,\n                        int options, int maxSurfaceFormsPerAnalyzedForm, int maxGraphExpansions,\n                        boolean preservePositionIncrements, int maxEdits, boolean transpositions,\n                        int nonFuzzyPrefix, int minFuzzyLength, boolean unicodeAware) {\n    super(indexAnalyzer, queryAnalyzer, options, maxSurfaceFormsPerAnalyzedForm, maxGraphExpansions, preservePositionIncrements);\n    if (maxEdits < 0 || maxEdits > LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE) {\n      throw new IllegalArgumentException(\"maxEdits must be between 0 and \" + LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE);\n    }\n    if (nonFuzzyPrefix < 0) {\n      throw new IllegalArgumentException(\"nonFuzzyPrefix must not be >= 0 (got \" + nonFuzzyPrefix + \")\");\n    }\n    if (minFuzzyLength < 0) {\n      throw new IllegalArgumentException(\"minFuzzyLength must not be >= 0 (got \" + minFuzzyLength + \")\");\n    }\n    \n    this.maxEdits = maxEdits;\n    this.transpositions = transpositions;\n    this.nonFuzzyPrefix = nonFuzzyPrefix;\n    this.minFuzzyLength = minFuzzyLength;\n    this.unicodeAware = unicodeAware;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b1eb427f2c6beed80d1724555fc1db003ccf3030":["d4e0095ef720d1b8e7406847147af69f19af3ab6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"867e3d9153fb761456b54a9dcce566e1545c5ef6":["b1eb427f2c6beed80d1724555fc1db003ccf3030"],"d4e0095ef720d1b8e7406847147af69f19af3ab6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["867e3d9153fb761456b54a9dcce566e1545c5ef6"]},"commit2Childs":{"b1eb427f2c6beed80d1724555fc1db003ccf3030":["867e3d9153fb761456b54a9dcce566e1545c5ef6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d4e0095ef720d1b8e7406847147af69f19af3ab6"],"d4e0095ef720d1b8e7406847147af69f19af3ab6":["b1eb427f2c6beed80d1724555fc1db003ccf3030"],"867e3d9153fb761456b54a9dcce566e1545c5ef6":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}